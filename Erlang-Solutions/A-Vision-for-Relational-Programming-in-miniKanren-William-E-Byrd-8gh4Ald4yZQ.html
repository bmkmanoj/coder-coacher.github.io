<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Vision for Relational Programming in miniKanren - William E. Byrd | Coder Coacher - Coaching Coders</title><meta content="A Vision for Relational Programming in miniKanren - William E. Byrd - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Vision for Relational Programming in miniKanren - William E. Byrd</b></h2><h5 class="post__date">2015-11-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8gh4Ald4yZQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello can anyone hear me the mic on
everything good to go
Thank You bootle and thank you for
having me here all right uh I had a
totally different talk planned and then
Phil's talk was really cool and then I
was like oh I'll do something with
lambda calculus and Minnie Cameron and
then I was talking to people last night
and basically Andrea and Mark and and
Stefan a few other people convinced me
to try something like much more radical
than I normally do with my life coding
so I want you all to be doing live
coding at least anyone who's interested
so if you can get out your lap ease and
go to this URL and that's that holds
doubly true for anyone watching on video
this is specially designed so that
people in the audience and people on
video can kind of follow it all along
and basically what I'm gonna do is I'm
gonna check in the code as I'm talking
and I'll let you know when I did a
check-in so you can do a poll so you can
sync up with me and there's a really
cool web-based version of Mini Cameron
that David Khan created and you can just
paste that code into the web browser and
you should be I'll run Mini Cameron okay
so we'll try that and it might crash and
burn we'll just see how it goes but the
great thing is if someone's watching a
video afterwards they should be all
follow along and stop and if anyone here
is confused about something you can't
get an example to run or whatever you
can ask a question okay or you can take
it offline whatever but there's one
thing to show this stuff but at some
point people will have all these
questions and if you can't really play
with it you you don't really get the
sense I think of what it's about so I
want everyone to be able try it okay so
so the web browser version Mini Cameron
is at this link right here the veneer
stuff okay all right so here's my repo
and I've got a file called talked at SEM
and that's where I'm gonna have my code
in it and the way I'm going to do this
is I'm going to basically type into the
code into Emacs and then I'll paste it
into veneer and that's basically what
you all can do in terms of opening up
the file and get
pacing into the near running it and you
can edit it in your own text editor you
can edit in the venire and I encourage
you to try some different combinations
or different queries and see if you can
break it see if you can run in infinite
loops which you probably can and so
forth and if you have a cool example you
can share it this is by the way like
version 0.01 of the technology I would
really like forgiving interactive talks
where you know either super Emacs mode
or a web browser or something like that
or people in the audience really could
could do this more seamlessly but that's
tech I'm working on with other people
like Michael Valentine all right so
let's talk about Mini Cameron and I'm
gonna bring up the venire editor refresh
if venire ever gets in a bad state you
can just click refresh
let's see you sir
I can make I can kind of make the font
bigger the way you use veneer is if
you've got code on the left hand side
you click the Run button
you know it'll evaluate this code and
there's like a little read eval print
loop thing you can just type for small
expressions if you want to try those and
this is a relational schema interpreter
which will we'll play around with
something like that in a minute
the main button your current care about
is this create file button so if you
create file just gonna blank whatever's
on the left and you can just type in
code here I'm gonna Cameron code and
then click run and it'll be evaluated on
the right hand side so let's just try
something simple so I said I'll go to
Emacs but well let me try doing in the
venire first of all is the font and big
enough can people see that I can try to
pump it up a little bit if the Run
button will cooperate maybe I can there
we go
that run buttons oversize okay so the
first thing I'm going to show you so
Mini Cameron core mini Cameron only has
three operators it's a very small
language just like lambda calculus is
very small right lambda calculus has
there's three three parts and so does
Mini Cameron for the core parts of
language and you could extend it just
like you can extend lemmy mini cannon
guessing like scheme right so the the
most fundamental operator in Mini
Cameron and Minich Enron's a type of
logic programming language like Prolog
it's got some real differences though
the fundamental operator is something
called unification unification you can
think of as sort of like a 2-way super
pattern matcher so if you're familiar
with pattern matching then in a pattern
match you have some value your power of
a pattern matching against and then
you've got some sort of pattern right
and in the pattern you can have
variables when call those match
variables or pattern variables okay and
those pattern variables get values
filled in from the value your matching
is similar with unification except you
can have essentially pattern very
pattern variables on each side okay so
you can have variables on both sides and
the variables don't actually ever have
to be filled in and that's fine also
variables don't ever have to get values
in this in this paradigm so here we're
going to do something simple and you can
also think of unification we call it
equal equal here really as it's like a
type of equality operator also so here
we're asking whether or not five is
equal to five or another way to look at
it is we're asserting that five must be
equal to five and if it's not equal to
five then we've reached inconsistent
conclusion basically so is five equal to
five one would hope okay yeah the logic
isn't that weird so let's run it and you
could see copy the expression and the
answer is yes well that's good that
makes me happy
all right okay so I promised I would it
would do the interactive thing so here's
our first program equal equal five five
and I will check
okay so oh yeah are you supposed to like
how do you do this thing you do like a
git add or something get upload add dot
oh okay
and I'm not really good at get so and
then get commit is that he do it
oh yeah they do it okay so get come in
and I have to give a message and I'll
say one is the message because that's
the first one okay
alright so you're following along that's
the first go so so you can do a pull and
you can paste that complicated program
into veneer let's all do it make sure we
get the tech working and then click run
and you should be able to see yes okay
that's the first program great okay yes
yeah okay all right I like this I'm
learning okay so so we can we can do
another program let's do a variant this
is program number two what about six and
five no that's right computer says no
alright so the proof of it okay what is
it will hold on let me check in my code
I promised okay I guess I could I could
like look I only get keeps track of
revisions so I'm not even going to add
another expression I'm just gonna like
do that and then it works alright so I
could do get was it get commit - a woo -
a and then - right do a pull okay so
what so what's your question but you
want to know about the proof why is 5
equal to 5 well let me change it up a
little bit and maybe I'll answer your
question I'm gonna put in something else
instead of a number so having two
numbers I'm gonna put in X and X is a
logic variable so you can think of it
sort of like this pattern variable right
okay so so is X equal to 5
yes we don't know yet okay we don't know
is it it could be if X doesn't have a
value yet then now it does have a value
right the answer is yes and X is five
but X if X is already six then the
answer's no all right so we don't really
know but but I'll say that X is starting
out fresh we say fresh it doesn't have a
value yet so let's run that yes and
Beyond yes we see that X has a value
associated with it five okay all right
cool yeah what what in that work oh I
didn't save oh you're right that's hard
okay all right so so that's one thing we
can do all right
and so if you look at it this way then
basically what we're really saying is an
assertion we're saying that the thing on
the left is syntactically equal to the
thing on the right as long as you can
find some some set of values to assign
to these variables inside the terms that
will make them syntactically equal right
so so the the question is is there any
possible assignment for X that will make
the left and right hand side equal and
the answer is yes as long as X is five
then they'll be equal okay so that's
that's the sort of reasoning you do with
unification and we can even put
variables on both sides x and y so what
should the answer be here yes and
furthermore what else what else do we
know we know that Y is five well let's
say we got rid of the original program
right this is the whole program now so
there's no 5s any more x and y are the
same presumably and so so we can see
here that x and y are both associated
with some value and this itself is a
representation of a logic variable that
doesn't have a value and you can see
that they have the same number if they
were different you'd see a one here than
one of them and a zero on the other so
it's telling us that really is the same
the same logic variable okay
I'm gonna get the hang of this soon so
it's it's basically a syntactic
definition yeah so so you could define
it recursively like over a tree okay so
that's the big operator and of course we
can have more complicated data
structures so we could do you know I
think veneer has this let's see if the
near has a list yeah so veneer has list
in it so we're creating a list
containing accent list contain why and
because they had the same structure
that's fine also okay but if we had say
list x and y well what would happen in
this case I think I was succeeds I got a
fail it's gonna be yes and notice we
have the same logic variable here for
the X but now Y wraps a list around it
okay yes certainly as a good question
internally there is a substitution
questions about why or why aren't we
using substitution internally there is a
substitution and this is actually the
representation of the substitution okay
we're seeing as the output the
representation of substitution all right
here's one more list X and X what's the
value there yes no what should get
printed out as infinite treat
no we're not allowed to have a term
unified with a term but with a structure
containing that term okay and this is
this gets to what Phil was talking about
where you can have these infinite
structures and you run into trouble with
that so we're doing what's called the
occur check we're checking to see if X
occurs in the structure and if so we're
going to say no no answer we fail okay
and that's important this is how we get
soundness if we don't have that we can
improve all sorts of things that aren't
true and get in trouble okay so that's
the unification that's the main operator
what else do we have well we have the
ability yes question you couldn't get to
fail and we're in one term so ah I see
okay
good question good point so so so I
think what Rob is saying is if you if
you do send like this and then you have
another equal and we're saying six and X
right then you think that's inconsistent
information but we're still getting a
yes that X is six so let me go ahead and
show you how we can sequence things so
what veneer is doing is its assuming
these are two separate programs that's
ignoring the first essentially and just
giving us the answer from the second
that's a good point
so let me show you the second operator
of mini-camera
which is called fresh and what fresh
allows you to do is a conjunction okay
so now we have a conjunction of goals
like that and I can run that and now my
answer is no okay
so fresh acts as a conjunction fresh has
one other purpose fresh also lets me
introduce new logic variables now the
way veneer works which is a little
different from standard mini cannon
veneer acts more like Prolog and these
variables that that are that aren't
defined lexically those become new logic
variables so you need to use fresh
lesson veneer than you do in standard
mini camera but if we add a Y there that
will allow us to create a locally
defined logic variable has no value
called Y okay so that's the fresh form
alright that's a pretty complicated
programs
better I better add that and okay all
right good
so you've seen two-thirds of the
language now fresh and equal equal and
then I'll show you the last part less
parts conde and this is something allows
us to get more than one answer back
yeah because it'd be kind of boring if
we could our programs could only return
one answer and one of the points of
logic programming is that we can return
potentially infinitely many answers so
the way we're gonna do that and and you
know Minnie can rinse in tactically
looks a lot like scheme because it's the
original implementation with scheme so
condi is based on lisps cond operator
which is a conditional operator sort of
sort of like a big giant type of gif or
pattern it's sort of like a pattern
matching syntax but it doesn't have a
pattern matcher built-in to explicitly
so we're gonna have a cond here sorry
Conde de stands for every answer and the
syntax for a condi is that for each
clause each condi Clause has set of
parentheses and then it takes one or
more of these sub expressions these
other many counter expressions which are
called goals
okay so equal equal 5x as a goal I'll
pop that in there and equal 6x as a goal
I'll pop that in the second case okay
and alright so what's gonna happen here
well the idea is that we're trying each
of these two clauses independently we're
gonna try one of the two clauses and
it's unspecified in mini cannon which
one we try first let's say we try the
second one first so we would try
unifying X with 6x we get we get a yes X
would be associated with six and then we
could ask for another answer and we
asked for another answer it says if we
had never tried this one we try the
other one and now we forget this
association between X and 6x is
refreshed magically and we're gonna try
it again
and now X will be five so as it gives us
a chance to try different branches of a
program so it's similar to like an if
except and if where you can
independently try all the possibilities
all you know though
tests and the consequence and so forth
independently Conde is like a
disjunction and fresh is like a con job
if condÃ© is disjunction fresh is
conjunction that's right okay and
there's a simplified version in Mini
Cameron called micro Cameron where
conjunction and disjunction binary
versions of those are the primitive
operators so those are much closer to
logic this is closer to two maybe a
nicer syntax to program with for real
programs but if you want to see the more
primitive stuff this closer to logic
look at micro Cameron and that has a
very short implementation the
implementation of micro Cameron saying
like 46 lines of scheme code for all the
logic programming system so so we can
try running this and we get the first
answer so we try the first one first
clause in this version minute Cameron
and we can click on more answers and hey
now we've tried the other clause where X
is 6 so we're not inconsistent because
we're trying to clauses totally
independently of each other and we could
ask for more answers and finally we say
no no more answers that's it okay and if
you've ever used Prolog this part is
very similar all right and that's the
entire language the entire core language
there are basically three other
operators that we might ran into but
that's the basis of it okay
any questions who's playing along by the
way I'm just curious how many people oh
well it's pretty good alright so now
let's try something more complicated all
right all right keep myself honest
check check myself in alright and our
programs are gonna become more
complicated here so the check-in thing
will be a little whoops oh I check that
in this 500 here so I hacked I'll put in
a space and check it in a 6
yes I need to work on my get skills
that's fine
oh I need to push yeah thank you yeah my
dream tool would have me not have to do
this step all right okay so let's try
something a little more interesting so
Phil was talking about lambda calculus
yesterday and he showed that there are
three basically parts of lambda calculus
so you have variables you have lambda
terms themselves or which are called
abstraction and lambda calculus and then
you have application you know applying
something saying else so so we have
these three things and you know if I
write down comments hopefully veneer
will check on this so we have you know
something like X is a variable and then
we have something like I'm gonna write
it in sir like a scheme leeway like
lambda XY okay so that's that's an
abstraction ABS and and then you have
something like an application so we're
we're applying you know you know F to G
or something like that okay so that's an
application so those are the three
syntactic forms that we have in the
lambda calculus so let's try just
writing something in mini cannon that
will actually you know recognize a valid
lambda calculus term syntactically okay
so let's just try doing that so how
should we do that well we're gonna
define a function so this part is pretty
much like scheme let's try to find a
function and so let's look let's call
this I don't know
lambda calculus syntax sin LC sin okay
and because we're in a scheme ly
language we're going to ourselves define
this function using lambda and we're
gonna give it some some arguments so
I'll say we're taking well under a term
lambda calculus term okay and and
now what we want to do is basically
match against the three possible terms
so which which form do you think I
should write here next or whatcha mini
Cameron operator handi found me because
I have choices to make right so we have
condÃ© and how many clauses am I gonna
have for this kanji three okay that's
right
so I go ahead write down my clauses to
begin with alright and now what I'm
going to do is for each of my syntactic
forms I'm going to write down a clause
for that okay so let's start with I
don't know the the application term all
right let's do the lambda term actually
okay so what what am I going to write
what sort of mini Cameron expression am
I going to write in that clause to match
against the lambda or at Conde on a
right fresh gonna write equal what are
used for pattern matching basically
equal right that's sort of like the two
way super pattern matcher
so let me write an equi quill expression
unification expression and what am I
gonna unify I need two terms two value
so I'll unify what term okay the term
that came in that's right and I'm gonna
unify that with well something that
looks like my lambda expression right at
the right saying down something that
syntactically looks like it okay so what
I'm going to do is I just copy this
thing alright and
ninja it a little bit oh look at that
huh yeah okay alright so so that's
that's kind of what my expression looks
like now there are a couple things here
so so I've got like X is a variable and
you know this thing in the middle is
really like the body expression or e you
know T some other term okay so we got we
got a variable and we got some term here
and to make this scheme Li we need to
make this not a lambda expression in
mini cannon or scheme in the host
language we need to make this a data
structure we can literally pattern match
against so we're gonna create a list and
the one way to do this in scheme was
with this backtick no operator I'm
called quasi quote and it's sort of like
a string interpolation style thing if
you're familiar with that basically if
we put a comma in front of
sub-expressions that means that that
these things here are going to be
literally filled in there like holes to
be filled in with whether the values of
X and T are at that time and we need to
have some X's and T's here so what I'm
going to do is I'm going to create a
fresh so I can have two new variables
for X and T yes I'm creating two new
logic variables I'm gonna grab that
and I might have to drag this even more
all right there we go perfect okay so
when we're when we're rating these sorts
of programs it's good to try to test
them sort of incrementally so what I'm
gonna do is I'm gonna temporarily
comment out the the first and the third
clause with the comments and scheme and
I gotta just try running this thing to
see if it works because I'm not sure if
it will cuz I don't use veneer normally
so let's see if it works
hache t ah cool okay because we didn't
actually call it so so we can actually
make a call to LC sin now let's try
calling LC sin and let's give it a term
so let's give it you know the term
lambda Zed Zed and see if that succeeds
and it says yes it does succeed so this
means that this is syntactically valid
great okay so let me check that in here
so here's our first version of it and
version seven okay all right and you
know notice I could just test it one
line at time right so let's do the
application line now okay so so here
we're gonna have an application once
again I'm going to want to have a fresh
to introduce some logic variables I'll
say e1 and e2 and the syntax of an
application is that we have term V one
apply to eternity - okay so that's what
that looks like
No
go ahead and check that
all right so 2/3 of the way done and I
could test that also but I've got some
confidence in it
so let's now do the last one which is
the variable X or some some variable
sums and we're going to represent a
variable as a symbol and scheme a scheme
symbol and so so we've added to sort of
the core logical foundations of Mini
Cameron a few constraints that make it
easier for writing things like
interpreters and type inference ORS and
type checkers and you know grammar based
programs and one of the constraints we
have is called symbol Oh
symbolic so if the term is a symbol then
we say hey that's a variable that's
syntactically legal
okay so sambhal oh is is the last way we
can represent you know we're not
actually saying we don't care if it's ax
or Y or whatever right but we care this
is someone so let's see if that runs yes
okay cool and we can try if we want you
know some other tests so we could say
well you know actually maybe it's you
know lambda you know said and Zed
applied to two Zed or something like
that
okay so we got an application we have
their variable reference and and we have
a lambda so let's see if that's
syntactically valid yes that's
syntactically valid okay all right so
we've implemented our grammar and we've
got all that stuff working and let me
check that in and this is check in
number nine all right cool now okay
that's kind of cool that we can write
that but would be more cool is if we can
use those logic variables we've been
using other places if we can actually
use that inside of our call to LC sin so
right now we're having to give a fully
ground or fully specified lambda
calculus term and we're checking we're
verifying validating that term make sure
it's syntactically legal but it'd be
really cool if we could instead put in a
logic variable
and say generate a valid lambda term so
let's try that I'm gonna get rid of that
term and I'm going to put in my term or
no I was caught cute for queer very well
okay so now I've got this query variable
in place of the call and let's try doing
a run now and so the first answer is yes
so we're getting back this underscore
zero thing bound to Q that's if you
remember that's a representation of our
fresh logic variable and we have the
side condition the side condition is
saying that that underscore is zero
thing has to be a symbol so it has to be
a you know if you were ever to
instantiate it to a ground value it'd
have to be a legal scheme symbol and
scheme symbols are however representing
variables so what this saying is that
any symbol that's fine that's just a
lambda calculus variable okay so that's
that's actually representing infinitely
many concrete values and philemon a
ground symbols now let's see if we can
get another answer okay here we're
saying ah if we have a lambda term and
it has the right structure has
parentheses in something that's fine and
if it has something else in the back and
it could be different that's fine
that's not very constrained but okay
that's fine as far as it goes what about
this underscore zero thing what should
that be syntactically for this to be
legal should be a symbol okay so so
maybe we're a little sloppy let's go
back and so we can add a side condition
maybe okay so what else can I write here
to kind of lock it down a little more so
I can use symbaloo X okay and symbolic T
so do we know if T is actually a symbol
that's a good question what is T it's an
arbitrary limit calculus expression so
what do we need to write here LLC sin
yeah we need recursion LLC sin on T so
that was part of the problem we weren't
recurring properly anything else you see
that's wrong and those along the similar
vein anywhere else where we were sloppy
application right we've got these e1 and
e2 things we're not putting any
structure on those those actually have
to be lambda calculus terms themselves
so we need to recur ok sim only one ok
so I'll see sim on the - alright so
hopefully that will work
I'll see you sin okay sit good thank you
ah okay cool so in
all right so this is check-in number 10
all right so if I run that let's see so
we have the symbol answer like we had
before okay so this looks better so now
when I get a second answer that I'm
generating it's like okay well it still
has that same structure we saw before
but now we have some side conditions
we're saying underscore zero has to be a
symbol and here we're saying the body is
a symbol in that case so so this and
they could potentially be separate
symbols but they could be the same
symbol that's what having the underscore
0 and M score 1 mean so this could be
lambdas that Zed or it could be lambdas
@w or something like that those would
both be legal and I can ask for more so
here's an application where you have a
symbol applied to assemble okay and I
can keep generating more of these so
here's Nessa here's a lambda whose body
is another lambda right so now I can
generate these and I can enumerate every
possible lambda calculus terms and
tactically right okay so so that's
that's basically the cool idea about
pure logic programming and mini-camera
is really a language for pure logic
programming where the idea is you can
just write down mathematical
specification something like that and
have something close to the math and
then once you have that you can just use
the same code not just to check that
something's correct but also to generate
answers all right so let's let's do this
okay so if you what I'm going to do is
I'm gonna refresh venire just refresh
the browser make sure it's not in a
goofy state and you can see up top there
are some different programs let's let's
see if I try type inference okay so if I
go to type inference you can see that
we've got this this mini mini can run
definition called bang / 0-0 or
something okay well this supposed to
look like is a turnstile operator in
logic it's supposed to look like one of
those special symbols that you know you
saw and
phil's presentation so this is going to
be a type inference err and if you've
ever used a language like ml for example
you know what type inference is you can
write down an expression and the type
inference or we'll try to figure out
what the type of that expression is so
so here we have three moving parts we
have the expression that we're going to
type type in for we have gamma which is
like a type environment it allows us to
accumulate information about the sub
parts of the expressions what those
types are and then type is the type of
that of that expression all right and
you could see actually already what some
of the similarities are so symbolic
spurt
this is the symbol case this is our
variable case right and in this case
instead of just saying well that's
that's it does you have a symbol now
we're gonna look up in the type
environment what that symbol is what the
type of that symbol is because hopefully
this is not this is not a free variable
this is a bound variable and we might
know that that variable for example is
bound to an int has type int okay and
there's some other cases like for
example is the expression coming in a
number so number o is another constraint
and if so we're gonna say the type of
that sub expression is int yeah that's
our end type so v would have type in if
it's a boolean like hash and scheme it's
gonna have type bool and so forth and
then we're also going to have some more
sophisticated rules for lambda okay and
if you look at if you look at the lambda
rule closely and if you look at the the
math that phil put offers in his paper
you'll notice that that these rules
essentially are the same okay so this is
what he was talking about the curry
Howard isomorphism and that basically we
have a little theorem prover here in the
form of a type inference err and
similarly we have application rule and
we also have a special version of let we
have things like addition and so forth
okay so let's let's just try doing
saying that says type inference or so
here's here's an expression that that
comes with but let's let's try something
simpler so let's try
calling or type in printer and we have
to give it an initial type environment
and we're gonna say that that initial
type environment is empty and now we
have to give it some expression I don't
know what the expression is going to be
and then it's gonna have some type and
it will just write Q for the query
variable for the type okay so what's an
expression that we might want to type
check well let's do something simple
like five I'm putting a quote here by
the way to make sure that that whatever
expression is here isn't evaluated at
the host level at the scheme level but
it's actually an valuated you looked at
that term has looked at in the type in
itself so what should the type be here
which type of QB should be an INT yeah
so that that worked it's an it okay and
I can do something like plus right so
plus three four what should the type of
that be that should be int okay sure
enough we got an int what about plus
hash f4 what to the type of that be
computer says no all right and we can
also look at things like a lambda
expression what about lambda X X which
is the type of that beam well should be
equivalent to some sort of function type
right so yeah so we're gonna have
something like a arrow a and you can see
that we have a fresh logic variable
arrow fresh logic variable so the thing
on the left is the input type for the
function the thing on the right stay out
put type the underscore zero means that
this is a fresh variable means it could
be anything but the input in Yelp would
have to be the same because it's the
identity function okay so this is a very
general answer all right and we could
try doing an application we could try
doing something like applying that
lambda term to the value of plus three
four and now what type should we get
back sure you're back in it
okay cool all right so that all works so
this is a working type inference err and
for the most part we just kind of wrote
down the rules
the math you know you could take take
the rules Phil showed and essentially
type those in now where it gets more
interesting is and this is where the
curry Howard part really becomes way
more interesting to me is that we can
say because we're in a logic programming
domain we can say that the type is going
to be int and that we don't know what
the input program is all right so now
we're going from type inference to type
habitation or inhabitation we're trying
to find a term than habbits this type
okay so what would be a simple term that
would have the type in zero okay sure
well zero is a little specific of an
answer we get back a more general answer
that includes zero we're getting back
some fresh logic variable with the side
condition that has to be a number okay
so that's a zero but it's also 42 okay
so a good question are we supporting
integers floating points so forth right
now in this one we're only supporting
positive integers actually probably
negative integers I don't know this one
yeah I think this one works with
negative integers too but well we could
try that see what the type of negative 5
is but I think this is only hailing
integers but we could add other
constraints that would handle other
other numeric types oh okay it doesn't
like negative 5 I guess so I guess some
I guess number oh and this
implementation only handles positive or
non-negative integers but you could add
more things in fact when I worked on
with Eric Hulk and clear Elvis on this
this language called Harlan the original
version of Harlan is sort of like a
scheme Lee language but for GPU
programming but it it was had like an ml
style type system and the original type
type inference or for that was written
in Mini Cameron and Orsi Cameron and we
had to extend these operators to handle
different types of numbers so you can do
that you just have to add other
constraints okay so what else can we do
here let's or what other sorts of things
should we get back other than just a
literal number well let's see what
camera says so here we have a let so
we're saying let some variable which is
a symbol which has some number value it
doesn't matter what it is because we're
ignoring it and the body of the let is
some other number
okay well that's true that as type in
and it's well typed it's the type checks
right and here's another one
so here we're saying let's um some
variable it's a symbol B hash F we're
ignoring that we're returning the body
which is underscore one and that has to
be a number and so we could play these
games and at some point okay so now we
get an addition of two two numbers and
here now we start keying in applications
so we're getting a lambda term lambda
expression and it's being applied to
something so let's make sure the types
work so we're passing in a number that's
our constraint and here we have some
symbol and we're ignoring what's passed
in and we're returning some other
potentially different number so you can
play these games all day and the yes you
get keep clicking more answers for as
long as you want all right I'm gonna
refresh one more time and I'm going to
show you something is a little more a
little more fancy but by the way that
you know that type inference stuff or
the type inhabitation that is the thing
that many of the modern proof assistants
work on okay I'm gonna be Dijkstra in
two minutes but I'm going to go ahead
and show you very quickly what you can
do with a relational interpreter so here
we have an interpreter for a significant
subset of scheme it's basically or
extended lambda calculus if you want to
look at it that way
and so we have this Val Expo thing and
so we can evaluate an expression and I
think we have sign yeah Val Expo and let
me just show you one query - Val Expo
and hopefully this will work so we're
going to call Val Expo and if Val Expo
takes sort of like the type inference or
is going to take an expression and an
environment and in an output so we're
gonna say we've got some expression we
don't know we're gonna start in the
empty
and we want to see if we can create some
expression find some expression that in
the empty environment evaluates to
itself well let's see if we can do that
whoa what is that thing well that's kind
of weird okay so we got this
weird-looking thing and let me just go
to Emacs and start up scheme try to type
that in format it in a way it's a little
easier to understand I try running that
oh wow I got back the same thing so
that's called a Quine that's a program
that evaluates to itself and by the way
if you look at here's the my last
comment that will make this historical
if you look at the micro Kant or sorry
the Micro manual for for Lisp by John
McCarthy he says is a difficult
mathematical type challenge exercise
right here find the list e such that the
value of e is equal to e and that's what
we just did by typing in the roles for
scheme and letting mini-camera do its
trick so I hope you'll have fun playing
with it and if you have any questions
I'm happy to answer
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>