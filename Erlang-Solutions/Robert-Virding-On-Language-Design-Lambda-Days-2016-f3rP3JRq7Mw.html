<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Robert Virding - On Language Design (Lambda Days 2016) | Coder Coacher - Coaching Coders</title><meta content="Robert Virding - On Language Design (Lambda Days 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Robert Virding - On Language Design (Lambda Days 2016)</b></h2><h5 class="post__date">2016-04-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/f3rP3JRq7Mw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm the one who fixed the bugs by the
way the other bit Mike and Joe were just
talking I fix
actual bug anyway this is some thoughts
ideas I have on language design I if you
call or philosophy not I don't know
beware these are my ideas so I come from
outlying solutions but these these are
my ideas and a lot of these things on
languages they also apply to libraries
and systems as well how to work these
things out so this is based on my
experience of developing languages well
as what I say here is three different
levels one you got say along the base
level is what LFE if anyone's here Nick
tomorrow afternoon I'm talking a bit
about that as well which is adapting a
language and implementing well lower and
Prolog on top of our language is making
new languages it's also based on a lot
of the language a lot of languages I've
used to our Father I've used a lot of
languages I think about 11 or 12 in that
list and some of them are groups of them
I don't know how you want to class
assemblers but I've used about three or
four different assemblers and I'm not
saying I'm uncommon here I think that's
pretty common but amongst most
programmers that they actually have used
a lot of languages well they should have
at least anyway right so just a few
points I think it's a very basic point
here is that don't be nice to users okay
okay this is this does sound very grim
but I think it's very important base
when you're working with language when
you're developing systems don't be nice
to users or to be slightly more more
exact when be very careful when you're
adding changes suggested by users okay
be very careful when you're doing that
then there are a number of reasons for
this one is very basic one is that they
often don't see the whole picture of
what their change will do if you have a
language where you have a system making
a v' for them very simple change can
affect very many other things indirectly
caused a lot of problems and a lot of
strange behavior going on and often as I
say they will not have the whole picture
and see what the actual effect of this
changes are another more slightly
cynical perhaps is they often don't
really know what they need sorry
if anyone's come with these change but I
don't think they are especially if you
worked as a consultant you'll find out
that they often don't really know what
they need and often they will help they
want help with a solution and not
solving the problem so they have a
problem they've come up with a solution
and then they find that your language or
your system does not provide the
primitives for that solution so they
want help with the solution and not with
the solving of the problem right so
that's why I say you should be very
careful about making changes suggested
by users okay and here is the necessary
animal picture in my presentation this
is the only there's only two pictures
this is one of them and this is the no
cat right so when they come with a
change they know and they say no again
and eventually they'll go away and fix
it anyway and they'll work around it and
make it better solution to what they
want to walk maybe actually they might
be worthwhile do something so just a tip
I think the basic thing to be aware of
when you're working with languages is
what is the problem okay I can make a
comment here this is a very engineering
point of view the language consistent
development okay we are out to solve a
problem we're not out to make a language
or a system with a specific set of
properties as such so I know I'm we're
talking a functional language conference
here but we're not out to develop a
functional language we're out to make a
language that solves a problem so it's
very much engineering so what is the
problem what is the problem you're
trying to solve or actually what is the
real problem and that is not definitely
not the same thing so I'll be taking a
few examples from our line here from our
airline developments but this is
definitely not now like presentation is
that so from our point of view the
problem will try
to solve was telecoms okay telecoms type
applications making your phone ring from
telling the switch to make a phone ring
and that was trivial extended to send
the switch to commands the phone starts
ringing that wasn't the problem you
could stretch a bit and say yes we want
to make a call that's slightly more
difficult but you have a sequence of
events and that will make the call go
they'll they'll wrap the call and they
can call be indifferent they can talk to
each other and everyone's happy right
but that wasn't the real problem and if
you look at description the problem
domain telecoms just does not come into
it so the real problem was things like
you have timing constraints things must
take a certain amount of time way or
happen within a certain time where at a
certain time you have concurrency you
have a lot of these things going on at
the same time and they must all
everything going on there must obey all
these timing constraints you have the
fault tolerance the system must never go
down if you accept errors they have to
crash we have to be update on the fly
all these type of things they were the
actual problem not making the phone ring
the phone ring was a simple bit about it
so this is what I'm saying is what is
the real problem you're trying to solve
in your language or your system right so
yeah another question of course is why
why you're implementing the language why
not just use an existing one hopefully
because well your solution is better for
doing this type of that work than other
other solutions are seeing I like
implementing languages also implementing
language for fun is a perfectly good
reason to implement a language it's
perfectly acceptable to that and you
should decide here what is the real
problem you're trying to solve and focus
on that do not lose focus keep focusing
what is the problem you are trying to
solve that is what you're developing
your language or your system for if you
start wandering you'll just end up with
a right mess because you'll have lots of
things coming in from other places
you'll get all of all the things I'm
saying you shouldn't do here you'll end
up doing if you lose focus for
yeah and okay I'd say the basic point
here I'm a big fan of simplicity keep it
simple keep the basic simple what do I
mean keep it simple here things should
be simple that you have a small number
of basic principles a small simple set
of basic principles and when you get
these right you'll be able to build
anything you need on top of these basic
principles okay you will not need to go
in add extra things in your basics for
it and then the language will be
powerful and and also will be easy to
understand what's going on because you
have this very small set of basic
principles you can point to things that
it works like this because you can point
that principle that this is why it's
doing this right so in this sense small
is good we managed this for a line so
the concurrency model there are three or
four different principles depending on
how you want to count them that are the
basics the whole concurrency model the
same thing with error handling model
there are three or four principles again
depending how you want to count them the
basic of the whole error handling
mechanism the fault for building
fault-tolerant systems and everything
works on top of these principles okay so
you can do it and it's very important to
do it and complexity at this level never
wins if you have a very complex based
system you're everything you build on
top is going to be complex and difficult
to understand because of the complexity
you have at the last level so keep the
language simple right
and yeah you might not get in all the
cool features or this year's cool
features into your language but it will
be easy to understand and you can also
began you also be sure that this year's
cool features are very uncool next year
anyway so have to put a new set of cool
features to just keep on going so keep
them out or keep the whole thing very
simple right unfortunately well how many
buttons all got down now there we go
yeah a simplicity is it's fantastic but
it is difficult it takes work to find
out these basic simple principles on
which to build everything else for it
it's not easy to do it right this is
jigsaws comment for one
had to cover of comments on this and
it's a great rich but it requires hard
work to achieve it and also requires
some education to appreciate it okay if
these our basic principles an outline
did not just fall out quiz step one
afternoon said what are we gonna do yeah
we'll do this problem it came out from a
lot of work in experimenting doing
things and working out with these set of
simple principles we could do everything
else on top of it we didn't need more
stuff in there right also as he points
out here complexity sells better if you
if your mates sat down for a year or two
working out a system you present a very
simple basic support people might feel
that this is a total waste of time
why have you done all this is so simple
I can say what one one one way of
working out that whether your principal
are correct is theirs when you look at
them or someone looks at them they'll
say yeah this is self-evident
of course you'll do it like this how
could you do it any other way right then
you know you you hit the hit the point
right that also leads me on to the next
point here is that in your language and
in your system you should provide tools
for building things not solutions again
you want the tools for building things
either your basic principles are tools
for building systems on top you don't
want to put too much loose ninjin
solutions into your language that
expands it makes it big suddenly you get
a lot of complexity in there and you get
a lot of very strange interactions as
well the problem is if you put solutions
in there they either tend to be very
specific solutions or very general
solutions if they're specific solutions
then you're going to end up having a lot
of specific solutions because you make
one specific solution that someone comes
along and says this doesn't work for me
so put another specific solution in etc
and you suddenly end up with a lot of
specific solutions or if you make the
solutions too general they just become
too complex to use so I have one
solution because it's got 15 different
options to set and work out and after
just becomes very complex to use so
again put a lot of effort into making a
good set of tools so on which people can
build their solutions and get them right
and get their solutions just the way
they need it for their application for
their problem right
if you want to consider the tools as
part of the language I don't know in one
sense the basic primitives are of a
language are the basic tools then you'll
build another set of tools on top of
that and maybe not let layers of tools
on it
but keep them as simple as possible
semantics is king here definitely more
important that more than almost than
anything else except for the simplicity
of course is the semantics what does it
mean right if you can't get this right
everything else is waste of time and
this is what determines the usefulness
of what you're doing
it's the span --tx what does it do how
does it do it that is what is important
and from that point of view you can say
well syntax is irrelevant okay there are
a lot of discussions on the net with
various languages and people going
totally berserk about the fact that the
syntax does not look like your J xxx or
your xxx that's ridiculous
sorry I can't help it it's ridiculous
right syntax is easy there's a manual
read the manual it's all there how do I
want to write the conditional read the
manuals all in there yes it might look
different from what you're used to doing
but you might spent probably spend less
time in learning the new set syntax than
in complaining about it to be honest
right if you look at some of the
complaints they're just read it also it
will teach you something new which
however you look at it is a benefit now
you might hate the new syntax and then
you can say yes I hate this syntax but
then why do I hate it because I know
what it is I know how to use it and I
hate it right or I love it whatever
right but at least you know about
something you've learned something new
right but one so that's why I'm saying
syntax is irrelevant and I will admit
there is some syntax out there that is
pretty confusing but also say no it
isn't irrelevant in that sense so if
you're designing a language try to make
a good syntax I mean you don't have to
make it unnecessarily hard for trying to
make a good syntax
the syntax of the language should
reflect the semantics this I mean a lot
of these things I think are self-evident
but sometimes you don't see that so it
should reflect the semantics of the
language and that means sometimes if you
borrow the syntax from a language with
different semantics and try to map it
onto your semantics it just won't fit
very well so however hard you try if you
want to try and make Java look like it
or Java work like hour long is going to
be very strange and it'll be very
difficult you probably can do it but
you're going to confuse everyone
including yourself doing it that's just
a bad choice to do it right here's
another thing I feel this is this is a
personal opinion of avoid providing
alternative syntax is for the same thing
if you want to do something provide one
way of writing in sorry I can't follow
that one's enough many just confuse the
issue you've got different ways of
writing is it difficult to it it also
makes it harder for newcomers to learn
your language because they might have
five different ways of writing exactly
the same thing and saying that well they
can only choose one of them and only
stick with that just does not hold
because when they go out look at code
they're gonna see all of them so they
end up having to learn all these
different ways of doing exactly the same
thing with no significant differences
just syntax for it don't do that and
there's a corollary to that is avoid
adding special syntax or special cases
you're just going to add extending the
syntax yes you might save a few bytes
here and a few bytes there but in the
long run it just makes it more difficult
saving a few bytes is not a big wind one
of the worst cases are heard of this was
a suggestion in the lure mailing list so
Lua has a basic as the basic data type
they have it they have a key value
tables and then of course they have a
syntax for writing down a literal table
and one guy calculated that if and okay
between each key value pair that you put
either a comma or you put a semicolon
it's very straight simple
straightforward but one guy worked out
that in many cases you could
have to put this common the semicolon in
there because the syntax would work
anyway it wouldn't always work but
sometimes you could do it and he worked
out he could save him with two or three
hundred bytes in his program to do that
right to make that syntax change yeah
great of course if you miss it in the
wrong place you might get something
behaving completely differently but
that's not the issue right but yes avoid
syntax and special cases yes your code
might be longer but it's very clear what
you're going on for it
again getting back to this be very
restrictive and adding features to a new
language or to a language where there
new features do it because any feature
will limit what else you can do and
affect other features in the language
it's just no way getting around it there
is no such thing as a free lunch here
and if you've got your language in the
sense that you keep having to keep
adding new features the whole time you
will eventually reach the stage which is
just not worth it it just becomes so
complex you might as well just redo the
whole thing anyway from the beginning a
typical case where this might happen is
you've implemented your language for one
type of problem then you're trying to
get it to work on another type of
problem and that just doesn't fit so
have to put new things in there if you
look for example what's happening say
with C++ and Java they're just trying to
phase in more this is my vehicles phase
in more different types of problems and
getting we're adding more bits of syntax
into it and making the whole thing very
complex when it initially wasn't yeah
this is just some Vice bitter experience
here it's much harder to change
something once it's been released once
you have users using something they get
very depressed very angry if you start I
want to change something right I can
understand them if they've written a big
production system running on it you say
y'all want to change this now they'll
get very unhappy about this so be very
careful when you're making changes when
you're putting something into the
language think a bit about before before
you do that before you put something in
and so I say huh you want hindsight
before you release something like it was
this a good way of doing it could we
have improved it could we maybe have
waited a week and thought a bit about it
about this and come up with a better
solution for it maybe not the feature of
self what we're going to add but just
the way of expressing it
another thing about documentation one
thing you should do is not just document
what things are but why they are like
they are and often you'll see that
that's not done you will see how to do
things but you won't not see why to do
things especially if you're looking at
the primitives maybe for library you
could say why use this library but the
primitive level you should not usually
not said why they look like they do and
again I can talk from experience here
one of the things we did not do when we
were developing our line was document
why things look like they do for example
I don't think it's really set anywhere
so the Erlang language developed at the
end of the 80s I wrote I wrote a small
paper on this about 2004 or something
like this about some of the rationale
behind it and some of the things some of
the things that came up and the
rationale has never been talked about
before for example one is that all the
concurrency error handling primitives
are asynchronous all of them and that
was by design right but we never said
that and of course the reason was we've
been thinking about it for so long time
we felt that this was caught this was
self-evident
of course everything should be
asynchronous how could you not have an
asynchronous so we didn't need to write
about that but then you find of course
other people who have been into this
thinking this way of thinking or like
this will not see that and not
understand what's going on there so be
very careful for docking if you're
making changes like this he's putting
things into a language in your system
describe why you're doing it it also
makes it much easier for people to use
these ideas in the right way because
you've had some idea of why things look
like they do you have some other plans
about these types of things for them so
if people know why they will be able to
use it in a better way they might think
up new uses of course but they'll
understand what they'd much I understand
what
what they're doing yeah I can say yeah
one thing about languages and systems I
should have said before often when
you're typically when you're designing a
language you will also have ideas about
the type of system this language is
going to be used in okay
and that will mean that your ideas of
the system will affect your ideas of the
language and your ideas are from the
language will affect how you do things
in the system so these things these
things mesh together very much right if
you try and separate these then you're
going to have problems and that's why
that's one reason why the airline
primitives are like like they are
because they're very good at
implementing the type of system we were
thinking about and they just fit
together that's why doing some things in
a lung system which is which can be
difficult and other systems is basically
trivial in our line because the
primitive design just to do that right
that's what can do them for so the all
these things mesh together that should
affect why you're saying things also
affect your libraries and stuff like
that as well through the whole way up
why why am i doing this because I want
to use in this way and therefore they'll
reflect back to why they look like they
do so yeah I'm not gonna go I can go on
quite long about that probe and at this
time anyway again also the tool thing
the thing here about implementing
primitives is that if you when you get
them right people who implement their
tools that they need in the way they
want them to do it to be and a lot of
things that that sound very simple
aren't when you start thinking about so
for example synchronous communication
sounds very simple really I send
something like it something back but
there are lot of issues you want to take
up when you start working with that for
example what happens when something goes
wrong or not when does reply come back
but how does the reply come back who
sends it when do they have to send the
reply etc etc and all these things were
how did it interact with other things
and now we're not even talking about
distribution which makes them puts a
completely different layer
difficulties difficulties on top of that
so a lot of these things things are many
things that sounds simple aren't another
thing here is be consistent this is
again this is self-evident if things
look the same they should mean the same
so if I've got two things which look
almost exactly saying they should be
meaning the same thing if I've got
something that two things that mean the
same they should look the same again
this is just getting back to
alternatives for this my dear be very
explicit ok I like having things very
explicit I like to see exactly what is
going on I don't like a lot of implicit
stuff going on behind it this I know a
lot of other people feel jobs away to do
that I like to see exactly what doings
yes I will accept I might have to write
more code because I am being explicit
but then I can look at this system and I
can say exactly know what's going on
there are no implicit assumptions going
on there because yes it makes it very
easy to see what is going on but it's
all there in the code there no implicit
assumption someone else can come and
look at and see exactly what what I'm
doing there but what this code does
because it's all there right
doing things implicitly also you have
fewer implicit assumptions in that and
the problem with implicit assumptions is
people might get well might get
understand these incorrectly or two
people will have that will see these
assumptions and things think they mean
something differently and that can cause
a lot of confusion because you can't see
it it's there in the implicit thing
again if you look at our line we have
very few implicit assumptions and
everything's very explicit I know that
people complain there's so much code but
at least you can see exactly what's
going on it also helps a lot that
especially for newcomers who don't know
what is going on there if things are
done implicitly things will just happen
in their system which they have at which
they might have no idea what's happening
or
I or how they can affect it because it's
not explicit okay so this is thing for
them yeah and again focus focus focus
focus be very focused on what your
language what your system is supposed to
do and stay within that focus is when
you start wandering things get very
complex especially if you're wandering
away from the basic principles of what
you're trying to do right this is
difficult to be honest I mean you've got
your language as fine as fantastic and
then people start trying to use it for
other things and they'll and they will
find that it doesn't quite do what they
want and can't you make a few small
changes to make it better getting back
to the no cat no right but again you get
the problem if your language design for
a certain thing make it trying to make
it to other things will just complicate
the issue and unless you're very lucky
it won't work
and you will end up having something
extremely complex again for example C++
and Java when you're adding new features
to a try and make it do other things for
which it wasn't intended suddenly the
whole language gets very complex I'm an
old C programmer classic C programming
that since C was a very simple language
it was very basic was very
straightforward most the case most the
time you knew exactly what I was going
to do had a few strange idiosyncrasies
in it and you had to be aware of them
but apart from that knew exactly what
was doing it's when you start trying to
add new features on top of it which will
for what wasn't designed then it started
getting complex and whatever you may
think of C++ it's not simple okay so be
very focused the same thing with your
system I would say if you're lucky often
your system will actually be suitable
for many other different types of things
and what then what you'd planned it to
be it's just that I think in many cases
the basic properties of a system of
systems are much quite similar
irrespective what the system is actually
doing here we're getting back to the
problem thing again right your problem
Omaha a different type of problems but
the real problem below
underlying all these can actually be the
same again I mean we're designing our
line for telecom systems but now it's
being used for web servers and web
servers and telecom systems aren't
actually the school they're not very
similar at all except when you start
getting into the real issues of what
you're trying to do there and what
properties need then you find actually
are very similar so yeah so again focus
on these things we're ending the simple
short here
we're intending in here DSL czar great
yes of course
they're fantastic for doing things but I
would say all the but above rules apply
what's a DSL Wilson another language you
might be a very specific language we're
doing something doing one specific thing
but it's still a specific language and
all the rules for designing languages
any language is basically the same for
DSL right the DSL is designed to do one
thing it's time to implement this type
of thing a special language for this so
then you make a special language for
that we're handling the primitives you
need for doing that and that from that
point of view there's nothing specific
there's nothing different with a DSL and
from any other language it's just a
language it might be more specific use
than you'd think but then other
languages but it's still just a language
and all these rules apply to it keep
things simple keep them very specific
have your simple primitives at the base
and then you build things on top of that
in your DSL anyway your primitives might
be different from the language of
implementing the me because you're doing
different things but the basic ideas are
exactly the same right and this is
something yeah ok this is again my very
personal view here I I think something a
calling it something a DSL which just
happens to be a few functions and maybe
some lack syntax I don't that don't look
like function calls I do not call that a
DSL sorry that is my personal opinion
here for that's just a set of functions
doing a specific thing and there is
nothing wrong with having a set of
specific functions doing a specific
thing nothing at all if they do what
they're supposed to do
but I would not call that a DSL sorry
yeah if that's the case I've written so
many dear cells I would not have I would
care not to think about it right because
they just happen to be a data structure
describing what was going to be done I
did not I would not call that a DSL but
according to some definitions afterwards
they they are right so yeah yeah anyway
I know I know a lot of people don't
agree with this so the main thing here
is what about this four language design
here it's focus focus focus focus focus
on what the language is supposed to do
what the what the basic problem of that
that language is trying to solve what
that is focus on that don't get
sidetracked from that that's the main
thing for it yes you might end up having
four more languages I don't see that as
a problem I'm sorry III don't see having
multiple language in languages in a
system as a problem I actually see that
as a benefit because if you look at a
large system you'll generally find there
are different parts of the system which
have different requirements doing
different things and expecting one
language to handle all that I think it's
just wrong then you can hear like a
complex language in that sense it's much
better to have multiple languages from
different parts of the system each
language doing what it's supposed to do
what it's doing best for in the system
yeah you might get a bit of trouble
interfacing it but I don't think I think
that's much that's a much easier problem
than trying out one language do
everything it might be harder to solve
but that's not another issue for also
having multiple languages especially if
they're different languages gives you
one extremely good benefit it forces you
to split the system up in spec into
separate sections and having a very
explicit interface between them if
you're running different languages it's
very hard to have back doors if I'm
running one language I can just make a
simple hack and pass something through
in a back door because if just easy to
do it now which means that in the future
people are getting very confused because
I have absolutely no idea or how this
data got from one place to another
because you can't see it
if you have multiple languages you
forced haven't explicitly very explicit
interface you can see these things for
of course that is something you should
do anyway but if these we get around it
it's it's very common you do get around
so yes yeah so focus simplicity yes keep
the basics very simple build things on
top and layers on on this week each each
each one as simple as possible doing it
have multiple layers for doing things
for it it's a big win in the long run
consistency yes things should all wait
to things should always look like they
they should do what they look like
they're doing and they should and they
should look like what they're doing keep
the things very consistent in your
system right and again be very explicit
you see it that means you'll see
everything forever and this these route
rules philosophy how we want a class it
has a very big benefit when you get to
maintenance okay there are two different
worlds if I would just want to hack
together something I'm gonna use in a
month and throw away or I want to hack
together something which I tend to use
for five years they're two different
completely different worlds but what's
going on here and if you want a
long-lived system someone else is going
to have to come along and maintain that
system after you maybe further
development someone like that the
chances are that you're the one who's
going to be doing that the whole the
whole system lifetime is quite small and
I think following these rules my ideas
here they will help that because you
keep things well structured because you
keep things explicit and very well done
because you've documented why you're
doing things not just what you're doing
and stuff like that they'll make it much
easier with people to come along
afterwards and maintain and work on your
system because they know they'll see
what is going on right and if you don't
do that they'll hate you because they're
running the system something's going
wrong and somewhere some somewhere of
bad values coming up and they've
absolutely no idea why that's cuz just
doesn't say anyway what's going on here
you've done something really smart but
they don't see the smartness which means
it probably wasn't
yeah I know I've been there myself I've
done sometimes you're so smart that six
months later you don't understand what
you've done right and you just like the
overly smart yeah and of course the
problem here the thing here is you're
making a production system and you want
to live for a while the initial
development that's the cheap bit to be
honest is the maintenance of the system
that costs so here I got 75 to 80
percent of the actual cost is
maintaining the system is the
maintenance of the system over its whole
lifetime and the longer it lives than
what the higher that proportion gets the
original developments quite small right
yeah you might you might cost you a bit
of extra time to do it to get everything
right but in the long run you will have
made it it gets it's the technical debt
thing right everything everything I do
now which I just do two wrong or two two
two hack early or something like that I
have to pay for it later and the longer
it goes before I pay for it
the more it's going to cost that's the
maintenance cost for again it depends
what you're after what you're doing for
and if you can leave the project fast
enough before these problems have
materialized right so I did it really
quickly it works then I go and someone
who comes along in three month time when
it doesn't work
won't like it so yeah they're just
there's some of my basic ideas I can go
on quite long but I'll just leave it
there at the time being for and open up
for any questions or so forth
so anyone have questions but you didn't
you haven't explained the exact meaning
of what I mean by simplicity okay
what I mean is that the basic the basic
principles of your system the underlying
basic principles on which everything is
built should be very simple that they
should age they should be they should be
simple they should be very clear what
what you're doing now you might build
complex stuff on top of that I'm not
saying I'm not this is not saying that
you can only build soup you only build
simple systems know you can get very
complex systems but the basic part of
the bottom line the basic principle
should be very simple to be very
straightforward because with that then
you can build complexity above it and
still keep it understand that that's
what I mean by simplicity but in this
way we can share the meaning of the
simple all these things which were just
talked about too not only the language
but building all the enterprise system
which we are having all the enterprise
system actually are tools for doing some
job so if we will share this like this
is not you should rename the talk not to
the languages but those things I
mentioned it ok yes yes yes yes that's
true that's that that's yes it should be
named that but I think that's what it's
trying to say before that a lot of
things that you're doing in your
language interact with how the type of
systems you build on top of them I mean
when you're thinking about a language
you're thinking about a specific type of
problem and you're thinking about also
at the same time thinking about how
would I write a system that solves this
problem and then you think about okay
what what type of primitives does this
system need to do this and what what can
I do in the language and they work
together I think that if you want to
build a successful language you end up
doing that right yeah you're thinking
you might implement the whole stack but
you're thinking about everything yeah
that's my that's that's my view of
simplicity for
yeah and that's why it's difficult
because it takes a lot of takes thinking
it takes experimenting do this to taste
I design a set of ideas I work with that
and I find no this just doesn't work the
way I want it to work so I have to go
back and start rethinking and doing
again it's an iterative process to get
round to it that's the difficulty in it
and again that's the selling point the
difficulty selling point is when you see
these they just say they're just so
self-evident so why should I pay a lot
of money for something which is
completely self-evident right but then
then you know you succeeded yeah this is
not nowadays even more important
important than when you have this kind
of sites like github and you get like
pull requests off from many people yeah
and the code is never perfect but you
would like to get those people involved
to get spray-tanned oh listen and
everything and get cooperation yes I
quite agree yes it's difficult sometimes
I'm not saying it's easy to say no but
sometimes it is sometimes you can go
back and say yeah but if you fix it like
this I'll be glad happier to take it and
things like this for it yeah I don't
have a solution to that I agree it's
difficult to do that sometimes before
people come in you need someone in the
end you can say no like Linus in Linux
right basically like I don't like it
nope that's it yes okay so the question
is actually whether you agree that it's
difficult or do you agree that you want
to have those users because the question
is do you want to have the big community
around yes I want to be yes of course I
want the big community well it depends
why you're doing this but yes of course
I want the big community yes of course I
wanted people to come with ideas people
to use it detect bugs and so on and come
with suggestion for it so in that sense
it's a balance of what you accept and
what you don't accept how you accept it
can I accept something and maybe react
it afterwards is that a good solution or
not or best can if you can go tell it
ask the person
or the pull request say yeah but could
you make the change in this way I'll be
much happier and they'll go away and do
that and then you can pull maybe you
need a set of rules for accepting pull
requests I mean if you if you look at
the Alain system I'm not part of the
development of it but they have a set of
rules for if you want to make a
suggestion you have to fulfill these
rules before they'll even look at the
suggestion right
I mean well has to work too has to be
documented history test cases and until
you've done that they won't even look at
it then when we're done that then there
may maybe start considering if they want
to take it or not
yeah it's might not always be a nice
system yes of course you want users of
course you want an environment using it
and sometimes yes users can actually
come with good ideas that fit into what
you're doing the worst the worst thing
with people with ideas is not the bad
ideas because they're easy to say no to
someone comes with a bad eyes in their
stupid this is problem is if someone
comes with a good idea that just doesn't
quite fit but what the system does how
the system is supposed to work that's
the most difficult thing bad ideas are
easy can just say no because it's stupid
but good ideas which don't quite fit
they're more difficult to do that more
difficult to a nice way as well to now
I'm opening up myself up here to my
projects but never mind yes
I don't like syntax really sorry I I
don't I don't recommend using syntax or
then I think then you're getting
alternates in taxes for the same thing
and that just complicates the issue I
can make a quick push here that I
haven't mentioned it in the talk we're
getting quite close to macros so I'm and
all this person first true the high
level language I wrote was Lisp so I've
been using macros for 35 years and I
love macros macros are fantastic but I
also understand all the problems you get
when you're using macros or well not the
problems I get defining the macros but
the person problem someone has to read
the code it gets for it that's getting
back again to a syntactic sugar so it's
something you have to be very careful
about doing that and again the problem
with the syntactic sugar is the same as
adding features that they'll start
interacting with other things right so
if I add some syntactic sugar for
something that means we'll start
interacting with the other syntax and
limit what other things I can do with it
because it just doesn't try thing for so
yeah
what's you what's your opinion on
handling situations where you introduced
some some syntactic feature and then
after some years you realize it was a
bad idea
like let's say Erlang records and yeah
how do you handle it is there some best
practice for duplicating such legacy
stuff or keep it for the sake of peace
yeah what's what's the best practice in
your opinion two points one I'm the one
who introduced telling records
so yes they were introduced to solve a
specific problem
Mars will take it they were introduced
to solve a specific problem our first
user group of building using our line to
build a product that not just experiment
their product they said they wanted
tuples but they wanted tuples with name
fields which is perfectly reasonable
request because using just using indexes
is very prone to errors they wanted name
fields but they said they wanted to be
as efficient as using the existing
tupple interfaces it was which meant
that everything had to be done at
compile time it couldn't be done at run
time the problem with having key value
data structures that that's nothing new
I mean they've been key value data
structure I know how many how many
decades so that wasn't the problem the
problem was making them as fast as being
done at compile time which is very
difficult to do that's why records are
like they are because they compile time
structures and yes people have
complained about the syntax of records
since they were introduced and no no
one's come up with a better suggestion
sorry with a better suggestion that
works ok they've been a number of
suggestions to improve that to improve
the syntax but none of them work well
none of them work all the time you might
have to revert the albin that that's why
they do one mistake we maybe should have
introduced a specific data type for a
record data type as devayne doubles but
that's why they look like they are and
that's why no suggestions have been
adopted to change that and there are the
things we did that were wrong too the
trouble is of course once once once
something is once something is accepted
and something is being used it's very
difficult to change it because people
start complaining about even more about
the changes it's the same thing with yes
people complain about the the Erlang
libraries they're inconsistently named
the functions are inconsistent the
argument ordering is inconsistent and
they generally write but every time you
suggest ok we'll change it they'll start
screaming even more that's yeah suffer
sorry I asked about the only and it's
solution I can give to that there are a
number of things we put in the system we
could have if we thought a bit about
more about it before we entered it we
could've made a bit better suggestion
their choice in their world was today
but unfortunate records yeah
map soap but their placements so yeah I
don't know if that really answers your
question but yeah that that's that's why
records are though
that's why records are like they are
because they have to be compiled time
seeing we don't have any declarations in
a line or I can't declare a variable X
as being of a specific type we always
have to for example have the record type
whenever we doing a record information
because the compiler can't always work
it out if we have two boys put the
record type in every time using a record
which makes it makes the syntax rather
verbose it's very consistent but it's
quite possible that's why it looks like
it does could we've got written that yes
by having variable declarations but then
would have significant that would have
been a significant change to the
language for other things as well to
they would change it that would affected
almost everything so yeah this was just
basically hacking the component okay
that's not a question
I don't know if this answer your
question but F that's why they are like
that that's it and all right what's her
opinion on Scala in terms of language
complexity and simplicity all right I'm
not a scholar person so you have to be
very careful here I was looking through
and those sort of about a three-page
list of operators or something like this
in Scala I think that pretty well
explains it right it seems to me that
Troy's trying to be too much and putting
too much into the language for it if you
compare to other languages I mean you're
compared to Python which is still
relatively simple it's a relatively
simple language for it and then they
managed to keep it simple
you might have guessed I'm against
having trying to make a language to
everything because they won't they'll do
something a language with some things
very well and the further way you get
from this central goal the language the
more difficult it gets the more trying
things doesn't work and I also don't
think you can mix functional and
object-oriented very well irrespective
of the language I think just some of the
basic assumptions excuse me
underlying them are too different to do
that you can do one in the other that's
not the problem
but getting the mix them together a nice
way those two I just don't think works I
don't if they answer your question with
that that's that's my view of you and
yeah I like simple languages okay and a
lot of languages have become very
powerful in spite of being very simple
so for example I mentioned law before
law is a very simple language it has one
structured data type the key value
topple was it going to key value table
and if you opportunism but but with that
and using it the right way you can build
you can build almost anything you want
on top of that they've also resisted the
temptation to add things to it well you
add one thing in the last version they
had it they added integers before they
only had floats right that's about the
most significant change they're made for
a long time so yeah so you can't do it
anymore
I'm not saying this is easy and fixed
who was right here getting things simple
is complicated it does take a lot of
work to work out what these simple
primitives should be and how to get them
down so they interact in the right way I
know what happened to Mike beam mighty
okay the questions the question was that
go I said that that was also very
engineering view of it they had a
problem they wanted they want to solve
so they implement a language for it
they took ideas from see and so I
borrowed a bit of syntax from C but it's
not seen in any way okay if we compare
to how long they had a different problem
in mind from what we were doing with
different requirements for it so some of
the things you which are very simple and
our line are very difficult to do in go
for example to to implement something
like OTP on top of go it it's almost
impossible because some of the basic
features they wish the OTP needs is just
lacking I don't really know exactly why
they did go like they did sorry I don't
know about that what what their
rationale was for doing that I think
it's an interesting idea I think it's
very coarse I like the idea that their
basic making the primitives from the
concurrency and stuff into the basic
language of course I I find that very
good way of doing things I like that
but I don't know why I think I think
it's not how I would have done it for
that way right and again if you're
coming from a long point of view the
fact they share things share data that I
mean that's that's really no can't do
that no you don't want to share things
yes it might make some things faster but
it makes a lot of things very complex
and it makes scaling very difficult
that's why they did that a lot about
things but it's an interesting it's an
interesting language and it seems to
work quite well for what it was trying
to do well this is question about go
being specialized that I can agree with
that I can support right I don't have
anything against go saying okay we want
to solve this type of problem so we'll
make a language that does this right
we have concurrency with these these
ideas we won't find it we'll do that put
that in that's fine I think making a
general-purpose language to solve in
every problem you'll end up with a right
mess sorry to do that because because
you have so many different features that
interact with each other and just don't
work together like for example I would
say concurrency and parallelism together
with sharing state getting that to work
together is very difficult especially if
you want a scalable system then it
becomes cool so you can do it but it's
also very difficult and if all these
things affect everything else right you
can't make one add one thing into a
language without affecting everything
else you make a choice of what you want
to keep what you don't want to keep
so in that sense goes fine that there
made a specific language for a specific
problem great okay it doesn't do the
same thing as a lot of other languages
so there are other languages right right
you other things in that those languages
and indirect interface that right I mean
typically selling example owling is not
very good at doing serious numerical
calculations we can do them but there
it's slow right and I don't see that as
a problem if I want to do is heavy
numerical calculations and I'll call
something in Fortran or a Java library
or something like that to do it I don't
see that as a problem do what we do what
we want to do and do that as good as you
can and then if you want something else
pick another language that does it
perfectly it was best if you can use
that okay I think I probably said that
already okay okay parts of it anyway one
thing to be one thing to be aware of
Alexia's running on the a line virtual
machine is running on top of our line is
running on top of our on top of OTP
which means basically at the low level
it selling there's nothing strange about
this it just is because that's all the
that's all the a line virtual machine
sports it supports our lines you're
running a line on this is a skin on top
of it with a different feel for it I am
NOT a ruby person okay so the sin from
my point of view the syntax is
completely foreign and full of these
weird strange things that I would never
do myself right did you understand that
that's it take that as you will if you
want another language on top of our line
use LF they use Lisp instead it's a
perfect syntax it's simple its
straightforward and you can do anything
you ever could dream of what wanting to
do in at someone else I think yeah I
think we can take them off with what is
Erlang best fit for your babbling is
designed and best for the building
massively concurrent
Thorin's scalable systems okay there you
go through you got three buzzwords right
we're extremely buzzword compliant from
the very beginning that that's what
design for doing it's designed for
concurrency so you have a concurrency
primitives built in from the very
beginning it's designed for building
fault-tolerant systems they're
primitives for building fault-tolerant
systems in from the language and a lot
of the other things just have made it
very scalable for example we don't share
we don't share anything which means
running things on one core one thread or
multiple threads or multiple cores just
fits because there's no sharing for
example that's the type of system is
built for it's not built for heavy
numerical calculations we don't do here
we can do it but I mean what my thing is
saying yeah tomorrow's weather in a
month's time right we can do what we can
do it all but just a very slow you
wouldn't do that
that's what we could for doing that's
where we're good for controlling stuff
as well too and you'll find a lot of our
line applications use things written in
other languages for doing specific stuff
and we just control them that's that's
that that's the type of system was
designed for so you take your you would
take your ailing application and you run
it on your machine it will just run
completely transparently whether you've
got two four six eight sixteen I think
up to 64 cores it does quite well now it
just runs just just uses everything
imbalances that just by default before
you'd have to worry about that that's
the type of thing it's good for
okay we looked at top it we looked at
strong typing when we're doing it okay
now we're talking 30 years ago more
there were two there were there's one
major issue one major reason we did not
go for it okay a couple one is we came
from a from a dynamic typing background
well past partly from the dynamic typing
background the thing is if you're going
to do dynamic code handling then having
static typing is very difficult because
if I mean if I were if I were if I have
a module which with a well-defined set
of functions and types and so on I want
to come in with a new version which is
had different types in that can be very
difficult to do that's one reason for
example why now long there are no user
defined data types because it just does
not work together with to work well
together with dynamic code handle and
that's one reason why we didn't do it
static typing is fine over nothing
against or such I'm sure I'm just I just
haven't used it for well I use one in
programming C that's very I think
they're the reason why we did not
include the minute in our like it wasn't
just a version to it but it's just that
someone said we didn't do it because we
couldn't write a static type checker but
we couldn't write virtual machines will
write compiler Z that we taught
ourselves that so we could have taught
house also snake type check if we wanted
to and also some of the experiences we
had with with some static type
functional language in those days
weren't very helpful we weren't very
promising
I mean you wrote a small little program
and find a tight burning at half a page
of type information saying what was
wrong with it and was full of arrows and
stars and parentheses around this
completely unintelligible and you say
don't what this yes very pragmatic
button okay and so I said here one thing
with my view of language design as given
here it's very pragmatic you were out to
solve a specific problem we were out to
solve a specific problem we weren't out
to design a functional language
it became functional the concurrency
model we didn't start off with this idea
we were talk I mean it's the actor model
yes more or less we were told that
afterwards you read in the paper that
our long implements the actor model we
go out and try and find out what the
actor model was and it was that it
became like it did because this was the
best way we thought of solving the
problem and I would say that can be very
very good a testament to how good
functional languages are so we went out
to design a functional language where to
solve this problem we ended up as a
functional language because this wolf
felt was best for what we were trying to
do same thing for and again the
concurrency model cuz this was this
worked we could create things we
massively concurrent we could crash
things without crashing the system and
everything like this just worked right
so if we could have got in static typing
probably in some way but we could just
not work out a way of doing that
properly I don't know if that's problem
is solved today I'm the wrong person to
ask but it's a typical thing I've
mentioning before to say again you make
one choice that affects a lot of other
things so in this case we want to
dynamic code handling and that affects a
lot of other things around the system to
get the dynamic code on them to work you
have the concurrency model that effects
a lot of things for example we have the
a line process we want to be a crash and
a link process whenever we want to
because something goes wrong but it
shouldn't ruin the data for other
processes therefore we don't share
because then don't get that and just
these things might sort of spread out
and affect everything so just getting
everything you want fitted together
that's a difficult bit okay we kicked
out now okay thank you very much I think</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>