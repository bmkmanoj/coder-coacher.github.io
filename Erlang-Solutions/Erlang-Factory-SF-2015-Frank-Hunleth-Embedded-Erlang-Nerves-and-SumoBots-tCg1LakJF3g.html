<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2015 - Frank Hunleth - Embedded Erlang, Nerves, and SumoBots | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2015 - Frank Hunleth - Embedded Erlang, Nerves, and SumoBots - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2015 - Frank Hunleth - Embedded Erlang, Nerves, and SumoBots</b></h2><h5 class="post__date">2015-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tCg1LakJF3g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks everyone for coming this is
actually a big drill for me because I
get to share some of my embedded
software experience with with you guys
and I just wanted to check real quick
how many embedded guys are out here in
bed software all right so this is this
is great so um we have more than I
actually expected so what I what I did
last year when I came is I gave kind of
what turned out to be a case study for a
little camera system there's built-in or
a line using a framework called nerves
that cross compiles the erling it really
the c code there are links to say not
not exactly cross compile and made a
little camera so so the problem was last
year was you could see my project I
could give all these details about it
and I actually open sourced with a lot
of the pieces but it was kind of hard to
get started on so I wanted to try to
make this a little bit more accessible
and I guess there's just one other note
that I wanted to say to all of you who
may not be in the bed in industry the
embedded industries kind of painfully
slow at change so a lot of things that
come very naturally to you guys um in
terms of coding are actually quite new
concepts for a lot of the people that I
work with them and and so don't hesitate
to give comments even if they're
completely obvious because sometimes
these things are new long so my route to
this this project well a couple years
ago I really I wanted to do something
about the C and C++ code that i was
writing because i had read a lot about
erling and i noticed i was reinventing
the wheel a lot um so I and with the
processors getting faster especially the
ones I used which happen to be 32 bit
linux processors few hundred megahertz
so you know thinking in terms of a
higher-level language was not that hard
um so I looked at our lang this looks
great and then I thought well has anyone
else use in in embedded and then I saw
all erickson did the case study for the
whole language is pretty much an
embedded project so I said oh super I'm
not even taking much riskier by pulling
this in a project so I started looking
into google so how I get started um i'm
using erling in one of my projects and
um I found
so I said okay good let me do a little
prototype and that was last year and
then all of a sudden I started putting
this together and I noticed uh missing
pieces um in other things that just kind
of were surprising to arm a guy that's
kind of used to UM far more images in
the size of tens of Meg so tens of Meg's
for our firmware image is actually huge
for embedded guy but then I found out
that there's another level of huge and
that's that most of the time most of
what I was having to be finding or
things that require desktop linux
installs and then you know I had fun
things like I saw Megan cone and
korvenites just like oh my gosh um I
don't quite need all that and I go went
through some open source libraries and
it was very clear that there are people
doing this stuff I'm not doing anything
new but it was on and off maintenance so
anyway so I started up um this little
project this was like toy prisak to try
to take on to try to build some sort of
frame or forgetting erlang cross-compile
inside a little embedded Linux system
and that my approach just to make this
more interesting with what if how much
since early has a lot of the same things
that you find a normal Linux system let
me try to not use the Linux versions I'm
so useful and use the early ones so the
so one that I'm going to explain this a
little bit further from where things
ended up um so as I saying before I did
put some limitations I'm using embedded
Linux for me that's kind of a base
parameter that I need just to excess
some device drivers I'm twice drivers
are kind of fun to write but not fun to
write too many um so the um I cross
compile all the little projects I bill
tend to be cross compiled and cross
compile can be a pain but it can also
save you on a lot of work because when
you develop natively on a device well
that brings in a lot of baggage and when
you cross the pile you can just take the
pieces that you need so you actually
save some work by cross compiling and
then I was I said okay fine network is
kind of a pain so i'm just going to
reuse call out to the the standard Linux
tools
networks at least in the beginning I
mean still now so um where what are
things that you look far in nerve so I
think these are some of the defining
characteristics of this system so Earl
annual of course because the mom what's
the point if it won't early a minimalist
so so a lot of times when you see
something nerves and you ask your
question is it included or is it not a
lot of times the answer is not nerves is
very much a minimalist system that you
can be built on it's like you start
small and build as opposed to a system
where you start big and prune it down
and that's somewhat nice you can you can
build these small systems and at least
for me you can kind of I can kind of
think that I actually understand a lot
of what's going on the system which far
any kind of big project is is certainly
a luxury um now that's the minimalist to
actually put this together there's a
system called buildroot and build root
is a common Psalm it's a pretty popular
project in the embedded world to to make
on the cross compiler compile linux and
build all these Linux tools that you
want to include on your embedded system
and then packaged it up in real one root
file system so it's buildroot since
build root filesystem so I i reuse this
build route project and customize it in
an Erling arm to the specific way um the
dit process for are you guys systemd in
it or system 5 in it systemd all that
stuff so there's some replication and
things that Erlang can do so I just said
well I won't think about it I'll just
toss it down add a little shim I
couldn't you can't just start Erlang as
process one um because there are some
things that you have to set up in the
linux user land beforehand but you can
have a pretty small um init process and
that's so there's this little little law
project that's basically one C file it's
about that long to set things up and
start early and that's her Lynette and
you'll see that start now when you get
to actually using it how does the ER
line
min um everything is on based on OTP
releases and I guess I you don't have to
have be an OTP release but makes things
a lot lot easier I think that's been a
common theme at this conference to go to
the OTP release um the last part I think
this is more of an embedded thing for
our devices that you tend to unplug and
replug that's so the lot of devices that
I make um they might stay on for a
little while but it's not good it's not
quite as important to have these rolling
updates like you can do with Earl I
there's nothing against it um those
things it's just I um I don't use those
as as much in my work so so nerves you
build an image but you know they're big
firmware image and then it's read only
small and then if you want to upgrade
the system you you download the new
image apply it and since these images
are small it's actually not that big of
the deal and then you reboot to run the
second image so so so when you start
using this you'll see oh why is this why
is my whole root filesystem read-only
well um it's the support this this use
case it actually has a nice side effect
that you can yank power off at any time
and your your file systems read-only so
it's a little bit harder to corrupt not
not totally robust against this but but
certainly better so here's here's what
you do when you use nervous they're
there to there are two routes for this
so there's the top part which is kind of
the Erlang route and then there's this
bottom part which is with everything
else route the Erlang route um is your
standard you write your OTP applications
you compile them um now the compiler
that you will get far for compiling the
C code will be the cross compiler so
that you'll actually get arm on binary
ziff your if your targets on arm and you
get down over to relax to create the
Erlang OTP release now in parallel
there's the there's this whole idea
about generating a base on a base image
so the base image is a base root
filesystem and that's really the build
root parts
the Linux kernel Erlang the airline vm
and a bunch of other tools those will
get built and combined into one image so
you have that base form Ram it's you can
actually boot in and work off and I'll
show a demo of how that works but the
key thing is that those two paths get
combined and that the output of that is
the is the are the bytes that you put on
an SD card if you're going onto an RS
berry pie or be going black or if you're
working on some other piece of equipment
that has soldered in memory that's what
you'd copy to that all right just a
quick note this cross compiling thing
comes up a whole lot I just want to just
say um just some small things about it
so this is cross compile you program on
a host PC which could be x86 run the
compiler you get our binary out of it so
that's that's cross-compile so the there
are a couple reasons why you might want
to do this and that's a lot of them come
down to is that you can't develop on the
target that you're actually trying to
program on now that's become less of an
issue lately because these embedded
devices like raspberry PI's and and the
BeagleBone saw that are kind of fast but
how many of you guys have developed on
Raspberry Pi beaglebone dead it's kind
of fast but I don't think any way you
would say that this is like a happy
place too if you one quick feedback so
so cross compiling is one place to to to
improve this because your PC's crazy
fasting person to these devices even
still um I don't feel like you're locked
into cross-compiling once you get this a
lot of programs that people write for
these embedded devices a lot of pieces
don't actually interact with the
hardware directly there's nothing
keeping you from developing that on a PC
and and and then moving over to the
cross compile environment they'll have
people think that you know since I'm
using nerves do I have to to program
everything develop everything this cross
compile environment no you don't don't
separate your code in a smart way and
actually that's not even that hard to do
the other thing is if you are doing
something really hardware-specific and
the the Edit compile debug cycle is he
feels too long or you're less
comfortable with it just install like
raspy and on here and do that piece
alright so let's get to um let's get to
building something so this this this
first start part is what happens when
you when you decide that you want to use
or want to try out nerve so what does
that look like so this is the first part
is that you have to clone nerve from
from github and I'm not going to be at
because it takes a little bit but this
is this part I had like the
choose-your-own-adventure thinks it
because nerve saw supports a couple of
varieties out of the box which if you
like to program in Erlang or elixir or
LFE I got to think I'll let you guys
choose but then I realized that one of
those languages actually had
cross-compiling going on that's LFE
there's so I'm going to go that one
because it will be slightly more
interesting the other shells don't have
um young that much they don't have code
specific to the shell that's C+ or C or
C++ so let's just imagine that we arm
that we get cloned nerves and we just
put it in this directory so the very
first thing that you want to do when you
get nervous you have to provide it a
configuration and there are a lot of
configurations that you might want to
start out with so you can see them and
hopefully this will show up so I these
are I would say these bomb ones these
are starter configurations and the
readme has a little bit more information
on what they do but essentially they'll
get you a image that's going to boot far
far one of these boards beaglebone black
raspberry pi AG 150 and a likes so those
are x86 boards mom if you're not using
one of those you're not lost you can go
to the build route project and they have
several ones and then if you get if you
look at the project you'll see that what
i did is is a fairly straightforward
extension so we're going for this we're
going to we're going
go to the there is our pil fe so we'll
do that one so that's all it does so so
you say that that make that defconn fake
and then all of a sudden in your boot
build root directory you'll have this
file called da config and this is a
build root thing but it will save it far
far you for the next time now the next
part that you do is you type make and
make it's going to download the Linux
kernel your cross compile toolchain all
this stuff but before um before we do
that I wanted to show you um something
so this is um d you know latest and
greatest GUI technology to let you show
that you pick what you want to have on
your target um so the base image is cool
but like i said it's minimalist so as
you start programming just using nerves
just remember if you want to get
something just go back to your base
image and you can add you can add C code
or modules that I may not have included
so the two places you're going to go
probably target packages and I'll just
give you um just so there's like tons so
anyone who's done apt-get install you
know there's like a billion packages
well buildroot is kind of the same thing
your billion packages are in this menu
and you can use a slash key to search
for them but basically the all you have
to do is go over and say oh I want to
buy instead of which is 40 confidence
you just say yes and the next time you
build the base image that will be the
Boshy program it's going to be in user
bin and you can call that from early if
you want if you want to use it but so
that's so let's go back here oh and the
other place in build route that you'll
want to see is the nurse options so the
nerves options since nerves uses
buildroot it ends up in this user
provided options directory and now all
these are things like we want Earl in it
of course we want our own it so that's
how we start early oh they're a couple
other things
v we happen to pick that config no I'm
now down here there's this thing called
nurse config and this is to give to give
the base image just something that boots
and it's configured somewhat rationally
I look at it as a way of selecting
through the menu of certain options that
we are going to go in the vm darks you
know so when the vm starts their alarm
you can pass some arguments to it um
well like the S name cookie stuff like
that a simple way to get started when
you actually develop with this you're
not going to use this you're going to
cut you you might copy the files that it
creates as starting templates for your
stuff but then you'll get past it sorry
let's not say that okay so the next step
is to run run make and so if when you do
this at home just leave just leave your
computer on it will it will be about 20
minutes later if you have a pretty fast
computer maybe a little bit longer um
but at the end what you're going to get
our are 22 images here um then let me
actually just show this a little bit
better rude
so the Builder output image is there to
two files in here once that dot fw file
and the other one's a dot IMG so the
dotted line g i'll start with so the
time g is the file that you can copy
bite for bite onto an SD card so SD
cards there's nothing magical it's like
one big byte array and the image file is
basically that byte array for the
beginning and you could use a tool like
DD to copy it onto their this other arm
file the fw file is a zip file which has
the root filesystem and linux kernel and
whatnot all the pieces inside of it when
you actually get to using nerves the dot
fw file would be a piece that you would
could distribute to someone to upgrade
their system ah so far for this demo let
me just plug this in and let's see
hopefully i'll come up
alright
alright let's see I didn't see the
message so it might not have come up I
have a little make file target to to
burn it so we'll see it we'll see
whether things in there so the first
step when you have SD card is just to
burn a complete image onto it um you can
make upgrades from that but it doesn't
make sense to upgrade something that
doesn't have an image on already all
right let me try again
good all right so the nice thing is is
that my system at auto miles um this can
that can also be a little tricky because
you can't write low level to an SD card
that's mounted well you can just things
can get corrupted um the former update
utility will automatically unmount it
for you so this thing is going to copy
so then the next step when this thing is
done copying to the card so this is the
first time copy so it will take a little
long but what we'll what we're going to
do is plug it in to this raspberry pi so
this is a raspberry pi model b and this
came on what's kind of crazy normally on
my Raspberry Pi in a little container in
this this the GPIO is all the little
pins on the the the pie that you can
connect the hardware I have coming out
to your ribbon cable um and this this
goes to a little bored that just goes to
a serial port so so you guys familiar
with serial ports rights it's it's a
very common way of interacting with
embedded systems so see that's done so
let's just get this in here and
alright
and hopefully this will work
all right plug it in and all right so
this is the what's coming out the serial
port and then okay so there so it so it
boot it um and lfts there and we can do
well I we can do list so so so that's a
base image so you're not really can't do
but too much with the base image but the
idea is is it will eventually pull in
apps that your own apps that that will
actually do something more then then
just add now just a couple notes so I I
won't show this but Erlang distribution
works fine you can actually set this up
connect to your network and start
pushing code over it over the net and
communicating um the default nurse
builds come up and the the host name of
this this device which you can arm is by
default nerves hyphen and then 8936 so I
all the raspberry PI's have a unique
number so it just has four of those
bytes so that you can actually have
multiple these out of the box on your
network all right so
so okay that's that's good but now we
actually want to do something which um I
have learned something that now that
people kind of like to do robots so um
so let's start putting this together so
we can actually build on a robot so for
this what I did was I took a robot far
that I built for my kids to program and
then to make it a little bit more
impressive here I instead of putting our
dueno on I put a Raspberry Pi and so it
has a Raspberry Pi on it and then they
wrote the code in Erlang but how you get
started building this frame so so this
frame is actually very popular frame for
building hobbyist robots this is called
a sumo bot frame um the nodejs community
um start something called node BOTS
where where they go to conference and
actually build frames like this except
without the camera and without the
Raspberry Pi they do it without doing
this but they and then control from
their pc but they publish the plans to
make these so these are laser-cut plans
um if you can find a laser cutter and if
you can go if you have a local
makerspace they probably have one so
these things are like hard work um like
shop for programmers seriously it's it
actually makes shop class would have
made it a lot more fun um so the laser
will cut it out it'll be perfect and
then you can just assembly so that's
that's that piece so let's get back to
the software um now the next part the
important part with software and
especially with erling is how are you
going to control things and i'm giving
this the these next couple things are in
are in general far of these open source
projects that are available i know from
searching google that there are many
others um these are the ones that i have
used so early AL the AL projects which
you may recognize they've actually been
prison in the past here those are for
interfaces like gpio i squared c and spy
on those of you who are not familiar
with hardware all i did once you look
for our little device those acronyms are
going to pop up all over the place so
just to remember match
there's another package called Erlang
serial so if you want to communicate
over a serial port and so this would be
for example GPS chips tinda tend to like
to communicate via serial but there's
also many other things that like to
communicate via serial so that's package
called Erlang cereal there are many
Forks of this package and I think this
one this one certainly works I think
this is a good one ah so that's where to
look so all right getting back to the
robot um now I just want to explain so
we're doing this in the context of a
what's basically a toy robot but a lot
of these concepts transfer to industry
so even though I'm explaining something
that you know it's kind of silly and fun
and a lot of this stuff is very similar
although I'll be it on a bigger scale so
so this this robot arm uses servos far
for the motors and servos the way they
normally work as you tell them tell the
servo which angle you want to go to you
want to go to 45 degrees it goes 45
degrees 90 so if someone figured out
that if they they removed a sensor
inside the servo they just make it a
motor and sell it and they actually sell
ton of these there they're really messed
up servos but that's okay having a
geared down motor in a standard package
is very convenient for in the hobbyist
field so so these mount very easily on
there and then you can concentrate on
controlling them and so the way their
control is you send pulses to them so
it's very simple there are three wires
to our for power once the signal and
that signal wire you send pulses and
each pulse is about 20 milliseconds
apart doesn't doesn't need to be perfect
on the duration of that pulse is is
what's key and that duration of the
pulse is measured by the servo and it
determines whether the servo goes one
way or the other way and that's if you
have it one half milliseconds stays in
the neutral position and then if you go
up to two milliseconds it goes one
direction down the one millisecond goes
the other arm that's a general idea this
is a whore
real time um thing this this one half
milliseconds you have to be within
microseconds or other I sister will go
and look then it's it's no good you'll
see um so I'm going to I'm going to go
in a little bit about how you control is
because I think that for none hardware
people are some confusion possible here
on control strategies for some of this
hardware that will make your life harder
than it should be so an obvious strategy
for this so you make these pulses so one
I just say gpio gpio is just you can
turn a wire on and off so let's just
turn the wire on sleep a little bit turn
the wire off sleep a little bit more and
repeat um so you can imagine this well
this is called software pwm and doing it
in Erlang well there's so many problems
it um the this timer sleeps not going to
give you sub millisecond accuracy anyway
so that's going to be done but there are
tons of context which is it just won't
work some people do it in the c-arm in C
language and do a little bit better job
of it but when you're running on a Linux
system at least when you get the devices
that are you have to make some more
guarantees about how reliable they are
Linux has well it's optimized for
through point and while it has real time
extensions you find yourself going
through all this complexity so um
software pwm is something that i shy
away from um even though i know a lot of
people have libraries in this and but
it's safe Erlang's not going to not
going to come close especially with
these micro processors to doing this the
the other arm the next approach which is
nice to take is to use Hardware pwm so
you're turning a wire up and down well
that's so crazy simple even a hardware
guy could do this and put on the chip so
they can do this and put it on the tip
but then they only put one or two and
it's kind of like well I kind of need
more than that oh and then and then just
to make matters worse the the how that
Tom turning on that wire on/off is
different all the time I
boards so you have to have a linux
kernel driver which even though they
have this generic framework for doing it
oh well the Raspberry Pi the mainstream
people using the raspberry pi don't use
it but it's it's just it's it's kind of
a frustrating mess so I didn't do that
so so um here's here's the approach that
I tend to take on for our lobbies hard
real-time this is being this is
simplistic on this one but it scales to
others and that's just use a
microcontroller so it's C programming
but it's really easy so so compared to
what you guys do in in early this is
like pretty easy stuff um to program
these microcontrollers and some of these
chips like on the BeagleBone black they
have the microcontroller built into the
main ship so you actually don't need to
buy one but raspberry pi didn't have one
so i had to buy one so I I spent money
on the 80 tiny 85 which you may have
heard of the atmega which is used on the
arduino's so so there's no you know
professional home in bed its software
engineer I'm not I'm not sad about using
the Arduino IDE and neither should you
um to do this stuff because it really
does make this stuff easy for the
problem is trying to solve okay so
that's so I use these chips you guys
probably can't see it on here but um
it's connected to the raspberry pi over
a bus called i squared c and i'm going
to show you guys how that works oh and
then on the other side it's connected to
the servos so here's a here's a picture
showing the connections on this on the
spot so there's a little purple board on
this top so you can make pc ps4 three
dollars this is a three dollar PCV so
it's just connecting wires effectively
um according to this all schematic so so
the the robots are power or battery
power for four double A batteries you
need to have good power to the Raspberry
Pi so what you do is you just buy one um
if you go to like pololu they'll sell
you little regulators for whatever
voltage you want and it will if the
batteries discharge you'll bump bump the
voltage up to 5 volts for the pie if you
if you happen to have a good charge in
your batteries and some and you get over
5 volts it'll bump it down so so so
that's so let's go to the Raspberry Pi
the Raspberry Pi model life right there
it's it's communicating via i squared C
to the 80 to 85 and then the control
signals are being sent to the servos I
also edit since I had a microcontroller
you can I could I can check battery
level so checking battery level is just
a matter of using what's called an ADC
analog to digital converter so all it
does is you can ask that pin how many
volts are on it so that's how I did
figured that might actually come in
handy if my batteries are getting low so
I put on there and that's also another
thing that for many reasons some arm
processors like the raspberry pi don't
have a dcs on them so you don't have to
go through an external chip anyway
alright so let's talk about the I
squared C so this is sending messages
back and forth to hardware and this
actually maps surprisingly well and I'm
going to give a little demo for how this
how this maps into early so what you do
on I squared C is it's it's a bus
architecture and you can have multiple
chips on each chip has its own address
so i have to pick a chip pick an address
that's what you do so I picked the dress
for there's nothing magical about for I
just picked it um the protocol um far
far communicating over that is is
implemented per chip but there are
conventions and when you start using
these chips they'll get familiar to you
but basically it turns out that that you
read and write register so the tip
exposes basically block of what looks
like memory addresses and they just call
each index each byte offset I'm a
register and you can read or write them
and what you do is you know the first
thing you do is you right um write a
number and and the the destination chip
will say ok that first bite that you
wrote that's going to be the register
I'm going to start at so so say you say
I've right to
and then then the next bites that you
read or write will um will read or write
from that the second register and then
auto increment so that's yeah okay good
so then let's let's just show this up
slowly all right so here this is this is
going to be what I'm going to do is make
the nerves project that can read write
this this servo and so I'm going to do
this in elixir um because i'm going to
use elixir al and it also so happens
that that elixir makes some things um
surprisingly easy for me to do live so
as with every um elixir project what you
do is you do mix new and then let's just
mix knew that so so I'm in here have my
had my project and what I'll do what so
if I what I want to do is I want to add
the mix file to the mix file my
dependency so I have to hear the first
one is um is x RM so I want to make a
release right so the way with the liq
sir to make releases there's there's a
tool called xrm which is amazingly
convenient so all so we'll just add that
on to the dependencies and let's see let
me just get that
and then the other arm library that I
want is elixir hail solo so let me add
that to the pin sees okay so I have that
part and then let me just said to get
Alex RL into the application enough to
put it up here alright did that now
that's it i'm going to do another thing
so this is the mix new gives you kind of
a stub of an application so didn't to
make this to make this slightly less
non-trivial i'm going to start norm the
i squared C process from the supervisor
so the I squared C process what's going
to do I'll handle all the communication
to and from that eighty tiny and let's
see the way that we do that is so I'm
opening up this and hopefully for you
for the Erlang guys out there who maybe
haven't seen elixir will kind of see
some familiar you see ur with the
application and starting up the
supervisor and then I'm just going to
add a worker here and then huh far um
elixir ale that's going to be this this
the i2c arm and then it's going to take
a couple parameters the first parameters
which I scored c-bus that you want to
use um you look up the documentation
raspberry pi says use I squirts the
hyphen one and that's so so that's what
we use next parameters what's the
address of the device so that for and
because I'm used to seeing these
addresses in hex I just put them in hex
um and then let's just register that
just so I can get to it in the shell
okay and then the last thing that I'll
do is I haven't makefile helper to try
to make this this easier and said
oh forgot to do this there's one
important thing when you cross compile
and all the stuff is you have to have
your environment setup right so let's
alright so and I'm just typing might
make make is just going to do um makes
get the depths dependencies and build it
on there is actually a big hex win um
hex is the package manager so I don't
know if you guys noticed this I'm not
connected to the network and it got my
packages and built it turned out it was
in cash and this blew me away the first
time I built without any network access
I just had assumed it was always going
to the network so so I'm so we built the
app it's going to start the I squared C
so I'm going to put in an SD card okay
and good news about this SD card is
apple red program that so i can do the
upgrade
alright so it upgrade it now let's now
let's go over to see let's try this one
so we'll plug this in and actually since
we're not dealing with the camera for
this part I don't need to have that on
but I will connect the serial cable so
you can see what happens let's power up
ok
so it's powering up
and all right so same thing except i'm
wearing the liq sir now and so now just
the API for for reading from my squirt
see just to send the message to get to
get some bites just type I to see to
read and then let's see we're going to
do but I to see and let's get six bites
and it got six bytes so so this is um
possibly a little hard to read but um
but the the first two bites the left
servos um duration that pulse duration
in microseconds and actually let me just
see it actually I'll just skip this so
uh ah so we can keep on doing this in
and keep on reading this but you'll
notice one thing I didn't write to see
which register I was going to head so
you I'm reading these bites and it kind
of doesn't make that much sense so um
alright doesn't make much sense because
the Tom the registers that you get keep
on getting different registers this is
like a common mistake yes so um the the
trick here that's it right
let's see is is just a to use another
function just to write first and then
read and this is very common oops well
we actually had a blip there um this is
a very common thing just write the
register to read the six back and you'll
see that you get those back so that the
last thing I do I want to do just before
I show the bots actually running is just
to actually show that you can write them
so the first step is what let's just say
that we want to turn the the left motor
and then let's let's do let's do let's
see let's do this direction and we want
to always I switch between Erlang and
elixir and I always forget the bits in
text so so what this is all this is
saying is right 12 hundreds of twelve
hundred microseconds to turn the wheel
so that's going to turn it one way and
it's little endian i squared cities
always a little endian for some reason
or almost always a little indian and 16
bits and enough you can see it but start
turning and let me just stop it home so
that's the basic idea so you can simply
turn the wheel so so what's so I'm going
to to quickly skip to the rest of the
pieces because those were the important
ones i want to show you guys because if
you can turn a wheel you can actually
get really far so um I mean fully the
next step is really just turning the
second wheel almost and then it's all
stuff that you guys are are very useful
oh I'm used to so the next part of this
is to control via the web so I just
hooked up may use the cowboy sample app
almost directly to have a little web
socket control um you know which way the
wheels turned and then i reused last
year's last year's i gave a presentation
on setting up video and video on these
is motion jpeg streaming the frames
turns out that there's this multi-part
buying trip trick that you can do with
browsers to make things really simple
it's totally not scalable to anything
outside land but um but it works inside
land just fine so let me just
get this other guy going
yes you well it could be this one
I have to look to see which wich 1i just
hooked up
let's read another one see if you food
alright
but one thing I can do well this guy
this guy boots um or or I forgot what
his number is all I can try to answer
any questions because I know we're
probably getting close on time right
okay so um Oh actually I know it's I
know
the one thing that I forgot did you when
we had trouble ethernet always helps and
also love you just make sure I get the
right one yay okay good all right so
that one's this guy and and I can try
from around carefully so oh alright I
will not dry first person oh I'm on the
table but you can kind of so there you
go so that's turning a wheel two wheels
and then connect
right so I guess we're all the time but
i'll be around here if you guys have any
questions oh sure you know you know what
erling is tolling the noise i mean it's
it's kind of amazing there are a lot of
other things that stuff that takes power
on this so um the the motors I'll take
tons with the robots off if you're just
running this Raspberry Pi model a when
I've measured it it's taking about 100
milliamps if if Erlang's cranking which
cranking for me maybe shot up like ten
percent twenty percent so compared to so
that's 100 milliamps the motors will
bump it up to three or four hundred
milliamps and the Wi-Fi another couple
hundred so so I'm my view on Erlang for
this is it's in the noise compared to
the other pieces anything else yes the
sensors every now and then you fail yes
yes how is Erlang this this is this was
really this is a really great question
so so how does Erlang and elixir help oh
and i have an example from last year so
last year I built the kit this camera
and basically woodstream basically it
was the same as this one so it worked
flawlessly when I demoed it and I
thought and then I went and looked at it
and the Seaport had actually crashed and
restarted and I didn't know it so so so
that was that was a huge huge win I mean
a lot of this a lot of this hardware
stuff sometimes goes bad every once in a
while I mean we try to engineer this so
it doesn't go bad they're like that you
know so they would last a little bit
longer than that but
um recently recently um restart of
individual components is is pretty good
for most this stuff when stuff fails a
little bit more often there's usually
electrical issue that's behind it and
and those can be resolved through some
work or worked around with some
robustness to the communications
protocol alright</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>