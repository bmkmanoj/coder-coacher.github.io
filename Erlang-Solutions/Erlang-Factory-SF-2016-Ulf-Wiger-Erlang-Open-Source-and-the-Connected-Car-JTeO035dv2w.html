<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2016 - Ulf Wiger - Erlang, Open Source and the Connected Car | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2016 - Ulf Wiger - Erlang, Open Source and the Connected Car - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2016 - Ulf Wiger - Erlang, Open Source and the Connected Car</b></h2><h5 class="post__date">2016-03-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JTeO035dv2w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yes let me just mention a little bit
first about Geneva you most of you
probably haven't heard about that before
Geneva where I VI stands for in-vehicle
infotainment which is essentially just
about all the interaction with a
dashboard and and radio navigation
whatever in the car and Jen probably
stands for generic it's it's an alliance
with including a lot of major players in
the auto industry to try to create an
open source platform for ivi and making
that a standard and this has been
growing for some years and there are
already actually a number of models
around the world that have that are
being sold that at least use parts of
these reference components and well you
all know what the situation is basically
with you know the car and your cars and
electronics you have usually you will
use your iPhone or tablet and Google
Maps rather than the onboard navigation
system actually in i would say that or
studies show that several of the
features that are actually sort of built
into the car in terms of infotainment
are not being used by almost half of the
people using i mean there are there are
number of features that almost never get
used and part of this is because all the
manufacturers so far have basically
to try to build this themselves from
scratch and it's an extremely
complicated system of systems and lead
times are too long and it's very
difficult to understand or to foresee
what is actually going to work when
things when these cars hit the market
and the realization this has led to the
realization that they have to do this
together and it's not about competing
with the iPhones and androids it's
rather trying to create an environment
where the consumer electronics actually
can be integrated or cooperate with the
car electronics in a way that feels
natural and safe and productive for the
users and exactly how that's going to
work well that I think that it's one of
the more interesting problems right now
in the industry and and they also pretty
much estimate that about eighty-five
percent of what needs to go into an Ivy
I system is generic and the remaining is
where each brand can try to distinguish
itself and and compete so just looking a
little bit at the at the members in the
Alliance some of these logos are very
small but you have players like car
manufacturers like BMW Daimler Hyundai
Volvo waving the swedish flag there and
some French and most of the major
Chinese car manufacturers actually you
have a bunch of first tier suppliers to
the auto industry and then you have
other big players like middleware
players down in the corner
there you see Erickson and they are also
represented here today and like I said
this is this is a very complicated
complex project and I should also
mention that the Linux Foundation is
also part of this a major player in
Geneva and basically what they they call
a GL automotive grade Linux so part of
this push is to do just about all of
this it's open source and use Linux and
the cars use reference hardware and
create reference components for all
these things also allowing obviously
different vendors to then add their
proprietary code so what I'm going to
talk about here is our VI which is one
part of the networking area remote
vehicle interaction so the idea is to
the big things that we're trying to sort
of support is obviously control being
able to invoke services operate on the
on the vehicle or whatever a and also
pushing data to to the cloud big data
analytics whatever and soda which is
software over the air that is software
update and the main thing I'm working on
is the transport component there and in
order to support these requirements what
we're trying to build is or what we have
built is a peer-to-peer sort of multi or
transport agnostic or less or multi
transport system that supports service
discovery authentication
and authorization so basically we can
take the next picture that say you would
have you could have services in the
cloud services in the mobile device that
is the the car or this is pretty generic
so if you're not interested in cars you
can think other areas where you would
have similar use cases and you could
have on your mobile device one of the
demos we're working on is door lock
unlock extremely useful actually it's
kind of cool and it's especially cool in
the demos when we have very nice cars
everyone everyone wants to be the person
who gets to unlock the sports car and
drive away so we have different types of
transports and in order for this to work
we also have to support not having
internet connection at all so in some
cases you might be able to reach the car
with an SMS so that you can possibly
rely on GSM working at least in other
cases you may have your mobile phone and
a Bluetooth connection and we're also in
some cases there may not even be a
connection at all that you you basically
just have to do manual interaction but
that is a slightly different case so for
security we are relying on open SSL
x.509 certificates and on top of that we
also use something called we call
credentials which is our own little data
structure that explains what kind of
services I can invoke I am allowed to
invoke and what kind of
service invocation I in vacations I am
allowed to receive so for example in the
unlock case first you you'd connect over
an SSL connection typically and you
would exchange credentials and then you
would try to send a an unlock command
and the vehicle transport component will
verify that you are actually authorized
to issue for example an unlock command
and once you get that far it will
trigger whatever interaction is required
so in the demo you would typically have
a Raspberry Pi that fakes pressing a key
fob and the car is unlocked so in order
for this to work robustly the system
needs to be able to choose between
different transports and also needs to
be smart enough to not for example send
a software image over a you know roaming
GPRS network or something so you need to
be able to put in conditions so that it
can be rate aware and things like that
and you can also do some basic routing
so that you can either go point-to-point
or go via some service that can then
forward the request so I'll go through a
couple of scenarios that that we're
working with one is software
over-the-air upgrade now part of this
obviously is is standardizing the whole
procedure and the components in the car
and everything so that this can be done
in a generic way but here you would have
typically a server in the cloud that
manages that keeps track of the
different software component
in the different versions and then you
would have a soda client in the vehicle
that understands how to implement the
actual upgrade inside the car and the
workflow would typically typically be
that you cue the software update
obviously you have to be sensitive to
when this is actually done it's
preferable to do it when the car is not
driving down the highway for example so
you transmit the software to the vehicle
obviously these are large software
images so that kind of that would
actually impose some new restrictions
you don't probably don't want to send a
couple of megabytes and have it fail
halfway through and things like things
like that we'll get back to that so
another demo that we have is the mobile
unlock as I said now this would be very
generically use any smartphone to unlock
any vehicle well provided you are
actually authorized to unlock that
particular vehicle a use case could be
that someone wants to borrow your car
over the weekend or there are some
services where you can actually register
your car for peer-to-peer car rental
where you would want to authorize
somebody to actually open your car and
drive it for a while so then what you
would want to do is you want to send
them a virtual key that they can store
on their smartphone so then when they
get to the car the car detects that
they're there or authorizes them and
lets them in so we have then is a key
management website a demo again which
provides a credential signed by using a
root certificate that is also installed
in the car so that it can be validated
when when the device is connect that
this credential is actually signed by an
authority and this is where we use the
root certificate to verify that so we
have this implemented on Android and
iPhone and the demo software in the car
runs on a Raspberry Pi and using just a
simple key fob so we somehow managed to
transport the credential to the mobile
phone which stores it in the app which
can be surprisingly difficult on iOS but
it's doable when the the phone
approaches the vehicle either you use
bluetooth and the car can detect where
you when you're in range we also had
some Christopher Keenan Oakes go over
there can talk to you later about the
fun how fun it is to hack the Bluetooth
stack to make sure that it can sense
your approach vector to see that you're
within a good range of the car not
necessarily you know 40 40 yards away
but actually being fairly close to the
car and approaching it and then you
actually connect over Bluetooth and
and then when you connect there is a
handshake credentials are transmitted
and then after that you can send the
unlock command another use case would be
for example to deploy a probe in the car
yeah owners of a certain make for
example have reported problems perhaps
intermittent problems or whatever as
they're driving and then you you would
prefer not to just recall all cars or
just hope that you will be able to
detect this scenario maybe it only
manifests while you when you're on
driving on the highway and only
sometimes so you're not likely to detect
this in the in the auto shop so then
what you can do is you can deploy a
probe that starts collecting data and
passes is up to the that up to the cloud
and this could be also some third-party
entrepreneur perhaps working with car
sharing whatever and they want to track
the usage of of their cars they buy what
we call a v2x board here's a v2 export
that one that's a normal Raspberry Pi MV
2 X stands for vehicle to vehicle or a
vehicle to infrastructure for example
and they implement their service on that
and the purpose of that board is that if
you can make it work on that then you
can talk to our car manufacturer later
and the same and that architecture
should be compatible with what's in the
car so then it that way you can
you can run your you can install your
own stuff and and run your own demos or
prototypes or your own services and then
there is a standardization pack so the
v2 export looks like this currently it
has an accelerometer a modem and those
are antenna sockets so you currently we
get the GPS we can get the GPS signal
from from there you also have a power
management unit so you should be you're
going to be able to send for example a
wake up SMS so that this can power up
the the Raspberry Pi there is a canvas
interface so it's a reasonably nice
board the version 2 will actually
combine these two into one board and the
design is open source so if you want to
manufacture it yourself you can go ahead
and do that but there are also going to
be there are places where it can be
purchased so health monitors where for
example you would if you're an oem you
would use the reference implementations
that sort of built into the car if
you're an entrepreneur you would you use
the v2x board and as I said these are
compatible other things would be for
example tracking feature usage or
tracking Bluetooth problems for example
that it is actually a very common
problem reported by a car owners that
the blue
is not working as it should so those
would be some use cases I mean these are
basically the demo use cases that we're
working with now but the whole idea is
to provide an open and stand eventually
standardized interface and that actually
is usable for entrepreneurs third-party
providers service providers in the cloud
people who want to actually install
stuff in in the vehicles or wherever so
just looking at the RBI transport this
is implemented in Erlang which is a
reason why I'm actually standing here
and talking about it the architecture is
you have a various components this is
the service edge is where various
applications would talk to the transport
or the RVI core and this would usually
be currently it's either json-rpc or wet
over HTTP or WebSocket now the service
edge will talk to the authorization
component which verifies the credentials
this schedule component here is actually
a form of a router and store and forward
you have a service discovery which
shares service announcements with
connected nodes and then you have the
data different data link layers and I
would say the the fully all the features
implemented in the Erlang implementation
are usually not available in the in the
cell phone sdk but also
typically what you would want to do for
from your cell phone is just connect to
a vehicle or to a certain to a service
and get authenticated and then invoke
some services now the handshake protocol
first a standard TLS upgrade we mostly
use self-signed certificates and have
the root certificate installed on the
RBI core node so once we have validated
that now if you use this is if you use
TLS we also have a TCP transport where
we just skip this and that would be
mainly for development because obviously
it is no longer secure but it allows you
to to implement and test your the rest
of the stuff then you send an
authorization an authorized message
which includes the credentials encoded
as JSON web tokens and signed using the
root certificates private key so they
can be validated using the root
certificate public key which the RVI
node has so once you have that you can
look at the credentials and figure out
which services to announce to the other
side basically the services they are
allowed to invoke are the ones that
you're going to tell them about so then
you send service announced messages and
on the other side the receiving node
will look at those services it will
check authorization against the the
credentials that it has and cash them so
that it can quickly approve service
implications afterwards
it sends now these authorized commands
go both ways also the service announced
messages go both ways so it's it's a
peer-to-peer and after that you can
start invoking services and that's
called a I think receive command I think
it's called or message don't remember so
the credential would look like this you
will have some time stamp validity time
stamps some IDs and issuing organization
but these are the things that control
the what you're not what you're allowed
to do the right to invoke these are
patterns matching various services and
usually they will look like manufacturer
and then some vehicle identification
number for example and possibly a path
beyond that so each node will have a
sort of a service prefix so when you
register services say I register an
unlock service that will be appended to
that nodes service prefix and that's the
full name that you would use in order to
invoke that service right to receive is
which service in vacations I am
authorized to receive so then it's up to
the other node to make sure that it
doesn't allow service in vacations going
to me if I am not authorized to get them
now for large packages and reliable
delivery this is all asynchronous the
service in vacations are send and pray
basically so but if you want reliable
delivery you can use the fragmentation
support and that basically works like
this you first send our first fragment
now that could possibly be the whole
message depending on how you've
configured it you you can configure it
using a max message message size but you
can also turn it on by just saying I
want reliable delivery and then it will
send the whole package as a fragment
saying this is the message ID this is
the size of the message and here's the
offset of this fragment the receiving
side will take that and it will try to
reassemble it and check whether it has
the entire message if it has the entire
message it will just send a fragment end
which is the acknowledgement otherwise
it will request the next fragment and
then it will provide an ID and the
offset and how many bytes it wants and
then you will send more more fragments
so in the reassembly you basically
identify holes in the package if there
are fragments that have gone missing and
then you request you can request them
again what would be nice to have that I
haven't implemented yet is timers which
is obviously a pretty serious defect but
so the service edge API you can register
services on register services you can
ask what services are available and you
can send a message which is basically
the service invocation will you name the
service you can provide a timeout and
parameters and these are more the
eternal API service available service
unavailable handle remote message that's
a message that comes comes in from
another node or a handle timeout I have
planned to implement message pack RPC on
the on the service edge since it's a lot
less overhead than json-rpc we are using
message pack encoding between nodes or
JSON if you want but sending especially
sending large packets over JSON is
pretty pretty painful in terms of
routing right now we have pretty simple
routing logic but you configure that
basically again matching on the service
prefix and then you have protocol
modules various options and this is
basically you will try from from the top
going down and for each matching
transport option here you will try to
see if they're available and you will
just go down the list and usually you
will have a catch-all down here but if
if there are no matching transports or
sessions then you buffer the message and
then you will try again if if transport
becomes available right now we're in
also implementing netlink subscriptions
so that we can detect when an interface
comes up and so that we don't have to
sit there in and retry or poll
periodically to try to see if we can get
out and what we're going to do is we're
going to expand this so that you can
also
sort of configure and match on rates for
example we'll see exactly what what will
be useful so that is basically it the
status is we are recently released
version 050 it's on github it's using an
mpr license MPL 2 point 0 which is we
think is a fairly fairly good license
for those for those of you who are not
aware it's it's kind of like the apache
license but it does force you to publish
your contributions so you are allowed to
do whatever you want with it but you
need to you need to make your it's kind
of like the Erlang public license used
to be so we believe this is usable for
pilots and we're going to start running
more serious pilots pretty soon and and
are developing our demos we do build
Debian packages and the recommendation
by the way is to use the Erlang
solutions packages for OTP r18 dot to or
or later we also build raspy and
packages unfortunately ESL is not hasn't
updated their raspy and packaged in a
very long time so I think but we do have
some build instructions it is quite
doable that you have to be M it would
certainly be better to have a
raspy an OTP package there is an
automated test suite using common tests
which test Suites can always be improved
upon there is an Android SDK and an iOS
SDK there are some Python support lives
for registering services and and
invoking services and they are at least
sort of a starting point to play with we
are also building some demos using Lua
so the idea is basically to be very open
about from which clients and which
languages you can you can use this
saudia the fact that the core protocol
is implemented in Erlang is is not
something that people will have to worry
about and I guess you could now some
ericsson people might cringe here but
actually the way it is implemented is
that all these components are at least
theoretically possible to break out so
that they can run separately and so
these api czar have sort of a JSON RPC
implementation and hopefully soon a
message back RPC implementation because
you get quite a big performance hit when
you go from using a gen server to using
JSON RPC to communicate but on the other
hand it would allow you to to distribute
and and get better scalability that way
but it would also allow you to break out
certain components and implement your
own logic and that's actually a sort of
an environment variable configuration
part where you tell it whether it's just
an internal the internal implementation
or whether it's using JSON RPC and then
you just provide an address for it and
and all the everything should work the
same I will say that this is not
something that we have actually tested
in the latest release it did work in in
a previous release and if it doesn't
work anymore it's probably just because
we've accidentally broken something so
it's 050 we're not at one point 0 yet so
there are a couple of a couple of things
like that that if any of you would like
to try that out I'd be happy to have you
send bug reports I could say that what
could I say yes
so yeah that didn't work so i guess so
most of the communication in vehicles is
through can buses and whether it's going
to be ethernet in the car i actually I'm
not sure so I sort of at the the face
where where I'm working that that's not
really something I I get involved with
and in terms of the the RBI transport it
doesn't really eat and doesn't really
matter yeah
no no that's the the RBI communication
is not going to go over the canvas but
whether it's a it's wireless or it's
probably going to be something like
ethernet or whatever but I mean that
would be up to two each manufacturer as
far as usually for the RBI course of the
what would happen is that this transport
is mostly for outside services or
devices communicating with the vehicle
and then the service that is registered
to RBI core and gets invoked right now
through json-rpc it is responsible for
actually interacting with whatever it is
so in the unlock demo for example that
is just a Raspberry Pi board where the
GPIO pins are connected to a key fob and
it will just manipulate the key fob and
unlock the door so and in that sense
it's just RF from the key fob so it's it
depends on what kind of and and if
you're using the v2 export you would
connect to one of the canvases depending
on which one depends on what it is that
you want to what you want to do and I
could say that we are for example
implementing trying to specify a
messaging one thing we're implementing
is a can firewall because if we're going
to invite a bunch of different
third-party services to communicate on
the canvas we would like to be able to
control what they actually do so we have
a reasonably well working can canvass
firewall we're also specifying a message
passing interface for if you want to
pull tons of data and it can really be
at an enormous amount of data from the
vehicle we found that most of the third
party or the existing messaging
solutions are simply too slow we will
use d bus for example for the
administrative or the control signaling
usually in the cart but the bus is too
slow if you if you want to pull tons of
performance data from the car so we have
something right now we have some
prototypes where at currently when we
are able to do sort of a publish to 30
30 threads listening in parallel at a
rate of about eight million signals per
second which we think is reasonably good
I think with just one thread it's like
18 million and I don't know exactly what
r VI core is going to do when when those
messages you're going to have to filter
in aggregate before you you push it out
over the Internet obviously I was going
to show you but for some reason the
screen didn't want to talk to my ubuntu
vm but in terms of performance i can say
that a in my test suite I for example
have one test case where I fire five
service in vacations in parallel that go
through two RBI nodes and loop back to
JSON RPC server running in the test
common test environment and that usually
completes in a couple of hundred
hundredths of a second something I board
Millie a few Miller 30 milliseconds or
something I don't remember exactly the
yeah so what we've seen so far in the in
our demos is that for example if we are
controlling the HVAC the actually Mike
my clock was reset so I lost track of
the time yeah and so we've tried to do
there is that if you for example one of
you want to update the air conditioning
or you want to display control the FM
radio from your from your phone what we
would like to do is to have this be fast
enough that you can actually sort of
individually update widgets on your
display without feeling that it's there
is a noticeable delay so it's not
supposed to appear slow and so far that
seems to actually work and we've done
some optimizations since then so at
least it's it seems fast enough that you
can have a pretty good interaction with
the car for example over Bluetooth from
your phone to or Wi-Fi from your phone
to whatever a you want to control on
your dashboard so I'd be I think it
would be fun to discuss other possible
uses of this we discussed for example
home automation I'm staying at an Airbnb
apartment I can imagine a couple of use
cases there were you you kind of you get
authorized right now you get a pin code
to the the door so that you can just
unlock the outer door but that's that
kind of it and then happily they have
provided a Wi-Fi password but I mean
there are obviously a lot of things that
that could be
implemented using this kind of service
invocation and authentication
authorization framework any other
questions and i'm sorry i forgot to
repeat the questions but they were
spoken so loudly yeah okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>