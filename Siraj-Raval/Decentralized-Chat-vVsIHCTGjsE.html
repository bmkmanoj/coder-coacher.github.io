<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Decentralized Chat | Coder Coacher - Coaching Coders</title><meta content="Decentralized Chat - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Siraj-Raval/">Siraj Raval</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Decentralized Chat</b></h2><h5 class="post__date">2018-03-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vVsIHCTGjsE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello world it's Suraj and we're going
to talk about a peer-to-peer chat
protocol so you don't need to use a
server and this is what aetherium uses
it's a protocol called whisper and I
have a demo of it right here so let's
check it out so my name I'm gonna put
Suraj and then I'll put the chat as
hello world
I'll hit Send boom and if I have another
peer in the network it's going to send
that message to that peer no server
involved from one pair to the other
peer-to-peer and I'll me send one more
message hello again and we send it so in
this video we're gonna look at this app
at the very end the code
programmatically but before we get there
we've got to talk about the architecture
of the whisper protocol because it's
very important to the web 3.0 stack so
that's what we're gonna do at the end
but let's start off with talking about
this stack so recall that before I
talked about the consensus layer and the
consensus layer is the ethereum
blockchain so what it's used for is for
the network to come to consensus
specifically any kind of DAP that you're
building it has to come to consensus on
what are called application level
constructs these can be user names
tweets timestamps anything you knit the
anything you need the network to agree
upon that's when you would use a
blockchain so that's one part of the
stack so look at these three gray boxes
here the other two boxes one is for
whisper and that's the messaging stack
right when you need your app to
communicate with other apps depths and
then the third is swarm which is the
storage layer which we're going to use
IP FS for which we'll talk about later
but right now we're going to talk about
whisper since we talked a bit about the
EVM before and we'll talk about that
more as well but let's let's get right
on into it so if we look at the etherium
stack clearly they've had whisper as a
very crucial part of the stack notice
that the smart contracts live on the
etherium consensus layer swarm is used
for file storage and then whisper is for
dynamic communication between peers
peer-to-peer right so it's a
communication protocol for adapts to
communicate with each other and the main
feature that Whisper has that other chat
protocols don't have is dark
so what I mean by darkness is no one can
trace who you are if you send a message
to somebody and even if they receive the
message and it's meant for them they
have plausible deniability what that
means is no one could could tell that
that message was sent to them and you
might be thinking how is that possible
if that message lives on their computer
of course it was meant for them well
the way whisper is set up is such that
messages are continuously routed between
all peers whether or not that person is
the recipient they will receive the
message and forward it along and I'll
talk about that in a second it uses
darkness as a feature but it comes at a
high cost and I'll talk about that as
well so remember this is happening off
chain this has nothing to do with the
blockchain this is just a peer-to-peer
communication protocol
and we can think of whisper as kind of a
distributed hash table so a hash table
has key value stores it's the data
structure a distributed hash table is
the same idea except the stores of
values are distributed across a network
of peers so we can think of it that way
because messages are the values that are
being key to end via the identity of the
peers in a distributed way the nodes in
the etherium network or we can think of
it as a Datagram messaging system
peer-to-peer messaging system you could
think about it different ways but it is
a messaging system that lives in a
distributed network so this is just an
example of a bunch of nodes there
passing messages between each other so
the way whisper works is that every
message is delivered to every node so if
I'm if I'm a node in the network and I
want to deliver you a message I'm going
to first send that message to my nearby
peers and what's gonna happen is this
message is meant for you because you
have a key that can unlock that message
you and only you have that key but
regardless of whether or not it's meant
for you I'm gonna send it to all these
peers why for darkness because these
peers no it's not for them but they're
going to receive it anyway and they're
gonna forward it to their neighbors
until eventually that message reaches
your intended recipient right so that
the point of this instead of sending it
directly to the recipient is so that
it's untraceable
and once the recipient receives that
message
the recipient will then forward it on
any way to other peers nearby hit to
completely have it be a dark protocol
now we can configure how dark we want it
to be in that we can configure how much
we want to give up in terms of speed and
bandwidth and computational cost in
terms of preserving that kind of
identity hiding right so knows our
message to neighboring nodes etc and
it's an identity based messaging system
so everybody in the network has an
identity this is a unique key that's
generated by it
the sha-256 hashing algorithm so at its
most secure mode of operation it can
theoretically this deliver 100% darkness
so there's a trade-off though between
the level of privacy you desire and the
performance it's included by default in
the go etherium client death under the
peer-to-peer package p2p and so
crucially in order to prevent ddossing
so if you think about this idea of how
the messages are being routed you might
be wondering wait a second can't someone
just spam the network by sending
millions of messages to you all the
peers and then it's just gonna call some
of the peers to go offline because of
the amount of bandwidth and storage it's
requiring even though it's ephemeral
well the way they prevent that is by
using a proof-of-work algorithm so
messages will be processed it processed
and forwarded further only if the
proof-of-work
exceeds a certain threshold otherwise
they will be dropped so all the nodes
are performing a proof-of-work on the
message so there's a kind of
computational threshold to the amount of
messages you can send and this prevents
spamming the network so what are the
youth cases of with of whisper so what I
have here is a diagram of a
decentralized game specifically HS and
so notice that there are two players in
this game and these players are using
the blockchain for the application level
construct what do the players have to
agree upon think about it for a second
they have to agree upon the state of the
game who's winning who's losing
how many pieces is each player have in
the game we can store that meta metadata
on the blockchain right when it comes
the actual storage the heavy loads of
you know what these objects look like
and the the shades and all that that we
can store in a distributed hash table
like for storage right swarm but when it
comes to whisper whisper is used for
them to communicate with each other as
in okay we see that this player is in a
new state let's sign the new state and
increment the move count and tell the
other player right so it's kind of a
message passage passing framework and so
the apps need to publish small amounts
of non persistent information with a
preset to TTL that means time to live
all right we can it can be anywhere from
ten minutes to two days right if your
dap needs that then this is a good use
case right and if your dap needs to
communicate with another one prior to
actually sending a transaction this
would be a good use case right so before
let's say two nodes want to send a
transaction to each other they need to
set up a deal right they need a settle
how much they want to send to each other
when what are the preconditions for that
transaction whisperer would be a great
use case for that right because so they
can communicate before they send the
transaction if you have a DAP that
provides non real-time updates this
would be useful as well
so remember whisper is not in real time
there is that cost in latency and in
speed to ensure darkness and status is
an example of an a messaging app lookup
status just status aetherium that is
using whisper in production and they
raised 44 million dollars in a few
minutes using an ICO and they're
probably the most widely used app that
uses aetherium today and it's
specifically the whisper protocol so
there have been a lot of existing
solutions that Whisperer has built on
for example UDP which is a similar at an
API level they kind of took bits and
pieces of these ideas from similar
protocols and just use the best of them
which is generally how good research
should happen the bit message was
another example tella hash talks they
all had their pros and cons but they
kind of tried to synthesize the best
ideas from all of them similar to how
ipfs was created but it has some really
great features so when it comes to
whisper the API is only exposed
two contracts never to user accounts
it's low bandwidth so it's only designed
for smaller data transfers you shouldn't
be sending giant movies on this thing
right just think about texts right just
strings of data there's an unpredictable
latency because there is a probabilistic
routing mechanism here so this adds to
the darkness feature that I want to talk
about right so because the routing isn't
deterministic meaning that we can't know
who you're gonna send those messages to
which order appears there's a
probabilistic aspect to it then we can
never trace back who it was or what that
route was we can't predict the route so
that's just for the darkness but because
of that probabilistic nature we cannot
predict the latency how long it's gonna
take to get your recipient and so all
API calls for whisper are contained in
the web 3sh object all of them and we
can type that into an interactive
console to get a list of all functions
and variables that are provided so if we
look at this code snippet here VAR f
equals web 3.8 filter and then we'll
have a topic this is a topic for the
message what is it about it's kind of an
identifier we'll say we'll use a get
function to retrieve that and I would
say let's get the message via the topic
and then post the message via that right
so we can get the message we can post it
via the topic that's the parameter that
we can use and we have these other
parameters as well in terms of payload
TTL work to prove etc so the payload
would be the message TTL is a ton to
live how long we want it to remain
active in storage and work to prove is
how much how much work do we want it to
require to compute that proof of work so
let's get right into the architecture
and I've got this really cool image of a
solidity extension for a visual studio
just because it's awesome but it has
nothing to do with the actual
architecture but yeah check that out if
you use Visual Studio this is a really
cool way to integrate solidity into your
IDE alright so let's talk about the
message object they're really two key
objects here when we're talking about
whisper we have the message and then we
have the envelope and so true true of
their name we can store the message in
the envelope and we send that to the
user these are just objects
so each message is accompanied by a
unique process of message sealing so
sealing is the proof-of-work algorithm
compression which is just compressing it
for faster data transfer and encryption
and this is just for security purposes
each message has a life span of up to
two days right the TTL and the
proof-of-work is using consists of a
simple sha-3 algorithm in which we try
to find the smallest number within a
given type time frame and this requires
computing power to find the smallest
number in a given time frame so it kind
of looks like this so sending a whisper
whisper message requires you to number
one create a new whisper message number
to seal it optionally you can encrypt it
and sign and supply with the topic of
your choice and number three is send it
to your peers so this isn't go right if
you if if we want it to write this and
go we could but just because the client
is written and go but we can easily
write it with JavaScript it doesn't
matter if you don't know go just just
take a look at this four lines snippet
of code so we have a topic a message an
envelope we seal it and then we send it
boom just like that right very easy four
steps then we could do the same if we
want to listen to messages right so if
we're if we are a recipient if we're
intending to receive a message we can
say well this is the topic that we are
waiting for and now we can use the watch
event listener of the whisper object to
wait for that topic to come in to our to
our network and then we can print out
what it is once we receive it very
similar to event listeners in JavaScript
so how does this feeling work right so
proof-of-work
we know that in Bitcoin in aetherium in
general the consensus layer uses a
proof-of-work algorithm using sha-256
well this one uses sha through to find
the smallest number what I mean by that
is we have to hash the contents of the
message over and over and over again
into the smallest possible number that
we can get it to via a proof-of-work
that that is the proof of work the work
that is being computed by the miner in
this case it's any node can be a miner
in terms of whisper is how small can we
make that number by repeatedly hashing
it and we can set how long we want to do
that right that's that that's that
parameter when we send a message how
much do we want
to offer the proof-of-work so the cost
of computing it can be regarded as the
price you pay for allocated resources if
you want the network to store your
message for a specific time and we can
call this the best bit the best bit is
the number of leading zeros of zero bits
in the hatch divided by the message size
and TTL and that is the proof of work
that just repeats over and over and over
and over again but it results in a
single aggregated parameter for the
message rating or a scalar what that
means is us we as developers if we want
our messages to have priority over
others then we'll need to spend more
computational resources sealing them so
we we can set that parameter higher if
we want to have priority over others in
the network meaning faster data transfer
for your message so whispered messages
are encrypted by default now if the if
here until developers encourage
developers to use their own form of
encryption on top of the standard
encryption but that just exists as a
kind of default State and they can be
encrypted either symmetrically or
asymmetrically remember for symmetric
encryption they use the same key for
encrypting and decrypting for asymmetric
encryption we use different keys for
encrypting and decrypting right public
private key pair similar to Bitcoin
right so when it comes to decryption
this takes place using a private key if
the message envelope was encrypted by no
more than one sender okay so that's it
for encryption decryption sealing we
know the kind of routing mechanism
that's whispered uses we know that it's
a part of the etherium stack when it
comes to communication between DAPs
let's look at this example I have here
about a way to send it to other peers in
the network so I've got the the DAP that
I just showed you in the browser
I've got Jeff up and running here as
well so we can see the blockchain
running but let's let's look at this so
it's using view V Yui which is a which
is a very simple framework for building
web apps right so in our case this would
be a web 3 app but let's take a look in
in this file whisper chat bue which is
really the
main code that we want to look at so it
starts off with some HTML you know
headers divs this is our chat
application here are some variables that
we are computing before the asymmetric
public key because we're using
asymmetric encryption in this example
here's our public key that it uh send a
message easily hitting this button and
then it's gonna send it to everybody
else now here is the really the the key
bit here so so now we're going to look
at these constant values here so it's
using a little bit of embedded go don't
worry if you haven't used go before it's
a very simple language I'm going to go
through it with you right now we're
gonna import some very important
libraries web three is aetherium is a
library for communicating with its stack
in general we have two libraries for
symmetric and asymmetric encryption and
then we have a hex a hexadecimal
encoding library as well so the first
thing we're gonna do is we're gonna say
okay this is our data we have some
message it's got an Associated key it's
got a private key and we're going to
create a new key pair for this data
specifically and then we're going to
return that data so now we have this
data object right so the next step for
us is gonna be to define this send
message function call right so in send
message we create a message the message
has a text it's got a name and then it
has those key parameters we talked about
before right what's the TTL it's by
default it's gonna be seven what's the
topic we're going to use hexadecimal for
the topic just for simplicity sake
what's our proof-of-work target let's
say 2.0 one remember it's a scalar how
long a hundred what's the payload and
that is going to be our message right
we're gonna stringify that message
encode it to hexadecimal and that's our
payload for the message that's what we
the data that we want to send in this in
this envelope we have another function
for updating the symmetric key if
necessary and then we have a
configuration function as well but the
really the the really key function here
is is us saying this we're gonna say get
to filter messages and then we're gonna
receive those messages as well and then
we're gonna push them right so we can
either receive those messages
or we can push those messages to other
peers and when we push them we can use
the push function right here and we
and we can print them out here we can
set our variables etc etc but yeah it's
it's it's a pretty simple protocol all
the API is available in the
documentation I'm gonna have great links
for you in the description as well but
definitely take a look at this protocol
I think it's very cool and it's gonna be
a crucial part whether it's whisper or
some other peer-to-peer chat protocol of
building adapt right we cannot store
everything in the blockchain we cannot
store anything on a server if we're
building adapt or else does not
decentralized and we cannot store
everything in ipfs we have to have some
way for nodes to communicate in as close
to real time as possible while
preserving darkness while preserving
privacy please subscribe for more
programming videos for now I've got to
go dark so thanks for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>