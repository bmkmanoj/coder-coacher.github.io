<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tensorflow.js Explained | Coder Coacher - Coaching Coders</title><meta content="Tensorflow.js Explained - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Siraj-Raval/">Siraj Raval</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tensorflow.js Explained</b></h2><h5 class="post__date">2018-04-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Nc8kZABv-KE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">make JavaScript great again hello world
it's Suraj and google recently announced
the much-anticipated javascript version
of its popular machine learning
framework tensorflow
dubbing it tensorflow dot j s in this
video we'll use it to build a very
simple web app that can detect any
object you show your webcam last year
the Google brain team developed a
library called deep Lorne is that was an
impressive contribution to the field
allowing developers to build machine
learning models in the browser and it
had a few impressive demos associated
with it like one that let any user
train a model in real time for image
classification but a lot of the code was
deprecated and buggy so an upgrade was
in order
they made it faster made the syntax more
readable and added lots of new low-level
functions to it that let developers
build very detailed models in the
browser
eventually renaming the project to
tensorflow j s if we build an AI app
using tensorflow j s it makes
predictions and trains itself entirely
client-side that means it can use the
GPU of whatever user accesses the app
and it doesn't have to be an NVIDIA GPU
Jensen you've badass it can be any kind
of GPU from a MacBook GPU to an Android
phone GPU usually to consume ML models
whether as a developer or as an end user
we'd have to install a few packages or
deal with some sort of technical issue
but because tensorflow jas works in the
browser we don't have to install any
dependencies the library is split up
into two different packages the first is
core which is a flexible low-level API
it's syntactically pretty similar to the
tensorflow Python library then there's
the layers API which is similar to care
offs it's higher level and makes it
easier to build models
at the expense of fine-grained control
over the details there's a lot of
potential for using client-side data to
help train models it really opens up a
whole new world of machine learning one
where we can start thinking more about
how server-sent events can be used to
feed rich data into these models in
real-time while operating in the browser
we can create apps that continuously
learn and even if users have only a
small amount of data to give we can use
the libraries ability to perform
transfer learning to augment an existing
models capability with new data we can
even load model files trained in
tensorflow Python or C++ directly to the
browser and because the data never
leaves the client it's privacy friendly
we can train our models on data
client-side without ever seeing the
actual data itself there's a lot of
potential to use tensorflow j/s to
create web apps that can learn from
their users you can crowdsource the
training of a music generating AI by
having the users make their own songs in
the browser have users submit articles
and create an AI that learns to write in
the same way they do or even learn from
users browsing habits to present them
with content that's most suitable for
them when it comes to installing
tensorflow j/s we don't even have to do
anything if we create a simple HTML file
we can access it by simply adding a
script tag to our code that points to
the library online then we can use the
library right under that as a test we
can write a basic HTML file that simply
prints out a tensor and in our
JavaScript console in the browser we can
see that it works no dependencies no
other scripts to run too legit to quit
let's look at some of the core
components of the library the reason
it's called tensorflow j/s is because
deep learning models are essentially a
graph of computations
that is we have some input data this
could be an image or a piece of text all
of this could be represented by a series
of numbers we feed that input data into
a computing graph at each step we
perform a series of mathematical
operations on that input data slowly
transforming it and we call the data
that flows through the graph tensors
since a tensor is a group of numbers in
n dimensions that can be one dimension
or a hundred dimensions the tensors flow
through the graph eventually producing
an output tensor which is the prediction
that it makes in tensor flow that J s
the primary unit of data is called the
tensor which we can access very easily
it's a self named a tensor instance has
a shape attribute that defines the array
shape it's found in the TF tensor
function we can create tensors of any
size we just have to define how many
dimensions we'd like as well as the
values that make up the tensor if we
want to get more specific and make the
code more readable we can use other
functions like TF tensor 1 D or TF
tensor 2 D that specify that the tensor
in question is of one or two dimensions
respectively tensors are also immutable
meaning once they're created we cannot
change their value instead we can
perform operations on them generating
new tensors but there should be some
mutability when building a machine
learning model right after all the model
must update itself as it learns
that's where variables come into play
variables are initialized with a tensor
of values but unlike tensors their
values are mutable we can assign a new
tensor to an existing variable using the
assigned method they're used to store
and update values during model training
but remember that tensors are only half
of the equation here we need to perform
operations on
them for this to be machine learning /
for us to be cool operations or ops for
short allow us to manipulate the tensors
the library offers a huge range of ops
that allow us to perform fast matrix
math on tensors easily performing
calculations on groups of numbers in
parallel and because it's a chainable
api we can call ops on the result of ops
on the result of ops on the result of
you get the point
so what does building a model actually
look like in tensorflow j/s we've got
two options the first is to use ops
directly to represent the work the model
does this is the low-level part of the
API we can define in detail every add
multiplication subtraction operation
that's applied to our tensors in what
order
how often et cetera alternatively if we
want to quickly prototype a model and
don't care too much about the details we
can use the high-level API using TF
model to construct a model out of layers
these are a popular abstraction in deep
learning adapted from the chaos library
in that a neural network consists of
layers of operations and while sometimes
a layer needs to be written out as
multiple lines of code a high-level
version of this allows the developer to
define a layer as a single line of code
specifying the necessary parameters
right there all right all right all
right let's get to our demo of having an
AI predict what type of object is on our
web cam
we'll use a popular machine learning
model called Yolo or you only look once
the way it works is that it first
divides a given image up into a grid of
13 by 13 cells each of these cells is
responsible for predicting 5 bounding
boxes a bounding box describes the
rectangle that encloses the object the
model will output a confidence score
that tells us how certain that the
predicted bounding box actually enclose
is some object once it does that it'll
look something like this
for each bounding box the cell also
predicts a class as in what it thinks
that object is it gives a probability
distribution over all the possible
classes and it does this after having
been trained on a data set that contains
a set of labeled image classes the
confidence score for the bounding box
and the class prediction are combined
into one final score that tells us the
probability that this bounding box
contains a specific type of object since
most of the boxes will have a very low
confidence scores we only keep the boxes
whose final score is 30% or more which
leaves us with a final prediction the
architecture of Yolo is pretty simple
it's just a convolutional neural network
I have an incredibly detailed video on
comm nets on my channel see the link in
the video description for more but it's
got it's got just a couple of these
layers repeated over and over and over
again we give the network an input image
and in a single pass it'll output a
tensor that describes the bounding boxes
for the grid cells then all we'll need
to do is compute the final scores for
the bounding boxes and throw away the
ones that aren't above our threshold but
since we don't know how fast a user's
GPU will be we'll use a tiny version of
this model called tiny Yolo which uses
fewer layers and is faster but also a
bit less accurate we can import this
model into tensorflow Jas easily then
access our webcam programmatically to
retrieve the image frame we can apply
each image to our Yolo model in real
time and have the bounding box layered
on top of the image for us to see since
the model is already trained we don't
need to train it
we're just repurposing it for use in the
browser now it'll tell me whatever it is
that I'm putting in front of
webcam TV three things to keep in mind
from this video tensorflow das is the
JavaScript version of Google's popular
machine learning library consisting of
both a low-level core API and a
high-level layers API for building and
training models it uses the user's GPU
no matter what kind for both training
and inference which opens up a whole new
world of possibility including training
on real-time data and we can port
existing ML models to the Jas framework
and repurpose them for browser use
pretty easily if you want to learn more
hit the subscribe button and for now
I've got to use tensorflow @j s so
thanks for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>