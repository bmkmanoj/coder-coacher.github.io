<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ethereum Explained | Coder Coacher - Coaching Coders</title><meta content="Ethereum Explained - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Siraj-Raval/">Siraj Raval</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ethereum Explained</b></h2><h5 class="post__date">2017-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-_Qs0XdPpw8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello world it's Suraj and today I'm
gonna go over a theorem that is the
second-biggest cryptocurrency behind
Bitcoin that lets us do incredible
things the demo that I'm going to build
in this episode is a decentralized
conference ticket purchasing web app let
me show you what it looks like it's very
simple you can buy a ticket you can
refund a ticket you can create a wallet
but the only functionality that we
really care about is buying a ticket so
if we have some ticket price I can input
some address so that is my address and I
can buy a ticket with the money that I
have and then the amount of registrants
increases by one it's a very simple web
app that lets you buy tickets for a
conference but it's decentralized what
benefits does de-centralized offer in
this case very few benefits one you
don't have to worry about a third party
taking a fee so it's cheaper for both
parties and two it's censorship
resistant which isn't that big a deal
for a conference ticket web app but the
point is to talk about etherium and
learn how contracts and the
model-view-controller architecture of
web apps all play together okay so first
of all what is a theorem so aetherium is
a platform to easily build decentralized
applications using blockchain technology
so we know that bitcoin was the first
blockchain application and aetherium
does two applications what bitcoin did
for money that is removes a need for a
trusted third party so for the Bitcoin
blockchain we had blocks and these
blocks are just are just objects right
that store data it's basically up the
blockchain is basically a glorified
linked list
okay that's store on everybody's
computer and the etherion blockchain is
very similar except it's different in
that what's stored in those blocks are
not just transactions you can also store
code snippets in those blocks smart
contracts that's really the key bit here
theorem is a programmable blockchain
while Bitcoin isn't well Bitcoin does
have its own scripting language but it's
not as awesome or complete or capable as
aetherium x' and that's for security
reasons but anyways you can build
decentralized applications and you might
be
you know decentralized what a
decentralized application looks kind of
like this it's a different stack
entirely so at the bottom we have a
blockchain and a blockchain allows for
this decentralized consensus over
application level constructs there are
so many things in an app that different
parties need to agree upon is this a
valid username is this a valid identity
is this a valid address is this a valid
reputation score is this a valid tweet
is this a valid owner is this a valid
owner of this data you need consensus
right if we had a server there's no need
for consensus right there's no democracy
it's a dictatorship and the server
controls everything but in a
decentralized application we need
consensus and the blockchain was really
that missing ingredient to reach
consensus in a distributed decentralized
way so at the bottom of the stack is the
blockchain and 2.0 means the ethereum
blockchain or any blockchain that allows
for smart contracts on top of that we
have a storage layer right normally we
use AWS we use Google Cloud there are a
bunch of service providers for storing
your data in the cloud that are
controlled by one entity but in this
case we would want a decentralized
version of storage that is peer to peer
owned by no entities and ipfs the
interplanetary file system is one great
example of that on top of the storage
provider comes the smart contracts so
the smart contracts are code snippets
that will live on the blockchain they
are decentralized computation while
storage and content delivery is
decentralized by IP FS computation is
decentralized by the etherium
blockchains
smart contracts on top of that then we
can start adding application level
constructs identity reputation attention
eyes and on using all of this we can
create adapt or a decentralized
application it doesn't depend on any
specific party existing and it's not
about one party selling its services
it's more about a network a community of
people who all share in ownership of
some piece of software and so everybody
profits and everybody contributes in
some way it's a more communal more
progressive way of building software
that is emerging
we'll soon be the mainstream way to
build software what are some examples of
DAPs I'm sure there are a lot there are
there are quite a few check to check
this one out so wave fund is one so wave
fund is a decentralized Kickstarter
right we know how Kickstarter works it's
all about crowdfunding and wave fund use
a smart contract technology to let
people crowd fund certain applications
or projects or really anything like that
that's one example
another one is Al Gore which is pretty
interesting because it's all about
forecasting right about getting rewarded
for your predictions and it's controlled
by no party and it's it's all publicly
verifiable all the bets all the amount
of funds it's all publicly verifiable
there is no trust involved which is a
great use case provenance is another one
so provenance is all about making supply
chains transparent if you're a business
and you're getting some kind of
ingredient or some kind of tool from
some third party company and you want to
know what's in that and you want to know
where it's been and who created it
instead of having to trust that company
you can verify all of that publicly on a
blockchain because every product has a
story what a great tagline right that's
some that's some good marketing right
there but empowering the whole supply
chain for everybody it's a win win win
win situation so great use case here but
there are lots those are just three that
I just kind of randomly picked there's a
lot and there's a lot more to come so
let's get to the architecture of
aetherium right so cerium is it it
provides the consensus layer okay so it
provides both the consensus layer the
economic layer and the blockchain
services layer so the bottom three
layers aetherium kind of it solves right
so for consensus like I said we need
some way to agree upon all of these
application level constructs on top of
the consensus mechanisms we need some
kind of economic token to incentivize
all of these nodes to do the computation
or do the storage or to do whatever is
necessary right and so that's where the
crypto tokens come into play on top of
that we can start offering services
right these are these are these are code
snippets that actually do things name
registry smart contracts messaging
Oracle's distributed hashed
Able's for storing data right on top of
that we have interoperability so in this
decentralized world where we are just
imagining all of these different apps
and they all have their own tokens how
are you supposed to exchange value
between all of these token silos well
the answer is to have a universal
wrapper around all crypto currencies
such that there is one currency that you
have to deal with and you don't have to
think about any other currency whether
that's your state currency or whether
that's Bitcoin or whatever it is and
under the hood this protocol this
exchange protocol would transfer value
or transmit value between all of these
different tokens at as you use different
services right so you can think of kind
of a lay a stack of decentralized api's
that all use their own token you pay
this you pay the top API with whatever
token you want and it pays all the other
api's and the tokens that they require
using this kind of decentralized
exchange protocol which you can just use
in your app and there's a lot of them
stellar is a great one the stellar
protocol but there are a lot and on top
of all of this we have the browser right
this is how we access the decentralized
applications now ideally the mainstream
browsers that we know and love Chrome
Firefox Internet Explorer no I'm just
kidding that one really sucks opera they
would accept these decentralized
protocols natively so we wouldn't have
to create another browser and hopefully
I think they will very soon but in the
meantime we have browsers that are made
for decentralized applications like mist
and Maelstrom and all these other ones
and once we have all of that then we can
build DAPs
on using all this technology just
scratch out storge though because those
guys have been vaporware forever but
everything else looks good
open Bazaar is dope and dows and all
this stuff but storge come on show show
show us what you got right so like I
said we want to store the data in ipfs
right you don't want to store data
directly in the blockchain because it's
too big right every miner has to
download a copy of this blockchain all
the transactions and that includes code
and whatever else is in those
transactions but if we're storing movies
really big files in the blockchain that
things gonna get way too huge so no
one's gonna be able to download all of
it right so the way to fix that is to
store it in some distributed hash table
like ipfs what what ipfs gives back is a
hash a Content address for all of that
content and that is what we store in the
blockchain right so we store it in a
distributed hash table get back the hash
and store that hash in the blockchain
which then points to the data storage
right so in terms of the architecture
the etherium whitepaper is quite is
quite extensive and there's a lot
happening here in this huge diagram but
let's go over it a little bit right so
with the ethereum blockchain you have
blocks and these blocks are all linked
together and inside each block is a list
of transactions and all of those
transactions contain state and other
programmable parameters so what the
etherium blockchain does is it's stored
on every miners computer it currently
uses the proof-of-work algorithm to
verify all to verify the entire network
and inside each of these blocks they run
the computation that smart contract
contained in each block and then once
that computation has been successfully
done on each miners computer the whole
network will do the same thing and then
the majority of the network if they can
agree on the computation of that code
snippet it is then added to the
blockchain as an immutable construct so
let's so I mean there is so much that we
could talk about when it comes to block
chains and all this stuff and in
particular the etherium blockchain but
next week I'm starting this
reinforcement learning course so I this
is really the last week of blockchain
stuff before we get into some
reinforcement learning stuff I'm gonna
keep my lips closed on that one but
there's one thing that I do want to talk
about and that is the Merkel tree data
structure so notice that inside of each
block there is a there is a tree right
there is a Merkel tree so it looks kind
of like this this is the Bitcoin
blockchain right like I said it's a
glorified singly linked list it's got a
pointer to the previous hash
of the of the previous block it's got a
nonce to ensure novelty write a number
only used once it's got a timestamp and
then it's got a Merkel root so the
Merkel root is the head node of a tree a
Merkel tree so you might be thinking
wait a second why can't a block just
store a bunch of transactions as a list
well ince into one big block header why
does it have to store it as a tree well
the answer is if we just sorted all as
one big list that would provide some
that would that would cause some huge
scalability issues so to get around this
the Merkel tree data structure is used
which is a way to hash a large number of
chunks of data together which relies on
splitting the chunks into buckets and
each bucket only contains a few few
chunks so it's hashes all the way down
the chain and you could think of this
kind of like a file directory right you
have the root directory you have child
directories and it just keeps going and
the reason we use a Merkel tree is
because it allows for merkel proofs
which consists of a chunk the root hash
of the tree and the branch consisting of
all the hashes going up along the path
from the chunk to the root and so anyone
reading that proof can verify that the
hashing is consistent going all the way
up to up the tree so the Bitcoin so the
Bitcoin blockchain uses a very simple
Merkel tree right and it's got these
parameters but the limitation of that
Merkel tree is that it can't prove
anything about the current state that
means who's holding some digital asset
name registrations the status of some
financial contract and so with the
etherion block chain does is it modifies
that Merkel tree to store and stores not
and store is not just one Merkel tree
but three trees for three kinds of
objects transactions receipts which are
essentially pieces of data showing the
effect of each transaction and state
which is the state of your code right
it's a decentralized computer that can
store a state and they call this instead
a patricia tree not a Merkel tree
because it's modified to store state
which then allows clients to easily make
and get verifiable verifiable answers to
queries like
tell me all the instances of an event of
type X like that and X could be a
crowdfunding contract reaching its goal
etc right so the Patricia tree allows
for two store allows a blockchain to
store state so there's a lot right so if
we look at the etherium github there are
so many repositories there but really
there are three key bits here right
you have the etherium virtual machine
which calculates elements that run
contract logic now this is kind of
encapsulated by the etherium client then
you have swarm which is the storage
layer which we can just use ipfs for and
then whisper is for all the nodes being
able to message each other and for that
we can actually also use IP FS so really
all you need are etherium and ipfs and
took to run ethereum you can just
download the client yourself just like
you would BitTorrent or Bitcoin and then
with that client you can connect the
ethereal Network you can explore it
there on his blockchain run smart
contracts mined new blocks the whole
deal right so the so the client is our
gateway into the etherium network
whoever you are and so if we if we think
about all of the pieces here you have
eath or ether which is the inbuilt
currency it's the cryptocurrency itself
you have the etherium virtual machine
which allows for a centralized
computation like Heroku ipfs and ipfs
for storage and for communication you
have smart contract programming language
and really the one that we should care
about his solidity which is very similar
to JavaScript and it's currently the
most popular of them and then you have
the client of course death which is in
go you have eath which is in c++ and you
have pi each app which is written in
Python but the best one is go
so go was a language created by Google
to handle distributed computing they in
fact upgrade it from C++ to go so
because it was it was more efficient for
the it was more efficient for computing
on Google's huge distributed computing
stack so if Google uses it you know it's
a good language and go is just a
beautiful language if you if you've
never looked at it before I would HIGHLY
come in checking out go it's really a
beautiful language that is it's pretty
new it was designed with a lot of the
elements of distributed computing and
even decentralized computing in mind
it's currently the etherium client that
is getting the most activity and it's
just it's just great Prak practice
because I think we're gonna start seeing
a lot more artificial intelligences and
a lot more fundamental architectures
being built with go right so Jeff is the
one to look at and then you've got the
smart contract languages you've got lol
which is kind of like Lisp which no one
uses serpent which used to be similar
which is similar to Python and in
solidity solidity which is the most
popular and it's very similar to
JavaScript and it's the one that we'll
use so there's a workflow for deploying
smart contracts the first step is to
download your etherium node and then
you'll write your solidity code and then
compile it usually using a framework
like truffle and then you can deploy
your contract to the network and then
once you've deployed your contract to
the network then you can call that
contract using web 3j s which is the
front-end client that speaks to the
etherium blockchain right so the idea is
that you know when you're writing these
web apps you have this Model View
controller architecture right Model View
controller we're all familiar with that
it's like Ruby on Rails uses it and
angular and all of these apps so in all
these software stacks so in in in the
case of decentralized applications the
controller is instead of speaking to a
server it's speaking to block chains and
to distributed hash tables in terms of a
model that kind of stays very similar
but you also have this other type of
model and that model is the smart
contract you can kind of think of smart
contracts like models that the
controller will speak to and the same
kind of logic applies when building here
we need smart models thin controllers
and dumb views and your views are your
HTML and CSS and JavaScript files right
so all the storage is happening in ipfs
this distributed storage network and the
application level constructs those are
user names anything that you need people
to agree upon write game scores all
that is stored on the blockchain and we
can use smart contracts to to help
facilitate that so let's just get
started with building this app right so
in order to run this code that I'm going
to show you there's very very few steps
all right so our first step is to use
NPM the node package manager and using
it we can install the test RPC chain
which is the test block chain right so
this is a block chain we can use for
development purposes that we can spend
fake money on and no real money is used
so it's super useful for us and once
that that's installed we can install
truffle so truffle is a smart contract
framework that offers templates for
smart contract building so you don't
have to start from scratch right there
scaffolds that you can use to build
software faster and once I've installed
truffle then we can go ahead and run the
test RPC chain directly in terminal in
its own console window once test RPC is
running then we can go ahead and run
truffle compile on our code and then
truffle my great trouble test and then
truffle serve but there's there's one
thing that I want to do first if we look
at our app we can see the in HTML all of
the constructs that we created right
here right so buy to get refunded ticket
create a wallet we can see them in all
of these sections and they are calling
JavaScript right so JavaScript would be
the buttons here and JavaScript the
JavaScript is identified by the IDS if
we look in the JavaScript we can see the
application the app dot J S which
contains all of the code right so when
we initialize a conference we are
calling these functions on these objects
right so these functions from my
conference instance are from the smart
contract directly right so these are
functions that we embed in the smart
contracts that my conference instance
think of it like a class right so that
the smart contract is a class and we can
call all the functions that we ride
right inside the contract directly from
a pj s because we're using web 3 j s the
framework for talking to the etherion
blockchain so it's pretty simple so we
would just have to write out our smart
contract like so right so
right out our smart contract for the
conference and then we can run it it's
just like a class right so we'll say all
right what are our what are our global
values here right we have an address for
the public for the organizer of the
contract we have some sort of mapping
right because we want an address to map
directly to an integer value rights
because that integer value represents
the number of registration registrants
that were paid right we want to keep
track of this stuff and then under that
we want two more variables one for the
number of registrants and then one for
the and then one for the and then one
for the quota like how much what is our
maximum limit of tickets that we will
let people buy then we'll have a
function for the deposit so we can log
the event right so we want to log how
much is being deposited into this smart
contract and we have those parameters in
place for that one more event which is
for refunds right we're going to log how
many refunds are being processed here
right from what address are they coming
from the amount and then the type which
is an integer we can then construct our
function using this constructor function
we can then construct our conference
using the constructor function so it's a
function conference and then we can go
ahead and initialize those variables
that we define the for hand we're
getting some message from whoever sends
the transaction to the smart contract we
have a sec quota that Initiatives
initializes zero and then we have a
number of registrants that starts off as
zeros quota is 100 and then number of
registrants is 0 under that we can go
ahead and finally write our buy ticket
function right this this function is
gonna let anybody buy a ticket and like
I said we can call this function
directly from app dot Jaya so we will
say initialize conference and then we
can run conference by ticket and so
whenever someone clicks on buy ticket it
would then call this contract directly
just like that right so then we can say
well if the number of reps so we'll
start off the function by saying if the
number of registrants is greater than
the quota that we have in
plays then okay that we need to so we
need to go ahead and write a thro
statement which will ensure that the
funds will be returned all right so
that's it for our contract very simple
stuff right and then like I said we can
call this contract from a pas and it's
going to run the contract just like
normal okay so that's a demo I hope you
liked learning about aetherium there's
so much more I could talk about there's
some great links in the video
description and hope you liked watching
this video if you find this stuff
interesting and you want to see more go
ahead and hit the subscribe button for
now I've got to go invest in myself and
not any other cryptocurrency for the
moment so thanks for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>