<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Crypto Math | Coder Coacher - Coaching Coders</title><meta content="Crypto Math - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Siraj-Raval/">Siraj Raval</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Crypto Math</b></h2><h5 class="post__date">2018-01-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tK3wuQN9MHE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello world it's Suraj and who's ready
to go into the mathematics of
cryptography I know I am that's what
this video is about the mathematics of
cryptography cryptography is used all
over the place in our day-to-day lives
in places we don't even think about
everything from our telephones to ATM
machines to HTTPS the one of the
protocols that are fundamental to the
web blockchain technology and of course
artificial intelligence okay so what
we're gonna do is we're gonna go into
the math of cryptography and I'm gonna
show you a demo first of all this is
running on localhost right now see right
here what this is is it is a
collaborative text editor that is zero
knowledge
what that means is we can collaborate on
this text editor like I can type
something in like you know hey what's up
and notice how I'm anonymous other users
can join this it's peer to peer and no
server can can know what we are typing
even if we were to put this app on a
server no one would be able to tell what
that data is unless they had our key
signature our digital signature for the
for this editor so that's that's the
really cool part I'm gonna go into the
code for this at the very end but before
we get into that we have to talk about
the mathematics that that's used in it
right the mathematics of cryptography
now what I'm gonna do is I'm gonna go
into the details of cryptography and
then I'm gonna go into some of the use
cases particularly artificial
intelligence and then we're going to
eventually go into the code for this
okay so first of all and also the thing
I'm most excited to talk about is the
concept of ZK snarks you might be
thinking what are you yeah I know we're
gonna get into that but we have a some
building blocks to get into before we
can talk about ZK snarks so what is
cryptography so check out this image
I've got here of this beautiful text I
love apples
I do love apples I don't like apple
juice I like apples so we take this text
I love apples and we have a key this key
could be anything it's it's some sort of
algorithm it's some sort of series of
steps to in cipher or encrypt some some
plaintext so we say I love apples the
key is to replace every letter with the
third successive letter so I love apples
would be
we start off with I so what's the third
successive letter in the alphabet
IJ K so then I becomes K okay so a
what's the third successive letter in
the alphabet ABC so then a becomes C and
we do that for every single letter and
once we do that we're gonna end up with
this random looking unreadable what's
called cypher now this is the essence of
cryptography cryptography is a set of
techniques to scramble data disguise
data it's used all over the place and
computer science and it's a really
important topic to understand because no
matter what you're doing no matter what
field you go into in computer science
whether it's AI web app development
mobile app development cryptography is
paramount to security to privacy and to
an anonymity ok so this is a really
important concept and so in cryptography
the scrambled data is available only to
someone who can restore the data to its
original form so what that means is this
data is kept secret from unauthorized
people but easily decipherable by
authorized people someone who has the
key for that for that ciphertext
cryptography deals with encryption
decryption hashing and digital
signatures mainly let's go into each of
these so encryption first of all is one
of the most critical tools used in
cryptography it means converting
intelligible plaintext in to ciphertext
which is not intelligible and there are
three forms of encryption that are
widely used symmetric asymmetric and
hashing so check out this image here we
have a sender and we have a recipient
two different nodes in a network and if
I'm the sender and I want to send you
some plaintext message that only you can
read and no matter if this message is
intercepted if it goes to the wrong
person only you will be able to read
this message I will use encryption to
secure that message and so I'll have
some plaintext like hello world the
string I'll encrypt it using some
encryption algorithm and let's say a
public key for example let's say I
receive a public key from that
encryption algorithm that that message
becomes a ciphertext and if you once you
receive that ciphertext it looks random
it's just a bunch of letters that mean
nonsense if you have the private key you
can decrypt that cipher and get the
plaintext the original plaintext hello
and that's public/private key
cryptography that's one type of
cryptography but symmetric encryption is
the one of the oldest forms of
cryptographic methods known to mankind
okay the concept is very very simple if
we were to break it down two steps it
would look like this I have some message
M that I want to send over to you okay I
encrypt the message with a key and I get
a ciphertext C okay this is a ciphertext
now you get that ciphertext C if you
have that same key that I have you can
now retrieve that original message M so
it's one key to both encrypt and decrypt
and because it's one key on both sides
it's called symmetric so that's the
oldest form of encryption now another
form of encryption that uses a
public/private key pair is called a
symmetric encryption no you know notice
from Bitcoin it uses this and all these
block chains they use public private key
cryptography but the idea is similar but
different the idea is that utilizes two
keys not one a public key and a private
key and the use of one key cancels out
the use of the other so I'll encrypt
something with the public key and then
you can use the private key or the
secret key to then decrypt it and it's
asymmetric
now hashing is another example so recall
from you know data structures and
algorithms 101 hopefully you've taken
that if not don't worry about it because
I'll go over it a bit right now but
hashing is a way to take some plaintext
key and convert it into a hash that
you're putting into a bucket or a hash
table which is easily retrievable so
hash tables are great because they have
constant time retrieval which is awesome
and storage as well I believe don't
quote me on that one I'm just saying
that for memory but hash tables are
really fast for both storage and
retrieval compared to other data
structures but the idea is that you have
some hash function it's a static hash
function it could be dynamic but you
know Stenton the standard is a static
hash function and you put in a list of
keys right names passwords whatever and
it's going to convert that key into a
hash like John Smith will become Oh to
using this hash function Lisa Smith will
become oh one Sam dough will become oh
for Sandra Dee will become Oh too so
notice that both John Smith and Sandra
Dee Dee become Oh too
this is a problem right we want unique
we want unique hashes for these keys and
so this is considered a collision right
we want to prevent collisions from
happening and in the context of Bitcoin
the transactions are taken as input and
run through a hashing algorithm so
Bitcoin uses what's called a sha-256
algorithm which gives an output of a
fixed length so there's a specific type
of hash function that these block chains
use and this is called a cryptographic
hash function it's a special class of
hash functions that has various
properties that make it ideal for
cryptography so the first property is
that it's deterministic that means that
no matter how many times you parse
through a particular input through a
hash function you're always gonna get
the same result and this is important
because if you get different hashes
every single time it's impossible to
keep track of the original input the
second property is quick computation
this hash functions got to be fast you
got to be able to hatch this thing fast
and if not it's not gonna be able to
scale your systems not gonna be able to
scale
it's got to be preimage resistant
meaning that given a hash its infeasible
to determine the original plaintext and
notice that I said the word infeasible
not impossible we already know that it's
not impossible to determine the original
input but it should be really really
hard small changes to the input should
make huge changes to the hash right so
if I change this a single letter in a 25
character input there should be huge
changes than what that hatch would be if
we were to hatch that it's got to be
collision resistant we've already talked
about that and lastly it should be
puzzle friendly meaning given part of
the input and the output it's very
difficult for us to find the rest of the
input and this is central to Bitcoin
mining which is essentially a race to
solve a cryptographic puzzle by
essentially trying out many many
solutions uniformly randomly now the
last part that is a key to cryptography
no pun intended
are the concept of digital signatures
okay so imagine that a paper that I've
signed with my signature what should
this what should a good signature do
that is a question right so a good
signature should provide verification
meaning that someone should be able to
verify that it was me who signed it
right
handwritten signature it should be nan
for jabal meaning no one else should be
able to forge my signature it should
have non-repudiation meaning if I've
signed something with my signature I
shouldn't be able to take it back or
clean that someone else did it right so
in the real world no matter how good my
signature is no matter how unique it's
gonna be easily fordable by somebody
right
but cryptography gives us a solution by
means of what's called a digital
signature which is done via the use of
keys right generating and verifying
digital signatures involves encrypting a
message digest with a private key to
create the electronic equivalent of a
handwritten signature both the
handwritten signature and a digital
signature verify the identity of the
signer and cannot be forged and they
serve to ensure that nothing has altered
the signed document since it was signed
so I've got this diagram here of using
digital signatures I've got a signer and
my data I'll encrypt it using my private
key and that's gonna create a digitally
signed document we put that through a
hash algorithm and use the decryption
public key to then match if the
signature is valid if two of the hash
values have matched and then the
receiver can then read that document and
then know that it was me who was the
originator of that document here's
another diagram so we have a sender and
we have a receiver right so I've got
some message let's say it's crypto
compare com it's some string I can use a
public/private key pair to then input to
a signing algorithm and that's gonna
output a public key my signature and the
original message the receiver can use
that public key to verify that it was
indeed me who signed that message and
read that message so it's proof of
ownership digital signatures are great
for proof of ownership and they're used
in Bitcoin for that exact purpose okay
so now what are some examples of
cryptography right like I said they're
used everywhere and in day to day life
they're using smart cards and electronic
commerce any sort of online banking or
any time you need to make a payment
online computer passwords ATM anything
that is critical anything that is very
important we want to use cryptography as
a way to ensure that that data cannot be
forged or stolen by an unauthorized
third party okay so cryptography keeps
data confidential
and helps verify data integrity so one
great example for this is HTTPS right so
HTTP is the protocol for the web right
you know this probably but it's how we
communicate on the internet it's
fundamental it's stateless and since the
server forgets the client once the
transaction is over most of our
day-to-day transactions are done online
these days bill payments online shopping
right so it's it's absolutely necessary
that the communication between the
server and the client is secure so HTTP
was invented to help with this it is
HTTP but running on top of SSL I know
acronym hell right now but SSL stands
for Secure Sockets Layer and that's what
HTTP runs on as this how ensures the
secure channel of communication using
cryptography so here's how it works
we have the client and the server and
it's a seven step process so we have an
initial hello message that agree and we
agree on encryption algorithms and key
sizes the client requests a public key
the server sends a digital certificate
the client encrypts a random number with
the public heat extracted from the
digital signature both sides generate
symmetric keys based on that random
number the server proves the identity by
replying with with a finished handshake
message and both sides encrypt data in
both directions using their symmetric
key so it's a seven step process right
you know about the digital certificate
and that lock sign in your web browser
that is HTTPS and it uses cryptography
to secure the data between both the
client and the server what's another
example of cryptography whatsapp right
so whatsapp is one of is is the most
popular mobile messaging software in the
world right now and conversations are
end-to-end encrypted what do I mean what
that means is only the data is encrypted
the headers the trailers and the routing
information are not encrypted and it
makes sure that a message that is sent
is received only by the intended
recipient and no one else whatsapp has
ensured that even it as a server as a
third party cannot read the messages
bolstering a very strong messaging
platform so on the client side the user
is encrypting their message using a
public key sends it off to the server
the server cannot read that
message and the message then goes to the
client B or the user B and then using a
private key they can then decrypt that
message client-side and read it and the
server could not read what was happening
between those two parties now artificial
intelligence so I know some of you might
be thinking why are you talking about
cryptography so much it's it's not
related to AI well I'm here to tell you
that it is very very much related to AI
and now here's here's one example open
mind open mind is a community it's an
online community that has a single
mission and that mission is to
democratize data they want to
democratize data and what what I mean
specifically is they want to make deep
learning technology accessible to
consumers who supply the data and
machine learning partition errs who
train models on that data okay so
basically if I've got some data right on
my computer locally and you're a machine
learning practitioner and you want to
train your model on that data how do I
give you access to my data without you
knowing exactly what data is in there
right how do I let you train your AI on
my personal data without you as a person
knowing what my data is about right so
all of this is using encryption all over
the place right how do we do this in a
decentralized way without using a third
party server right how do you train an
AI on data that you don't know what is
the details of right so like let's say
for example hospital records I want to
train my a I model on some really
sensitive patient data but knowing the
patient's name and all their details
that's specially private right they
don't want to give that away however
they want to let me train my AI on that
data so that I can then solve some
disease in the future right so this
would be a perfect use case for open
mind which heavily uses encryption now
another use case and this is the future
of AI which is where we're going is the
idea of distributed autonomous
organizations so recall that
corporations are actually a rough
initial form of artificial intelligences
right corporations are consists of
humans right there they consist of
humans but really a corporation is is an
entity in and of itself but they're
there
the second stage and getting to real AI
so what I mean is corporations are
humans at the center and humans at the
edges well we're moving to where we're
actually where we are right now is
having is having humans at the center
and AI at the edges right so uber for
example once they have this self driving
car network it's going to be humans at
the center and AI at the edges so the
cars are going to be a eyes right so
that's the the the second step
eventually we'll have AI at the center
and humans at the edges so the AI is
making the decisions the main decisions
and humans are going to be completing
tasks that the AI needs but eventually
eventually we'll have AI at the center
and AI at the edges so that's a
completely autonomous system that
doesn't need humans at all that can
flourish that can learn for itself that
can get the data it needs it can pay for
what it needs all of this requires
encryption and to end encryption in
order to make sure that it's a system
that can be trusted all that we can
trust this system right it doesn't
become something bad that we don't know
what it's doing it needs to be able to
prove what it's doing right a provable
trustfull system that is verifiable by
third parties humans that in that the
work that it's doing is valid so all
over the place right we can have AI is
at the edges we can have hey eyes at the
center's and we can have swarms of AIS
right these are all simple AI agents
that together make up this higher-level
complexity and encryption is kind of
like the glue it's kind of like the tape
that make sure all these systems are
able to work together seamlessly
encryption and cryptography all this is
important stuff but you might be
wondering what math do I need to know in
order to do this well for cryptography
in general there are four topics that
are supremely important to know well the
first is mathematic notation the second
is abstract algebra the third is
discrete math and the fourth is calculus
now if you want a refresher on all of
these I highly recommend Khan Academy
that is the that is the best source I
think out there for learning just basic
math and also brilliant org brilliant
org check it out some great interactive
games to learn math okay so that's a
primer on cryptography now let's get
into a type of cryptography called zero
knowledge proof
I mean there's so many directions we can
take this I mean we could just go in
depth on a single topic like forever but
I'm just going in at high level right
now because I want to get to ZK snarks
at the end okay so now I want to talk
about zero knowledge proof zero
knowledge proof SAR a type of
cryptography that are supremely useful
in both blockchain technology and in AI
so the idea is that how can I prove that
I know something without having to tell
you what it is that I know that's the
idea behind zero knowledge proof how do
I prove that I know something it could
be anything without having to reveal
what it is that I know here are some
examples treasure hunts how do I prove
that I know the location of a hidden
object without revealing what its
location is in Sudoku how do I prove
that I know the solution to the puzzle
without revealing what that solution is
sealed bid auctions how do I prove who
won without revealing any bid are you
beginning to see the idea here zero
knowledge proof account balances how do
I prove that my account has enough
without revealing what that amount is
zero knowledge proof are super useful
for all of these use cases so the idea
came in the 1980s to a group of MIT
researchers zero knowledge states that
approver can prove to the verifier that
they possess certain knowledge without
telling them what that knowledge
actually is a zero knowledge proof has
three properties completeness soundness
and zero knowledge for completeness if
the statement is true then an honest
verifier can be convinced of it by an
honest prover soundness
if the prover is dishonest they can't
convince the verifier of the soundness
of the statement by lime and zero
knowledge if the statement is true the
verifier will have no idea what the
statement actually is so let's go into
two examples here the first case is this
scenario called Ali Baba's cave right so
in this example the prover P is saying
to the verifier B that they know the
password of the secret door at the back
of the cave and they want to prove it to
the verifier without actually telling
them the password so the prover goes
down any of the paths a and B and
suppose they initially decide to go down
the path a there are two paths here when
they do so the verifier comes in at the
entrance with no knowledge of
path the prover actually took and
declares that they want to see that the
prover appears on path beat the prover
does indeed appear in path B but what if
it was dumb luck what if it's not that
they knew it was path B they had to take
what they just guessed how do we prove
that right so to test the validity we
just do that experiment multiple times
if the prover can appear at the correct
path every single time it proves to the
verifier that indeed the prover knows
the password even though the verifier
doesn't know what that password actually
is and so this dissatisfied the zero
knowledge properties right it's
completeness because since the statement
was true the honest prove are convinced
the honest verifier it satisfied
soundness
if the prover was dishonest they
couldn't have fooled the verifier
because the test was done multiple times
and zero knowledge the verifier never
knew what the password was but was
convinced that the prover had the
possession of it one more case finding
Waldo so who played a Where's Waldo
because I used to play that right
remember that book shout out to the 90s
all those nineties kids out there so
finding Waldo is this game where you
have to find this guy Waldo in a sea of
people so imagine you and me are playing
Where's Waldo and I solved this puzzle
before you and I want to prove to you
that I've solved that puzzle without
giving any hints as to where where Waldo
is right like I could tell you hey I
found Waldo and you might say well where
is he and I was I just want to prove to
you that I found him without telling you
where he is because I want you to solve
it - how do I do that so one way to do
this is to take a sheet of paper with
identical dimensions to the picture and
Mark the spot on it in the exact
position where Waldo is and then I fold
that sheet of paper into some kind of
origami or something and give it to you
so once you've solved that puzzle you
can open up that folding put it back on
top of Waldo like an overlay and then
see oh that point is is exactly where
Waldo was and that's a way of having a
zero knowledge proof just to give you
some concrete examples of what I mean
right - really dry this point home okay
so there are two types of zero knowledge
proof the first is proof of statement
and the second is proof of knowledge so
proof of statement means that this is
some intrinsic
about the universe like the number X
belongs to the group Y or this star is
brighter than the other stars proof of
knowledge is I want to prove that I have
knowledge of a particular idea without
revealing what that knowledge is that's
as can be seen in those two examples I
just gave cryptocurrency is mostly
focused on proof of knowledge okay so
now let's get into ZK snarks a bit so
this stands for zero knowledge sucks int
non-interactive arguments of knowledge
ok ZK snarks so it's used in its use in
modern blockchain technology is immense
and to understand its application we
have to understand a bit about how smart
contracts work basically it's an escrow
of funds which gets activated once a
particular function is done so let's say
I've entered into a smart contract with
you for example then I'm and I'm only
gonna get the payment if I do a B and C
a B and C are tasks what if I don't want
to reveal the details of what a B and C
are because they are confidential to my
company and I don't want any competitors
to know what I have to do what ZK snarks
does is it proves that those steps have
been taken in the smart contract without
revealing what those steps actually are
and this is very useful in protecting
privacy it can just reveal part of the
process without showing the whole
process itself and prove that I'm being
honest with my claims so how does this
work so it consists of three algorithms
G P and V G is the key generator P is
the prover and V is the verifier G is
going to take an input lambda and this
is a this should be kept confidential
right it shouldn't be revealed under any
circumstances and a program C it then
proceeds to generate two publicly
available keys approving key PK and a
verification key BK these keys are both
public anybody can look at them and
available to any concerned parties
lambda is that part that has to be kept
secret so P is the prover who's going to
use those three items as input the
proving key the random input X which is
publicly available and a private
statement that they want to prove the
knowledge of without revealing what it
actually is which is we're going to call
that private statement W so P is going
to generate a proof such that the proof
equals P of the private key
input X and then the private statement
that we want to keep private W that's
our that's really what we want to use
everything for how do we encrypt this
thing right so the verifier algorithm v
has basically returned a boolean value
the boolean variable only has two
choices it can be true or it can be
false so the verifier takes in the
verifying key public input X and proof
PRF as inputs such as V V of VK x PRF
and returns true if the prover is
correct and false otherwise
the value of lambda must be kept
confidential we've talked about this and
here's what an example looks like a
function C with parameters X and W
returns the sha-256 of the original you
know private statement equal equal equal
X all right it takes two values as input
a public hash value X and the secret
statement that needs to be verified W if
the sha-256 hash value of W equals x
then the function returns true otherwise
it returns false
okay now the proving algorithm we talked
about looks like this proof equals P of
P kxw and now that someone has generated
the proof PRF they're going to give that
value to the second person who's gonna
finally run the verification algorithm
of ZK snart's which is this V of VK x
PRF here VK is the verifying key and X
as the known hash value and PRF is the
proof that they've gotten from the first
person if the algorithm returns true
that means the first person was honest
and they did indeed have the secret
value W if it returns false it means
that that person was lying about knowing
what W is so lastly I want to go over
this code for this repository called
crypt pad that I found is a really cool
repository basically it's a zero
knowledge real time collaborative editor
and there's a lot of code involved but
it's really easy to install like it's
like just three lines that I just you
know Bower install NPM install and then
node app touch AAS and it's running on
localhost but there were some parts of
this that I wanted to talk about really
quickly so one part is the common hash
so if we open that
you
this is where the hashing is happening
here right so they're using different
hashing algorithms here to get the keys
from the server right but the idea is
that only the clients that have that key
can decrypt the messages so if there's a
server that this web app is hosted on
then the people who control that server
can't see what the data is that these
people are collaborating on in real time
okay and they're using javascript to do
this with the common hash function I
mean there's a lot of code here but I
think in main dot j s we can see the
high level of what's going on here if we
go to examples right where we go into
examples and then pin and then main dot
J S so this is this is what's happening
on an app start right so we synchronize
the channels right so we get the -
channel list we get the file size we get
the server hash and then once that's
ready we get the network the store and
then we create a pin path a pin pad by
synchronizing the hashes from all of
these different clients and all of its
being encrypted and decrypted
client-side so the server never has any
knowledge of what these people are
talking about in real time so Google
Docs for example Google knows what
you're typing in real time but if there
was a zero knowledge proof involved like
ZK snarks or you know etc then they
could not know what you guys are
collaborating on so it's really useful
to keep your data private to keep it
anonymous and to create systems that are
trust less or you could say more
trustful in a way but Z CAPTCHA does is
a great example that uses ZK snarks it
aims to provide completely safe and
shield a transaction spaces for its
users without revealing their details
and aetherium as well wants to integrate
ZK snarks as it enters its next phase of
development please subscribe for more
programming videos and for now I've got
to research some crypto map so thanks
for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>