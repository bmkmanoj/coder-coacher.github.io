<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Why is P vs NP Important? | Coder Coacher - Coaching Coders</title><meta content="Why is P vs NP Important? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Siraj-Raval/">Siraj Raval</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Why is P vs NP Important?</b></h2><h5 class="post__date">2016-11-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9MvbNPQiEE8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">don't check out my friend Ryan Charlie's
YouTube channel for some cool magic
videos hello world it's Suraj
in this video we're going to talk about
perhaps the biggest unsolved mystery in
all of computer science what are those
couldn't resist does P equal NP P and NP
both represent a class of decision
problems do these two line segments have
an intersection or can we beat the game
of pong in under three minutes or given
a Rubik's Cube can we always solve it in
20 moves or less so let's start to
define our terms we'll start with the
first class of decision problems labeled
P P stands for polynomial which comes
from the Greek phrase meaning many terms
a polynomial is a math expression that
consists of a sum of many terms like 2x
plus 3 or X cubed plus 4 X and we can
create strategies to solve any
polynomial reasonably fast so P is the
class of decision problems that we can
solve in polynomial time
which means reasonably fast an example
of a P problem would be sorting like can
we sort a set of numbers in increasing
order yes and there are several known
strategies to do this another set of
examples are any of the basic math
operations like addition or subtraction
we can solve these problems reasonably
fast or searching given a set of numbers
does the number-5 exist in it we can
solve that pretty easily by checking
each number in the set so that's the set
of decision problems that we call P but
there's another group of decision
problems that we call NP and P stands
for non-deterministic polynomial which
is Matt terminology for problems that we
can check the solution to easily but not
solve easily an NP problem example would
be can a traveling salesman drive across
a given set of cities and return back to
his home city without running out of gas
if someone proposed a possible solution
we could verify it instantly by tackling
the amount of gas that would let him
travel the given path in miles but to
find the absolute best solution we would
have to try every single combination of
routes to find a shortest one which
would take forever to calculate let's
look at what this looks like in code
let's start by defining an empty list of
routes then we'll define a list of paths
between cities as a dictionary of
dictionaries for each key which is
defined by a city initial will have a
set of key value pairs which define the
distances between one city and another
as an integer now that we have our two
variables defined let's write our
function to find the shortest path
is what our function will look like when
we call it our starting city is RV now
it stands for River City okay so let's
add that to our empty list now we can
calculate the path length from the
current city to the last city by looking
up the distance in our dictionary well
check if our path contains all the
cities and isn't a dead-end with our if
statement and if that's the case we'll
add the total distance and path to our
routes list we've done this for one
possible path now let's do it for all
possible paths using this for loop we'll
call this function inside of itself to
find paths for all possible cities not
yet used this technique of calling a
function inside of itself is called
recursion it'll show us the shortest
route in terminal when it's done in no
time since the list of cities was small
but for larger numbers of cities this
will take way too long to calculate so
instead of trying to find the absolute
best solution routing apps like Google
Maps instead estimate the best paths
using different techniques which is way
faster another example of an NP problem
is scheduling let's say we have a set of
courses at a school and we want to
schedule final exams during finals week
so that no student has to take two
different exams on the same day
calculating all the possible schedules
for say a thousand students would be a
huge number that would take years to
solve but if we were given a possible
schedule we could check it easily by
saying if it gave any student more than
one exam on a given day or what if we
wanted to find all the prime factors of
a number we could verify a solution
easily if it was handed to us but there
isn't a way to solve it in a reasonable
amount of time
for a huge number any problem that can
be solved easily can also be checked
easily all P problems are always NP but
can any problem that can be checked
easily like scheduling or prime
factorization also be solved easily
meaning are all NP problems always P
that is the question does P equal NP and
the answer is we don't know there's also
a set of problems called np-hard that
are really hard to solve at least as
hard as the hardest NP problems I mean
some of them can be verified easily but
others can't even be verified easily
they can't be solved or verified easily
an example would be the halting problem
which says given some computer program
and an input will that program finish
running at some point or will it just
continue running forever we can't solve
that or véra
by a solution to that easily the only
known way to check a possible solution
like it'll just continue running forever
is to wait forever that intersection
though of problems that are both np-hard
and NP are called np-complete these are
problems we can't solve easily but can
check even though they are pretty
difficult to check an example of an
np-complete problem is finding the
longest common substance so given two
different sets of numbers what is the
longest common subject and Sully but we
can check the solution with some effort
np-complete problems are the hardest NP
problems to check if we were to find a
strategy to solve any np-complete
problem in reasonable time then we could
use that same strategy to solve any NP
problem in reasonable time it would
prove that P equals NP that means there
would be a single strategy that could
solve any problem one algorithm to rule
them all proving P equals NP is the
million-dollar question seriously the
Clay Institute is offering a million
bucks to whoever can solve it if P
equals NP were true it would have
profound effects on society it would
mean online security systems would all
be vulnerable to attack because our
current inability to efficiently Factor
huge numbers an NP problem forms the
basis of modern cryptography which
everything from national security to
banking depends on it would also mean
that we could make everything more
efficient transportation schedules
production cycles for manufacturers
protein folding simulations which would
effectively solve cancer all of it would
be optimized to be faster and cheaper it
would mean Harambee would come back to
life
hello oh it doesn't wash on the flipside
if someone were to prove that P doesn't
equal NP it would be proof that there
are some problems that no amount of data
expertise or intuition could solve but
unlike the other sciences computer
science is only sixty years old and
because of that I believe there is still
a possibility that P equals NP we just
haven't found the right algorithm
anything is possible
so to break it down the P equals NP
problem asks if because we can easily
check an answer to a problem does that
also mean we could solve it easily
approximating an answer to NP problems
lets us avoid the huge computing
requirements to find the optimal
solution like in the Traveling Salesman
problem and if someone were to solve P
equals NP it would mean we could solve
any problem in a reasonable amount of
time which would be awesome the winner
of the genetic algorithm coding
challenge from the last video is Nicole
Rigby she asked what the average global
temperature would be in five years using
the given climate data she found an
optimal solution estimate using genetic
programming and documented her process
in the read knee with really cool
visualizations badass of the week and
the runner-up is Nick ven holes he
thought of a bunch of interesting
questions to ask about the data and
documented them and to read me the
coding challenge for this video is to
prove that P equals NP now I'm just
kidding the challenge is to write a
script that estimates a solution to the
travelling salesman problem instead of
trying every possible path details are
in the readme post your github link in
the comments and I'll announce the
winner in my video a week from now
please subscribe and share this video
and for now I've got to find the limits
of computation in our universe so thanks
for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>