<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Guide to Building Your First Decentralized Application | Coder Coacher - Coaching Coders</title><meta content="A Guide to Building Your First Decentralized Application - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Siraj-Raval/">Siraj Raval</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Guide to Building Your First Decentralized Application</b></h2><h5 class="post__date">2017-09-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gSQXq2_j-mw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello world it's Suraj and don't go
anywhere this is gonna be one of the
most important videos you've ever seen
in your life so sit down and enjoy the
ride what I'm gonna do in this video is
I'm going to build a voting app okay and
let me demo it first okay this is my
hello world voting app it's got three
candidates and I'm going to vote for one
I'm gonna pick one Rama and then click
vote and the vote shows up okay there
are three candidates in this app I voted
and then the vote shows up and anybody
who uses this app can vote and then that
vote is gonna show up in the web app so
you might be thinking wait a second it's
so easy why are you demoing this because
the difference between this voting app
and a normal voting app is that this
voting app is unhackable that means that
no one can modify the votes okay so it
is hackable but it's hackable in that
you would have to have access to the 500
fastest supercomputers in the world
combined that's how much computing power
you would have to have in order to hack
this so it's basically unhackable unless
you have that much computing power which
no one does and this is called a
decentralized application now you are
probably used to building a centralized
applications so am i right that's what
we do we all of web development all of
mobile development all of it is centered
around building centralized software I'm
going to talk about what centralized and
decentralized are in a second
but that's the that's the voting app
we're gonna do that's the demo we're
gonna build today I'm going to go
through setting up the environment and
all the tools you need to build it and
then we'll build it ourselves but first
let's talk a little bit about the World
Wide Web okay so the web started off
decentralized what does that mean if you
are around in the early 90s and I was a
little baby but you know I was still
there then if you wanted to make a
website you would just buy a server
right you buy a server that is a
computer you put it in your room and
then you would put your web page or your
blog they weren't even call blogs back
then but you're you know whenever you
want it on your server on your computer
and then you you owned that server
because no one was offering to host your
data for you what that meant was the web
consisted of a series of nodes that were
all linked together a very neutral
playing field where everybody owned
their data or the data that they
contributed to the World Wide Web
that's how the web started off but what
happened was during the dot-com bubble
entrepreneurs realized that if you
wanted to provide value on top of this
neutral playing field then you would
create some service right you create
some service and that service would
collect data and monetize it and this
proved extremely extremely useful right
we started hosting our data on geo
cities if you remember shout out to geo
cities or any of the old you know web
hosting services we started using you
know a whole host of services that were
centralized and what this meant was you
didn't have to buy your own server you
could just use these services and have a
very thin client but what's happened is
these services have become so massive
that the web is now a cent a set is it's
basically a handful of huge nodes it's
become centralized around a handful of
huge nodes and these nodes are Amazon
Google Facebook snapchat Instagram all
data is routed through these all data
requests all queries data is routed
through these central nodes and this is
bad really bad and here's why of course
these services provide a great value to
our lives we use them every day
right we I use Google and all these
services every day they make our lives
easier but it's bad for four reasons the
first reason is that it's shrinking our
economy what I mean by that is that in a
good economy we monetize more and more
but in a bad economy we monetize less
and less and that's what's happening
because data is the natural resource of
our time and because data is so
centralized that means the ownership of
data is so centralized there are less
opportunities for people to generate
value to generate capital because all
the data is being collected right data
is how you make money right as a society
we are starting to value
more and more data and less and less
labor right before we valued labor now
not so much it's all about the data
and as this economic trend progresses
it's going to only the value of data is
only going to increase over time and
because that data is so siloed right now
it's hard for normal people to make
money off of it you would have to be a
part of one of these big corporations to
do so and that's not the future that we
want right so that's that's a problem
the other problem is that this is just
too much concentrated power right
knowledge is power right and knowledge
is data information is power information
is data and it's it's just too much of
an overhead God view of what everybody
is doing for any of these companies to
have uber for example I had a friend who
will remain nameless who worked at uber
who showed me god mode and if you don't
know god mode is what they're they are
able to view all overrides that are
happening obviously at the same time so
they can they can basically predict you
know who's having a one-night stand or
who is you know anything really personal
details they can glean from this and
that's just one of many many many
examples and that is just too much power
for any any one entity to have and
that's just not good because it doesn't
matter where our intentions were this is
a problem and we have no say in how our
data is used right are once once we we
exchange our data control of our data
for access to a free service and what
this means is they can do anything with
our data they can sell it to advertisers
they can use it to manipulate us they
can learn our personal details they can
sell it to the US government or any
government's really and we just have no
say and how this goes in the end the
last point is that we should be paid for
our data we need to we are generating
this valuable resource this natural
resource and we should be paid for it so
a great book on this is called who owns
the future by Jerome Lanier the dude
looks you know really wild he's got
these long dreadlocks and he you know
big dude and Berkeley and he plays all
these instruments he's a really cool guy
but I mean no one can talk about this in
the way that your own Lanier can he's
one of the pioneers of the internet he
now works at Mike
research as a virtual-reality researcher
and yeah so that's a great book and also
I mean I wrote the book on decentralized
applications I don't really talk about
it that much because the code is
deprecated at this point but um yeah if
you want to see a great book on
decentralized applications then check
out my book general Riley book as well
the code is deprecated but the ideas
remain I just don't have time to keep
maintain that code I'm making videos
like a madman anyway back to this so
let's let's talk about this
decentralized versus centralized versus
distributed what is the difference so a
centralized application is what we're
used to Google Facebook Amazon what
happens with the centralized application
is we create a server and then we have a
bunch of clients connect to that server
so everybody connects to this this
central point of authority that defines
the rules of how the network works an
example is Facebook right we whenever we
go to facebook.com where our browser's
are acting as clients that in our
browsers are requesting data from
Facebook and posting data to Facebook
it's a central server
and that's how pretty much all the web
works right now it's easy it was just
easy to do that's why we did it
and but it's difficult to scale and it
has a single point of failure right if
someone takes down that data center all
of our data is lost
so that's centralized let me talk about
distributed next which is this right
here this image right here so a
distributed system is one where
computation is spread out across the
network so actually all of these
services that we use are distributed so
a service can be both centralized that
means there is a central point of
authority and distributed as in the
computation is spread across multiple
nodes because if you think about it is
Facebook doesn't just have one giant
server they have several data centers
that are scattered across the web and
data is routed through these servers
depending on where you are and so these
services are both centralized and they
are distributed and so this having a
distributed architecture speeds of
computing and it's just data latency it
increases bandwidth there's there's a
bunch of pros
having a distributed architecture it's a
little harder but the pros are worth it
and that's why these big companies do
that now the last one I'm going to talk
about are decentralized systems like the
middle picture right here so for a
decentralized system in a decentralized
system you can take away one of those
nodes and the network will still run
that means that no node is telling any
other node what to do there is no
central point of authority all nodes are
equal in the network in terms of their
authority
so bitcoin is an example of a system of
a network that is both distributed
because it's a time-stamped public
ledger it's a it's a database where
everybody owns a copy of the data right
it resides on multiple computers so it's
distributed and it's decentralized
because if one node goes down the
network is still able to operate right
you could take down you know 20 Bitcoin
miners but Bitcoin would still run it's
a it's a it's a more resilient way of
building software it's faster software
the demand and failures are better
handled so examples of decentralized
software are all of these
cryptocurrencies that we we look at
Bitcoin aetherium litecoin these are all
decentralized systems and when it comes
to decentralized applications there's
really only one that satisfies my
criteria at least right now and that's
called steamin and I'll talk about that
in a second but steam it is one what is
a profitable decentralized application
look like so if we look at the web 2.0
stack okay let's look at the the web 2.0
stack so anytime you want to build
software any any kind of web app or
mobile app you are using these tools
right there there are certain parts of a
website or an app that you need to use
tools for right so for payments you're
gonna use credit cards and PayPal stripe
some kind of API for monetization you
know you'll you'll develop some strategy
like selling ads paywall and your
content selling some good some goods
external data you you use a third party
API from some service right like clarify
or any of these api's for file storage
you use Amazon
three or Google cloud you know what have
you and lastly for computation you use
Amazon ec2 or Heroku or you know there's
a lot of services out there because web
2.0 has been around for so long but now
we are moving into web 3.0 and that
means that because of the invention of a
certain set of technologies in order bit
torrent which maximize bandwidth bitcoin
which allowed for decentralized
consensus amongst a set of nodes in a
system for the first time to several of
these technologies we are now able to
make decentralized apps so the web is
kind of like a pendulum and it started
off as centralized and it start off with
decentralized it moved to centralized
and now it's moving back to
decentralized and that is the mission of
a many peak of many developers right now
it's to ridi centralize the web and so
there are tools out there that will let
us do that theory on Bitcoin all these
crypto currencies are for payments the
token model for monetization now this is
a really interesting bit and I'll talk
about the token model in a second
Oracle's for external data Oracle's are
third-party data sources that you don't
have to trust a human for like you have
to trust stripe or any of these API is
to provide valid data but when Oracle is
essentially a smart contract that has
some data that you can trust but it's
run by machines for file storage you
would use a network like the
interplanetary file system which I'll
talk about which is essentially a big
distributed hash table and lastly for
computation you would use aetherium for
example which is which is a
decentralized virtual machine it's kind
of like a decentralized Heroku that you
could push code to but it doesn't live
on one central server it's it's it's
decentralized and so I put red you know
ready for these bottom tube and these
are in progress but really like if you
think about it you can use all of these
it's just not gonna be at the these
tools aren't as evolved as you know the
web 2.0 tools but you can use all of
them for sure so what is what does it
look like well there are four features
that make up a profitable decentralized
application
the first feature is that it's open
source so you might be asking wait a
second if I open source my code couldn't
someone just steal it then and now if
you're using a traditional business
model yes if a competitor can see your
code a lot of the times that is your
competitive advantage they could then
just use that code and then fork it and
then profit off of your code but in a
decentralized application if you're
using a token business model an app coin
model then they could not take away from
your network right because it depends on
the community of users it depends on it
depends on the trust of your users and
that your user your users are profiting
from your model as well so people want
to join the network that has the most
trust that's built the most trust over
time
Trust is a moving concept it's not just
established once you have to continually
prove and reprove that trust and so
people want to go with the longest chain
of trust so to speak the second feature
is the use of cryptocurrency so this is
a this is an image of a some random
company's time line for for ICO or
initial coin offering but basically the
use of cryptocurrency is this so you
know there are traditional models for
monetization right the transaction fees
advertising revenues but the
cryptocurrency way is to do this okay so
you would allocate some scarce resource
in your network using a scarce token
right that scarce resource could be
storage space it could be images it
could be videos some scarce resource
some scarce data that people are
contributing to the network that and you
monetize that with an app coin some kind
of token and what happens is users need
this app can app coin to access the
scarce resource and because of that
you're creating a supply and a demand
right you're you're you're imposing this
artificial scarcity and what that does
is owners of the scarce resource get
paid in app coins so they get paid for
their tweets and their images and that
whatever data that they contribute and
what this does is it makes the value of
the app coin rise right so this app coin
is kind of like a hybrid
acet it's both a stock but it's also a
currency and so it's both it's not it's
right so you can mate you can own it and
you can just keep it as investment or
you can use it and you or you could just
use do both keep it keep a part of it as
an investment and the other part has as
use of that of that of that app so
that's one way and Bitcoin does as well
file coin does as well like in the file
coin Network miners of the scarce
resource storage space get paid in file
coin and then people who want to store
their data on the file coin network pay
have to pay file coin to access it and
so there is this market that's being
created and this can apply to any kind
of decentralized application and the
scarce resource could be anything
all right so steam it is a great example
of a decentralized application right
because there is because there is a
digital point system and people are
getting paid for their scarce resource
which are their posts as you can see
here they're the most valuable posts are
the most paid posts and it's open source
it uses cryptocurrency under the hood
but it's got a dollar wrapper here but
anyone can pay in cryptocurrency so
steamin is a great example of a working
decentralized application the third
feature is decentralized consensus so
what I mean by that is the ability for a
network to all agree upon everything
that's happening in the app and only
until very recently this was not
possible Bitcoin proved that we could
reach decentralized consensus using the
proof-of-work algorithm 51% of the nodes
in the Bitcoin network have to approve a
transaction before it's made valid and
added to the chain of blocks the
blockchain and not just an as they vote
on the validity of a transaction they
also have to offer a proof of their
computational work and so what this
means is they have to have you have to
have more computing power than 51% of
the Bitcoin network in order to fake a
transaction and that's where the 500
fastest supercomputers phrase I talked
about comes from and so that's what
was one very popular way of reaching
decentralized consensus and so another
thing is the blockchain alone isn't
enough it's not just like you just take
an application sprinkle some blockchain
on it and you're good
no blockchain is a big part of it it is
a data structure that you would use but
it's only a part of the stack so for big
files
you're not gonna store big files on a
blockchain right for big files
you're gonna store that on some kind of
distributed hash table and one that I
really like is called ipfs which I'll
talk about for feature four but right so
you use a distributed hash table to
store the data and then music you use a
blockchain for app level constructs
these are time-stamped constructs like
user names and status updates and high
scores anything that you need the
network to agree on agree upon and so
the reason you use a DHT and a
blockchain is because the blockchain
solves the major security issue of the
HTS which is not forcing nodes to trust
each other on the validity of the data
so the DHT is more of like a dumb data
store that no one controls and the
blockchain helps the DHT reach consensus
on the data which lets you create
applications on top of it lastly there's
the idea of smart contracts which are
crypto economically secured bits of code
right so in a normal piece of code now
here's an example in a normal piece of
code you would upload it to some central
computation engine like Heroku and then
you would trust Heroku to compile that
code and keep that code on unmodified
just like you pushed but in a smart
contract you don't trust any central
source you push it directly to a
blockchain ideally the ethereum
blockchain because they they have a
turing-complete blockchain which allows
for loops and all sorts of application
level constructs but you would push some
code to the etherion blockchain and then
it would run on that blockchain and so
everybody every miner has a piece of
that code and it's crypto economically
secured so it's that what that means is
it is a pre agreed-upon snippet of code
that once deployed is unchangeable it is
immutable okay so that's a smart
contract and lastly
for a profitable decentralized
application there is no central point of
failure that means that you just could
not take this application down if you
wanted to so right so all these big
countries that try to block access like
China to applications like Facebook they
could not do that for a decentralized
application why well one way is again to
use IP FS as your data store
so IP FS and III one the creator of this
was my roommate when when he was writing
the paper and there's a lot there's a
lot I could do an entire video series on
ipfs there's a lot here but basically it
is a real it is meant to be a
replacement for HTTP which is the normal
way in which we access websites on the
Internet right now so for ipfs there are
certain technologies and you can see
them here that that make up its stack
but the idea for ipfs is that instead of
IP addressing our web instead of IP
addressing our content meaning we
location address where some data is
let's content address it and access it
that way so instead of going to a
website by using its IP address we would
use its content address kind of like get
right like it has those these hashes
that represent data so ipfs is
essentially like a giant get tree a
merkel tag as they call it an IP FS
where all data is linked together and
there's resiliency happening in the
network as well bits and shards of data
are replicated across multiple nodes so
you couldn't just take down some content
address because there are multiple
copies of it they're constantly being
replicated inside of the network so you
could take down a website by just
ddossing it right but you could not DDoS
an IP FS node because the data is
replicated it's not location addressed
its content addressed and there's a lot
of reasons for creating ipfs that i
could go into but basically it helps us
create a permanent web where links never
die so it's a more resilient web than
HTTP okay so and it's it's decentralized
so in general these technologies are all
a way for us to build
more autonomous software that is
software that is independent of its
creators it's it's almost like we're you
know with AI and with blockchain and all
of these very interesting new
technologies we are creating ways of
removing the human from the loop because
with humans there is always some kind of
trust involved right whether it's a taxi
and you know having to trust a taxi
driver to give you a fair price or using
some kind of meter right so you offload
that trust onto the machine and so you
don't have to trust a human and it just
makes the whole process the whole system
better
so with artificial intelligence and with
blockchain it's our way of making more
autonomous software it's almost like
entities that live and exist
independently on the internet and this
is very exciting so I have this image
right here so just look at the one on
the Box on the left let me just talk
about that so the old way of creating
organizations companies was that humans
at the edges and humans at the center
just humans and those are boring old
organizations the next step is to have
automation at the edges and humans at
the center so the assembly line is a
great example robots are doing all the
grunt work but humans are overhead
watching it now where we're heading
towards our distributed autonomous
organizations which is what adapt is is
another word for it and that means
automation is at the center the trust is
in the blockchain it's in these
distributed decentralized technologies
and humans are at the edges so the
community kind of supports this
autonomous network so like a
decentralized uber the drivers would be
at the edges of the network but they
would have more of a say in how the
network operates then in a model like
uber which is centralized and lastly you
would have automation at the edges and
automation at the center and that is
just the holy grail right just pure AI
so in the end these technologies are all
really related lastly before we before I
go into the code this block chain and
the IC o---- model is just a way for us
to more closely approximate the the
value generation and capital generation
right that's what we're trying to do
because a lot of times
Capital generation and value generation
are just not aligned what what I mean is
people do things that are not providing
a lot of value but they get paid a lot
of money like football players or Kim
Kardashian or right all these people who
are making millions of dollars but it's
not really providing real value to
society whereas these social impact
causes that are fighting climate change
and trying to solve cancer they have to
raise money they're considered
nonprofits but with the blockchain model
we can more closely approximate this so
we can we can give these people more
money they can earn as much money as
they deserve and so it's a really
exciting time if you want to monetize
more social impact causes like
volunteering or scientific research like
the people who are working on ethereum
are extremely wealthy and some of the
original scientists that worked on it
independent scientists who were doing
research that was worthy of turing
awards they were they were they were
incentivized with the ether coin which
is skyrocketed in value right so it's a
way to more closely you know give value
or capital to the people generating real
value for the world let's get into our
voting app so this the first step is for
us to set up our environment so what
we're gonna do is we're going to just
use if Theory Allen I know I talked
about ipfs that's that's for maybe a
later tutorial right now just a very
very simple application we don't really
need a distributed hash table for this
because it's so simple it's essentially
just a smart contract that we deploy to
a blockchain and then we have a thin
client that can access that smart
contract on the blockchain which is just
HTML and JavaScript so this is what it
looks like right so we have the etherium
blockchain which is a blockchain like
Bitcoin except it's a turing-complete so
that means we can
there is a scripting language associated
with this that we can deploy to not just
transactions but code we can have code
run on the blockchain and then we can
access that code just like we would a
server and so this is called the
etherium virtual machine and then we
would we have some thin client which is
called web 3j s which we're going to
access
this from and we can do all this from a
web browser so that's that's that's what
it's going to look like so let's go
ahead and set up our environment okay
so the first step is for us to download
the etherium test our pc this is a this
is an in-memory blockchain and it's
great for testing out blockchain without
having to download the actual blockchain
okay so we're gonna go ahead and install
that by running npm install
aetherium j/s test RPC and web 3
now remember web 3 is our thin client
that lets us access the blockchain
but basically test RPC is gonna let us
create 10 test accounts that we can play
with automatically and these accounts
are going to be are going to come
pre-loaded with a hundred ethers these
are fake ethers it's you also call them
gas in etherium like this is how the
network runs like you make transactions
and these transactions are how you
deploy a contracts to the blockchain
right and so because it's happening on a
test network we don't to pay anything at
all right it's all free but this is on
the test network so it's gonna take a
while it's gonna you know download all
this stuff and when it's done we're
gonna go to step two which is creating a
voting smart contract okay now it's done
alright so so that was our first step
and so now we're gonna create our voting
smart contract we're gonna use aetherium
language which is called solidity for
programming our smart contract we're
gonna deploy that contract to the
etherium blockchain and it's gonna
consist of two functions one is going to
return the total votes a candidate has
received and the other to increment the
boat count of for a candidate and these
deployed contracts are immutable if we
have any changes we want to make we
would just deploy a new contract unlike
in a regular web app where you could
just modify the existing code you can't
do that these are these are immutable
pieces of code so we would just upload a
new contract if we wanted to make any
changes and and we could link them back
to each other I like it if we wanted to
but to do this we're gonna first install
the solidity compiler which is also on
NPM a node package so we can run npm
install sol see the solidity compiler
and when we're done with that we'll go
ahead and code
right so let's write some solidity here
shall we so we're gonna start out by
saying we're gonna specify we're gonna
start up by specifying the version of
the compiler that we want to use 0.41
now we're going to create our contract
so we could think of this as kind of
like a class in whatever your favorite
object-oriented language is okay so so
this is our voting contract our first
bit is to create a mapping field which
is the equivalent of creating an
associative array or hash and what this
is going to do is we're gonna say we're
gonna say you int date and this is a
public this is the number of votes we've
received it's a key of the mapping the
key of the mapping is the candidate name
is stored has the type bytes 32 in the
value is an unsigned integer to store
the vote count okay so that is our
number of votes received that we're
gonna store here now so literally so
solidity doesn't let us pass in an array
of strings in the constructor yet so
we're going to use an array of bytes 32
bytes 32 to store the list of candidates
right and we want to have three
candidates so I'm gonna say candidate
list then we're gonna create our
constructor our constructor which is
going to be called once when we deploy
the contract right so this is our voting
constructor right for our class it's
gonna be of type block 32 and the
parameter is are going to be the
candidate names and inside of the
constructor we can set our variable
candidate list candidate list to the
parameter candidate names which is how
we initialize it ok so then when we
deploy the contract we're gonna pass an
array of candidates we will be
contesting in the in the election and so
once we have that we can return at the
we will create a function that's going
to return the total votes for the
candidate that that candidate has
received so far
again the parameter is going to be the
candidate and then it's going to return
the total votes as a integer okay as an
integer and so yes we can go ahead and
return it votes received candidate
now we're gonna we're going to create
wait so now we have two more functions
so the next function is going to be to
vote for the candidate right so this is
this the function that increments the
vote count for the specified candidate
and it's equivalent to casting a vote so
for voting for a candidate so voting for
candidate that's going to be bytes 32
for a given candidate we want to say if
it's a valid candidate so if the
candidate is valid and we'll write that
that function lasts so if this candidate
is valid votes received four candidates
plus equals one so if it is a valid
candidate then and only then do we
increment the vote count if not then we
then we don't so this last function is
going to help us decide if a candidate
is valid or not
so we'll say bytes 32 candidate returns
ball okay so we're gonna say okay we're
gonna create a loop and now here is the
terrain completeness coming out all
right because because we can do loops we
couldn't do loops in Bitcoin scripting
language and satoshi do this for
security reasons but overall we need
this if we're going to be able to build
robust capable applications on top of it
so we're gonna say go through the list
of candidates and if the given candidate
is inside of the list of candidates then
and only then do we know that it is a in
fact a valid candidate because we pass
in a candidate name from our thin web
client okay so that's it for our code
let me return false at the end return
false okay that's it for our let's it
var solidity code and then for our
client our client is going to be simple
HTML right so we have some table that's
going to show the three candidates Rama
Nick and hos
and then we have the this on click code
that's going to say once you type in a
name like Rama and then you hit boat
it's going to execute this function vote
for candidate and then it's going to
update that so in the JavaScript section
we can see what this code looks like
right here but what happens is we say we
create a new web 3 object we then
retrieve that the contract that we've
deployed to the blockchain and then we
vote for the candidate or we we retrieve
the content that we deployed to the
blockchain and then we use that we then
we then update the we then send the vote
from the string the string vote that we
did in the web app to the blockchain to
update the candidate and then we can
retrieve it from the blockchain and then
display it in the HTML web app so so
then we can say okay so after writing
our smart contract we're going to use
web 3 J s to deploy our app and interact
with it so our first step we make this
bigger is to open up the node console
and then we're gonna say ok so web three
we're gonna initialize our web 3 object
require web 3 oh kaolin web 3
equals require web 3 okay and so that
okay so we did that and so now we're
gonna say web 3 equals new web 3 and
we'll create an instance a localhost
instance for this to let us access the
etherium blockchain the test chain from
HTTP so it's kind of like an interface
between HTTP and the etherium test RPC
chain close ok we did that and now we
can ensure that web 3 that J is
initialized by querying the accounts on
the blockchain
alright we've we've queried those
accounts and lastly we're going to
compile this contract by reading it
hold on we're gonna compile this
contract by reading it directly so I
called it voting dot solidity converting
it into a string got it then we'll say
require the solidity compiler and then
finally we can then compile the contract
and deploy it by saying compiled code
equals solidity dot compile code okay
and so once I've done that then I can
interact with the contract via that
Ã¡notÃ¡
via the node.js console or we could just
interact with it directly from our HTML
interface which I already have here so
let's go ahead and interact with it from
our HTML interface so let's see I'll
just say you know Rama again to see if
it increments and it increments okay so
that is that is my simple voting app
demo all the code for this is in the
description check it out on github if
you have any comments please feel free
to comment I love seeing comments for my
videos and I hope you found this useful
hey I hope you really liked this video
and if you did please hit that subscribe
button for now I've got to go Reedy
centralize the web so thanks for
watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>