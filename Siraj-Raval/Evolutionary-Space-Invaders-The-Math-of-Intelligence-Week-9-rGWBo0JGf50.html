<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Evolutionary Space Invaders - The Math of Intelligence (Week 9) | Coder Coacher - Coaching Coders</title><meta content="Evolutionary Space Invaders - The Math of Intelligence (Week 9) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Siraj-Raval/">Siraj Raval</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Evolutionary Space Invaders - The Math of Intelligence (Week 9)</b></h2><h5 class="post__date">2017-08-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rGWBo0JGf50" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello world it's Suraj and today we're
going to build a genetic algorithm for
the game space invaders well it's
actually not space invaders it's called
Sidious and major invaders but it's or
it's very similar it's based off of
space invaders so I'm going to start off
with a demo of what we're going to build
there's a JavaScript version of this and
there's a Python version of this and of
course we're going to do the Python
version because that's what we do
Python of course so let's look at this
game first ready set go
okay so we are this dude at the bottom
you you've played space invaders before
I don't even tell you how space invaders
works but it is a special version
because what happens is these invaders
will breed or crossover every 5 seconds
they're going to breed every 5 seconds
and my job I'll hit the space bar is to
kill them all all the time
all of them they're going to keep on
breeding over and over again and I've
got to get them to be obliterated but
they're just going to keep on breeding
and what they're going to do is they're
learning from my behavior they're not
just breeding for the sake of breeding
they are learning from my behavior and
they're getting better over time there's
a learning process happening here but
it's not gradient based optimization
which is what we're used to and it's not
reinforcement learning base which I
talked about last week with a DQ learner
there's a whole different paradigm it's
called genetic algorithms and sometimes
called evolutionary algorithms as well
but now there's a there's a million of
them anyway so that's what the game is
going to look like this is in the
browser we can also compile it from our
desktop but that's the basic idea oh my
god there's so many of them they are
breeding like rain Vader's ok so that's
what we're going to do and so what our
algorithm does very simple it's a very
simple algorithm but the concept itself
is very cool is it starts off with 4
invaders so the game doesn't can never
have less than 4 invaders 4 is the
minimum so there's no there's no winning
the game just you know whatever but you
can't have more than 100 invaders so
that the interval is between 4 and 100
if there are a hundred invaders on the
screen we lose it's game over but if
they're what we try to
keep them as close to four as possible
by shooting them and so each invader has
for what are called genes you can think
of them as attributes as well speed how
fast it's moving the probability is
going to change direction which is
between zero and one as all
probabilities are the size of the
invader it could be big be small they're
variational there's all sorts of sizes
and the color which is kind of
negligible really but what will update
that as well it's a hex value and so it
had four attributes or genes as we call
them in this paradigm and every five
seconds they mate or cross over and it
produces children like new invaders that
are supposed to be better than then it's
apparent than their parents and the
invaders are the highest fitness by some
measure of fitness that we define we're
going to define what Fitness means it's
like you know our measuring contest and
by some measure of fitness we're going
to determine who gets to breed and who
doesn't the very Darwinian process so
that's what it is and invaders that
learn the best or or who have the best
set of genes are going to be the ones
who get to crossover or breed so this is
a this is this image all of genetic
algorithms all of genetic algorithms can
be summed up in this image but before I
get to this image
let me look down here a little bit and
give it a little bit of background
because I never talk about biology but
it's dope so let me talk about it so DNA
we all know what DNA is right it's the
blueprints of life all all humans share
99.9 percent of the same DNA it's that
point 1 percent difference the results
in our the way we are different the
results in Charlottesville and oh anyway
you know I got stay relevant here you
know trending terms anyway but DNA is
the blueprint of life from DNA Springs
everything else and so genes are the
recipes so you can think of DNA as the
cookbook it's a book of all the recipes
and the recipes are the genes right you
have a gene for your hair color you have
a gene for your eye color you gene for
everything right and so DNA consists of
genes and from
genes that make up the DNA strand come
proteins and proteins make up the
physical attributes that make up who you
are so right that's DNA and those are
genes and so we could think of these
genes as parameters for each individual
so each individual is like has a set of
genes or parameters that adapt over time
based on how they breed and so all life
on Earth has sprung up this way through
Darwinian natural selection the idea is
that usually species will overpopulate
it'll they'll create more than necessary
to survive and then there's going to be
variation amongst all the individuals of
the species this this guy's skin color
will be brown has to go will be why is
that's been called black all sorts of
different people and then what happens
is selection so everybody's going to try
to reproduce I mean that's the point of
life if you think about it at the low
level or at the basic level I mean there
there are other points of life like it
doesn't just have to be about sex it's
going to be about social impact you make
your own meaning in the end but I
digress
anyways everybody tries to breathe but
the ones that whose children are the
most fit are the ones who get to survive
or the ones who are most likely to
survive and the way that nature does
this is it lets it find those that are
most fit by some measure of fitness in
the real world it would be brute
physical strength and those genes are
then more likely to be passed on to next
the next generations and so that's
adaption so that's like the idea behind
which now go back to this genetic
algorithms are based off of
so we initialize so the first step is
initialization so we'll create a
population whether that space invaders
whether that's different solution
solutions to some train routes
optimization problem like different
routes and then those routes evolve but
anyway we initialize some population of
solutions possible solutions and then we
assign each of those individuals a
fitness value by some fitness function
that we decide what it's very problem
specific as well like based on the
problem what is the
how fit is this individual or solution
you can call it as well and then we
select those individuals that are the
fittest and then by some measure of you
know what that Fitness is in the easy
case we can just think about it fitness
as outputting just a single scalar value
right for each person and then we just
choose those individuals that have the
highest fitness level and that highest
fitness level could be you know it has
to be greater than 10 or else they don't
get to breed and we choose all those
that's a selection process and then
there's crossover or mating or sex if
you want you know whatever it is and
right so they reproduce these genes why
am i laughing because I said sikes I
know oh my god my so these genes
reproduce that's the whole point right
that's how you came out that's awesome
huh oh okay so then they cross over and
then the fittest ones those are the
children
we then the last step is mutation we
take those children and we add sometimes
we add some kind of mutation to them so
we can multiply it in by some random
distribution like a Gaussian or you know
whatever else and that's that's how that
works so let me go back to this okay so
then we mutate them and so what the
reason we mutate them is so there there
is some variation right it doesn't
necessarily mean that the genes that are
passed on are the optimal gene values
like they could be better but we know
that they are the best of the type of
genes that we've been given so we could
take those best of what we've been given
and if we mutate them we open up the
possibilities of their being better
genes out there that weren't even from
the parents right you see what I'm
saying so that's what we bury them a
little bit we had some kind of
variational probabilistic aspect I'm
doing this because I'm talking from
something about distributions right and
also in terms of crossover there are
different ways of crossing over parents
you could add these two scalar values
together you could multiply them you
could multiply divide by two and then
square it you know it depends on what
you define bikes crossing over and once
we meet some stopping criteria
then we we end the game like let's say
you know we want the solution to be X
amount so we'll measure how good it is
and so in our case that's going to be
having a hundred invaders that's the
stopping criteria but if we haven't met
it and we just repeat this process over
and over and over again all right so
that's that and now we're going to talk
about the use cases so okay so most of
the advances in machine learning have
been due to gradient based optimization
as long as we can compute some gradient
value we can compute how best to update
the weights of our network the
parameters of our network right whether
that's through supervised or
unsupervised learning clustering a
classification generation you know
variational Auto encoding all of these
things are based off of having a
gradient value that we can then update
our weights with but in this case
there's no gradient value this is a
totally different paradigm there is no
linear algebra and there's no calculus
involved there is just algebra like
performing the crossover and then
performing the mutation it's like
multiplication addition subtraction
basic operations and then probability
and the probability is the mutation as
well like you know if there's a
probabilistic aspect to who gets to
reproduce and what those mutations look
like so there's only probability and
algebra whereas in a gradient based
optimization where most of the advances
in machine learning have occurred
there's calculus in linear algebra and
probability theory and statistics so
it's an easier way of thinking about it
and it's not necessarily as it's not
necessarily as efficient when it comes
to certain use cases but these genetic
algorithms are used in real world
applications one of them one example is
for relational databases like post gray
or h2 they select the best query plan by
the which is the one with the lowest
estimated cost they're used in finance a
lot for stock price prediction for
portfolio optimization evolving designs
so computer-aided design is a great
example where you have some idea of what
the solution should be you don't know
exactly what it is but you have some
kind of base design whether that be a
CAD model like a 3d CAD model or a
of rules to conduct some kind of
experiments and you can evolve these
rules over time so that they get better
and better and so this is used in
evolving CAD models in engineering wind
turbines and things like that things
that you would design which is a really
cool field and very close to be related
to generative generative modeling from
grain based optimization like generative
adversarial networks and variational
autoencoders where you generate new data
it's kind of similar to that it's been
the same kind of subfield computer-aided
design
so those are two use cases although
right you don't you don't see these you
don't see like the top researchers that
deepmind or open AI or you know anywhere
posting papers on genetic algorithms it
just doesn't happen but I still believe
in them I still believe in them and when
to use this if you have a huge search
space and you're not really sure what
the ideal solution should be like
computer-aided design it's a very
creative open-ended solution then that
would be a good this would be a good
solution to that problem and so whenever
you have a multi-dimensional search
space is just a huge search space and
you don't even know what the deal is
okay so that's the high level of what
genetic algorithms are now what I'm
going to do is I'm going to go over the
code for this game it's very doable and
it's all going to be in Python the only
parts that I'm going to code are the
three main parts and the three main
parts are selection crossover and
mutation so those are the parts going to
code the rest of it we're going to go
and just glaze over it and I'm going to
talk about what's happening there so
there are four different classes here
there are four different classes and
we're going to start at the highest
level class which is just this right
here this 30 lines of code the main code
and then we're going to iteratively go
down the hierarchy of functions so we
get to the lowest level which is
evolution where that is where the real
evolutionary code is happening and
that's where I'm going to code some
parts alright so let's write the high
level so we have four dependencies here
that we're going to importantly make
this really big for us so we can really
see what's going on here all right
make it bigger bigger is better as they
say in
as I say okay so for for dependencies
sge is a wrapper around pi day now Pi
game is the most popular game building
library in Python and sge you pronounce
it sage is a wrapper over pi game which
makes it even easier to use
however like with all wrappers because
there is a layer of abstraction the
trade-off is you don't get as much
control over the details but we're not
going to talk about you know the details
we're building a very simple game and so
sgz sge is essentially pi game but
wrapped to a higher level game is our
objects that's going to contain the game
logic objects are are the player and the
invader class that will define as well
and os is just for you know operating
system functionality right so in our
main function here's the highest level
of the code so first I'm going to define
where the file is and then we'll create
the game object so when we when we
initialize invaders game that's just
going to set some basic parameters like
the clock time whether or not there's a
game over which there's not going to be
when we start off duh and some other
things but these are just game specific
parameters not player or invader
specific parameters those are objects
alright so then we'll initialize a game
and then we're going to load up the
background and by the background I mean
the color of the the back of the game
right let me just show it over here so
the color of the back of the game I'll
keep going back to this by the way right
so we want a black screen and so that's
what we're doing here we're defining a
black screen we have a wall height we
have a resolution
we call it wall sprite a sprite is like
a figure right animation but the we're
just going to call the background a wall
sprite as well and we'll set it as a
background layer and we only have one
layer so it's just setting the
background layer to that wall sprite as
a rectangle that we draw once we have
that we'll add it to the background so
we take our background layer that we've
initialized and add it to the background
and so that now we have a black box for
a game so far and now we have a
background now we'll initialize our
objects we have a set of invaders so
we'll start off with six of them so we
say let's create a little initialized
and invader six times
and we'll store them all in this
invaders array or list and then we have
our player which is just one that's us
and then we say the player is always the
first object we take both of them and we
add them to this object array with the
player being first so it's in we're
initialized before the invaders are and
then we start the game well we don't
start the game we initialize a session
of the game and so this is kind of like
the PI game specific syntax of like you
know syntactic sugar it's like an
intensive level where you initialize a
session and then you run the computation
graph so we initialize this section here
with the gameroom function giving it the
background that we define and the
objects are player and the invaders and
then we remove the mouse because we
don't want to see any of that we
have--we're focus on our invaders in our
player that's it right and then here we
go we start the game why we initialize a
session and then we start the game and
that's it at high level right very easy
stuff no no evolutionary anything no
anything really
too easy almost right I know it's too
easy for you you use smart use smart
person you alright so alright anyway
where were we right so now we're going
down a level of hierarchy we're going
down one we're going to objects so for
objects we define our invaders right so
we define our game and we define our
classes so now let's define those
objects those those entities inside of
the game so our first entity is going to
be our invader now how our invader is
the one that is the individual that will
breed and cross over you know all this
you know mutation all of this
evolutionary logic will be applied to
this invader so let's define what this
invader what the attributes are so our
first step is going to be to define the
genes the genes for the invader so when
I say attributes this is what I mean the
first one is going to be sides and so
these are key value pairs stored in a
dictionary okay these are key value
pairs so for each of these genes we are
going to sort a minimum value and a
maximum value and we're going to have
some generated random number here so
we're going to be able to say let's
generate a value for this individual for
this gene and it's got to be between the
min and the max and if it's smaller than
the min or it's greater than the max
then we're just returning the min or the
max respectively but you can't generate
a value for this gene for any individual
that's beyond the scope of this min and
Max value right so we'll do that for the
sides of them right so the size has to
be between 1 and 7 the color right we
have colors on a scale of 0 to 255 but
our min is going to be 5 or speed
between 0.01 and 5 our Y velocity or X&amp;amp;Y
velocity of our speeds and you know both
direction both taxis and then our
probability of changing directions in
both the X Direction x direction and the
y direction up and down up and down up
and down wavy hair I got my hair dyed
silver again yes oh my god it was so
long I'm so happy to have the silver
again back to this back to this back to
this ok so we have those jeans and now
let's look at this next function which
is to generate some jeans foreign
invaders so whenever we initialize an
invader this generate gene function is
called right here it has a set of
attributes when we initialize it so
let's look at what this code looks like
we're going to use that generated number
like we define over here to define what
this is going to be like write a value
for the specific gene so we know what
the max value is and what the min value
is and if the generated number is less
than the men return the min if it's
greater than the max return the Max else
returned the generated number and so
that's how you that's how we generate
genes for each individual in this
function right so when we when we when
we initialize an invader like we did
over here we said let's initialize six
of them when we initialize an invader
this is the logic that's being called
right so first of all we'll generate
some random values for its genes and
store them in the attributes and then
we'll set the generated genes for this
invader in terms of genes that's just
you know genes are the attributes same
thing and then we'll set it sprite
animation which is that like now robot
looking dude that was it this this thing
right it's not game over the game isn't
over till I say it's over or till we say
it's over haha okay press ENTER Ready
Steady Go e come on come on gene there
we go
- fun game right so it says little
sprite animation it's like little
character thing here and it's just it's
just a PNG it's just an image a static
image that we're setting here using the
the beauty of sge
that's just lets us you know magically
set these sprites for an object that we
declare and then we're going to pull
these values from the gene so we have
these generated values and they're all
stored in this jeans list but we'll also
have individual variables for each of
these gene values just because it's
easier to call later to get to pull
later on and we'll set the width for the
image and the height the scale and it's
going to start off with 0 in terms of
its Fitness score we don't know how fit
it is yet because it's just initialized
so let's initialize that value at zero
zero to hero Hercules that I was just
saying that I try to keep it interesting
anyway up right so we have those values
and now ok so here's here's nothing
really cool so notice this function
right here is then step you're like okay
event step great what this what this
does is it in one so there are vents
right so every step or time step in the
game there's a series of times that you
know every interval like there's always
time steps in machine learning and so at
every time step do something right so
what is that thing that this invader is
going to do what it's going to do is
it's going to increase its Fitness score
by one because the longer is alive the
more fit it is that's what we're saying
that's what our Fitness correlates
there's more to the fitness score that
I'll talk about in a second but that's
kind of a basic idea but because this
this this invader has survived a single
time step we're going to increase that
Fitness score by one and so then we
change directions randomly so we'll
initialize some random value and say if
it's less than the probability of
changing directions then change the
direction else you know for both x and y
then we have logic for bouncing off the
edges and the wall all four sides up
down left and right ok so that's all it
does it computes movement like where
should this invader move in this time
step and so that's how the invader just
moving randomly all over the place but
it's not just moving randomly it's
moving randomly but based on the
like what the values of these jeans are
so you see how its movement is dependent
on the jeans right one gene will be the
X probability one gene would be the Y
probability the X velocity the Y
velocity okay so okay so here's the
interesting thing so you're looking at
this and you're like okay so this
happens at every time step
when is this function called so you'll
look at this you'll copy it you'll
control f you will try to find words
where it's called well this is just this
is just a duplicate of it's not called
there this is another duplicate where is
it's been called so the thing is it's
not called anywhere there are event
listeners so that's that's another thing
about sge or sage with Pi game you have
adventists inners because if we were to
call this we would just have like a
while loop right because we have to call
it continuously throughout the whole
game but we're not going to do that why
should we do that we're just going to
have these event listeners and they're
built into fgg so what I'm saying is
these functions are going to fire every
time there is a new time step by
themselves kind of Auto magically it's
built into the framework kind of like
iOS or Android programming if you ever
done mobile development you don't want
to just you're not you're not manually
constructing event listeners for all the
actions that a user can do swipe up
swipe down tap you know two fingers
three fingers you have those event
listeners that are a part of the core
framework that are going to fire
whenever a user does that action so user
swipes up which would fire so if you're
if you're to put a breakpoint inside of
that function and the user swipes up the
breakpoint would catch that action and
you could execute whatever code you want
to and it's very useful for mobile
development and it's also very useful
for game development having event
listeners built into the framework so we
don't have to build them so we can just
say then step is going to be this and
the reason we can say this is because
this class inherits from the SCE DSP
object class we're overriding these
functions right so that's that's it for
our invader right that's that's the
basic logic of us defining what those
genes are and then logic for moving and
for generating generating those values
for each gene okay so in a single time
step
now let's define for the player right so
when we initialize a player we are going
to say okay we can only move in two
directions left or right that's it so
we'll define maps for both of those keys
and then we're going to say okay what's
the starting position
what's the sprite image right and that's
it for our initialization steps and then
we can go to our event step and remember
this is called every time step of the
game so we'll say okay first of all
let's capture the direction entered by
the player whether it's left or right
and we'll put that in the key motion
variable we'll find a speed in the
x-direction and then we'll animate the
sprite according to the movie direction
right so if we're going left and move
the image this way we're going right
would be image this way that's it and
then we keep a paddle inside of the
window right so then we're never outside
of the bounding box on both sides we
want to keep the player inside of that
bounding box and so whenever the player
shoes right later the player shoots
we're going to say you know whenever the
space button is pressed the number of
invaders must be higher than the minimum
loud and a number of bullets lower than
the maximum and only if that's the case
can the player fire a bullet so these
are parameters for which for when we can
fire a bullet or not which means we have
one more class and that class is the
bullets itself so like that little
bullet that's traveling when the when
the player shoots so we'll animate that
using this sprite function it's that lit
it's a little you know fiery little
image will set that will set it speed
which is going to be the starting speed
that we define as a beforehand and then
we'll say in the event step which is
happening at every iteration either
destroy it or if there's a collision
then kill that invader whoever it
touches all right so that's four objects
class and now we have our game class and
so in our game class we'll say okay
we've got our game engine we've got our
player and invader object's evolution
which I'll code in a second time and
then our clock so then we have a bunch
of global parameters here for the
resolution for the position of the
objects for how how the number of
milliseconds between generations like
five thousand milliseconds or five
seconds and the minimum generation time
as well like what's the width the lower
limit that we want it to be
the number in invaders four and the max
100 minimum for max hundred so in a game
class which we initialize right here
what happens here well like I said we we
are initializing a bunch of these game
specific parameters the HUD which is a
score and the timer whether or not to
game over
very basic stuff the clock and then we
have some basic code for the HUD which
is not you know I won't go over that and
then a new generation okay this parts
interesting so soul generate some new
invaders and then will reduce the time
between generations which makes it
harder for the player right so that's
what we had this minimum value for the
generations 2000 because the time for
generation between generations will
decrease every time step so it gets
harder and harder and then in an event
step for one full game will first
calculate the number of invaders on the
screen show the score and if it's more
than a threshold it's game over we're
done we're through are the jig is up the
gig is up but if if it's over a
threshold then it's time to breathe
again so we'll create a new generation
right and so but if it's for if it's if
it's if there's four invaders on the
screen and we're trying to kill one of
them we can't do that so we'll draw this
immunity bubble around them which means
that you just can't kill them until more
are generated so that's kind of our way
of saying this is the minimum number of
invaders will have key prices for you
know escaping and for pausing the game
and so okay so this is this an
interesting step this is where the
animation for how crossover is happening
happens right here so whenever so every
5 seconds the game pauses and then those
invaders will breed and then so what's
happening is will say recombinator
crossover step to create those kills
child genes and as a new individual to
our current list and then reanimate okay
and so then for keep resting and for
event closing all right so now let's get
to our good stuff the real the real the
real meat of this code so before I get
to these three things let me talk about
the bounding interval for the genes so
we always have some downing interval
like it's got to be between this this
scalar value and this scalar value so
this is where the crossover and the
mutation is happening and this is where
the selection is happening so the
three really key aspects of how this
works will create a list for the
offspring that will store the values in
for all the for all the children and so
for each pair of parents right we're
giving it parents as the parameters here
we're going to say okay so for each pair
of parents let's go ahead and create an
empty store for the offsprings jeans so
we'll say okay so for the jeans of each
child for the despair of parents for
each gene from the key value pairs
remember it's a dictionary that these
gene values are stored in we're going to
store both pairs as gene attributes okay
so for both parents we're going to
compute what those genes are that we
want to give to our children as values
and we're going to randomly generate the
child genes attribute so for the
children the for the for each child
genes and this gen is going to be the
index for the specific child
we'll use a uniform distribution to
compute what the values should be so
we'll say okay men values and then max
values so it's going to be a
distribution between the min and Max
values for this gene and then we'll
randomly decide it's time to mutate the
children so if if it's so we'll generate
some random number and then if it's less
than the mutation probability then we'll
go ahead and mutate the children else we
won't so this is this is how we select
whether or not we're going to mutate the
children or not right so M our mutation
probability is 0.1 so it's got to be
less than that so we'll say okay so
first get the min and the max values or
the parent so the min and the max value
porta parents pulse again min and then
we have for the the max value for the
parent look at gene props gen max all
right and then we'll get the value for
the child and the child is going to be
that same index and now it's time to
mutate so for mutation here's what it
looks like for mutation so
so basically the communication step for
introducing new genetic material into
the population by replacing one
parameter in the genome by this random
value within the allowed range and then
once we have that then we can go ahead
and return we can go ahead and add the
children to the store so offspring dot
append and then the children gene and
then finally we'll return all of the
children return offspring and this goes
right here okay great
right so that's for a crossover and
mutation that's how we're crossing over
parents we're saying we're taking these
values from both parents and using those
values for those genes to help compute
this child gene and then we're mutating
the child gene right using this random
normal distribution so that's crossover
a mutation and then their selection so
all these children who gets to reproduce
so for all the members of the population
will sum up all of their fitness scores
and then we'll say ok so we'll randomly
generate a distribution and then for
each invader we'll subtract its value
the fitness value from the randomly
generated number and if it's less than
zero then that invader gets to breathe
so here's here's why we're doing this so
you might be thinking okay so why could
we just compute the fitness for each
individual and then say whichever you
know however long it's alive we'll just
keep incrementing that Fitness value the
scalar single value and then the ones
that have the highest Fitness scalar why
don't we just choose those why do we
have to add this random value the reason
we're adding a random value here is
because the ones with the best genes and
the immediate term doesn't necessarily
mean it has the best genes in the long
term so if we add some kind of
variational or probabilistic aspect to
it then that allows for different
possibilities right it means that these
genes right now were the best ones but
let's add some variation to it just in
case there's other possibilities out
there you see what I'm saying so by
adding a variational aspect to selection
it just improves how we evaluate the
fitness
for each individual and so that's that's
it really for this and then we have this
mating pool and tournament but that's
just for that just we're printing out
the terminal so that's it for this code
if you liked it please check out the
github repository I've got all the
instructions in the details in there
definitely try out a genetic algorithm
on your own they're very simple very
easy to understand you don't need to
know back propagation or calculus or
linear algebra very simple stuff you can
easily implement them in PI game and
open a is gym and open a eyes universe
there's a bunch of possibilities and if
you do this then it's just going to
increase your confidence as a developer
as a machine learning engineer as a data
scientist whatever it is so thank you
for watching I love you guys seriously I
do it for you have you made it this far
I'm very proud of you thank you and I'll
tell you a little secret something big
is coming up and only you get to know
that because you made it to the end I
can't say what it is but something big
is coming up before the year ends for
this channel it's going to be amazing
alright so that's it please subscribe
for more programming videos and for now
I've got to evolve my hair so thanks for
watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>