<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How to Make an Evolutionary Tetris AI | Coder Coacher - Coaching Coders</title><meta content="How to Make an Evolutionary Tetris AI - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Siraj-Raval/">Siraj Raval</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How to Make an Evolutionary Tetris AI</b></h2><h5 class="post__date">2017-05-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xLHCMMGuN0Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello world it's Suraj and today we're
going to be talking about evolutionary
algorithms in the context of building a
tetris AI so I've only made one video on
evolutionary algorithms ever and it was
like three months ago so I'm really
excited to make this video we're going
to use evolution we're going to use an
evolutionary approach to build a tetris
AI and this is going to be using
javascript I know
JavaScript for once so let's get started
and you might be asking why JavaScript
well the reason is well two reasons one
javascript is the language of the web
it's not going anywhere
it is a very messy language it's a beast
people are always tacking on different
components to it but regardless it is
the language of the web and second of
all why not because we I want to see
more machine learning happening in the
browser and of yes we could make a
Python shell and then call it from some
front end you know like angular or
something but to do it all in JavaScript
just seems cleaner and even on Drake our
Posse has made a JavaScript library
called called comp net GIS so let's just
do some JavaScript and just see what
it's like if you've never done
JavaScript before that's okay
the code is totally readable it's in the
description and I've made sure to
comment every single line of code so
it's very readable so don't even worry
if you've never done JavaScript before
because this is going to be awesome
and plus it's more visuals so you like
we could see it in the browser right now
we can compile it as we go and see the
changes we make but yeah anyway so
that's what we're going to build and
this is a little demo that you see here
of what we're going to build okay so so
I'm going to start off with a
presentation and the presentation is in
an I Python notebook not that we're
using Python I just I think it's a good
format to talk about what we're going to
do okay so we're going to be building an
evolutionary algorithm for Tetris so the
code in total is like a thousand lines
of JavaScript so it's like a lot of
JavaScript we're not going to be coding
it all in this video what we will do is
we'll code the first 100 lines and the
first 100 lines constitute the highest
level approach so the initialization
function and we're going to call all the
help all the helper methods inside of
that initial 100 lines so you'll get to
see exactly what the structure the
high-level architecture is and
dense amount of code and then we'll talk
about the helper functions okay so get
ready for this but we're going to go
over all one 1000 lines so what is what
our evolutionary algorithms so one thing
I want to clarify is that evolutionary
it means genetic they're the same thing
evolutionary algorithms genetic
algorithms they're the same thing
and there are three parts to an
evolutionary algorithm
there's selection crossover and mutation
so the idea is to replicate Darwinian
evolution right the evolutionary
algorithms right evolutionary algorithms
are based on Darwinian evolution and
just like in Darwinian evolution we have
a population and the population breeds
and only the fittest survived so let's
talk about that a little more in detail
so for step one step one is called
selection so what happens is we create a
population of genomes and genomes
they're also called chromosomes
sometimes but I like to call them
genomes genomes can be anything there
are some entity that you want to improve
over time so let's say we were creating
some kind of like 3d simulation and we
wanted to create a bipedal robot let's
we would probably have a bunch of like
bipedal spiders or you know quadruped
quadrupeds or whatever they're called
but we would have a lot of them and they
would be our genomes because we want
them to improve to breed and improve
over time
and the idea is that each genome has
multiple genes and the genes are akin to
parameters they mean the same thing each
genome has a set of genes or parameters
and what happens is we use a fitness
function to select what the best ones
are
and so the fitness function can be
whatever we decide you know it could be
like whoever is able to walk for a
certain threshold like let's say 2
meters if you if you can walk past 2
meters you can you get to breed congrat
congratulations so something like that
right and that's the selection part we
select through a fitness function who is
fit to breed and once we get done with
selection we move on to step two and
step two is crossover so crossover means
reproduction so the fittest genomes get
to reproduce and reproduction can mean
different things but we have some sort
of merging computation that means
that is akin to reproduction so it could
be like we take both of those winning
spiders or the ones that are fittest and
then we we vectorize them or turn them
find some way to convert them into a
scaler and take those two scalars and
multiply them together and then we get
some output scalar and an output scalar
and then from that scalar we revert it
back into a like a 3d spider you know
what I mean so it's it's it's breeding
and we'll talk about what this crossover
function is but it's entirely
application dependent and that's going
to create a set of offspring and The
Offspring are the next generation there
are a new population and once we have
these set of offspring when the fittest
genomes breed then we perform the last
step in the last step is mutation and
mutation is just randomly editing the
genes or parameters in some way in the
hope of creating more beneficial
features in the future so we have a set
of genomes they try out whatever the
task is the objective and the fittest
ones that are defined by a fitness
function get to breed and then which is
cross over and then we take that new
population and we mutate it using some
mutation function which could just be it
could just be like multiplying the
scalar by a random value or something
and then we just continue that process
so this is a map of what it looks like
right we initialize a population and
then of genomes we perform selection
cross over and then mutate them and then
we just repeat the process for as many
generations as we want or as many
generations as it takes to reach the
objective whatever that objective is and
so you might be asking well why haven't
we been using this right evolution is
all its nature we should be using this
more often
well let me talk about why we don't use
this more often so one use case is neuro
evolution right so neuro evolution is
this really cool idea and this this game
is a great example of it but the idea is
that we have a neural network right like
always we have a neural network and it's
its opposite is optimizing for an
objective function and in this case in
the case of Super Mario this is an
example of neural evolution the the idea
is - the objective is to beat the game
in the shortest amount of
like minimizing the time spent for a lap
is the objective function and we use a
neural network to do that and so
normally we would use back propagation
to find the optimal weight values right
but we could also use neural evolution
so we could think of the weight values
as genomes and then we perform the whole
evolutionary process instead of back
propagating where we take some input
data we propagate it through each layer
and then we have an output value and
then we take that output value and then
we have our expected value hopefully
it's labeled data and then we find a
difference between the two to get an
error value and we use that error value
to calculate the partial derivative with
respect to each layer going backwards
and then multiply it by the weights to
update our network instead of doing that
that's that's the normal way with that
propagation instead of doing that we use
an evolutionary algorithm so that we
evolve the weights through crossover and
mutation and so why you might be asking
which one is better so in most cases in
most cases back propagation is still the
most popular it's still given the best
results but evolutionary algorithms are
promising I mean they've been around
since the 80s right it's something it's
not like they're something new I mean
it's a very intuitive idea but they can
give really good results intuitively
speaking like I feel like they can and
I'm opening I released a paper recently
umm what was it called but it was about
like evolutionary algorithms for open AI
evolutionary algorithms but it was a
cool paper evolution strategies as a
scalable alternative to reinforcement
learning that is the one so definitely
check out that blog post if you want to
learn more about evolutionary algorithms
I'm going to be talking about it in this
video but that's another that's another
resource to check out but anyway the
thing is gradient descent is great at
optimizing neural networks but sometimes
gradient descent doesn't converge to the
global minima it converges to the local
minima which is like if we consider like
the optimization options as a you know
like a very bendy curve it will find the
local minima instead of the global
minima which means the actual
lowest point and so as a search strategy
it could sometimes be beat by
evolutionary algorithms but we I just
haven't seen a very compelling use case
for it but there is promise I think it's
a great technique and I think as we not
I think as we improve our algorithms we
will see evolutionary algorithms play
more into machine learning in general
that's what that's what that's what I
believe will happen so and and also like
they're also able to discover entire
neural networks so instead of just
discovering the hyper parameters it
would discover the entire neural network
what I mean so you know how we have like
multiple neural networks like neural
networks zoos and each of these networks
is optimized for a different use case
right some networks are used for feet up
for time series data and then some
networks are used for scalar data some
networks are used for binary data and we
have so many different types of networks
what if we could learn what the optimal
neural network architecture is for a use
case and so this is a great example of
when evolutionary algorithms would be
great and this is what's something that
back probably back propagation can't do
back propagation is about optimizing a
single neural network but evolutionary
algorithms can can optimize for the
entire type of neural network so a lot
of promise there okay so enough about
that so what is it in the context of
Tetris when the contents of Tetris is
how it works
we initialize a population of 50 genomes
okay so what are genomes in our case so
notice right here let me make this
bigger so 50 genomes in our case are
these hold on these values right here
not all they see like these seven values
right here in these brackets so these
are weight values okay and we'll talk
about what each of them mean but these
this set of weights is our single genome
that's what we consider a genome a
genome isn't an AI like a bot a genome
isn't a block that's falling a genome is
this set of weight values that we
improve over time that the eight that
the agent that the AI uses to decide how
to play the game so the agent makes
decisions based on these values based on
this genome value and if we can improve
that genome value these weight value
and overtime and these values tell the
AI where to move then we're going to
have some interesting results
right so we initialize a population of
50 of these right 50 of these sets of
values these seven parameter values and
right so each of them each genome has
seven parameter values Rai will make a
move based on them and so it's going to
try out all the possible moves based on
each genome in the current population to
make a single move
so each genome is going to help the AI
make a bunch of possible moves and it's
going to pick the absolute best one for
that genome using some value or measure
that we decide that I'll show you and
then it'll keep doing that and then the
best genome will evolve so we'll take
both sets of parameters and we'll
combine them through some process
crossover that we'll talk about and it
will create a new set of genomes and
we'll keep going until we get our AI
to get to the high score of 500 okay and
this has been running for a while so
we're already up there and we could
speed this up as well but that's the
idea and so in terms of Tetris I'm
hoping you know how to play Tetris you
probably do but each time a block moves
down the score is incremented by one and
when a row is cleared what do I mean by
cleared like when all of the values like
going across from left to right are
filled then that row disappears and then
we get we gain a certain amount right to
the score so there's two ways to gain
points one is to make the block move
down without reaching the ceiling and
the second is to have a row clear and
the goal is to get to 500 without the
block stacking up over the ceiling and
the ceiling is this top row up here okay
so that's the basic idea so let's go
ahead and write out the first part of
this code okay so we're going to write
out the high level code and then I'm
going to talk about the helper function
because we've got about a thousand lines
of JavaScript to get through so let's
get started okay so the first step is
for us to create a ten by twenty grid
write that grid that you saw right here
we want to create that grid so right
it's just it's just a matrix create a
ten by twenty grid create the game grid
which is ten by twenty and let me make
this bigger there we go alright and so
let me paste that because it's quite a
lot okay so here we have our grid
and our grid is that 10 by 20 matrix
that we just saw that's our game grid
and then we're going to define what our
block shapes look like there's there's
an I shaped block there's a j-shaped log
there's an L shaped block right
what are these block shapes going to be
and we define them as a set of nested
arrays right but and these are basically
these are coordinates on the grid that
we want to fill and notice that this is
how it looks like right right so one is
like a you know like two straight across
and then one is like a the one is like
an L but it's rotated right so these are
these are our block shapes that we
define so we define our grid then we
define our block shapes and then we
define our block colors so and these are
just hex values hexadecimal values that
define the color code right good old
JavaScript so those are our initial
function so let's keep on writing them
we have a we have quite a few global
variables here to write out but we want
to cede our we want to see our code so
that it's reproducible and this is for
this makes our code deterministic what
does this mean
this means that we're going to have a
lot of randomness in our code like we're
going to call the random function quite
a bit and what this means is that
whenever we compile the game over and
over again it's going to start off from
the same point so the generated values
the randomly generated values are going
to be the same every time and that's
good because we want to debug our code
and we want to make sure that we have
certain values so it's good for
debugging that's why we see it our code
we do that a lot in machine learning in
general so now we're going to define a
set of parameters and these parameters
are going to be the block shape so let
me just write that out in all caps block
shapes block shapes okay so what are
these block shapes so we want our
current shape we want to keep track of
the current block that we're on so we'll
say well for its x value is going to be
0 and then its Y value is going to be 0
so these are its initial coordinates
that we're going to update over time and
then we have its shape which is going to
be undefined then we're going to update
as well right
like which which of these you know ijl
is is it going to be and then we have
our upcoming shape so we have our
current shape and then we want our
upcoming shape we want our AI to know
what's coming up
okay and so where are we going to store
all these blocks what we're going to
create what's called a bag we'll just
call it a bag but it's going to store
all of the upcoming shapes or blocks
whatever you want to call shapes blocks
same thing we'll store both of them so
we have that and then once we have that
we'll define an index so this is going
to define where we are in the bag like
what what positions block are we or
shape are we using and then yeah that's
it for our block shapes and now we can
define our next set of parameters which
are the game values and the game values
are going to be are going to are more
global they're they're going to be used
throughout the code they're going to be
used throughout the code we're going to
use them quite frequently so that's why
I call them game values okay so we'll
start off with the score that's the most
obvious one what is the score that we
want to keep remember we want to reach
500 and then we're going to start off
with a speed for the game so we can
actually change the speed of the game
through like by doing this like check
this out I can toggle the speed by
saying speed up is e so E see how it
speeds up negatory down again
that's my sound effect repeat it
okay so then we pull it back down again
but yeah that's the idea for the speed
we can increase it or decrease it and
then we have our a boolean like do you
want to even change the speed like
what's the deal here and I'm going to
say well let's let's keep it false at
first we don't want to change the speed
right now and then we want us to save
the state of the game right so what is
the the state of the game and the state
of the game we're going to use that so
as a way to save it and then reload it
later if we want to our genomes wherever
we are in a way it's kind of like model
checkpoints right in tensorflow
so we want to save the state of the game
and then we want to store the current
state of the game right so we have a
save state and then a current state
which we'll call the round state okay
and then
what else do we got here so we have our
speed index so we have a speed array of
values like because we're gonna have
several speeds like preset speeds it's
not like it's some kind of like counter
where we can just like you know like
increment by like intervals of one it's
going to be like four hundred five
hundred a thousand and fifteen hundred
like for speed values so we have a index
in the speed value array that we're just
going to set here and we'll set it to
zero and then we have our what else what
else we have yet we have our speeds we
have our right and so this should be an
array what am i what am I thinking this
would be a set of values be 501 and zero
okay and then we have those and so now
it took time to define our a ID as in do
we want an AI or not so we'll say yes we
want an AI because we could turn the AI
off and then we could just play like
this see like check this out I'm going
hold on where was I
toggle AI a right and then I could just
play instead of the AI but I'm not going
to do it anyway all right so it's going
crazy okay so then we have our AI and we
have a draw boolean which says do we
want to draw the game or do want to
update the algorithm we can do one or
the other and so this this is a boolean
for like letting our algorithm know when
to do that and then how many moves do we
want to take like do we want to take we
want to keep track of how many moves
we've taken so far so that we can take
our next set of moves okay and then but
we want a limit of moves we don't write
the limit that we're going to set is 500
just because more than that is going to
definitely go over the ceiling okay or
ideally for efficiency sake we can limit
it like part officially like this so
that it's going to optimize for that 500
number like that score by doing five
kind of moves or less which would be
ideal right you don't want to do have it
do it in like a thousand moves or less
you want it to do it in 500 or less so
we have that and then we have our move
algorithm and our move algorithm is
going to say it's going to consist of
the seven move parameters which are
those values in the genome right those
seven crime
we're going to talk about what like what
each of those are so so we have that and
then we're going to inspect move
selection so this is just you know a
boolean for whether or not we want to
inspect which moves we're going to play
next so there's going to be set to true
pretty much all the time and in fact we
don't actually even need this value we
could just set it true always but anyway
yeah so that's it for that and so we
have one more set of values which are
the genetic algorithm values these are
the actual like evolutionary values let
me just say it's evolutionary to keep it
keep the terms straight okay so what so
in terms of Genet in terms of
evolutionary algorithms we have a
population which is we're going to say
50 let's just say 50 genomes to start
off with and once we have that we'll say
well let's store our genomes in array
then right so we'll initialize that
array that we want to store our genomes
in and then we'll get we'll keep track
of where we are currently what is the
current genome that we're focusing on
and we're going to say 1 which is the
first index or what you know that not 1
but negative 1 which is the index we
want to start off with and we're going
to we're going to iterate through that
genome array as we try out different
things so right what else we've got a
generation and what's the first
generation called it's the 0th
generation right it's the 0th generation
and then we want an archive so this is a
this is for us to store what our values
are for each generation and what we're
going to do is we're going to use java
scripts i'm built in local storage
function which is supremely useful and
what local storage does is it allows us
to store some set of values in
short-term memory in RAM right which is
amazing because you it's just super
useful like we don't have to use a
database we could just store it in
memory and that's super useful not
computationally expensive we'll have a
set of elites which are the which are
the
genomes that we selected to reproduce
and we have all of our genome so we want
to keep track of both so what are the
elite genomes like the fittest ones that
we define and then what are the what are
the general genomes like all of them
okay so we have that and then two more
few more parameters and then we're good
to go so we have our genomes we have our
population data make sure that all right
and so then we have our mutation rate so
this is going to be our value that we
used to mutate the children and we're
going to say it's point oh five and we
can tune this just like we would hyper
parameters in our neural network we can
tune this to make it better but we'll
start off with 0.05 right it's kind of
like the learning rate right when it
comes to back propagation but this is
the mutation rate the similarity is is
definitely there and then we have a
mutation step which is going to also
it's kind of like momentum in this case
but what is a race that we want to
mutate and then the step is what is the
inner interval that we want to apply
that mutation rate to you'll see what I
mean when I when we look at the code for
this but okay that's it
that's it for our global variable that's
a lot I know right it's quite a lot of
global variables but hey it's JavaScript
and welcome to Jas world so let's go
ahead and write out our first function
so this is the highest level function so
this is what I was talking about when I
was saying that we're going to write out
the highest level part and then we'll
talk about the helper functions all
right so it's all going to happen in
this initialize function although all
via high-level magic so the first part
is for us to initialize our population
size so assuming that we have it in our
archive like in local memory which we do
we'll say like okay let's store it let's
well we're going to store it in the
archive we're going to store the
population size 50 in our local memory
which is that that archive that we
defined here so that's our first part
this initializes the population size and
then we want to get a shape right so
we'll say next shape so this function is
going to give us the next shape from the
bag that we have of what is the next
shape that we want the AI to play so we
have our next shape and then we want to
apply that shape to the grid so we have
that shape which is an L or o or
whatever and we want to apply it to the
grid one way what do I mean by apply
we want to we want to stick it in the
grid so it stays in one place right when
it falls down and then it becomes a part
of the grid right so we have that and
that's what apply shape does we've
initialize our population got a shape
apply this to the grid and then we want
to save where we are so we'll say let's
say where we are by using the get state
function to get our saved state which
are those values those those genome
values and then we want our current
state as well so we'll get both using
these getter functions get state and so
we'll have two clones these are clone to
the same state one will save and then
one will set to our current state and
then we'll go ahead and create the
initial population we've defined our
initial parameters so now we can just
create what that initial population will
be and then we can define the game loop
so we created our initial population of
genomes 50 genomes which are randomly
generated values for these seven weights
and then we can start go ahead and start
the game loop so the game loop will call
it loop is going to be a nested function
and this is where the this is where the
actual you know the logic happens so
then for the logic we'll say okay so
let's say let's see if someone said
change speed vis which is a boolean if
someone wanted to change the speed we'll
go ahead and do that for them and the
way we'll do that is to use Java scripts
built-in functions so it's clear
interval given an interval value it's
going to clear the the timer so we have
a game timer and we want to clear it and
once we do that then we can say okay so
the new interval is going to be set
interval given our loop and if given
speed this is going to give us a new
timer let's go ahead and say change
interval equals false so we don't change
it so we stop the time and then we don't
change it here okay so that that's the
first if statement so we have one more
if statement so we say if speed equals
zero so if there is no speed so the game
is stopped we need to say well don't
draw anything I mean we we stop the game
so there's no need to draw anything
right so we say draw equals false and
then we say
time to update the game right so
regardless of whether or not we're
drawing we we want to update and so this
is why I said that we want to either
draw or we want to compute our
evolutionary algorithms we could do both
actually but we're going to keep the
simple we could do both asynchronously
using some kind of concurrent library
but then there's like callback hell and
there's a way around that with like
promises but we'll focus on the
evolutionary algorithms right now okay
so so we have that and let's go ahead
and say ok so that's our zip statement
so then else let's go ahead and draw the
elements so if the speed is not 0 then
we need to keep drawing when you tell
the game that we need to keep drawing so
if they draw the elements and the
elements are going to be true though so
we'll set draw to true that's going to
tell our game to draw the elements and
so by the way the update function is
going to update the game if that means
it's going to update a fitness make a
move and evaluate the next move there's
going to update the fitness function
make a move the AI will make a move like
you know what wrote what shape to put
what block to play how to rotate it and
then until it goes to the bottom and
then it's going to evaluate the next
move using that previous mood and will
update it three times to do that we
could update it just twice three times
or four times but we'll just updated
three times just so we have some kind of
updating happening so then we're going
to do an update in general right so
regardless of anything whether or not
the player so this is all about changing
speed so regardless of whether or not
the player changed speed we want to
update the game anyway so we'll update
it right and then we'll say plus we got
one more value so
so then oh this should be a part of the
game what am I thinking
blah blah blah so then we'll update this
update regardless and then we'll say one
more time so if speed equals zero then
we're going to draw the elements and
then we're going to update the score
okay okay so then we're going to
initialize it with the document onload
function and so the document onload
function is going to initialize our our
initialization function right when the
Dom loads up for JavaScript right the
HTML elements and all those things
whenever you load up the web page run
this function that's what it means okay
so that's the gist of it but the idea
here is that we are going to initialize
a population right so we initialize a
population of genomes which are those
sets of values and then we run a game
loop and then whether or not the player
has decided to change the speed we're
going to reset we're going to reset the
timer for the game and then we're going
to iterally update the game and then if
the speed is zero then we update the
score okay so that's the high level code
and now we'll talk about the helper
functions because we've got a lot to go
through so let's talk about them okay so
we probably want to start off with
looking at this create initial
population function and then just move
on from there so we'll go into order
like in order of what we need to look at
cuz we have a lot of functions and I
actually have them here at the bottom
let me just move this hold on phone
phone phone okay where were we
let's get started okay so move this out
of the way okay so the first thing we
want to look at because this is a
function this is the main function right
this initialization function so let's
look at this create initial population
function so for create initial
population this is our keydown function
this is just like you know depending on
what key you press run one of these
functions like you know if you press W a
s or D which are these key codes move
down the left move right save the state
if you press Q load up the previous
state if you press W change the speed if
you press e turn the AI on or off these
a bunch of just a bunch of key presses
so we can just
skip this function key presses right
this is our this is our code so let me
let's talk about this is that this is
the fun part okay so click our create
initial population function we're going
to initialize a genome array which we're
going to store all of our genomes in and
then we're going to say okay so given a
population size so it's going to be 50
right we defined it as 50 so given 50
genomes let's say each genome will
initialize it just like this so these
are the seven values that you saw right
up right over here right these are the
weight values that improve over time let
me slow this AI down
it is moving so fast that it can't even
draw fast enough and so that's what we
need a sink more asynchronous code so we
could do that right but we have a we
have suboptimal code in terms of
synchronization and concurrency but
that's okay let's see so you watch the
voice values improve watch them improve
they're going to improve once this once
we move on to the next generation yeah
there we go they improve see okay so
that's how they so they're like weight
values their weight values okay so let's
talk about each of them so we have an ID
so each genome gets own unique
identifier that will initialize randomly
and then we have our rows cleared up
parameter or gene these are genes right
the genome has genes which are
parameters and so what rows cleared
means it's the weight from each row
queered by the given move the more rows
that are cleared the more this weight
increases so it's a way of quantifying
how much how many rows we clear and
clearing a row it's a good thing right
the road disappears it means all that
row is filled to our score score
increases so we create a weight value
that represents how many rows are clear
you might be asking well why don't we
just have the direct value the absolute
value why don't we just say well two
rows have been cleared or three rows
have been cleared because the weight
value it's kind of like a weight value
in a neural network where these weight
values are they look unrelated to the
input data and the output data but in
actuality they're like they are
measurements that we use as scalar
values essentially whenever we're matrix
multiplying to compute an output so
these values change there they look like
they're unrelated but they're updated so
that we
reach that optimal output in the end
there used to optimize for our objective
whatever that objective is and in this
case that objective is to get a score of
500 and so we use rows cleared as we use
a weight value that represents the rows
cleared and we initialize it randomly
right minus 0.5 and you'll see more
about this when we when we actually use
the amount of rows cleared to calculate
this weight value it all plays into it
right but we initialize that as random
and that we use the amount of rows clear
to update it and then we obviously then
we use cross over to update the weight
values in general like all of them okay
so so here are seven weight values we
have rows cleared then we have weighted
height which is the absolute height of
the highest column to the power of 1.5
so the highest column that we've reached
when in an inner generation is the
weighted height and it was added to that
we can detect if the blocks are stacking
too high and then we have a cumulative
height which is the sum of all the
column I so we add all them together and
we use that sum and then we have a
relative height which is the highest
column minus the lowest column and the
holes which are the sum of all the empty
cells to have a block above them so
whenever we have our game like the holes
would be right here right here at the
bottom like these are no TVs are nope
these bottom values right here are holes
right where my mouse is check those out
those are holes so we're going to we
want to minimize for those holes right
and then we have a roughness which is
the sum of the absolute differences
between the height of each column right
so just like weight values in a neural
network we don't know what these optimal
values should be right that's why we're
going to optimize for them and the way
we'll optimize it through evolutionary
algorithms to your selection crossover
and mutation that's how these weigh
values learn what what the optimal value
is like we don't know that we have to
minimize the amount of holes right oh we
but I mean we know we intuitively know
that we should minimize the holes but we
haven't told the algorithm that it will
learn to minimize for the amount of
holes it will learn to minimize for the
relative height and the weighted height
right because we want the smaller
heights are good because it means that
our block our rows are clearing that are
our
blocks or shapes are fitting together
right so those are the genes for each
genome and we'll take each of them and
push them to our genome array that we
initialized and then we'll evaluate the
next genome ok so right so speaking of
evaluate next genome let's look at this
next function right we created our
initial population of genomes and then
we're going to evaluate the next genome
so let's see what that looks like
ok so me make sure that were yeah cool
so this is the actual selection part now
that we value now that we created that
initial population we want to select for
the best genomes right so how do we do
that
so we say ok well first of all let's
increment where we are in the GMO genome
array so because we're going to do this
to each genome right what is the next
genome let's evaluate it in the context
of Tetris so we say ok so if there is
none then we're going to involve the
population and so that is the crossover
step if there is no next genome it's
time to move on to the next generation
right and that means like start breeding
but if there is one then we want to use
it to evaluate what the next move is so
we'll load up where we are in the game
we'll reset the amount of moves because
we're going to try out a bunch of moves
for this genome and then we'll make the
next move ok so so that's our selection
step so now let's talk about crossover
so when it comes to crossover so let's
say that we've tried all of them out
like we've tried all the genomes out and
now we're going to evolve let's talk
about what evolution looks like in this
case given a set of genomes so this is
the our evolve function and this is
where the step 2 of evolutionary
algorithms happen this is where that the
the mating step happens don't worry it's
not rated R or rated X it's totally
rated G ok yeah ok so yeah it's rated G
so anyway ok so we're going to take you
balls and then we're going to evolve
this genome so how does this work so we
say ok so we're going to reset the
current genome for this generation and
we're going to increment the generation
it's time to move on to the next
generation reset the game because every
time we have our new generation we want
to reset all the block values right so
it's empty the grid is empty again
we say ok so let's get the current state
of the game with where we are in the
game and then this is our way of thing
who has the best fitness so we use this
function we haven't actually defined
what the fitness value is but we're
saying like assuming that we calculated
it which we will in a different function
that I'll talk about
assuming we calculated what the fitness
will be we can then sort all of our
genomes in order of fitness and that's
what this function do it this as what
this function does it's going to sort
the genomes in that array in order of
fitness and then once we have those
we'll push each of them into our elites
remember our archive array had this
elites value right up here or was it a
data see this one these elite values are
the ones that are fit to breed right
these are the ones that are fit to breed
they have the most fitness of all the
genomes and we can say let's add them to
this array because we're going to then
use those to crossover to breed so then
we'll say ok so then we'll remove the
rest so the tail-end so the population
size divided by 2 if the length is
greater than that pop it off the list
like that like a stack right pop it off
and oneit it anymore so we're only going
to focus on the fittest genomes and then
we're going to say ok let's sum the
total of the fitness of each of those
genomes together to get the total
fitness okay and then we're going to get
a random index from the genome array
which says ok let's get a random
weighted numba tween 0 and the genomes
length minus 1 and we're going to use
that genome as our this is our selection
function right
this is selection right here this line
is essentially selection
we're basically randomly selecting ok
and that is our fitness in this case so
it's a very brute force not brute force
sort of error it's a very primitive
Fitness function I mean we could do
other things but it is Fitness function
it is a fitness it is a fitness function
right it is better than nothing so
that's how we choose which the witch
genomes are going to be fit to breed
randomly ok so then we have a children
array that we were going to populate
with our children and we're going to
push the fittest genome to that array so
we already have those fittest genomes
we defined and we're going to push those
fittest genomes to the array because we
popped off the bad ones or that's not
fit ones and so then once we have that
we're going to say while the length of
the children is less than the population
size we want to push all the now it's
time to actually make the children to
that children array so we'll say okay so
push the children and the way we do this
is we take two random genomes that's how
we select our parents and then we and
then we do some dot some computation
that's defining this make child function
that we're going to I'm going to talk
about and then we're going to get a
child a child genome and we'll push that
to the children array okay so that's
that step and then we're going to create
a new genome array and we're going to
store all the children in there and then
we're going to store that in our archive
so we saved it right and then we'll say
okay so now this is the current
generation so we have our past
generation and our current generation
and then this is the local storage part
this is where we saved the archive
thanks JavaScript short-term memory kind
of like a differentiable neural
computers a external memory bank no
that's too advanced for this that's
pretty awesome that wasn't it if you saw
that video cool okay so all right so how
do we make our children well kids well
boys and girls this is how we make
children here Reno was kidding
what am i doing okay this is how we make
children we make children by hand so
many jokes can happen here
focus Suraj focus on have a child
function we are going to say okay so we
have a child so we have a mom and a dad
so right the mom and the dad are two
genomes from the previous generation
with those seven parameter values so
we'll first initialize a child using
both mom and dad's values for those
seven parameters and we'll pick a random
choice we'll pick a random value that's
how the actual reproduction happens okay
so that's a reproduction set that's the
cross over step step to cross over it's
happening here so we say four rows
cleared for all those values we're going
to just pick a random one between both
month between either mom or dad and then
once we have that child with
it's seven parameter values that have
been decided by cross over which is
actually just randomly picking between
the two then we can mutate each of them
using our mutation step so it's a step
three this is the mutation step the last
step of evolutionary algorithms right so
we'll say if a mutation rate is greater
than some random value then set that the
child's value that that parameter value
that gene for each of the genes to its
own parameter value plus some random
value times our mutation step times two
minus our mutation step so this part
right here is yes magic number territory
but recall from hyper parameter search
it's very similar to hyper parameters
you know we have to kind of guess and
check what these values are and then
whatever works best that's that's what
it is and you know we can learn to learn
and we can just have everything be not
magic numbers and then use evolutionary
algorithms even for the these parameters
but you know that's a step further but
right now we're going to set a two x two
right and then our mutation step and
we'll do that for each of the values and
at the end we'll have our mutated child
will have our mutated child but yeah so
we'll have our mutated child that we can
then return okay so uh yeah so that was
those are the three steps that's that's
that's the logic for an evolutionary
algorithm right selection crossover and
mutation so but let's keep going right
so make next move is the next thing I
should be talking about so back to this
back to this evaluate next genome let me
go back there's a lot of code here so so
so keep keep track with me I know
there's a lot of code but remember that
first step creating an our initial
population and then we took okay well we
created our genome we define what those
parameters would be and then we
evaluated a next genome right and we
talked about what the evolved function
was and then we went down that chain
that hierarchy of what was next and that
was basically old evolutionary
algorithms but let's talk about this
make next move step right this right so
make next move right yeah makes next
move and then get all possible moves yes
so let's go to that make next move step
what is it what does it take to make a
next move and so that is how does our AI
decide to make a next move based on
those weight values so this is how it
happens let's go
down there so here's our make next move
step so here's how it happens so we
increment the amount of moves taken and
then we say if it's over the limits then
we want to update the genomes fitness
value using the game score and then
evaluate the next genome but if it's not
over the next moves limit then we're
going to make the next move for this
genome so we're going to say okay so
we'll store the old drawing so we just
have that stored and don't say let's get
all the possible moves and we'll talk
about what this function is but
basically this function is going to
define all the different possible moves
that a genome can make in a game state
so it's going to rotate a block this way
this way this way
move up down left right all the possible
moves that you can make for one genome
and we're going to store that in a list
and then we're going to get the state of
the game because we're going to update
it and then what's the next shape to
play we want to define that so here's
how it goes down we say for each
possible move let's get the best move so
we're checking all the possible moves
and then we're gonna get the
highest-rated move the best move move
set move section is what I called it
so we get the best possible move and we
saw that in our next move function okay
and so that's what the best move will be
and then we're going to say we're going
to add that rating to an array of the
highest-rated moves right then we'll
load the current state and we'll say
well well looks like the highest-rated
move and sort that and move and then
rotate the shape as it says - so for the
amount of rotations and move that's how
many times we're going to rotate the
shape and then move left as as many
times as it says to translate and then
move right as it says as well so this is
like it's decided what the move should
be based on those weight values based on
those up on those genes proto genome and
now we it's like we got that back so in
this get highest-rated move and get all
possible moves these two functions
that's where the actual weight values
play into the move then the move that
we're going to make so we'll go into
those functions in a second we just keep
diving in deeper and deeper
so once we've made the move then we want
to update our move algorithm and then we
want to draw the old drawing output the
state to the screen and update the score
okay so let's talk about what this did
all possible move function is and then
this get high
rated moon function so so we'll say okay
so forget all the possible moves will
initialize the last state the possible
moves the ratings and then the number of
iterations so it's basically a bunch of
nested statements so here's here's how
the waves play into the the genes or
weights play into the move that the each
player is going to make so say for each
iteration so we have between negative
five and five so ten iterations we're
going to load the last data and then
we're going to say rotate the shape for
as many rotations as we defined up here
up here so for each possible rotation
move left as many times as we can move
right for many times as we can and if
the shape had moved at all then move it
down that means like if it's able to
move it so it's not blocked then move it
down and while the results are and if it
if it has if it's able to move then move
it so here here's the step right here
this this part is how the weights how
the genomes how the genes play into the
move we set the seven parameters of a
genome right here okay so these are the
seven parameters we set them using these
getter functions and then we rate each
of them so given our algorithm we rate
for the current genome all these values
by multiplying them together and we just
concatenate all those values together to
get a scalar rating value and if the
move loses a game then we want to lower
that rating so if it's a you know
boolean value the move lost then we want
to lose the game then we want to I mean
lower trading so then we push all the
possible moves with their associated
ratings and parameter values to an array
so we tried out all these possible moves
using this using these parameter values
and so these get getter values are
getting these weight values from the
state of the game so whatever they are
currently it'll get them and then we'll
use them to rate each of the parameter
values in our current genome and but for
every single one that we try out so each
genome is going to try out a bunch of
moves and then we'll use those parameter
values to rate each of them okay and so
then what
we have all the possible moves we'll
update the position of the old x-value
for that shape and then push that to the
old x-ray and then load the last state
and return that array so then given that
array well how do we get the
highest-rated move right so that's the
next function so we'll start off these
values is very small so we have an
initial max rating that we want to
update and a max move variable as well
as ties which we'll talk about okay so
so we'll say also so let's iterate
through the list of moves however many
moves we have and then we'll say if the
current moves rating is higher than our
max rating which it will be at the start
because there's a very very small number
then we'll update our max values to
include this most value and then we'll
store the index of this mood of this
move in our ties array else okay
so else if the current moves rating is
not higher than our max rating then add
the index then if it ties with the max
rating then we're going to just push it
to this ties array ok so then eventually
we're going to set the highest move
value to this move value and then set
the number of ties right here and then
we're going to return the move okay so
that's how we decide what the
highest-rated move will be given those
all the possible moves we can play so
and then one more function that I want
to talk about over here is the update
function so where do we call the update
function well we call the update
function right where was it
the update score oh we call it up here
so at the highest level right so we went
down through all of what create initial
population means right we went down
through all of that now we want to talk
about the update function and
clearinterval is just like native
javascript but we went through all of
that logic and remember this is the
highest level function so this is what
matters and we went through all of this
and so now it's time to go through the
update function right so how do we
update the game okay so let's let's see
what that looks like and I have
painstakingly commented every single
line here so definitely check out the
code on github but where were we for
update okay so here's how we update the
game so this is pretty this pretty
readable code I like it so if we have
our AI turned on and the current genome
is nonzero so we have it we have a
genome and it's da I then make a move
and so we move the shape down and if
that didn't do anything if we and if we
lost then update the fitness function
and move on to the next genome but if we
didn't lose that make the next move
pretty simple right so and if so then we
have another else statement so if the
move didn't do anything then just move
down right so if the move didn't rotate
then we move down and then we output
this date to the screen and then update
the score so let's look at this update
score function what is update score mean
right so this just updating score just
means drawing it to HTML like outputting
the score value to HTML after we've used
the seven gene values to help rate each
possible move for each possible genome
and then we picking and then we pick the
highest one or the fittest one because
we randomly cross cross over we randomly
select children be a cross over and then
when you take those children via our
mutation rate once we do that then we
can update the score and the score just
means updating the score to the
II to HTML or to the to the to the Dom
to be more technically accurate okay so
and then the rest of these helper
functions are just getting set of
functions that was really the main logic
of this code these are just getting
center functions like cumulative Heights
and get holes like it basically goes
through the grid and then just like you
know calculates like how many zeros
versus how many ones
what's filled in versus what's not
that's what this part does and then yeah
that's basically hit but it's about a
thousand lines of code but it's all it
all fits in this j/s file and it's all
readable so I definitely hope you check
it out it's going to be awesome if you
do I want to see more people using
evolutionary algorithms and let me end
this with answering a just two questions
randomly from the comments okay so let
me answer some questions from the
comments here we go here's the question
we need to block chains to distribute
and decentralize our systems so no
single entities like governments or
organizations can overpower us
absolutely I think there's I mean there
is a huge opportunity to combine
artificial intelligence with blockchain
technology to create entirely autonomous
organizations and corporations and all
sorts of organizations that live in a
distributed system that no one has
control over and it just it self
improves itself and it has its own rules
embedded in smart contracts and yeah
there's a lot of possibility for using
block chains and it one idea that I
think is really great is the idea of
tensor coin so a distributed system
where you're using a cryptocurrency to
pay people for compute peer-to-peer
compute so there's my answer to that
like it's not really a question it was a
statement but one more question and the
question is
and you please make a tutorial on
handling multivariate time series data
using LS p.m. and Karros
so yes I've made a video on that but how
to predict stock prices easily and also
what else yeah that's the main one ok
cool
please subscribe for more programming
videos and for now I've got to go evolve
so thanks for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>