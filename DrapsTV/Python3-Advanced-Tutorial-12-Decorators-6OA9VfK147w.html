<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python3 Advanced Tutorial 12 - Decorators | Coder Coacher - Coaching Coders</title><meta content="Python3 Advanced Tutorial 12 - Decorators - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/DrapsTV/">DrapsTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python3 Advanced Tutorial 12 - Decorators</b></h2><h5 class="post__date">2016-08-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6OA9VfK147w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to Python 3 advanced 12
decorators in this video we'll be
looking at the complex idea of
decorators this topic can be confusing
and it took me a little bit to get my
head around the idea everybody who have
all slideshows anchored available in the
description so what are decorators
decorators as an abstraction changes the
behavior or adds features to a function
decorators are a less known programming
pattern but as that influences in almost
all programming languages really a
decorator is a fancy way of talking
about overriding a function with a newer
and better one before we tackle
decorators head-on let's look at nesting
functions this will help us with
understanding decorators in Python we
can nest functions inside other
functions so it can break up our
functions into smaller functions but
functions that are inside another
function can only be used inside that
function it follows the same scope rules
as the rest of python another thing that
will come in handy is that if you leave
the parentheses of a function it will
act like a pointer to that function and
we can store it inside a variable if you
watched my methods video from the
intermediate series you will remember
that we can store methods to use later
inside variables we can also do that
with functions so here we have an
example of a nested function first we
define a function and inside it we
create a variable called X and then set
it to hello world then we define a
second function inside it in which we
print out the value of x but now we do
something sneaky back inside the first
function we return the second function
here we pass it back to where the first
function was called from so I pose the
question does the X go out of scope and
the second function is returned does it
disappear well in fact
Python has a feature called function
closure this is where the power of
nesting functions comes in whenever a
function is defined in a non global
space that is anything inside a function
or a method - takes a snapshot of what
all the variables and values were at the
time of definition you can even test if
a function is storing any values by
calling the closure attribute of a
function so
we can finally get to decorators a
decorator is just like the example we
made before except instead of printing
out the value of x we modify or add to
the function here we have the original
structure of our nested functions
however this time we pass in a function
as a parameter this is how our
decorators are born in this simple
example we pass in a function as old
func then inside our second function
which will be the one we return back to
overwrite the original function we get
what the result of old func would have
been and then add one to the result and
return that instead on the third last
line we returned second back to where we
called this function from these last two
lines are an important part of piecing
this all together we create a new
variable and store the result of the
first function passing in some function
we want to overwrite then we get the
result of our new function we can then
run our new function and get the
modified final result even just
explaining this now I understand it can
be confusing I just can't think of a
better way to explain it
hopefully these colors hope your
understanding of what's going on let's
give it a go and try writing a simple
decorator we'll write a function
decorator to check if a file exists
before we try and read from it rather
than handling it with a try-catch let's
call the file exists Dec PI all right so
over here in PyCharm I've got my file
already opened and ready so first thing
we want to do is import OS because we're
going to be checking in with file exists
and we're going to define our decorator
function so we'll call it exists so def
exists and it's going to take the old
funk as a parameter and then inside
we're going to create our inside
function so def inside and that's going
to take a file name so that's gonna be
the file name of the file we're checking
for so any function that uses decorator
needs to provide a file name alright so
if I've in brackets the OS path exists
and the filename that we passed in so if
it exists then we're going to run the
old function with the filename else if
it doesn't exist then we're going to
print out print out say the file does
not exist all right so that's our in
front inside function done now in our
exists function we're going to return
our inside all right so we've created
our decorator now we need to create our
function that's going to be decorated so
let's death we'll call it a output line
and it's going to have the in file so
the file name and then we're going to
with open and lift up the in file as F
then we're going to print F whoops print
F dot read lines all right so we're
reading the lines out of the file that
we open up all right so now that we've
created our function we want to decorate
we can create our decorated function so
let's create a variable called func and
that's going to equal exists with our
output line function passed in so now
we've got our decorated function we can
start using it so func and let's do
something that works first so I know
definitely in this directory that the
exist Dec dot PI file so this file that
we're working on at the moment currently
exists and it's two another one that
doesn't exist so I know that
a test pie doesn't exist in this
directory so that should return the file
does not exist all right so let's save
this and run so come up to the top run
and when we run it we get all of the
lines printed out of our code file it's
because it did it did actually exist and
on our second line we have the file does
not exist because it was unable to find
the second one cool but the only
downside to this currently is that we've
got three lines just to use our
decorator function and really we only
want to use the one so what we can do
instead is instead of having to reuse
this whole sort of section here we can
just put at the top of our decorated
function that we want to decorate at
exists and what that's telling it is to
decorate this function with the exist
decorator so the one that we've created
up here and then we can remove these
line down bottom here and instead of
func where you can just call our
function so output line and out put line
and when we run this we'll get the same
output save that run and we get
everything's printed out from this file
and also the file does not exist for our
test file cool sometimes well actually
many times we want to take unknown
amounts of parameters into our
decorators if we want our decorators to
be reusable or want to share them with
other people we aren't always ready for
what their function may look like so if
you've used Python much you'll have
probably heard of star args star star
keyword args the single star as a
parameter means you are taking a couple
of arguments that could be used of any
size the double star lets you take a
dictionary of named arguments that could
be of any size the standard is to use
the words args and kW args but sometimes
you may not be able to do to them
already being defined which we'll see in
a later example all right let's go
another simple decorator this time we'll
just print out the parameters that are
passed into the function we create we'll
call the file params dak pi alright so
over here in PI chum I've already got my
file opened and ready so the first thing
we're going to do is create our
decorator so def params and we'll take
in our old function and then we're going
to death inside a decorated function and
star ogz comma star star KW args keyword
arguments and that will allow us to take
as many arguments as we want in the
function and then what we're gonna do is
just print and will print out params :
space close quotes and then come on hogs
comma kW arcs so that'll print out all
of the parameters that are passed into
our function and then what we're going
to do is return hold func and it's going
to have the star star star kW args take
as many parameters as it likes and then
inside of our params function we're
going to return our inside function
all right so want to create the
parentheses on me alright so now that
we've created our decorator what we can
do is create a decorated function so
let's use our act params and let's call
create a function called mult so def
mult that's going to multiply an x and a
y and we'll make it so that Y has a
default value of 10 if nothing is
entered and then we're going to just
print it out say x times y so just
something simple so we can see that it's
working
all right so now let's try running our
function so mult for four should give
this sixteen molt let's say just to put
in a three give us twelve actually no
that will give us 30 and now mult
will do one more and we'll say that x
equals one and that y equals three
all right so now if we're using our
function let's give it a shot so we'll
save this file and we'll give it a run
all right so we run our file we get
params is four and four and we get an
output of sixteen our parameters three
and the Y is ten so we get 30 and our
params X 100 our keywords rather at x +
1 + y + 3 and we get the output of 3
cool so it's all working correctly all
right hopefully this is starting to
click and you're getting a grip with the
idea of decorators now let's step this
up a level and add parameters to our
decorators this isn't talked about much
but I feel it is one of the most
exciting features decorators have to
offer we can pass parameters into our
decorators and modify what the decorator
does to the decorated function now how
might we do this well we add another
nested function causing a chain of
function returns now we return to our
original nested function example except
this time we have 3 functions and the
order works a little different first is
for our decorator function with
parameters then we have our second
function which acts as the actual
decorator for the incoming function and
then the third function is our decorated
function that we are overriding with the
great thing is we can also use these
star args star star keyword uggs
to take many parameters into our
decorator once again confusing but
hopefully the next example should make
everything clear
let's build one more decorator that
wraps strings in HTML tags ready for
placing into a web page we'll pass in
the tags we want to wrap the result of a
function in a decorator will look
something like add tags Open bracket P
comma B close brackets which will
surround the result in bold and
paragraph tags let's call it add tags
Dec pi all right so once again over here
in PyCharm and i'm going to start by
creating my decorator so deaf and i'll
call it add tag or add tags rather and
we're going to take star tags so we're
going to take multiple tags if if
necessary or just one and now we're
going to define our decorator so death
and we'll call it our deck or radar and
our decorator is going to take the old
funk like usual case F and then we're
going to have our def inside and that's
going to take star args star star kW
eggs so that we can take functions of
any size or any type kind of depends
what they're being fed into them and
what we're going to do is we're going to
get our code out is going to equal our
old funk so we're going to run the
function that we're wrapping and passing
in star oops
star eggs and star star kW args and for
the tag in reversed so we're going to do
it in reverse order reversed tags :
we're going to curd equals and we're
going to use a format string here so
we're going to
a template of zero for the first tag or
for the tag and then we're going to use
a template for the actual string that
we're wrapping as one and then we're
going to use our closing template of
zero so for the end tag and close that
up and then we're going to dot the
format I'm going to pass in the tag 0
and E code for 1 alright so now that
that's wrapped with each of our tags
we're going to return code and now we're
going to return inside and finally after
we return inside we're going to return
the decorator alright so that's how our
decorator function written so what it's
going to do is whenever we pass in tags
in quotes it's going to wrap the result
of the function in HTML tags all right
so let's create a function let's say
it's called def my web well
welcome welcome and it's going to take a
name for example and we're going to use
our at add tags decorator and we're
going to pass in let's say pass in P
it's gonna be in a paragraph tag and we
also wanted to have italics and we also
want it to be bold alright so we've got
our tags that we want to add to the
result and now my web welcome let's do
something like we'll just return the
string welcome
plus name and we'll say to my vlog
something popular all right so we're
welcoming whoever the name is to my blog
all right so that's half function
written let's try it out so we'll print
my web welcome and let's say it drops is
the person we want to welcome we're
printing that out and let's give it a
shot so we'll save that up
and we'll run it run when I run ad tags
and we get our output so output is
wrapped in P tags then wrapped in italic
tags and wrapped in bold tags and we get
welcome jobs to my blog awesome how cool
is that
all right just some final notes to keep
in mind when working with decorators
Python provides a really neat module
called funk tools that provides
functions to aid in debugging decorators
as a decorator is an overridden function
the stack trace will be a little harder
to analyze looking to the wrap function
it's also interesting to note that you
can build a decorator with a class as
well but overriding the underscore
underscore call underscore underscore
special method so a decorator class
would look like the following the only
thing to keep in mind is that you must
pass in the function inside the init
method which is cold when the decorated
function is defined then implementing
the core method will be called every
time the decorated function is cold
which could be really handy for
separating special logic that concludes
our look at decorators hope you weren't
confused for too long feel free to leave
any questions in the comments and I'll
do my best to answer them next we'll be
looking at Python c-types module and
using and interacting with dynamically
linked libraries don't forget to
subscribe thanks for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>