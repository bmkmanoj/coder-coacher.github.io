<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python3 Advanced Tutorial 5 - MultiThreading | Coder Coacher - Coaching Coders</title><meta content="Python3 Advanced Tutorial 5 - MultiThreading - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/DrapsTV/">DrapsTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python3 Advanced Tutorial 5 - MultiThreading</b></h2><h5 class="post__date">2015-06-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6eqC1WTlIqc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to Python 3 advanced 5
multi-threading in this video we'll be
looking at what threads are and how we
can use them in our Python programs
every video of all slideshows and code
available in the description so what is
threading a thread can be thought of as
another program running alongside your
main program the difference between
being an actual separate program is that
a thread runs within the same scope as
the main program meaning they can share
data much easier than to actual separate
programs however with this gain in power
comes challenge but it's a piece of
shared data between two separate threads
may be accessed or change at the same
time this can cause issues of which
thread will use it first or write to it
first ok so we can use threads for
different things quick tasks such as
running an algorithm to get a result or
to run a slow process in the background
while our main program continues this is
great for saving files in the background
while the interface still responds to
the users input most of the time it
would be unnoticeable however imagine if
you were saving a 5 gigabyte file it
would take a lot longer and you don't
want your program to just sit there and
hang for a few minutes we may also want
to create threads to try and find an
answer to a problem faster a great
example would be hashing let's say we
have a hundred passwords and we need to
hash them with md5 we could create 10
threads each hashing the passwords they
are given and returning the hash
password meaning the whole process which
may take 10 seconds in one thread now
takes 1 second because the work is split
up between 10 threads how does it work
well since the introduction of cord
processes some smart people have written
the code to interact with the operating
system to allow programs to use more
than one thread on a programming level
however the key point to remember is
that threads run alongside our main
program if you're on Windows you can
open up task manager and it will tell
you how many threads a program is using
ok so I feel the best way to learn
threads is to actually try and use them
so let's make a small-timer program so
you can see how threads are working each
thread will output the current time then
wait a certain amount of time until
outputting again let's call that program
timer dot P way ok so I'll come over to
bunt again
and let's create a file so in timer t1
all right so the first thing we want to
do is from threading import thread oops
from threading import thread all right
now we're going to want to import time
so that we can output the time next we
want to define our function that we're
going to give to our thread so we're
going to call it timer now inside our
timer function we're going to pass in a
name for the timer a delay between the
outputs and a number to repeat so repeat
all right inside our function let's
print out that timer and then we'll add
in the name of our thread so we know
which thread is started and then we'll
just output that it started so you can
see when the thread starts all right now
we'll do a while loop
so while repeat is greater than zero
that's time dot book time dot sleep so
what we're going to do is we're going to
tell the computer to wait a certain
amount of time so we're going to wait
the delay then we're going to print out
our name of valve timer put a little
colon in there and then the string of
time dot C time so use the C time
function to format the time time dot
time so the current computer time all
right
I'll close that all off and then after
our print we're going to
- one - our repeat alright and then
after our while loop so outside about
what we're going to print that timer
timer name is completed all right so
that's our timer function written let's
write our main function now so def main
and inside of our main we're going to
create our threads so we'll call that
first thread t1 and that's going to
equal a new thread so thread and then
the target of our thread which is a
special parameter is going to equal our
timer function and then our arguments
our args is going to equal open brackets
we're going to pass in the string timer
1 close quotes comma I'm going to put
this in the value 1 for the delay comma
and we're going to repeat 5 times close
off the arguments and then close off the
thread all right now let's create
another threat to run alongside this one
so t2 is going to equal a thread the
target it's going to be the timer
function again and our args this time is
going to equal timer to with let's say a
delay of 2 and we're going to have it
repeat 5 times as well alright and we'll
close that off now that we've created
our threads we need to tell them to
start so that's called t1 dot start and
also call T to start all right and
because our main thread is still running
after we call these start functions will
print out so we can see that it's it's
completed so main
completed all right now this is our main
function done let's write out if name is
main so if I'm just going to score name
and this going to score is equal to
let's going to score main let's gotten
the score run main right now let's save
this and let's give it a shot so python
three time' dot pi alright run it and it
says time I wonder started timer too has
started and the main thread completes
and now we get our timer one prints out
timer one prints out timer two prints
out timer one prints out etc and we see
our timer one completes first and our
timer two completes second even after
our main thread is finished cool all
right
I'll clear this and we'll come back to
the slide show thread the great for
asynchronous tasks tasks that can run in
the background to complete a task that
may take a long time these days there is
a high amount of programs that must be
in real time so you can't afford to have
a program wait for one minute while you
save a file or set up a network
connection this is where threads can be
really great because it allows the user
to still interact with the program if
you're like me and don't like having to
write out the same code over and over
again the beauty of the Python threading
module is that we can create our own
subclasses of type thread these are
useful for making task-specific threads
that we can reuse and add features to
the bonus meaning if we need similar
thread types in another program we can
just reuse the ones we wrote before okay
so let's create our own custom thread
that will write a file in the background
the custom thread will take a string to
save and a file to save it to because
this task will actually be really quick
because it's such a small file we'll add
a small delay just to more easily
demonstrate what's going on we'll also
use a method of the thread class called
join this waits for the thread to finish
before continuing let's call the program
async right bye
all right so come across over to Ubuntu
again and this time we're going to
create a sync right dot pi all right
so again what we're going to want to do
is import threading this time so we're
not importing just the thread class so
we're also going to import time again so
we can put our delay in all right now
let's create our class so class async
right
and we'll use threading dot thread as
the base class all right now we're going
to need to make our initialization so
deaf I'm just go out and score in it and
just go underscore it's going to take
self text to write and the out file to
write it - all right now we need to call
our superclass in it so threading dot
thread dot let's go underscore in it
underscore underscore and that just
takes self all right now we need to set
up our other variables so self dot text
is equal to the text it comes in and
self dot out is equal to the out that
gets passed in all right now let's
define our run so def run self
and we'll create open up a file so f
equals open and we're going to open up
self dot out in let's do a pen mode and
we're going to F dot write our self dot
text and then we'll add a new line on
there as well backslash n all right now
LF closed and then more time dot sleep
just to see what's going on time but
sleep and we'll sleep for two seconds
alright last thing we'll do is we'll
print that it's finished writing so
print finished finished background file
right - then we'll add in self dot out
so we can see what file we wrote - cool
that's our class written now let's write
our main function
so deaths main and we'll get our message
from the user so message equals input
and we'll do enter a string to store
and then we'll create our background
thread so background equals our a sink
right class and we're going to pass it
message and we'll output it to app dot
txt cool now we need to do our
background start to run the thread and
when we call background start it'll tell
the thread to start run calling the run
function so the special run function
that we wrote just before actually has a
special meaning for threads and when
when start is called it will run the run
function all right cool
now we'll do some printing so print the
program can continue while hit writes in
another thread and we'll print out
something else so there print and we'll
do something like 100 plus 400 equals
comma 100 plus 400 and into some math
and we'll do our background dot join
function so what join does is it'll sit
here and wait until the background
thread is done and when it's done it
will continue so when it's done we'll
print and go waited until thread was
complete alright now we'll do about if
main so I'm just going to school up name
equal to main
yeah run me all right
so if I made any errors we can write
quit and you can run this so Python 3 a
sync right dot PI now we run this it'll
ask us for a string to store so let's
put something like hi my name is Gramps
and we get the program can continue
while it writes out to another thread
100 plus 400 is 500 and then finish
background file right to out and then
waited until the thread was complete
cool so that all worked and we wrote a
file in the background so we can them
out dot txt tab look and you see hi my
name is wraps has been written to a file
cool okay so if you're using Windows you
may have noticed in our timer program
that the print was printing out on the
same lines this is because threads were
both accessing the standard output at
the same time this can also happen with
other data inside our threads we can
avoid clashes of threads using the same
data by using locks locks for me were
one of the hardest things to get my head
around it wasn't until I used one for a
few times before I fully understood what
was happening now we use locks to lock
access to one thread only one thread can
be within a lock at a time let's modify
our timer program to use a lock so that
only one thread can output the time keep
in mind this example is mainly just for
showing how a lock works in the most
simplest way all right so come back over
to Ubuntu and rule them timer py and
we're going to be creating a lock so
what we can do is we're going to remove
the specific import of thread so we're
just going to import threading
all right so now from the threading
we're going to create a a lock so we're
going to call it t lock and that's going
to equal threading lock all right so now
we've got a lock we need to start
learning how to use it so inside our
timer we're going to use our lock so
after our first print where it says
timer name started we're going to do T
lock dot acquire hook now when we
acquire a lock it means this thread that
currently acquired I own the lock now no
other thread can try and use it all
right so we can leave everything else as
it is actually let's put a print
statement after the acquire order print
and we'll do name plus the name yeah
name plus I actually will just do the
variable name so we know what timer it
is name plus has acquired the lock so
they'll let us know which thread
currently has the lock and then after
our print out back sorry after our while
loop before our print that the timer is
completed
we'll do a print that name is releasing
the lock and then to release a lock so
that another thread can use it we do t
lock release and this will release the
lock so that another thread can acquire
it so if another thread is running and
it gets to this acquire but the lock is
already acquired it'll just sit and wait
until it can alright
so because we are no longer just
importing pure thread we need to type
threading in here so threading dot
thread all right and that's it so let's
save this and give it a shot five in
three timer dot py so you can see timer
one has started timer one has acquired
the lock and timer two has started but
it hasn't acquired the lock yet and it
goes through and timer one prints out
all of its statements and then it
releases its lock and then our timer one
is completed and now time and two can
acquire the lock and then timer two will
go through and print out over two times
and then it will release the lock so
that somebody else can take it if needed
and then timer two is completed now
hopefully this demonstrates how a lock
works and how threads can acquire a lock
and that no other thread can pass the
acquire until the original thread
releases the lock there is also a type
of lock called a semaphore like locks
they restrict access to a thread however
semaphore is allow for more than one
lock to be acquired let's say we have 10
threads trying to load up ten different
web pages you may only want to open two
or three connections at a time to stop
the server rejecting your requests and
this is where a semaphore would be
useful it's important to mention that
when using threading it isn't the answer
to every problem if your problem logic
has to run in a sequence such as each
line of code relies on the previous line
of code then threads most likely won't
help you out however if you're writing a
graphical user interface or GUI then you
will always want to have at least two
threads one for the interface and want
to do all the processing in the
background this will hopefully avoid the
interface becoming unresponsive it's
very important to keep in mind the
platform's you'll be deploying on if the
CPU running the code only has one core
then there'll be a no performance
increase when you have more threads than
cause on a CPU then the threads are time
split this means the operating system
will split the amount of time the
threads will be running on the CPU core
there is only one core and two threads
then each will get 50% of the CPU time
alternating between the two an example
of a great use of threads is of servers
that deal with TCP connections you want
to be able to hand
more than one connection request at a
time alright so that covers threads I
hope you now have a feel for threads and
how to go about adding them to some of
your Python programs next we're going to
cover networking don't forget to
subscribe thanks for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>