<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python3 Advanced Tutorial 6 - Networking | Coder Coacher - Coaching Coders</title><meta content="Python3 Advanced Tutorial 6 - Networking - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/DrapsTV/">DrapsTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python3 Advanced Tutorial 6 - Networking</b></h2><h5 class="post__date">2015-06-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bTThyxVy7Sk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to Python 3 advanced 6
networking in this video we'll be
looking at what networking is and how we
can use it to communicate between our
Python programs this video will be
rather long as a topic is quite complex
every video of all slideshows and code
available in the description so what is
networking networking is a field of its
own so we weren't going to it in too
much detail the more you know about how
networking works the more easier this
will be for you however it's not a
necessity to know how every interworking
comes together to make our programs
communicate the concept of networking is
the communication of two programs across
the network whether that be a local area
network or land for short or over the
internet these connections can be
between clients or between a client and
server a client is an end device
interfacing with a human whereas a
server is a device providing a service
for the clients there are two main
models for networking paradigms
the first being client-server model this
is the most common model because the
server can run constantly and be
available for clients to connect to at
any time to receive the information they
require an example would be a web
browser being a client and the Google
website being a server you always want
the Google server to give you the web
page so you can search for the
information whenever you like the second
model is the peer-to-peer model this
model is more complex to set up however
is useful for software that doesn't have
to be constantly available or for a more
private connection take voice for
example you don't want to have your
voice going to the server to be stored
before going to your friend though deep
down peer-to-peer is the client-server
model just the clients act as both the
server and the client
ok let's quickly clear up some
terminology we have addresses and ports
addresses our IP addresses or computers
connected to a network should have one
usually it looks like four numbers
separated by dots eg 127.0.0.1 next we
have ports ports are like pigeon holes
on your network card they tell the
incoming data what program to go to port
numbers range from 1,000 to 65535
however the first 1,024 are reserved for
core protocols now what our sockets
sockets are the programming
one set for connections they allow us to
communicate in a bi-directional manner
from program to program across the
network once they are connected or ready
to transmit we can send data into them
or receive data from them sockets easily
handle the implementation of TCP and UDP
here are some of the methods that we'll
be using the constructor socket takes
two optional parameters these are the
socket family by default is AF
underscore inet meaning the address and
port are given in a topple and the other
parameter is the socket type so either a
sock underscore stream for TCP or a sock
underscore diagram for UDP the method
bind will bind a socket with a port this
takes a topple of the address and port
we will use this for our TCP server the
method listen will instruct the socket
to start listening for incoming TCP
connections we then use the method
except to instruct the socket to accept
and voyage the TCP connection with the
connecting socket note this will return
a new socket object on our client side
we use the method connect to request a
connection with the listening server we
can then use on both client and server
the receive method which takes a buffer
length the buffer length determines how
many bytes to take out of the network
card each time the method is called
and then the send method which takes the
bytes to send either with the bytes
function or encoding and decoding with
something like utf-8 finally we can use
the close method to close the connection
and the socket now before we jump into
the code let's look at what TCP actually
is TCP or transmission control protocol
is a reliable connection based protocol
this means the protocol forms a
connection with the other device and
keeps the connection going until it is
closed the reliable part is built into
the protocol if a piece of data is lost
on its way through the internet the
protocol will organize the data to be
resent the protocol also checks if the
data is corrupt and arrives in an
ordered manner TCP is slower than other
protocols because of all of this
checking and making sure the data is
there so it's used in programs that must
have all the data arrived such as a web
browser
nobody wants half a web page of data
went missing ok finally on to some code
let's create a simple TCP client /
server program that allows the client to
send some text to the
and have the come back capitalized let's
write the TCPS over pi first and then
we'll start with our TCP client second
all right so come over to your bundy
here and we'll create our server first
so tcp server okay now the first thing
we want to do is import socket all right
so now that we've got socket imported we
can start writing in our main function
so def main and inside our main we need
to set what the host and port of that
server is going to be so our host is
going to be this machine so 127.0.0.1
which is the loopback address this means
i want to talk about this machine
alright now we need a port to run the
server on so let's just pick an
arbitrary port something like 5,000
because that's outside of the range of
1024 of the reserved space and it's not
going to clash with any other programs
all right now we need to set up our
socket so let's call our socket object s
and it's going to equal socket dot
socket all right so to create a TCP
socket object and now we need to bind
our host address in our port to the
socket so s dot bind and it takes a
tuple so first come on port close it off
and now we've bound our socket to this
machine and now we can tell our socket
to listen so s dot listen and we're
going to listen for one connection at a
time all right now we need to get the
connection we need to accept the
connection rather so when we accept a
connection we need to store the client
that we accept so a socket object of the
client and the address that it came from
so call
clients II and comma and we're going to
store the address as well that's going
to equal the result from s dot accept
all right so now that we've accepted a
connection and we've got a client
connected to us we're going to print out
that we got a connection
so we'll do print and we're going to
print out connection from and then we'll
output the address that it came from so
two plus the string of address okay now
now that our server is running and we've
got a connection we're going to do a
while true so we're going to have our
server run indefinitely and in our
inside our loop we're going to start
transferring data between a client and a
server so we'll create a variable called
data and we'll store our client dot
receive so we're going to receive data
from our client and will receive a
thousand and twenty four bytes at a time
so 2024 and this is going to come in and
as raw bytes so we need to decode it so
we're going to dot decode and we're
going to use ute F dash eight so we're
going to decode it back into our string
okay so now that we've received some
data from our client if not data so if
there's if no data actually comes in and
we don't receive anything from our
client then we're going to break out of
our while loop okay but if there is data
there we're going to print out that data
so print from connected user and then
we'll output the data that they sent us
so plus da all right now we're going to
set that data to uppercase so data
equals
data up up so now it's been capitalized
we're going to send it back to the
client so print and we'll do sending
whoops sending plus the data that we're
going to send back all right now let's
send it back so descend we do out see
suck it for our client dot send and
inside our send we're going to send our
data dot encode so we want to encode it
back into raw bytes and we'll use GTF
dash 8 and that will encode it and send
it off to the client and then if we're
outside of our while loop so if there's
no data and we break then we're going to
see close and close off the connection
cool so that's our server written let's
write out if if main so if I'm just
going to score name I'm just going to
score is equal to I'm just going to
score main then we're going to run main
all right set our server it written
we'll save that and we can give it a
quick run if we want so it would apply
in three TCP server dot pi and that
should run and it should just sit there
because we haven't got it outputting it
anything at all all right let's cancel
that to the control C to interrupt and
let's write our client side so vim TCP
client PI and we're going to import our
socket again and because this is a going
to be our client it needs to be in a
separate file so that we can run both of
them at the same time
all right so now it be imported socket
we can define our main function
so there's main inside of our main we're
going to stop our host again which is
going to be this machine because we're
just going to test on this machine
127.0.0.1 so I'll live back again and
our port is going to be five thousand
because that's the support that our
server is running on and that's the one
we want to connect to all right so now
we need to create our socket object so s
equals socket top socket and then we're
going to try and connect to the server
so s dot connect and we'll pass in our
tupple of the host and the port and then
now that we've connected we're going to
get a message from our user so we'll get
message equals input and then we'll get
a message from the user
all right now while our message doesn't
equal Q so the character Q which we'll
use for quitting we're going to s dot
send the message that we got from the
user dot encode and we're going to
encode it in utf-8 so the server can
decode it all right now we've sent off
our data we need to receive data back
from the server so data
data equals s dot receive and receive
1024 it's a nice round number and we're
going to decode in utf-8 okay so now
we've got data back from the server
which should be our capital a string
we're going to print it back out to the
user so print received from server plus
the data that we got back all right
now we'll do our message equals input
again so that we can see if the user
wants to exit and then we'll come out of
our while loop and we'll do our socket
close cool so that's our client written
written so let's do it if I'm just gone
the score name and it's going to score
equal to let's go on to our main and
then run main okay cool let's save that
and we've got it ready so I'll open up
another terminal and this one can be our
server so I need to change directories
to PI hook up capital P all right now
Python three our tcp server dot pi and
that'll start running over there and we
can come back over here and python 3 our
tcp client type i and that'll run and we
get our little message pop up and if we
come over to our other server
we see we get our connection from from
this computer on this port so when a TCP
connection
connects it'll assign itself its own
random port that isn't colliding with
anything else
all right let's send a message so it's
go hello my name is straps 2n enter and
we received from the server hello my
name is drops in capitals and we have a
look at our server we can see we receive
the hello my name is drops from the
connected user and then we sent back the
capitalized version cool
let's type little lowercase Q to quit
out of that we'll give it a clear come
over to server and it's ended already
let's get that clear cool now that we've
seen TCP in action let's have a look at
UDP UDP or user Datagram protocol is an
unreliable connectionless based protocol
this means that UDP never actually
connects with the other device it purely
sends the data off to an address whether
there is a computer there or not the
protocol is also unreliable meaning
there is no guarantee the data will
actually get to the other device if it's
lost in the internet it's lost forever
however because the protocol doesn't
resend and check every piece of data it
is very fast which makes it great for
real-time software like voice over IP or
online video games let's create the same
program as before
however this time we'll use UDP and see
how our programs differ you'll notice
that we use the methods received from
and send - these are the UDP specific
methods for sockets let's call the files
UDP server PI and UDP client PI all
right so now we need to create a new
file server via UDP dot the server OOP
sorry
UDP server dot PI and we're going to
import our socket so it import socket
and we'll find our main function
alright and once again we'll set up our
hosts to equal our loopback address so
127.0.0.1 and our port lose 5,000 again
for our server you noticed something
different when we do our client and I'll
talk to that when we get there so we
need to set up a socket so s equals
socket socket but this time we need to
set up our UDP socket so by default a
socket is TCP so we need to change it
and force it into a UDP so to do this we
need to tell it what its family is and
that it's a UDP socket so we need socket
dot AF underscore eye net as we're going
to pass it a couple of a host and port
and we need socket dot sock in capitals
underscore D gram for Datagram or UDP
alright so now we've set up our socket
we need to bind it to a port so s dot
bind and it's going to take our host
port tupple and then we'll print out
that our server started all right now
we'll do it another while true so well
true to change that
well-well true are going to data comma
address because EDP is connectionless we
don't have a connection to receive from
so we need to store the data and the
address that the data came from so the
data addressed equals the socket dot
receive from and we're going to receive
do
thousand and twenty four again alright
now we need to decode our data so we
could have done it on the previous line
but we'll do it on this line so data
equals data dot decode in utf-8 and now
we'll print out the message from the
user so message from and then the string
of the address and then we'll print out
on the new line from connected user even
though they're not connected we'll just
use connected illustrative purposes and
the data that we received from them okay
now we need to set the data to uppercase
so our usual line from before data
equals data upper and then we're going
to send it back
so we'll do a print out that we're
sending it so sending sending data and
then we'll do our socket dots tend to
this time so we're going to send to and
the data we're going to send so a data
in code we're going to incurred in ETF
eight again and also with the center we
need to tell it where to go so data
we're going to send comma the address so
these dress that we received from okay
so outside of our while so this is going
to run indefinitely receiving from
people connecting I will do SC close if
for some reason it ended right do if and
it's going to Scott name and it's got in
the store it's equal to and it's going
to score main then we're going to run
main
all right so that's our server-side done
for UDP so let's write quit and now
let's write our UDP client so vim UDP
client dot pi all right now once again
we're going to import socket and we'll
find our main now we're going to need to
have our host
so our host it's going to be this
machine again so our loopback put
127.0.0.1 and then our port has to be
different from our server as we're going
to be creating a socket server ourself
almost all right so let's just use the
next one up so do 5001 all right now we
need to tell it where the server is so
let's create our server address which is
going to be server that's going to equal
a couple of 127.0.0.1 so the server is
on this machine and the port that the
server is running on is 5000 it will
close up that tupple all right now we
need to create our socket so s equals
socket dot socket and once again we're
going to have our socket dot AF
underscore eye net and our socket dot
sock underscore D gram all right now we
need to bind our socket so s dot bind so
we're going to bind it to our host and
our port just like our server does and
then we're going to get a message from
the user to to send so our message
equals our input the little fancy arrow
and then while
the message does not equal Q we're going
to s dot send to message dot in code and
we're going to incur it in ETF - eight
and also in our Center just like we did
with that server we need to put in where
we're going to send it so we're going to
send it to our server tuple that we set
up earlier we're going to send it to our
server and then we're going to get our
data and our address that it came from
it's going to equal our socket dot
receive from and then we're going to see
1,024 all right
and then we'll decorate our data again
so data equals data decode and we'll be
carried from utf-8 all right now we've
got our data it's printed out so print
received from server the data right and
then we'll do our message again so a
message equals input and that's our
while loop done now let's do our socket
dot close so once they're done and they
put in a little lowercase Q we'll close
off the socket and exit out and so
throughout if I'm just going to our name
let's go to school is equal to I'm just
going to store main I'm just going to
school we're going to run main all right
that's our client written let's give it
a shot so to write quit and save this
and we'll come over to our server make
sure we start that up first so python
three UDP server so PI server started
come-over Python 3 UDP client dot PI and
it's set everything up and it's waiting
for a message and you'll notice that we
don't get a user connected because it's
connectionless all right we'll send a
message to the server so the hello can
you hear me and then we receive back
from the server hello can you hear me
capitalized and we come over to our
server we can see we get a message from
this address from the port that there
are clients running on and we get the
message and we capitalize it and send it
back and then we can do this as many
times as we want here because we don't
break from no data all right so you do
hello hello hello
and we receive back hello hello hello
and we used to like ask you to quit out
and we'll come back and we'll control
see to cancel out of our server I'll
clear that cool you may have noticed in
our programs that the program will sit
and wait for a connection to receive
data sometimes we may not want our
program to hold up and wait we can solve
this with threads or by setting the
socket to non-blocking non-blocking just
tells the socket that if there's no data
to grab try and grab it anyway and
continue this way our program always
continues however if no data is present
an error will be caused so make sure you
deal with that using a try except I hope
you now have a feel for sockets and how
to go about adding networking to your
Python programs next we're going to
cover CGI programming don't forget to
subscribe thanks for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>