<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python Advanced Tutorial 10 - PyCrypto | Coder Coacher - Coaching Coders</title><meta content="Python Advanced Tutorial 10 - PyCrypto - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/DrapsTV/">DrapsTV</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python Advanced Tutorial 10 - PyCrypto</b></h2><h5 class="post__date">2014-07-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lSrrhP2vFS8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to Python advanced an PI crypto
in this video we'll be looking at using
PI crypto to encrypt data I'll keep it
as simple as possible every video of all
slide shows anchored available in
description some click preamble I'll
assume you know the basics of Python
having some knowledge of cryptography
will be helpful for your understanding
of what's going on however it is not
necessary to follow along with this
tutorial if you're on Windows you can
find PI crypto on the Python package
index on Python org ok what is PI crypto
PI crypto is the Python go-to package
for cryptographic modules containing
efficient symmetric and asymmetric
ciphers hashing algorithms cryptographic
protocols public key encryption and
signature algorithms and it comes with
its own cryptographically strong random
functions just quickly what is
cryptography typically it refers to
encryption of readable text called plain
text into unreadable text called cypher
text as well as the reverse decryption
of cypher text back into plain text to
be read a cipher is an algorithm used
with a key to turn plaintext into
something that looks like random output
however it must be able to turn the
random looking output back into its
original plaintext form the strength of
an algorithm is measured measured by an
adversary breaking the cipher or an
adversary can determine the cipher text
from a completely random text we're
going to use AES it's fast secure and
fairly simple to understand
AES stands for advanced encryption
standard and is a symmetric cipher
meaning that both the sender and
receiver share the same key it uses a 16
byte block size meaning that each part
of the encrypted data is encrypted 16
bytes at a time and this must be full so
padding is required and AES can handle
three key lengths 128 192 and 256 bits
AES also supports many block cipher
modes and I'll have a link in the
description to a Wikipedia page on the
topic we'll also be using an IV IV
stands for initialization vector and is
used to randomize but still create a
distinct cipher text for a certain block
cipher
anyway we are going to use a random IV
for each file that we encrypt as it's
important that we do not use the same IV
and key more than once the IV doesn't
give anything away about the ciphertext
if it's only used once with the same key
so it's safe for the IV to be known
because our cipher requires a fixed key
of length 16 bytes it's also useful to
hash the users password into a 16 byte
hash shot 56 can do this for us and it's
a secure hashing algorithm by today's
standards this means the user can have a
password that is 5 characters long or 40
characters long and we still get the
same 16 byte output ok on to some code
let's create a file encrypting and
decrypting program we can then use it to
encrypt the contents of text files music
files video files and more so let's call
it encrypt PI so I'm going to come over
to Ubuntu ok login and we're going to
create our file so on Ubuntu it comes
with the PI crypto library so it's fine
so we'll create our file so I'm going to
call it encrypt dot PI ok now we're
going to need to import some things so
because we're going to be input
encrypting files we need to be able to
access the operating system so import OS
so you get like the file length and
that's also import random because we're
going to get random a random IV so we're
going to need random at some point ok
now we're going to grab our encryption
algorithms so from crypto and dot cipher
so we're going to grab a cipher we're
going to import
AES and that's all in capitals and we're
also going to grab the chart 256 hashing
over an algorithm so from crypto hash
import sha-256
okay now let's define our encrypt
function so we'll just call it encrypt
live encrypt and it'll take a key and a
filename to encrypt okay now we're going
to need some variables so we're going to
need a chunk size so this is going to be
the chunks that we pull out of the file
so chunk size and we'll make that equal
to 64 times 1,024 save us from typing
add the amount of bytes ourselves okay
now let's create our output file so our
output file and we'll just make it equal
to what the current file name is but
we'll put a encrypted in front so in
brackets
I'll just put encrypted and I close the
brackets off and I'll add that onto the
filename that we've already got and you
can do whatever you want here you could
even just get input from the user of
what they want the new file to be called
or you could even overwrite the old file
okay file size so you need the file size
of the current file that we're going to
be encrypting and I like to turn this
into a string and fill it to 16 bytes
but if you want to use something like a
structure for getting the size of the
file you can go and do it that way if
you like so I'm going to turn it into a
string Oh s dot path and I'm going to
get size of the file
name and then I'm going to Z fill this
to 16 bytes and that will just fill the
left-hand side of the string with zeros
okay and we need one more variable which
is going to be the IV and I'm just going
to set that to nothing at the moment now
let's generate our random IV so for I in
range and 16 because we want to 16 by PI
B we're going to get our IV and plus
equals onto the end of it
the charr of random dot R and int so
we're going to get a random int between
zero and zero x FF okay
so that'll generate our random IB of 16
characters now we're going to create our
encrypted object so encrypter and that's
going to equal an Aes dot new and
they'll take the key to be passed into
the function and it's going to go to
pick our mode our cipher block mode so
that AES dot mode underscore and I want
to use CBC which is the chained cipher
block and we're going to put in the IV
for our AES okay that'll create our
crypto now we're going to open our files
so I'm going to use the width keyword so
with open and we're going to open the
file name so the file we want to encrypt
I'm going to open it in read binary and
we'll call that as in file okay
now with this file we're going to open
up our output file to dump everything
into so with open and our open is going
to take our output file and that's going
to be in write binary as out file okay
now with that out file so out file dot
right we're going to output the file
size of the original file and we're also
going to output so out file dot right
the IV so that we can use it when we
decrypt okay now that we've output our
file size and our IV we can start
encrypting all the data in the original
file and storing it in our output file
so while true so I'm going to keep going
until we break out of this we're going
to create a chunk which equals in file
dot read I'm going to read our chunk
size that we specified earlier chunk
size okay now we're going to write an if
so if the length of chunk is equal to
zero so it's got nothing in it then
we're going to break add about a while
else if the length of chunk modulus
sixteen so we get the remainder does not
equal zero then we're going to add some
padding so we're going to pad the chunk
so chunk plus equals whoops plus equals
and we're just going to Pat it with
spaces so
space times an open bracket
16 minus the length minus the length of
chunk modulus 16 so the length 16 minus
the remainder of the length so that'll
get how much more we need to pad with
and we're timing up by well we're time
seeing space by that and that'll pad our
how far our chunk so that we can encrypt
it and now after we've done our ifs
we're going to use the outfile
and we're going to write the output of
the encrypter dot encrypt of the chunk
and that will write right out tau
encrypted chunk and that's all we need
to do for our encrypt function okay
now let's define our decrypt function so
def i've call it decrypt and that'll
take the key again and the filename
okay now we'll specify that specify our
chunk size again so chunk size equal to
64 times 1,024 okay and out output file
we'll make that equal to the file name
that were decrypting and we'll only grab
everything after the first 11 characters
because after the alluring 11 characters
is the original file name if you copy
what I'm doing because I added the
encrypted in brackets of the original so
I'm just going to get rid of that
encrypted in brackets okay now with open
and I'm going to open up the file name
so I open up the file in read binary as
in file and now we're going to specify
our file size and our IV so I have file
size it's going to be equal to long of
in file read 16 update 16 bytes and
we're going to get our IV which is going
to equal the in file dot read the next
16 bytes okay so now we've read out our
file size and our IV you can create our
Decrypter now so Decrypter is equal to
AE s nu and that will take the key and
then our mode again to AES dot mode
underscore CBC and we can pass in our IV
okay now we're going to use the width
command again and we're going to open up
our output file so open output file and
that's going to be in write binary has
app file
okay now that we've opened up our app
file we're going to do while true and
we're going to grab a chunk so chunk
equals in file dot read of chunk size
and then after we've read in our chunk
size we are going to do an if statement
so if the length of chunk is equal to
zero then we're going to break and then
we can decrypt the chunk that we pulled
out of the file so out file dot write
the Decrypter dot decrypt the chunk and
we're going to write their result out
now after we get out about get out about
while we're going to truncate the out
file so out file dot truncate and what
this is going to do is just reduce it to
whatever size we specify which will do
the original file size so this will
truncate all of the padding that we
added at the end of our encryption
process and that's our decrypt function
done now we'll just write a small
utility function called get key so get
key and that will take a password and
we'll create a hash of so a char equals
sha-256
dot new and then we're going to give it
the password
and then we're going to return the
hashes digest so that will return the
hash of that the password that we pass
in and now let's create our main
function
so depth main and we'll just make a
little menu so create a variable called
choice and that can equal raw underscore
input and will ask the user would you
like to in brackets of e capital e
encrypt or in brackets D decrypt
question mark okay now we'll just write
a simple if so if the choice is equal to
e then we'll get the filename they want
to encrypt so file name equals raw
underscore input file to encrypt and
then password equals raw underscore
input password and then we're going to
call the encrypt function so you can
crypt and we're going to get key off the
password and then we're going to pass in
the file name and then we'll print out
to the screen that it's done okay
now we're going to do else if so LF
choice is equal to D
then get the file name equals raw let's
go input and the file to decrypt and
then we'll get the password to crypt it
with password equals raw underscore
input password and then we'll call the
decrypt function so decrypt get key of
password and the file name okay and then
we'll print that done again right done
and we'll do an else statement just to
be nice print no option selected closing
okay now we'll just write out if so if I
just go underscore name I'm just going
to score equal to let's go to main then
we're going to run main okay and that
should be our program done if I haven't
made any errors and we can save this and
we can give it a shot so over here I've
got my encrypt to pilot which we just
wrote I've got a sample song and I got a
text txt and inside the text txt we've
just got a hello my name is drops okay
so let's run it so Pythian encrypt PI
and I'll ask us would you like to
encrypt or decrypt we'll do a capital e
because we want to encrypt and the file
to encrypt so that was text txt so text
dot txt and will give us a password this
is the password we want to encrypt grid
so for now what I'll do is I'll just
cook do you test and it says done okay
so we come back over here
we've got an encrypted text txt so I've
opened this up you see we've got the 16
bytes of how long the file is so you can
see it's 25 bytes long and then we got
the IV which is over here which takes up
about 16 bytes or whatever and then we
got the rest of our encrypted file okay
so let's give it a go of decrypting it
now so we'll run our patent encrypt
again this time we want to decrypt and
before I do that what I'll do is I'll
just delete the original so delete this
if I want to delete it and that way
we've only got the encrypted version so
we'll decrypt it and the file was
encrypted text dot txt and then the
password we used was test and it says
done okay so we've got an output here we
open it back up says hello my name is
drabs so it successfully worked
successfully encrypted and decrypted it
now if I delete this and we used say
decrypt again but we use the wrong
password so this is e in cryptid text
dot txt if we use the wrong password so
to say I use password and it says done
it'll go ahead and do it but when we get
it back it's still encrypted there's no
way they're getting that so there we go
now I can encrypt the song as well it'll
go through and encrypt the song so I can
use it again and song mp3 password which
is test again done
and we've got our encrypted song here if
I try and play this Thunder should have
a go at me and say it couldn't load it
that will go to nothing here I've got
input errors problem occurred without
error being set this is a bug but really
it's just I couldn't play it because
didn't know how to read it and there we
go we've been crypt it and we can also
decrypt it as well alright so that
that's it come back across to the
slideshow smacks our notes are looking
through the PI crypto library you'll see
quite a lot of ciphers and hashing
algorithms but some of them are no
longer safe and have either been broken
or may not be suitable for the kind of
task you're trying to perform I suggest
just looking up the correct type of
algorithm to use for your situation if
you're interested in cryptography and
the algorithms you are using all of them
are open source and you can read them in
many places a word of warning please
never try to create your own algorithm
unless you know exactly what you're
doing and have a team of professionals
working with you
current algorithms are constantly tested
rigorously and all of the standardized
algorithms have been audited by
thousands of people in the cryptology
field I hope you now have an
understanding of how to encrypt things
using Python feel free to leave any
questions in the comments and I'll do my
best to answer them next we're going to
look at object serialization with pickle
as suggested by the beam hacker thanks
for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>