<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Make your Own DNS Server in Python - Part 9 - Finishing Off! | Coder Coacher - Coaching Coders</title><meta content="Make your Own DNS Server in Python - Part 9 - Finishing Off! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/howCode/">howCode</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Make your Own DNS Server in Python - Part 9 - Finishing Off!</b></h2><h5 class="post__date">2016-11-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wuo_nWN4YJU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so in the last video we left off having
created the DNS Hatter that we're gonna
send in a response in this video we're
gonna start creating the DNS body which
is the bottom half of the response that
we're going to send back to the client
so let's get started so the first thing
we need to do instead of printing out
the DNS Hatter is we want to create a
new variable called DNS body so we're
gonna say DNS body is equal to a string
of bytes then what we do is we call our
get Rex function up here and we're going
to create three variables the first
one's gonna be records then we have rec
type and then finally we have domain
name and that's gonna be equal to the
return value of the get Rex function and
we're gonna pass the get Rex method data
and then we're going to start on the
twelfth byte and we're just going to
send at the rest of that string the
reason we're starting on the twelfth
byte is because the DNS Hatter is 12
bytes long so the data we need to sand
it starts after the 12th byte so next
what we need to do is we need to create
the DNS question because if we go back
here you can see that this is a DNS
response and straight after the Hatter
the first thing we see is the DNS query
is sent again so we need to create the
question so to do that what we do is we
create a variable called DNS question
and it's gonna be equal to build
question and the only thing we need to
do is we need to stand at the domain
name on the rack type and we got these
from the racks method up here what we
need to do now is go up and create this
method so we set def build question and
we pass it to me and name and rack type
and all this method needs to do is
actually just convert these strings into
bytes so first what we need to do is
create a variable called cue bytes and
it's gonna be equal to an empty string
of bytes and that's the string that
we're gonna return whenever we've
converted everything the domain name and
the record type into bytes then what we
do is we say for part in domain IAM
because domain name if you'll remember
came from the GAT racks method which got
it from the gate question domain method
that method returned to me in parts
which was a list containing all of the
items in the domain so the first thing
we need to do is get the length of the
part of the domain name because if we
just pick higher org for example as our
test case the first time
will contain two items it'll contain hi
code and I will contain a second item
called org and if we go back here you
can see that the first bite of the
question is the length of the first
label so we need to get the length of
the first label here so we simply do
that by saying length is equal to land
part then what we do is we append it
onto Q bytes we Sepik you bytes plus
equals bytes which is pythons built-in
function that converts something to your
byte then we just need to put in length
but we need to put it into a list and
here we'll just print out Q bytes and
you can see if we run that we get the
less Q bytes the first item is a byte
which is just a number seven which is
the length of haiku org because that's
the domain we sent then the second item
is org which is a length of three and
the third one is just zero because there
is an axial length for the next item so
now that we have the length of the label
we want to say a four char in part
because we want to get each individual
character and what we want to do is just
convert every single char into a byte so
we do that by saying Q bytes because we
want to pan it on the Q bytes afterwards
is equal to Ord which just converts
ASCII characters into decimal numbers in
Python when I say or char dot two bytes
we want to create one byte and we want
to set the byte order equal to big it
doesn't actually matter because we're
only using one byte and then don't yeah
once more we'll print queue bytes and we
just need to append that rather than a
sign it and you can see no we've got is
the length of HO code then we have the
word high code then we have the length
of all then we have org these are all
individual bytes but as usual the
terminal is converting the ASCII bytes
into their actual character
representations the next thing we need
to do is convert the record type into a
byte so we said if rec type equals a cue
bytes plus equals one dot two bytes one
byte I will set the byte order to big
because once again it doesn't matter
because we're only sending one byte so
what's the record type finally if we go
back to the text file you can see we
have record type in green which is the
air type then we have class of in which
is internet and every day and a score is
pretty much always in for internet so
we're just going to set Q bytes once
more plus equals one dot two bytes one
byte order equals big because the
internet class in DNS is encoded as a
one then finally we'll
return q bites I will just print out DNS
question here so there we can see we
have first our string which is haiku org
and we have two bytes of one the reason
we have them is because we have these in
our for Lib we just need to take the
racket type out and take the second one
right as well right on one more time
we've haiku or get that's the string and
then we have zero zero which is the zero
byte which tells DNS that the string is
over
we need a byte of 0 and a bite of one
whoops we just need to change this to is
two bytes and we want to create two
bytes as well because according to the
DNS protocol the type on the class are
both stored in two bytes so we'll just
run that one more time and you can see
now we have the string we have the zero
byte that just has the DNS server that's
the end of the string we have our DNS
type which is two bytes and we have our
class which is two bytes as well we're
going to go down here and instead of
printing out the DNS question we're
gonna save for record in records because
we get records from get racks up here
and what we want to do is we want to say
DNS body plus equals a new method we're
going to create called rack two bytes
which just converts the record into
bytes
just like the billed question method did
we want to pass it the domain name the
record type we want to get the record
TTL which is the time to live and we
want to get the record value so
obviously we have to go up here I went
to create this method we said a frac two
bytes we pass it domain name
rec type rec TTL and rack value the
first thing we want to do is just create
a variable called our bytes set it equal
to an empty string of bytes just like we
did up here with cue bytes and if we go
over here you can see we have this C 0 0
C again that's the DNS compression and I
already went over that in an earlier
video so I'll put an annotation on the
screen you can go back and watch that
again if you need to but for simplicity
we're going to keep this as C 0 0 C and
all of our responses because we're only
going to be focusing on really simple
DNS responses we're not going to be
worrying about advanced queries at this
point so we can put that into our string
of bytes instead of creating an empty
string of bytes we can put in our two
bytes here so essentially the way that
works is you said /x to tell python it's
a byte we said c 0
and we do /ox again and we said 0c and
now we have two bytes of our response
and those are the first two bytes that
come right before we actually start
sending the records back and those two
bytes represent the DNS name of whatever
was requested so for example haiku org
this c00 C represents the compressed
version of that so next what we want to
do is we want to say if rec type equals
a and we'll say our bytes equals our
bytes plus bytes zero because as you're
ordering is getting the number zero
turning it into a list and converting
that into bytes and that will give us
bytes that are /x 0 0 that will give us
a zero byte sort of the same as this
method up here it's just a lot simpler
and then we just want to pair it one
more time we say bytes 1 and that's
essentially just going to give us a
slash X 0 one byte
the reason we're converting it into a
list it just has to do with the way
python handles lists entirely in Python
3 I haven't tested this in Python 2 /
Python 2 and Python 3 handle lists
differently so if it doesn't work you'll
have to use the two bytes method if
you're using Python - but there's our a
record represented as two bytes a zero
byte on a one byte then once again we
have the class we say our bikes is equal
to itself plus a zero byte on a one byte
then we get the TTL switch there are
bytes plus equals RAC TTL but RAC TTL
isn't actually a number yet so we need
to convert it to an integer and that
will allow us to convert it to bytes so
we said 2 bytes and we want to create 4
bytes
once again our byte order will be big
the reason we're creating 4 bytes is
because that's how many bytes the TTL is
stored in in a DNS response next we get
the value out of the record and
different records need to be treated
differently so once again we need to say
if RAC type is equal to a for an air
record but before we do that we want to
go back here to the RFC and you can see
here after the TTL which is 2 bytes we
have the record length which is another
2 bytes and then we have the record data
an a record stores an ipv4 IP address
and if we just create a new file would
say 127.0.0.1 each one of these numbers
is stored in a one byte number that's
where the maximum ipv4 address possible
is 255.255.255.0 five because each byte
can store 256 different values and each
one of these is stored in one bite so
that means we need four bytes so if we
go back to Google Chrome you can see the
record length for an air record has to
be four bytes but that itself is stored
in two bytes so the way we do that is we
say our bytes equals our bytes plus and
we want to create a zero byte and a byte
that says the number four because the
data is stored in four bytes but the the
length of the data is stored in two
bytes after we have the record length we
need to get the data and that is the
data we extract from the zone file if we
go back here we can just close out we
can see this is how it's stored in the
zone file and we need to split this up
based on the dots to get the individual
parts of the ipv4 address so the way we
do that is we say for part in rack Val
dot split because we want to split it
based on the dots to create a list and
we want to loop through that list with a
for loop we want to say our bytes plus
equals bytes which is pythons byte
method and then we want to pass it a
list once more because of the way that
Python handles lists then we want to say
int part because the number itself is a
string at the moment then we convert it
to an integer we can
right that integer to a list and then
the bytes method uses that list to
actually convert it into bytes so that
should be it and then we just say return
our bytes so finally what we need to do
is go down here and we simply say return
DNS header plus TN s question plus DNS
body so let's just run this on hopefully
it will work there we go
the we'll just close the server but as
you can see we got this response from
our DNS server you can see the values
returned to there are four err records
if we go back to our zoom file you can
see I have four err records in here if I
create another record a fifth one and
let's just call this one for example 10
10 10 10 we run this one more time you
can see
we got tender tender tender
t'ayn returned to us she can see this is
coming from our local server so you can
see this is coming from our local server
and we can see that because we have the
app sign and then we have 127.0.0.1
which is just my local computer if I
delete that and actually get the live
records from haiku org you can see we
got completely different results because
these are the IP addresses is these are
actually client for our IP addresses
because high code is hosted behind Chloe
flower but you can see these results are
completely different from the local
results we got from our local DNS server
which shows us our DNS server works and
it's standing back responses that are
formatted correctly that means de can
can interpret them and we can also say
that our responses are returned in one
millisecond because they are local
responses you see if we get the live
responses it's about 43 milliseconds so
I'll just go into Wireshark and I'm on
the loopback which is essentially just
my local computer and I'm gonna run this
one more time
whoops I should have on the server first
so there's the first query so here's the
actual query that we sent here is the
response this is the response we sent
back and it matches everything correctly
there are no red lines or anything that
you would sometimes see here if the
response was done incorrectly so as you
can see everything is working as we
would expect so that's it for this
series pretty much I hope you enjoyed it
it was quite a lot longer than I
expected but we got over a complicated
topic and hopefully you understand it
well and we've also implemented our own
DNS server which is something that's
usually quite difficult today so thanks
for watching don't forget to Like
comment favorite and subscribe thanks
for watching and I'll see you next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>