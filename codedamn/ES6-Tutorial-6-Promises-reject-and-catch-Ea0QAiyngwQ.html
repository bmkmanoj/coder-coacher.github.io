<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ES6 Tutorial 6 - Promises reject and catch | Coder Coacher - Coaching Coders</title><meta content="ES6 Tutorial 6 - Promises reject and catch - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/codedamn/">codedamn</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ES6 Tutorial 6 - Promises reject and catch</b></h2><h5 class="post__date">2017-07-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ea0QAiyngwQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so what is going on YouTube my name is
maple and welcome to your sixth es6
tutorial in which going to take a look
at rejections and promises and catching
them with a cache block now let's just
see that so in the last tutorial we took
a look at what promises are actually and
if you want to watch that the link is in
the description you can go ahead and
what else we take a look at is how to
create a pizza right with promises where
we made use of said time outs to kind of
create the latency which we would expect
in a normal asynchronous function like
getting HTTP requests or any sort of
other asynchronous function so anyways
in this tutorial let's take a look at
how we can handle the rejection and
catch them within promises so let's say
we are creating some sort of calculator
which is accepting a number and let us
try start with additions so we're going
to get a number here and we're going to
say that this returns us a new promise
promise and this could either result or
reject but for the part now we want to
just resolve it and we're going to stay
num plus 10 right similarly for
multiplication or let's just name it
multi we're going to just multiply it by
10 and similarly for division we're
going to divide it by 10 right so this
is obviously synchronous but any in
synchronous code can go in right here
and you could then resolve it inside
there doesn't matter
it's just the same thing right so what I
want to do is first of all I'm going to
say add number now again do not get
confused by the scoping this number is
different so we can just name it X as
well so add X and then once you do that
we're going to get this resolved we're
going to get the result
and we're going to stay multiply the
result then we're going to get another
result which is from this multiplication
and we're going to divide that result
and then finally the result we'll get
I'm just going to console.log that thing
so if we take a look in the browser hit
reload aureus or we have a type of
somewhere actually everywhere right okay
so let's just reload this now we get 20
because you start with 10 we add 10 we
get 20 right and then we multiply it by
10 and we divided by then so that
cancels the effect all right so now
let's say I change this thing to this
thing right and rather let's just
compute this in another variables so I'm
going to say let's result is the 10 upon
numbers so what we can do in here is say
if is not a number result which in our
case would be if this is either 0 or
something which is not a number right so
there's not a number
infinity okay so it actually don't fall
for that so it considers infinity adds a
number so anyways this is going to
return as false if the this number is
not actually a number right so if this
is not the number what I'm going to say
is reject not a number and else we're
going to resolve it
with result ok so what's happening here
first of all we are chaining down the
promise chain starting with addition we
are adding 10 then we are multiplying it
by number 10 and then we are dividing it
so what we can do is we can switch these
positions so that I can just show you
how we can break the promise chain if
something rejects so now you can see
that the inside multiplier we can the
state console dot log multiplying now
I'm similarly for addition and similarly
for the division okay so now what
happens is that we start by adding the
number X then we get the result which in
our case would be 20 we multiply we
divided by 10 so we get something like
10 divided by 20 which is perfectly fine
but what happens if I pass in something
like any character here now this should
throw an error because we are dividing a
number by a string which is obviously
wrong operation so we are going to
reject this promise now when we reject
this promise what happens is is that the
next bin is not gold and if you have a
catch at the bottom it would always be
gold so we can just go into a long beer
now what's the catch here actually is
that when you reject the promise it
stops the promise propagation chain
until it finds the sched statement now
this is important because if you place
this gap statement somewhere here right
or somewhere here now once this gap
statement is executed the promise chain
again starts continuing by that what I
mean is that let me just show you first
of all let's just reload this and we get
an error somewhere
oh we have a semicolon there we can just
reload this again so you can see that we
get adding now dividing now and not a
number so I guess we can just console
dot error this you can see that we get
not a number as an error now now what's
happening here is that we get adding now
find it's a number which is 10 we get
dividing now find but this time instead
of number we are passing this character
thing and this is obviously is not a
number so we reject this the moment we
hit this rejection promise chain would
not look for the next then the next then
it would just skip over these and it
would find this catch now once it
encounters this catch and the catch code
is executed it would again start
propagating from the next step so if we
had some dendrite here then this code
will execute again
so what we can do to see that is place
it just after let's just say this thing
so what we can stay is that this time
strange something like this if we reload
this you can see that we get adding now
which is find we get dividing now which
is again the second part of the chain
right where is it dividing now then we
get not a number thrown as a console dot
error which is fine because again we are
passing the characters so this is
obviously not a number so it skips over
this multiplication bin right because it
does not find any catch in between it
fires the cache block and finally it
phases undefined strange now why this is
undefined is because this then would
contain the result actually returned by
the sketch block so we can if we can
return something like five thousand then
what we are going to see is adding now
dividing now now right here catch
through it as an error and we returned
five thousand as a value
now you could also have done something
like promise promise got resolved 500 or
5000 whatever it doesn't matter really
because promise don't resolve this or
actually when you return a value from
any den block if a value is returned
that is automatically considered in a
promise only so one more thing you might
want to learn is that doing something
like new promise resolve reject and then
immediately resolving it to some value
you know right it's similar to doing
something like promise not resolve
resolve 500 and this is similar in doing
something like inside then you could do
something like promise resolve 500 or
you could do something like promise new
promise dot or whatever the first result
will check and then do resolve 500 or
you could do simply just 500 so all
these three are equivalent right and
yeah so that's how we pretty much catch
the error and say promises and this is
how we rejected so mostly it's always
advisable to actually place the cache
block at the last and give your errors
right here a descriptive name so that
you can actually recognize your errors
later on inside the sketch block and
handle them so promise kind of acts like
you could just create a chain of a
promise chain and then you could just
resolve or recheck individually from a
promise and if you want to not stop the
chain then or if you expects rather you
know assume that this promise step might
fail somewhere else and do not want to
stop the chain from getting down so you
can place a cash flow right here and
handle that error for that particular or
for that all the particular promises up
to that chain and then the code will
resume again so again it might seem a
bit overwhelming
if you are seeing this thing for the
first time but it is actually quite
helpful and would save you a lot of
headaches if you have have been working
with asynchronous coding cross me it
it's not that really hard if you think
about it it's just that you need to get
your hands set to these things for the
first time and just a little bit of
practice with some actual coding you can
try to build an application which uses
the this sort of asynchronous things
right now I am working with some Chrome
extensions so I can suggest you that
Chrome users that asynchronous API for
storing data so you can go ahead and try
to convert that API into a promise based
API and see how the orluk fits in and
how all that works promises are really
cool trust me once you get used to them
you will never make use of callbacks
again so yeah that's all for this one
and again if you liked the story then
please don't forget to subscribe and if
you want to support me you can check out
the patreon link in the description that
would really help me thank you so much
so again that's all for this one
and I'll see you then in the next
tutorial</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>