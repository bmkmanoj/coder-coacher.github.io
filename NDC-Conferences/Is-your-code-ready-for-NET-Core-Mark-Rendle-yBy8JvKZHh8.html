<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Is your code ready for .NET Core? - Mark Rendle | Coder Coacher - Coaching Coders</title><meta content="Is your code ready for .NET Core? - Mark Rendle - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Is your code ready for .NET Core? - Mark Rendle</b></h2><h5 class="post__date">2016-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yBy8JvKZHh8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome to the second talk on
dotnet core this morning the one thing
that they all have in common is that
when we pitched them six months ago they
were very different I'm mark Rendell
that's my Twitter that's my email
that's my blog you can use my blog as a
forensic investigation of everything
that's happened in dotnet core for the
last 18 months including the one which
is literally just a video of me crying
so but you've had a kind of introduction
to dotnet core and how to run it on
Linux and everything from matter who was
in Matt's talk before this one I'm
guessing probably most of you were but
yeah I'm not going to assume knowledge
so I'm sorry if i duplicate some of the
stuff that he said but that one guy who
was in a different talk at the first
I've known him to get lost
that would be terrible okay so but the
question is is your code ready for
dotnet core yeah
yeah they've yeah yeah that's it
because you know that they're porting
every single API across now on they and
it's just it's now full dot me at that
runs everywhere so so of course all
except you know maybe not because they
might not be look you know what no so
basically the I'm going to do a very
quick rundown of what dotnet core is
okay so these are the things that make
up don't make core you have the core CLR
the runtime okay
garbage collector memory management's
cheating bytecode and native code all
this other stuff core CLR which is
Microsoft's own code open source on
github and it works on Windows it works
on Mac it works on that other thing
we've got core Artie we've got core FX
we've got asp net core we've got entity
framework core and then there's some
other stuff in there okay
so yes core CLR works on Windows works
on Linux works on some other operating
system that is probably not important
but that's quite cool it's it's fast
it's open-source you can you can get at
it
and no offense to Miguel de Icaza or
anyone else but it's slightly better
than mono but then you can't use it to
build iOS or Android applications which
is really what mono has been focused on
for the last five years and fair play to
them for that we also have core RT and
people don't know about this as much so
karate is an alternative kind of run
time and set of base libraries and it's
designed for ahead of time compilation
so you build a dotnet application and
whether you ship it self-contained or
you install the.net runtime on the
machine that you're running it on and
that bit you ship dll's
which contain ms on IL bytecode and then
the CLR and the JIT turn that into
something that actually runs on the
machine core RT is dis
to take the bytecode that's produced by
Roslin and then turn that into via C++
or LLVM or something into actual native
code for a specific platform and
architecture so like for Linux x64 or
Windows x64
upfront and the new ship a
self-contained statically linked
enormous binary file that just runs and
you start it and it starts like that
there's no time necessary to spin up all
the runtime bits and pieces because it's
already been done there's no JIT delay
so if you need if you've got like a
little console application and you just
need it to run and then stop running and
get out of the way then you can compile
that using the native compilation tools
and core RT and and it statically links
any kind of dependencies runtime
binaries that you need and it also does
tree shaking so it looks at the code
that you're compiling and says you don't
appear to be using this assembly or
these classes from this assembly or
these methods from this class so I'm not
going to bother putting them in for you
okay which comes with some limitations
that we'll talk about later
well that's very cool and you've got
core framework core FX and that is most
of the base class library and most of
the framework class library that's been
brought across and that's now open
source MIT licensed and in some cases
for some runtimes
for some platforms that's building on
other open source projects so for
example the HTTP client on Linux and Mac
uses curl lip curl under the covers
which is great because Lib curl is being
developed for 20 years and it's in the
same be powerful and it would be stupid
to reinvent that wheel on Windows it
uses win HTTP which is great because
that's been developed for 20 years and
it's insanely powerful and we stupid you
get the idea but yes there are fewer
api's there are not less api's there are
fewer api's I appreciate your Norwegian
but I can still try and teach you proper
English
I'm getting lynched then this is P net
core and this is where it all kind of
started off this is a complete ground-up
rewrite they didn't kind of go
let's take MVC and just knock bits out
of it until it runs they went right
let's build MVC again Bert's
starting from scratch and without making
very assumptions using everything we've
learned and so now you've got this thing
where there's no Web API MVC is NBC and
Web API there's no API controller you
just have a controller and you can have
a an action method on that controller
that returns an enumerable of spaceships
and it will just serialize those two
adjacent representation of spaceships we
go install middleware which we'll look
at in a little bit there's no
dependencies on iis there's no web
config caveat there is sometimes and
there's no web forms so and we've got
entity framework core which again is a
complete ground-up rewrite of entity
framework and God knows it needed it so
yeah it's smaller it's faster it's
lighter and yes those are all three
different ways of saying it doesn't do
as much now as it used to
okay now the reason all the other
speakers have been going you're doing a
dotnet court'll is because there's been
quite a lot of controversy because we
got to rc1 at the start of the year and
then it supposed to be our c2 kind of
the end of February and then it was out
and then they went you know what we're
gonna completely redo everything and
then we're taking away D and X and we're
putting dotnet in and so forth and so
the talk that I had right I had had some
of these points
no more CS proj files we're getting rid
of CS props files and we're just using
project Jason everything's in project up
Jason no CS prata files are coming back
we got those again but that's a good
thing
I got paid to say that that's that's
covered my expenses for this trip there
are dozens of missing api's from the
full dotnet framework and actually at
the time when I wrote this like an
example of one of the api's that was
missing was web request HTTP web request
but since then because so much of
Microsoft's own code depends on HTTP web
requests they've put it back in it's
actually just a wrapper around HTTP
client but it makes it much easier to
port your code if it's using web
requests so yeah they're all back as
well
no msbuild and no miss built that was
great news because XML and oh it's
horrible all over the place and you got
anything and then that came back as well
I I don't know it's it's there you can
use it the thing is so people here today
my my brethren and sistren we are not
your typical developers okay we are the
developers who care enough about what we
do to go to conferences and learn more
about it the vast majority of the
developers who use Microsoft net build
stuff in Visual Studio and they hit f5
and then they right-click on their
website in solution Explorer and say
publish and they're not quite sure what
happens after that okay and that's all
based on a mess build a Microsoft need
to cater to those guys because quite
frankly selling something to the couple
hundred people who are in this room is
not sustainable for a multi-billion
dollar company so they've brought back a
mess build just ignore it use cake or
fake or sake don't use sake for heaven's
sake see what I did there so yeah and
then the other thing that people have
been getting cross about and I I don't
quite understand this is there were
system dot runtime and system dot mate
and then but now they're a mess core
lives come back and that's bad for some
reason no no I I don't care
we're system void or system dot in 32 a
living I don't care if they're in a mess
call Lib or if they're in system dot run
time or if they're in Microsoft
framework contrib okay that doesn't
matter so they're bringing all the api's
back the bringing msbuild back the
biggest problem here is that what
they're releasing on the 27th of June is
course ELR core FX asp net core EF core
and that's already and RT m and final
but the tools and the Visual Studio
tolling the command line tolling vs code
all that sort of stuff is still going to
be previewed too and then it'll be
release candidate one previewed nor
point five and then it will be beta no
hang on just Omega I don't know anyway
so and and this is the point is that
your codes on the 27th of June might not
work with don't met core but for a lot
of code there is a very real chance that
six months later it'll be fine and it'll
just work because they look for all the
API is back they'll have been supporting
CS profiles again so really the question
is not if your code is ready for dotnet
core it sees donate call ready for your
code to quote JFK prints of trademark
that was had e Hariri who couldn't make
it to this NDC for the first time in in
six years but he's here in spirit and in
Twitter so the reality let's let's just
go through the different types of
application that you could possibly have
built with dotnet up to this point and
we'll talk about whether they're ready
for dotnet core is my asp net web forms
application ready for dotnet core no
seriously just leave get another job
anywhere else anywhere just somewhere
that's not doing that well no not
anywhere don't go and do rails because
that's just so much for us any rails
developers in the room I'm guessing oh
yeah do you like it rails 5 you love
rails 5 &amp;amp; 4
you don't like want to throw yourself
off that thing and it's probably not far
enough you could like go around and do
it a few times and I liked rails 1 I
think it's got a bit kind of Barack and
big which is kind of why I like don't
make core because it's like it's doing
the opposite of what rails is doing it's
not layering more stuff on and that's
why people are getting upset is because
now it feels like they're layering stuff
back on but all the stuff that they're
layering back on is on NuGet and the
nice thing about it being on nougat is
it can stay there is my WPF desktop
application ready for dotnet core no no
it isn't stopped writing desktop
applications for God's sake
seriously browsers mobile everything
else just don't know more desktop
applications we don't need them is my
windows forms application ready for a
dotnet core yeah the fun thing about
windows forms not being ready for dotnet
core is that you sort of go well I
wouldn't expect system dot Windows Start
forms to be there you might expect
system dot drawing to be there and no it
isn't which means you don't have image
you don't have bitmap you don't have the
ability to load a byte array and then
tell the framework that it's PNG and
then resize it and create thumbnails and
all this sort of stuff and that is still
up in the air what's gonna happen there
what I'm really hoping is that someone
will create a kind of open source really
good image processing library that we
can all use instead so with that those
things are not ready asp net core you
might find that you have an MVC and web
api application and that could be easier
to bring across you might not have to do
a lot of work
I brought an MVC and web api application
across two beta three of asp net 5 and
actually I had to delete some things and
do a search and replace on some
attributes but for the most part it did
just work it came across so there are
differences with asp net core versus
traditional asp net and these are the
things that are gonna hit the majority
of people there's no I is integrated
pipeline because you have to assume that
there's no I is there might be is if
you're running this on Windows there's
probably IRS but if you're running it on
Linux in a docker container in Amazon
Web Services
then there's no iis okay so there's no
web config so all the stuff that you
would have put in web config isn't there
anymore you can't do that you have to
put it in code instead which is a good
thing in my opinion they're a new
standard libraries for doing certain
things and there's no bundling or web
grease so when you want to minify your
JavaScript and turn your les files or
your sass files into CSS files you have
to use the same tools that the rest of
the world uses instead of just creating
a bundle and letting net take care of it
for you again this is a good thing you
should you should be happy that bundling
and web grease have gone away because
the stuff the rest of the world uses is
a little bit better uglify for example
for minifying javascript occupy is the
best javascript minify you've never used
unless you've used it in which case
yay the reason it's the best is because
it has a flag that you can pass in - -
screw I ate
because it turns out that all the other
browsers can cope with an extra level of
minification but it makes IRS that makes
ie8 cry so what is no integrative
pipeline mean so the things that are
part of the integrated pipeline are HTTP
modules and HTTP handlers so I is knows
what these things are and it can load
them up inside its own process space and
do various things before the code ever
actually hits your your.net process okay
and you get stuff like static file
handling for example is is in there
which means you don't need to say handle
these static files it will just go as a
file called that I will download it for
you that's that's convenient and nice
and everything but if you google web
config you will find that quite a lot of
people have not configured the static
file handling an IRS correctly and that
you can download the web config from
their website which is awesome generally
works best on those sites where all the
pages end with aspx obviously there's no
iis authentication so you can't say the
windows authentication or do basic
authentication or whatever inside iis so
we have to handle that ourselves as well
and there's no application pulse right
so if your application leaks memory and
and that's been fine because every 20
minutes you recycle the app pool and it
releases all the memory and starts again
you're gonna have to fix your
application ok it was gonna happen
sooner or later just put your big-boy
pants on and and fix the memory
leak okay all of this has been replaced
with middleware
okay so middleware is rails guy will
know about this rack Ruby has has this
thing called rack which sits between web
servers and applications and handles
turning streams of bytes into
into requests okay now kestrel handles
the turning of streams of bytes into
requests but then we have a series of
middleware that basically says okay pass
me this request and I'll see what I can
do I can modify the request I can inject
information into the request for other
stuff to use later on
or I can reject the request or I can
handle the request okay so I just want
to take a quick look at some code can
everyone see well enough people at the
back there yep I'm seeing thumbs if I
can see your thumbs I'm guessing you can
see my code right so this is a startup
class here and we've got this eye
hosting environment comes in at the
startup there but then we got configure
services and we'll talk about what that
is in a moment okay and then we've got
this configure here and this is the real
middleware part of the application okay
so we've got we're adding a developer
exception page so we're in web config
you would have said custom errors mode
equals remote only or off or whatever we
now handle that by saying okay is this
the development environment and the way
we work out this is the development
environment is there is an environment
variable asp net core underscore
environment okay if you set that to
development then end his development
returns true when you ship into
production you set it to production and
then different code runs instead and
it's great you know because previously
all we really had as a configuration
option here was do we show the yellow
screen of death yes or no whereas now we
can say if we're in development mode or
in staging or in test or you can
basically any string it can be an
environment name then you can say use
the developer exception page you to the
database error page write some extremely
complicated logging information that
takes a long time to extract that I
wouldn't want to be doing into
production
to log stash or Raygun or wherever you
send your errors to otherwise just use
this exception handler and redirect to
our home error page okay we have app dot
you static files if you don't put app
dot you static files into your
application you won't be able to serve
any of your static files and when you
say app dot you static files what it
uses as the route by default for those
static files is this folder here
dub-dub-dub root and everything in there
is a static file except web config
funnily enough there is a web block
config hiding in there for iOS if it's
using it and everything that's not in
there is not a static file which is just
really nice and easy okay use static
files you can't put an index dot HTML
file in dub-dub-dub root and expect it
to get served if you want to do that
then you have to say app dot use file
server or something let's see if I can
use file server yeah so that's if you're
running you can just run a static web
site you can literally take everything
else out and just in configure take MVC
out take everything out and just in
configure have used static files and use
dotnet core as a static file server
which may sound like a weird thing to do
but if you look on NPM form ojs there's
an H there's a static package that is
used just to do that ok app don't use
identity so that's adding in identity
management and basic authentication and
if you can if you install a bunch of
Microsoft authentication libraries from
NuGet then you can add Facebook and add
Twitter and add Google and add window
Microsoft Live with passport net fit
whatever it's called now Microsoft
account I think it is at the moment
there's an Active Directory and on Azure
Active Directory plugin for that as
well and obviously you can write your
own you can also use identity server
which I highly recommend if you want to
do federated authentication just spin up
identity server version 4 I believe runs
on net core spin that up use that as
your authentication thing they've got
middleware that you just drop in here
saying use identity server and then you
can just forget about it okay and then
use MVC down at the bottom if you don't
put use MVC in there then your
controllers will never get hit so
there's some new bits in there as well
and we're going to talk about those now
we have dependency injection is now
built-in so in MVC it's always supported
dependency injection and basically what
you do is you go right going to use auto
Frank or an inject or structure map or
unity or castle Windsor or the other
thing and then asp net MVC defers to
that and says create me a controller and
and handle its dependencies we now have
dependency injection built-in and that
is in the configure services section up
here okay so we have a service
collection which is sort of like it's
somewhere between a container and a
service locator but you get your service
collection and you say okay I'm gonna
add my DB context that's entity
framework in there so I'm adding my
database context as a service and then
I'm setting the options to use sequel
server you could also have options don't
use Postgres equal other databases as
well but outside of those two I really
have no idea why you'd be using that
stop it unless your friend is a DBA in
which case you want to ensure his
continued employment and success and so
you probably want to use Oracle so yeah
and we say services to add identity and
you can configure all your identity
providers and everything else in there
and then you can see that this is a
proper kind of dependency injection
system here because we've got ad train
and I email sender and I SMS sender
those have been added in automatically
because Microsoft's auto-generated
identity system lets them put in email
address and a phone number for password
recovery and two-factor authentication
and all that sort of stuff ok so that's
now you might say well I don't want to
use those things I want to use structure
map or I want to use auto Frank and I
completely wouldn't blame you and what
you can do is you can hook structure map
or auto map Auto fact up as the provider
as the container for the built in
dependency injection system so if you've
got an asp net called an asp net MVC 5
and web api application then that's
using auto faq and you've got like a
thousand lines of setup of all your
dependencies right it takes about 12
lines of code and you can say to service
a collection use this as your ioc
container so like services use container
and then pass your auto fact container
or your n-- inject container in there do
you see how i don't favor anyone in
particular i keep using different ones
because i'm just that professional
unities though so configuration has
changed as well configuration you there
are two ways of doing configuration I
mean there were obviously millions of
ways but there are two sort of
out-of-the-box ways of doing
configuration in an asp net application
you can just put stuff into app settings
and connection strings inside your web
config and then when you do your release
you have to use the built-in publish so
that it will do the XSL transform and
apply the values from web release config
which the thing i find amazing and the
thing that says to me we are in a time
of great progress is that five years ago
that
the best way to do that so look how far
we've come in five years where we've
worked out that there are other ways to
change information than using XSL
transforms yes so now you just come that
you have a various different kinds of
configuration and so forth or the other
place you could put it was you can
actually create this really complicated
class structure which would then map to
a whole section of your web config file
if you look at end log or log Fernet you
can create a log for net section which
is thing got strongly typed bits inside
there and we don't have that anymore
we now have if we go back up to the top
here we have this configuration builder
and with configuration builder you can
use environment variables you can use
JSON files you can use command-line
arguments you can write your own
configuration provider and plug it in
there and that could pull data out of a
database it could pull data out of table
storage in Azure you could use console
or xcd if you don't know what those
things are you probably want to learn
sometime over the next 12 months if I
come back next year and you still don't
know I'll be very cross and the really
nice thing is we've got if you look at
these two lines here we've got a JSON
file appsettings jason okay and if I go
down here I can open up app settings
Jason and that has got connection
strings default connection and that's
got my thing there and logging settings
and so forth and then we've also got app
settings I'm just going to try and
select this sorry my laptop screen my
laptop is very very old
and the screen resolution is only 1440
by 900 which doesn't project well onto
there so I have to work from here so
this is AC sharp 6 interpolated string
you can tell because it's got the dollar
at the start which means that anything
inside curly braces is evaluated as an
inverse as a variable and so we're
saying app settings dot m dot
environment name Jason and so if you've
got an app settings development Jason
there
it will pull that in if you've got an
app setting stop production Jason it
will pull that in no XSL transforms no
web deploy publish step it just looks
for a file with a particular name and it
uses it now what you should be doing
here because you don't want to be
putting your connection strings into any
kind of file and checking it into source
control is you can say dot add
environment variables at the end and
then when you launch the process you say
connection strings underscore underscore
user database equals and then a
connection string for Postgres equal or
sequel server and then you launch the
application with that environment
setting that's that's the correct way to
do it or you use the distributed
configuration thing like console or HCD
so you can just change these things on
the fly and people are writing
configuration builder ad console for
example to automatically talk to that ok
user secrets
I've never successfully got to work but
that's a way of keeping those values on
your machine in an encrypted file which
is quite handy and then you just build
that out and then you can create
strongly-typed option settings from that
so I could create a class called
connection strings and add a property to
that called identity database and then I
could say in services I could say use
this class and pass in the configuration
setting there and it would create a
strongly typed class for me there much
easier than the other way of doing
things the the whole XML mapping thing
ok and then there's logging and logging
is very important and logging on Windows
there's been lots of lovely ways you
could do logging you could write to
trace you could write to event tracing
for Windows you could go into Windows
Event Viewer and all this other stuff
and you could use n log and Sarah log
and log Fernet and various other logging
libraries the problem so two problems
one problem funnily enough Linux doesn't
have event tracing for Windows
and it's really I don't want to talk
about what it does have because what it
does have is Journal D yes let's use a
binary format for our log files trap
syslog which was great but it has
journal D you don't actually want to
write to any of those things what you
should be doing now really is writing to
standard out and standard error you just
turn your error message into a string
write it to standard out and then have
something running outside of the process
which is monitoring standard out for
that process and just then shipping that
off to lock status or whatever if you're
running on Linux what you do is you have
fluent D and you tell fluent D to watch
the standard out from other processes
and then fluent these configurations
says if it comes in on standard error
send it to Raygun otherwise send it to
New Relic or Splunk or whatever you're
using for that the other problem with
the old way of doing it is okay so I've
got my application and I like n log and
so I'm going to use n log and I'm going
to set N log up with dependency
injection so I can have an N log logger
injected into all my controller classes
but I'm using this this library over
here which turns Postgres equal into a
document database chair I'm using Martin
okay and I like Martin and it's great
and you know it turns out Postgres equal
is the best document database ever and
that's brilliant but Jeremy doesn't know
that I'm using n log so I have no way of
getting log messages out of there on
windows everything wrote to trace and
that was funny because you just set up
trace listeners but we don't have that
anymore so now what we have is built
into asp.net core built into the the
Microsoft framework layer we have
logging and so down here you can see
when we're doing a configure we say
logger factory
okay now logger factory is just there I
don't have to say I want to use this I
just installed the package and then
logger factory is available it just adds
itself in automatically and then I can
say add console I can say add deeper
it'll say alright if I'm running a
Visual Studio or Visual Studio code or
something that supports debug then I'll
write to the debug output in there if
you know you're going to be running on
Windows then you could say logger
factory dots ad etw or add trace if you
generally I would recommend just write
it out to the console okay
and there's configuration in there so
you can say if I'm running it on my
desktop machine so if enemy's
development like a factory that I had
console stick some color in there but if
you're running it in production on the
server don't stick color in there
because those just come through as
control characters into your log files
and make them hard to search ok but this
means that anybody who's writing a
library like Martin or simple data or or
Nancy or whatever can just go right I'm
taking a dependency on logger factory
when you put me in your application
you'll get that anyway you're probably
using it already and so I can say logger
Factory get logger and I will be writing
to the same place that you've decided
you're going to write to and if where
you want to write to is Sarah log or n
log then you can say logger factory dot
add n log and you can bring all your n
log code over or your Sarah log code
over Sarah log in particular because
that does weird structured things and
it's very cool so yes you can bring that
across as well so all your existing
logging code that you're doing lovely
things with will still work you just add
them as an output for logger factory and
the really nice thing is that then
everything will be writing into them as
well ok
at HTML dot editor for in particular but
also action link and so forth
they're still there but you won't want
to use them when you see what's there
instead which is tag helpers tag helpers
are just completely brilliant I'll show
you some tackle pers let's go into here
so again when you are in development you
want a different set of HTML rendered
most of the time than you do when you're
in production ok and there's a really
nice tank helper so when you're in
production you want your CDN and ideally
when you'll see the end with fall back
so it'll fall back to your thing but
when you're in development mode you want
to use the unbelief eyed JavaScript and
CSS that's on your machine because you
don't want to be trying to run your
website and then because you're on an
aeroplane you can't because it can't get
to CloudFlare or MaxCDN or whatever so
there's a tag helper in the stack views
generally will still work you can just
copy your views across for the most part
but you'll want to edit them to add in
various new bits and pieces hello did
you get my double click yes you did
there we go right so look here this is
this is a tank helper basically that is
saying if we're in development it's
saying right click menu if we're in
development then use Lib bootstrap from
my local stuff and site dot CSS
otherwise if we're in production then
use these things here
those are tank helpers they're a little
bit like the old ASP - or ASP : text box
things from web forms but it's best not
to think too much about that because it
will make you feel dirty
so instead we we think of them as like
more like angular or web components or
you know the sort of custom element
names except these are handled by Razer
so that's that's a simple example of
it'll either output what's inside it or
it won't and then it will just disappear
the other type of helpers we have are
attribute-based tank helpers so in an
asp net 5mm vc5 application these would
say HTML action link and then home comma
index home comma about okay
and now we say ASP - controller is home
and ASP - in action is index the reason
this is nicer is because of the bits
after it where we're saying class is
navbar - brand so this has always always
been the problem with HTML helpers
whether you're saying action link or
editor for you want to be able to say
this is an F barb wrangling this is a
danger link this is a form control and a
grouped button or input or whatever and
you had to pass in an anonymous object
with the values for the attributes that
you wanted to pass in there as well if
you wanted to put like Aria helpers and
that sort of thing in there and of
course you couldn't put class in as a
property in that anonymous object that
you were passing in because class is a
reserved keyword in in c-sharp they use
it for something I can't remember what
but you're definitely not supposed to
use it as a property name and so they
had to add a special case thing where
they had a class parameter for and now
it's just much easier you just write the
HTML for the thing that you want to
generate and then you add these couple
of ASP - attributes to it and it takes
care of that stuff for you so those
attack helpers so again like I say HTML
dot this and dot that and dot the other
still there will still work but move
away from it move towards this stuff and
it just makes your code much nicer and
cleaner and easier to work with right
the other thing you'll need to do which
I don't have a slide for is clean up so
all your Web API controllers currently
derive from API controller
don't do that they just arrived from
controller now and actually they only
derive from controller if you need to
use any of the built-in functions that
are on controller if you are literally
just getting a dependency injection
dbcontext and pulling a list of
spaceships out of your space station
docking database this is my demo app
that I always use because I like elite
and no man's sky and stuff let's just go
and play that but know if you don't
actually need the stuff from the
controller base apart you don't have to
inherit from it at all which saves a lot
of time creating and and tearing down
the thing and the attributes have
changed you got attribute routing used
to say HTTP GET comma route API slash
something's left something now because
someone worked out that that's stupid
you just say HTTP GET and then pass the
URL in as a parameter to HTTP GET or
post or whatever
also things like action filters the big
advantage here is that the MVC action
filters and the web api action filters
are their same action filters you don't
have to implement two sets of action
filters one for your page controllers
and one for your API controllers it's
all bundled together they're pretty much
the same internally they all sort of
default to being asynchronous the whole
framework right the way through defaults
to being as asynchronous as possible
performance suffers probably a bit for
that but actually get the same hardware
and run an asp net v asp net MVC 5 and
web api application on iis on windows
and then run an asp net core application
and you will see orders of magnitude in
terms of performance increase it is
ridiculously fast entity framework core
who's using entity framework in their
applications at the moment yeah ok
entity framework core is code first you
can make it work with an existing
database
but it is code first you create the
classes you put the attributes on the
classes to tell entity framework counter
magnet of the database you can no longer
go to sequel server management studio
hold down the mouse button on your
database and drag it on to visual studio
and have it generate four and a half
million lines of XML and eight million
lines of classes that you will never use
some people are quite cross about that
and I think the best thing to do is to
eat those people I suspect they would
taste like bacon so you've got DB dot
ensure database at the moment yeah when
your application spins up in your
application start or app setup or
whatever you call DB dot ensure database
and it runs the migrations for you
that's still there again it's kind of
for backward compatibility but we now
have DB dot migrate which is much more
sensible you can pass in specifically
which version of the database you want
to get the difference here right the
reason you want to switch over to DB
migrate is DB ensure database doesn't
create the migration history in the
database it just makes sure the database
is right
DB dot migrate does it the kind of one
migration at a time and then keeps the
history and so you can do DB dot migrate
down and so forth which is quite handy
and we now have the dotnet EF command
line so mat before was talking about
this new net command line we've had this
weird situation with Visual Studio and
the package manager console for quite a
while where it's kind of is therefore
installed package but then you're
supposed to use the package manager
console to add migrations to your
project I've spoke entity framework as a
package so it makes sense because of
that anyway map mentioned that Nets the
command line thing is extensible and you
can just create dotnet - whatever dot XE
and dot if you put it in the right place
dotnet will go yeah I can do that and so
there is a dotnet - EF XE and then
there's a dotnet -
EF - ad which will add a migration and
everything you can run migrations and so
forth so using the the dotnet EF command
line the nice thing about that is it
does work from the package manager
console but it also works from you know
CMD or com EMU or CMD or whatever you're
using it works from PowerShell it works
from the command prompt it works from
bash it works on your Linux machine it
works on your Mac machine databases
don't work on your Mac machine but you
know dotnet EF will work on there for
you
so yes entity framework there's a bunch
of stuff that isn't in there but for the
most part unless you were doing really
kind of weird horrible things entity
framework will still mostly work the way
you expect it to the really nice thing
is as we saw in the configuration
section there you can basically just
because asp net core and the dependency
injection system and everything are in
there you can now just say services and
you can just add a DB context so you
don't have to create a wrapper around
your DB context and then pull that in
and so it has an interface and so forth
you can just say services don't add DB
context that takes care of hooking it up
and setting connection strings and and
everything else and if you've got
logging set up and you've got verbose
logging turned on that entity framework
will write all its logs to wherever you
have your other logs going to so you can
get all your generated sequel written
out and so forth so yeah so that's nice
who's going to messy DMX files damn I
wanted a bacon sandwich
so dotnet core this is the thing where
people have been getting stressed and
going on are they're bringing back
everything and we're losing everything
and I I hate everything right now I this
may not be right it was right 45 minutes
ago when this talk started things that
have got app domains app domains have
gone
I don't like app domains I find them
incredibly annoying it's very hard to
write code that works inside an app
domain properly it's very hard
definitely very hard to write code that
sits sort of either side of the app
domain boundary and works reliably
because things have to be C realized to
binary across the boundary is hideous
it's absolutely hideous
okay the one thing at domains good for
is if you need to load and assembly like
a plug-in or something and then you want
to get rid of it without without
restarting your process and then load
another version of that assembly then
app domains are good for that but
there's a new thing called assembly load
contexts which is used throughout asp
net MVC and you can load things in using
that and you can actually have multiple
copies of the same assembly in different
load contexts at the same time and you
can just pass objects to them it's
lovely
it's brilliant keeps them all set for it
sort of sandboxing and so forth so don't
miss out domains because we have load
context instead dotnet remoting is gone
again that was a hideous hack to make it
look like this class here existed on
this machine here when it didn't there
was actually an ISDN line in between the
two things it's one of Microsoft's very
early dotnet don't worry about
complicated things like that will take
care of it just pretend you're writing a
windows forms application so that's not
there anymore you're actually going to
have to write networking code if you
want to do networking sucks to be you
binary serialization has gone for much
the same reason and currently code
access security is gone now
strong naming had gone and then they
brought that back we also lost assembly
neutral interfaces and assembly neutral
types fairly early on in the process and
I did weep a little for those because
they were great code access security is
the thing where you can say right you
need full trust or partial trust or
whatever
now obviously Linux systems don't have
full trust partial trust they basically
have all the other users and route and
if you're running as root then yes you
can RM minus RF slash at least until it
gets to slash user slash bin slash RM at
which point it will stop so code access
security is gone
now these things may come back as NuGet
packages that will only work on windows
ok things like app domains and binary
sea rice and net Rohtak they could be
brought back as NuGet packages and if
you are happy to say this is a Windows
only application then you can use them
with with those various constraints
that's good that means that people
who've got enormous investments in code
that use these features and are happy to
continue paying microsoft's increasingly
expensive server core license prices can
carry on using their code and they can
migrate over to this new thing and the
rest of us who want to write
applications that we can spin up on
linux boxes or this new server lists
architecture I don't know if you've seen
this but someone's worked out a way to
to run processes on the moon and
communicate with it using lasers which
is fantastic
literally and we can do that and we just
don't download those new get packages so
don't get cross because Microsoft are
going to release some new get packages
to increase backwards compatibility with
the old dotnet framework getting cross
about that is just mean and God knows
the people who need those new get
packages have got enough problems in
their lives without you being mean to
them ok stop it there are some things
which are changed ok and I'm just gonna
flag up to the cryptography api's again
they seem to be introducing some shims
but you've been using our ng crypto
service provider or
scripto service provider all this time
okay you don't know that those have been
deprecated since dotnet three when when
Microsoft released Vista one of the
things I introduced as a whole new
cryptography subsystem inside the kernel
which is used using CNG cryptography
next-generation api's and so there all
these CNG ways of doing things as well
and when they did dotnet core on the
core framework they went you know what
we've had the deprecated or obsolete
attribute on our energy service provider
for a long time let's not port them
across and so they're gone
and again backward compatibility
packages coming to bring them back but
you it is better to use CNG in the same
way that it's better to use HTTP client
because web request is just an
abstraction around it it's better to use
the CNG api's because the crypto service
providers if they do create them will
just be a shim or a wrapper around those
and obviously want to be closer to the
metal reflection has also been up and
down reflection wasn't available on
things like WinRT and the Universal
Windows platform which meant they took
an awful lot of things off of type so
when you did object get type you
couldn't do get properties get methods
get fields get this get that get the
other invoke all this other stuff they
moved all of those onto a type info
object that was not available in dotnet
in Windows RT and then you had gets
properties and get methods and
everything off there now this and talk
about whether they're moving things back
and everything else but we need to talk
about reflection more deeply anyway on
the next slide let's go to the next
slide there we go so that's light so yes
things that you shouldn't count on right
who uses reflection dot emit in their
code or or compiled link expressions
yeah one person you're wrong all of you
whose is Jason net yeah whose is dapper
who's his entity framework
whose is asp net MVC web api and to any
of these things all these frameworks all
these libraries that you're using and
plugging together to build your
applications in size depo uses
reflection dot emit that's how it can
map sequel data readers to classes so
fast jason dotnet i not revisit
reflection document or compiled link
expressions my simple data library uses
compiled link expressions all over the
place because it's quicker to generate a
bunch of code once and then reuse it
over and over again than it is to keep
saying type method invoke okay but if
you're happy that your application is
going to be a self-contained application
that runs with core CLR on linux and mac
and windows or with the runtime on the
linux and mac and windows then it's fine
you can use reflection to make Jason net
all these things will still work if you
are thinking I want to build one of
these nice tight statically linked
precompiled ahead of time executables
then reflection dot inmates you know it
doesn't have a JIT there is no
just-in-time compiler there's it's not
there you're not going to ship a
just-in-time compiler
inside the runtime code for native
compiled code because there's no
bytecode in there which means you can't
generate bytecode and then have it
cheated at runtime now there are people
working on ways around this and whether
they'll get there or not I don't know
but for now what this means is that you
can't native compile an ASP NS MVC
application all right what you need to
do is go to the Roslin issues page and
demand hygienic macros for c-sharp
we might get them now because anders has
gone he's doing typescript if we can get
hygienic macros for c-sharp then we can
generate json serialization classes and
route handling classes and all these
things at compile time and then have the
native compiled if you look at things
like rust and go that's how they work
rust has rusts json library generates
rust code
at compile-time that then handles Jason
serialization so yes that's that's
probably gone things that are obviously
gone so we've already said windows forms
WPF asp net web forms you poor bastard
win32 Interop obviously if you want to
write an application again if you're
working on Windows if your entire
infrastructure is on Windows and you're
building an Internet application then
fine yes you can carry on doing win32
Interop and using shell execute w or
whatever but if you want to write an
application that you can put into a
docker container and run on a linux box
or that anyone can deploy wherever they
want to feel selling a kind of bundle
this and put it on your own
infrastructure dotnet application then
you haven't got Windows 32 just assume
you haven't got Windows 32 just assume
you haven't got office ok so you'll want
to write some kind of wrappers around
those that can be optionally loaded and
say if you've got office then do this if
you're on Linux then use those and and
so forth ok those are basically done to
finish up with so hopefully you've got a
rough idea of whether your particular
code base is ready for dotnet core now I
kind of called out the big things
c-sharp still works about everything
else still works ok it's still classes
it's not scary and new everything is
still normal C sharps got some nice new
features I hated string interpolation
when they announced it I thought that's
terrible I love it now it's it's some
string dot format
resharper it just goes you got string
dot format in there you're stupid you
want to change that to string
interpolation you're like god yes yes I
do
so yeah you can go through and you can
clean up a lot of stuff and you've got
like the new way of doing properties and
read-only properties you don't you could
just create a property that's just got a
getter and now c-sharp will let you set
the value of that in the constructor
which is great
but you are you ready for dotnet core
are you ready for like the next 10 15
years of dotnet development so these are
the things that I think you should
probably be looking at learning to make
sure that you are either doing the best
job that you can where you are or more
importantly that you are portable to
other is
who may be willing to pay you more or
have a ping-pong table Linux including
bash em I promise you once you learn
Linux and you learn bash you will agree
with me that PowerShell is an
abomination a blight upon the face of
shells on computers and we should all
just use bash if you're using Windows 10
when you get the threshold or
anniversary update just just download
and run a bun to inside windows and it's
got bash and everything works just learn
it it's great okay but you're gonna be
running stuff on Linux you need to know
how Linux works you need to know about
demons and system D and Journal D and
flu and D and lots of words ending with
be okay you need to understand how
that's working you need to understand
the web servers that you're going to be
using when you deploy code onto Linux
because you are going to reverse proxy
your kestrel application behind I use
nginx I've used H a proxy I've worked on
things that used to H a proxy that's
very good H a proxies better for load
balancing nginx is great first single
servers I've actually worked on things
where they used an engine X proxy per
single server and then an H a proxy load
balancing to all of them which was just
weird Apache is still there bless it you
know but you won't be using like mod
mono anymore you'll be reverse proxying
so learn all about that you'll wonder
whether nodejs and NPM and gulp and web
pack because web grease has gone now I
wouldn't worry too much about power at
this point pretty much everything is now
in NPM so just just worry about that
you'll want to learn docker
this is you know obviously you'd have to
learn docker
even if you don't know what docker is
you're vaguely aware that you need to
learn it right it's it's cool and and
it's docker but now this is this is how
we do DevOps now this is how we do
publish okay you create a docker
container you push it up to the dock of
registry you bounce onto a machine and
you pull it down and you run it okay
on the Saturday I did a talk at
Microsoft in the UK and my it was a demo
kind of workshop thing and so my idea
was I'm going to start
scratch empty Visual Studio create an
application debug it in docker which you
can do on Windows now run docker for
windows beta run the vs tools for docker
f5 and it hits and you can step debug
for it while it's running in docker push
the container up to the docker registry
use terraform to create an abundance in
over for server in Azure on a Linux VM
and install docker onto it SSH on to it
and then pull docker and run it and it
was there ok and I thought that's great
I've got an hour but that'll be a nice
kind of demo I turned off and they went
you've got 30 minutes and I still did it
all of that in 30 minutes ok because
docker and various other things
terraform also pull stack I think is
doing a talk on infrastructure as code
with terraform you may have already done
it if you don't watch it is brilliant
and then the other thing you want to
learn is Python because there's all
sorts of stuff that you want to script
and bash is great but you get to a point
where bash doesn't work properly anymore
and you need to interact with like the
docker daemon directly or or various
things Python as a scripting language is
fantastic don't use it as a web
development language that's just stupid
but as a scripting language is it's
superb it is just without peer ok so
that's all the stuff that you should
still be learning this is all the stuff
that's still also about dotnet core and
the reason we should still be positive
about it
it is cross-platform we can run on the
Linux that's much cheaper and in some
cases a lot faster we can deploy
self-contained applications that have
the runtime inside the folder so you can
just ex copy it you don't need to
install a runtime you don't need to
worry that this new version of the.net
framework is going to break this old
version of the.net framework everything
literally everything including the CLR
is a new get package so you just
download the bits that you need and you
don't download the bits that you don't
need and eventually for a specific
subset of code we will have native
compilation with static linking and
stuff and people can finally stop going
on about go that's it for me
thank you very much enjoy the rest of
the conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>