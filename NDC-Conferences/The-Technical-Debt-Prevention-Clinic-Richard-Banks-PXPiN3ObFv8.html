<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Technical Debt Prevention Clinic - Richard Banks | Coder Coacher - Coaching Coders</title><meta content="The Technical Debt Prevention Clinic - Richard Banks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Technical Debt Prevention Clinic - Richard Banks</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PXPiN3ObFv8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone how you doing
very formal this is the introduction
part where I say hello my name is
Richard this is the technical debt
prevention clinic I was going to be
really cheesy and we're like a lab coat
and a stethoscope or something like that
and say you know the doctor is in but
let's face it something's so much you
can do for a dead patient um all right
so introductions I'm Richard there's my
twitter handle email all that sort of
thing
feel free to hit me up on any social
networks ask questions all that sort of
stuff as you would just in terms of
background I tend to do a bit of talking
I run the auto connect group here in
Sydney with a few others so who comes
that just who's a local so you guys
already know what you're in for
congratulations I don't know why you're
here again I also am a Microsoft MVP
principal consultant we ratify written a
couple of books I do scrum coaching and
training as well as I'm a scrum guide
all accredited trainer basically means I
have no social life at all and I don't
know why I do this so we're going to get
into it because what you're really
interested in is the content of the talk
not me
and here's what we're running through so
we you know have to do the structure to
start off with basically we're going to
cover off what technical debt really is
not what you think it is probably what
it's all about how we end up with it
most of you know how we end up with it
right we write code good then how do we
quantify it if we can how do we reduce
it and reduce the problem and then
preferably how do we actually prevent to
being a problem in the first place so
that's the intent you're all with me so
far you haven't fallen asleep after
lunch yet still time cool all right so
take that what's it all about it's a
metaphor nothing fancy is just a
metaphor in the industry you might have
noticed we'd like to take our metaphors
and make them bigger than they are
metaphors are just things to explain a
concept we've turned it into this thing
and now people would go crazy with it
and actually try and put dollar values
on there technical debt all sorts of
stuff as if it was real financial debt I
mean it's just a metaphor now question
is where'd it come from because we
really should understand where this
whole
thing came about who started the idea
and so forth so guy named Ward
Cunningham anyone heard of at all few of
you awesome at an oops the conference
back in 92 being the object oriented
programming symposium of Los Angeles
it's great said this so although
immature code might work fine and be
completely acceptable to the customer
excess quantities will make a program
unmask trouble leading to extreme
specialization of programmers and an
infix flexible product I'll put my teeth
thank you so being a clinic let's
diagnose the patient who's got an
inflexible product thank you for your
honesty the rest of you you're all liars
do you have specialized programmers guys
who or girls who know just that bit and
no one else does anyone few more hands
good we're getting there
all right and do you have a mature code
did you write it today hands keep going
up these are all problems we have now
the metaphor is to this idea that
shipping code for the first time is like
going into debt this is the metaphor
right a little dead space development so
long as it's paid back promptly with a
rewrite so a little debt speeds
development interesting who has a little
debt no hands all right I'm gonna ask
the opposite question cuz I like to be
scared who has a lot of debt we didn't
even have to quantify that you just go
yeah we got heaps who's got those parts
of the code base that they just don't
want to touch because every time they do
it's yeah okay yeah and who blames the
previous person for writing it all right
so what would saying with this metaphor
had two hands nice what he's saying is
that technical debt is good technical
debt treated well is good because it
lets us deliver faster to our customers
let us put something in front of our
customers that works well remember we
said it's immature code but it works so
where I would put something in front of
our customers to learn from it so we get
earlier feedback and we can then use
that to improve our design and then the
value delivered over time and our
maintainability and all those sort of
things does this sound familiar to
anyone yeah now what happens normally by
the way out yeah we stop there yeah yeah
we write our proof of concept code and
what happens to a proof of concept code
ship it its production but if we say if
we think technical debt is good you know
if we were to use someone else who's not
Gordon Gekko we would say something like
you know technical dead is for lack of a
better word good technical dead he's
right it sounds terrible you've really
got to do it with a bad accent
technically it works it clarifies it cut
through cuts through and captures the
essence of the evolutionary spirit this
last bit cuts through and the
evolutionary spirit is what we want in
agile software development we want to
get stuff in front of customers get them
using it see if it works or not clean it
up a bit afterwards pay back our debt
and then carry on which means that 10
your debt is a healthy part of an agile
team who's doing agile development of
some variety who's doing cowboy
development pretending it's agile good
who's doing waterfall development
because they still work in a really
large organization and by really large I
mean government am i close
am i close all right 10 your debt is not
this this is what most people think of
as technical debt the quick and dirty
stuff that's not technical debt quick
and dirty is not a way to just just slap
stuff out there yet the blogosphere cuz
no one's used the live blogosphere for a
while so I thought I'd crack it out for
another try
took that teeny with that metaphor and
confused it with the idea that you could
write code poorly with the intention of
doing a good job later I'm thinking that
was a primary source of debt now the
person who said this is again Ward
talking about other people's
interpretation of just a metaphor does
this seem a little too close to home for
people the road to hell is paved with
yeah absolutely
so these are problems is there's a whole
lot of stuff here that you can think
about in your day to day where you
intend to do something well like our
proof of concept code and then we put it
out there and we have to move on to
something else
and we never come back and clean things
up Wood says this though he's never in
favor of writing code poorly he's in
favor of writing code that works and
he's good but the reflects our current
understanding even if that understanding
is partial this comes back again to the
idea I write something I deliver it I
put it out there so that I can learn
from it
adjust and adapt and inspect and adapt I
should say and fix things up afterwards
so that it is maintainable code and I
read again a little daddy's healthy a
lot of debt we're drowning your bad code
as it turns out he's not technical debt
just go on go on own up yeah thank you
keep going I can't help you if you don't
admit you've got a problem here's the
other thing those bugs that you've got
that you got it's just technical debt
that's not technical debt either your
bugs are just bad code that doesn't even
work properly anyone again who's got by
the way a technical debt backlog yeah
you've got to like a list of these
technical debt issues that you want to
clean up are they basically bugs copy
and paste code shoddy design slap
together stuff that you've just never
cleaned up proof-of-concept code that's
ended up in production and you'll get to
it later what else is on there nothing
we've gone quiet it's interactive it's
okay
feature flags all right so technical
debt means you've got easy to change
well-written code
who's got technical debt
it just doesn't implement the full
solution right so this is the idea if
you're doing technical debt well you're
doing iteratively iterative and
incremental delivery add-on development
that's what we want so it's not these
things own up if you've got this quick
and dirty yes come on a few more come
okay maybe you didn't write it someone
else in your team wrote it or a friend
of someone who hypothetically had a
friend who was hypothetically working in
the same team might have written it
yesterday copy and paste development
Stack Overflow base development yes
unit tests as in you don't have them or
you've got unit tests that break every
time anything changes ever because your
unit tests aren't unit tests their
integration tests and extremely brutal
all refactoring that you've left for
later
that's not technical debt that's just
your bad code you haven't gone back
cleaned up the bugs are fixed later
mistakes that come from an experience
like skill carelessness all these sort
of things that happen these are problems
now this is all bad code all bad bad bad
bad bad it's not technical debt but it's
a problem and the fact that it's just a
metaphor means we really should deal
with both problems the proper form of
technical debt and then all the rubbish
that you guys have managed to produce so
let's quantify it how do we quantify bad
code any ideas
is it possible can we actually quantify
it can we get some unit of measure to
say yeah this is how much we've got how
do you define bad code great question so
let's go subjective right so how do you
do how do you quantify beauty and how do
you quantify ugly because when you look
at some code I'm not the same people
here by the way but some code you go
that's really nice code I like that and
some code you look at and you just kind
of go oh is that that's code only a
mother could love
so consider this how much time do you
spend on problems you could have avoided
by doing the carpenter thing I've
measured twice cut once last week how
much time did you spend banging your
head on the table thinking I could have
done this this could have been avoided
if only someone had a thought first or
they had have done something a little
bit better anyone more than five minutes
that's not many people you guys don't
okay managers you're okay everyone else
what are you doing all the number your
WTS per minute now you've probably seen
the xkcd comic and if you haven't you
know we can do the modern family version
at WTF Phil's Asif II the number why the
face is per minute and it's actually
really amusing if you walk around a dev
team you just watch them working you see
them go through the different
expressions right they bring up a bit of
code and what are their faces do what
and then it's like and then they get the
double facepalm and then they start
getting angry and they start getting
sweary in their faces a handsome anyone
did I miss a few by the way no the tease
I forgot the tease all right so there's
plenty of these things that happen right
you generally know based on these things
it's a subjective measure but how good
or bad some code is but you can be
easier about that instead of watching
people you can simply ask them let's
grab every member of the team come
together how do you feel about our code
quality between a 1 and a 5 alright so a
5 just to set the expectations is this
okay
a 1 is that so Phibes pause why are you
in the room 3 to everyone else you
didn't even make the scale like I'm
really concerned for you guys all right
so they're very subjective right now you
obviously can do objective measures as
well you can look at things like code
coverage and cyclomatic complexity and
class coupling and naming issues and
duplicated code you know a few
copy/paste development that we've never
ever done ourselves only someone else
and these are objective measures and
there's various tools that you can use
to look at these things in your code
base and see where stuff's at who's had
a sonar cube by the way who uses it
awesome
I love sonar cube I'm into graphs and
charts and things like that I just love
it
so being able to quantify and measure
some of these things is great it helps
me understand what quality of code base
is at now I don't always agree with some
of the measures in terms of where Sona
comes up with the number of days needed
to fix things especially when the number
of days equals that when the heat death
of the universe is going to occur but
those sort of things are really useful
in terms of understanding more the
volume the specific measure doesn't
matter but the volume of stuff that's in
your codebase these are things we can
look at but there's other indicators as
well we could look at trailing
indicators such as what's happening with
our velocity so our rate of delivery as
a team is generally a good indication
all right so if our delivery is going
along nicely everything's cool we
generally I would assume aren't picking
up too much technical debt or bad code
it's not slowing us down but you found
rate of progress starts doing Billy
odds are you're starting to struggle
with this stuff sound familiar
yeah who's got a velocity that's in the
negative
okay um service system availability how
often your system crashes in production
how often you have to bring it down
because you've got memory leaks how
often are you rebooting IAS and
restarting simply because you keep
hitting the memory limit no one has that
problem right
we don't do web applications or changed
it broke at their bugs near come on
anyone again you guys are great
it's only like 10% of the room that has
this problem
either that or you're working on really
simple applications or you don't
actually fix the bugs you just write
them in someone else fixes because we
don't have any tests we don't know that
it broke anywhere else so we're gold
star turnover and attrition yes this is
a nasty one if we've got problems we've
technical debt and bad code we generally
will struggle to keep people around
because they won't enjoy their work
which also affects your general morale
the passion of your team and the overall
happiness of your team doing the work
I'm not gonna ask who's got this problem
because it's not always a code related
thing that said in a lot of
organizations that suck devs can
generally be happy as long as the work
is interesting interesting when the
works not interesting even if it's a
good company the devs will tend to roll
through and go Emily I don't need to be
here this is not a challenge anymore
unless they're making their own
challenges
and also other things like declining
levels of skill and relevance so if I've
got bad code one of the interesting side
effects of that is that I can't move it
forward and modernize it because I've
got too much rubbish to deal with too
much legacy to hold on to so therefore
my skills tend to rot and this is how we
turn ourselves into the next version of
COBOL developers anyone still writing
done yet one code BB six by the way I
should check a few of us don't need to
anyone still have to crack our Visual
Studio 2008 to do anything yeah I just
just for fun all right now with all
these things you don't want to aim for
specific measures you're looking at
trends over time you're looking at how
things improve over time so so no cube
is good with that because we can see
trends but you can also do this the same
thing with your subjective measures
right so again looking at that quality
question if we ask the team you know
over the last n number of months what's
happened to our quality has it gone up
has it gone down what do you think are
you happier with where we're at or not
scary question to ask but hopefully we
have people saying this yeah five years
like it's so much better arm happy days
dancing in fields of roses and stuff one
maybe not roses they've got thorns other
flowers or yeah nothing's really changed
not a big deal it's like we're just
carrying on or
and if you think about your last three
months even that sort of timeframe which
way would you be heading and if you're
trending down you've got a problem so
it's not a perfect measure it's very
much subjective we've got some objective
measures but fairly subjective in terms
of what we can look at so let's have a
look now at once we understand the size
of our problem how do we actually do
something about it how do we reduce the
bad code and the technical debt we have
so who likes the technical dead sprint
approach anyone done one of these so
most of you are doing agile I assume you
understand what a sprint is or an
iteration who's done a technical debt
spree go on coming up nice okay don't do
them what's the business outcome of a
technical debt sprint nothing correct so
how do you prove you made any difference
how do you prove that here's what
normally happens by the way no take me
you're dead sprint you have a whole lot
of these big ideas I've got two weeks
we're gonna cut so much we could do in
two weeks so we go off and we start
writing stuff for our two weeks thing
and they're usually big efforts to
change a whole lot of stuff and we do
them in pairs maybe even maybe unlikely
it's usually solo and everyone's going
off and doing their thing and the first
person finishes their big restructuring
of the code and they can beat it what
happens to the rest of the team they go
no I didn't win the merge war so now
they've got conflicts all over the place
because they were doing restructuring as
well but they can't tell what should
have been to where it is now anymore the
size of the pool request that this first
merge went in was about near that big
and everyone obviously paid a lot of
attention when they absorbed that merge
and so they just slapped it in a way we
go how do we prove that we didn't break
anything along the way we don't because
we don't have any unit test because who
has time for that and we end up with all
this code that got moved around and
changed and now even
by some miracle everyone got their
changes in what happens the next sprint
when you start doing normal work again
stucco Oh where's this gone and what's
happened to that and I don't know what
happened to my codebase anymore and now
everything's all over the shop and I see
they're scratching my head and as a team
we've now actually made it worse for
ourselves in the following not just one
sprint but probably three or four
sprints and any net time we might have
saved in the technical dead sprint is
pretty much eaten up by the delays we
have in the following sprints and
there's no guarantee we've proved
anything anyway
what about this one anyone doing a
rewrite project ironically I was quoting
on one of these yesterday but you know
what the rewrite project is right this
is the I write the netscape browser up
should i stop me up everyone knows the
story so we're writing netscape it's
really horrible it doesn't do what we
need to do it's really hard to work on
it's terrible code so what should we do
throw it out and start again of course a
rewrite means do what the old thing did
correct how's it usually implemented
though do what the old thing did but
make it better er so what's the spec for
better er uh-huh keep talking yeah
silence good
no one knows no one knows it just means
better write better as defined by and so
we end up with this oh it's a rewrite so
everyone starts piling on all their
wishlist stuff as well and as des again
we can use all the new and shinies that
we've never used before so now we can
write it in angular 7 using JavaScript
ACMA 74 and dotnet core 3.6 service pack
1 or whatever other random thing and all
we should use some new design patterns
because I read about these on the
internet and even though it's a desktop
application we should write it as a
micro service and we should deploy with
darker because everyone once had docker
on their desktop
for normal users so we can run that
because that'd be cool it's gonna look
great on my resume anyone got this one
yeah so the end result is exactly the
same as before you've got a new mess now
you've got your old legacy mess and now
you've got a new mess and because your
new mess is just as bad as the old one
no one's using the new one so you're now
maintaining two messes don't do that the
problem with these rewrites isn't the
technical problem it's a cultural one
you don't get into the situation where
you've got bad code because of a cult a
technical problem it's not just that you
as devs write bad code or we I have to
talk to myself every time I do this talk
it's a whole lot more than that it's a
people problem code is not the result of
some thing that happens code is a result
of us using our brains to put something
on the screen so what's the source of
the problem his silence everyone's got
how he's talking about me yeah all right
so what should we do to reduce our
technical debt the boring stuff right
the iterative removal of technical debt
it's not sexy you definitely not
glamorous it doesn't look great on a
resume
it's nothing you can point out and go
that was exciting look at all that stuff
we reduced it's not easy it's not quick
it's not simple always comes with a cost
and you've got to remember that like
anything again abusing the metaphor the
bigger the loan it takes longer to pay
off so if you've got really horrible
technical debt problems and bad code
problems in your current codebase it's
going to take you a long time to fix
that similarly if you're only chipping
away at it a little bit at a time it's
going to take a lot longer as well
hopefully you're paying back more than
you're adding every time but sometimes
that's not even the case one person's
going through cleaning things up and the
rest of the team of eight is currently
writing their own new forms of technical
debt and bad code on top of it you're
never going to keep your head above
water but generally you want to follow
the Boy Scout rule for those who don't
know that basically says leave the
campsite cleaner than you found it do
the same in your code if you're changing
a bit of code
changing a method or a class or
something and you see a problem in there
just fix that little problem and move on
another way of looking at it is this
same ID as you're doing stuff identify a
change that's going to save the next
person two seconds two seconds a day two
seconds a week it doesn't really matter
any of those two second savings add up
and those two seconds savings aren't in
terms of how long it takes to write code
technical debt is not about how you
write the code technical debt is
understanding your code so the cognitive
load in your head how much do I have to
keep track of so I know what to change
so how long does it take you to figure
out the spot to change that's what we
have to improve obviously there's also
the r-word who knows the r-word did I
spell it correctly by the way because I
often see it spelt with EU you can
figure out where that one goes so the
idea of refactoring is a series of small
steps this is from Michael feathers who
came up with the approach each of which
changes the internal structure of the
code without changing the external
behavior most refactoring which is the
other form is where you do a series of
small steps where you change the
internal structure of the code you don't
even bother about checking the rest of
it just ignore that you can change the
external behavior as much as you want
let's redesign the whole application
because that's refactoring anyone take
that approach or seen someone they work
with do that yeah that's no refactoring
we don't want that you should not change
the behavior of the code when you
refactor at all I should see no
difference now Michael talks about two
forms by the way there are actually two
types of refactoring there's the micro
and the macro the micro is obviously the
simple stuff
you're just improving those two-second
savings improving the readability of
what's there fixing a naming problem you
know so I had a going back a while ago
and I'm gonna age myself even more than
it looks like at the moment I used to do
VAX basic programming on backs VMs is
anyone else with me on that yes so we're
going to get our walking canes and we'll
walk
here together and very procedural code
but we would you know in in backspace if
we had a variable name strangely enough
I had a guy who named all these
variables within a a procedure as temp 1
temp 2/10 3/10 4/10 5/10 to it it did
yeah it's great he had a long method
that had up to temp 47 in it
special he went on holidays for 6 weeks
and a bug occurred in that bit of code
and guess who got to fix it it took me
two weeks to figure out what was going
on as I did it I renamed all the
variables so that I understood what they
did which is kind of useful
so I improved the readability of the
code that's refactoring even way back
then ironically another bug occurred in
that bit of code about three months
later and I was like wow that's weird
and they gave it to me to fix because I
was nominally the last one to touch it
guess what all the variable names were
called temp 1 attempt 2 attempt 3 the
guide come back from holidays seen the
change to his code and gone and put it
back to what he had before this is
before source control by the way I'm not
doing that
alright so refactoring you are for
bigger stuff where you hit multiple
files that's obviously a macro
refactoring again you're still not
changing functionality ok so this is how
we're reducing it micro refactoring is
do magic as you're done
no problem fire it will it's all yours
ladies and gentlemen go nuts
but the macro refactoring is on the
other hand you're really in your team
only want to have one maybe two of these
active at any point in time because
they're changing the structure of your
code or they're making large changes
that will affect the rest of the team
you need to make sure the rest of the
team knows what those changes are so if
you have multiple of them happening at
once like in a technical dead sprint no
one's going to keep up with what's
happening you also the rest of the team
can also still be delivering value while
you're working through this all a part
of your team is working through this
but you need to make sure the changes
are well communicated and well
understood by the rest of the team
otherwise they're not going to help okay
so limit yourself work-in-progress rule
should be only one maybe two if they're
in very discreet areas like a front end
and a back end that are very separate
generally though your rules for
refactoring hopefully this is fairly
straightforward rule number one don't
talk about Fight Club okay
if you don't have any tests you can't
really do refactoring anyone got code
with no test at all yeah when you break
it by adding tests you have a gift all
right so micro refactoring if you're
going to do it make sure you introduce a
behavioral test to prove the behavior of
the code you're about to change change
it make sure the test still passes
fairly straightforward right but note
that wear make sure to the test exercise
the code you're about to change don't go
I know I wrote a test over there it
passes and now I'm gonna change this
that's cheating
and if it's a macro refactoring it's
very much the same approach you approach
you introduce passing hopefully
behavioral tests you make your changes
ensure those tests still pass okay you
won't want to rely on coverage tools to
make sure you're hitting enough of it to
give yourself confidence if you do
things that affect data based structures
and schemas you obviously need to think
about data migrations because a lot of
us forget that stuff and you also want
to check your performance I've seen a
number of people do refactorings that
have taken highly optimized code that
they didn't understand refactor it so
they could understand it and their
performance went from really good to
really mmm
less good because they've started
introducing n plus 1 queries to the
database and all sorts of stuff simply
because they didn't take the time to
understand it they just thought oh
that's bad code
but it was good code that ended up
getting optimized in the future so you
gotta watch out for that too all right
yeah refactoring feature flags we had a
talk on this just before lunch which I
did not know is happening before lunch I
was when Ethan said you know who's in
that talk lots of horror stories it was
great I loved it feature flags are a
great idea everyone knows what they are
right just to check if you don't the
idea is that we're enabling or disabling
features in production independently
from deployment right the
functionalities you just want to be able
to turn things on and off by setting a
flag at runtime fair enough and launch
darkly again I didn't know though it's
hooking before it's kind of ironic and
the sample code something like this you
know you get your user you call the
launch duckling client and say get me a
boolean flag and there's the name of it
this is my user and the default value is
false fair enough and if the feature is
on show the feature and if it's not do
it off basically glorified your
statements nothing more to it than that
really simple to implement okay how
could that possibly go wrong
I can implement this with good clean
code and still drowning technical debt
how because I don't think about things
properly I can have too small or too
fine-grained flags I can have too many
of them
anyone dealt with an s AP programmer
anyone because you're all smart enough
to run away screaming SOPs famous for
having flags for everything
configuration like you wouldn't believe
it's a flag heap like there's our
thousands and thousands and thousands of
them and trying to put anything together
that works with that many flags is
basically like taking your pile of Lego
at home throwing it in the air and
hoping it lands in the shape of the
house really horrible so that can be a
problem poro misleading naming because
naming is easy right everyone knows you
know the best way to name a method is to
call it method one the best way to name
a test is to test one so how hard can
that be
and all variables should be named
template
correct so poorly named flags lead to
all sorts of problems
duplicating a flag so that we have the
same feature controlled by two different
Flags we actually have to set them both
at the same time to make sure it's right
otherwise the system behaves
inconsistently or repurposing an
existing flag so again like Capital
Group was mentioned in the previous
session they're the guys who managed to
lose millions of dollars in 45 minutes
simply because they deployed an app with
a flag set missed one of their servers
and it all went they haywire do you ever
want to read up on that hilarious makes
you cry but hilarious or not removing
your unused Flags afterwards so you end
up with all these things that get left
in there
out of curiosity who's got source
control okay good good
who has people checking in commented out
code into source control why why for the
love of God why someone's gonna look at
that commented out code and what are
they gonna do oh oh should I remove that
or not is that meant to be uncommented
was that like test code that got but is
it my head just don't do that right same
with feature flags
once you're done get rid of them if the
feature is stable you're not gonna kill
it anymore just delete go on or no
documentation on what a flag does why
it's there and who came up with it
there's all sorts of these problems
these things here can kill the team not
done well the code can be good but the
code is immature yes it works but we
haven't really dealt with it so we were
able to get the feature into production
we were able to get testing and feedback
we never went back and paid off our
technical debt we end up drowning in
tech debt make sense so that's sort of
think cleaning those flags up would be a
macro refactoring because odds are
you're using those flags in multiple
code files so when you remove a flag
you've got to change here here here here
and here and you go to do some retesting
fair enough all right on to the next
part prevention instead of a cure all
right so let's see if you've had this
conversation manager don't listen it's
really important we get this new rule
labeled ASAP like really important
because it's just like a new condition
in the code it's a new flag right I've
got customers ringing me up asking for
this thing to be turned on and an able
door do this and it's just like you know
I'm getting caught all the time can we
just put something in there for them
it'll be quick
just fix it up we can do it later just
get it in there get it in production
we'll fix it up later I promise anyone
had that conversation or something like
that yeah and then of course our
response as the dev team is sure you pay
my salary sure you can have whatever you
want
I don't wanna upset the boss and what
happens Hey
so that promise does that ever get
fulfilled or this one dev one says can
you review my poor request dev two guys
sure yeah no problem
15 minutes 20 minutes later have you
merged it yet oh wait sorry oh I forgot
yeah give me a sec and I open up the
pool request and they see 48 vials like
really again this is too hard I'm like I
don't have time for this crap merge and
we're done yeah you're fixed move on
inside I'm swearing at them outside I
know we're nice we're friends I hate you
but we're friends anyone done this okay
who's been dead one night all right
um so he's the thing that just
introduced a whole bunch of technical
debt we gave em bad code we gave
ourselves the opportunity to let that
get in there and who's at fault
the manager no dev one no who is it I'm
helping you out by pointing at you all
of us we're all at fault here it's our
problem bad code only exists because of
you guys well not just you guys it's
also the guys next door the guys
upstairs the guys who don't get to come
to NDC that's all their fault as well
we're all in this together hand in hand
and singing songs
the first step though to fixing all this
is to admit we are the problem not that
we have a problem we are the problem
it's our problem so what we really need
to think about is why why did we
actually let this happen in the first
place so you might think it's laziness
anyone human error
sure human error happens in experience
and and skills gaps those occur I get
that they're legitimate reasons and we
can't prevent that other than having
team members around us to pick it up
pick us up on it when it's a problem
however mostly it's this mostly that
that conversation with the boss was a
pressure situation they put pressure on
us and we didn't respond the right way
or another team member put pressure on
us to get something done there was an
implicit time pressure by saying I
didn't you do that already and so again
we responded by going yeah okay sure
just get it done get you off my back
that pressure that we face can be
external like those situations but it
can often be internal as well we want to
do a good job so again those of you
doing agile you do sprint planning I
assume or something like that unless
you're doing the cowboy a gel where you
just kind of write bugs and hope it
works later internal pressure is you
know we set an expectation we could do
it in this amount of time we can do that
sure I can do that I know it's something
it'll take me four hours to do that you
get to three hours and 30 minutes you're
going I have no idea what I'm doing
I don't know clue what I'm doing here I
don't want to ask for help because
that's embarrassing so I start rushing I
start copy and pasting from Stack
Overflow I find somewhere else in the
code base that looks similar I copy that
across and I drop it in and I don't
bother naming things probably because I
want to make sure I try and get it as
close to four hours as possible so I
look that I'm like I'm awesome what am i
doing seriously what am i doing Who am I
helping I'm not helping the team I'm not
writing good code I'm not gonna be
maintaining it well I'm actually going
to reduce our velocity in the long run
because I'm I'm taking shortcuts now all
I'm doing is just adding technical debt
and bad code for no reason
whatsoever other than my own ego we are
the problem each and every one of us so
what we really need to do is not just
refactor our code we need to refactor
ourselves we need to think about how we
do things and improve from there so step
one you're all adults you all put your
pants on in the morning most of you
probably did both you know right leg and
left leg you didn't put both legs in the
same side be professional you don't need
permission to do your job properly you
don't often we do know are we should get
permission to see if we can write unit
tests hello just the damn unit test is
part of development it's part of being a
professional and doing the job properly
I need to ask permission if I can go and
refactor that little bit of code there
just do it
don't worry about it get it done things
like definition have done have those and
stick to them be disciplined or as Henry
Newberg who worked with Spotify as an
agile coach for a long time says just
stop it now he's saying it a lot rougher
than I just did his delivery is usually
a bit firmer they just stop it versus
just stop it I'll get in your face and
headbutt you afterwards
not that Henrik does that by the way if
you're listening but just stop it right
no more excuses don't make excuses do
your job it's ok it's what we paid for
so one of the fundamental principles of
agile development
this is Henrik again is this idea of
sustainable pace if you're consistently
creating bad code what happens to your
velocity it's going south does that mean
you're working in a sustainable pace no
we often think sustainable pace means I
do my 8 hours a day right because I want
to stay fresh each day and want to stay
awake and alert yes that's a part of it
but if in those eight hours I write a
whole lot of crap that's not sustainable
ok and it makes no sense it's not agile
you're just gonna kill yourself in the
long run and you're going to tie
yourself into a corner
right back to where we were with that
technical debt metaphor would mention
right at the start in fact if you don't
do anything no changes
your progress will tank however to make
changes and improve it takes us longer
now we need to be more realistic over
what we can achieve so that green line
there hopefully that comes across on the
projector okay for you but if we change
and we start doing things properly
yes we're going to go slower in the
short-term but the area under the under
the line for the Green Line is much
higher in the long run than the red line
so yes your manager might be upset with
you that your velocity used to be 30 and
now you're doing 20 what the hell is
wrong with you guys we're doing things
properly now sir I don't want you to do
things properly keep your velocity up
you see the problem how do we respond to
that pressure again most of us will go
okay we'll stop doing unit tests or
we'll just copy and paste again all
right
team culture support each other right so
listen for the excuses here's an excuse
it was easier to add the extra code to
this method than adding a new method
trigger word uh-huh and it was quicker
to add the method to this class there
and creating a new class because I ain't
got time for that sunshine again trigger
word so you're listening for easy for
quick for I didn't have time excuse
excuse excuse excuse verses I'm a
professional we do things properly it
will take a little longer but the net
result will be better okay now there are
some practical things let's think
obviously automate everything see ICD
pipelines make sure the test that you do
have by repeatable and quick if you've
got a whole bunch of tests that take
four hours to run and break all the time
anyone who's got a test run by the way
whether it takes a long time and it's
always broken always occasionally
without changing anything if you rerun
the test that passes anyone yeah okay
not enough hands obviously you guys
aren't testing this is really common I
actually know places where their tests
are always red but they deploy anyway
because they look at the number of
failed tests and go that's within
tolerance
yeah editor configs anyone seen this
this is in Visual Studio for the dotnet
guys but there's also editor confit
works across all sorts of browsers so
you can take away the tabs versus spaces
argument anyone had this anyone's still
having it yeah and there's all sorts of
conventions so you automate your
conventions as a team you take away the
argument you save time as a team improve
your test design which means obviously
start by writing tests yeah and avoid
those those implementation specific ones
tests that know all about the internals
of a method and don't actually check the
behavior because those are the ones that
are going to break every time you change
anything so you want to avoid that then
these things like code reviews he likes
code reviews yeah Wow he's my approach
what's the value you get from them
because here's what normally happens in
a team you'll see when there's a code
review pull requests all sorts of stuff
people generally think it's a waste of
time they have negative attitudes
towards them the large reviews as we
mentioned before get glossed over and
all the risk that's in there gets put in
where we tend to focus on the small ones
with a lot of attention to detail it's
bizarre like this inverse effect
reviewers themselves generally lack the
context or the knowledge of what the
change is so they end up looking at
stuff on screening on yeah ok I can see
what happened don't if that makes sense
or not I don't know if we've just
implemented the wrong thing correctly
don't know any of that but we'll check
it in anyway because it looks ok thumbs
up or we're inconsistent within the team
or personal preferences vs. team
standards kick in and we end up arguing
over tabs versus spaces or temp 1 versus
temp 42 the bad devs in your team choose
the friendly reviewers to look at their
stuff so it can get in you know it
happens all these assumptions like the
reviewers gonna check my work so I'll
throw it over the fence to them because
I know that they're generally good at
picking stuff up and I don't have to or
your the review and you go they're
generally right decent code so I won't
pay as much attention to it
yeah again alright now that said doesn't
mean the ideas wrong maybe it's just
their execution so thinking about how do
we do peer code reviews better well
let's stop let's instead just bear with
me try this thing called peer
refactoring everybody go what the hell
are you talking about Richard okay so
the idea here is that I write some code
that works in mature code that works and
I open that up for a pull request I make
my own you know I have my branch I push
it say please do this stuff review my
code but instead of reviewing the code
the reviewer has to refactor it instead
improve the design of existing working
code so they then pulled down my code
onto my look onto their local machine
they review that they do the refactoring
they push it back up I then look at
their stuff see if it makes sense to me
we rinse and repeat until we're good and
then we check it in your response should
be that right this doesn't make sense
surely what a stupid idea get off the
stage but think about it for a second if
you're going to refactor code you need
to understand it first right before you
refactor it you can't just read the diff
log on the screen who does that by the
way honestly honestly keep going there's
more I do it on small ones on big ones I
don't even look you can't just hit merge
and go you've got to actually run it and
check it you have to compile it you have
to make sure the code works on your
machine not just on their machine so you
you're ensuring some of these things are
in play it also means you have to
understand the reason behind the changes
so now we have two people in the team at
a minimum who understand what a piece of
code does so we avoid the knowledge
silos there's a whole lot of benefits to
this kind of cool I think but you know
I'm standing up front I can say that you
can in your heads be going nuts but it
is still a slow process so how do we
eliminate the waste well
let's not do the write the code send it
to someone else and bring it back let's
do it side by side what's that called
oh yeah all right so who likes pair
programming he's how it works one person
codes the other sleeps or two people
fight over who's the smartest uh-huh or
one person codes in silence the other
person is watching their I I don't know
what you're doing but on to I don't want
to interrupt because you look like
you're in the zone or an expert pays
with the novice and makes them feel like
a foe your life if you can't read it
down the book that's not good that's not
good pair programming that's just
embarrassing because you're basically
doing it wrong it's like trying to use
the spoon and holding the big round in
and eating with the guy named Al and
Falcon has this approach called strong
style pairing which is much more akin to
what we want the idea here is that if
you want to get that's his description
I'll just skip over it but the idea here
is that to get code to the screen it has
to go through someone else's hands if
I'm the developer I'm not touching the
keyboard so I'm navigating and asking
someone else to write the code so at a
full loop here called the variable this
whatever else when they want to make
some changes they give me the keyboard
and I do it so we're directing each
other the advantage of this is that we
are both engaged in what's happening I
can have different skill sets without a
problem at all I can have a dev working
with the tester and it's not a problem
and again two people understand the code
we can refactor and talk about as we go
which means there's no more passive
balsamiq partners you don't have anyone
having the opportunity to fall asleep we
deal with that uneven skill issue when
we get rid of the need to do these long
run Ditko long winded code review
processes because two people have
already looked at the code and come up
with an approach reduces our technical
debt and bad code and gives us more
opportunities to spot savings so anyone
worked anyone done pairing by the way
it's surprisingly rare even today but
you often find that if you're pairing
with someone you're watching them work
even if it's ad-hoc anyone a Mouser
you know if they want to hit debug so
they grab the mouse and they drag it
ever so slowly up to the top of the
screen and they click the play button
and the application starts and then to
go to the neck it's a breakpoint they do
the step they have to switch and they go
up to the step button and click it and
then click it drives me nuts and I will
actually grab people's hand and stop it
get off the mouse because it takes time
right I get I get frustrated just move
along and that's part of those 2 second
savings right they add up but there's
other things you can do so a guy named
Woody's all went crazy with the idea and
came up with this a protocol mob
programming who's heard of this ok mob
programming goes way over the top says
don't do pair programming no no no
there's not enough people involved get
the whole team doing it one keyboard one
screen the whole team as a group now the
interesting thing is this actually works
this works really well a lot of people
won't do it because they can't get to
pair program they're not gonna get to
this but the idea again is that person
with the keyboard is doing whatever the
others in the team are saying you rotate
the keyboard faster so people don't drop
out but again there's a navigator and
the rest of the team's talking about
stuff and working through it everyone
stays engaged and we share our knowledge
across the entire team now which again
means we don't need to do a code review
because everyone has seen the code now
we don't need to worry about refactoring
because everyone's seen the code who can
talk through things as they're writing
it
our team collaboration improves all
those sort of things and you might think
it's gonna be a slow down it's gonna
cause problems it's going to cost more
because the cost of software development
is how fast people type correct not it's
about what's up in our heads so
interestingly there's all sorts of
benefits that come out of this apart
from the shared knowledge and
understanding the team morale and so
forth but there's also those two second
savings again the shortcuts that help us
work through things quickly all the
boring stuff that
would manually do that takes time that
no one else notices and you don't even
notice becomes really apparent when
we're doing it as a team and everyone's
watching you fumble about with your
mouse so again doing this is an
interesting approach so if you want to
maximize the number of lines of code
typed out by keystroke and stuff and
this isn't the thing for you if you want
to maximize the value and the collective
brainpower of your team and get them
working well together
consider it I'm not going to prescribe
this these are options to help refactor
ourselves the idea really should be you
experiment with these approaches find
out what works with your team and try
and make that a part of your everyday
because that will help prevent problems
in the first place remember prevention
is better than a cure so transparency
helps us eliminate TechNet and bad code
the more eyes over it the better this is
kind of that Cathedral and bizarre thing
with storming and open source if you
aware of some of that as well the more
eyes on it the better the code is should
be there are other prevention techniques
of course you know limit your work in
progress
anyone doing Cambrian approaches yeah
okay so again limit your work in
progress right because helps us isolate
our thinking to one task at a time if we
spread out thinking we have context
switches context switches cost time also
means that we're not as in tune in what
we're doing we were more likely to make
mistakes
bad code ticket surely branches that
should be obvious and no one was to do
the merge commit of a branch that's
lived three months premature
optimization avoid that get your code
that works make sure the code is stable
and in production and has been stable
for months before you come back and then
try and improve the performance of it
you probably don't need to but if you do
wait until it's stable don't optimize
something is still working watch out for
temptation resist temptation so you know
what I mean by this new framework comes
out your package we need to reverse a
string or we should go to new get and
find a string reversal package
or our new frameworks come out that
someone has that that helps us do
something that we could have done
ourselves in two seconds so quick we're
writing a hello world application
install an ioc container again why
resist the temptation out until it's
needed or the I read a blog post I learn
a new coding pattern so now everything
needs to be coded that way I need to
make all my code look like F sharp
because they're shops the best because
someone sent someone a blog post or
framework v2 is out that's ironic
um don't need core B do is out quick we
need to update everything rewrite
everything from scratch why because done
that once suddenly stopped working
obviously doesn't happen share what you
learn with your team
lift up the skills of everyone remember
one of the problems we'd take that is we
end up with rotting skills and we get we
aged far too quickly and become COBOL
programmers stay up to date share within
your team that's refactoring ourselves
stay on top of what's going on the fact
that you're here is a good thing you're
just got to make sure you take what you
learn here and bring it back to others
run hackathons hackathons are a great
way to scratch the technical itch
without doing it in production code do
those things I strongly encourage that
if you want to try some of these new
things do it but do it in the context of
a hackathon don't do it as part of
changing your day to day code that's not
the mission adhere to your definition of
done remembering that works on my
machine is not done that's you I'm sure
and it's the whole product not just what
you're working on and we are pretty much
there so remember technical debt is a
good thing done properly it's agile
you'd relieved incremental development
that's what we're after bad code on the
other hand never is so reduce your bad
code and your technical debt through
steady flow as small improvements it's
the best way to do it not sexy not
glamorous not exciting doesn't look
great on a resume but it does deliver
great value and prevent the bad code by
getting plenty of eyeballs looking at
the code transparency stay disciplined
be professional don't respond to
pressure Paul
as hard as that might be and definitely
don't respond to that by cutting corners
because that's going to be a problem
identify and eliminate your waste you'll
improve your productivity anyway and
that's pretty much it so thank you very
much and we're doing for time a couple
of minutes to go so questions for anyone
for preferably for me but you know if
you want to ask someone next to your
question that's okay
thoughts questions avoid the rewrite yep
sure the okay so clay valid business
reasons are why don't rewrite just
because it's difficult to work with
anymore if that makes sense so a rewrite
where say the technical stack that you
built that old thing on it was still vb6
for example and you can't find vb6
programmers anymore because they all
died or you know the basically the
skills down in the market no one wants
to work on that anymore that's a
legitimate business reason to look at
potentially doing a rewrite however it's
not a rewrite it's not a port or
anything like that what you're really
doing is saying if I'm going from vb6
there's something else I'm actually very
platforming and going to something
completely different so going from the
desktop to the web means I don't take my
desktop paradigm and try and apply to
the web which is what happened a lot
with those old vb6 desktop programs and
they just didn't work and then people
didn't have the skills there or anything
like that so they end up creating all
sorts of other problems so if you're
going to do that re-platforming and a
porting exercises effectively they start
a new project with a completely
different skill set so you need to make
sure that you pick a skill set that the
team understands that you're not also
learning skills at the same time because
then there's just too much risk involved
you know if you're gonna do a rebuild or
basically a new product from scratch
with skills you've never used before on
a team that doesn't have a lot of
experience what's your outcome going to
be
so work within the skills you've got do
the read platforming that's fine
questions other questions alright if not
I will be around all week enjoy the veal
all that sort of stuff thank you very
much for coming
enjoy the rest in DC</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>