<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Beyond step-by step debugging in Visual Studio - Tess Ferrandez | Coder Coacher - Coaching Coders</title><meta content="Beyond step-by step debugging in Visual Studio - Tess Ferrandez - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Beyond step-by step debugging in Visual Studio - Tess Ferrandez</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BQE8HmD7-vk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello ok let's get started
my name is Tess I'm a developer and
we're going to talk about debugging
beyond stuff I started bugging so we're
going to talk about beyond stuff I
started bugging in Visual Studio and
dotnet debugging in general so much
beyond that we're not actually going to
do any step-by-step debugging at all so
some of you might know me from my role
my previous role as a support engineer
where I would troubleshoot other
people's crashes memory leaks and
performance issues essentially anything
that you couldn't step-by-step debug and
this is sort of the agenda for today
we're going to take a look at what you
do when you can't step-by-step debugging
kind of strategies for troubleshooting
these kind of issues
so if you can't step-by-step debug but
you have to resort to something else and
that's something else say sometimes
profiling we'll look at that but
sometimes it's also memory dumps how
many of you have used memory dos before
to debug things Wow awesome crowd so
we're going to talk about memory dumps
and those of you work with memory
diamonds know that a memory dump is
essentially a snapshot of a process and
all the memory that's through addresses
there's all the kernel mode dumps that
are snapshots of the entire system we're
not going to deal with that here because
we're just looking at one particular
dotnet process when we're doing
something but looking at a memory dump
is a little bit like looking at a crime
scene
so you take a picture and you can't move
forward because it's not a video
you can't move backwards because it's
also not a video but you can find a
whole lot of clues about who did the
crime and that's what I'm really really
interested in when it comes and that's
what intrigues me about debugging but
it's so easy with memory terms and such
to actually figure out who the culprit
is
so let's take a look at what this looks
like and we're going to start off and
one of my favorite tools
this is windbg you probably have this
knee or machine even if you never
thought you installed it because it
comes with the debugging tools for
Windows it comes with a windows drivers
kit it comes with a Windows development
kits essentially install windows
anything and it'll get windbg and lately
I've been doing a lot of you guys and
and one of the things I'm usually talk
about is a UI should be super
understandable which yeah this is not in
fact I don't know if I have internet but
this is kind of what it feels like to
just startling to you
so to make it use that a little bit more
understandable I'm going to go ahead and
copy some commands because in winter
baqi we use commands so we'll get to
visual studio later don't worry what we
just kind of need to figure out what it
is we're looking at so I copied a few
commands into something called a scratch
pad because when you're debugging window
bikini you might want to write down
things like the evidence that you're
looking at or the your Twitter handle
with your you're presenting something
and then we have the actual memory done
and the memory dump that we're looking
at here is the memory dump taking
another crosses this is a WPS classes
called the precedent it had an unhandled
exception with this funky number we'll
get battered up later and and then it
doesn't tell us too much more because
it's expecting us to do some PowerShell
e goodness and write some commands so
one thing you did it's really quick in
Windham achieves learning really weird
stuff like learning really weird
characters and stuff so we'll start off
with a command that looks like this and
I'm going to see if I can do this please
so up top you're going to see a
magnified version of we're looking at at
the bottom we're back to work where else
so we'll skip that can you see what's at
the bottom of the screen here yeah okay
so our first command is going to be
tilde which is Klingon for threads and
we're going to look at all these threads
and we're going to run the command case
the command K is stack when you're the
bugger you don't like to write a lot of
stuff so we're going to look at more
mostly one letter commands and very
short commands K is back it should have
been s but s was already taking per set
so this is one of the 28 two men sitting
on one in visual studio till the start
key and what you get then is a list of
stacks this should look fairly familiar
to you if you're used to visual studio
because they're actually typically the
type of stack that you would look at but
one thing that might be a bit
challenging to look at is the number of
threads that are actually in a very very
simple WCF process that's been going on
please two or three seconds so which
ones of all these 20 22 threads are
important experience will tell you which
ones but if you want a quick fix then
take a look at healthy process and
compare the threads and see if this was
in a healthy process and this was in a
sick process then maybe that's not
important
I'll you scroll up a bit and point out a
few threads so one of the more important
threads are is this finalizer thread so
there is one a lot of supporting actors
and they in this whole crime scene and
one of them is the finalizer thread
which essentially goes in and terminates
everything like Arnold Schwarzenegger so
what what it actually does is it calls
all your destructors if you have an
object it has a
thruster to to get rid of any native
items like a file handle or something
then that would go on this single thread
which means that if you block this then
you're screwed because you'll have a
memory leak because nothing else can get
finalized anymore but this was not
anything that was going on in this
process because we're looking at a crash
and and when you take a memory dub of a
crash what you'll have is like one
active thread and that active thread
will be the one that is actually the
culprit in this case so that active
thread will also be marked with a dot
again a one characters things that
explains everything so threat zero is
the one that costs the problem it was
throwing some kind of exception and then
underneath here there is a lot of weird
stuff that we can't really decipher this
didn't look like any of the threads that
we saw below that we could actually read
out the function names and everything
and this is because this is a dotnet
thread so this is a managed thread and a
window bit key is not a managed to
bugger
when did yeoman understands like C++ and
most such things will have to have an
interpreter and that interpreter is
called SOS so we're going to load up SOS
and this command what it does is it will
load up SOS a dll an expansion to help
us translate and it loads it does from
the same directory where CLR de Cielo is
located which if we look is going to be
in the framework directory so I'm just
pointing this out because this means
that if you have the framework for your
machine you also have a Swiss and since
you have window key and you have SLS
you're pretty much all set for this now
we're going to run a few commands in NFS
to to give some more information and
figure out which ones we're going to run
bang help bang in this case is Microsoft
short for exclamation point because
exclamation point is very long
so we run that and we're going to find
out or what you can do with SS among
other things you can do things like run
bang threats and this will show you and
the managed threats or the darknet
threats in the process so it will show
you a few things like the finalizar
again recurring character and then the
fact that the first thread thread 0 here
was hitting an argument out of range
exception so with this information and
kind of know what we're looking for but
we would like to look at this fact just
like it looks in visual studio so we're
going to run another command called CLR
stack and that's going to give us a
stack that is very very familiar to us
if we were no visual studios so we have
some Next button onclick that calls into
a go to another function and that in
turn goes in and throws an argument out
of range at this point we can just look
at the code and figure out what what's
going on here and we're kind of done in
windbg so to speak but I just want to
show a few more commands that we can one
here one of them being dump stack
objects or again since the buggers are
lazy DSO and this will show us pretty
much the same thing that you would see
in Visual Studio if you were looking at
the locals window so we can see our
argument arrange exception in fact we
can see seven different times anyone
know why it wasn't because it was thrown
seven different times it's in fact the
exact same system argument out of range
exception they all have the same address
but windbg doesn't do the fancy stuff
about putting like figuring out that
this was already shown once before it
was it's showing us multiple frames and
therefore it's showing up multiple times
here so that's the thing so I'm going to
click on this and what this will do is
it will dump out the argument data range
exception and now I can go in and do
things that I would normally do a
Mitchell studio like and I look at the
message for example find out the
imbeciles out of range yada yada and
that gives us just a little bit more
information about what's going on so
that is all stuff that you could do the
individual studio and that's kind of not
all that exciting what is very exciting
though is that something you probably
haven't done a visual studio is looked
at all the objects that your processes
and that your process can access or that
you process s created so I'm going to
run a command called a heap
- GC and we don't act like so if you if
you want to C++ app then what you do is
you do a new and you get some random
piece of memory from the operating
system and then you do another new and
you get another random piece of memory
from the operating system but there's no
central location where you can actually
find that all of these pieces of memory
so you have to keep track of them and
you have to delete them and you know all
that stuff and that's why we do why we
use stuff net because does not have
memory management as a service through
the garbage collector so the garbage
collector keeps track of everything that
you allocate and it keeps track of it in
segments in this case we can even know
that we have allocated this much like 70
what what is it seven Meg's of dotnet
objects and if we look at these heaps
now we're getting kind of deep into the
internals of dotnet but it's kind of
important to figure out how we can
actually get here so don't peep and I'm
going to step out one of these segments
that is an extraordinarily bad segment
to dump out why
okay if you don't write from one
location to the same location that will
kind of
I'll show you which so dumpy sad to hear
and what we see here is how memory is
laid out in dotnet so I think this is
extremely interesting because the fact
that dotnet lays out our bits one after
another means that we can enumerate all
the objects in the heap so we can take a
look and find out every single object
that you have ever allocated well that
is still not garbage collected we're
going to take a look at it we're going
to take a look at the data and
everything like that and the magic
happens not only in that it's laid out
one after another but it happens because
if we go up and look at this argument at
a range exception dotnet objects have
are sort of like self explained they
have a method table that tells you what
methods they have they have an e class
that's kind of like the blueprint that
says you know at offset singing I'm
going to have an exception method string
and adopted one C I'm going to have the
help URL and so on and so forth so it
tells you how the object looks and it
also tells you how much memory it uses
so what this means now is that we can go
in and do this we can go in and say
dumpy fat and we can find every single
object in the heap this is a little bit
scaring sometimes if you're storing my
passwords or stuff and clear text and
some variables because if I create a dub
of your process and I look at all the
thread or I look at all the the strings
let me go ahead and do that I'm going to
go ahead and do dump heap - type system
dot string and I'm going to say give me
the ones over 500 by vechs a decimal and
it's going to pop out like all the
strings that match that criteria and I
can go in then and look at them and see
oh this was what's in that string maybe
that was your password
so just be aware of that because the
fact that I took it memory dump of this
process doesn't necessarily mean that I
have to own this process and own all the
code for it and anything I can do this
in any process I can also do some other
things in here I can figure out why this
object is still around so I'm going to
do GC root which we'll go through and
figure out how come this object is not
garbage collected
well it wasn't garbage collected because
this string is a member of variable and
some section XML inflow this member
variable and some section input and yada
yada yada all the way up to some client
configuration section some battles
pinned and therefore it will not be
garbage collected because if you tell it
the dialect I don't want this garbage
collected it won't be garbage collected
and finally while we're here in the
memory down let's go ahead and run a
command called LM which means list
modules now we're getting up to two
character Hemmings and this will list
all the DLLs and all the x's well the
one you see in your process so you can
go ahead and dump out things like the
version of this if you took the memory
dials maybe a process that was crashing
at a customer's machine you want to
figure out do they have the hostage do
they not this is the place to do that
and this is also your place to go ahead
and dump out the code for for this and
do some aisle spy on it so that is the
magic of dumps you can get to anything
that's in the process and because stuff
that works as it is you can enumerate
every single object in the classes so
let's go back and have a look at where
we are so we can see the threads called
stack stack objects modules dotnet heap
and that's all cool but when you when
you create or sorry when you
troubleshoot a memory issue or craft or
something like that it's important to
get the memory dump after why time
so we'll take us a few minutes to look
at how you collect a memory Dom so there
are a couple of tools to do this
and the one the simplest one I would say
is just right-click in the task manager
and choose create some awesome if you
want to take a memory job of a process
that's running now and you want it in
the state that it is right now if you're
looking at a hang or if you're looking
at a memory leak that's awesome one
caveat to do is it has to be a 64-bit
process because it's going to take a
64-bit memory dump and it's awfully hard
to troubleshoot a 64-bit dump of a
32-bit process if you want to get a
memory dump of a certain situation like
for example a crash you have to go a
little bit more specialized and you can
download something like custom proc down
is a tool that comes with this internals
and the cool thing about it is that you
can download it on one machine and then
you can copy it over to another machine
and use it so you don't have to install
it in a different machine which is often
an issue for example on the server or
whatever and the other thing that's cool
about it is that you can write a few
command line parameters and you can say
for example you take a memory dump when
it's crashing that's - E or - C for a
CPU has been over a certain amount for a
certain number in a certain time or - H
for if a window has been hanging more
than five seconds and sometimes you want
to go even a little bit deeper then you
can use a tool like debug diox the debug
guide you just downloaded from will
search for debug ID and what it has it
has rules that you can set up for all
iose processes for example and for
specific situations like I want to get a
memory dump every time I get a file not
found exception you can do that even
though it's not kind of crashing the
process you can get a memory dump of it
and then you would go in and analyze
them and we've seen windbg so you can of
course do it there and you can use debug
diag to analyze the memory dumps as well
so if you do that what you will get more
than windbg is debug diag is a tool that
will run scripts for you so when I
worked in support and one of the reasons
I left support was because I felt like I
had the bug that in any issue there was
like there all looked pretty much the
same and they all went through the same
steps of looking at the stack looking at
the exceptions yada yada yada so we try
to automate this and put this in a tool
so that you didn't have to remember like
the Klingon word for threats and what
you do then is you run it through this
through this tool it will run all the
commands and it will create a report for
you that nicely tells you exactly what's
going on in 80% of the cases and then in
the other ones you will have to use
windbg or something else and you can
also use Visual Studio and so we'll have
a look at that because it's super super
we need to debug memory dumps in Visual
Studio actually but we'll start off and
we're going to look at crashes
performance issues in memory what sorry
we're going to look at crashes
performance issues and memory leaks so
we'll start off with crashes and a crash
typically manifests itself like this my
mom calling him just that internet
singing it's not working anymore I'm
gonna like okay it's good mom what did
you do I didn't do anything okay so she
did not do anything then who did there
are a couple of things that can cause
a.net crash and we've already seen one
which is an unhandled exceptions the
exceptions go from first chance where
you still have a chance to handle them
to second chance where you're screwed
and that's what we what we ended up with
here so that's one thing but then there
are some special exceptions that will
only good first chance
so stack overflows out of memory
exceptions and execution engine
exceptions they will only good first
chance because once you have a stack
overflow exception how do you handle it
by putting an exception handler a little
bit further up on that stack but you're
already overflowed not possible so
that's why that won't work as a memory
exception the same thing in the exact
same thing and the execution engine
exception is usually a bug and dotnet
framework somewhere so in that case the
garbage collector is is messed up and
you can't do anything and then you'll
also often see if you grab a memory dump
when the pasta succeeds but in mine
maybe not have been a class necessarily
it could also be someone is killing or
recycling the process so that's the
further common one too and when you
troubleshoot these issues is go through
a couple of simple steps so the first
one is always check the event viewer it
will give you a lot of juicy information
and then capture a dump when the process
is crashing so reproduce the issue
somehow
and setup Proctor we're setup debug die
to capture the dumpling is crashing and
then look at the one thread well you can
look at all of them if you want to but
you only have to look basically at the
one thread that's triggering the dump
because that's going to be the one this
question so we saw that already and when
we looked at winter the key but we'll go
ahead and try one out so I have this
precedents out we've seen that before
and what's going to happen here is that
please go to mr. Clinton and then I
click Next Next okay yeah we all kind of
knew that what happens so what happened
there
let's go and debug that for a second so
I'm going to go ahead and do cross dump
- MA this is mini dump with all options
it's actually a fool done but what it'll
cost a mini dump with all options so and
then we say one debug the press who then
start exe and we want to say - e because
we're going to wait for an exception to
happen and now I have to start this
process to have something to attach to
because this is going to attach it's
going to not attach as much as for
example Visual Studio is going to be low
level attaching but it's now going to
sit there and monitor and whenever it
made X plates is going to crash and it's
going to create a memory dump so let's
do that again okay that was pretty quick
so now well I've done this a couple of
times practicing and we get a memory
dump from this so we already saw
troubleshoot this in a window between so
I thought I'll now go in and do the same
thing but in debug diox
so in debug diag what you do is you
choose one of the rules and we know it
crashed so we're going to use a rule
it's called a crash hang analysis I
apologize if you can't see this because
it's too small but it says crash hang
analysis there and then I'm going to go
in and I'm going to pick the memory dump
why can you pick this one they're all
the same and and I'm going to start the
analysis so now it's going through the
exact same steps looking at like old
stocks looking at previous exceptions
yada yada what what was going on on the
thread that's cost the issue and it
gives us this report that says on thread
0 there was a CLR exception it was a
system an argument at a range exception
and this was the issue and if I go in
and look it will also give me the proper
stack for what went on in fact if I go
through this report it will also give me
some other things like I don't know the
more about the exception is going to
give it previous exception information
not less stuff but at this point would
pretty much know what's going on is from
clicking on that one
crash hang analysis isn't that fantastic
a little bit right I did this so that is
if you don't want to get into to visual
studio or sorry if you don't want to get
into window booty but there is actually
one more step we can take and that's
using visual studio and it's the bugging
features so I'm going to go ahead and do
file open file and I'm going to pick
that same memory dump and it now gives
me the option to do a few things so let
me see if I can actually get that
magnifier working okay so you see where
I'm pointing right so now it tells us
that like we knew that this was this
weird exception by the way if you're
really into ASCII tables you could
decipher this and
4343 5-2 stands for CCR that's comm
called the rapper and that's the dotnet
exception from four oh and forward into
oh it was the ask characters for calm so
well everyone was saying we're going to
get rid of calm and do this new thing
called dotnet there are some
infiltrators but we're still kind of
like in common these the product teams
at least the ones that came up with the
exception numbers we're going to go
ahead and do debug we'd managed only we
have a few options debug would make
specifically we'll also want to go in
and look at native stuff and it's been
I'm going to go in and probably shoot to
dumb and show us what cost the exception
and put it as the actual line of code
that cost the exceptions that is awesome
that stuff that you get though if you
have coal if you have the code on your
machine and you know you ran a debug
version isn't and stuff like that you
would still get things like the call
stack and things in Visual Studio and
you would be in a familiar environment
but the code will take you exactly to
the source so don't dismiss jump
debugging and Visual Studio or a theory
on window Vicki okay that was crashes
and oh yeah we we should look at the
Event Viewer because I say always check
the Event Viewer and let's have a look
at what that looks like
so windows logs applications and this
was the exception and I'm going to put
it up so grow up so if we would have
bothered looking at the Event Viewer who
wouldn't be here at all because we
didn't have to debug it all because we
had the call stack we had the exception
everything but that's no fun so let's
not look at the Event Viewer and capture
a dump on the clash and look at the
folding stock and all that stuff okay so
now we know everything we need to know
about crashes let's move on to
performance issues performance issues
come in a couple of different forms like
the app is not responding requests take
too long by the way if a request takes
too long
make sure you understand how long it
should take because otherwise you might
end up is optimize saying forever and
then they might also come in the form of
the CPU going haywire and again who did
it well they're two different types of
of hangs or performance issues there's
the low CPU and there's a high CPU the
low CPU is pretty evident we're not
doing anything we're being a siliceous
the debuggers that are going to debug
this problem so Greece waiting for
someone else to do something we're
waiting on a deadlock and high CPU
issues we'll look at busy threads doing
a lot of computations or stuff like that
or more commonly doing a lot of garbage
collection and one way that you can get
yourself into a high CPU and garbage
collection situation is by creating a
lot of large objects because the garbage
collector will do full garbage
collection every time and you allocate a
large object and one way to allocate a
lot of large objects this is like tips
and tricks if you want to have
Foreman's issues its to go ahead and
concatenate strings in a loop because
strings are immutable so if you just add
one character to a string allowed to
create totally new strings and if you
look back to what we looked at that is
pretty evident because everything was
fact right after another right
we saw the addresses there was used like
a tiny little bit of free space in
between them we couldn't necessarily
expand the strings like ad infinitum so
yeah don't don't come Cadenet strings in
the loop and when you troubleshoot it
you're going to go through three steps
again so it's going to be like the three
miracle steps to troubleshoot anything
so determine if it's a high or a low CPU
issue more for yourself because then
you'll know what you're looking for and
then capture one or more dumps it might
be good to capture a couple of dumps to
see sort of like did this thread
progress at all am I still waiting for
the exact same thing that I was waiting
for is the moment ago or did I go to
something new and then in this case look
at all the facts because we don't
necessarily have a single culprit but
cause an exception the trigger to dump
we're going to use take a snapshot like
a picture that wasn't necessarily
triggered so and by the way if you can
go ahead and performance profile well
let's have a look at how this looks okay
let's get rid of him
and also my TweetDeck we're going to
look at this HP night NBC application it
doesn't necessarily matter what it is
but in this case we have an issue
whatever situation the word we have a
page that is taking a little bit too
long at times so what I'm going to do is
I'm going to go ahead and use a tool
called nestling nothing is you something
I found on github that will send a
random of not random they're going to
send requests to the server one after
another essentially so I'm going to go
ahead and stress this using neckline by
saying go ahead and pull up that page
use eight threads and that and do that
for 10 seconds and we're going to see
what happens so I'll go ahead and remove
the Event Viewer
it does not want to die so I'm going to
look at task manager instead and go okay
so we are going to want to look at W 3 w
P which is the IAS process and we're
going to specifically want to look at
this column because this column is going
to tell us how much CPU we're using and
let's run this and we'll look and if
this a high CPU or a low CPU hang kind
of low CP so let's go ahead and do that
least one more time and this time we're
going to actually get a memory dump up
the process so we're going to do create
dump file and wait and there was the
memory dumb ok so now we're getting
ready to debug this and
I already prepared because I'm a good -
so we have a memory done both taken at
the same exact same place here so what
we wanted to do was we wanted to look at
all these all the facts so we're going
to run til the star II is execute if you
have an extension and bang see at our
stack which was dumped out all they
managed threads and then we're going to
use our matrix size to kind of look okay
so what is happening here or we could
you slow down and see that this thread
for example is going to products then
calling in to get all products ISM data
service and then sitting in a wait and
if we scroll past this by the way if
you're debugging a lot you actually get
good as looking at things while they're
scrolling really fast because you also
did I mention lacy like you don't
actually want to go through and look at
all these threads so all of them
actually happen to sit in the exact same
locations and then we would go in and
look at the code and what was going on
well someone did something stupid
probably trying to get this thing to
hang but it's now time to look at the
code so other ways we could do this is
now go in for example would be bug dog
and choose again a crash hang analysis
because this time is to hang remove the
old data file and choose this one
instead and start the analysis and this
is now going to go through and do some
like it's going to look at all the
stacks and look for common issues that
it's things could be causing performance
issues like excessive weights for like
excessive waste for example and it's
going to say okay so you have eight
threads waiting in a monitor weight and
this is kind of useful because it was
eight threads and I could have locked
looked through them and I could have
examined them and seeing that it was
thing but this thing will do that for me
and again I mentioned Lacey yes so this
will help me out kind of figuring that
out without having to do the work and
I'll go in and I look at this and it's
going to tell me first off that all of
these are the same like it groups them
together as being the same and then it
also shows me that this was the stack on
that thread so again we're back to
looking at the proper code let's go
ahead and use for fun also do this in
the visual studio so I'll close the old
memory dump and I'm going to go ahead
and and open up see open up file in this
case I'll actually pick the one that we
just captured and I'll debug would
managed only again but something went
wrong what went wrong it takers and now
could have been a serger too big process
but this is actually a 64-bit process
because it was I asked but what what
this is going to show me is the active
thread and we don't have an active
threat here because we captured the dump
like a snapshot so we're going to have
to use another feature in the visual
studio
that's called debug windows parallel
stacks if you guys seen this some okay
this is something that you can use while
you step-by-step debug and this will
kind of give you that 10-foot view of
all your threads and not use the one
thread that you're normally on and what
this does is it kind of groups them
together in this case we actually only
have eight threads doing the exact same
thing because we're running eight
concurrent threads bang this product
controller but the funny thing here is
that if we
have the code we can actually go in and
click on it and get to the proper
location again right for me is Lisa's
Jesus so performance issues let's see it
high or low we thought it was a low CPU
did it matter for this case maybe not
but at least we know we're looking for
something that's waiting for something
else right we captured Dom we look at
all the stacks and then if you have
another type of issue you might want to
go into profiling instead like if you
have issues that you can't necessarily
go through and stress to the point where
you can get a memory down while it's
happening so before I do this I just
need to shut down a few things because
I'm keeping the symbols and in that case
this one works so let's go ahead and do
that one too it's going to stop this
debugger and say yes okay so what we're
going to do now is we're going to look
at the same app actually I did not write
this out I just wrote the the problems
with it and one of the problems I kind
of spaced in this one is if you look at
the picture of the the president you'll
notice that sometime it kind of sticks
like you have a situation where goes
through fine and then from time to time
it's it's stuck and obviously I can't
really reproduce this far enough to get
a memory dump so we'll have to do
profiling for this and I'm going to
start off with George Washington again
so actually let me go ahead and shut
that down all together so I'm going to
go ahead and open up the project and you
could do this without having the the
project but you would be limited in what
you could see so
in fact let me go ahead and do this so
you can see so what I'm going to do is
I'm going to go ahead and go to debug
and performance profiler I'm going to
open that up and in performance profiler
I can do a couple of things I can either
debug this and kind of start the process
and profile it or I could use something
like a nice peanut process that was
already running or another running app
or whatnot and then I have a couple of
options for things that I can do like
look at the application timeline for
exceptions and things like that or CPUs
it's your memory usage I'm going to go
through the performance wizard and I
already know because I know what the
problem is that this is going to be a
low CPU situation so we have two options
when we go ahead and do profiling and
one of the options is CPU sampling so
CPU sampling what it will do is it will
go in at certain times like every so
often and slice the stack and say who's
on top who's on top who's on top and it
will record that and figure out that
this problem like this function spent
this much time like this much CPU time
and then we have what we're going to use
the best use for high CPU issues but
we're going to use something called
instrumentation an instrumentation we'll
go in and put in markers at a call of
function and at the exit of a function
and it will record the proper elapsed
time for that method so that's what we
want to look at and I'm going to do next
next finish and then it's going to start
off the process and I'll go through and
clip my way through some issues and I'm
going to stop profiling
and then as if by magic instead of going
to tell me exactly where my problems
lies so in this case out of the total
time I spent I spent in the process I
actually spent 63.8 Christmas fifty
three point oh eight percent waiting for
something so in a and a task wait and
that was coming from a function called
get color which was in I don't have been
help them Illyria with a saml but this
is a converter that converted the party
denomination democratic-republican to a
color so it would look pretty because I
do you x2 and so on so here already we
can go in and look at a code and with
that we can see that most of our time
was actually spent in this weight this
weight is of course fictional but it
could be waiting for a database or it
could be waiting for another process or
an API or something
so profiling is awesome if you if you
can reproduce it in your machine and if
it's a small nothing that you don't want
to grab a memory dump okay and let's see
here and then the last one that's one
we're going to look at our memory leaks
so a memory leak will also have a couple
of ways that it can manifest itself and
one of them is out of memory exceptions
but you can also see things like slow
response times because suddenly the GC
is used using us way too much time and
or you can see something that is pretty
common that you see for example in task
manager or in person
that memory is just kind of growing
em and we want to investigate what's
happening there so what I'm going to
show you them let's get in look at why
this happens because we have a memory
management manager we kind of use dotnet
because it has a memory manager as a
service and because c-sharp is awesome
but we if we tell it if we don't tell it
to garbage collect or rather if we tell
it to not garbage collect it won't
garbage collect and a couple of ways to
tell something to not garbage collect is
by adding things to cache or session
stage or adding things to pinned or
static objects that will then hold on to
things or by blocking the finalizar
lesson sure ways to get a memory leak as
well and then we have some other memory
leaks that are a little bit more subtle
like assembly leaks so an assembly leak
will happen for some constructs for
example if you deserialize something it
might create a dynamic assembly or well
a number of regular expressions might
create dynamic assemblies and if you do
that enough and if you do that in in bad
ways by using the wrong configurations
and things you'll end up with assembly
leaks in that case you look at LM and
see you I got so many assemblies that I
don't recognize
okay so let's investigate that or you
could go in and do have a native leak
so if you use a con component but you
call and that has done new and then
delete anything that would cause an
issue to if you have memory dump again
the magic three-step classes will go
ahead and capture multiple dumps and the
reason why we capture multiple dumps is
we want to compare things we want to
compare how many artists do you have
here how many objects do you have there
because that's so much easier to compare
and see what you're leaving instead of
having to figure out is this odd should
I have like 10,000 strings is that
normal but if you see that
if you can compare and actually find out
what's leaking that's a lot more usable
and then we saw earlier in when the BG
that I would run for example GC root and
figure out why things were still around
and for native leaks you can use B back
to it has rules that you can set up so
it will put in markers when you do new
and when you do delete and when you
allocate a handle and things like that
so that you can figure out where did you
go wrong what did you what did you mess
up with so let's go ahead and do the
final investigation and with a memory
leak and I'll start off in Visual Studio
X or sorry in window beachie so we'll go
directly to dump heap stat because that
will tell us all the different objects
are on leap and I'm going to do a little
trick let's see prefer DML 0 you don't
have to worry about this but this is
just takes the performance bug in the
window BG I actually found myself
debugging windbg win with the B key
which yeah weird thing but then I
figured out these blue lines there are
kind of neat because you can click them
and they will do great things they can
also cause big performance issues if you
want to if you want to enumerate a lot
of different objects at the same time so
if you look at dumpy then and
troubleshoot a memory leak what you
would do then is you would go through
the object and say is anything here
looking kind of unusual and this is
where your trick with the multiple dumps
coming because then you have a chance to
compare them but I'm a seasoned pro so I
know that having for example 20,000 HTTP
requests is very unusual unless you have
20,000 current requests coming in so
because they should go away once they
are
once they're served the traduced be and
removed and you would look at things
like so there's a recurring number of
20,000 887 so the fact that I have so
many HTTP requests and HTTP responses
probably means that they are connected
somehow
and if I get rid of the age to P request
I'll probably get rid of the age to peer
responses too and then I'll go through
and I look at things like I don't know
what else is there there's some work
requests here I have something else
ticked
okay so I have 20,000 new controllers so
that's an object that I created that's
the one that actually handles the flash
news request and that's what's where -
but let's kind of explain so if I have
that many controllers that's why I have
that many and that many HTTP requests
and such so I'm going to go ahead and
dump out all of them and this is where
the whole preferred DML serie comes in
so don t don t empty empty cells for
method table this was what we saw
earlier and this kind of is what defines
the class so don't he dump out anything
that has that method table and we wait
we wait and then we go in here because
we're bored so go ahead and ask this one
to do memory analysis at the same time
so let's go ahead and grab that same
thing and start your and I'll see so
this is going to do now the same thing
it's going to enumerate all the objects
kind of figure out what it thinks I am
leaking this should be done in yeast
a little bit the bad thing about SOS is
that you can't actually cancel a command
in here so you can sit here all day and
do control C and it won't happen so
let's say I thought this was going to be
a little a little bit quicker so I'm
going to go ahead and actually start up
let's see if it was finished okay
so I'm going to start out the
investigation also in the visual studio
at the same time so in Visual Studio
I'll open up that same memory dome and I
had it at John dumb Adams okay so this
was one little sleeking and in this case
I'm not going to do debug would managed
not debug would mixed but I'm going to
do debug managed memory and what that
will do that and it will also go through
and enumerate all of the objects it will
also go through and enumerate all the
routes so it will kind of run GC route
if you will in the background and kind
of figure out why things are sticking
around so while that is running let's go
back to to this one because now it's
done and we can now pick any of them in
theory we should pick all 20,000 but
that's going to take a little longer
than we have so we're going to stick one
and say GC route to figure out why that
is sticking around and that now gives us
a similar route stack that we saw with
the with the string that we looked at
earlier difference here is that this
news controller item it's stuck in
something called a cache item removed
callback eventually if you look up here
it will be it will be in proper cache
but at this point we will then go ahead
and Google for cache item removed
callback or talk to whoever did
and use controller and figure out do you
know what this cache item removed
callback is and they would say yeah you
know what if I look at this code what
I'm doing is I'm going in and I'm
cashing a bunch of stuff with cache
stuff ad and at the end when whenever
the cache item is ready to be removed
I want to go ahead and call back this
method to clean up some other stuff so
that's the cache item removed callback
don't worry about like the details are
on cache item removed callback this is
one example of how you can sort of lose
memory and then okay so why why would
that cost the news controller to stick
around well if you are sitting there in
cash and say callback this function when
you're done which is like in five
minutes or whatever then this object has
to be around for you to be able to call
a method on it right and and that is why
we're leaking this if we would instead
have a static callback function we would
not have this leak we would not be here
you could go to a different session and
not have to worry about the memory leaks
at all but so that is how you
troubleshoot them let's go ahead and
look at what debug die I said and I'm
going to refresh this to get the blocked
content to show up
yes
okay so in in debug diag it does what we
did but it also does a few other things
it runs a couple of different commands
that if things are kind of useful for
you like figuring out you know how many
obvious are ready for finalization that
might be interesting to you also might
be interesting to you to figure out how
much memory you actually have in dotnet
memory we could get this from a heap FCC
but this does it automatically for you
without having to remember to do that
gives you a few examples a blog post
that you should look at that might have
to do with this a lot of them go to my
blog so if you ever want to go to my
blog you can use run debug tag and pick
any link in there and and then what it
will do is this will enumerate the heap
and then it will go in and say these
things look kind of strange okay so for
example we know that we're sometimes
leaked web UI or gigs so we're going to
mark those would read we know that
sometimes the existing data are because
this is based on your ristic information
from us debugging tons and tons and tons
of memory dumps and then purple is
basically your own objects and in here
it was kind of stick out and say you
might want to look at this news
controller because you have like this
many of them so that's what do you get
from debug tag but individual studio
let's see what happened there so in
Visual Studio will enter and load it up
to DOM and here I'm going to actually
use the baseline dump this was a memory
job I took at the beginning of the
process before the leak happened so now
it's going to numerate and obviously
it's much smaller so nothing okay
ignoring like this and have a look at
Bizness dead
because soon as I shut this down like
everything bill will be will go away so
if you have to memory dumps what you'll
get is the difference between them and
it will for example say you know between
these two you have leaked in this case
20,000 HTTP responses and it will
actually give you down here so let me go
ahead and Windows Plus this - it will
say okay most of these let's go ahead
and look at the news controllers instead
so most of these in fact 20,000 out of
the 20,000 or so objects are routed in a
cache item removed callback so this is
essentially going through and doing GC
root on all of those objects and giving
us the proper stats instead of us having
to go through and do that so Visual
Studio is doing some real magic when it
comes to memories of debugging
especially for memory leaks this
particular feature is something that you
could use if you were f10 debugging too
so if you get to a point where you see
okay so between like I'm going to stop
here with on a breakpoint then you can
go in into diagnostic tool kit take a
snapshot and then move on take another
snapshot compare them and get this view
and figuring out figure out why
something is sticking around okay so we
saw how we did that and then I just want
to end off so now you have basically all
the tools that you ever need to do these
crime scene investigations now I want to
end off with a slide on I need some
resources that you might want to look at
if you want to go further and debug so
debug dies obviously if you want to
download that if you want to look at
these slides I have them a
slideshare.net
and if you want to try this for yourself
all the demos that you've seen today
you have them under debugging demos on
on my github account so with that thank
you very much it's been awesome having
you and I don't think they have any
proper time for questions but if you
want you can come up I'll be here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>