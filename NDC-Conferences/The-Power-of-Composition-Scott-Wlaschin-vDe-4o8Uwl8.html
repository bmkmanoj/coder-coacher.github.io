<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Power of Composition - Scott Wlaschin | Coder Coacher - Coaching Coders</title><meta content="The Power of Composition - Scott Wlaschin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Power of Composition - Scott Wlaschin</b></h2><h5 class="post__date">2018-02-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vDe-4o8Uwl8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we're having a good morning it's a
lovely day here in London nice view so
if you if you find the talk to
look out the window it's a good name
right and so okay this is the power of
composition my name is Scott Aleutian I
have a website f-sharp for fun and
profit comm which is an f-sharp site as
you can guess do consulting with f-sharp
works if you need a sharp insulting so
this talk is for beginners in FP so if
you already know what a monad is you're
gonna find it kind of boring if you
don't know what a monad is and you're
very scared about monads and you're
freaked out by my nads then this is the
right place to be because I will
basically start from scratch I will
assume you know nothing about functional
programming and at the end it will get
kind of complicated but the point is
that I just want to introduce you to
some of the concepts and I don't expect
you to remember everything there's no
way you can remember everything but
hopefully just demystify stuff so that
when you see it next time it's like no
it's rather than thinking of it scary to
the elk I remember that is it's not not
as as weird as I thought it was and I
can actually make an effort to
understand it so I'll be using F sharp
examples but this is really a conceptual
talk things about concepts so you can do
this in pretty much any programming
language except maybe COBOL or something
but you can certainly do it in c-sharp
and Java and JavaScript and so on so
here's the overview of the talk we'll
start off by talking about the
philosophy of composition and what does
it even mean to do composition
composition is something that when I
first got into functional programming
people talked about it all the time and
I never quite knew what they meant I
thought I knew what they meant and I
think well why is such a big deal and so
that's really I thought I did this talk
really to explain to myself when I was
learning why is composition such a big
deal otherwise it's such an important
concept in a wider function of
programmers go on and on and on about it
all the time and then I'll talk about
functional programming so this is just
the basic stuff about what functional
programming is from a kind of completely
non-technical point of view which is
basically functions and how to compose
them and types and how to compose them
and it's just typed functional
programming so this is F sharp a camel a
score it's not closure or JavaScript but
the concepts are very similar then we'll
talk about composition in practice I'm
going to go through a bunch of examples
and each one's going to demonstrate
something about composition so we'll do
some simple examples first and then
we'll do fizzbuzz carbonated fizzbuzz
which is a really complicated version of
this verse and I don't really recommend
you actually do this work this way but
that's just to demonstrate the
principles of course and they're not
doing a web service and we'll see how
these composition principles apply to
all of these things okay so the
prerequisites for this talk I'm assuming
you want to learn functional programming
and so I have some recommendations you
need to have a beginner's mind you need
to forget everything you know you need
to pretend you've never seen anything
stop before I think they will be really
helpful and in particularly you need to
forget everything you know but I'll go
into programming you need to forget
about loops you need to forget about
variables you need to forget about
objects if you try and bring your own
concepts into learning you'll you'll get
very frustrated say well how do I do
loop and how do I do an object how do I
do you know mutable variables like just
forget those things even exist and your
life will be a lot easier just start
from scratch so it's a little test for
you are you ready to learn functional
programming
okay now you must pass this test before
carrying on with this talk otherwise
you're gonna have to leave I'm afraid
okay here's the test what is a class
okay what is a method and what is a for
loop what's inheritance okay think about
these questions okay ready here's the
answers what does the class I don't know
that is the correct answer
what is the method no idea okay what is
a for loop I can't tell you what is
inheritance search me okay so those are
the correct answers to those questions
and just not here how did you do I hope
you got them all right if you didn't get
them all right you need to try again
okay come back and do it later all right
so let's talk about philosophy for a
second
here's the things you need to know in
order to understand composition first of
all you need have been a child at some
point I hope all of that applies to all
of you everyone was hoping it was a
child you have to play this Lego and
hopefully you have to play for those toy
trains or at least had a friend or a
boyfriend
and in fact that first thing you don't
need to have been a child at some point
because actually there are a lot of
adults who like playing with Lego too if
you google a fall you will find a lot of
adults who are really obsessed with Lego
add up add up friends of Lego everything
right so let's start with Lego hopefully
everyone knows about Lego this is a
great ad from the 70s
Lego philosophy Lego has a philosophy
and the philosophy is that all pieces
are designed to be connected that if you
connect any two pieces together you get
another piece another Lego piece that
you can connect to other pieces right
you can still connect them together once
you've connected two of them together
and the pieces are reusable in different
contexts so here's an example here some
pieces they're all designed to be
connected they all have the little dots
on right every single Lego piece has a
frame and when you start gluing them
together if you want to take the first
piece in the second piece in an igloo I
have another thing and I can keep adding
things to it I don't have to stop just
because I've connected to things I can
just keep adding and adding and adding
okay you don't need to create a special
adapter to connect two pieces of Lego
together you just connect them together
you don't have to like create a little
container to put them in alright you
just like stick them together straight
away very very easy it's why it's so
easy to play with Lego and because this
very important thing because when you
add them together you get another thing
of the same kind you can keep going and
going and going so there's there's no
limit to how big your Lego can be now
you can see where I'm going with this
when I'm talking about programming but
this is just your sneak preview here so
here's the reusable thing too you can
take it up you can put them together in
one way you can take it apart and put
them together another way we use Legos
reusable okay why is it reusable it's
because each piece is self-contained and
there are no strings attached
there are no strings attached till they
go so it means they don't get tangled up
you know if you if you have to put three
pieces together you have to wire them
together and you couldn't you we use one
with having a special kind of wiring
something that's not reusable Legos are
reusable because they're completely
self-contained they have no dependencies
on the outside world
each piece is an isolated piece it's
very important right so this thing of
keeping adding and adding and adding and
making bigger things this is what you
end up with you end up with giant pieces
of Lego and this is a piece of Lego too
you can keep on adding to this right you
can little things on it you can add to
it so that's what I call the power of
composition that's my slogan for this
talk the power of composition compels me
to tell you this so alright let's look
at another philosophy which is wooden
railway tracks as in Rio or something ok
all the pieces is designed to be
connected if you connect to well we
trace together you get another wheel
weight right and the pieces are reusable
alright here's some railway track
they're designed to be connected right
everyone has a little thing on them when
you connect two pieces you take two
pieces of track you put them together
you've got a now kind of bigger piece of
track that you can keep adding to other
pieces okay this is obvious right it's
really obvious how this works I don't
know why you know it somehow it doesn't
seem to be obvious when we're doing
programming but it's really obvious when
we're doing Lego and you know you don't
need a special adapter to stick low
weight tracks together actually they do
sell special adapters for when you have
enough of certain kind of piece but you
know in general you don't need special
adapters which means you can keep adding
and adding and adding and you can make
you know okay we make big ones
reusable again you can take them apart
we use them in different situations you
can have a special you know points track
and you've got a little bridge piece and
you can use that bridge and other little
things which is kind of cool
okay and you can keep going and going
and making bigger and bigger pieces if
you need to that's the power of
composition as well alright so lego
philosophy well we track philosophy very
very similar
all right now let's talk about some
thing the Poli have heard of which is
UNIX philosophy so I stole this from the
Wikipedia page from UNIX so hopefully
it's right because I trust Wikipedia to
be always a hundred percent accurate
number one write programs that do one
thing well and if you want to do a new
thing you build a new piece you don't
complicate old things by adding new
features you build a new piece you debit
you don't modify old code you design the
pregnancy to work yeah so you expect
that the output of your program is going
to be the input some other program you
don't have any Linea well you don't even
know what it is and you might programs
to handle text dreams because text
dreams are the universal interface on
UNIX now it's maybe not so Universal but
you know I can see where their game were
they where they're trying to get out
here so this match does very well to our
competition philosophy
you've got reuse or PB each piece is a
single thing which is reusable it only
does one thing they're designed to be
connectives they're designed to work
with each other and you don't need to
have a special adapter you can use the
universal tech stream interface to
connect your components together right
so that is the philosophy behind
computation now let's look at functional
programming and see how that philosophy
applies to functional programming so I
can I'm gonna see when you know nothing
about functional programming in a mess
or if you do because this is be a bit
boring so core principles of functional
programming and this is my theory of
functional programming people have
different ideas but here's to three
things first all functions are things
and I'm gonna think of them as little
bits of railway track use composition
everywhere again that's like Lego and
types in you're doing type functional
programming types and not the same thing
as classes they're much more like sense
and we'll talk about all these things
these three things
so first principle functions are things
so in functional programming I like to
think of a function as a little bit of
railway track that transforms inputs
into outputs and there's a little tunnel
of transformation on there and something
goes in one end and it comes out the
other end different in this case the
Apple goes in one end and a banana comes
out the other end and we write that in
in coding we where there's Apple our
banana apple is the input and Barnard's
the output okay so there is a function
now it's really important that a
function is a standalone thing it's not
attached to a class and that means it
can be used as inputs and outputs for
other functions and when I say
standalone
that's really another word for a
reusable component I can take this
function in isolation and reuse it in
many different contexts which I couldn't
do if it was a method for example in the
class so here is a function which has an
output so the function has an input and
the output is one of these food
functions or here is a function and here
is an input so it's got a function as an
input so here's another function with an
input and output and here it's got
another function as a parameter okay to
control how the input gets turned into
the output so function as input
functions and output functions as
parameters you can build really complex
systems it's that's the basic principle
and from that just like with the Lego
and the railway track you can build
really complex systems because functions
that return functions that generate
functions and so on and so forth
it can get really complex that the
fundamental principles very
straightforward all right second
principle composition everywhere so here
is a piece of we're track here's another
piece of where we track how do I compose
them together well just like with the
toy trains I just take the two things
together and I push them together when I
get a new piece of track so now we have
a new function composed from the two
smaller functions now what's interesting
about this function is that you cannot
tell that it was built some smaller
functions and like with a railway track
where you can see there's a seam with a
function you can't there's no seam you
can't tell that it was made from smaller
pieces and that's really cool because
you don't know how it was made in this
particular case there was a banana but
the bananas disappeared hey where do the
banana go right the fact is the banana
is now hidden
you've now kind of got an abstraction so
the fact that banana was important at
the low level when you've got this
higher level function that you want to
show people this is your public API the
public API doesn't talk about bananas so
there is kind of cool all right so let's
look at some code let's say we've got an
ad function add one function a double
function we want to clear them together
so this is f sharp code so f sharp you
define a function saying let's if anyone
does Python it's F sharp looks really
really like Python except instead of
saying def if you say let's okay so
there's a double function which is plus
X plus X and also in F sharp you don't
have return key words the the value of
the last the return value is the last
thing in the in the definition so this
case just returns X plus X so to make a
new function I just add take add one and
I mush it together with double and that
double angle bracket is the composition
simple so I got a new function add one
then double and I can just call it with
a number like five just like it was a
regular function and the answer is 12 in
fact it's not just like it is a regular
function okay
so that angle angle is the composition
operator in F sharp in other languages
it's different in Haskell it's just a
period different languages might have
different symbols for that here's
another one we've got three functions
who want to play them together okay we
just take all three functions and we
mush them together with the composition
operator and then we've got a new
function and when he just call it with
five and in this case we get a hundred
forty four add one then double then
square so hopefully this is kind of
really obvious especially if you've
played with railway tracks
you should totally understand how this
works now in F sharp we actually use
another technique in more so than than
that kind of anger bracketing which is
the piping this is very much like UNIX
piping so here's the problem with you if
you're doing a traditional language with
parentheses you might say well I want to
add one to five and then I want to
double it and then I want to square it
now each time you do that you you put it
in
deep inside parentheses you put
parentheses around and then do something
on the outside and your parentheses
the the thing you want is buried right
in the middle of the parentheses so you
have to read it from the inside out okay
so you say well I want to start with
that one and then I want to double it
and then I want to square it and it's a
little bit confusing when you have all
these parentheses so this is you know
what you're used to in c-sharp or Java
or something but in functional
programming in F sharp especially we
like to use the piping model so it's the
same thing you start with five you feed
it into the add one function you take
the output of the add of that function
which for six you feed it into the
double function you take me out but if
that function you feed into the square
function so it's very much like the UNIX
piping model and I think this is a lot
easier to understand because you don't
have this nested parentheses you just
start from the left and you kind of work
your way across so this is how it looks
in F sharp five you pipe it in to add
one or you pipe it into add wire then
take the output and pipe it into double
or you take it you know start with five
pipe it in to add one take the outfit
about one pipe into double take you out
for a double pipe into square and in F
sharp the pipe symbol is a vertical bar
with an angle bracket because the
vertical bar actually use it for
something else but it's very similar to
the UNIX model of piping okay so we're
gonna be seeing a lot of piping as to
that's the main way of doing stuff like
this in a shot so building bigger things
and functions okay it's compositions all
the way up it's not Turtles all the way
down these compositions all the way up
so we start with a low level operation
for example like application a string as
a function it's gotten the string input
string output now to make something
bigger we take a bunch of these
low-level operations we compose them
somehow and we get say a service in
address validation service and this case
the inputs and dress and the output is
some sort of results and for people who
are under 30 you might not know what a
service is it's basically just like a
micro service but without service
anyone over 30 anyone who's program in
the 90s knows what a services nowadays I
don't think anyone does okay so we got
these services we glue those together
into a use case or a scenario worth
whatever you want to call it in this
case updating some customer data so
you've got an input which is a quest
you've got an output and these are all
the use cases and then you take these
use cases and you build a minute you can
compose them into a web application and
the way you do that so web application
has a request as an input and the
response is now put and inside the web
application there's a dispatcher router
control or whatever you want to call it
that decides which one of these use
cases to call based on requests all
right composition all the way up it's
kind of fractal what's nice is he using
Sako same techniques at the bottom as
you are at the top all the way you know
so you're just using one kind of unified
principle okay so you end up if you look
inside your web application it's going
to look like this a whole bunch of
functions move together the power of
composition okay and we'll actually see
an example of this at the end of the
talk so power of composition power of
composition I think you get the the
message I'm kind of emphasizing it very
heavily here composition is good all
right
there's more kinds of composition you
can do as a functional programmer and
this is where some of the jargon comes
in mono age okay so Manos is a jargony
words it's a mathematical word it's
really a way of composing things like
strings lists even integers and stuff
it's it's a it's a technique for doing
composition of things like that
monads is another java new word which we
will be talking about later and that's
for composing functions which have
effects and will I'll show you that when
we get to fizzbuzz and finally there's
category through which functional
programs of a kind of obsessed with
category theory and the reason is
because category theory is sort of a
composition theory it's really about how
do you do compositional if you compose
this thing with this thing is that the
same as composing this thing the other
thing
that's what I'm you're going to say in
this talk if you're a mathematician
please close your ears but then I never
said that but from a sort functional
program point of view that's why people
are interested in category theory all
right another principle types are not
classes
so then we'll access so what is the type
okay there's a kind of set if you have a
function you have a set of valid inputs
for the function then you have a set of
valid outlets for the function so the
type is just the name for that set
that's all the type is it's not a clause
it's just a name for a set of things so
if you say the set of valid inputs is
all the possible integers we just pull
that type integer if a set of valid
outputs is all the possible strings we
say that is of type string if it's all
the possible people in the world we say
its type person if it's all the possible
fruits you say it's type fruit
okay now because it's a set it can
contain any group of things including a
set of functions so you can have a set
of functions as outputs or inputs and we
have that set as a name in this case is
the set of fruit to fruits functions
functions that turn fruit into food and
so this would have the type Y we could
type through our food that would be the
name of that type okay that's something
that's when it starts it starts spinning
a little bit but it's really really
important thing to understand okay
composition everywhere types can be
composed at least these kinds of types
can be composed and the reason is oh
it's oh yeah so this the kind of type
system that f-sharp and Haskell and
other functional programming language
have is called an algebraic type system
a bit more jargon if you forget about
algebraic and call a composable type
system it makes more sense okay it's a
composable type system and it's
composable because you build new types
from smaller types just like any other
kind of composition and there's actually
two different ways you can build bigger
types you can compose them with and and
you can compose them with or okay so
what does that mean
this kind of competition by the way is
only possible because it's just data
okay it's just like sex you can have a
set intersection and set Union in the
search so upsetting so this it's it's
dual because there's no data if this can
sing certain methods attach them it'd be
really hard so the very fact that that
set the types are just data means it's
really easy to compose them okay so
let's start with anding things together
so here's an example let's say you want
to make fruit salads and you say well I
have an apple and a banana and a cherry
that's what makes up my fruit salad and
this is a very familiar thing any
programming language it has this kind of
stuff there's a pair it's a to pool it's
a record it's a struts whatever you want
to call it here's an example in F sharp
you say type fruits out of equals and
it's an apple and a banana and a cherry
and it looks this curly braces it looks
kind of like JavaScript or types grid or
whatever you know and that's a record
type in a shop okay so that's something
you will be familiar with already but
the other way of doing it is a bit more
unusual if you're not used to functional
programming it's composing with or and
so let's say I want a snack and I'm
gonna have a apple or a banana or a
cherry that's my snack and like I say
this kind of boring things together is
not available in languages you used to
unless you're a programmer and
in a shop you write it like this with a
vertical bar or boolean or okay it's an
apple or it's a banana or it's a cherry
this is a really really useful type so
wait I call this a choice type the
technical term in F sharp is
discriminated Union you can also call
them some types and if you're really
fancy you can call on Co products I like
to call them a choice type because from
a modeling point of view that's why I
think of them either a choice between
these three things so let's look at real
world example of composition okay so
here's a real world thing we need to
accept payments for my business
let's say we take three forms of
payments we take cash check or credit
card for cash we don't need any extra
information for checks we need a check
number for credit cards we need the
credit card type and a credit card
number and I'm going to have to change
this example because in the future
cheques are kind of going out of fashion
but anyway I'll replace it with PayPal
or Bitcoin or something okay so how
would you implement this in your
language of choice well if you're an our
programmer you probably immediately say
well I need a an interface to represent
the payment method may be a abstract
basic class I don't know and then I'm
going to have a bunch of subclasses or
classes that implement its interface a
cash class a check class a credit card
class and each fast is going to have the
extra data it needs to represent that
thing well that's fine but let's look at
how you do this in a shop so we're not
going to do that way we're not going to
start with in the face we're gonna build
up the thing using composition so we're
going to start off with some primitives
we'll say hey we've got a check number
and we've got a card number okay those
are our primitives and we doesn't these
are just aliases for a primitive to make
our code look nicer okay once we've got
a check number and a card number we can
say well the card type is it's either
Visa or MasterCard okay and then we have
credit card information which is going
to be the card type and the card number
okay so the Visa or MasterCard that's a
choice okay so that's a choice type and
the credit card information is a car
type and a card number so it's an and
type use it as a record type okay next
let's do our payment method so a payment
method is cash or cheque or credit card
and in each case we have the extra
information there's no extra information
with cash or cheque there's a check
number for card the extra information is
credit card info as choice type right
and it's a choice with the vertical bars
it's one of those three things and we
can keep going so we say okay a payment
amount is a decimal a currency is euros
or dollars okay another primitive and
another choice type and then
we can keep going we say well the
payment is an amount and a currency and
a payment method and now this is and
this is a record type okay so what we've
done here is we've built up the final
type by composing small types over and
over and over building a big thing from
a small thing okay it's a power
composition what's nice is it's very
compact it fits in one page very nicely
so this is another nice thing about
functional programming is you return to
use types as executable documentation
they're not just something that gets in
the way there's something that actually
documents what you're doing so if I show
you something like this can you guess
what I'm talking about here I'm talking
about you know a card game of some kind
right these are all different types in
the card game and it's a fits on one
page pretty much describes everything I
doing at the card game now these are
nouns but you can also have verbs I
functions so to deal is you start with a
deck of cards and then you take one of
the cards out and you put on the table
and you've got a new deck left back
that's a function that you know starts
the deck and it emits a new thing so you
can do we can represent now so you can
represent verbs okay very cool that you
can fit the entire domain on one screen
here's the one we just looked at payment
method if I come to you you and I'm just
trying to maintain your code all right
let's say your time I mean you're trying
to maintain my code and you know
can you guess what all the different
payment methods are if you you've got a
KO to maintain and someone says what
different payment methods do we take
well if you have the OO thing you might
have to look in five different files in
this one they're literally on the same
page and you know the same four lines
that right next to each other so from a
document the documentation point of view
this is very very nice so this is a
massive topic I don't have enough time I
have a whole talk about this if you're
interested in domain driven design and
types
I have a talk at /td on my website and I
have a book coming out called domain
modeling make functional which you can
all rush out and buy please thank you
very much okay next think of a number so
we're going to start now with a very
simple example of basic composition
think of a number think of a number add
1 to it square it subtract 1 divide by
them and first thought of track that we
first thought up in the answers - ok
this is kind of a child's you know
little fun game ok how are we going to
implement this using composition well
we're going to have a little bit of
railway track for each step and we're
going to glue them together so we're
going to add one we'll take the output
of that we're going to subtract one
we'll take the out of that and square it
and the output of that and divide by the
number first thought of and so on and so
forth ok it it naturally maps the
composition model which is why I picked
this example so let's look at the code
we're going to define a function for
each step would define an add one
function a square root function there's
a track one function the divide function
that another one we define it define all
these helper functions and once we've
defined all these helper function then
by the way don't worry about
understanding the syntax too much I just
want to kind of show you that you define
all these helper functions and then you
combine them so we take the number you
first thought of we've pipe it into add
one we pipe into square we pipe it into
subtract one and we probably divide by
them because those little and so on and
so forth ok so that is the composition
principle applied to this particular
problem
ok so the code is quite a bellicose
notice there's no classes there's no
methods it's all functions all right
that's very simple example hopefully
this all makes sense and I say if you
need to look at these slides I'm going
very very fast I will put the slides up
on my website so you can review them
later on all right
somehow it's not always that easy you
know so I've made it look really easy no
it's not always that easy so we what
we've been talking about so far is
functions where you can just literally
compose them and it's works first time
yeah as if so here's the problem let's
say you have a function with two outputs
okay like this one some functions
actually have more than one outlet
here's another function some functions
have more than one input okay and what
happens then is they can't be composed
if you have two outputs and one inputs
how do you even compose these things
okay or if you have one output and two
inputs how do you even compose them okay
so this is a problem and this is what
functional programmers actually spend
most of their time doing is manipulating
things so they can be composed not that
functions writing the functions
themselves is pretty straightforward bit
manipulative so they can be composed
that's the kind of just like it it's
like playing Tetris you know to like
twist things around and stick it back in
so let's look at an example of why we do
this one example of how this might work
so Roman numerals this is another simple
problem to make something into Roman
numerals so this is our task we have an
integer now the Roman numerals means if
it's a five we replace it with a V if
it's a ten replace with an X and so on
right now the algorithm that we're going
to use is based on the fact that Roman
numerals is a tally system so in the old
days you know one two three four when
you've got for them you put a
strikethrough and that would be your 5
and notice that that kind of looks like
a V it's probably where the V came from
and so on so forth so algorithm is going
to be very crude but very effective
algorithm which is we start with you
know if we're doing you know returning
25 in tournament we create 25 slashes ok
25 ones and then if there's five ones in
a row we've replaced it with a V and if
there's two V's in a row
or your place with an X and if there's
five X's in a row in place with an L and
so on and so forth up to M that works
out really well it's a really easy
algorithm to understand and it's a lot
less complicated than some of the stuff
I've seen on the Internet
all right so and I've also chosen this
algorithm because it's very composable
let's look at this replace function
we're going to be replacing ones with
X's you know ones with threes and visa
fixes this replace functions going to be
used a lot let's have a quick look at it
so the replace function has an input
string an old value and a new value and
the
but is is the new that's a three
parameter function all right so the
problem is when we want to replace the
one by the V and the V by the X and the
X by the L we can't glue them thicker we
can't do them together because they just
doesn't work all right so this is our
problem how can we solve this problem so
this is a more general problem which is
all these nice composition patterns of
gluing things together it works really
well when every function has one
parameter right but these functions
don't have one parameter so that's bad
news the good news is that you can
actually turn every function into a one
parameter function that's a very cool
thing the functional programming allows
you to do and it's thanks to this guy
mr. Haskell curry the technique of doing
this thing is called carrying named
after him
so this is something you might have
heard of carrying what is carrying so
here is a very simple function with two
parameters okay it's an uncovered
function and what we're going to do is
after carrying we're going to turn it
into a function a one parameter function
with say the a input and it's going to
spit out a new function a new kind of
intermediate or temporary function and
that temporary function is also a one
primitive function and that has the
extra input B all right so currying is
the the technique of taking a multiple
the multi parameter function and turning
into a series of one parameter functions
and what's great about that is then
these one-time parameter functions can
be composed all right now in F sharp
you get currying for free in other
languages like javascript do you
actually have to do some work to get
caring to happen but this is why
carrying is so important because it
makes everything into a one primitive
function so this is the function before
carrying and here's the code I'll just
show the F sharp code is a three
parameter function we have the old value
of the new value in the input string and
dotnet already has a replace method but
it's a method on on the string class so
we're just going to pull that method but
we're just going to make this into a a
nice
function that we can use okay so this is
how you'd call it in c-sharp replace
input string dot replace now after
currying the code is going to look like
this it's now a two parameter function
and it returns a lambda and a lamb in
f-sharp the lambdas are written with a
fun keyword because there's a lot of fun
to write lambdas and it's you know
there's a function so we're returning a
lambda then lambda has one parameter
input and it does this replace it over
here so the output we now have a one
primitive function the output is a 1
parameter function which we can compose
and the old value and the new value sort
of baked in like that so this brings us
to the next taste test me after we've
done the currying we can do caution
applications so partial application
means passing in some of the parameters
but not all the parameters and what what
we're left over is a function that's
kind of missing some parameters we can
then provide those parameters later on
so it's important not to mix up partial
application and carry incurring is the
process of turning functions into one
parameter functions partial application
is the process of passing in some but
not all of the parameters baking them in
so that you can then use that function
later on so it's a really important
technique so here for example if we do
replace five ones with a V we're going
to call the place function with two
parameters not three okay and that will
give us a function back so we can then
use later one and if we're going to
replace two V's with an X that we call
replace with two out of the three
parameters we're missing a parameter
that will be used later on so we get
better function back okay so you can see
it's partial partial application we're
only passing in two out of the three
parameters and and the the after we've
got the function back of the old and the
new star self baked in so we can now use
it okay so now once we've done this
partial application we can now chain
them together so let's look at the code
for that define a helper function which
uses partial application another helper
function another helper function another
helper function and so on
fourth and then we can do our pipeline
so we start by replicating it the I and
then we do the replace and we do the
replace and we do the replace and we do
the replace and so and so forth okay
that's very straightforward now well in
Waiting helper function at the time we
typically don't bother to that there's a
lot of extra code we normally use in
line partial application so if you're
sampling here if we have an odd function
and an odd apply function you know add
function takes two parameters but in the
example below we're just passing in one
we're saying add two okay and we're
missing the extra parameter that extra
parameter will be provided later on
through the pipeline and same with x - x
- what's you know again the extra
parameter be provided later one and we
can kind of do nested in line
application like this so in this case
we've started a list of numbers one to
ten we're going to map each of those
numbers using add two and they're going
to map each of those numbers using
multiply so map transforms things so map
it's a two parameter function it has a
function to transform each element and
then the list itself
well I'm passing in the transformation
function but I'm not passing in the list
so I'm partially I don't know applying
map and again and we're partially
applying add so this is a partial
application within partial application
so if we use partial application in our
Roman numerals thing we don't need to
write these helper functions we can just
literally write them in line replace
five with V replace to reason of X and
so on so it is very rarely will you
actually bother to write these special
helper functions you just use the postal
application like this okay now what's
cool about using this composition model
is it's really easy to add new segment
to the pipeline for example we haven't
done you know for four ones in the rows
of 1v so we can just keep going say
we'll place V 1 1 1 1 with 1 X replace 4
ones with one V and so on and so forth
and this is this we go back to the unit
source we don't change the original code
new things on so with the pipeline model
it's really nice you can insert new
segments you can append new segments but
you're not messing with the original
code so that's why another piece is why
this particular composition approach is
so nice so there you go that was this
particular challenge how do we compose a
function with two inputs
the answer is we use partial application
alright next fits bars okay for people
who aren't familiar with fizzbuzz is
another child's game writing a program
that prints the numbers from 1 to 100
but but if it's a multiple 3 print fizz
it was a model of 5 print bars it as a
model 15 print fizz buzz okay I'm sure
you've all seen this and most people
would probably write information like
this it's very simple if it's divisible
by 15 print fizz bars they're just
miserable i three print fizz and so on
and so forth so this is the imperative
solution okay and we're going to use
this little helper function is it
divisible by just to make the toad look
a bit nicer so this is fine this is the
easy way of doing Fitz buzz and I really
wouldn't recommend make it any more
complicated if you're doing a
programming interview but since this is
a talk let's make it more complicated
this is not complicated enough it's also
from a functional point of view there's
things wrong with it it's not it's not
composable I can't connect this Fitz bus
to something else right because it's
just it's a self-contained it's a
monolith it's a mini monolith it's also
mixing in IO and it's not pure so
there's printing out to the console
functional programmers like to put IO at
the front in the back of their functions
and in the middle you have a pure
function that doesn't mess with the
outside world it makes it a lot easier
to tests and what using to understand
what's doing on so from that point of
view this is about implementation oh
wait but ok we're gonna do the pipeline
model of fizzbuzz ok so the pipeline
model we're going to have to handle the
15 case we're going to handle the 3 case
the 5 case and then we're going to have
a last step where we handle the
remaining cases alright just like all
the other ones so the question is what
are these handlers how do we handle a
particular number
so if you think about it a number comes
in and we have two choices it can either
be unprocessed like 2 or 7 or 13 I'm
going to call that uncarbonated and or
the alternative is it could be processed
in which case I'm going to call it
carbonate is like a fears or buzz oK
we've got two choices so if we think
about in the railway track model so you
can think of it as like points or
switches in the u.s. you have input and
you have two different outputs
uncarbonated output and culminated
output all right so this is our railway
model for this particular function so
let's look at the code so we're going to
define a type which represents the
choice it's a choice between carbonate
and uncarbonated if it's uncommon ated
there's an integer associated with that
choice if it's carbonated there's a
string associated choice okay so this is
our type and it's a choice type and then
to actually carbonate something we pass
in the number two divided by the label
or the whatever and then the number so
if it's divisible by the divisor then
it's carbonated and we use that label
like this even if it's not divisible we
or say it's uncarbonated okay so that's
the code see it's pretty straightforward
code the concepts are harder than the
actual code itself
so I've got this idea from Ragan walls
original braithwaite's so if you think
it's a terrible idea
you can blame him actually he was using
us to demonstrate how not to do a
program interview and I would agree but
it's kind of fun to see to take it to
its limit see how far you can go right
so if we say carbonate 3 with fears we
get a carbonated fizz if we pass in 10
it's not divisible by 3 and so it's
uncarbonated if we pass in 10 and we
carbonate it with a 5 it is carbonated
to random get a buzz okay so that's how
our little function works so okay we've
got our functions how do we compose them
okay well if it's uncarbonated we want
to call the next one down in the line if
it's carbonated we want to bypass we're
basically done if we hit Fears we can
skip the rest of the line okay so this
is how we want to compose them and if we
have a whole chain of these things we
want to compose them all together
how would you compose them if they were
real train tracks well obviously you can
make it like that okay this is the
two-track model of composition or the
two-track fizzbuzz okay I call this
railway oriented programming I have
whole talk about this if you're
interested it's a very silly name but
it's quite useful concepts okay so one
track functions can't be composed if you
just take the output at the input to
track functions can also be composed
because you take each input to the you
know each output to the next input that
works fine here's the problem we have a
one track input and a to track output
and they can't be composed so let's look
at an implementation of fizzbuzz our
first attempt so we start by carbonating
it with 15 if it is carbonated we're
done we get that we use the string if
it's not carbonated we go to the next
step which is 3 so we carbonated with 3
and if it was carbonated we're done and
if it's not carbonated we go to the next
step which is 5 we try culminating with
5 and if it's carbonated we're done if
it's uncoordinated we've finished now
this is really ugly code
I mean this is fine it works but it's
really ugly you don't want to be writing
code like this but there is a pattern
here that we can look at and steal okay
which is that every time we see an
uncarbonated do we do something so if
it's served carbonated we stopped if
it's uncarbonated we continue so if it's
uncarbonated here we do something if
it's uncarbonated we do something
it was uncarbonated we do something okay
that's the pattern so this is the
pattern in encode here if it's
carbonated we're just done we return the
string it is uncarbonated then we do
something with that number and this is
crying out to be turned into a function
with a parameter so let's write some
code we're going to call it if
uncarbonated dude that's the name of our
power function and if the is basically
encapsulating that patent so if it's a
carbonated string we're going to leave
it alone okay we're going to keep
passing back to the end of the line it
was an uncarbonated number we're going
to call a function which is the next
function in the chain all right so this
is a function parameter we always like
to parameterize things and in functional
programming we use function parameters
to parameterize things now we call it F
we have no idea what this function is we
can't give it a name so we can use very
short letters like F because it's just a
function I have no idea what this
function does okay and there is me using
this function so now if we have this if
carbonated do helper function we can
rewrite our code so we start by
culminating it and then if uncarbonated
do the next bit which is carbonate by
three if you're still uncarbonated we do
the next bit which is carbonate by five
and then finally we carbonate the
remaining and I've got a little helper
function which is basically this is one
is different because basically if it's
carbonated we return the string and if
it's not carbonated we cast the int
interest ring so you can see though that
we've now come we got now a composable
model if I want to do seven you know I
don't have another one I can just stick
another one right into that pipeline all
right if I want to you know change the
order or something I can do all sort
things with this model there's one other
thing we need to talk about which is
loops I said there are no loops okay
loops are not composable so we have a
fizzbuzz that only works for none for
individual numbers and the goal was to
work lists of numbers and we can't pass
a list of numbers into this function
because it only takes single integers
okay that's a problem but we always have
a solution which is to use another
function in this case we're going to use
a transform a function that takes a
function that works at individual
numbers and transforms it into function
that works on lists and that is the map
function so this dot map is a
transformer function that takes one kind
of function and spits out another kind
of function it takes a function that
works and normal things and turns it
into a function the works and this
that's what this map is all about and if
you're using link in c-sharp that is
selects yeah so now we can have a list
input to this function and list out for
me so the fizzbuzz code the final
version list of this 1/200 is our thing
we take our fizzbuzz function and we use
map to turn it into a function of works
on lists and then now we have a list of
strings and we want to print them all so
we use this titter which is the same as
map except it just has no output and
that's the io part and the i/o is now
the end of the function there's no i/o
in the middle of the function and again
the fizzbuzz function itself carbonate
if uncarbonated do if i'm Carboni to do
and so on so you've got this composable
way of implementing fizzbuzz okay the
m-word is there a general solution to
functions like this okay and the answer
is yes
it's monads monads do everything in this
particular case bind as the answer bind
all the things functional programmers
like the word bind to get very excited
by that so this is our general problem
this is not just with fizzbuzz we go but
we also have a situation where we have
one track input to track outputs which
is not composable if we could turn it
into a two track input in a two track
output that is composable so how do we
convert from the before to the after
okay and that's what the bind function
does it's an adapter block if you think
about it there's basically an adapter
block and there's a slots and you pass
in your your switch your points function
and the output is now a two-track
so the bind function is a function
transformer it transforms one kind of
function into another kind of function
so if we talk about in in the fizzbuzz
the bind was actually the if
uncarbonated do that was our buying
function so if we look about it if we
look at it this one
the two-track result is the uncorrelated
coordinated if it's uncarbonated we do
the next function in the chain alright
and that gives us to track out but if
it's uncut its carbonated we just buy
plus so this is the fizzbuzz version of
bind ok and there's a bind for all sorts
of things so this is a quick definition
of monad a monad is it sounds
complicated but all it is is a data type
in our case the carbonation data type
and an associated bind function in our
case it was the if uncarbonated do and
some other very simple stuff just to
make sure that everything works as
expected that you don't have weird
behavior and that's basically it
and a magnetic function which you might
also hear it's basically one of these
switch or points functions and you use
bind you you run these a lot and bind
the reason why binder so important is to
bind as a way of composing these things
so if we have tasks here's another
example you have tasks or a sink or
whatever you want to call them you know
you do something you wait for result
when the task completes you do the next
one down the chain when the task doesn't
complete or something you just skip
right so it's a very very similar
situation and you use this very very
similar solution so you can call this a
promise the future whatever you want to
call it so here's an example without
using bind we start a task when it's
finished we call another function we
start when that's you know we start
another task when that's finished we
call another function when that's
finished we call another function and so
on and so forth really ugly codes okay
so if we create a bind for tasks which
says when you're finished call this
function with this F Prime
okay take take the result that you get
and call and call it with an F once we
have this bind the code looks a lot
simpler we start a task and we pipe it
into bind or the next task and then we
bind the next task and we buy the next
star and so on and so forth so now we've
got this kind of instead of having this
kind of diagonal pyramid of doom thing
which you get a lot you now a nice
linear vertical model okay so buying you
can see how bind is really really nice
sometimes you'll see binds written in a
different way which is a symbol which is
angle angle equals it's literally the
same thing as the bind method just we
written for the parameters around when
you when you use it this way you can use
it just like just like a nice
composition of a pipe it's kind of like
a piping thing so there you go
right and error generating functions we
can use exactly the same technique so
let's say you have a web service and you
have a request that comes in and you
want to evaluate request and
canonicalize the email and then fetch
the existing record then update the
record and so on so forth that's fine
there might be errors okay when you
validate requests you might the names
might be blank or something when you
fetch an existing record that you might
not find the record you mother you might
get a database error when you try an
update you might get an authorization
arrow of time out or something there's
errors okay so your code is going to
look like this the validation function
might return an error so it's going to
be one of these monadic points functions
when you canonicalize an email like
lower casing it or something stripping
out trimming blanks that's always going
to work when you fetch a record that
might be an error when you update a
record that might not return anything
okay it might be a kind of a void
function equipment of a void function
how can you compose these functions okay
they don't they don't have the same
shape so we have all these transformer
functions we have Matt we have bind we
have a tea and map and we basically go
through some work to transform them into
two tracks and once we've transformed
them all into two-track functions that
we can then glue them together so that's
what all these helper functions like map
and bind are really important because
they they allow you to transform
into things that can't be composed
alright so getting composition to work
is like the number one priority when
you're doing functional programming all
right next one and I'm running a little
bit behind I'm sorry last one which is
something else called quietly
composition okay so we have these
monadic functions these points functions
we saw that we turn them into two-track
functions but there's another way of
doing doing it we just combine two of
them into another points swich manere
function okay you can just add them
together and get another one at the same
time now what's cool when it's the same
type of thing you can keep going you can
keep adding and adding and adding just
like the Lego just like the railway
track if it's the same kind of thing you
can keep adding to it so there's a web
library for F sharp called suave suave
to i/o and it has a concept called a web
part
now a web part is one of these magnetic
functions the input is an HTTP context
which is a wrapper which contains the
request it retains the response it
contains the cookies it contains the
credentials whatever all the stuff you
need to know to process a forest the
outputs is an async HTTP context option
so it's a sync because everything should
be async and it's an option because you
might not handle it you might say you
know this is the kind of request I can't
deal with so I'm actually not gonna
return anything
all right so it might fail this is the
way you can tell it's going to fail and
you can read all about it on the suave
site so you can compose two web parts to
make another web part and the
composition symbol is the angle equal
angle another way it's simple this is
the standard simplifies the composition
but again when you combine these two
things you get another thing of the same
type which means you've got another web
part and now you can combine some other
web parts to make another web part and
so on and so forth
so let's look at actual some real
examples so here is composing two web
boots so path hello
path is a web part you pass in a string
and if it matches the path it succeeds
and if it doesn't match the path it
fails and okay
is a webpart that returns the okay
response with this particular message so
I'm going to glue them together using
Cline's decomposition and get a new web
part and the web part now is going to if
it's if the input is hello if the path
is hello it's going to succeed if the
path is not hello it's going to fail if
it does succeed it's going to return 200
with hello okay so that's where the
feigning thing so the whole web part
this whole new web part will fail it's
kind of just like with the railway track
it's going to bypass the next stage if
the path thing fails that the OK will
never happen all right now the next
thing is we're going to have two web
parts I'm going to choose between them
so this is the choose web parts and you
pass in a list of other web parts and it
basically picks the first web part that
succeeds so if the input is hello it's
going to find the first web part it's
going to succeed and it's going to
return hello if the input is goodbye the
first web parts going to fail and the
second web parts going to succeed and if
the if none of these succeed the whole
thing is going to fail mm-hmm all right
so that's a choose now we now we're
building up a web part from smaller web
parts okay and then we're going to
combine it with the get web part now the
get web part only succeeds if the input
if the request type is guest so when we
say gets composed with choose this whole
thing now only worse when the input is
get and then we make a complete
application so we're going to choose
between gets with two cases and post
with two cases so now the inputs you
know if the input is closed that whole
gap thing is going to fail and it's
going to drop down to the posts if the
gate does work it's going to look at the
path and it's either going to be hello
goodbye if the hello if it's not hello
it's going to drop down to the goodbye
and if that works it's going to say okay
so this is a complete web application
written using web parts composing web
parts together to make bigger and being
a web parts just like the logo just like
okay and then you basically take this
webpart and you the entire application
takes a web part as input that is your
application is one giant web part so web
parts are connected all just like Lego
okay stick to them together you get
another web part you get another thing
that's the composition they're reusable
okay so the get web part can be reused
in many different contexts the choose
web part can be reused in many different
contexts the the okay web part can be
reused in many different contexts okay
these are reusable components that can
be glued together to make a web app and
this is when you do this you get your
web app that looks something like this
lots of little functions inside no
classes no loops no objects nobody it's
just pure functions compose together
okay the power of composition okay this
is the power of composition so let's
review what we we discussed we talked
about philosophy the philosophy of
composition things being connected or
not having to use a special kind of
adapter everything being reusable okay
that's is really the whole philosophy
behind composition this is why it's so
important you can do so much with it we
then talked about functional programming
composable functions composable types
composable composable everything is
compressible you probably get fed off of
that word because I've said it so many
times and then we looked at basic
composition using angle brackets to
compose new functions and piping to
chain functions together partial
application is another technique to help
you do composition and then we talked
about monads and using bind and using
Kleist accomplishes so all these
functional programming techniques like
motifs as if they're all about
compositions all about how can I make my
life easier how can I do
composition okay so when they you think
why do they even have monads why do they
make it so complicated they're not
trying to make it complicated trying to
solve a problem which is composing
different kinds of things all right and
you can see that when we do use these
techniques things do become composable
we can turn on composable things into
composable things so that's it thanks
very much
I'm gonna put the slides on my website
slash composition and the video will be
up in a month bubbly if you like this
talk that I've got more videos if you
like domain-driven design you might want
to check out my book there's my book I
add me on Twitter and if you want to
know more about F sharp F sharp org is
the place to go I highly encourage you
to check it out so thanks very much if
any questions just come and grab me
Cheers</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>