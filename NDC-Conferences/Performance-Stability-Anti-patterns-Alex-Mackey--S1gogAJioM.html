<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Performance &amp; Stability Anti patterns - Alex Mackey | Coder Coacher - Coaching Coders</title><meta content="Performance &amp; Stability Anti patterns - Alex Mackey - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Performance &amp; Stability Anti patterns - Alex Mackey</b></h2><h5 class="post__date">2017-01-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-S1gogAJioM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">when I year proposed this talk I had
quite a different talk in mines and I
actually ended up with I was thinking
we'd look at things like sort of m plus
1 very sort of memory management issues
and stuff and I started looking at where
the problems were in my own organization
and other organizations that worked with
and I realized that these probably were
not the main issues but i'll be talking
more about that over the next hour or so
Who am I I work for a company called
zero we produce accounting software my
job role there is practice lead which
basically means i'm a developer and i
talked a bit and work with other teams
to look at various practices are working
and not working I've learned a couple of
books on door net and offered a couple
of Pluralsight courses all these slides
they're available on my website simple
is best al Qaeda UK so I've got a few
good references throughout the
presentation so don't feel you need to
write them down because you can just go
and download them from there I'm also
going to say that I've certainly
contributed my own share of crappy and
stable and the slow code so by no means
of my innocence in some of the things
I'm going to be describing to you today
I have made all these mistakes and many
more applique tree described aside these
are my own opinions and honestly my
employer we will talk a bit about some
of the things that we do at zero and
towards the end as well so what we're
going to do well we're going to start
off talking about fail and then what
exactly failure is how we can measure it
how we can define it and we're going to
move on to talking about patterns and
anti-patterns and we're going to wrap up
with what we do at zero and some final
thoughts after that so let's begin I
think it's also important to acknowledge
that what I'm going to be talking about
here I'm going to be talking about your
typical line of business systems that I
suspect many of us are working with
we're not talking about critical systems
so this picture here this is the
computer system of a Boeing triple7 I
think we could all agree if something
were to go wrong with that there could
be catastrophic failures and although we
could have some very bad failures if
things will go wrong with a zero or some
of the other systems we're working with
hopefully no
lives would be lost it's very
interesting that if you hit that URL up
it took some great detail about how this
system was designed there's multiple
levels of redundancy they ensure that
there's not too much communication on
the wires connecting the machine it's
really quite interesting the other thing
I'm going to say is I'm going to be
concentrating on some of these sort of
software architecture perspectives when
we're talking about developing
resilience and stable systems there's a
lot of other things we could talk about
everything from process to hardware to
network design there's a heap of stuff
there so my demos I'm going to introduce
you to my site hat for capcom and this
is a site we're going to be using to
demonstrate some of the patterns and
n-type essence here now hat for capcom
you can go to this this is online and
the purposes of this site is that you
can purchase a hat feel your cat here
and if anyone would like to invest in
this business please see me afterwards
so i can go in here I can select a hat
and I can go and that to the basket
there and I've cats will have a very
nice black bowler hat and to where
they're down the bottom of the site here
we've got a couple of things we have
that certain beautiful advert that and
we also have a list and for top-selling
perhaps at the moment over us here but
we'll be coming back to that later on in
the presentation so what I'd like to do
now is I want to talk about to fail
we're not that type of fail we'll talk
about this type of fail the sort of home
videos that are so enjoyable to watch
and it's really enjoyable about watching
someone else get hurt when it's not us
or maybe this type of fail and you can
only anticipate what's going to go wrong
there it's not going to be good so
Google software reliability engineering
group they looks from the failures in
their own systems and they found that
seventy percent of the outages would use
the changes that have been made in a
live system and this brings us to you an
interesting point in that generally
systems are pretty stable until you
start actually making changes to them
and it kind of this continual sort of
arm wrestle between the stability of a
system and introducing new features and
changes here now unless you're perhaps
these guys and your site looks the same
as it did 10 years ago your customers
probably are not going to be overly
happy if your sites and applications
stays the same and it never developed
server on so it's really going to be up
to you depending what your business is
in order to have way up what the balance
of these new features are maybe if your
systems handling air traffic control of
something you're probably going to be a
little bit slower about how you're going
to release some changes there's a number
of different reasons that systems can
fail I've listed what I think of some of
the top ones here can figure out
configuration errors developer errors
beds requirements hardware failure into
system component interaction that will
often bring a lot of first systems down
and there's many others as well so what
should we do about this well one
approach is to attempt to run away from
this failure and this was an approach
taken for many years and it's still
taken by many developers and
organizations and organizations
developers they'll attempt to anticipate
every possible failure in an application
and code some type of remediation
against these type of failures
unfortunately there's a lot of things
that can happen so relatively recently
Sydney AWS region the experience an
outrage desportes a number of major a
rare sites down to its knees and I in
fairness you know AWS it's pretty
reliable on the whole I mean I know
instances and will go down but it's
generally a service that you can rely on
so who could have you know imagined that
an availability region would go down
here recently Telstra they've had a bit
of a bad here in terms of reliability
really and on their network this brought
down some major systems people couldn't
check into flights there's all sorts of
problems with this now when your whole
infrastructure level goes down you know
that's a pretty serious issue here and
no matter how careful you are as a
developer or coded as you know
relatively little you can do about that
unless you're you know you're running
multiple infrastructure providers there
so probably the first thing that you
really want to do instead of an
attempting to run away and deal with
this failure if you want to embrace it
because failure is inevitable and over
the next 40 minutes we'll say I'm going
to talk about all the ways that we can
do this and cope with these types of
scenarios better one way of looking at
this is patterns and there's a lot of
talent these have been around for a very
long time and they're also very easy to
implement a lot of these but they'll
cope with a lot of different issues
probably the canonical reference on
patterns and this book here by Roberts
hanmer patterns of fault tolerant sir
software and it was released in 2006
unfortunately for some reason unknown
for me it's almost two thousand dollars
to go and buy a paperback copy of this
book this is a real shame because this
is actually one of those computing books
that you probably do actually want on
your desk in order to use as a reference
you can't ever get an electronic format
for about fifty dollars which would be
my recommendation unless you're
particularly rich there it contains
details of about fifty or sixty
different patterns to do with resiliency
design and resilient system and this is
everything from things like retry logic
to manual patterns and approaches which
are just as important what seemed it is
worth mentioning is he can have academic
names for these patterns which will not
be familiar to anyone but you can it's a
good bird like any architectural so
decision implementing some of the things
i'm going to show you is a trade-off and
you might get some increases in
resilience and reliability but it's
going to impact other areas you're
probably gonna have additional
complexity in your code it's going to
take a bit longer to develop
you're going to have availability
consistency issues capture m5 stuff
maybe it's going to slow your system
down in order to make it to scale better
so these things that they don't come at
zero cost there is a cost and it's going
to be up to you with your applications
to way up this particular costs here I
think a number of the patterns that I'm
going to go through their kind of
depends on these three principles here
which are probably good principles
anyway in order to develop scalable
system statelessness I depot teams try
never know how to pronounce and location
transparency I depot to identify tins
the ability to make the same request
multiple times and receive the same
result often implemented by including
some kind of ID in the request that can
be ticked off under that progress has
already been processed by location
transparency if your time request to a
specific IP address or hard coded
something it's going to be harder to go
and modify and change that at a later
point if you need to rather than say if
you are using I don't know some sort of
DNS based solution I know another one I
don't think it strictly fits in with
them these that so I think we can all
agree that feature toggles a pretty good
thing generally and that these can
assist with your applications and if you
do find this is and being able to turn
off a new feature you've introduced is
certainly a good thing as a general
guide there's something called the
reactive manifest place which can put
together who's who's heard of the word
that it's been around since 2014 or so
now this is a it's fairly short if you
go head over to reactive manifesto org
but it's a good set of principles to
develop scalable a Brazilian
applications it's well worth a read and
they say that systems built as reactive
systems are more flexible loosely
coupled and scalable this makes them
easier to develop and amenable to change
and they're significantly more tolerant
of failure and when failure does occur
they meet it with elegance rather than
disaster
this tolerance is something we're going
to be talking a lot about and it's very
important for resilient systems first
answer pattern that I want to talk about
is not defining targets and what I'm in
target I mean actually setting about how
our system should behave what should it
be able to cope with when we're talking
about reliability of systems a lot of
people think in terms of availability or
the number of nines a system is
available for so ninety percent
availability over a year that means it
there could be a downtime of 36 days
which is probably unacceptable for the
majority of systems here I would get the
majority of systems or companies are
still in business perhaps for somewhere
between the two and four nines here it's
obviously dependent on what your
application is as soon as the type of
availability that you're going to be
targeting if you have some kind of
ecommerce sites like hats okay you can
probably cope with eight hours people
not being able to purchase headwear and
for their feed lines if ever you're
working with place maker software eight
hours could be a bit of a long time
there Google and suggest when looking at
the availability of the system you could
potentially perform a cost-benefit
calculation so for example if you were
going to improve your systems
availability from 99.9 229 availability
there we can say this is an increasing
availability of north pointe noire nine
if our theoretical service has 1 million
dollars revenue we can then turn this
your point naught 9 into a percentage
and say that if that can potentially
give us an increase in nine hundred
dollars worth of revenue there now it's
a simplistic model I'm not going to
disagree with that there but if you're
spending more than nine hundred dollars
there then potentially you might be
wasting your money because you might not
make
any more money there now of course we're
ignoring things like service level
agreements your reputation all sorts of
things like that but this brings us to
an important point in that it's much
more expensive and to go and increase
and these levels availability to the
higher and higher you go and do to
estimate that of all requests ISPs as
you screw this up between North Point
North one and one percent of all
requests and there are made to services
so if you're playing a lot of money into
increasing the availability of your
services this could be lost in the noise
of ISPs here one way over measuring
availability is from engineering called
mean time to failure and I guess it
would be used with something like say a
car tire and you might say over time we
expect my car tire or wheels to last
about two years until we get failure
indicated by the universal symbol of
failure there what's potentially more
useful in terms of computer system is
the mean time to recovery how quickly
you can bring your system back up online
again so we have our failure occur there
and then we can quickly recover and we
have the M PDF in between these points
here the meantime and between failure
number on considerations when you're
coming up with these targets and items
in that your availability can never be
more than any third party system you're
depending on here so if you've got a
third party that's down 50 cent of times
that sir sure it's all going to impact
the availability of your systems here
functions and systems also has different
levels of importance the ability of
users to log into your application is
probably a lot more important than the
ability to change their profile pic for
example and then of course there's
different levels of users and severity
of errors when you're beginning to
develop services and systems the
important point to consider is what does
your system require and it is so
important and it's missed out across
many different components people don't
define how many requests it should
respond see how what load it should go
and without these factors how can you
actually test and ensure that your
system will respond to these things okay
let's move on to dependent systems I'm
going to say lovely gift here and you
can imagine this isn't going to end well
and those guys they spend all their time
and and that dude in the middle
unfortunately was the guy that placed
this domino that brought the whole thing
down there ever watch that again because
we quite enjoy that failure he leads
vehicle and I it's a bad thing that said
first leave him in there peace so this
is a very common is here I'd like you to
imagine a is some kind of contents for
our website and is dependent on the
server's services b c and d wanna goes
wrong in see here but unfortunately this
is actually going to propagate and down
soup the other services in our
application there unless we actually
handle this type of failure and
introducing what I'm going to term the
flood of fail here so it goes over to
our site here and I'm going to this is
an NBC project and I have a Web API a
hint for this that's been called and i'm
using the rest sharps library to go and
make some of these requests so i'm just
going to go and throw an exception in
our advert here we'll go and build that
and business to do will chug away and
we'll go and refresh our page here and
as you might imagine we're going to have
some problems then when they don't
answer completion then completes their
and this is an incredibly common thing
to do that in a system someone will make
a call to another system and it will
bring the whole site down now in this
example that particular method was
serving up an advert for our users now
despite what your friends and marketing
may tell you that is not critical to the
function of hat for capcom and what is
important
calm is that we continue to sell hats
for people for their cats otherwise cats
will get cold heads and bad things will
happen and then we terrible revenge so
we're going to need to sort that out and
of course a very easy way of sorting
that out is that we can go back to our
controller there and we can I'm just
going to comment out the other one and I
tend to lose the ability to type when
I'm talking so I'd like to use comic
books like this and we'll pretty simply
handle that with a try-catch block we're
all familiar with that very very easy to
implement but there are so many sites
that won't even take that simplest level
they'll assume that some downstream
system will work and when it could be
very trivially handled exceptions such
as this and I'm way of handling these
types of failures is bulkheads and these
come from ship terminology where if
there was a leak in a ship we'd have a
watertight compartments that would
contain the damage and where this could
go to and we can do the same and with
some of our systems here and you don't
necessarily need to implement these
bulkheads fire separate servers or
separate instances this could be sort of
virtual but bulkheads in terms of
resource or memory constraints and that
this works quite well with some other
patterns I'm going to talk about I think
another very large mistake is assuming
network reliability I think we've all
done it we've developed some code it
runs absolutely fine when we've got
everything on our local machine but it
turns out when it runs over the network
it doesn't work so well and if you're
not familiar with the deutsches eight
fallacies of distributed computing you
really should because this is so
important on some of the systems we're
developing and those came up with a
number of different fallacies here which
can basically be summed up as assuming
the network is reliable it's really not
and you cannot rely on the
same perfect network connect connect to
especially any as we move towards more
and more distributed systems now a guy
called Leslie Lamport he has the lovely
quotes a distributed system is one in
which the failure of a computer you
didn't even know existed can render your
own computer unusable which is awesome
and there's a trend to even more
distributed systems we've got micra
services mobile Internet of Things and
cloud now I'm going to focus on mobile
so as some site called open signal calm
and they produce a report on how the
percentage of times people have 4g
connections so in Australia they took
them the 22 cents at a time people
didn't have a 4G connection slight
variations I guess depending on on the
network and depend on where you are in
the world just can get even worse oh we
have our friends up in South Korea there
which have ninety-seven percent and 4G
coverage which is just an incredible
infrastructure I'm so jealous and right
down to cheryl anchor there and there
must be some other places in the world
that maybe even have normal lower than
that but they have thirty nine percent
down the bottom there so if you're
designing your application and you
tested it on a 4G connection there's a
good chance of the quarter of the time
it said not going to work in unless
you've actually gone and tested this so
don't assume that a network and reliable
it isn't and people tend to go out of
signal they go into the tunnels all
sorts of things happen so what can do
about that well a very easy way to
resolve some of these things is to use a
retry and this can resolve transient
failures so also some of those failures
we're not really knows why it failed it
just did and try it again then it's all
good it's very easy to implement and we
will talk about exponential back-off in
a second so on the net platform a
library that makes this very easy to
implement is called poly does anyone
using this and their application
at the moment it's available on you get
it's been around for at least two or
three years now it's very stable and it
contains inbuilt functionality for some
of the patterns I'm going to be showing
you here so for example our top selling
hats here I'm going there comment that
out and I'm going to need to come on now
on what do we do well with poly we
install the package we tell it we want
to handle HTTP exceptions and we can
then tell it and there's various ways
that you can define this that we want to
retry a certain number of times that we
want to retry off to one second after
two seconds and after three seconds and
we then give it a delegate of going to
execute and there which is just the
request there so can you implement it
yourself yes of course but probably
makes it very easy to go to implement
this type of logic so we'll go back to
slides there and this brings us to
timeouts this is another incredibly easy
thing to add to your application that a
lot of people don't so just to show you
the type of issues at timeouts am going
to call I'm going to go into my web api
project here and i'm going to go and
introduce a year thread.sleep here for
20 seconds will go and compile the
application there and when that's
compiled will go and refresh the webpage
there and we're not going to get that
back for some time hens in addition to
the dotnet compilation time it's going
to be at least 20 seconds before that
that page is going to be rendered and
there's a really crappy experience for
your users it's much better to fail fast
on this type of thing the resources
being used your users probably got bored
they've gone off to one of hats or caps
competitors many competitors
and that's a bad bad thing so what can
we do well sure enough rest sharp has a
timeout prophecy very easy to implement
and we're going to comment that out and
I'm going to compile the application and
it's going to compile there I'm going to
go back to my solution will refresh that
and we'll get that slight chuggers done
it does its business and but much better
experience scroll down see all sorry
yeah things are unavailable yep it's not
the ideal experience we want to present
the users but still a lot better than
people leaving our site because they've
got bored of waiting around around there
now pretty much every web request
library will have some type of timeout
property front end dev softened get this
so xhr request has it the new fetch API
which is the new way of making these
types of requests does not have a
timeout property which is interesting
and I'm sure some front-end guys can
argue with me about this but it does
seem a strange omission and I think some
of this is because the promise base
nature of this and that the API
developers felt this should be dealt
with in a different way now you can
implement timeouts with perfect it's
just a bit more complicated in order to
do and you'll find several stack
overflows and posts on how to do that
but incredibly easy thing to implement
but a lot of people don't tend to do
this and by having timeout we ensure
that we don't hog resources for calls or
never succeed we maintain a responsive
system if it is going to fail it's going
to fail quickly your users going to
receive a better response and we can
combine this i'm using retry logic if we
want to circuit breaker in the olden
days and lectricity immerse out when
there was too much current flowing
through a system it would set fire to
the wires and burn people's houses down
which is obviously a bad thing
so what was done was when this there was
too much current this switch would go
and flip breaking the circuit and stop
it these fires here and we could do
something very similar with poly so I'm
going to come back into my application
and scroll up here and did the door and
I'm just going to need to comment out
the old on there well comment that out
and I'm going to talk you through in
just a sec what we're doing here so this
one's a little bit more complex than
some of the other ones so what do we
have I've said that there can be two
exceptions when we go and call the
advert before the circuit is broken and
also defined a time span here one minute
which subside before the circuit will
reset automatically we've got our advert
here and I've also made this circuit
breaker policy static here as it needs
to maintain account of the failures now
there is a obviously an issue with that
in that discount is only going to exist
for this app domain here so we have ever
across multiple servers there is going
to have their own account here now
pulley doesn't define an easy way of
giving that a different backing store so
it does have some limitations here i'm
going to compile this application and
i'm going to once that's a compiled i'm
going to see better take that too oops
that's time I'll as well have those
that's going to get a bit annoying and
will refresh that and over here or we
shall share that and what I'm doing in
my circuit breaker example is when
there's a failure I'm just going to
print out the message exception has
occurred so we should get a couple of
those before finally the circuit is
broken there we've got exception record
I'll go and refresh that and get another
one and then finally we get the circuit
broken
was that important it means that we can
stop making requests that will never
succeed we can save our resources we can
fail quickly and we can get back to our
users and give them a better experience
you can of course implement that logic
yourself but I do you think pull it
makes it quite nice although the use of
statics it's an ideal so these things
that they've actually got a bit of an
issue though because if you start
combining retrace and timeout there's a
bit of a gotcha that can happen so we
need to imagine we've got a five second
timeout and we said we're going to go
and retry these requests here so i have
three services and so it's a BMC service
i am is going to send a request to
service be service fees going to receive
this request and say oh around two
seconds so if these can send this
request to where service c and four
seconds now service fees got this and by
the time it goes and processes it it's
going to go and send this request backup
the stream here but was we were at six
seconds here here and we said we're
going to try them out here after five
seconds so we've got a bit of a problem
the Conservancy is then going to send
stuff back but they've not interested
anymore because he said I'm going to
climb out after five seconds here so by
implementing this policy we've actually
made things worse because service see
went out of time so services going to
fire off another request at the same
time well this request is still
traveling back from service see what to
do about this one option would be to
pass some kind of exploration with your
requests here because if you start
having these services responds a little
bit slowly then it's going to take a lot
longer and you're going to end up
actually hammering your systems with
this type of setup here trusting input
big security no no and I think the
majority of us we know that any input
coming into api's or systems is not to
be trusted when it's from users if not
the service and talks you should be
attending the disk
friends but where we tend to screw up
and I did this on a project recently is
that people tend to trust input in their
own internal systems so we're working
with some other teams they got some bad
data from external service they then
pass it on to us because they were an
internal service for us we fought yet
that data is all good and we'll take
that and we then have this error flow
down through these services here so
whenever you're developing services by
choice for anyone certainly don't trust
your colleagues they probably screw
something up there be an accident yes
it's going to introduce a little bit
more complexity in your code the
mistakes do happen and if I don't know
god forbid someone gets inside your
network your services more secure so do
not trust anyone any service should be a
standalone and treated as such no plan B
or C I think Netflix really pioneered
this or so many were most public about
how they approach this so most of you
probably know netflix they have this
movie recommendation Olivia TV program
recommendation system which works really
great as long as you use profiles apart
from mines now full of kids programs
because my wife refuses to use her own
profile and forget Jake the pirate and
wiggles and all sorts of things but
anyway netflix has this recommendation
system so when you log into networks it
says hey you might be interested in
these TV shows and their films the first
option they'll give you is a completely
personalized recommendation but if
that's not available they'll fall back
to a list of popular movies if that's
not available they'll give you a fix
list or someone's defined and finally
nothing at all now this is a much better
experience than not being able to use
netflix at all if one system was down in
the chain the problem i found was this
sort of fullback logic it's not a
technical one it's actually a business
one so i found fucking some of our
product owner and so i'd say to them
well ok but what happened
the systems not working or what's the
experience you want and they'll say but
it's got to be working it's going to be
working always and that's bullshit we
all know things fail I'm saying with bad
things that happen so work with the
business and stable okay yes we'll try
to cheer it tough all the time what
about those days it's not do you really
not want people to be able to sign up
for your application or site is there
some other experience that we could give
further users and the answer is almost
certainly yes so yeah not so planning
for success is a major issue so what
often happens is people click on in
commerce sites there might be some kind
of special offer there's been a few
public instances of this with Xbox
preparations launches computer game
launches and they'll fail xiomara Graham
will go and scale of the number of web
servers in order to cope with this
increased demand but what of course
happens with this is that all these
order request change from being a small
amount to this massive amount and our
order processor at the back there can
potentially be overloaded what to do
about this well being potentially shed
load and you could too much load is just
going to ruin things everyone no one's
going to be able to order an xbox if the
entire site goes down so you can look at
implementing various gateways bounded
cues from leaky bucket it's a particular
pattern so you might say I'm only going
to have thousands of orders in a queue
before I'm going to accept any more
people have implemented logics such as
if people don't have entering the basket
they'll be redirected elsewhere in the
site or a session won't be established
until people actually add something to a
basket number of different ways and you
can handle this nexenta pattern I wanna
talk about it is no monitoring and this
is something that tends to happen quite
often is it's something that's added
after a problem has occurred and really
when you're developing your applications
I'd encourage you to write from the very
beginning to be including monitoring in
your applications and one a good thing
to consider is what would you want to
wake you up at 2am in your applications
because of course if you have too many
notifications then it just comes noise
people ignore pages yeah so Kickstarter
they look at what are the number of
pledges as a key metric and they know
that if something changes radically here
that it probably means that some things
have gone wrong in their applications
let's see they monitor the number of
orders Google suggests you should be
always looking at four key metrics the
request latency traffic number of errors
and saturation so at a minimum you
should be looking at these items next
ten Japan assuming it works and as
developers I think we're all guilty of
this one now the lady called KD
purgatory and she now works for Twitter
previously she's worked on their
projects or limbs some of the halo
large-scale systems and she says without
explicitly forcing them a system to fail
it is unreasonable to have any
confidence that they will operate in
failure modes which you could take his
test your shit there's a number of
different ways of doing this we've got
the usual unit integration testing stuff
I think we're all pretty familiar with
Netflix is simian army it will
deliberately turn on and off
applications and services in order to
check that people have coded for these
type of scenarios another thing that's
becoming more popular it's Mary called
game days and this is where you
deliberately introduce a fault or
failure
in your system and check that the system
controller fit and the team and it's a
great way of learning for the team they
get a real-world scenario you check to
your processes and you'll probably
discover some interesting things now
you're gonna have to work with a
business in order to establish when is a
good time to run a game day because you
can imagine the conversation I want you
to liberally break our our system and
check how it works that's probably not
going to go down so well and probably
going to need some careful communication
around that you also get up essentially
want to avoid some key dates so we deal
with accounting data we would not do
that accounting year-end yeah google and
have a system called chubby look which
manages it's a distributed look system
and it's very it's used on a number of
their systems and what they were finding
was that people had come to actually
rely on this always being available so
they've got a bit lazy with some of
their coding here so what Google started
doing was deliberately breaking this
system to ensure that people were coping
with failures of this log system it's
been studied by imran and a number of
other people in 2014 and they looked
about looked at about 200 or so
businesses failures and then to why
these systems were actually failing and
they found a ninety percent of
catastrophic failures which is the
incorrect handling of non fatal errors
seventy-seven percent of production
failures could have been reproduced by a
unit test fifty-eight percent of
catastrophic failures and underlined
faults could have been detected through
simple test either verra handling code
and thirty five percents of catastrophic
failures are caused by trivial mistakes
in error handling logic now this is
stuff that we as developers can be
better this is this is where we're
failing potentially as developers and
themes and it sounds very simple we know
it's not but this is something I believe
that we can do do a bit better
so I work for a company called zero and
I've been with zero probably bear the
loss come on 22 years now we've got just
under 1,500 staff globally and we'll go
about 7,000 paying subscribers and if
we've got a lot of businesses and using
the zero platform this is what it looks
like for those you haven't seen it and
it's got functionality for your basic
accounts payroll and a heap of other
stuff which I haven't come into contact
with I guess text and I got a major
component now zero eight or nine years
ago began life as a relatively simple
application there was a server and a
database now as you can imagine as
customers increased that didn't tend to
scale so well there's a book post down
here by our chief of architecture and he
goes into a bit more detailed I'm going
to see if you want to refer to some of
this so one of the first things that was
done is that we shouted and the database
in order to achieve that scalability but
is that the business grew and grew then
that didn't work either so the model we
have now is what we're referring to this
cell based model now a cell contains
everything that's needed to run the
application and one cell cannot talk to
another so there's also some security
benefits from doing this we can run up a
new cell and relatively quickly as well
one of the really sort of important
things I think is often neglected is
some guidelines so I've taken some
guidelines here these are our service
and our guidelines so anyone developing
the service we suggest adheres to these
77 guidelines here so abstract
everything and your services should hide
the implementation details you should
know about particular technologies
consistency if the service uses a
concept if you go to contact that's
shared across services it should be used
in the same way avoids the
to become quite confusing we'll try and
push a contracts first approach so teams
will talk about how services should
interact before even a line of code has
been written designs Republicans access
any integration will be via events
services should self-managed and seem to
be able to manage the series themselves
and overall simplicity now these are
just a set of some of the guidelines but
i do think these type of guidelines
processes and education in the team to
have a big impact in terms of the
reliability of resiliency of your
application it might be very tricky to
come up with some of these guidelines
but you signified the reactive manifesto
make sure your team members and
developers are aware of them and I think
that's a pretty low cost start we use a
number of monitoring and metrics in
order to check or applications are
running properly we use something called
dialer dog and what it allows you to do
is these can send it various information
and you can construct dashboards and
from this information so for example we
might have counters on a number of
requests or the number of sign ups and
just be sent to data dog and you can
then create your own dashboard and each
team will have dashboards for their
service so they can see what's running
and how it's going page duties used it
is what it sounds like Amazon CloudWatch
measures we use a tool called 23
biologic this is a bit like splunk I
don't know how many people are using
that but it's basically a look query
into on steroids I guess you can perform
a lot of very clever filtering you can
reduce graphs from some of the reports
it's a cultural we have dedicated teams
so that if any issues do occur they
refer to themselves as the sniper and
Bomber Command teams but if there is an
urgent issue of the application these
guys have the knowledge and ability to
respond very quickly to go and fix and
deploy this a colleague of mine called
Hannah gray she's got a presentation
on some of this structure and some of
our learnings from this but we found
this works quite well in the future and
we're moving towards having operations
support in teams some things already
have this sometimes died but it
certainly where we want to be with
that's a sort of knowledge and level of
support will just be encouraging the use
of messages keys and things like pulley
and designing for a rare failure so
what's so potentially the feature of
this well I think I'm a particularly
interesting area is something called
formal verification and this is where
you produce a mathematical model of how
a system should behave now this has been
around in the academic world for quite a
long time now but it's sort of just
starting to creep in server maybe
commercial use Amazon useless and they
found a couple of issues with cs3
components or application so this is in
use in the real world there's a language
called cock which is e oq apparently
there's a tradition it's developed by
some French developers and there's a
tradition to call your languages after
animals crazy French I don't know but
it's free to use probably the main
barrier to entry and why I'm not
demonstrating it to you now is that it
requires a reasonable level of math
knowledge in order to be able to use it
so at the moment I think that's probably
going to be a bit of a barrier to update
for this but it's pretty cool because
you could potentially use this language
and you can this language will actually
generate code as well once you've
adequately described to your system the
various processes which can assist you
I'm designing and developing resilient
systems is there one for Microsoft there
and the Jesus formal verification the
courage fault injection at game days you
know Netflix been talking about fault
injection since probably last four or
five years or so yet a lot of a lot of
applications and people are still not
doing this game days again relatively
cheap link and
but I think you'll learn a lot from your
applications doing this the actor model
this is proving to be quite a good way
of managing and scaling applications
it's a pattern has been around since the
70s but is starting to gain a bit of
popularity and movement now with the
cloud computing and improved computing
their power as a number of sessions as
one on this afternoon on our code or net
if you don't know what these patterns
are well these are frameworks but if you
don't know what these are I'd highly
recommend you attend one of these
sessions because I think these are going
to be a big deal over the next few years
this is a good way of developing some
scalable and reliable applications more
automation intelligence self learning
system systems that see when boundaries
are exceeded and can potentially deal
with some of that failure so putting
together this presentation I've been
really influenced by these two books
which if you haven't read them I'd
highly recommend you do so there's a bit
called release it here it is Java
focused but the examples of simple
enough that you know no developers going
to have trouble reading a lot of them
Michael goes into a lot of detail it
gives real-world scenarios and examples
of failures that occurred on some very
large applications and how they dealt
with them he talks at some of the
patterns that I've spoken about today so
I'd really recommend that book and it's
a relatively short read as well this is
an awesome book site reliability
engineering so Google have an
interesting approach to how they ensured
of applications are always running they
created something called site
reliability engineering group and this
book goes into great detail about
Google's technical architecture which is
really awesome as developers it's I'm
just reading this and like well that's
really cool that tells you know that's
scaled and that's how that's done they
talk about failures that they've had
their they took a failure where I'm
going to our data center gets wiped so
in some good stuff in this book and
there's a lot of learnings about how to
run
processes and their departments as well
I was also interested if we stop by the
add these two people here and can't even
get free she talked some writes a lot
about this stuff her presentations are
awesome so if this is an area that
interests you and kendra we've submitted
all those systems like Twitter the halo
social stuff it's well worth following
their these guys I'm not sure how to
cloud Cisco's maybe you were free to
prejudge than other sure but he writes a
lot about patterns and it's got some
great presentations so if you take away
one thing and from my presentation apart
from hats okay calm it should be that
shit happens it really does no matter
how careful you are with the design and
development of your applications there
are just some Hades that you can't deal
with and the only sane approach to this
is to code with failure in their mind so
embrace fail by all means don't vote for
Donald Trump ogres fit though it breaks
the failure of your air systems is
whatever encouraging you to do because
the failure is coming to your systems
yeah thank you very much anyone have any
questions what do you won't get up with
what did I bulkhead so the question is
what did I bulkhead other than their
friends so our systems will be divided
designed as separate instances scaled up
you know different nodes they won't have
state so there's a lot of different
approaches to bulkhead in so you could
have the separate instances which I
guess most obvious approach if you had
some kind of women like p.m. wear or
whatever you could limit resources so
you could say disservice can consume no
more than I don't know 100 Meg or
whatever
so I guess it's more philosophy and
rather than a physical yes so
technically she knows was it more
physical sharing or theological chattox
I'm assuming a more physical than just
logical sharing of resources and the
projects I've worked on we'd probably
create separate instances I guess oh
well i'll be around the whole conference
they find out any questions feel free to
send me on shoulder thank you very much
enjoy the rest of conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>