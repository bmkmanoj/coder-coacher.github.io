<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Back to Basics: Efficient Async and Await - Filip Ekberg | Coder Coacher - Coaching Coders</title><meta content="Back to Basics: Efficient Async and Await - Filip Ekberg - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Back to Basics: Efficient Async and Await - Filip Ekberg</b></h2><h5 class="post__date">2017-02-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Al8LrBKpZEU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good morning London I'm very
excited to be here I hope you've all had
a great morning so far so is anyone in
here expecting to hear about async and
await in JavaScript ha
I'm sorry to disappoint you but there
will be no such thing as JavaScript in
here I'm gonna talk about async and a
weight in dotnet and how we can be more
efficient so I want to go back to the
basics and look yet what is a
synchronous programming all about how do
we apply that in our programs and what
we need to do to avoid potential
deadlocks and problems before we get
into that I want introduce myself I'm
Philip Ekberg I'm a Microsoft and samory
an MVP which is pretty much the same
thing now that they've kind of the same
company which means that I go around to
places and talk about technology doesn't
necessarily mean that I know how to do
things in the real world so if you do
have any questions please feel free to
ping me on Twitter send me an email I've
also written a book called c-sharp
smorgasbord and since we pretty much got
a full room in here and it's been 5
years since I released a book I'm gonna
give everyone in here a free digital
copy just take a photo and ping me on
Twitter and I'll sort you out and you
also have to leave a green thing out
there ah it's fine if you do want to
leave a red note out there please let me
know why right so asynchronous
programming what is that all about you
know every time I go into a project and
I try to apply synchronous patterns or I
help other developers apply a
synchronous programming I feel like a
fire fighter because every time I add
something is synchronous every time I
change something to be more a
synchronous it's a fire starting
somewhere else a fixed one problem and
then all of a sudden I have other issues
in my program asynchronous programming
is pretty much all about allowing us to
write better applications and we have
tools to do that in dotnet and we're
going to explore those tools and
hopefully by the end of this session
we'll have a better understanding of
what it's all about and how we can build
better apps in dotnet so why do we
bother writing applications and using
asynchronous principles it's pretty
simple we can build applications that
behave better one of the most obvious
reasons for myself is that I want to
avoid unreliable applications an
unreliable application could for
instance like in this case here be get
an android application that behaves
weirdly you press a button and all of a
sudden the application thinks that is
crashing in this case here I'm hogging a
lot of resources on the UI thread so the
OS thinks that the application is
crashing and we can apply a synchro's
principles in order for us to build
better apps and avoid this problem which
pretty much boils down to improving user
experience so you know I want to build
apps that behave better I want to build
apps that are faster I want to build
apps that are more efficient both as a
developer and for the end user so we
kind of want to avoid this crashing
application here but one of the most
common reasons for applying a
synchronous principles is to leverage
all the available resources on our
devices so my machine here I got four
cores with hyper-threading on which kind
of gives me eight course I would
leverage all that and then I have a lot
of memory I have 32 gigs of ram out and
I want to be able to leverage all that
as well as my super fast SSD drive if I
load a file from disk into memory
I want my application to not lock up but
allow me to get notified when that data
is available so leverage leveraging all
these resources means that we need to be
able to use our CPU as well as our
memory which kind of boils down to CPU
and i/o bound operations in dotnet it's
super simple to kind of group these two
together welcome but what we want to do
is that we want to divide these two into
different buckets so CPU bound
operations that's more or less about
parallelization we want to parallelize
our problems which means that we divide
them into smaller pieces and solve them
in smaller chunks for CPU bound
operations it's like loading things from
the disk adding things to the database
going out to the web and doing some
calls
those two are totally different concepts
but in dotnet we kind of use them
together using the task parallel library
and the parallel extension
so there's a very thin line between
working in parallel and working with
asynchronous programming but we can use
these two concepts together so a lot of
the time we go off and we fire off on a
synchronous operation in this case here
I have a mobile application I want to
start some work I press a button and
that goes off and run something in
parallel it could be that it's solving a
problem it could be sending emails it
could be doing a lot of things but the
idea is that I start off an operation
when that operation is done I get
notified that something is completed so
I like to use an example from my book
where I talk about how I can improve
boiling eggs which is funny because I
don't even eat eggs but somehow I want
to improve that process for other people
so think about having a bunch of eggs
that you want to boil on yours though
you have a lot of pots and the more pots
you add the more eggs you can boil in
parallel makes sense right so how do I
make that process asynchronous I take an
egg timer I set that to eight minutes I
put it down and once that egg timer goes
off I can go back and take care of the
eggs I get a notification that the eggs
are now available for me to take care of
meanwhile that asynchronous process is
going on I can go ahead and clean the
kitchen I can prepare my bacon I can do
other things so while I'm parallelizing
the egg boiling I can have that as an
asynchronous process by setting an egg
timer and if we translate that into code
it could look something like this here I
could start off on a synchronous
operation by using the task parallel
library which then goes off and runs
something in parallel
now you wouldn't always do this looking
like this here but this is just an
example of how you would translate that
into code let's not get ahead of
ourselves let's talk about how we go
from being synchronous to be more
asynchronous it's all about taking an
application that's synchronous today we
want to improve that to be more
asynchronous so what what does that mean
it means that we want to go from a
blocking application to a non blocking
application the example that I showed
before with the mobile app crashing
that's a blocking application we're
doing something on the you are thread we
want to avoid heavy lifting on our main
thread or you are threading the
application
in order for us to be able to let the
user do other things if we go back and
talk about the egg boiling process I
want to mention something called never
block your asynchronous operations
blocking an asynchronous operation is
like if we talk about that egg boiling
process I take the egg timer I take it
in my hand I put on my blindfold myself
I put on my headphones so I can't hear
anything and I just put the egg timer in
front of me and wait for it to go off
but how will I know that the egg timer
goes off if I'm blindfolded and can't
hear anything
that's the same thing as blocking our in
synchronous operations so we want the
synchronous operation to be able to
allow us to tell us when it's done and
we don't want to block that from being
able to do so so we can do other things
so most of the times we talked about
going from blocking apps to non blocking
apps which means that we want to take
this application here and we want to
translate that into something that's a
lot better which means that we introduce
another type of blocking we block the UI
from input but we allow the user to get
notified that is currently working on
some data and we can use these
principles like asynchronous programming
in parallelization to do things faster
quicker and do it in the background and
show the user a loading indicator I'm
not saying that blocking the UI in
either of these ways is a better
approach but it's certainly better not
crushing the app right in the left
example here the OS things that we were
doing so much work on the UI thread that
is thinking that the application is
crashing you could of course have
crashed in the other example as well
because we don't know what's happening
in the background thread if the
background thread is crashing that we
running work on we'll see the loading
indicator forever
but as a user I'm more or less you know
I'm leaning towards clicking please
close my app rather than when I see a
loading indicator I tend to wait a
little bit longer so being able to apply
these principles with a synchronous
programming it's pretty much all about
allowing the user to get a better
experience and we can do that by
introducing the task parallel library
how many of you have used it
her library today so almost everyone how
many of you have had a deadlock okay so
no one pretty much raised their hands I
did lock it's just around the corner I
promise you that you have apps that have
a deadlock in them because it's super
simple to get that happening especially
when we introduce a sync in a way you
know efficiency is not only about
building apps that behave quicker it's
also about building apps that are
maintainable we have two different types
of efficiency we can be efficient as
developers and we can have an app that
behaves efficiently so the tax payer
library is about simplifying concurrent
and asynchronous code which kind of
groups these two paradigms together both
asynchronous programming as well as
parallel programming will get this
bucket that we can use to you know use
all these principles which is great so
what's a task all about a task is a way
for us to introduce an asynchronous
process if we write tasks that run and
then we have an asleep on an unused
method here we can start a lot of work
and do that on we don't to say a
separate thread but it's most likely
going to end up in a separate thread but
when we talk about tasks we don't want
to talk about different threads because
we don't know where that is running all
right so what I don't want you to do
here now is go out into your apps and
just wrap all the synchronous code in
tasks got run and have that work at a
synchronous Li because that's gonna end
up giving you a lot of headache and
hopefully after this session you'll know
why so this is simple way for us to just
offload a lot of work we're starting off
in a synchronous operation that's going
to run some work on a separate thread
and then we have a separate another way
of doing this we can say that we have an
asynchronous operation that will in when
it's done give us some data back so the
first one could be just go ahead and do
some work the second one could be boil
my eggs and when the eggs are done I
want to receive those eggs back all
right so let's just have a quick look at
what this looks like and a few potential
problems that we can get when we're
working with tasks so I have a project
here it's a simple WPF app now it's
synchronous programming is applicable to
all types of dotnet apps we can do this
in WPF we can do it with
laughs we can do it in asp.net console
apps WinForms and so forth which makes
it really powerful but it also means
that we need to understand what happens
on each different platform but we'll get
into that a bit more later so all I have
here is a button that lets me run
something I have a text block called
debug and I want to click my Run button
and then have some data added to this
debug window here so let's just look at
the code I'm clicking that button and
what happens is that I I start off an
asynchronous operation and the message
that I'm trying to set on my debug test
text here kind of indicates what's gonna
happen here I'm not going to be able to
set anything on that text box if we run
this app and I click the button the idea
is that I click it I get into this
operation here it runs this task Tron
which starts off an asynchronous
operation this asynchronous operation
tries to manipulate my UI and I click
this here and nothing happens what
happens here is that we've got a problem
because we can know what we cannot
invoke the UI from a different thread so
this is synchronous operation ended up
being in a different thread but I didn't
get notified that there was a problem
normally when we try to do things that
we are not allowed to we get an
exception so where's the exception in
this case I have a reference to the
ongoing operation here so what I can do
is that I can introduce something called
a continuation which lets me check if
the tasks that just completed is faulted
and if it's faulted I can do something
properly right so if we set a breakpoint
in here the asynchronous operation
completes we're getting to a place
called a continuation which which is a
state that tells us that it has
completed we can take care of any
potential results I'll click the button
and we'll see here that it's faulted
and then we got an exception so I want
you to remember this here that when we
get an exception on one of our tasks
that's going to be swallowed by that
task itself so a lot of times we might
have asynchronous operations that fail
silently which means that our app might
look like they behaved like they should
but in fact there's things that might be
crashing on different threads and
different tasks that we're not taking
care of so in this case here what we
would have to do is that we'd have to
properly handle this here and this
starts to get a little bit messy because
now we end up having a different method
here that has to check this task here if
it's falter then we need to go back and
do something else and just gets a bit
messy the proper way of doing this if we
want to invoke the UI if we want to
avoid have this problem up here what we
can do is that we can inside the
continuation for instance we can use
something called the dispatcher which is
something that's available on pretty
much any platform that allows you to do
asynchronous operations it's a way for
us to communicate back with the original
thread so we can talk with it in this
case the UI thread or in you know
asp.net we can use the thread that's
executing our upper our web request so
if I start this again here we'll see
that I'll be able to set that from this
different thread which sets the message
to done so if I use the dispatcher I can
invoke the UI thread which is great so
what I want you to remember from this
here is that tasks tend to swallow
exceptions and we need to validate that
those tasks didn't get any exceptions
and if they did get exceptions we need
to handle that properly but it could end
up getting a little bit messy so in
order for us to streamline the work with
a synchronous programming we want to
introduce more helpers in our
programming language so we want to
introduce async in a waits and we want
to do that because it's pretty hard
working with the synchronous programming
if we need to look at the state four
states for all our tasks and we need to
keep track of all the errors they need
to do all that ourselves our
applications are going to be bigger and
a little bit Messier
even though the task parallel library
has been around since dotnet for and
helped us a lot along the way to solve
these problems it's still not really
there to make our applications be more
maintainable so what they did was they
introduced async in a way which is
pretty much just to contextual keywords
that means that they don't change the
runtime it means that our applications
will just have a different compilation
step so the compiler would see that we
use the async and avoid keywords and
they'll just add a bunch of code for us
and solve all these complexities for us
actually what happens is that they hide
our complexity since it's so hard to
work with a sinking away then
asynchronous programming in parallel
programming it's still complex we just
hide the complexity somewhere else which
means that we still need to understand
this complexity and what it means to add
these different keywords but if they
highly complex view from our apps that
means that we get more readable code
which ends up being hopefully more
maintainable if we apply async in a way
properly in our apps and if we were
doing that efficiently it means that our
apps are gonna be more readable and
hopefully more maintainable but hiding
complexity and a lot of the times when I
work on a program that's applying these
principles I work with developers that
don't always know what to do with the
async and awake keyword for instance
myself when I started out I applied the
async keyword to a method and just hope
that well now it's asynchronous it's
going to be running somewhere else right
that's not gonna happen
which means that when even if our
applications look more readable it's
going to be more error-prone which means
that we're going to end up having more
deadlocks
it's even simpler to get a deadlock with
async in a way than it is with tasks you
actually have to do a little bit of hard
work to deadlock an application when
you're simply using tasks but when
you're using async in a way it's super
simple to deadlock an app and if the
task swallow our exceptions that means
that we might not always know if there's
a deadlock right so what does it look
like adding these two keywords these two
key words are always used together at
least that's the
the intention right I don't always see
them used together but when they're not
that's incorrect you want to use these
two keywords together in the same
context so for instance what we do here
the first thing that we do to make
something a synchronous is to mark our
method in the method signature to say
that the intention of this method is
that it's going to run asynchronously
and how does it know and how does it
work with asynchronous programming if
that keyword doesn't make this method
asynchronous then what does well the
awake you were down here
that's where pretty much all the magic
happens there's a lot of things
happening with both of them but when we
add the awake keyword we are indicating
that there's some asynchronous operation
going on I have a two second delay here
that's running somewhere else it could
be my egg boiling process so what I'm
saying here is that well now that we
have this egg boiling here I want to
pause here and before we go on to the
next step before we do the debugger
right line X here I want to wait for
this egg boiling process to finish so
these two together is what makes it
asynchronous these two together with the
tasks in what makes this magic happen so
I said that it's gonna wait here but
that's not really accurate it's not
gonna be sitting here waiting blocking
the app until it's done it's going to
continue executing the app from where
you call this method so we'll look at
that an example of that in just a moment
to make more to make it like a bit more
clear so the awake keyword kind of
marked something called a continuation
so you saw before where I did the t1
continue with and then I could capture
your any potential problems the await
keyword us the same thing but it also
does a lot of other magic it checks if
there's an exception on our tasks if
there's a problem on the tasks that we
just executed the await keyword will in
fact make sure that we throw that
exception back to the caller or set it
on the task that's currently running but
what it's also doing is that when we see
the await keyword it returns back to the
caller with a reference to the ongoing
operation the ongoing work so that means
that when we see the
a keyword it's going to return back to
where the caller called our synchronous
method and then continue with the next
line after that so there's complexity
and stuff happening behind the scenes
here so remember I said there's no
changes in the run in the runtime that
means that all this logic is bundled
with your app and if you're using this
incorrectly you can end up having a
problem in your applications so what's
the difference between using the awaits
and tasks that continue with accept the
obvious that the exception will be
thrown back to the caller it's also a
few other differences the first one here
we are simply doing continue with and
then we're running out to the debugger
but in that case here if we try to
invoke our UI we would get a problem we
wouldn't be able to do that
it's also looking a little bit more
messy in the second example here we have
the away keyword to indicate that I want
all the code beneath here to be in
something called a continuation but the
cool thing here is that we are now back
to the caller thread so these two are so
different that in the first case we
cannot invoke the UI because we're on a
different thread but in the second one
we are back to where we called the
asynchronous operation problem which
could potentially be the UI thread all
right so what's the bad things about
async in a way what makes this you know
it sounds like it's awesome it makes our
application more readable it hides
complexity that we don't know don't want
to handle ourselves but you know that's
one of the problems it increases the
complexity of the apps and if we don't
have a great understanding of what
happens when we add those keywords for
instance what's generated when we add
the async keyword what happens when we
really away keyword into our method if
we don't know that it's pretty easy for
us to get problems and that's what makes
it hard to master like I've been working
with asynchronous programming for a long
time now I've done a lot of talks about
async in a way and every time I learn
something new every time I tend to
deadlock an app or I do something that
you know I get a fun experience out of
it as well which is great that means
that deadlocks are just around the
corner
so I want to show you this app here that
we worked on so what we could
potentially do inside this app here
instead of having these tasks in here
let's move this over to a different
method so in the example code that I had
what I had was that I had a public async
task Bron async or X is equal to 10 and
then we had a weight task of delay 2
seconds and then we could potentially do
something after this year so let's say
that we want to return some data here so
how do I return something from an
asynchronous method
well task is a generic type so I could
say that when this is done it's going to
return a string and we can call this up
here I just want to prove a point here
when we call this here now what happens
is that first is gonna run run async
it's gonna we click the button it goes
in to run a sync it declares the
variable X is equal to 10 it sees that
we are now using the await keyword we
start off on a synchronous operation
that'll run for two seconds and then it
says here that well I don't wanna do
anything after this line until you are
done so what happens it goes back to
whoever calls this method it goes up
here and then it goes to the next line
and once it's completed once those two
seconds are up it'll come back and it'll
set the value hello world as they were
resolved on the task that we're
returning here all right so this is
normally where people start to get a
headache and that's totally fine so in
order for us to get the value hello
world here so I don't want to continue
to just this line down here in order for
us to get the value out of run async I
need to introduce another la keyword
that means that I need to mark my run
click here as async and I'll wrap this
in a trying catch block does anyone know
why I wrapped this in a fried catch
block because I don't want to throw any
exceptions so the reason I do that
seriously is though because this is
marked as async void and I'll show you a
sneak peek off the state machine soon
how did you just say that oh sorry yes
so the reason is because it's acing void
and I'll show you the state machine
later on and what happens so to get the
value out of run a sink now I'll have to
use the awake keyword so when I use a
wait here I mark a continuation which
means that it won't continue doing
anything else before it gets that value
and once the task is done what their
weight keyword here will do is that it
will validate that we had no exceptions
so if we throw an exception in here
it'll know it'll see that and we would
be in the catch block here right
it also fetches our result from that
asynchronous operation so the weight
keyword does a lot of things for us
which is great and now I could say debug
text sequel to result because remember
that we are now back to the collar
thread so hopefully if I run this here
after two seconds it should say hello
world right so I didn't have to
introduce any dispatchers I didn't have
to do the dot continue with I just had
to get an understanding of what happens
when right I had to understand what
applying the async keyword does and what
using the await keyword how that changes
our application but the cool thing here
is that I don't have to worry too much
about cross threading
alright let's talk about the state
machine so the state machine is pretty
much what's making all the magic happen
that's where all the great things goes
all the complexity goes into the state
machine and that's also what makes this
application a little bit more fragile so
state machine is pretty much like a
child when you're going on a long
vacation you're sitting in your car
you're driving somewhere and you have a
child in the backseat asking you are we
there yet that's pretty much a state
machine so the state machine keeps track
of what we're doing when we're doing
what and it's continuously asking us if
we're ready to go to the next step
it's nagging our application all the
time asking us are we done yet with this
asynchronous operation it also handles
potential errors and results which means
that inside the state machine what
happens is that it will actually capture
any exceptions that are being thrown
inside a task and it will know how to
handle that properly it also takes care
of executing the code after the away
keyword so it's executing all the code
in the continuation block all right so
that sounds pretty cool so how do we get
this state machine this state machine is
generated when we apply the async
keyword so whenever we mark a method as
async it pretty much takes the entire
method body of that method and moves
moves it into somewhere else
and applies a lot of complexity to that
code so I have this example here this is
pre compilation so this is something I
wrote in Visual Studio I have this
method marked as being async I have some
continuation down here at the bottom
which is writing out something to debug
the right line now when I compile this
here normally we can just open this up
and reflect or and have a look at that
and that's exactly what I did here so
what happens was that it changed the
entire behavior of my method see here
that it removed the async keyword from
the method signature because we can note
we cannot change the calling convention
right because we cannot
change the the runtime so only something
that changes during compilation it
introduced something called run async D
underscore in school one which is the
state machine so we instantiate it's
that and creates a reference to the
state machine and then here at the
bottom we return a task this is a
reference to the ongoing work so I don't
know if you noticed but in this case
here we don't have a return statement
and up until now I didn't mention why we
don't have a return statement it just
magically compiles and that's because we
have the async keyword so as soon as we
add the async keyword will automatically
get a task returned as we can see here
at the bottom so we get a reference to
the ongoing work in the state machine
alright so if we're taking deeper into
the state machine it's running sort of
an internal loop it's checking if we're
done with the asynchronous operations
and if we drill into that we'll get into
some code looking like this here so this
is in fact the code that we had in our
run async method we can see here that we
have the task a delayed starting that
off we can see that it has the X is
equal to 10 on the line above that so
it's moving all our code and it's
splitting up into smaller pieces and
putting it in the right place inside the
state machine if it's not completed it
goes out to the outer loop and runs that
again and asks us again if it's done but
then when we are done when we are
finally ready to handle the result when
we are in the continuation we are back
at the line at the bottom so there's no
magic here there's nothing going back to
the color thread there's no references
to the caller thread here so how come
this runs on our UI thread it's because
the entire state machine runs on the
thread of the caller which means that if
the UI thread spawns off in a
synchronous method if we mark something
as async that entire method will run on
that thread right so keep that in mind
this entire block is executed on the
caller thread that's super important and
we'll see why soon all right so async
void
it's a problem so I like to talk about
how I stand in line to get an ice cream
during summer but being from Sweden and
now being in London most of us don't
know what a Sun looks like or we're
going to the beach for that matter but
acing Foyt it's like let's just imagine
just imagine going to the beach is a hot
day you're standing in line for 40
minutes with your kids you're trying to
get an ice cream
you're the last one in the line you buy
the ice cream the truck closes drives
away and then you drop the ice cream in
this end that's how I feel every time I
see a scene void I want to lie down and
cry because it hurts my feelings so is
it really that bad well obviously
because I want to lie down and cry but
if we look at this example here
we're doing an async void run async what
could be the potential problem here if
we compile this here it'll end up
looking something like this here it
looks pretty much the same like the
other one that we D compiled the only
difference is that we no longer have a
task that's being returned here there's
nothing that returns anything at the
bottom here and internally it's using a
totally different way of creating our
state machine it's using something
called the async void method builder
which is a separate way of creating the
state machine for a void method so why
is this a problem why is it a problem
that we don't get a reference to the
ongoing work if we don't have a
reference to the ongoing work how would
we know if there's a problem how do we
know if there's an exception you know if
I ever buy a car that's written in
dotnet I want to make sure that they
don't do a sync void because we'll end
up like this here so let me show you
what happens look at these two we have
these try-catch block here we're calling
run async this application works right
what happens if we let's just remove the
return from here so and still call that
method
so we'll simply do a wait run async and
inside run a sink we're gonna throw an
exception and I'm gonna mark this as a
sync point does anyone know what's gonna
happen now first thing is that you
probably know what's gonna happen first
thing is that I can no longer use their
weight keyword that's problematic so now
I have no way of saying well I want to
wait for that operation to run but since
the method signature doesn't indicate
that it's an asynchronous operation I
have no idea that it's asynchronous I
have no idea that it's now something
that's gonna run somewhere else so we
have to remove the await keyword first
all right that doesn't seem too bad
right I'm wrapping that in a trying
catch block how about we put a
breakpoint here and see what happens if
I run this I'm gonna click the button
and I got an exception that's great but
the application crashed let me run that
without debugger look at that the
application simply crashed which is a
bit problematic I have the method I have
the method call inside a try-catch block
but there's no way for me to catch the
exception because this is marked as a
Seng void what happens is that inside
the state machine it sees that we don't
have attached that skirt there reference
to the ongoing operation so what's the
next best thing to do well let's tear
down the application let's tear down the
app domain there's no way for us to
recover from this so if you mark
something as a Singh there's no way for
us to catch those exceptions so why
would we allow us to do a single it's
because of event handlers because we
can't go ahead and change all the
delegates for all the event handlers
right so the problem is we have no way
of catching those types of exceptions so
how do we make sure that we don't throw
any exceptions in here don't do too much
things inside your event handlers
because if you have like you handle on
handle exceptions in your app you won't
be able to catch that either which is
problematic so just make sure you build
applications that never throw up throw
any exceptions if you have to use async
Boyd or it's probably easier to just
avoid 18 Boyd right so the way that we
fix this is simple we simply change void
two tasks but then what happens is that
we need to avoid that in the caller
because now we change the behavior of
the app all right let's talk a little
bit more about efficiency how can we
build apps that behave a little bit more
efficient and how can we be more
efficient now that we have an
understanding of what is asynchronous
programming how do we apply that in our
applications what's the difference
between using continue with and using a
wait how what does the state machine do
internally we can probably think a
little bit ahead and think about the
efficient parts of async and waits so
one way to be efficient is to avoid
deadlocks so remember before that I said
it was probably
a little bit easier before to make
deadlocks sorry it's easier now to do
deadlocked prior to a sinking away it
was a little bit more difficult you have
to do a little bit of work here
something a bit of an example so in this
case here I'm simulating a one
millisecond worth off load right so I'm
doing some work for one millisecond
after that I want to continue with
something
dispatcher here tries to invoke the UI
notice this one here at the bottom so
remember before I said it's important to
remember that the state machine runs on
our color thread and we'll get to that
soon but in this case here we're
blocking just as if this was running on
the UI thread right so here we are
blocking our UI thread and then we're
trying to invoke our UI thread actually
what's doing is that the white key word
here will say I want to force us to wait
on this thread until the asynchronous
operation is done the synchronous
operation says well I can't be marked as
done until I can communicate back to the
UI thread which kind of ends up in a
deadlock we're locking the UI thread
until it's done and it's trying to
communicate with the UI thread to be
completed all right
so this looks a bit tedious how many of
you have seen this before probably not
so many but with async and await all we
need to do is this so why is this a lot
easier with async and await isn't it
supposed to be harder to get bad
applications with async in a way in this
case here what we're doing is that we
are starting off our run async method
remember the async furnace state machine
for the async operation is running on
the color thread this loop that's
continuously asking us if it's done it's
running on our color thread and then
we're blocking the color thread they're
blocking the same thread that executes
the stake machine so whichever task
it's awaiting inside itself cannot
communicate back to tell us that it's
done which means that we end up in a
deadlock
and there's no way for us to recover
from this so what do we take away from
this never use the white keyword never
do dot result never do dot way never use
task cut wait all for instance if you
have void those things you'll have a
harder time getting a deadlock okay
so don't you wait another thing I like
to talk about when I mention efficiency
is the overuse of unnecessary state
machines that sounds a little bit weird
so imagine this case here this is a
legit code here that I'm working
something as async returns a task I have
a continuation it's calling some
internal method that's being marked as
async I have this other thing that's
also waiting something that's being
async which is that in its turn awaiting
some things that being async which in
its turn is yeah you're the drill what
happens if we do this well probably not
something good so I have that code in
here exact same one I have a run a sync
method here which calls something
internal which is mark as a sink which
is calling something that's mark is
async they're all using the async and
Away keyword if I compile this here I
set that start a project gonna go ahead
and go into reflector and hopefully I've
got this loaded here at the bottom so
we'll see what this looks like now I got
a state machine for run async which
makes sense because we have a
continuation we need to invoke the UI or
do something in that method but then we
have a state machine for running turtle
and something async in something
internal async
so the problem here is that each of
these methods in here they all got their
separate state machine we've got a state
machine here because we mark this as
being async we've got a state machine
here because we marked this as being
async so why is that bad if we run this
on our desktop application or in asp.net
we probably wouldn't bother changing
this or fixing this because it wouldn't
impact efficiency
but when we run this in salmon for
instance or in a mobile device every CPU
cycle counts every time you run a line
of code that's gonna drain battery so we
need to think about those things when
running on mobile devices so what we do
here how do we change this to be a
little bit better well we can first off
we can start by removing the async
keyword but now we broke something
because now we can't compile because we
have the await keyword so how do we fix
this without changing our signature or
changing the behavior we replace a
weight with return so all we do now is
that we move our tasks to the caller so
the caller can now await this task by
itself and then we do the same thing for
all of them except the first one all
right so I'm gonna return all of them
which is pretty much gonna be the
exactly same tax actually say the same
task instead of having three different
or four different state machines that
each of them take care of their internal
tasks and work with those pretty
expensive operations I only have a state
machine here at the top which is run
async because the only time you want to
use async in a wait east when you do
something in the continuation when you
do something after the away keyword
otherwise you can just return that task
through the caller if I compile this
here go back to reflector all of a
sudden we only have one state machine
and all of the other ones are just
calling or just returning those tasks
because remember each of the state
machines introduces complexity and they
make it harder for us to work with them
so if we don't need to do anything
inside our inside our continuation we
don't need to use they await keyword but
that doesn't mean that we shouldn't
return the task back to the caller so we
don't want to break the chain right we
don't want to call something that's
asynchronous and then all of a sudden
that thing blocks whatever it's calling
down the line so we want to do a sync
all the way which means that if we have
an asynchronous method at the top or at
the bottom we want to return that task
all the way through the phone
so this is what the complete example of
that would look like all right another
thing that I'd like to talk about when
talking about efficiency is how we
cancel tasks cancellation is something
that I often think that it's left out or
talks about async imagine that I have
this long-running operation here it's
combining a little a few different
things
it's a while true loop the idea is that
we want to run this on a different
thread or a different context it's gonna
run forever and they we have a
dispatcher here that invokes our UI
pretty much as increments or shows us
the ticks right and then we await
something for 500 milliseconds in each
of these iterations how do we cancel
this task here when I call this
operation here what I could do is that I
could pass something called a
cancellation token so in this case here
are I create something called a
cancellation token source that lets me
indicate to a task that it should
complete whether to cancel so what I'm
two years did I start off an
asynchronous operation which wraps my
long-running operation async what this
is doing is that since this method here
if you go back here this is Marcos async
which means that we have a stake machine
it's running a state machine for this
entire thing because we have the awake
you were down here at the bottom
wrapping this with a task like I'm doing
here takes that state machine and runs
it on a different task hopefully a
different thread alright and then I'm
passing the cancellation token to that
as we see here at the end so I'm passing
the cancellation token which lets me
call cancellation token don't cancel so
how many of you think that by just
calling this here it's gonna cancel the
operation one that's excellent because
nothing's gonna happen so why is nothing
happening well imagine what would happen
if the framework allowed us to just
cancel an operation like that like how
does he know where to cancel if it's
currently invoking the UI and we press
or
do cancellation token got canceled how
does he know where to gracefully cancel
this operation
you wouldn't know right we have to
manually check in here if the
cancellation token has to cancel
requested and what we could do if we
notice is that there's a cancellation
requested like I'm doing here we could
for instance rollback data we could say
that well if you cancel here at the
bottom let's say that we just added a
record to the database and then all of a
sudden you go ahead and cancel our tasks
we could roll back the changes in the
database all right
this brings me to something I like to
call smart cancellations
this is kind of the mobility edition so
what I've been doing lately is I've been
working on a stammering project where we
don't wanna block the UI pretty much at
all we want to allow the user to always
enter data into the app but we want to
wait until the user is done so how do
you do that well you could for instance
fire off a task so let's say that you
press a button and then you fire off a
task to say after 400 milliseconds for
instance I want you to go ahead and go
off and call our web server but if the
user presses another key we cancel out
the running tasks right so that means
that if the user keeps pressing buttons
we'll just cancel all the tasks all the
time of course it's going to be a little
bit of overhead because you need to fire
off a task and then cancel them and so
forth all the time but it's a smarter
way of doing cancellations so let's have
a look at that so first of all I do have
a little bit of an example here on
windows for cancellations so let me run
this project so I can click run here and
it's gonna print out all the ticks it's
the same example that we saw before and
when I click cancel
crashes shouldn't do that let's just
imagine that it worked let's have a look
at the code so I'm doing the exact same
thing here like we saw in the example it
passes down to cancellation token it
lets us throw the
exception here if it's being canceled
and I can catch that in here so it's
probably not all right so it's passing
that down to that operation so when I
click cancel
it's simply calling cancellation token
cancel and then what we can do is that
when we call this run async method here
and we click the Run button we can
capture any exception so we can capture
these tasks cancel exceptions so we can
then roll back data so the idea here is
that you start off on operation then you
click cancel and you can capture that
that cancellation just repose we're just
requested all right so let's just go
ahead and have a look at what this could
look like on Android instead I'm gonna
run this off so I'll show you the code
first because the end word emulator he
needs to start off so the idea of smart
cancellations so what I'm doing here so
what I'm doing when you start pressing
some data I'm starting up a task delay
some way time allowing the user four
seconds for every keystroke it could be
a slower user we could for instance
lower that to 400 milliseconds what
happens is that each time I press a
button I want to cancel ongoing tasks
right so if we have a look at what
happens I have a text field called some
user data when the text changes I call
cancellation token stores that cancel
that's the same cancellation token that
I passed to my task delay right so that
means that every time the user presses a
button I can go ahead and cancel these
tasks so if a that has a start a project
we'll see if this runs
all right so I write some date/time text
in here you can see here that it's being
cancelled and then after four seconds
hopefully it says something else in here
all right
so every time I press a key here it goes
off and cancels my running tasks I'll
only have one task running at the time
at one time and the way that I'm
checking that if I need to start off a
new task is that I'm first checking if I
have a task that I have a reference to
that ongoing operation I check is it
null is it canceled is it faulted is it
completed if I've already done all the
data if I've done the request to the
back end and the user starts pressing
data again of course I'm going to
restart and send off that operation
again but this is what I like to call
smart cancellations so in this way here
we've built an application that allows
us to let the user work with the app
without popping up dialog telling them
that well you have to wait for the data
to load or you know adding a button to
start lower the data from the web or
send request we can we can in a smart
way find out what the user wants to do
all right one final thing that I want to
talk about is asp.net asp.net as I
mentioned before allows us to use the
asynchronous principles as well we can
do parallel programming in asp.net we
can do asynchronous programming asp.net
doesn't it really isn't that much of a
difference between asp.net and you know
working with any other type of app one
thing that I want to get out of the way
straight away though is that but simply
marking something as a sync in asp.net
doesn't mean that we make the client
asynchronous right doesn't mean that it
introduces Ajax by default might seem
obvious but it might not be so in this
case here I have a simple web
application I have a simple index action
here which is marked as being acing
which means that we need to render a
task whenever we use the async keyword
we also need to return a task and once
this task has completed we get an action
result
so why would we be able to do this if it
doesn't mean that decline becomes
asynchronous it's about relieving
resources from iis and letting the
server work on more things at one time
right if I run this here we'll see here
that hopefully after a little while it's
gonna say okay and all the code did was
that it said run async which is a
waiting and a synchronous method that
I'm calling in here which is just
delaying for one sec one millisecond I
could change this to three seconds we
start the app and then of course it
would take three seconds before we see
that okay text up here at the top you'll
also see that it's still loading the
website right so doesn't make it a
synchronous by default on the client
it's just a synchronous on the server
now it's also super simple to deadlock
in asp.net it behaves a little bit
differently than in a mobile app because
what you can do is you can just click f5
in your browser and it goes off and
performs a second web request so it's a
little bit different but the idea is the
same
so what we do here if I change this back
to one again just to prove that it's
quicker what I have here is I have a
method called deadlock deadlock calls
run async and then simply calls dot wait
and doing that is a big no-no because
that means that the thread that is
currently processing our web requests
will wait until the state machine is
done but the state machine is running on
that thread right so it cannot can never
be done so if we call slash deadlock
oops slash home deadlock it's good it's
just gonna sit here and load forever
because it's now deadlocked but if we go
back here I can still refresh this page
because it's two different threads
handling that process so after a while
is we'll probably terminate this process
but you never know I do like to show you
how you can block if you really want to
but you should never do this at home
so you can do is that I kind of hinted
this before but what you can do is that
you can take the state machine and run
that somewhere else and block the UI
thread and the way that you do that is
by introducing a task that run like this
here and then simply call wait on that
task itself so if I run this here it
shouldn't deadlock but what happens is
that we take the run async state machine
we run that somewhere else and when
that's completed it's going to notify
this task here that it's completed and
we are blocking the UI thread until this
task is done and that task can get a
notification because it's not being
blocked make sense yes so your question
is is it better to use configure our
weight falls yes always in asp.net so
what happens that's a very good question
so what happens is that in asp.net I
don't know if they've changed is in core
but I don't think they have when you use
async and await in asp.net what I do is
that I try to get back to the color
thread but in asp.net we don't really
care about the main thread or the UI
thread so what we can do is that we can
use something called configure await
false which says that whenever you
return into the continuation we don't
care which thread you use on the thread
pool which means that the applications
are going to be faster because it can
just pick any thread available in the
pool all right
so unless you want to be the firefighter
I do recommend that you do acing all the
way down so make sure that whenever you
use a sink in a way have a sink in a way
all the way down return tasks from all
your methods which will make it a lot
easier for you to work with it is
problematic debugging asynchronous
programming because it jumps around to
different threads and jumps around into
different contexts but once you have an
understanding of what happens in the
state machine you shouldn't have to feel
like the firefighter anymore and if you
want to learn more I have a course on
Pluralsight which you can check out
which goes into this a little bit more
in detail and it's a little bit slower
so hopefully you wouldn't get a headache
alright let's wrap this up so what we've
talked about is that we can introduce
asynchronous programming in our apps be
console applications or WPF applications
or WinForms applications or web
applications we can use the same
principles as long as we understand what
the state machine is all about what
happens when we introduce the a Sinkin
awake keywords that's all that we need
to do to make better and more efficient
applications and if we have a better
understanding of how to apply these
principles and how to work with these in
different contexts our apps are going to
be a lot better all right thank you so
much for listening to me please do
remember to ping me on Twitter if you
want a copy of my book and don't forget
to vote on your way out thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>