<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Asynchronous Programming From The Ground Up - Filip Ekberg | Coder Coacher - Coaching Coders</title><meta content="Asynchronous Programming From The Ground Up - Filip Ekberg - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Asynchronous Programming From The Ground Up - Filip Ekberg</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bda13k0vfc0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right I think we're ready to get
started so before we get started I just
want to warn you that I have been
feeling a bit under the weather the last
few days so if I fall off the stage I
want you all to just remember to go
slowly outside put a green thing in the
box and just forget you ever was ever
here all right deal
great so we're about to talk about a
synchro's programming from the ground up
in PHP sounds good okay now it's dotnet
I promise so before we get started I'm
Philip Ekberg I used to live in Sydney
but now I'm back in Sweden I don't miss
the slow internet here but I do miss the
awesome weather and it's true that in
Sweden we do have a lot of polar bears
roaming the streets just as we have drop
beers in Sydney all right so what I want
you to do is that bring your cameras up
take a photo of me doing this talk ping
me on Twitter and I'll send you a free
copy of my book sounds good the digital
version you have to buy the one in paper
all right let's get started so a
synchrony is everyone in here a dotnet
developer excellent so I imagine that
for the last few years we've all
probably done a ton of asynchronous
programming you'd be using the async and
await keywords you've done the TPL using
tasks the parallel extensions and all
that but a lot of the times we feel like
things just fall apart you feel like the
firefighter you just add a lot of these
keywords and the application might work
for the most of the times it does work
really well but then you're running to
these problems where the app deadlocks
and if you've never experienced a
deadlock it's probably because you've
left the project before it even run
right so a synchronous programming is
really hard the idea here is that you
know we want to build applications that
perform really well
so I'll take you through what we want to
use a sequence programming for how we
apply that in ducted applications and
how we can understand the state machine
and everything that goes into these
applications so hopefully when you go
out of here you've learned how to avoid
deadlocks but you know why bother
asynchronous programming at all what's
the reason for us wanting to introduce
this in our applications like the main
reason when we first started doing this
was to you know avoid unreliable apps an
unreliable application can be like a
website that loads forever it could be
in this case here it's a mobile app
that's telling us that well this
application is not it's not responding
the problem here might not be that the
app actually crashed it could be that
the OS thinks that well your application
is doing a lot of work in the wrong
place so therefore I'm gonna tell the
user to kill it right so we want to
avoid this here and we've got patterns
and principles to allow us to build
better apps using async and await and a
lot of other cool things in the.net
framework that allows us to avoid this
here so ultimately we're here to improve
the user experience and the way that we
do that is by introducing async and
await and doing that properly and of
course you probably want you books
personal UX for you but we are
developers and we want to focus on
building fast apps that are reliable so
the way that we do that is by leveraging
all the resources available to us in our
applications so in this case here I'm at
my workstation at home I got a course I
got 32 gigs of RAM and I got a ton of
hard drives so leveraging all resources
mean I want to be able to use my disks I
want to be able to use my memory I want
to be able to use all the cores but
those are all different paradigms so
when we talk about leveraging the
resources we talked about CPU and i/o
and we work with these two different
things separately so if we want to work
with CPU bond operations we work with
parallel programming we take a problem
we divide that into equally small pieces
and we solve that on each core and we've
got parallel extensions to help us do
this so that allows us to just say take
this problem solve it for me divide that
across all our different course and
it'll figure out how many threads to
start it will just let us solve our
programs for us which is great and then
we've got IO so I oh is a little bit
different we might have an application
where we want to say we'll load this
large file into memory when it's
available in memory I want to be able to
consume that far
in my application so what happens is
that we introduce asynchronous
programming which allows us to say for
instance when this thing here is done
notify me so I can work with that result
so those two are really fundamentally
different the parallel programming
allows us to just solve a problem as
quickly as possible while it's synchro's
programming allows us to offload some
work somewhere and be notified when we
are ready to handle the result so when
we work with parallel programming we
could be using the parallel extensions
we could be saying that in this case
here I want you to iterate from 0 to 100
and do that with all the available cores
so that's great but we're here to talk
about a synchro's programming so how
about we have a phone for instance my
phone here probably got more coarse than
my my first computer I've got the latest
Samsung Galaxy s8 it's like a hexa core
machine it's it's really powerful so if
I run stammering and dot bet on this
thing here I want to be able to leverage
all the available RAM I want to be able
to use all my course and if I take the
same dot in this library and run that
across asp.net or if I run that you know
on my workstation at home I want that to
leverage all the different types of
architectures that I might be running
the code on so in this case here we have
this parallel extensions and I want to
combine that with asynchronous
principles and the ax synchro's
principles allows us to say start this
work and tell me when it's done
so we can combine these two different
paradigms rather easily so one of the
times you might see this being used here
is in in this case we have a mobile
application we're simply saying I want
you to start off this asynchronous
operation and this asynchronous
operation might have something parallel
that's that it's executing itself so we
are starting this thing here it's using
parallel extensions in that asynchronous
operation it's easier if you look at the
code right so in this case here I'm
simply saying well start off an
asynchronous operation tasks that run
here is in the TPL it allows us to start
off an asynchronous operation and then
we can subscribe to notifications when
that's done and inside this asynchronous
operation we are running this parallel
dot for loop what's interesting about
parallel
for is that it'll actually lock up the
application unless you did this because
it's leveraging all the available
resources which means that it's also
going to make use of your UI thread
which makes sense so when we talked
about asynchronous programming and
making an application more asynchronous
we're talking about going from an
application that's synchronous to
asynchronous that kind of makes sense
right but we can also look at this as
we're going from an application that's
blocking code to a non-blocking
application so in our first example with
the mobile app it told us that the
application is crashing but actually
what's happening in the mobile app is
that we are blocking the working thread
of the application so there's one main
thread running most applications we have
the UI thread for winforms WPF sermon
apps there's one thread in asp.net
application that's handling our requests
if we're blocking that it means that
we're gonna have a really bad experience
for whatever is using that thread right
so what we want to do is that we want to
go from blocking to non blocking and the
way that we do that is by avoid heavy
lifting on our UI thread it kind of
makes sense and in this case here all we
can do is that we can introduce this
task Gudrun and something just runs
somewhere else right but we can try to
understand why we get deadlocks I'm
saying here that we should never do if
you're gonna block our synchronous
operations and I'll try and reiterate
this a few times blocking an
asynchronous operation means that we
were saying I want to wait until this
thing is done so just imagine for a
while that you are the main thread you
are delegating all the work and looking
over your rest synchronous operations
and then all of a sudden you just
blindfold yourself and you have no
longer any idea of what's going on you
can no longer keep track of your
asynchronous operations so blocking an
asynchronous operation means that we can
no longer look over our asynchronous
operations there's no way for us to know
if they're gonna be done which results
in a deadlock and we look at some code
later on and once we look at the state
machine and what's happening internally
when we apply us you can wait you'll get
a better understanding of why the
is a problem so ideally we want to take
this application the application that's
even the user a pretty bad experience
that's blocking the UI and introduce a
loading indicator that's also blocking
the UI but what's interesting here is
even though these two things are clearly
doing the same thing they're no longer
allowing the user to do an input the
user is more inclined to actually close
the app in the first one because the
user doesn't know about internals right
there are more leaning towards just
waiting for a little while longer if
it's loading especially if they've done
a lot of work in the app so we want to
avoid having the user close our apps
even if some if even if in some cases it
actually deadlocked and to do that we
introduced the task parallel library so
the task parallel library allows us to
simplify working with concurrent and
asynchronous code so concurrent code
that's parallel programming and
asynchronous code is this a way for us
to run something concurrently and then
get notified when that work is done so
if we look at this TPL we saw a little
hint of that before and most of you have
probably worked with tasks so this task
here allows us to start up some
asynchronous operation imagine that we
have a lot of work that needs to be done
and we simply want to be notified when
that's done so the most simple way for
us to start this work is by saying tasks
that run do some work somewhere else so
you simply pass a delegate to this here
and it just executes that somewhere else
in some cases that we want to return
some data from this as well that's where
we introduce the generic version of the
task and we were allowed to retrieve
values back from this now when we want
to subscribe for what results we get
from here we introduce something called
the continuation so this is where it
starts to get a little bit more
interesting because most of us have
probably seen this and think well I
already know all this but when it comes
to the continuations that's where it
becomes a little bit more interesting so
we can subscribe to when this is done
here by introducing a continuation by
saying well I want you to continue with
this block of code when you're done now
when does this run here so does this
draw
if there's an exception in the task does
this run if someone cancelled the task
or does it only run when there's
actually a value that we can use the
continuation runs in all different
scenarios so if you cancel the task if
it's faulted if it's completed it runs
all of those different scenarios so when
you're inside the continuation here you
probably want to check if it's actually
completed all right so a lot of cases I
see that
well we're inside the continuation so
everything probably worked but that's
not necessarily the case so in this case
here I'm just referring to the task
outside of the scope to check if it's
completed but we can also get that task
passed into this delegate so what's
interesting here is that we can work
with this here and we can check if the
task is completed if there's a result
available you get that by doing T dot
result two tasks that result but you
should only use tasks that result once
you're inside the continuation now I'll
show you why in a little moment but just
to take a look at this in another
scenario so imagine we have this WPF
application I'll be showing a lot of
demos in WPF but the same thing applies
to asp.net mostly console applications
samer in WPF WinForms and all the
different types of dotnet apps that
you're working with so in this case here
we have a WPF application in the
constructor I'm simply saying well I
want you to simulate one millisecond of
work so what we're doing here is that
I'm simply doing a task deal I for one
millisecond now what happens when the
user clicks the button in this case here
the task is clearly completed but I'm
telling this here that I want to
subscribe for the continuation after
it's actually completed so we'll this
here execute how many of you think that
this code here will execute excellent so
let's look at the code behind this here
so it doesn't matter if you can't read
everything in here so this is from the
reference source you can go into the
reference source Microsoft comm and you
can drill into the dotnet framework and
there's comments for everything for the
entire dotnet framework it's really
handy
so what we can see here is that at the
bottom here it's saying well if the
continuation was not previously cued
we'll just execute the continuation
right so if everyone in here now
expected that the code would actually
not execute you'd all have a bug in your
rap right so let's look at a bit of
tasks let's look at how we can work with
this here so I'll jump into Visual
Studio 2017 is everyone in here using
the latest version of facial studio if
you're not I can highly recommend it
because it's got a lot of features when
you're looking over your tasks
especially if you work with a
synchronous programming you can see all
the different tasks that are currently
running you can see threads that's being
allocated and you can see if there's any
problems in those tasks as well so the
idea here is that I have not WPF
application I've simply set up a task
here I'm doing tasks that run and in
this task of running I'm simply doing
thread dot sleep now threaded sleep just
just you know sleeps the thread that is
currently running on which indicates
that task that run is running in a
different context and then after that
we're simply returning hello world so
let's just run this app here and just
make sure that we've set the right one
as a sort of project we're gonna look at
a bit of asp.net later on as well
because there's some really interesting
cases when working with a asynchronous
programming in asp.net so I'll click run
here and after two seconds we can see
here that it says hello world and if I
click this again here you'll see here
that I can move around my window while
that is actually you saw that I couldn't
front it moved around the window here
because we have teed up result here at
the bottom so the problem here is that
I'm simply saying thread out sleep and
I'm clearly sleeping on a different
thread so what happens here is that we
start off an eye synchronous operation
that asynchronous operation tells it to
sleep in that context so it locks up the
thread that is currently running on but
then what I'm doing here at the bottom
is that I'm blocking my my code from
continuing because what's happening here
is that I'm saying will give me the
result of the task and when is the task
available
well it's available after two seconds so
it'll block our application here and if
we do this for a longer time like 20
seconds maybe 30 seconds windows will
think that the application crashed and
it'll tell us well you should probably
terminate the app on mobile apps that
window of when the OS thinks the
application should no longer be
executing it's much smaller so if you
work with salmon you'll notice that if
you don't do this properly if you do
that T dot result or T dot wait you'll
have a much worse experience with the
app so how do we solve this well one
thing that we can do is that we can
introduce the continuation that I talked
about so I can say well when this task
is done I want to continue it with with
something else and in here we want to do
exactly the same thing so we can skip
that task for now what happens if I just
paste this code in here and run the app
so clearly what I'm saying here is that
well after 2 seconds I simply want to
set the result text to whatever gets
back from that task
so if I click run here and move the
window around it doesn't lock up anymore
which is great but I'm not getting
anything in here it's the problem here
is that the continuation just as our
task runs in a different context so it
runs on a different thread which means
that we cannot change the UI from a
different thread that's basically why
programming so if you have two threads
one is the UI thread and one is some
other thread you can't cross communicate
when it comes to the UI so the way that
we need to solve this is to use a
dispatcher to invoke the UI and change
the UI from that but what's interesting
here is that we didn't get an exception
because the task actually swallows any
exceptions and we don't validate our
tasks in here so how do we validate the
task one way to do it would be to do dot
result but we can't do that here because
we're not returning anything and we
should never do dot result because that
walks yep so the way that we can do this
is that we can introduce another
continuation to check if this one worked
so we can say well when the continuation
is done which is also an asynchronous
operation sort of we can say well I want
you to continue with this block here
this is where it becomes a little bit
nasty working with TPL and the way that
we did a synchronous programming prior
to async can't wait so now I can in here
say well if t2 is completed or is
faulted well how about you just tell me
that and you give me the exception it's
not a breakpoint in here and if I run
this with the debugger and click the
button it'll tell me earlier because I
have the debugger attached but I'll just
jump through that and you'll see that
we're getting to this second
continuation actually we'll set this
here as well I'll click the button run
here we can see that after two seconds
we try to update the UI and that fails
it's gonna tell us that well you try to
do a cross threading call so that's not
gonna work but what actually happens is
that we're getting to the second
continuation because when we try to
change the UI it throw an exception it
sets the task to a completed state or a
faulted state and we get down here and
see well this task here is faulted and
we can see information about what
actually what's actually going on you
seem in here and we can get the
exceptions in here as well and see that
well you try to change the thread from a
different one right so no one wants to
do this it's like if you're working with
JavaScript and promises it just becomes
really nastier for a while because what
you need to do now is well you need to
check if this one fault
right so you say well let's continue
with this one as well it just becomes
really nasty so we don't do that but
this just shows you that while working
with the continuation in this sense here
isn't really going to work out for
larger abs it's gonna be a bit terrible
to work with in the long run but if we
just make this work what happens is that
well we need to use the dispatcher and
in asp.net that's called the
synchronization context so you can do
this
WPF in wind forums in asp.net
applications the way that you
communicate with the original thread is
just a little bit different in WPF its
dispatcher in asp.net is called the
synchronization context so we can say
well I want to invoke the main context
so we'll just do that and once this is
running back on the UI thread there
should be no problems updating the UI
and the UI no longer locks up so we can
move this around here really nicely and
after two seconds is this hello world so
we kind of made the app a little bit
better but we also introduce complexity
which makes it easier for us to get an
application that's gonna be crashing so
not so good but this kind of shows you
that well it's rigorous programming is
really good but doing it with just the
TPL is problematic especially if we have
all these different full states that we
need to track and just need to make sure
that you know we can access the data
properly all right so let's jump into
this here so we saw that you know tasks
are really good allows us to easily
offload work somewhere else and get
notified when that's done so we got into
the continuation and saw that well
there's there's some data available here
or there was an exception we can check
if it's canceled if it's false and if
it's completed and so forth so this is
where I like to introduce a sinking away
you know a sinking a weight is just
really two contextual keywords that
pretty just pretty much means that all
they're doing is that they're taking a
lot of complexity and hide that
somewhere else it generates a ton of
code to keep track off where you are in
the state machine builds up the state
machine it just does a lot of things for
you okay but there's no reason for it to
change the runtime which is what the
contextual keywords are for so you don't
have to rely on a new dotnet framework
or a dotnet runtime sorry so that's
pretty good so they just need to update
the compilers to make sure that this
works and compiles down to the same il
that can be executed by the current
state machine or the current runtime all
right so async in a way they pretty much
just allows us to hide
complexity which is great hiding
complexity often means that we increase
readability that means that not only
does our applications maybe become
better for our end-users
but also it becomes better for the
developer at least that's what we all
aim for but the problem here is that it
does become a little bit more
error-prone so this means that well we
are introducing a sink in a weight where
we know that working with TPL can be a
little bit hard and problematic and now
we're just gonna add even more things to
make it even more confusing so in this
case here we have a simple simple method
the idea here is that we want to run
this method asynchronously so the first
thing that we do is mark it with the
keyword async now one of the
misconceptions is that this just
automatically makes everything inside it
asynchronous that's not really the case
so marking something with async only
prepares for asynchronous operations
it's when we introduce the away keyword
or it becomes a little bit more
interesting and where it actually
introduces all these asynchronous
principles so we'll look at what happens
when we actually add that keyword and
both of the keywords and what's
generated but just remember that when
you add the async keyword you only
prepare for using async or synchronous
operations and we when you add their
weight keyword that's where you
introduce it continuations and that's
where you start doing yours includes
code so basically what that means is
that you see the VAR x is equal to 10
that's not going to be executed
somewhere else it's gonna be executed on
the caller thread so as I said the await
keyword is where pretty much all the
magic happens the awake keyword marks
the continuation so instead of doing the
continue would thing that we saw earlier
we can simply add their weight keyword
which makes it a lot easier to read and
what's even better is that it also
validates that the task that we were
awaiting is completed successfully that
means that it's checking if there's any
exceptions or if there's any problems if
it was canceled if it is canceled or if
there's a problem
it'll just throw that back to the caller
and then it's up to the caller to make
sure that handled uh handles that
properly so that means that when we mark
something with a weight we don't want to
run the code after it until it's done so
what happens is that when you see their
weight keyword it returns back to
whoever called the method with a
reference to that ongoing work so that's
really confusing really so let's look at
an example in this case here we have a
button click the first thing that we're
doing is that we're calling a method
called run async so it's gonna go down
into run a sink the first thing in run a
sink is doing run internal async and
then inside running ternal async it does
it tossed a delay so this is the first
time it doesn't really call anywhere
else and we don't really care about
what's happening internally in tosco
delay but what it's doing here is that
it's simulating a hundred millisecond
work so when it sees the a weight
keyword it's gonna return back to the
line or the code that executed that in
that code so that'll be a way to run
internal async and that in its turn sees
their weight keyword which returns up to
the button click handler so now we're at
the top of the chain what happens now is
that it's just keeping track of all the
work that's going on so the weight
keyword here and the async keyword set
up state machines and they're making
sure that it's jumping to the correct
context and that you're on the correct
thread so after 100 milliseconds we're
gonna come down to hello world here and
after hello world's gonna be returned
actually what happens when you see the
return keyword is that it takes whatever
you want to return the result of that
and sits that as a result on the task so
what happens is that well we saw their
weight keyword up here which means that
we grabbed the result not only does it
validate that there was no exceptions or
cancellations it also grabs the result
of that I synchronous operation all
right so it takes that hello world and
we return hello world - from Ron
internal async and then that returns up
to our button click event handler right
so a lot of steps just to make something
a little bit
whether for the end-user but there's a
lot of things that can go wrong here and
if I wrote this in production that would
do a lot of different things as well
let's look a look at the different
example so pretty much the same code but
I left out the await keyword here at the
top so what we're actually doing now is
that we're calling run async without
their wakey-wakey word in front of it
because actually what happens is that it
first calls the method and then it gets
a task and then it awaits it but in this
case here we don't see their way keyword
so it still calls down to run async
which calls run internal async which
awaits the task at delay and that means
that it's gonna be going returning up to
the next line that's in queue to be
executed and since this has not
completed yet so 100 milliseconds is not
up it's gonna run the next line after
run async because there's no white key
word now if we introduce the away
keyword it's gonna check well it's the
task completed right so we got the the
run async task that we're keeping track
of the work inside bran async inside run
internal async which in its turn it's
keeping track of the test at delay so
when we introduced a weight keyword here
it sees that well this completed now so
we can return hello world which returns
inside run async and then we can get the
result in here alright just to make this
even more confusing all of these
different ones are running on the same
context which means that we call this
from the UI thread so whenever we see
their weight keyword whatever is after
that it's gonna be running in the same
context as the code before it all right
and just to make that even more
confusing it's not true for asp.net if
you use configure weight false but we'll
try that on later on does this make
sense good or just load your mind you're
just all sleeping alright so what's the
difference between doing a weight versus
like task continue with besides the
obvious things that well you know it
looks better it also makes sure that we
execute the code after
continuation on the same context so with
the continued with here we actually run
the continuation on on different context
doesn't necessarily mean that we're on
the same thread that we did our
asynchronous operation on and it doesn't
mean that we were on the UI thread we're
somewhere else right so we have to worry
about the cross threading ourselves and
all that but when we come down to just
normal continuation with the awake
keyword we're at the original context
and what also is really good with this
is that you know it validated validated
the task which means that we don't like
the throws the exceptions if there's a
problem which is essentially what we
really want so the really bad parts
about async in a way it is that you know
it increases complexity and you can't
really see the complexity but it really
does make your code if you d compile
that a lot more complex and even if it
seems like well I can just add the async
keyword and whenever there's a task I'll
just add a weight oh it's hard to master
it's funny because I like I've done ton
of workshops and talks on async wrist
programming and I learned something
every time and I still do deadlocks and
I still do crappy applications I don't
know if I'm still like a slow learner
but it's hard to master let's just leave
it at that and if you've never had a
deadlock I promise that you'll
experience a deadlock sooner or later
it's really easy especially when it
comes to waste and can await because it
becomes harder to you know separate
what's running somewhere else and what's
running on the same context which is
essentially where you seem to run into
deadlocks
it's when you forget which context you
are currently running on normally when
you get a deadlock it's because you're
saying well run this thing here and I'm
gonna block until it's done normally you
don't want to block you just want to
wait for the work to be done but
sometimes it's hard to know where you're
running the code and we'll look at that
soon as well but before we do that we
need to understand what the state
machine is all about the state machine
allows us to keep track of all our work
so whenever we add the async keyword it
introduces one of these stay
machines and I I tend to say like
compare the state machine to a a child
that's sitting in the back seat of your
car just asking over and over again are
we there yet is this annoying little kid
just asking you all the time if we were
there that's pretty much the state
machine it's just keeping track of all
the work and when it knows where to go
it jumps to the correct context on the
correct thread which is essentially what
we want to do it keeps track of the
state make sense but what it's also
doing is that it keeps track it handles
all the result handles the results and
potential errors so that means that if
we're throwing an exception inside our
task got run it'll capture that which is
really good and also make sure that it
can execute the code after we have the
awake keyword so it goes into the
continuation and it runs that in the
correct context so what does applying
the async keyword related well it
introduces this state machine and
introducing a state machine means that
it's doing a lot of work it's generating
a lot of code and this code is
essentially it's gonna take our method
body and move that into somewhere else
it's not only gonna create a new file
it's gonna tear everything apart move
lines all over the place and as soon as
you have their weight keyword is just
gonna make it even more complex so just
looking at this very small example here
we're adding the async keyword you can
see that we have the debug that right
line at the bottom so when we compile
this here well you would probably expect
that it'll live a bit similar to this
here how many of you have looked at
decompiled async code before okay good
so you all know what it's gonna look
like pretty much so what happens is that
it introduces like nothing that looks
like our code it took the entire method
body move that into something called run
async d underscore underscore one which
is the generated state machine and
inside the state machine it keeps track
of of the asynchronous operations it
keeps track of certain errors and in any
results and so forth now we can see here
at the bottom so keep this in mind this
is really interesting so we have this it
returns a reference to the ongoing work
that means that when we call an
asynchronous op
operation or and I say my method that's
Marcos async and it returns a task we
can check if it's if it's faulted we can
check if there was an exception you know
if there's a result available that's
really good that's helpful so keep that
in mind so if we take one step further
and we look inside the steak machine we
will see here that well we do have the
task to delay for two seconds here which
is the same code that we had earlier and
on the line above it it introduces this
variable which is our VAR X is equal to
10 and then what it's doing is that it's
checking if it's completed and then at
the bottom when everything is done and
it's in the context of running this the
continuation of the code we can see that
we have our debugger dried line that's
good so this is pretty much our code
that we had here now what's really
interesting here is that this is all
running on the same thread that you're
calling the method on so if we just step
back a little bit here we have run acing
here right so if we go back one step
further if you call this method here
what I told you earlier is that this
doesn't just magically become
asynchronous it generates a state
machine and we can see here that is
running our state machine on the line
above this here it's doing builder dot
start which is starting and running all
the code inside the state machine so all
of this code here is in fact running on
our UI thread if we're running this in
WPF alright so keep that in mind when
we're looking at deadlocks because this
is where a lot of people seem to be
deadlocking at least once or twice third
time well you probably shouldn't be a
developer I'm joking all right so this
is where we talked about a Singh Boyd
does anyone know when to use a Singh
void never that's the right answer
I didn't hear anyone say but let's just
imagine a Singh for should never be used
except in one case and I'll show you
that soon
so a Singh Ford is pretty much like you
know it's the hottest summer day
especially in Sydney you go to the beach
you stand in line for 40 minutes to get
your ice cream and as soon as they hand
you the ice cream and you walk out of
the line you just drop it like you just
want to lie down and cry right
if the Sun doesn't kill you the Sharks
will that's that's acing board for you
so is it really that bad well let me
just show you a little bit of code here
so what happens here it's the same code
that we had earlier but I've removed a
sync task it's doing a sync void instead
so if we look the decompile code of this
here with a compiled code we can see
here that it's doing this exactly the
same thing that we had earlier except
that we're now using this async void
method builder which handles exceptions
and problems a little bit different if
there's an exception inside this state
machine here it'll just tear down the
entire application that sounds good
right why it's doing that though well
it's because as we see here there's no
return builder task at the bottom we no
longer have a reference to the ongoing
work so the only way for the application
to tell us that there was a problem is
to just kill the app then he will
certainly know there was a problem and
we have to fix it so you know I heard I
don't know if anyone else in here heard
that Elon Musk said that I think that
AIS are going to destroy humanity and
all all of that right everyone heard
that well I think ASIC void is gonna
kill us all especially if we do it in
cars called joking aside how do we fix
this
it's really easy to fix the way that we
fix this is by just don't do a sync void
we change this to async task but you
know what do we have to do if we mark
this as async task so I said earlier
that the await keyword is validating
that the tasks are all done properly and
what we have to do here is that we have
to make sure that all the code in this
part here executed properly it's better
that the app no longer crashes but we
also want to make sure that there's not
a not any problems in the code so the
way that we've checked that this is in
fact working is by introducing their
weight keyword so if we look at a button
event handler can we mark that as async
Boyd well we can't mark go on we can't
mark this click event handler as async
task right
because that would break the delegates
so this here needs to be void so if we
simply do this here I'll just show you
this example here if we have a weight
task delay delay 2 seconds we have to
mark this as async so told you to never
do async void but there's not really any
options in here right so I can't mark
this as async task and pretty much the
all the initialization of asynchronous
programming is through event handlers
when the user clicks a button or
something happens right so we need to be
able to do this and the only way that
it's not going to tear down the
application is by making sure that
there's no exceptions in here so how do
we make sure that there's no exceptions
in here well we don't write bad code
it's super simple now what we do is that
we wrap all our code in a try-catch
block gotta catch them all we do this
now we want to write as little code as
possible inside our try catch block
that's what we've all learned before
right so we want to make sure that we
don't have too much coding here that
could potentially fail so what I
normally do is that well I try to have
very small async void methods when they
click event handlers and then I call out
somewhere else in this case here I'm
simply just validating that our our code
worked properly so now this won't tear
down the application but I probably have
to make sure that there's no problem in
the catch block right so we might want
to clean up the resources if there's a
problem we can clean that up in here and
if everything is in the application is
async and we might want to log this to a
database if you do stuff in here as well
that's asynchronous because now we can
use a weight inside catch blocks and
finally blocks as well just make sure
you have one more layer of twine catch
it doesn't tear down the app right so
this is just an example of if you would
have like a database call here like log
to DB or clean up or do something
like that so it's really handy so in
this case here when we run this here and
when we have this code compiled it's
allowing us to to work really easily
with all these a synchronous code right
it's it's more beautiful than doing all
that task dot run business that we saw
earlier
even if tasks that run is the way that
we initialize our our a synchronous
operations we want to avoid doing the
continue with on those tasks because you
know this is a much better approach
because it takes care of looking over if
there's any fault it gives you the
result it just makes it a lot easier but
as we saw earlier there is one use case
for using to continue with on tasks it's
for instance when we start a task
somewhere else and we always want to run
something when it's done that we might
want to just do continue with because
what happens when we introduce the async
and a weight keyword is that it improves
is all this complexity right in this
case here it might not make any sense
for me to introduce a state machine to
move this entire block of code into that
state machine right doesn't really make
any sense so as we saw earlier if we
have this private async let's say string
run async ideally we can in this case
here for instance say await a stub delay
let's do one second the world so what
we're doing here is that we are simply
in producing an asynchronous operation
and this needs to be task of string
workout this keyboard you know I'm
acting salmon for too long as you forget
a normal keyboard alright so what we
want to do now is that we want to grab
that whole the world out of this here
and what we saw earlier is that well if
we call run async this returns a task
right so just as we had earlier we can
say well give me the task of run async
now what happens here is that goes in to
run a sink it runs the task of delay and
then after that we get the result so it
takes that result hello world which we
have here it sets that on our tea here
so we could say well I wanted to to give
me the result but in T dot result this
here will in fact give us hello world
after one second but this here would
block the application and it would most
likely deadlock as well so I want you to
think about that for a second why this
would deadlock and I'll get back to that
just a little moment so the way that we
get the result out of that without any
hassle is to say well give me the result
it's equal to
result is equal to a wait T it's not
pretty see this here validates that
there's no exceptions it checks if
there's an exceptions if there's an
exception in T here it's going to take
the exception and set that as a full
state on this one and if it sees that
it's gonna throw it back to the caller
so that way keyword will make sure that
we can grab that exception and we can
get that Pokemon in here super simple
now a lot of people ask me well what if
I have an asynchronous operation that
returns something as synchronous such as
the HTTP client you can actually what we
can do then is that we'll say let's say
that we do we get hello world from a
stream from somewhere we might be doing
it from a file so we can do tasks dot
from results which is a good way for us
to fake that this is running as a task
and we have a task of a task of a string
and then we can have a wait T here which
returns a task of string and then we can
have one more wait and sometimes there's
even more tasks but you get the point so
we can just chain all these subways
together so it might not become readable
but you can do it so a task can return a
task which might be you know an
asynchronous operation like an HTTP call
and then you need to read the content
from the HTTP request which is another a
synchronous operation so then you can
chain up all these
it's like that all right and you know if
we compile this here and I'll just close
off the app and we head into reflector
I'm just gonna refresh this here we'll
see if it it's all good
compiled so we see here that we have the
button click event handler which is
introducing this state machine it's
introducing the state machine that keeps
track of run async and the result of
that so we can drill into that and this
is a void method so it's doing the async
void method builder but if we're going
to the state machine we have a method
called move next which is running all
our code and this here is all the code
that's executing and keeping track of
everything that we have inside are about
the click event Taylor Wow
it's a lot of code for just this little
part here right so it's a try-catch
we're running just a method we're doing
a wait right so we have what 70 lines of
code in here to do that really simple
thing so one thing that I tend to talk
about is how it can be more efficient
when we when we work with asynchronous
programming and one of the things that
we want to avoid is of course deadlocks
right so deadlocks is pretty easy to
avoid an example of getting a deadlock
in this case here this example looks
difficult to understand but it's really
not so we're introducing a one-second
delay I continue after that one one
millisecond sorry and say well after one
millisecond I want you to run something
in the UI and then at the bottom here I
say well I'm gonna you know lock up the
UI until you were done so how do they
know that it's done right how does it
communicate back to the you I'd say well
I'm done yeah if we do this it just
blows up which is not so good an easier
way for us to get a deadlock is to
simply block our state machine so said
earlier that well if we do run a singer'
salt or run a single way this state
machine that's key
in track of all their synchronous
operations it's running on our calling
context so that means if we introduce
this code here and do a white or we're
blocking this here I'm gonna blow up the
app it's not going to blow up at all it
says cannot stop responding because it's
locking up so always avoid doing dot
wait
the only time you do wait or dot result
is if you work with a console
application where there's no UI thread
you can even deadlock asp.net so yeah
just avoid this another thing that I see
a lot is like unnecessary state machines
so what do I mean by that well in this
case here we have a method called run
async run async is an Eastern calling
one internal async which is marked as
async task
it's awaiting something it's calling
something async and then it's calling
something internal wasting what happens
here is that each of these methods are
going to introduce their own state
machine which is going to keep track of
the work inside that state machine and
each a weight keyword is going to be
working with a continuation to make sure
that it's jumping to the correct context
each a weight keyword is gonna make sure
that there's no exceptions and it's
gonna check the result and so forth
that's a lot of work just to do one
simple thing what do we want to do here
really whenever we want to use their
weight keyword is when we want to get a
result after the execution so if there's
nothing after the continuation we don't
really need to wait so the way that we
clean this up is by simply remove async
in the weight from the method that
simply return back back to the caller so
in some cases look at the method chain
here so at the bottom we were returning
tasks a delay instead of marking it as
async tasks and doing a weight it's
simply doing the same thing so when we
looked at these the builder earlier when
it compiled the the code into the state
machine we saw that the method signature
changed to just builder tasks which
returns a reference to the ongoing work
but the reference in this case of the
ongoing work is just simply tasks to
delay so we can return that up to the to
the top level or whoever wants to work
with it and then has something after in
the continuation so the first time that
we need to
introduced a continuation in this case
is when we do run a sink does that make
sense right so another thing I want to
talk about is cancellations so
cancellations is a really interesting
topic is anyone in here doing mobile Sam
urn no just a few of you yeah so one of
the things that I've been doing a lot is
optimizing when user inputs data for
instance I want to make sure that well
if they still write something and I'm
gonna search for something online well I
just wait until they've finished writing
and I can do that with smart
cancellations or tricking it using tasks
which is pretty interesting you can
probably do the same thing if you're
working with WPF or asp.net as well so
just an example here this is more like a
CPU intensive thing and it's not the
best example but it'll give you an idea
of the problem that we have here so I
want to be able to cancel this operation
here so this is a long-running operation
there's a little bit of a mixture off
talking to the UI and there's some some
asynchrony here so I want to make sure
that I can use this in my app and I
wanta be able to cancel this operation
so the way that I introduce this is by
introducing something called a
cancellation token source so the
cancellation token source allows me to
get something called a cancellation
token now the token is what's traveling
throughout all our different
asynchronous operations and ideally you
pass that down along the line to the
call at the bottom and you can just
track if it's been canceled along the
way now i can use this cancellation
token source by simply saying
cancellation token source dot cancel can
I see a show of hands how many of you
think that this is gonna cancel my
operation exactly it's do nothing
correct
so why is it doing nothing well how
would it know where to break my app how
would it know where to stop executing my
code so the way that we introduce the
cancellations is by saying well just
throw an exception if there's been a
cancellation requested so this here is
really it's really neat and you can use
this in a variety of different scenarios
so I've done this in mobile applications
like whole is smart cancel
so what I do is that I set up a task
that's running for let's say 400
milliseconds each time the user presses
a button I cancel the task and just
restarted and if it has not been
cancelled I go ahead and do the web call
right so that means that if there's
nothing input for 400 milliseconds I
don't do any cancellations and the user
didn't the user wants the data right
all right so how many of you doing
asp.net who well was all of you that's
awesome
so everything that we've talked about up
until now is applicable in asp.net the
only difference in asp.net which makes
this really hard is the synchronization
context so the synchronization context
is pretty much like our dispatcher dotty
invoke so imagine we get into our
asp.net application we got an action
that's running on one thread then we
start doing a synchronous operations and
the way that we get back to the original
thread is by doing synchronization
context that current outpost for
instance this is what it's doing
internally to get back to that original
context so how many of you near so all
of you are pretty much doing asp.net and
how many of you have been told to always
do configure right false so a handful of
you have been told that so what's
interesting here is that if we do just a
weight task that dealer here so this is
applicable in WPF as well but this is an
asp.net application what happens here is
that we're not forcing this line back to
the colon context which means that all
the code after inside our continuation
is behaving like we were doing this with
dot continue with all right but in this
case here we are executing the code on
the original context so why is that
important and why is that such a big
difference
well the thread pool in asp.net is
limited which means that if it can you
just pick whichever thread you want or
whichever is available that's gonna be a
lot faster so doing configure away falls
is a lot of times faster but
it's gonna run you into a few different
problems so let's look at a few of the
interesting cases in asp.net that gives
you a little bit of a headache so I've
got an example here this is a Web API
and I've got my values controller here
and I'm just gonna run this here and and
you'll see run the right app and you'll
see here that what I'm doing is that I'm
using something called the cache so I'm
using HTTP context current of cache I'm
setting that to hello world I'm calling
an asynchronous operation that's doing
something in the background but I'm just
waiting for that to finish before I
return something back to the user super
simple right
so what happens now is that well it's
gonna go in here it's gonna set our
cache and test here to hello world and
then is gonna return that back and we
can see that we have hello world here
super simple now what happens if I say
will configure wait and do Falls here
can I see a show of hands how many of
you think it's gonna be the exact same
result okay couple great
I like that my questions aren't all that
obvious
not to leading in my questions it's
actually going to show us nothing at all
the problem here is that what we're
doing is that we are first setting a
value in our dictionary to something and
this dictionary lives on our current
thread that we are using when we're
executing this for the user so it lives
in the context off the original thread
that's spawning this user request and
what we're doing here saying well I
don't really care which thread you use
to return back to the user so that means
that all the code that this part here is
no longer running in the same context as
this one up here so two different
threads which means that it no longer
has access to this thread static thing
so obviously threads statics aren't
really the best thing probably shouldn't
use that but it also means that well you
couldn't use sessions and everything
from the use of principle would probably
not transfer over here either right so
that that kind of changes it a little
bit so you need to think about that but
what makes this even more interesting is
that configure await false is just
context aware so it's it's aware of its
own context which means that if we do
this here and this is interesting if I
introduce a new method called public
async task run a sync let's call it one
I think one just to make it more
confusing I'll just take this code here
I'll pop this down here at the bottom
and then I'll do a wait run async one
now I'm going to think that I'm gonna
see hello world half alright
let's see what actually happens so what
it's doing here is that it contacts the
world which means that if I move
configure wait somewhere else it's a
different context which means that I
want to spoil it we can see hello world
here right so that means that let's say
that we are at thread 1 here that means
that we are at thread 1 here as well but
that also means that we are at thread 1
here and this is returning from thread 2
confused yet so this is why it's really
important to think about whenever we
have a method that's using configure
await false just make sure that after
you don't need anything from like the
use of principal or the context of the
previous operations especially if it's
static variables right everything else
is the same in asp.net as we've talked
about earlier in WPF and and WinForms
and console apps and so forth so one
thing that you want to do is a sink all
the way and I'm just saying this because
you shouldn't just break your async
chain and have like an ASIC void in the
middle because that's just gonna make it
really horrible it's one way to like
tear down the app and get a lot of
unexpected exceptions but you know just
do a sync all the way and if yours don't
have anything in your continuation just
return the task that's referencing that
ongoing work instead instead of
introducing a sink and a weight in that
particular method and remember that
asp.net makes it easy for us to use
async in a weight as well but if we
apply just configure way to everything
it's gonna be hard right so if you want
to sit down at your own time I've got a
plural set course and if you want a free
trial for that just hit me up on Twitter
and I'll figure that out as well and
remember take a picture ping me on
Twitter and I'll give you a free book
nothing's ever free so please put a
green thing in the box there I'm gonna
stand there and look at you if you
didn't you won't get the book I'm just
joking so just to wrap this up a sink in
a weight is
really good it makes it easier for us to
build asynchronous applications and even
if we go back to the basics there's
always something that you know makes us
think about what's really going on under
the hoods here
now hopefully you you'll have a better
understanding of how not to get a
deadlock and what's really happening
when we introduce these keywords so
thank you so much I'm Philip Ekberg
please hit me up on Twitter if you have
any questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>