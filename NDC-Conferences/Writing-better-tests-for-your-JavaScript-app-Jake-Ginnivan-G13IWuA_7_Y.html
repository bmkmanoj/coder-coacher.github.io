<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Writing better tests for your JavaScript app - Jake Ginnivan | Coder Coacher - Coaching Coders</title><meta content="Writing better tests for your JavaScript app - Jake Ginnivan - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Writing better tests for your JavaScript app - Jake Ginnivan</b></h2><h5 class="post__date">2017-04-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/G13IWuA_7_Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">get started afternoon everyone
it's a second last talk for the
conference so it's been pretty
interesting I've been to a bunch of
really interesting talks over the course
of this conference I'm going to be
talking to you something about better
JavaScript tests which is a quite a
vague topic so I'll try and explain what
I'm what going to talk to you about I've
come from a dotnet background where I've
had a large focus on helping clients
make write better tests not throwing the
tests weed away after sort of six months
or so and moving over to JavaScript
which I've been heavily doing for the
last sort of six to twelve months I've
just some of the ecosystem generally has
a lot less knowledge collectively about
testing there's a heap of really good
projects out there a lot of good
community champions doing good stuff but
there's a lot we can learn so I'm going
to be taking some of the ideas that I've
had out of my from my net experience and
also just experimenting around how I can
write better JavaScript apps and sort of
hopefully give you a couple of different
tips and tricks that you can take away
and use straight away start writing
better tests so this place to start
would probably be defining what I mean I
better what is better so if we've got we
try and plot out what our good
characteristics of tests fast
comprehensive reliable maintainable give
you increased confidence and enables you
to refactor your code with confidence
they're kind of some random things that
I've just selected as things that are
quite good to be striving towards so if
we try and plot out what each of those
could be the idea is you would want the
large your tests to be further out on
this graph which means they're generally
better tests so a lot of the tips will
be trying to push one of these sort of
things further out
but then as you're trying to achieve
these things like more comprehensive
tests you send start suffering things
like your tests are really large and
complicated to write they're really slow
to run they fail intermittently
especially when you start talking about
UI tests or they don't fail at all so
they're giving you false confidence and
this one is particularly bad because the
number of times you put a heap of effort
into a really good test suite and then
you go try and change something and half
your tests fail because they're testing
implementation which you've now changed
I have to go update all your mocks and
that sort of stuff you don't want your
tests to be getting in the way of
helping your codebase evolve over time
and then this is sort of a broader issue
is you've invested a heap of time into
your tests but they're not catching the
issues you're still deploying having
bugs so as that said why do we actually
write tests let's go back to the the
problem for me it's just about shipping
software if I want to be able to ship
with confidence and I don't want to fail
we'll all have been there we've done a
production deployment and things go bad
we don't want to do that so tests are
kind of that insurance for us because at
the end of the day we're really paid to
write software we're not paid to write
tests so if we have a good test suite we
can deploy with confidence and then make
our customers really happy so that's
writing better tests through your
JavaScript app there's going to be a lot
of code later and actually diving in
I'd really like everyone if you've got
questions when we're in a particular
sample around sort of what problems
you've encountered we can dive in
assuming I'm let you know if I'm going
to be touching on your question later
bit about me my background I am Digital
development just for a company called
seven west media in Perth in Western
Australia we produce a large newspaper
and
a bunch of other digital products I also
do a fair amount of open source my
testing specific open source projects
include a org called test stack we've
got a couple of projects in there
WAIS is a UI testing framework solano
wraps selenium and introduces a bunch of
really nice features and just better
abstractions help you create
maintainable selenium tests convention
tests which I'm not going to touch on
today but it's an interesting class of
tests where rather than writing specific
tests write some sort of convention for
your code base so as soon as you add a
particular type of code the convention
test picks that up and make sure it it
is here's to the conventions of your
project really useful if you're doing
like event handling making sure that you
if you create an event it has a handler
those sort of things
and finally B to D Phi which is a BDD
testing framework the other one is
should Li which is an assertion library
that focuses on creating really good
error messages so that's something that
I've been really looking for when moving
over to JavaScript because I've been
spoiled we've seen the testing pyramids
I everyone familiar yeah who likes this
concept and agrees with it are we not
putting up a hands because who doesn't
agree then not familiar so this is a
something floats around the testing
areas um quite quite a lot and the idea
is that you should write heaps of unit
tests and then you hit the next problem
no one agrees what a unit test is so
then you move up to the next layer and
some people like well they're service
tests their acceptance tests their
integration API component tests one
thing people do agree on is the GUI
tests at the top which I have had a lot
of experience with and have come to the
conclusion that generally they are a bad
idea for anything other than just
smoke testing your system but this is a
good kind of generalization of the types
of different types of testing that you
want to be performing as you move
further up your tests are slower
generally more brittle down the bottom
not as comprehensive so you need a mix
of these things so just different
scenarios that I have in my mind and
kind of want to address is you've got
different problems that you have to
solve when you're testing so it could be
you don't have much testing you haven't
invested much time so you want to get
some confidence well you probably want
to do a specific type of testing will
give you the confidence without a lot of
effort what about a bug really easy to
fix that in a bit of code that's moving
all the time you probably want to do
lower level unit tests for that sort of
thing or you're shipping a particularly
critical feature so you need to have a
lot of confidence that your tests are
actually going to stop regressions
because it could be expensive
embarrassing whatever if bugs are in
that area of your system the point is
there's no real one testing strategy so
when we dive into the code we're going
to go through different levels and just
apply different techniques to each of
them and show that we can actually blend
some of these together to really get the
best out of everything so unit tests the
definition that I like and I follow is
they're in process they're isolated
they're fast
and they test one thing one thing that I
do fight against is when people talk
about they have to be a module or they
have to be a function or have to be a
class that ends up with people overusing
mocking frameworks and we'll go into why
that's a bad idea later so if we're
looking at a little spider chart here
unit test looks something like that
they're quite reliable they give you a
bit of confidence that generally you
have to write a lot of them and that
gives you the confidence quite
maintainable because they don't do much
but they're not very comprehensive
so they have pros fast write faster run
easy to debug but they inhibit
refactoring so show you some techniques
later what it doesn't show you is issues
between collaborations they've seen a
number of the other talks I've seen over
MVC last couple of days there seems to
be people moving more towards
integration and UI sort of style tests
because it solves that particular
problem
um when talking about unit tests there's
a lot of different ways you can
obviously start with in JavaScript the
main two ways are using browsers or
using node everything else is a subset
of one of those I'm a massive fan of
going down the node path so I when I'm
writing these sort of tests I don't
really care about browser quirks I
really want to test the logic of my code
because it will have other techniques
like browser stack which will test your
application in as many browsers as you
need and have sort of high-level tests
for that particular reason be very
specific in what you want to get out of
each of these different style testing so
examples of those are maca jest and
tapes as a bunch of others the one that
I'm going to be using today is jest so
you can use just with anything it's come
out of Facebook so it's quite tied to
the react community but there's been a
lot of people around the angular 2 and a
really a community starting to pick jest
up because it brings some really fresh
ideas especially when you're starting to
use the new world of JavaScript with es6
and webpack and those sort of things it
works really well with that style out of
curiosity who's using angular 1 no
angular 2 react
what about Aurelia okay so what about
vanilla Jas kind of traditional okay
who's using webpack here
not too many so what sir what are the
others using call something out of mist
yep so knockouts an interesting one what
do you use through your package manager'
is it Bauer yep so if you're using NPM
via package manager just as great it
sort of works with that new node way of
thinking a lot of what I'm going to be
talking about is moving into that
direction where I see JavaScript moving
not talking too much about using bower
global script tags and the problems that
come out than that so let's dive into it
let's have a look at some unit testing
so I've got a little simple app here is
pretty calm popular at this conference a
lot of speakers like to track what beers
they're drinking so I thought really
simple demo would be a like tracking
what whisky you like drinking so it's
quite really really simple you just
start typing after a couple of seconds
it'll find a bunch of different whiskies
and you can check them in not going to
go much further than that but this gives
us a nice base to be able to test with
so the unit tests that I want to write
is around the search so I start typing
after half a second it executes my
search so the pretty common pattern you
see
so in here I've got my utils and part of
my utilities is I've got this little
search latest class or function is
everyone familiar with like a s six
modules import and export syntax anyone
not familiar cool I won't go over it
then so this is a typical thing I see
when I see these sort of functions
people keep their modules going further
and further down so it's pulling in my
API which is then calling the web server
to get all the results you pass in a
callback witches do I have results let's
bump that up in it then sets the delay
for half a second once that has fired it
checks to see if the search term has
changed if it hasn't it'll execute the
search when the search comes back it'll
make sure it's still the same and then
it will call the to have results
function so that's kind of cool works
I've got a test here which tests this
quite simple it searches after timeout I
call search latest give it a callback I
then execute search term change changed
this is what jess looks like I'll just
run this
cool so it's quite nice it's got a
console runner that gives you a lot of
feedback you can just type in test name
still tur down so here you can see my
testers blowing up because I don't have
a oh god no one can see that but uh I'll
just wait for my machine to reboot and
then I can continue writing the test so
had this happen for a long time
excuse me while I start my computer
again
you like that
into presenter mode so the last
conference I was at quite a little while
ago I started went up to do my
presentation open my laptop machinery
boots for our windows update not having
much luck okay so we're almost back mmm
keoki I have to close all of the things
okay
get our tests running again and we're
almost back where we are
cool so back after a brief interruption
also I just have to stop the app up
again
okay so you can see back where we are
you can see that my tests have failed
because of the network request this
typical problem you're talking to an
your API you need a bunch of stuff
started don't have things isolated so
once we want everything's all started
here my tests now pass because it can
talk to the running API we want to get
rid of that problem so the first thing
is in my search term changed this here
is a problem I'm invoking an API and
then makes my tests brittle so one thing
we want to move towards especially if we
have code with logic is making sure
these things are as pure as possible
this is a much better approach than
mocking so in this instance I've got two
options
I can either mock the HTTP call out or I
can raise the function up if you raise
the function up which I'm going to do
here you end up with a lot of modules
which don't actually have a deep
dependency hierarchy and then it makes
things much easier to reuse much more
composable so I'll just call this
perform search
and switch that over so now this cat
this utility is not actually in control
of whether it where it actually performs
the search it's just actually doing that
delay and then invoke so if I go over to
the test now I can pass this as my
second parameter so perform search
that's great it's just a function and
then it returns a the results so I can
start off with ID of one name is I don't
know let's leave that blank for the
moment and then we'll go grab some
others and then we need a region
we open the browser
cool I will grab Glenmorangie Signet as
our whiskey cool so now instead of
hitting my API I'm just blocking it out
manually test my test still passes
problem is I'm not actually I'm just
making sure the tests are defined this
is one feature I really really love out
of should Lee and the dotnet community
is something called approval tests the
idea is this when you've got something
quite complex to assert that could be
like a bunch of data or a single object
that has a lot of properties you find
you unit tests have sort of seven or
eight logical asserts they're all
testing the same thing but what you're
trying to assert against is quite hard
to assert so just has this thing called
should match snapshot which is exactly
the same thing so instead of going
expect results start like first index
name to be blah I can just go should
match snapshot when just runs it should
tell me that I have one snapshot now
what that will actually do is write out
a snapshot there that's good you trigger
that
hmm
empty why is it empty
search term returns can anyone see what
I've done art promise doing everything
asynchronously I returned a value not a
promise okay so here you can see it's
gone snapshot summary one snapshot has
been written so what that'll do is will
actually drop our test result directly
into this snapshot file this is really
nice because in my test if I go now
change this to ten-year-old and go save
I'll have a failed test and it gives me
a gif of what the value was before and
what it is now I know the Reds really
hard to see on the projector but it
gives us a really nice way of testing
this stuff we can then just go just
update and it will copy whatever is the
new value over the old one so it makes
it easy to maintain these things over
time any questions about snapshot
testing does anyone use snapshot or
approval testing before give it a go
it's a it saves so much time
it is so it'll be named after the file
here and it exports for each test name
it exports a value which is then used as
the snapshot
yeah so there's actually um another one
for JavaScript as well so the library
that introduced this concept was called
a approval test and it actually has a
net version a JavaScript version a
Python version that's pretty much for
every of them all of the different
frameworks rather and ecosystems the one
difference is that what approval tests
and should we do is when the test fails
it'll actually just pop up a diff tool
of what it was before and after and then
you merge the results so if you are
happy with the changes you merge it
across to the approved file the where
Facebook and moving with just is
interactive resolution in the console so
it's quite a really really powerful way
of asserting against data yes so that is
your assertion that file is your
assertion so you have to check that in
so that's a little let's go back into
PowerPoint now blue screens are really
inconvenient
I can't even resume at the same spot
cause under the exist cool so the two
things have kind of started showing with
unit tests is keeping modules really
pure so make sure you rather than
mocking things out and ending up with
quite a deep hierarchy this is really
common in net with IOC containers try
and keep functions really really pure so
you pass your different dependencies in
and make the boundaries between these
different modules values or objects
instead because then they're super easy
to test you can just create what you
want to test against pass it in that the
function as pure so there's no side
effects and mocks the potential design
issues really so jess does have the
ability to mock out modules which is
really handy it also has the ability to
mock out all the timers so in that set
timeout that we are using you could use
just to take control of that timer until
all time is to resolve so you don't have
to wait half a second in your tests
those use of mocks not too bad
but if you can avoid them ends up being
nicer in JavaScript
so the next when it's unit tests are
kind of great we can try and make these
small little units of code but it's not
super interesting the type of tests that
I'm really getting excited about are
still unit tests keeping everything in
process but allowing it to test the
majority of your application so it's not
quite unit integration tests because you
don't go out of process but it's quite
close so if this is a unit test and the
sort of attributes of that if we go to
higher level the orange there is kind of
bit higher confidence definitely slower
less reliable because there's more stuff
going on probably more chance of issues
I find them really maintainable because
they remove all of these implementation
details and they also enable you to
refactor really rapidly so these
high-level unit tests I find them really
faster right they're quite fast to run
it also it covers the interaction
between modules with unit tests miss and
they also a less prone to breaking
during refactoring so they're kind of
your staple tests that you never want to
modify during refactoring where unit
tests if you refactor you can delete
them if they if they break that's kind
of my mindset because you your unit
tests are testing a lot about the
implementation of your code and if the
implementation is no longer what the
test is asserting probably change they
have two downsides though that they're a
lot harder to debug and they cannot
cover all scenarios there's a really
really good talk called unit integration
tests are a scam and the idea of this
talk is prove going through
mathematically proving that high-level
or integration tests are bad for your
application and the reason for that is
if you've got a number of modules and
they have a number of code paths as you
add more modules in you have a
combinatorial explosion of the paths
through your application so these style
tests cannot possibly test all of the
paths through your application this is
why you still need the low-level unit
tests quickly I'm going to show you two
things I'm going to show you an approach
to that I use to testing single page
applications it is specific all it is
implemented using react but a lot of the
same concepts can be applied elsewhere
and the other one is testing a nodejs
Express API so another style of testing
called subcutaneous testings so when I'm
testing a single page application
there's a couple of things I do I said
that before I like testing in node so
node never has a browser how do I do
sort of these high-level browser tests
just does this by default as soon as you
run ingest it actually already has a MOT
Don using je estan I then make sure all
of my external services are marked so
any HTTP calls that sockets those sort
of things
they're the points that I mock I try
very very hard not to mock anything
within my application a test simply just
mounts your application into this test
Dom and then starts like simulating
browser events and then making sure your
application behaves the way it should so
that something gets rendered the nice
thing about all of this though is with
one level sort of below we're using the
Dom but we've mocked all of that out so
it stays really quick we don't have to
worry about starting up browsers we
don't have to worry about browser quirks
those sort of things and then in the
node web service similar sort of
concepts we want to make sure that we
can mock out any external things like
databases we also want to because we're
not going to go through our API directly
we want to reduce logic that's in our
middlewares
so if you're all net developers and your
back-end these are kind of your MVC
action filters and those sort of things
you want to remove as much logic out of
those as possible so I'll jump across to
so this is my really simple react up and
this is the start of the test so we've
seen here that I've got my search and
after a certain time it hits the API I
use a tool called fetch mock to mock my
API this will change if using angular
you'll have to use their HTTP mocks
those sort of things but the first thing
I do is make sure that I don't want
anything succeeding by default so I want
if my test calls an API I never want it
to go out so I start off saying anything
I haven't explicitly mocked blows up
with a 500 then we'll just mock out this
the get function the next thing I want
to do is I want to mount my application
so I can go const up equals mount app so
i'm using the tool called enzyme it is
just a wrapper around the react test
utilities and essentially it takes this
app component
it creates the divs in the fake browser
and then melts my app into it and gives
me back an instance if you're using
another framework these sort of
techniques can still be used so the
jeaious dome is actually a complete poly
well reasonably complete polyfill for
the dom so most of these libraries can
actually work using it the first thing
I'll do is I will find my input which is
called
searchbox thing I like about these style
of tests is their because they are so
high they allow you just to really focus
on what what are you trying to test the
next thing to do is once I've got my
search box I can actually start
simulating events
so I'm just simulating a textbox change
event reacts quite nice in this way it
has an amusing I'm taking advantage of
react synthetic event system but if
you're using another library like just
even jQuery you could trigger use jQuery
to trigger real Dom events
so once I've simulated that that should
kick off my my test my research so what
I need to do is I need to wait for that
half a second to elapse because I'm not
locking out time yet does anyone in the
concurrency talked earlier like the
JavaScript asynchronous patterns yeah so
this is actually using a think in a
weight that is in stage three at the
moment I might have hit stage for it
with Babel so essentially what this
allows me to do is remove callbacks from
my code so I just want to await a weight
function and just say wait wait 700
milliseconds so essentially that's going
to pause my test for 700 milliseconds
hopefully by this time the the input box
is fired off that search and now it's
searching because I'm mocking out the
API that returns instantly so I don't
have to worry about latency there so now
I should have are the results so I can
actually just go app dot find and then
in my app for each result I'm just
creating a span which has some text in
it so I'll just find me all stands
because there's only going to be one
result I can actually just go expect app
dot fine spanned text to be Glenmorangie
signal and save that cool so it didn't
find it
another missed
so we are know so find actually is
really really handy at I'll search by ID
or react component or class so it's kind
of this hybrid so if I had my own
abstractions my own components I can
actually pass my my component in this is
something I'm going to show you a bit
later with that and refactor this to use
something called the page object pattern
just to save time I'll just copy the
hopefully that'll pass
can search for whiskey
ah I know so we changed the signature of
our test so it's actually found the
legit problem so when I've got my search
latest I now have to pass a second
function into that which is that perform
search and that just calls my search
whiskey's so it was found finding a
legit bug in my code cool
now everything passes so the style test
is really really nice because you're
working at your app level you can still
use abstractions for things so you're
not just testing the Dom so it's not
super brittle like UI tests and
everything's in memory so the nice thing
is if you are invoking promises and need
to resolve things because you've got
everything within your test you can
actually control when those promises
resolve one of the largest problems
around UI test is when you click on a
button and it's doing something
asynchronous you can't control when that
resolves so you have to kind of guess
similar to the way I'm doing the wait
800 milliseconds here but that's because
of the timer if I mock that out which I
can because it's all in process it's not
a separate browser window I can just
mock the timers and now I can tell them
also resolve so it's really really super
flexible and it's a lovely way of
writing tests any questions around this
before we move on to the API so sweet
so our API is up here so is everyone
using HughesNet here most people is
anyone actually using node no cool
I'll skip through this a lot of these
techniques I've actually taken directly
from the way I build web api anyway so a
lot of these can be applied directly
back to your dotnet project but I'll
move through it reasonably quick so here
I've just got a route that I define the
whiskey's route I then get the query off
the query string and then I call my
database function here I actually just
returned 200 and whiskey's and then I
returned the error this is written like
this very specifically I do not want
anything that's not HTTP or API related
in here so in the.net world one of the
libraries are used to facilitate this as
a library by Jimmy Bogart called
mediator and it allows you to plug sort
of middlewares in and it makes all your
API control is really really thin taking
the same approach here
so my test I actually just want to
create an in-memory database and then go
from just under the API surface area
through to the database this tests all
of the moving parts and gives me a heap
of confidence I'm using a library called
connects so it's very similar to entity
framework or in hibernate or one of
these all I do is my connect file which
is kind of my configuration to my
database I've got two options of
development one I've got test one test
one is simply an in-memory sequel Lite
database
so I run my database migrations this is
a super important area of when you start
doing these tests you need a
reproducible way of building up your
databases so another one of my open
source projects in net land is called
DB up and I use that quite fondly to do
the same thing the idea is you just have
a list of migrations and it just keeps a
record of which migrations it's run so
you can create an empty database and run
it up to a specific point so each of my
tests will just create an empty
in-memory database run the migration so
now I'm up to date and then set up some
sort of test expected data I then use
same code that I would use in my API so
importantly I don't call my API I'd call
whatever my API is calling so I remove
all of those HTTP concepts because I'm
going just below the surface this style
is called subcutaneous testing it's also
really useful if you're doing MVC on the
front end you can go just below the view
side so work at an abstraction below the
HTTP level and allows you to get really
effective testing without having to go
through something that you have no
control of so here should return all
whiskey's when get receives it called we
call it now this is a quite an important
technique that I use all the time it's
called creating a seam in your code so
if I go into my database get whiskey's
call actually I'm defining a second
optional parameter which is tests
database that allows me to pass a
database instance in that this method
will use if I don't it'll just use my
app like the applications one so that's
quite handy
so you can have a look if you look up
that pattern it's known as a test seam
it's quite common in the dot in the Java
space actually because I've set up the
data here I've only got one in there and
then I can just call to be one
I hate these sort of tests and I do this
all the time when there's some sort of
test data so this is a perfect example
if you have any of these in your code
once again just go get rid of that
change this to two should to match
snapshot and test that
so snapshot automatically gets created
and you can see the data from my
databases in there the great thing going
to keep going on about these snapshot
testing that are the best thing ever the
great thing is that we're really good at
seeing when there's problems with our
data writing assertions against the data
misses stuff all the time you kind of
just pick the most important things and
just ignore the rest snapshot testing
gets around that just go and take
anything out of the talk it's using
approval tests in your net API code or
something like jest or approval test is
super super handy technique so that
subcutaneous testing any questions
around that awesome
you might have seen here that I created
a mockable abstractions for external
systems this is an alternate way I
prefer creating an in-memory database
but if you don't have things like
migrations and the ability to quickly
stand up a database you can't really do
that there's another pattern which is
quite common well quite useful for this
problem is called ports and adapters and
the idea is that for anytime you're
talking to any external system create an
adapter for your application you can
then have multiple ports that plug into
that the idea is all of your application
code sort of sits in the middle and then
anything outside that could be the Dom
it could be API calls it could be
databases anything that's external to
your application make sure there's an
abstraction in place you can then test
through these ports or through these
adapters and at laugh and mock out the
other adapters because these ports and
adapters are well defined in your
application you're safe from refactoring
so an example is if you had an email
sender you could use an event emitter or
something like that just to decouple you
so that's the example of the adapter in
my application I've just call email
sender passed through emails and it
would just raise an event and then I'd
have two implementations I'd have a test
one and I'd have a real one I'd plug
them in the correct one in this leads me
to integration tests now we are because
we've got the we want to move from the
sort of all in memory to something
that's a little bit higher level problem
with them is out of process
communication means you lose control of
that out of process so if you're calling
another API you've got no control of
asynchronous operations in there you
can't cross that space it's completely
separated they're slow
there's often shared mutable state there
also tend to be fragile because of this
asynchronous issues in outside services
but we'll go ahead and do that anyway
for this I'm actually using a library
called super test I'm now rather than
going subcutaneous I'm going upper level
what I'm actually doing is using our
super test to create an instance of my
Express server so as it is anyone using
a scenic or yeah
so as vena core has a really really
handy test library for doing this you
can just pass it your application
bootstrapper and it will create you an
in-memory test database sorry in memory
test web api and you can get HTTP
handlers back for that super super handy
super test similar sort of thing i'm
passing at my in-memory database and
then I'm telling super sis to start that
server so at least they're sharing the
same in-memory database it then is
actually making real HTTP calls and then
validating that solution so this is
there's a few downsides of going up to
this next level you just lose the
ability to reach into the API and
control things like asynchronous
operations and timers and that sort of
thing
the advantage is any sort of middlewares
or action filters are going to be used
yep the question was out of interest
what does the snapshot look like exactly
the same as the other mainly because I
am NOT snapshotting the entire result
I'm just stop showing the body those two
snapshot the results would see I have a
failure and it has the entire result so
things like the headers that have come
back so quite useful as well
just snapshotting the entire result
because for instance if you changed
cause settings on the API calls you
would have all your snapshots failed so
you could see the impact of your change
that's massive advantage of moving up
that one level
cool so UI tests along same way as those
integration tests they're out of process
one area that I do really really like UI
testing and they've had a lot of success
is smoke testing deployments so create a
small suite of UI automation tests which
do not run as part of your CI build but
if you have like a continuous deployment
environment whenever you deploy run
these smoke tests against the deployed
environment and they should do things
that are like business critical
functions through your application the
reason why I find them not very useful
for other reasons is it's really hard to
reach in if you're going through the UI
there's a lot going on you can't
necessarily see that there's
asynchronous operations going on behind
the scenes you don't know when to wait
those sort of things and also you
normally won't have a way to reset the
tests unless you close down the UI and
reopen it your tests will actually
impact each other so if they're running
randomly the first test may change the
result of the second one this is why
it's good for smoke testing because
you're just validating that the
application works
you're not validating correctness of
things but I'm going to show you some UI
test patterns for our react application
so if we go back into our app test here
you'll notice that I'm going app bind
and then I'm calling a simulation event
and then I'm waiting for things instead
of mounting if I actually created a
something that encapsulates that so I'll
just call this app page
so just create a constructor here
javascript has classes now
so when I create my app page it'll mount
the application I can then move this
into a function which can be called
search for whiskey this is for a term
and I'll move that in here so those who
haven't seen a sink and a weight it's a
something that's coming to JavaScript
quite soon if you're using net you've
probably all seen it very very similar
concept it's going to be it's currently
in typescript and you can plug in a
bunch of plugins to Babel to enable it
essentially it allows you to just
decorate your function with a async
keyword and then that function will
return a promise instead of returning
the value so I'll encapsulate all of
this searching logic into this page
object so now what my test starts
looking at is I can just go Const app
equals new app page app search to
whiskey and I'll call it Glenn again and
then I'll change up here
so the event that simulated is passing
in the using the value I pass in we can
then go Const results equals app dots
get results
so what this will do is I'm
encapsulating the fact that each of
these results are in a span I don't want
my test to know that and instead I'm
just going to return a list of strings
which are the test results now I can
just go results and remove the dot text
and that will be potentially a single
that won't work it's going to go dot
text for the moment
that was our existing test so just go
back and fix that
to make the noise
cool so here I have broken it because my
snapshot was saying I did have that and
now I've got nothing
can anyone see the back we'll progress
anyway we get the idea so this is called
page object pattern
the idea is you encapsulate the
functionality of your application into
an API so then your tests consume the
API rather than directly manipulating
things yourself the major advantage of
this is if I refactor my UI I only have
to make changes to one page object to
make all my tests pass again so it's
another technique for just keeping your
UI tests maintainable
yes so that the question was was the
sole function of the get results
function to facilitate your tests yes
the page objects will only be used by
tests they are essentially they live
alongside your tests to logically wrap
your application so rather than having
to know how your application does things
it pulls that in so you don't believe
that into multiple tests and the last
type of test that I want to show you is
defensive tests so this is our just a
bit of a concept for in this test I have
I'm mocking things out and I'm calling
fetch mock catch so if I remove this the
test will fail worse than it did now
I've got the broken test but if I remove
that essentially the test will fail
because it's throwing directly now often
when you're at this higher level you've
got error handling
so you'll gracefully handle that arrow
and your tests won't actually see that
things have failed so something that
I've started doing in it at the moment
I'm just using I'm just going to give
you one example but I'm using this for
quite a number of things is I want to
make sure that if I have an unmatched
API call I fail my test so actually the
only way I can do this at the moment is
hooking into the console output so
whenever I get a console message that
says unmatched I'll push it into an
array and then after every test if I've
seen any unmatched API calls I'll fail
the test
so here I've got a value of Glenn M I'm
just going to change the stuff
need to remove the other test
so I'm going to simulate the targeting
so I'm going to search for Glen mo but
I've mocked out Glen this often happens
as your API evolves and things don't
quite match up so here I've got this
unmatched get to Glen mo and for some
reason that's not finding the error
got too many hours now
I'll skip that as well but the
essentially the idea is that think about
when you can do this so anytime that
you've got a potential condition in your
application if things happen too many
times so additional API calls I've had
bugs in my single page applications
before which due to some state
management issues I create two API calls
for the same thing if you explicitly
make sure that you only mock out once
instead of multiple times those sort of
issues will find themselves so actively
go out and think about what can I test
that is not just what I'm expecting that
the negative so fail when my test does
something I don't expect as well it's a
bit of a recap of all things that we
have talked about testing in node much
faster than spinning up browsers
definitely can still do that but it has
its place snapshot testing amazing get
on that use different styles of testing
all of these are completely valid blend
them what you want to do is make sure
that your tests are quick and reliable
and all of those sort of things don't be
afraid to try and have a little session
and workshop how can we actually solve
this better and then testing doesn't
have to be painful it really can be
quite pleasant
if you continue pushing these things
testing can be really valuable and are
and not up endurance to refactoring
thank you any questions
come grab me after I'll be around sir
just hanging in the main hallway for the
next hour or so and thanks everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>