<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How to stop worrying and love MSBuild - Daniel Plaisted | Coder Coacher - Coaching Coders</title><meta content="How to stop worrying and love MSBuild - Daniel Plaisted - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How to stop worrying and love MSBuild - Daniel Plaisted</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CiXlVrbBepM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome my name is Daniel places I
work on the.net the dotnet team at
Microsoft and I'm going to talk about a
mess filled and sort of the stuff that's
been going on with that will cover kind
of the journey that we had away from him
has spilled a little bit to project
Jason and back and why that happened and
then a lot of the improvements that have
come in Visual Studio 2017 and in that
are coming in update three for msbuild
and dotnet core and dotnet standard
projects and then we'll look at basic
msbuild concepts so that you can
understand how to customize your build
and we'll see how the investigate see
what's going on with the build figure
out what's going wrong and we'll look at
in these new style of projects kind of
the defaults some of the defaults that
apply and how to modify those if you
need so I joined Microsoft in 2008
because I just loved dotnet and I was
really excited about it and I ended up
on the mess the managed extensibility
framework team that was one of the first
open-source dotnet projects at Microsoft
and I say quote unquote on open source
because it was open source in the sense
that periodically we would take the
source and we would copy it over the
code flex but there wasn't any mechanism
to accept contributions and if you
wanted to change the source code and use
your own version there was no really
easy way to recompile it with your
changes and then drop it in as a
replacement so I'm really happy with
what we've been doing over the past
several years with the dotnet framework
moving to you know almost everything is
open source it's open source by default
getting lots of great contributions
having development and they open and
everything but that doesn't mean that
you know we've done everything perfectly
there's been some bumps along the way
and so first I'm going to get into a
little bit of the background of what
we've been doing for context and so we
have the dotnet framework this is the
the platform that we have that has
traditionally supported desktop and web
apps mainly and then xamarin is based on
mono that's another dotnet platform that
supports iOS and Android apps and then
the new thing is dotnet core this is a
completely open source and
cross-platform version of.net
it runs on Linux on Mac OS and on
Windows and each of these kind of has
different app models for the types of
apps you can build with it and they each
have their own base libraries so there's
a base class library set for for each of
these frameworks that has stuff like
file i/o and collections and Link and
all of this basic.net stuff that you're
used to and that the reach of dotnet is
great but when you want a target dotnet
having a separate base class library for
each one wasn't a great job and so a
great thing to do and so what we have is
dotnet standard and this is basically a
unified based class library that says
that the same API is base api's will be
available across all of these platforms
and if you've been following the past
few years for the past five or so years
we had something called portable class
libraries and I worked on those too and
to me dotnet standards is kind of the
new and improved version of portable
class library so it does do the same
things it's better and I don't have time
to go into the details of that but I'd
be happy to talk to you about that
afterwards so but what we've been doing
over the past couple years is working on
dotnet core and then dotnet standard and
when we were working on that core we
came up with this new project format
called project up Jason and msbuild has
traditionally been how you build net
apps
but at the time msbuild was an open
source it didn't run cross-platform and
it also had kind of a lot of baggage it
was verbose hard to edit / arctic valve
manually and we were looking at tools
like nodejs where it was really just
simple you just edit a simple text file
and that's your project you don't need
any complicated tools and so we came up
with this project format which was had a
lot of great features so it's simple
human editable project files
it doesn't explicitly list each source
code file it just by default it'll just
compile all of the see sharper visual
basic or whatever source files you have
in the directory it could produce new
get packages directly traditionally what
you would have to do to create a new new
get packaged would be to create a new
spec file which listed all the things
that would go inside the new get package
and the metadata about the new get
package but with this format all of that
information was just directly in the
project file and you could just say pack
this up and it would create a new get
package and the project could target
multiple frameworks so we're introducing
this new dotnet coarsing we still have
the fold out net framework maybe you
have portable class libraries UWP
xamarin you could list multiple
frameworks that it would target and it
would compile the project for each one
of those which was pretty convenient if
you if you needed to light up platform
specific functionality and it also let
you switch you could have a reference to
a new get package that was easy to
switch the DAP that out with a local
copy of the source so if you find a bug
you just clone the source and then now
you're debugging you're fixing the bug
and using that local copy so that had
some some great advantages but about a
year ago we realized that we had the
switch back to msbuild
and there were various reasons for that
everything else in dotnet used msbuild
and when we think about dotnet standard
we want you to be able to write
libraries
run on dotnet core but that will also
run on dominant framework and xamarin
and uwp and so all project types need to
be able to reference that standard
projects but references between
something that was project Jason and MS
build in either direction just we
couldn't make that work well we had some
hacks but kind of work but it in the end
it just wasn't working very well and
then we have the tooling of the ID
Visual Studio understands and that's
build projects and we had written a
completely separate piece of project
system in Visual Studio that understood
this kind of but there wasn't a uniform
way for tools to work with dominant
projects and when you have other IDs
other editors like the whole ecosystem
was built around ms built and then ms
build has lots of extensibility and
power you can pretty much do anything
you want with ms build and that wasn't
really supported by project Jason so if
you just want to compile a set of files
for a project that works or if you just
want to do something some functionality
that was pre baked that we had thought
of and implemented for you then that
worked in project Jason but if you
wanted to extend your build pipeline
there wasn't a good end end way of doing
that for example some people want to
generate code files you got using
protobufs and so you have a definition
of your protocols before you compile
your project you want to generate
c-sharp code for those interfaces and
then after you compile it you may want
to manipulate the il there's some il
weaving projects like so D which will
add inotify property changes or do other
transformation on the result of your
compilation and there were you could
have like scripts that would run before
or after bill but when you have a
complex pipeline that starts to break
down when you want to support things
like
incremental builds only building what's
changed or parallel builds and things
like that
and my pet peeve was that project Jason
did not support comments that's
something that if we have moved forward
with project Jason I think we would
eventually fix but the Jason spec does
not support comments so this didn't
support comments so we said we told
everyone hey we're going to move back
then as filled but this was msbuild this
is new project console app in dotnet
framework in Visual Studio 2015 so
that's quite a bit more verbose doesn't
have those advantages that project that
Jason had and we said you know we know
that project Jason has these great
advantages and we're going to bring them
to msbuild
but the joy of open development is that
we announced this change of direction
pretty much at the same time that we
made it and before we have all of the
details worked out of how that would
actually work so all we could really say
was you know trust us it's going to be
great and judging by the reaction online
there are a lot of people who didn't
really trust us and think it would be
great and that's quite understandable
but so since then we've worked on making
lots of changes to msbuild and the
visual studio and the project system and
so what we have today as of Visual
Studio 2017 our msbuild projects that
look like this and so this has basically
all of the advantages that project Jason
had now if it's XML so if you prefer
Jason I'm sorry about that but given
that it's XML it doesn't have lots of
verbosity it doesn't have lots of
information that's not needed the
philosophy behind this new style of
projects would have sensible defaults
that you could override if needed and so
the only thing you really need to
specify about a project is what am i
targeting what version of.net for done a
standard or what am i targeting and here
it's saying it's an exe it's an act
that's how you say it's an app and so
we've kept
all of those advantages of project Jason
the one that we don't have entirely is
swapping out package references with
source you can kind of do that but we
will hopefully do work there eventually
to make that a bit better but everything
else we've pretty much got and so let's
look at some of this so for context
we've made lots of improvements and what
they apply to right now is dotnet
standard projects and dotnet core
projects and asp.net core projects that
run on the dotnet framework that's what
we support with this new style of
project it is possible to try to use it
with other scenarios other fold net
framework projects and that's kind of a
use at your own risk
if you are hoping that a lot of the
Visual Studio features such as designers
and stuff for winforms WPF or classic
asp.net a lot of cooling and Visual
Studio may not work
it might compile it will probably
compile but a lot of the tooling that
won't work and so we hope to bring this
to more types of projects in the future
but right now that's what it's supported
for so let's take a look at this so here
I have a project and let's look look at
what the project file looks like so I'm
going to right click on the project here
in Visual Studio and I'm going to go
unload project right that's what I have
to do to see the project file but wait
what's this
edit handle here left cord SES ROG so I
can edit this project file directly in
Visual Studio without closing it
Hey so what am i doing next
so here and you know the tools in Visual
Studio still work so I can modify this
project you know by going in solution
Explorer adding files and stuff but I
can also just type if I want so if I
want to add another package I can say
packard reference include equals well
know the time right and okay and so now
I have a package reference to know the
time now maybe I want to by default unit
you see that I have a bunch of source
files here but I and they're not listed
in the file but maybe I want to include
something that's outside of this project
folder so I prefer to put this in a
separate item group because it's a
separate type of item but it could go
with the package references so compile
include equals dot slash common /m DDM
does yes okay okay so I've typed this I
have not saved so you know I'm going to
hit save and have a blender that yet
you'll see it show up there
let's move the mouse here save all
that's not supposed to happen
whoa demo sale I'm also had a syntax
error there what sucks yeah that was my
clicker I flipped down on the clicker
which eventually gives me next
okay so now we see that that file showed
up so we'll just comment that out save
it disappears uncomment it save and it
shows back up okay well this is a file
you know that's included from elsewhere
and it shows up here and there's a
little link symbol there but you know
maybe I don't want it mixed in with the
rest of my source files in solution
Explorer maybe I want to show it
somewhere else so base equals shared
okay save so now that same put it in the
shared folder and this is new that
specific feature is going to be new in
update 3 of vs 2017 so it won't work if
you're just on the the RTM release right
now but the the link metadata here is
where it shows it in visual studio but
that needed to include like the whole
file name so now we've added a link base
which will just be the start of the link
and then if you have a glob it'll
include any recursive folders and then
the file name in the extension ok now
let's see what if I'm adding a new file
here so we're just going to copy a file
here copy and as I face it you can watch
and it'll show up there in solution
Explorer paste ok so there we go ok so I
can just move files around copy them to
the project folder and they'll just show
up but I actually don't want this file
right so I can right-click and I could
say exclude and it's removed and you can
see it just puts sorry it put it up here
it just puts the exception to the
convention in the project file in es2015
you could use wildcards at the MS build
level to include source files and some
people did that you know compile include
star star slash star CS
the issue with that is Visual Studio
would happily read that but anytime it
wanted to make any edit to it they would
just expand that out into a separate
compile item for each file but now what
kind of respects the defaults and just
knows this is the piece that needs to be
changed okay oh man I've made a mess of
this project I just want to go back to
what I had before so I'm going to just
get reset and it's going to reload in
place here presumably is that the right
folder yeah okay made the software here
there we go and so it's just reset back
to where it was I doesn't ask me do you
want to reload the project file or
anything it just reloads in place and if
I want to switch branches same thing get
check out move files I think move codes
okay enter and I moved all of those
files to a subdirectory I have a new
package reference that retargeted from
that standard one three two one four but
this all just works okay and then
another feature that was in project
Jason and that we have is multi
targeting multi targeting means to
target more than one framework in a
project and we used to kind of call this
cross compiling but cross compiling
kinda has another accepted meaning it's
like compiling on one architecture or OS
for another one like from x86 to arm and
so we decided to use the term multi
targeting for the dotnet of compiling it
multiple times for different platforms
so all I have to do there is it says
target framework which is singular I
change that the target frameworks which
is plural and then I can just have a
semicolon separated list here so I want
to also target net four or five okay and
save it in that case it has to reload it
but now this project targets targets to
frameworks and if I go Madeline if I go
in here I have this context drop-down
and so this shows the different target
frameworks that I'm that I'm targeting
and I can switch between them and get
intellisense and syntax highlighting and
everything for each of those and I also
have conditional compilation symbols
based on that so I could say if net for
five right so that's grayed out right
now because I'm in the net standard
context but which the net for five and
it's not grayed out and intellisense and
everything works the same way and that's
probably going to give me a compilation
error so let's get rid of that does it
need that and then creating a new get
package right so I can just invoke the
pack command pack means create a package
on this and it will build it and it look
for you then you get package so start
plus okay so Kendell here them for this
is my project bin debug and here's my
new get package so we see that we were
compiling for different target
frameworks it's the same DLL so it needs
to have a different output path for each
target framework so that's what these
folders are under here and that's where
the output goes but the NuGet package is
for all target frameworks so we open
that up and we see we have a new get
package that has the assemblies for the
the frameworks we're targeting so very
easy to create a new get package from a
project with multi targeting if you like
okay okay so what do you need where do
all these tools come from there's
there's a couple things to cover so
Visual Studio 2017 that is the the first
version of Visual Studio that has a
Lovely's features and update three is
coming out sometime soon and it's going
to have a little bit more and Visual
Studio includes an MS build which runs
on the full framework that's the
traditional version of ms build it runs
on sole net which means it supports
targeting all of the different platforms
such as uwp WPF xamarin it's all built
on that full framework ms build and new
and visual studio 2017 maybe studio 2017
supports side-by-side installs and so
each copy of Visual Studio 2017 actually
has its own version of ms build and you
invoke it using just calling MS build
from a Visual Studio command prompt and
that will set your path so that is
pointing to the corresponding version of
NS build for that version of Visual
Studio we also have the dotnet core SDK
sometimes we call this the CLI or the
command-line interface and this is what
you'll download if you go to the dotnet
and look at like the command line
experience or it's available for Mac and
Linux as well as Windows so if you're
doing cross-platform development this is
what you'll let's use and so the dotnet
core SDK includes a copy of msbuild
that runs on botnet core and you run it
with the dotnet command so the dotnet
command that's the dotnet CLI and it has
a lot of different commands one of them
is MS though and that is basically the
same as calling them it's gold except
that we'll use the core version of MS
filled instead of the full framework
hopefully normally it won't matter that
much but when you start to get into your
building projects that require paths and
targets that don't run on down that core
if you're trying to do some of this
stuff then it can matter
and a lot of the other dotnet commands
are kind of implemented as wrappers over
msbuild
so you know there's got net clean
there's net pack which invokes the pack
target just like right-clicking in
google studio and clicking pack that
invoke to the pack target so a lot of
the dotnet commands are implemented in
terms of msbuild and then there's
microsoft's net dead sdk and that is
what you so I get that from here so SDK
equal microsoft.net not SDK that is what
supports a lot of the simplification of
the project files msbuild is a generic
build engine which includes a lot of
functionality to build dotnet apps but
the way that we made the project files
simpler is we put a lot of it in this
sdk functionality now that that sdk is
delivered as part of the.net core sdk
and in Visual Studio thousand at Visual
Studio 2017 update 3 both the whole
framework msbuild
and the.net core msbuild will use it
this sdk from the taught net core sdk we
have a problem with naming a few if
you've noticed but that means that if
you install the preview of Visual Studio
2017 update 3 today then to get the new
support for dotnet standard - OH
dot net core - oh and some of the new
things we've been doing in this project
like that link base that I showed what
you do is you install the update of this
and that will update Visual Studio will
use that as well as the command line
will use that and you'll get the new
functionality so you can update some of
this functionality up out-of-band and
the love of the dotnet core support and
botanist standard support will come that
way
global debt Jason so global Jason is
used to select a specific version of
the.net core SDK and it kind of applies
to all folders below it unless there's
another global Jason nested under there
generally you shouldn't need to do use
this except if you're still using
project Jason then you need you need a
global Jason with this in it to say I'm
going to use this version of the.net
core SDK which supported project Jason
otherwise don't use it by default is my
recommendation but if by accident we
make a breaking change then this is kind
of the escape hatch that you install the
new version and it broke something and
then you can use this to say no don't
use that new version that I've installed
use this exact version it's not our
intention to make breaking changes
although in msbuild everything is global
so any change that we make could
conceivably be a property name that you
happen to use for something else but in
practice we don't expect there to be
breaking changes in general but you've
got an escape hatch if you need it so
let's cover some basics of msbuild
properties so properties go in a
property group and they're basically
scalar variables you've got a name and
you've got a single value that goes
along with it
properties can be based on other
properties so here we have a version set
the 101 and then here for the you know
the net for part version we're adding a
dot 0 to the end of it so the way that
you get the value of a properties with
this index you get a dollar and then in
parentheses you have the name of the
property and then here we're just
setting file version to exactly the same
value as Assembly version this syntax
for property value you can use that in a
lot of different places in msbuild most
places where you can specify a string
you can just put all our property and
get that property value interpolated in
there
conditions so you can add a condition
attribute to to most things actually in
msbuild so this is the defined constant
property and that's the compilation
constants that will be passed to the
compiler so here we're saying we're
going to take the existing value add a
semicolon the net standard if the target
framework is no standard - oh well you
know this this is great that we have
that capability you know you can have
arbitrary conditions which is powerful
and sometimes you need that the syntax
starts to get not so beautiful here and
this normally wouldn't be too bad it's
just that you know on the slide the word
wrapping is makes it a little bit ugly
you can also put conditions on the
property group so if you're working
within the constraints of what can fit
on a slide you could put that condition
on the property group and then it
doesn't have the word wrap as much and
it means the same thing so properties
are single values variables with single
values basically items items represent a
list of values and the element name is
the item type such as compile or content
reference package reference it can be
arbitrary so msbuild items compile these
are what msbuild generally uses for your
source files what's what's it going to
pass to the compiler
content this is the content item type
and then the reference now items may or
may not refer to a file on disk so these
refer to a file on disk and usually it
depends on the item type compile needs
to be a file that exists it's going to
pass that the compiler and if that file
doesn't exist the compiler will complain
reference here
well reference because of the way it's
used by the build process it might be a
file on disk or it might not so here I'm
referencing something that's going to
resolve to something in the in the
reference assemblies and so this isn't a
literal file in my project but here I'm
referencing a path that's this dll on
disk
and so items might be files they might
not be it depends on which items they
are and how they're used items can have
mega metadata on them so and again items
go in item groups right property is
going property groups items go in item
groups items can have metadata so items
are a list of values and each value can
have corresponding metadata so the the
value for this package reference item
here is Newton's up Jason and then the
version is 1002 so this is metadata on
that item may the data can be as of
msbuild 15 can be specified via an
attribute like this it can also be
specified as a sub element here you know
usually this attribute in texas cleaner
that's why we added it but sometimes you
want to want it like this especially if
you want to put a condition on it
there's some cases where where you'd
need to do that and just because that's
the traditional thing that's supported
you'll you'll see that a lot if you just
browse through existing and ask old code
so you can have wildcards for items or
globs
and so compile includes star star access
our CS so this means recursively
anything and then you know any file that
ends with dot CS and then content
include all the text files and copy it
to output directory now copy to output
directory that's made of data on that
item or these item values that are going
to be produced and the build system
knows about this this type of metadata
now so so when you have a a wild-card
here a glob it'll search the filesystem
for everything that matches that and
then create an item value for each match
now this has actually got a problem here
if you're going to end up copying all of
the text files to the output directory
typically your output directory is under
your project folder so the first time
you build it and copy it there and then
the second time you build this would
actually match
in your output directory so you'd have
another text file which would probably
then be copied to an output folder under
your output folder and each time you
build you just get more files so you can
also exclude exclude things from items
usually when you're doing a wild-card
and so here since I'm doing it a couple
times I've defined a property which is
the pattern that I'm going to exclude so
I'm saying everything under bin and
there's everything a table the output in
the intermediate folders and then I'm
using that property value in my item
includes here so I'm saying include all
of the c-sharp files except the ones
which are under the patterns specified
by this property so that kind of fixes
the problem we talked about okay that's
items so project imports so you have
your project file but you can import
other project files and msbuild calls
calls all of them project files usually
we think of the project file is just the
main thing your entry point that you're
building but the syntax is import
projects equals and then the path so you
might want to import some common logic
for everything in your repo you could do
that by specifying the path here before
we have these simplified projects every
single project that you got near the end
would have something like this which
would say import project roll this
msbuild tools path which is a built-in
property than msbuild
under the MIS build installation and
then Microsoft that sheet c-sharp dot
targets are visual basic or whatever and
so this was how the common build the the
build logic specifically for the.net
framework in c-sharp was imported
now with the SDK attribute the
microsoft.net dot sdk that we've added
we kind of have implicit versions of
those and so the syntax is a lot cleaner
and you don't have to have this kind of
thing in your project file so you can
see here it's the extension of procs
here the extension is dot targets those
are conventions msbuild doesn't care
what the file name is but
the convention is props file sense for
your properties and those are the things
that are imported near the top so before
the body of your project is evaluated
generally and then the targets would be
which generally imported at the bottom
or after the body of your project okay
so how do you actually do something in
this build
well that's tasks and targets so task is
a unit of action and does something
creative director 8 you know something
with the file system maybe create a
directory copy files call the compiler
or you know some arbitrary computation
or action and there's a lot of these
that are built into msbuild and but you
can also write your own in c-sharp or
you know another botnet language now you
can't have a task by itself tasks go
inside targets so targets group the
tasks together and then they express the
dependencies between those operations
and they do that with you know depends
on targets before targets and after
targets so these are attributes that you
can put on a target to express these are
the dependencies between them and so the
the set of targets that run and the the
order that they were undependable to daj
a directed acyclic graph if there are
any cycles then you'll get an error and
you have top-level targets which are
kind of entry points which are the
things that you build such as build
clean rebuild publish and pack and then
those have you know dependencies and so
when you say build it'll go through its
dependencies walking the graph until
it's completed doing everything that it
needs to do now each target is run only
once and so if you run target one and
then you're in target two but they both
of them depend on target 3 well then
it's going to run it's going to say I
need to run target 1 Oh before I do that
I need to run target 3 and Oh run target
3 run target 1 and then when it gets the
target 2 it says
I need to run target 3 that says I've
already run that so target will never
run more than once in single build and
so you know I said there's a dependency
graph so this is an example of part of
the default dependency graph and you
know you can't see the details there but
the compile compile depends on core
compile which is what I think actually
called the compiler it depends on
resolve references which depends on
resolve assembly references which
depends on the bunch of stuff so there's
a bunch of stuff that goes into
compiling and this is kind of the
default set of stuff that it needs to do
so when you when you build a project
what targets does it run well by default
it will usually just run the build
target
there's the rules about what it will run
by default but if you say Ms filled or
dotnet M is filled it'll usually have
the build target as the target that it
runs you can specify which target to run
with /t command-line options so /t :
clean that will run the clean target now
you've got dotnet and so just watch out
about the difference between dotnet
build and dotnet msbuild I when I
started working with the.net CLI I was
just using dotnet build for a bunch of
things that's what called msbuild right
it turns out that that specifically
invokes the build target so when I tried
to do dotnet build slash T :
my custom target it was running both of
them and I could not figure out why and
that's because it ended up translating
into calling them as build slash T build
because that's what this does and then
flash T my target which I had done so
that's just something to run a watch out
for to understand dotnet msbuild versus
dotnet build now in the 2.0 dot net core
SDK uh most of the commands that need it
such as build or publish or pack will
automatically do a new get restore
before actually running them so there's
a button at restore command
which will run NuGet restore but in 2.0
SDK you most of the time won't need to
do that dotnet build dotnet run anything
that needs it will basically do that for
you but dotnet msbuild would not dotnet
MS builders kind of just raw invoke and
s build with these arguments that I've
specified so this is what a target looks
like so it's got a name and it can have
but four targets after targets depend on
target so this is saying you know run
this before prepare for publish so if
you're publishing somewhere in that
graph of targets is probably a prepare
for publish target and then you put this
in your project file and it says run
this target before that and since these
are tasks so there's an exact task which
is built in them it's the olden that
means you know start this process call
this command and so here we're doing npm
install and vmware and build now this is
a common kind of thing you need to do
you know run the script before and after
this actually caused some issues because
the way that msbuild works is first it
does evaluation of the project so it
goes through and it walks the project
and walks through all of the the imports
and it builds up well what are the
properties first and then what are all
the item values and then it starts to
run the targets and targets can also
have item groups and property groups
inside them that will modify that those
at the time that the target is running
but if you don't do that then the values
you get from the property from the
properties and the items are going to be
whatever it evaluated that during
evaluation before you ran any targets
and so what this command target ended up
doing is npm install and camryn build
that ended up you know generating some
javascript based on typescript and
putting that in the WWE folder and by
default everything in the WWF older gets
published but that happens at evaluation
and so what would happen is if your
first build you wouldn't get the files
that were generated by this included
the publish because at the time it was
evaluating that they weren't there so
that's the kind of more complicated
thing you can run and we we mostly fixed
that but if you had to do it yourself it
could look something like this
so how we've added an item group to the
target which is going to be this is
inside a target it's going to be
evaluated after these commands run and
so here we're saying include everything
from ww2 except what was already in the
content item and also our default item
exclude so our output and intermediate
path and stuff would be excluded and
here we see a new syntax so like four
dollars property name that's how you get
the value of a property the at symbol is
how you get the values of an item so
this will kind of expand into everything
that at this time was a was a Content
item and so that says we don't want to
add these things twice but if it wasn't
already in that we're going to add it
again so that's that's useful to
understand how some of the stuff works
this specific example you shouldn't need
to do that because we've built that into
the web SDK okay
so you've got to build and it's not
doing what you expect how do you how do
you investigate what's going wrong so
three things pre-process the project
look at the log file or look at a binary
or structured log so what we're going to
do is is we're going to look at that so
okay just get rid of them okay so I'm
going to build this so first what you
might want to know is you know I've got
all of these imports a lot of them come
from Emma spilled some of them are from
this net SDK some of them make them from
nougat package and you know who is doing
something who is setting this property
value that isn't what I expect it to be
or you know what does this target look
like so a really useful thing you can do
there is msbuild slash PP which stands
for a pre process and : you give it a
filename so I'm a spilled XML okay so
that when you do slash PP that that
doesn't actually run a build that just
does a a walk through your project and
all the imports and then it creates a
flattened XML file that shows you the
contents of everything that would have
been part of that evaluation so
okay so here we have it so this is the
output of that free process so here we
can see like this is the the path of
what was pre processed and then we start
seeing the contents of that project but
every time that there's an import then
we'll jump into that import so here we
have that SDK equal statement so that
gets that implicitly imports and file so
it tells you what it's doing here and so
that ends up importing this file and so
now we're in this file and now we're in
the contents of this file so this
comment comes from this SDK props file
and we can see what it's doing and then
it's going to end up importing some
other stuff so this is the import
statement that was in that file it's
commented out and then it also has a
comment that says well this is what it
ended up importing and so this is
basically going to show you everything
that was affecting your build and so if
you want to know you know who's setting
a property you can kind of look for that
although you know I can't spell if you
want a specific target you can look for
name equals a strong name right so this
is a target that's being injected from a
nougat package for example and you can
look at what it's actually doing what
it's passing to it what is passing out
of it now sometimes if you're looking
for something that are in the common
targets the targets file that come with
msbuild
those are sometimes kind of long so you
know where is this where is this
actually coming from well you scroll up
until you can see this kind of header
and it shows you where if you end up
looking at something in the common
target sometimes you'll have to scroll
up quite a bit okay so that shows you
what it was evaluated in your project
file but you know then what actually
happens so then you want to create a log
and so you can do I always do FLP
verbosity or V equals diag
and you know you can look at the command
line help for different options here but
what this means is file logger parameter
so that means it's going to use a file
logger and the parameter it's going to
pass to that as V so both of these is
Diagnostics so that's the highest
verbosity if I'm investigating something
there's different varieties but usually
if I want to investigate something I
just want the full level it's very
verbose but it might have something I
need it tells me exactly what parameters
were tapped passed to each task for
example and what came out of them so
it's usually useful so there I did a
build and then here I must build dialog
so you can specify the name of the log
file but by default we'll just be a mess
build log and then so this has lots of
information that near the beginning it
has all of the we've got property
reassignments which is something new but
then it has initial properties so this
is you know when it evaluated the
project file here are all the properties
and their values and then initial items
right same thing for items so if we look
for a compile so this had one compile
item programs es and this had a you know
this item the value was this and then
further indented these are the made of
data on that item okay and then it will
execute the target so here's where it
starts actually building and it's got a
bunch of targets that are skipped at art
like most elements and then as well the
target can have a condition on it so
saying well I would have executed this
except it's evaluated the condition
evaluated defaults and then when there's
actually something that does it says I'm
running this task I'm passing this
parameter to it if it has output of that
task you'll get that here it has all of
those information now so that's great
it's very detailed but you know I don't
think anyone's going to love looking
through this for both log file and
trying to figure out exact
what happened searching through text log
files is not great a lot of the time yes
the question is is there timestamps at I
believe I'm surprised it's not included
I don't know specifically on the text
log file I'm not sure now there is the
summary at the end that tells you how
long each target and how long each task
took so that can help you as far as the
performance the msbuild supports
arbitrary loggers and so the logger has
that information available it knows when
each event was raised I'm not sure if
there's an option on the text logger to
actually include that if you know at
each thing that it logs but it's there
but like this is somewhat useful and is
what we had to deal with until recently
now we can say msbuild slash dll duty
rebuild
okay so /bl means binary log so this
creates a binary log this is a compact
log format it includes probably more
information than the verbose log would
do but it's in a structured format so
you can't open up it up and look at it
in a text editor but you can have a tool
that runs over it and analyze those
other displays and that does include the
timestamps and so you could you could do
that this is this is new this is new in
update 3 so if you have vs 50 no it
won't support this /bl switch but 15-3
will and so by default it creates
msbuild in log and you can create a
different name there so but you you want
to do something useful with that so we
have NS called structured log viewer
okay so this is a cool to view these
binary logs and it it understands them
and has a nice display here okay pretty
visible so this has basically the same
information that you would have seen in
that diagnostic log but now it's in a
structured format and so you can see it
built this project and the initial
properties were these and the initial
items were these and you know it'll show
the metadata on them and then the
targets that were running ran the
rebuild target and that caused it to run
before rebuild clean this one and then
build and so you can see the the
dependencies of the targets you can also
you can also search so so if we want to
say resolve assembly references right
then you get results here and everything
that matched was all assembly references
and you can say I just want the target
with that name and you can find
specifically that target and then you
can go into that and so this has an item
group which added some items and then I
ran this task well this task had these
parameters right so you can just drill
down into all of the information it's a
structured format so it's a lot easier
usually than scanning through this
enormous log file so this is really
super useful for for analyzing your
bills yeah why 123 bills when I do an
incremental build so many blog post
about finding what
charming and then sort of covers it but
even on the give up issues or requests
one thing is service to me why is newer
or only extreme description in this one
what I just tell us why so the question
is about incremental builds and how can
you diagnose why it is rebuilding
something when you think it shouldn't
have to do that to work why can't we
just tell you hopefully we will someday
I'll probably probably the binary log
includes enough information for that
although I'm not absolutely sure but you
know that's just would be a great thing
to have incremental builds are
implemented by a target another thing
that the target can have is inputs and
outputs and so ms builds incremental
builds are based on timestamps and so if
you have a target that declares inputs
and outputs then then when it goes to
run that target little compared the
timestamps of those files and if the
outputs are all newer than the inputs
then then it won't actually run any of
those tasks it's a good question I mean
I don't have a great magic way to solve
that for you yet okay I think that's
that for that demo
okay so a couple more things a common
build logic so you know if you have a
repository with a bunch of different
projects in it you know sometimes you
want to use the same settings for all of
them and something like this is what we
used to do and so there this is a
built-in function so this is the syntax
for calling some built-in functions in
them as Bill get directory name of file
above and so that says look in the MS
build project directory and walk up the
directory tree until you find a dirt off
target file and then return that
directory name and then you know add the
targets of that so we're going to import
that if it exists so then we have to
have a condition with all that repeated
so that's useful and you know you don't
necessarily need to do that you could
just specify dot dot slash dot targets
but then if you change your hierarchy
around and you put it one folder deeper
shallower then it stops working so this
is more robust very verbose with msbuild
15 probably you want to just use
directories that build up props and
directories I'm bill targets so this is
built into the common targets now and
they will walk up the directory tree
starting with your project directory and
look for these file names directory that
build up props and directory build
targets and if it finds it it will
import them automatically and of course
the props will be imported very early
and the targets file will be imported
after most everything else and so what
can you do with that you can have
consistent package versions so if you
have a bunch of different projects and
they reference a lot of those same NuGet
packages maybe you want to use the same
package versions across your projects
and so you can just declare a property
that says this is a version of deuce and
soft I want to use and this is the
version of know the time and in the
project file then you have this version
metadata but you use the property value
here so this would be common across your
repo and then you have the package
reference in the project that uses this
common version you could put a package
reference in in your common logic if you
wanted to reference that
package from every single project but
here let's you pick and choose and say
if I'm using Newton softer than I want
that version another thing you can do is
a common output folder so by default the
output folder in the intermediate folder
will be under bin and AAB
in your project folder a lot of people
would prefer to just have one folder
that was like under the repo root so
that it's cleaner and so that they can
just delete that folder or get rid of
everything reset everything so this is
what you could do you would put this in
in a Property Group in directory that
build up props repo route so this is a
built-in msbuild property msbuild this
file directory so it's what file am i
evaluating right now give me that folder
and so that's just a way we create a
repo root property both because it's
shorter and then in if we're importing
targets from other directories than we
still have that reference to the repo
root anyway and then base output path
and based intermediate output app now
this would need to be in an SDK style
project for I think base output path is
new in the Microsoft net ck
so you're saying put it under output and
then msbuild project name so msbuild
project name is another built-in
property and so if you're building my
project CS proj then msbuild project
name will be my project and so this is
if you want to have a separate folder
for each for each project under this
common folder and so here we're
specifying where the the bin folder is
and then where the optional
tourism-based intermediate output path
the microsoft node sdk so when you say
project SDK equals this and I've said
Microsoft NS SDK if it's a web project
it'll be Microsoft net that SDK dot web
and that includes some additional logic
for web projects like handling the
wlwt's folder and and some other stuff
so but that will also use this basic
Amit
piquÃ© so that there's common stuff that
will apply to both okay default items so
you know you didn't see compile items or
embedded resource items in your project
directly by default it'll just include
everything in that project folder and
you know you can also include additional
stuff outside of that project folder and
you can exclude stuff by saying compile
remove equals file name dot CSS or
whatever you want you can disable this
entirely per item so enable default
compile items except that default and
you won't get any default compile items
enable default items set that defaults
and you won't get any of those people's
assembly attributes so when you're
converting from existing project to SDK
style projects you probably have an
assembly until that CF under your
properties folder or maybe in their
common folder or something that you've
changed you don't need that anymore
we just have properties that during the
build those properties control assembly
in tributes attributes that get
generated and so usually that's better
but if you already have an assembly in
Philadelphia and you want to keep using
that you can disable that so you can
just into each attribute that would be
disabled has a property that you can set
the faults to disable it or you can say
generate assembly info sets that
defaults in the bulb that will disable
it all together the default values of
these come from properties like version
file version company stuff like that
okay so I have this URL here and then I
want to show you one more thing so this
tiny URL coms /nd Co Co 2017 - msbuild
that's how you can get to this and this
has some useful links documentation
structured log viewer which I showed and
I said that that was a new thing in
update 3 but MSP also supports custom
loggers and so this project also has a
custom logger so if you're using them as
build from vs 2017 or probably even
earlier this project will let you use a
custom logger which will log the same
information and then
get the same kind of thing projects
simplifier this is a work in project
progress tool but what it'll do is it'll
take your project and evaluate it and
then figure out convert it to this new
SDK style of project so if you want to
take advantage of microsoft.net the SDK
this project will help you do that it's
still a work in progress I tried it out
you know and preparing for this
presentation and it left some stuff in
there that I still wanted to delete but
you know hopefully that will improve
over time and it's still pretty useful
and then resources systems the
documentation is actually pretty good if
you want to learn and I think I'm over
time so thanks so much I love to talk to
all of you about msbuild about dotnet
dotnet standard portable class libraries
whatever you want you can email me you
can contact me on Twitter you can come
up afterwards and there's that link
again thanks very much don't forget to
vote</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>