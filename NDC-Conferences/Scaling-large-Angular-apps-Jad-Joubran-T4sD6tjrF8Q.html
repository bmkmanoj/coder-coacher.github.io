<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scaling large Angular apps - Jad Joubran | Coder Coacher - Coaching Coders</title><meta content="Scaling large Angular apps - Jad Joubran - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scaling large Angular apps - Jad Joubran</b></h2><h5 class="post__date">2016-08-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/T4sD6tjrF8Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">morning everyone how's NDC Oslo so far
so today's talk is about scaling large
angular apps my name is Joe Gibran and I
found it
startup called a table and the MENA
region which connects patients and
doctors online and right now I'm
teaching with lo hago in Brussels
Amsterdam and Lisbon and I love open
source so I want to start by telling you
exactly what I mean by scalings because
it can mean literally anything and what
we're going to cover today is how we can
scale on an angular project the number
of developers and how we can scale the
performance and the functionality and by
functionality I mean how can we keep on
adding functionality to our project
because with time sometimes it can get
very hard and I will start with the
takeaway of the talk which is scaling
requires a solid code base so this is
why we will be exploring we will be
talking about JavaScript I'll be talking
about component-based architecture even
API calls then performance and at the
end I'm gonna show you how angular 2 is
fixing all of the problems because
mainly today I'm focusing about angular
1 so let's talk about JavaScript and
technically this is how it all started
in 1997 we had es 1 which is ACMA script
1 and then a year later we had ES 2 in
the 1999 es 3 and then for 9 years
almost nothing they're working on es 4
which wasn't released but then we had
the S 5 which is what you know today
which is what you're using ACMA script 5
and then for 6 years we've been using ES
5 no new additions to the language no
new features just like just like it was
so as I told you we've all been using
ACMA script 5 because we know it's
supported on all browsers but the nice
thing is that we will be having new
releases every year this is why you have
ES 2015 2016 2017 and so on and so forth
so I'm gonna talk a bit about yes 2015
and technically you already know es2015
that's because your es5 code already
runs inside es2015
so if i want to put this into a Venn
diagram you have this is your es5 code
then you have this super set which is
es2015 and then you have another super
set which is es2016
and now the reason why they created yes
2015 was to fix some of the es5 problems
and there are a lot honestly and they
wanted to bring modern syntax and new
features to the language and if you're
wondering how it works like how can you
write es2015 code if it doesn't run in
the browser because we don't have the
perfect browser support yet and all of
them what we do is we write in es2015
the new language and it gets transpired
into es5 we call it the s5 compliant
because all the browser's know how to
run it and we can use a tool such as
Babel for this so I'm gonna show you a
few yes 2015 features with without
taking a lot of time on this so we've
got template strings classes lat and
Const our functions and a lot more but
these are the only things that I'm gonna
show you today so if you were in the
previous angular talk you probably seen
template strings they're technically
likes regular strings but with backtick
we call it the back deck operator so the
back deck character and they allow you
to do multi-line strings just easily
without appending without concatenating
a string with backslash and to another
string etc and you can finally do
interpolation so if you got a variable
called name you can do interpolation
inside of it and this by using this
dollar sign curly braces and then the
variable name and then we've got classes
so in this example I'm creating my own
custom class which I called person and
it has a constructor like an issue
initialize function that has two
arguments first name and last name then
I can say this dot first name equals
first name same thing for
name so I'm setting the attributes then
I can create my own custom function for
example get full name and I'm using here
template strings which returns first
name space last name then if I want to
call it in my code I can say var John
equals new person and then John that get
full name but I have to tell you that
I'll keep it for a few seconds okay so
that's the code behind the classes it
makes things a more neat but I have to
tell you that this is only a syntactic
sugar so everything you know in the
prototype object oriented Java Script is
still the same this is just a way to
make them look nicer and then we've got
arrow functions so this is an example of
an arrow function I can say var say
hello equals I start with the arguments
and then to the arrow and then curly
braces and I have my code inside it
might look a bit weird the first time
you see it but it solves the problems
that I'm not going to talk about today
which we call the lexical dis but it's
very useful and it's it's short it's
short
then we've got let so for example inside
this for loop we create let X equal zero
and we can do console that log X inside
the for loop but outside the loop we do
not have access to X this is what we
call axis blocks code block scopes
not like the var which is when you
create it inside the for loop you have
access outside of it which can lead to
several issues later on so and then I'm
gonna talk a bit about typescript as
well so typescript compiler regular
JavaScript just like we used to do with
es 2015 to s5 but if you look at this
example which adds two variables x and y
you can actually tell typescript that I
expect x and y to be of type number but
don't forget that when you compile this
to or transfer this into JavaScript the
types will be gone and the easiest way
to show you the benefit behind this is
you cannot do a string to integer I know
this
is a dull example but this is the
simplest thing I can show you so it can
warn you when you do things wrong so
some typescript benefits are static
analysis are actually all the benefits
we get from static analysis because we
have it is now typed and we also get
code completion which is also awesome in
the text editor
so when I press dot I get exactly what I
should see for this function or for this
variable and as John Papa said if you
screw up it will tell you that's the
main benefit of typescript
and then there are other types crypt
features for example I showed you a bit
about types and I'm really interested in
interfaces so I can create an interface
call it I user I for interface it's just
the naming convention and I know for
sure that this interface will have a
first name of type string and the last
name of type string and can have
optionally an age variable an age
property of type number the optional is
because of the queries the question mark
so you can think of interfaces as a code
contract and you know this is very
beneficial in teams if you have a code
contract so with the same interface I I
hint the user variable to be of type I
user now I know that I can get the auto
completion of user dot first-name and I
know for sure that it should exist so
these things are very beneficial when
you're working on a team so as a recap
for all the JavaScript that we've been
talking about everything is transpired
into s5 right now but it can change in a
year or two so once we have es2015
support across all browsers you do not
change your code you only change the
config file and instead of transpiling
into s5 we transpile into es2015 and so
once again the Venn diagram is we have
es5 then we've got a superset which is
yes 2015 then another superset yes 2016
and we have this huge super set which is
typescript
so typescript allows you to use the
future today allows you to use all the
nice things all the nice features just
today so that's it about JavaScript and
now when you are starting a new project
and angular we often know that if you
want to setup your project by yourself
it's gonna take a lot of time and it's
almost impossible to get right because
there are so many things involved and if
you think you got it right just wait a
couple of weeks and you will start
seeing that the folder structure is not
working properly so I would like to
introduce you for an angular 1 generator
that can generate your app so assuming
you have you which is yeoman a generator
and
gulp and Bauer installed you can solve
this generator and then just run you got
- angular and what this thing is gonna
do is just ask you a couple of smart
questions I summarized some of them so
would you like to use the rest resource
library which means it gives you options
like would you use would you like to use
dollar HTTP or maybe dollar resources or
restangular and you can choose whichever
option you like then it asks about the
UI framework so would you like to use
material design Lloyd angular material
bootstrap or even know your eye
framework you can choose between less
sass or stylus etc so you can really
customize it to fit what you're looking
out what you want and then mainly for
JavaScript pre-processing you can choose
between es2015 by transpiling
transpiling using bubble or you can even
choose typescript or you can just choose
plain JavaScript and then basically
that's it at the end it will run npm
install so it probably takes forever but
that's a really nice starting point and
now i need to introduce you to
component-based architecture so you
probably think that it's really all
about some kind of having a solid
codebase it's not about doing one
particular thing and component based
architect architecture is now possible
because of angular 1.5 and it kind of
mimics what's gonna happen in angular 2
so you're not learning something that
you will need to throw out in the
garbage
very soon and the benefits of
component-based architecture is that the
components you build are testable
producible and isolated isolation is
very important in teams so I will talk
about this later on now how many of you
are still using ng controller raise okay
so I will start with some of the best
practices that they have been
circulating in the community that we
need to get rid of plane controllers
and the simplest reason is because plane
controllers like ng-controller has been
removed in angular2 so what we do
instead we stick two components now of
course inside the component there will
be a controller but this controller is
strictly to be used by this component
it's not a global controller available
everywhere in your code so we only stick
to components and I can show you a quick
like from controllers to components code
so instead of having div ng controller
and then side menu controller you can
actually have more much more expressive
syntax which is a component I called its
side menu and I can even pass in custom
attributes like theme equals arc and if
you're wondering how would the code
behind this look in yes 2015 it would
look something like a class side menu
controller which has a constructor that
does nothing for now and then we can
register the component by saying angular
that module and then that component I'm
gonna register it as side menu with the
lowercase s and capital M and then I
need to point it to the correct template
URL so I say temperature outside menu
dot component dot HTML this is where my
view is gonna be and I reference the
controller by saying side menu
controller so that's a really nice way
to start writing components in angular
1.5 hands up for dollar scope come on
don't be afraid okay so you're you're
taking a picture okay so so we need to
get rid of dollar scope the reason why
once again is because it doesn't exist
in angular 2 anymore and it just
cluttered our code without any like
beneficial reason so what we're gonna do
instead is we will bind to this keyword
this by using the controller as syntax
how many of you have been using the
controller as syntax
great so instead of having this terrible
thing we're registering a controller and
then injecting dollar scope etc we will
be fixing it and - and in the view you
would have a name variable we would be
fixing it to use the s 2015 syntax and
the controller so we would have a class
and then in the constructor I do this
dot name equals Igor and then when I
register the component the only thing I
need to change is add controller as
dollar ctrl has anyone been using VM
instead of dollar ctrl yeah it's
basically the same they just change the
documentation the best practice for it a
few weeks ago or a few months ago and by
the way if I omit controller as it would
still work because this is a default
here but I needed to add it to so I can
tell you about it but then the only
thing that changes in the view is that
you need to prefix name with dollar ctrl
so this is where you probably see in VM
dot name and again that's how you can
benefit from this new syntax and make
your code look much cleaner
so then I'm gonna talk about components
and directives so there has been a bit
of confusion between components and
directives should I use a component
should I use a directive or is there
even a difference I'm just going to
briefly summarize it that components are
meant for UI components I know I use the
word component again but so when you
have when you're building your
application you can think of UI
components as Lego blocks so I have this
user detail here I have this to do entry
user info user profile those components
and when I add them together I will have
a page or a website and components
promote best practices by default like
the controller as syntax like the bind
to controller which will not see but it
has the best practices built built-in
and then for directives so they're
mainly meant for Dom manipulations if
you're doing Dom manipulations think of
it as if you were doing your own ng if
you would use a directive so they're not
mainly for doing your I components that
you will use for UI
and then for component isolation which I
mentioned is very important in teams I
will start with the folio structure
which is something you will get by
default if you use the generator that I
showed you
so the folder by feature architecture
allows us to group related features and
two feature files into one folder so
everything that relates to one feature
will be in the same folder and this is
easier to maintain especially on the
long run if you go back in 6 months and
you look at the side menu folder you
know that you will find everything
inside like the side menu dot component
dot HTML this is the view side menu dot
component yes this is the component
JavaScript file and I also have dot spec
DOJ's for the tests and for example all
the sass or less files in the same
folder and then the funniest issue is
coping CSS like we want to avoid class
collision and teams you end up having
the same class as being used maybe on
different components and changing one
property here would conflict another
property so you end up doing a meeting
and after the meeting we agree that we
will have unnecessary long names to
avoid this class confusion and it's not
really a nice way to deal with it and
also we want to scope CSS because we
want to keep our files short so I would
suggest using name naming conventions
like BM on or suit CSS has anyone been
using BM or suit CSS none ok so I will
introduce suit CSS but you can use B or
any other naming convention that really
thinks at the component level so on the
top I will show you the general rule and
below I will show you an example so dot
component name in our example is going
to be a button so if you're building a
component for a button we would start by
saying dot button with a capital B and
then we can have a modifier and the
syntax for the modifier is by having the
dash dash so dot component name dash
dash modifier name our example it could
be something like button large or button
so immediately when I see this - -
syntax I know that this is a modifier so
this is something I can add maybe next
to the button to change the way it looks
like and then we've got descendants
descendant so component name - only one
- descendant name in our example could
be a button - icon so now again I
immediately know that this is a
descendant of button and finally we have
the estate of component for example like
button is active so I will show you an
HTML example of this we can have
something like this div in the class
button then inside of it we told you
about the descendants we can have a
button icon and then you can have the
modifier so you can have button - -
large or you can remove it but that's
how the modifier is meant to be used and
finally you can also use as active so
once again the purpose behind this is to
scope CSS because up until now this is
the best thing we had I will mention how
angular 2 is changing this at the end of
the talk and what I really like about
suit CSS is that we don't have those
dangling classes anymore just like
Twitter bootstrap you've got dot nav bar
dot BTN everywhere and if you've got
some junior developers on your team
they're probably end up using dot navbar
add display flex and then the whole
website doesn't work so what suit CSS
tells us is it's better to prefix our
helpers with you you for utility so all
the utilities will be prefixed with you
- something that way you know that this
class is being used everywhere and you
should probably not have a lot of them
and now for API calls this is my
favorite part of the stock although
people will be wondering you might be
wondering why does what does API codes
have to do with scaling large angular
apps so I'm gonna ask you how many times
do you call your API and what I mean by
this if you look for for example door
HTTP dot get and dot post in your code
how many times do you think you will how
many results do you think you'll get
please raise your hands for thirty-plus
you can raise your hand again because
how many of you think it's 50-plus and
sometimes it's also 100-plus so if
you're doing something that frequent to
your code why not take a step back and
think how we can make it more fluent how
we can avoid boilerplate code so so in
this example I'll be using restangular
which is an API library and I'll use
restangular to remove all the bit of
boilerplate code so we can keep our code
dry and dry as and don't repeat yourself
and at the end we will notice that we
will have a fluent syntax so you don't
have to use restangular
you can use dollar HTTP and build your
own functions on top of it or you can
use another library but just for the
sake of this example so and the first
thing I'm gonna do is I'm going to
create my own API service so this is a
regular angular service I called it API
and I just return restangular with a
custom configuration and we will be
configuring restangular step by self
what this means is from now on you will
see the word API you can think of it as
dollar HTTP but it's my own version on
top of restangular so I'll start with
the basics and it's really good too
but the base configuration is very
important because imagine if you were
doing something like API odd get and
then you have this whole base URL and
then slash users once again API dot post
all of the year it doesn't really make
sense if you want to change the space
URL it's gonna take a lot of time and
it's not best practice so what we can do
instead as we can just configure in the
figuration part that I showed you can
just configure and set the base URL to
something like example.com - API slash
v1 I know this is simple but it will
save a lot of time later on and then in
your code you just use it as API dot cut
users API dot post articles has anyone
been doing something similar with Dori
HTTP okay we're on the right track and
this allows for environment based base
URL which is also simple but you can
easily flip the environment variable and
then change the base URL without adding
some tooling so if you're on staging you
can flip it if you're on testing you can
flip it and then for all remaining cases
you're on production so we need to use
the production endpoint and then same
for default headers if you're sending a
particular header on every request or
maybe every subset of requests you can
just set it from the configuration in
this example I'm doing content
negotiation with the server particularly
particularly asking for v1 and I'm
asking for a return type of JSON but it
could be any any header that you send
you can just set it from the
configuration and then you forget about
it now for the even more interesting
part our request interceptors how many
of you have been using them great so a
request interceptor is basically a
method that gets called before every API
call so for example this function which
uses the arrow syntax without request
interceptor this function inside the
block will be called every time before
sending the request so what this allows
I'm gonna show a few examples you can do
everything related to HTTP
authentication so whether you're doing
basic HTTP authentication JWT JSON web
token authentication or even token
authentication for example you can read
the token from the local storage if it
exists and then again check if it exists
and add the custom header instead of
doing it in a weird or bizarre way so
you can manage all your authentic
from inside the request interceptor and
then we will see the same but for
response interceptors so a response
interceptor is technically a method that
gets called after receiving data from
the server every time after receiving
data and the syntax looks almost exactly
the same but this allows us to do much
more powerful things so if I use both
the request interceptor and the response
interceptor we can handle we can manage
the loading state from one place of the
app so I can set a request interceptor
to start a loader this is where what
loader service that start does so when
we send a request we start a loader and
then when we get the response back we
stop it so I find this really elegant
solution especially in teams where you
have sometimes developers forgetting to
start the third loader or forgetting to
stop the loader so we can manage all of
this once and then never worry about it
and one more thing with interceptors
which is for errors and once again our
interceptors allows you to set a
function that gets called after there is
an error with the server so this allows
us to do even more things so also same
syntax
and the first example is handling
unauthorized requests so if your server
sends back 401 you want to redirect the
user to the log login page you can do
this by checking the response to status
for 401 401 as an unauthorized and then
you can redirect the user to the login
page for example so you do this once and
then later on when you're using your API
service you don't worry about it anymore
and another thing I'd like to do is to
manage validation errors because
validation errors occur on almost every
single API call so this is what we used
to do before it so you would say API dot
get users and then you resolve the
promise with dot then and then you have
to pass in two functions the first
function is the success callback okay
what should I do if everything was
successful then the next argument would
be what should I do if there was an
error so I would go and inject the toast
service and then I would show either the
data error message and you have to do
this every single time by the way this
is how a toast would look like for
example so instead of doing this tedious
process on every single API call what
you would do is start by configuring it
so four to two and some of the
frameworks 4 to 2 means unprocessed by
entities so and most frameworks it's
used for for validation errors so if
there is a 4 to 2 error I will take the
error message from it and then open a
toast
so with that piece of code you would you
would have solved the validation for
most of your application and then you
can just simply worry about the success
callback so you do API dot get users
then resolved the promise and then only
worry about the success callback
and if you're wondering that this is
making me lose my flexibility with the
code that is not true because you can
still pass on a custom error handler and
it will be executed so you're not losing
the flexibility of having an error
function but you're just setting a
generic generic way to handle all the
validation errors so you can do things
for other responses I just showed you
four for oh one and four to two and one
last thing with the with the dealing
with API sometimes and some projects
you're dealing with multiple api's and
we already saw how we can do it because
remember I created the class API that
extends restangular so you can create
another API for example API - that
extends restangular and has completely
different configuration so this is
highly customizable and will save you a
lot of time and that's a summary for the
API is look at the instead of doing this
actually instead of worrying worrying
about the headers the base URL success
and callback functions you can now do
all of this with just this
enough onto performance so just I will
define my strategy first the strategy
poor for performance is not going to be
about micro benchmarks I'm not going to
tell you to use a particular thing
instead of another thing because that's
not really the best way to approach
performance because in most scenarios
you have to rely on profiling and see
why this particular issue is slow
however I'll try to give you as much as
possible of generic rules that you can
apply and don't forget that the right
optimization technique will outweigh
thousands of micro benchmarks so this is
why we tell you not to waste your time
on micro benchmarks so angular has
something called Watchers but before
talking about tortures I'm gonna quickly
mention the digest cycle I'm sure you've
heard about it
it's basically angular's way of say of
checking what has changed so angular
does some checks okay what has changed
and then if it picks up some changes it
needs to update the UI that's basically
how it works
and how does it check for changes it
goes through a list of fortress so
things that angular kind of watches and
it sees if they change now what are
Watchers so Watchers are created when
you have an expression or one-way
data-binding if you're using directives
like an gif so basically every time
you're using the framework you are
setting Watchers without knowing it and
normally there is no problem with this
but when you set too many Watchers the
app becomes to feel a bit more
responsive that's because the digest
cycle is taking up more time than it
should and this is a problem that you
should solve if you have too many
Watchers and I'm gonna have to talk
before about to a data binding so if
you're using the new component this
would be the syntax for it before we
used to use the scope two points but in
you in the new syntax it would be
bindings and then I'll say theme and
then equal sign for two-way data-binding
and the view would look something like
this so side menu theme then I'm binding
to another variable another component
dollar ctrl the theme
this is two-way data-binding because
we're using the equal sign so if we want
to know exactly how to wait data binding
we need to explore the two factors of
two-way data-binding
and the first one is parent to child
which means when the theme changes in
parent go ahead and update it and the
child which is the theme which is the
side menu and then for the other aspect
it would be child to parent and then it
means when the theme changes in the
child update wait could you do that in
angular so a lot of people had no idea
that you can do that in angular so or if
you know about it you probably don't use
it what I mean by this is in most
scenarios we don't really need to wait
at a binding this is why in angular 2 it
has been renamed to input and everything
is one-way data-binding by default so we
don't have to pay for something that we
don't need this is why we can start
using the one-way data-binding syntax
and angular 1.5 which is this less than
sign and instead of the equal sign for
the theme I would say less than and now
we have only one way data binding
then we've got lazy loading so lazy
loading means we should only load what
we need without loading instead of
loading the entire application we just
load exactly what we need because the
benefits of this is that it reduces the
footprint the JavaScript footprint so we
have the footprint for download and
footprint footprint for execution
but unfortunately an angular 1 lazy
loading is not supported by default you
can do some workarounds for it but it's
not going to be very easy however I can
give you an advice which is you can
create separate modules and then
bootstrap different applications so if
you're building a web application that
has a client facing up and an admin
admin interface then it doesn't really
make sense to have only one application
instead we will have the app which is
for the client and then we have another
completely different app which is the
admin so now as if you have two
independent angular applications and
you're not loading something that you
don't need for the client and vice versa
then for caching how many of you are
doing caching in angular just four so
caching doesn't have to do anything and
with angular it's not really what I'm
gonna say is not really angular specific
and just reminding you that if something
takes a bit of time to get from the
server then and it doesn't change
frequently then it makes gen makes sense
to just cache it
so just a reminder that sometimes the
optimizations need to be done are not
really relevant to angular they are to
write the optimization techniques that
you already know so you can cache and
memory in local storage depending on
your purpose if something changes every
week you can also set an expiration for
it so it can expire after a week and so
basically that's it for for caching then
really answers it to know how many of
you have heard about the angular
production mode okay three even the
angular dogs haven't heard about the
angular production mode or they forgot
it
so first development mode so by default
angular runs and development mode and
the development mode is basically
angular goes and attaches debug
information to all your elements have
you seen this ng scope before while
inspecting yeah so this is this is all
angular running and development mode now
you're probably you're probably
wondering why do they do it so they do
they do that because they need to make
tools such as Batarang then we need to
make it possible to work so this is only
for debugging purposes so they go and
update every element with some data that
is relevant for debugging so are you
thinking what I'm thinking do you need
this in production of course not so and
yes you can disable this you can disable
development mode which technically
brings you into production mode and
angular will run perfectly fine without
this debug information so it's only for
debugging it doesn't matter angular can
still work without it it will be
actually more optimized without it
because angular doesn't have to touch
the Dom and update some classes if it
doesn't need it so basically this is
performance improvement for free so
don't forget to switch to enable
production mode before deploying on
production and the code behind it is
very simple you just inject our compiled
provider in the config and disable you
say debug info disabled and then force I
mean enabled force
but now what if we have something wrong
on production and you need to debug it's
still possible you can just open your
console and run angular dot reload with
debug information it's gonna reload the
page and only set debug mode for you I
think they do it using a cookie so you
don't lose the debugging flexibility you
had on production serviceworkers hands
up for service workers nothing to do
with angular I will be completely honest
with you this is not angular-specific at
all but I will show you what I mean by
this so first of all a serviceworker is
a script that is run by your browser in
the background and separate from the
webpage so so even if the web page is
not running you can have a serviceworker
running and the serviceworker allows us
to do features I think you've been
hearing about them such as push
notifications on the web even offline
support or even intercepting requests so
all of these new stuff you can do them
using service workers and the best
approach to use serviceworker is to
build an app shell structure the app
shell structure means you have something
that loads initially that will hold your
application it's like a placeholder for
your application and this is supposed to
load as soon as possible so as fast as
it can and every time you enter your
website this app shell will load super
quickly and then it will start
requesting other resources so this is
going to give your app in native like
performance so for the web this is like
the peak of peak of optimization I mean
how it looks for the user in terms of
user experience you go into a website
and then under a split of a second the
app shell would start loading and I will
show you an example of this
so here's the option here's the
application shell on the left you can
see we have the side menu and we have
this header and then just a white
placeholder for the content so this is
supposed to load as fast as possible and
then it will request the content on the
right if you think about it that's how
mobile apps work when you click on an
icon you've got a splash screen and then
you've got a header and the sidebar
maybe and then placeholder for the
content and then you see a loader so we
are now able to do this on the web and
I'll show you an example of how we can
make how we can use service workers to
make this app shell load very quick
quickly on repeat visits so on the left
you've got first visit it's going to
take a bit of time and on the right it
will load as quickly as if you were on a
native mobile app so that's it 0.8
seconds you have the option structure
loading loaded without having all the
information that you need but it will
show the user that there's something
happening so this is great for user
experience one more time
so I can't really dive a lot and to
service workers I just wanted to
introduce you to service workers and
again they're not really
angular-specific but if you're looking
to do this kind of user experience then
you would have to use service workers
and you can use them with angular and
now for testing so testing is very
important although some people don't
like to do it very correctly I'm gonna
tackle a different perspective about
testing today so but before we know that
writing tests is very important because
it gives us the flexibility to optimize
without breaking the previous
functionality so if you learn something
new and you want to refactor this
component you can just make sure that it
still works if you have a solid unit
test case and obviously this is a
requirement for maintaining large
angular apps or large apps and which
will allow us later on to scale our
developer team but what I'm gonna talk
about today is I think it's very rarely
being talked about which is the
developer experience behind tests
because I'll be honest with you I don't
like writing tests and angular the
syntax is horrible and is you've got so
many dollar signs flying around so I'm
gonna introduce ng mock and Angie mark
allows you to write tests for angular in
a declarative way so start by saying ng
describe then I name my tests and then
set whatever module I need to inject and
then I can tell ng mock I want to test
this side menu element so I pass an
element and say side menu then I can
write my test suit inside of it so
that's really nice way to avoid all the
boilerplate code that you need to write
tests some things create their own
helpers but you can also use something
that's already out there and it works
and another huge benefit of
ng mock is if you want to mock HTTP has
anyone mocked HTTP before with dollar
HTTP back-end have you suffered yes so
look at the nice syntax so once again
I'm injecting this element and I mean
I'm selecting this element I want to
test this site menu element I think can
also easily inject dollar HTTP and then
you specify that for HTTP and forget
requests if I get this URL API slash
pages it should return this that's
basically it and now you can carry on
and write your test without worrying
about all the massive stuff behind the
scenes so that's basically it for
angular 1 and now I'm really excited to
tell you how angular 2 has been already
thinking about most of the problems and
their new approach to solve to solve all
of these issues so we will start with
the same structure you already know that
angular 2 comes with typescript and the
next step would be setting up the
project and to set up the project you've
got angular CLI which is the official
tool to bootstrap angle to start angular
apps so npm install' and gene new and
then your app and then basically have
all the development lifecycle that you
would need so if you want to create a
component like you've got some sub
generators to create a component so it
will generate the boilerplate code you
need for components if you want to run a
test server you've got that working if
you want to run an optimized version and
deploy it it's it's also built in so
we've got everything you need inside
angular CLI and then for component-based
architecture
as I told you that it didn't change a
lot except for the syntax because we now
have typescript
it's mainly it's kind of still the same
but we get more formalized and put
properties and output events and if I
want to map this to angular 1 the
put properties would be the you we used
to use the equal sign for two-way
data-binding which is not correct which
is the same as the less than one-way
data-binding
then the output events would be similar
to using the ampersand and then the
function and at input and output are the
decorators that you that you use to
inform angular that this is an input
property and this is an output event
then do you remember the mess for the
Styles using all of these naming
conventions so there's something called
shadow Dom which you can think of it as
this section of the Dom will be kind of
completely independent from the rest so
angular 2 allows us to use this
functionality as of today so it means
that every component and angular will be
isolated from the rest so I can use a
dot active class and not worry about
having a different component or a
different developer using it somewhere
else and this is something that works
natively in the browser and new browsers
and chrome but because we need our app
to work everywhere what angular does is
they have an emulator mode so emulated
it means they take this class and then
they add some attributes to make it only
match this your component so you can
actually decide if you want to have the
emulated mode or if you want to have the
native mode or you can even disable it
so this is a really nice feature you can
just go back to use those image selector
h2 selectors if you're building small
components without worrying about the
cascading stuff of CSS
then for lazy loading it's a good thing
that angular 2 comes by default with
lazy loading as you already said the
router has been deprecated but I think
the new router also supports lazy
loading and so it means you can just
load the components that you need and
because of the new way at the new
dependency injection outwards it will
resolve only the components that are
required for this route and they will be
loaded so this is last JavaScript
footprint you download less stuff and
less execution for JavaScript last time
waiting for JavaScript execution another
feature of angular 2 is web worker
support so all of these features are
mainly targeting performance at least
the web worker and the web worker is
different from a service worker but it
allows you to run computations in the
background of your page on a different
thread so without blocking the main
thread because you know all your
JavaScript code is running on the main
thread and if you do something that
takes a bit of time Iori I will start
having degraded performance so this has
been in browsers for a few years I think
but no one has been using it because
it's a bit complicated in order to
implement thread safety you had to you
don't have access to the Dom inside the
web worker so no one was really using it
but what what angular 2 gives us is they
have optional support for web workers
and if you stay within the boundaries
they define you can make your code and
angular code run and the web worker
which also means you get more
performance benefits because you're
running in a separate thread without
blocking the UI then this is something
really exciting static temple' template'
come compilation so everything that
angular needs to do to prepare your
templates instead of doing it in the
browser it can now be done on your
machine and then you deploy optimized
code so it means that angular can
compile all the templates at Build time
which basically means angular is
removing all the overhead of the
framework and now you're delivering
optimized templates to the view so
that's how they were able to make
templates render five times faster than
angular one whether it was the first
view or repeat view so we now have much
faster template rendering on the client
so you can think of it as for example
when you write this curly braces if they
need to be transpired into something
else for angular to understand angular
will already do this and your build
tools so when you write your code that
will generate the optimized version
which will be then served to the browser
then three shaking so the technique of
tree shaking has been for a lot of time
a lot of time now but I'm really excited
to tell you that there is support for
tree shaking in angular 2 you can think
of it as pay for only pay for what you
use so if you're only using a couple of
things in angular 2 you have the
possibility to generate a version of
angular 2 that only has the things that
you need so instead of serving the whole
angular framework you only serve the
parts of it that you need and this is
something that can be done automatically
and this is another benefit of
typescript because of because of the
typescript ecosystem and that angular is
written in typescript they can know
exactly what functions you require and
what functions you don't require another
interesting thing we have is server-side
rendering so by project called angular
universal server-side rendering is when
you render it the component on your
server on the server side and then
return it to the front-end so this will
give you a better perceived performance
because instead of waiting for the whole
page to load and for angular to
bootstrap in order for it to render the
component you will serve a component
that is already pre rendered and then
later on when angular loads you can do
everything that you used to do now this
is the main benefit but you can finally
get SEO optimization now we know that
Google as a search engine can
can crawl angular apps but what about
the other search engines so now because
we're serving something that is already
rendered we don't have the SEO problem
SEO problem anymore and same thing for
the site preview so remember when you
used to share an angular website on
Facebook and you get those curly braces
or ng cloak or whatever so those are
some of the angular 2 features there is
a there's all performance features I
mean there's also one that's I didn't
mention here I can tell you about it
which is the change detector for angular
2 always runs a VM friendly a an
optimized version of JavaScript so the
way they used to do it is they used to
have one change detector for all your
angular app and this is going to use
polymorphism in JavaScript and at the VM
level for v8 and all of those software's
running JavaScript with the jet
controller with a sorry JIT just-in-time
compiler it will be slow because when a
function gets repeated a lot which is
what you call when a function is hot the
just-in-time interpreter will not be
able to optimize it because every time
you're giving it different inputs but
now what they're doing with angular 2 is
that they create a change detector for
every component which means when this
change detector gets hot on every digest
cycle it will be already optimized by
the virtual machine which is another
performance benefit so once again as a
close closing thought is the same thing
scaling requires a solid code base so
it's about using all of these best
practices thinking ahead of time and
again angular 2 makes things a lot more
easier I hope you enjoyed this talk you
can find it online on this URL and I'll
be happy to answer your questions thanks
for your time
yes guys can you please go that way and
vote because it's not working on that
side and if you've got any questions
we've got five more minutes or you can
catch me around today
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>