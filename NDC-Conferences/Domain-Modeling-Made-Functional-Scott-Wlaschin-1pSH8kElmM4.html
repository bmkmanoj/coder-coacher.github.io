<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Domain Modeling Made Functional - Scott Wlaschin | Coder Coacher - Coaching Coders</title><meta content="Domain Modeling Made Functional - Scott Wlaschin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Domain Modeling Made Functional - Scott Wlaschin</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1pSH8kElmM4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is the main main the main modeling
made functional and I thought just to
start the morning off I'll give you a
little challenge and this is a little
bit of code a little data type obviously
and so how many things are wrong with
this design you've probably written code
like this many times we have some sort
of contact or a customer type and
they've got a name and they've got an
email and all this kind of stuff did you
think this is a good design this is how
you dress it what kinds of things would
be born with it you think yeah name
could be anything yeah you miss there's
no validation on the name why yeah you
said it got one email that's true okay
yeah
uh-huh
primitive type using a string rather
than something more sophisticated right
exactly
good okay that's all good so yeah I
think you guys are in the in the right
place because it I'll be talking about
exactly those things and what we'll do
in the course of this talk as we'll see
how to evolve this design into something
which is much more self documenting and
does actually capture the domain better
so before I talk about the nitty-gritty
of domain modeling I just want to talk
about why why do domain modeling at all
because you know if you think of
software development as a process that's
an input and an output and there's you
know the middle bit of the coding part
and we spend most of our time talking
about coding and tooling and you know
all the fun stuff you know stuff of
developers we'd like to do but the
problem is this is like a regular
process garbage in garbage out right so
even if you have the best development
tools and the best programming language
in the world if you have garbage coming
in you're gonna have the knowledge
coming out you can't have a you can't
ever have a good product if the input is
bad so the idea of doing domain design
doing proper domain modeling is if you
can reduce the garbage in then hopefully
you can reduce the garbage out and
that's you know the design process
basically so we should spend some more
time focusing on design another spending
time on coding and tools that's what
this talk is about how can we reduce the
garbage in all right so let's go back to
this and I'll I'll tell you the things I
think are wrong with this and they are
politically with most of them the first
thing is which values are optional right
it's not at all clear
that is that is the first name required
or is optional is the middle initial
required or optional and so on it
doesn't it doesn't tell you from the
code now you may have some validation
logic buried in your code somewhere it
says yeah if the middle initial is no
less an error that's what it allowed to
be no but the first things not have to
be that's in your code that's not right
in your face what we want to do is
actually encode
in the design not in the actual code
buried in some validation module
somewhere so in this case that was
optional and all the other ones have
acquired say okay what are the
constraints so as you say these are
wheezing primitive types can can you
really have a first name that's like a
million characters long can you have a
first name that has non-printable
characters in it maybe you can but know
most of us would find the hard if you're
printing out a mailing label or
something you're going to have to limit
it to some standard length and you know
not allowing carriage of turns or
something in your in your first name so
there has to be some sort of constraint
in this case it can't be more than 50
characters now I realize it in the real
world people do have names which along
that but we're unfortunately in the in
the normal world we actually have to
deal with databases and stuff so there's
normally constraints and what we can do
which feels a linked so in terms of
atomically atomic updates versus
independent objects so if one person is
changing the name on one website and we
know one browser and another browser
they're hitting the same thing and
they're changing email is that okay is
there concurrency problem probably not
but if one person is changing the first
name of the other person is changing the
last name then we probably do have a
some sort of becomes equipment rights
but it's not clear from this design so
what we wanna do is group them into
things which have to be updated
atomically so that's an atomic update
and that's another atomic a bit okay and
then what's the domain logic so we have
this is email verified flag here and we
use that to say okay you know I've sent
you a you put in your email but I don't
know that you only yet so I'm gonna send
you a you know a verification email you
have to click on the link and verify who
you are and if you have verified who you
are
you can set this boolean flag the
problem is that I just said all this but
that's not anywhere indicated in the
copy in the design right nowhere is that
it's like in there's some piece of code
that does this but the design doesn't
make this at all obvious and it's quite
easy for someone to set it to false
true without any with that accidentally
or deliberately image either maliciously
or accidently they can said it's the
wrong thing so the rule is in this case
the rule is if you put in a new email
address you have to reset this to false
because you haven't verified it there's
nothing in design that conveys that
information so these four things we'll
see how we can actually encode that in
the type system because F sharp can
actually help with all these questions
and most function languages can - but
I'm going to talk about your shop today
so domain modelling made functional with
the F sharp type system
I'm Scott volution I have a website F
sharp of a nonprofit comm so if you're
interested in F sharp would you come to
my website so this is a kind of a
mishmash of different topics in the
store servant domain driven design for
those of you who are not familiar with
this it's originally a book by Eric
Evans but the point about domain design
as opposed to object oriented design or
database driven design or any other kind
of driven design it's about the domain
it's about understanding there's the the
system from a user's point of view not
from this or technical point of view so
focus on the logic the business logic
rather than a technology using so this
is this talk asur the intersection the
main modeling which is to believe
considers of our thing and functional
programming and I actually think they go
together really well and I hope you
agree so I'll talk first of all I always
put in a bit of thing about demystifying
functional programming because I just
want to do that anyway the fun I'll talk
about why it's good for real-world
applications then I'll go into the F
sharp type system and how it's different
from an object-oriented type system and
then we'll get into the meat of the
thing which is how would you design how
would you model that simple thing using
types alone so a lot of people think
functional programs really cards they
think it's scary because there's all
these big words like functor and
catabolism and Monod and monad
those do sunlight skywards and I mean
there's Homer he's a little freaked out
by all these words the problem with this
is that sort of math admissions got
there first and these are these words
are scary but they're actually not that
scary is actually just unfamiliar if you
know what they were
if you knew it once you know what they
are they're not that bad and also if you
had different names of them so mapable
instead of functor and collapsible and
aggregated ball and chain a ball or
something
those things if they would call those
things you still wouldn't know what they
were but they wouldn't be so scary
sounding and we like his homework right
he's still he's puzzles you know but
it's like it's not so intimidating so
unfortunately you'd have to get over the
mathematical jargon and the concepts
actually pretty straightforward telling
what's really scary object or into
programming because there's all these
buzz words all these strange words like
you know polymorphism and inheritance
and covariance and and solids which in
turn is another five abbreviations right
there's a lot of there's a lot of weird
stuff in object programming but you're
just used to it so you don't think it's
scary but I think if you're a brand new
program it's just just a scariest
functional program and of course there's
IRC and di and ABC and NBC is like some
little jargony buzzwords and they were
alright so don't forget that just
because you know something you know you
have a lot of knowledge normally that
you bring into a system the good thing
about this talk is you're not gonna need
any of this stuff I'm not going to talk
about monads on mono anything so it's
absolutely from smash and it turns out
for domain modeling this is all forget
about all this stuff is not relevant all
right functional world function
programming for real world applications
so people think that function program is
all about mathematical stuff for its
algorithms and power processing and all
this stuff you know and it's pretty full
of stuff but you need like a PhD to
understand it know things like well yeah
it's true I mean it's good for all these
things but it's not true that you need a
PhD really you can have a friend who's
not
we'll son and he's teaching his son
sharpen this really yes so not from so
tell you what I think functional program
is really good for what I call boring
line of business applications okay which
is the stuff that most of us actually do
for our day job this is like writing
accounting systems or inventory
management systems or ecommerce sites or
you know boring stuff basically the
stuff that pays the rent
and I think phone is actually really
good for that by the way I call these
things blubbers so if you like blah blah
driven development so if you think about
blah blah developments like boring
enterprise apps the requirement so
you've got expressed it got a expressed
appliance clearly because often you're
dealing with people who have a hard time
having clear thoughts the users you need
a rapid development cycle because you
want to kind of get the stuff out of the
door before they change the mind about
what the requirements are you need high
quality deliverables because there's
nothing worse than going back and fixing
a bug from six months ago and you've
already moved on to an another project
right so these are things these are the
things you want this is the things you
want any kind of software but especially
in enterprise software so the nice thing
about F sharp is it's very concise it's
really easy to express requirements
again that's what we're going to be
focusing on today rapid development
cycle F sharp has a repple an
interactive system where you can
actually type stuff that's very cool for
doing web development and the high
quality so again we'll talk about using
the type system to into sort of do
compile time unit tests so you can
actually write less unit tests and
actually have more reliable code and of
course fun if you're going to be doing
boring if you're building boring
applications elysian have fun doing it
right so the fund is an important aspect
of any kind of programming and luckily
fun is a key word in F sharp so II knew
what they were doing
okay so f sharp blah blah development go
together very well
right domain during design is the next
thing the key point about domain driven
design is it's really about
education it's not like a technique or
it's not like I said of buzzwords to me
it's all about how do you communicate
between the developer and the user or
the domain expert so the the approach of
domain driven design is that you have a
shared mental model so you don't have
one of those things where you know a
domain expert tells a business analyst
and the business analyst tells the
software designer the software design of
writes up a requirements document they
hand it off to a developer who write you
know that whole thing that whole
waterfall even the agile model you tend
to have this translation stage where the
developer translates the requirements
into code in the domain driven design
approach the developer and the domain
expert and the code itself also always
all have a said chain to makers same
model the same mental model so that
means that your code looks like the
domain so you don't have things in your
code which are not part of than main so
you don't have any manager classes or
factory classes or you know things that
you know a base an abstract base class
is not part of the domain a domain
expert doesn't know what that you're
talking about so you try and avoid that
kind of stuff and everything in your
code is named in such a way that a
domain expert could read it and
understand it that's the theory
unfortunately it's pretty hard for most
domain experts to read most code but I
think we'll see that you can actually
get halfway there so one of the problems
with having a shared mental model is
it's really easy to have communication
mistakes and so one of the goals of
domain driven design is to try and
eliminate these kind of community
communication mistakes that's what
common so for example if I say this word
write UN IO and I said e so is that
someone who's you know fighting for
better pay or is that a nice way a
chemical chemistry term right which one
is it
well the artists is both right it
depends on the context so this is the
the first thing that domain-driven
design into space there's context for
things with a piece of you know a name
doesn't necessarily mean the same thing
everywhere so obviously in this case
it's really obvious but we create this
context with where the words mean
something but here's another one spam
right in a supermarket it means one kind
of thing and in an email system that
means another kind of thing same word
okay what's really obvious but what
about products there's an example where
in a sales context it might mean
something that you can sell but in a
warehouse system it might be something
you have in stock there's a physical
item and non-physical items don't count
you know so subtly subtly different
meanings there and if you try and make
the same word mean the same thing
throughout the entire system you're
gonna get in trouble there's another one
customer I went into this one all the
time where the marketing people think
customers anyone has an email address
anyone they can send you know they can
spam with emails and finance people
think customers somebody owes us money
and obviously coming from a different
place and I've seen people try to merge
these into one giant customer which has
thousands of different fields and
surface like that's not gonna work keep
them separate
and then after you get these different
contests within that context there's a
set of words that sort of define the
domain so in the chemistry domain you
have you know polymer and compound and
molecule and stuff and it's very
important as developers that we use
these words so if you if you're working
on a system that does chemical analysis
you don't have a linked list of
molecules you call a polymer that's what
the domain experts call it you don't
like say well technically it's this
nothing it's like don't it's not what it
is technically it's what the domain
expert thinks about it might and that
set of terms the terminology in that
context is the a bigoted language we
call that and everywhere language
everybody should use the same words that
includes the code the developers and
their domain experts and if people are
using slightly different sets of
languages that's where you
communication problems so similarly in
sales like here's the word product and
customer and stuff warehouse might have
something different so again the same
words but the overall set of the camera
they use may be subtly different alright
so that's the theory so let's see how
you do that in code alright it's like oh
yeah it's a nice ideal but surely code
is more complicated that so let's see so
this is a piece of F sharp code and the
question is can you tell what's about a
context is and can you tell what the
ubiquitous language is right so the
context means that something like you
know a deck in this context is different
from a deck if you're in a kind of boat
building context deck means something
completely different right so there's
the context it's a conscious of a card
game and these are all the nouns and the
verbs alright so this is an example of
how you can represent a ubiquitous
language and a bounded context in one
page of F sharp code and I'll just
quickly explain some of these terms that
vertical bar means a choice so a suit
which is a club or a diamond or a spade
or whatever that little star means a
pair so a card is a pair of a suit and a
rank the list type is built in at hand
is a list of cards a deck is a list of
cards and then that's the F short way of
doing a function with an arrow X arrow Y
as a function which has X as an input
and Y is now cut so for examples deal to
deal is you start with a deck as the
input and after you finish dealing the
new the output is a new deck because the
deck has got one less cards and there's
now a card on the table so the output is
that there's a pair so we've
communicated a lot of the meaning or of
the domain you know in a few lines of
code is cool so do you think this is a
reason about a code to write to
represent the domain
I think it's not bad I think it would be
hard to write this in text to convey the
same information it's quite condensed do
you think a non programmer can
understand this yes yeah you could yeah
I think I mean you know you don't have
to be you don't have to go to super
detail but I think it's pretty
reasonable certainly good enough that if
I was like missing out a suit if I'd
left off hearts or something they could
say you know you're missing a suit or
you're missing how to deal a card it's
not I mean it certainly could go through
it and have them understand it can act
as a shear documentation and the other
thing about this is really important is
this what the domain drone design people
called persistence ignorance which means
there's nothing about databases mites
there's nothing about foreign keys and
and you know it's like it's purely a
domain
there's nothing about classes here
there's nothing right inheritance
there's no abstract think there's no
interfaces right this is all about to
make every single thing and this is
something relevant to the domain so this
is the you know there's something we've
always been we always kind of strive to
do especially in agile is the design is
the code the code is design you try not
to have the design be a separate thing
because if you have documentation or
something it's going to go out to take
right the code is always the sort of
source of truth so if you can make the
design and the code be the same thing
that's really great and I think this is
really a good way of doing it so this is
not pseudocode this is executable code
and typically in an F sharp project you
would do something like this and you'd
stick it as the first file in your
project and then obviously you have more
complicated code kind of executing
algorithms and how do you actually deal
how do you actually do it you know a
shuffle algorithm whatever but this part
is something which can be shared between
the you and the domain expert so you
don't need any UML diagrams right you
don't need any out of date documentation
200-page required documents I think this
is great way it's a very agile way of
working in in conjunction with the
domain expert right understanding the F
sharp type system
so the f-sharp tie system has something
called algebraic type system I just do
as does Haskell and no camera on most
talking languages
that's another Massey word so I'm gonna
use the word composable type system
instead and composable it's like Lego
you can glue pieces of Lego together to
make another piece of Lego and so on so
that's what composable means so let's
actually see how that works
so you given you two types you can
combine them to make another type
composable and there's two ways you can
combine them you can multiply them and
you can add them and that sounds kind of
strange how can you add a type on
multiply type so that's what I'm talking
about here let's say that you have a
function called add 1 the input is a set
of interests any possible integers and
inputs and any possible integer doesn't
happen it's easy enough so we write that
in a shop we like there's int arrow int
right enters the input and int is the
output fair enough
ok now what happens if the input is a
pair okay so we know whether we can know
the output type is would say the out
present in but what's the input now we
can say well let's just define a class
called a pair some things like no we
have to use it by building on the types
we've already got we can't define a new
thing so how do we how do we do that
well if you think about it a pair is one
from the first pile and one from a
second part right every possible
combination so let's say there are four
integers in the universe how many
possible combinations are there well
there's you know four possible things
for the first number and four possible
things for the second number total
number combinations is 16 yes so it's
multiplication right so we actually
write this and his list let's say a pair
of boolean's two possible ones for the
first power of two plus one second of
all it's four possible combinations all
together so this is what we call a
product type I'm multiplying two types
together okay
and so I in F sharp you actually write
it with a multiplication the star so int
star int is a pair of Vince
and the bull star pool is a pair of
balloons right
okay let's okay that kind of sounds
theoretical but let's look at a
practical example let's say you want to
pick model people's birthdays so Alice
has a birthday on January 12th and bob
has a birthday on every second or
whatever well you take the set of people
in the world all the possible people and
you take all the possible dates and you
multiply them you get every possible
combination of a person in a date and
that is the set of all possible
birthdays so you could quite easily say
that their birthday is is that person
times a date no a pair of a personality
so that's how you do that all right
let's look another example let's say
that you have a function that figures
out whether you have a fever or not so
there's some sort of temperature comes
as the input and if it's true or false
so the outputs a boolean but what's the
input well let's say that you want to be
good and support both kinds of
temperatures Fahrenheit and what type
well if we think about it again let's
say there's only four possible
temperatures if you think about you can
either have one from the Fahrenheit pile
or one from the Celsius Pole all right
so how many possible choices are there
there's eight like this four plus four
so we call that a plus so we call this a
sum type and how can we represent this
in a shop well they might both be
integers or floats or something so we
need to separate them we need to
distinguish them tag them and we're
gonna tag the Fahrenheit ones with an F
and the Celsius ones there's a C and we
end up with something looks like this so
we say a temperature type is either a
fan height where it's represented by an
int or Celsius where it's represented by
a float and this is something that you
can't do in C shop so the pairs and
stuff you can certainly do in most
languages but this kind of choice type
or combination time like this this is
really cool really important for the
main modeling
alright here's a here's a more
real-world example okay we have a
payment method what can we do for
payments as well you can take cash we
can take checks we can take credit cards
and if you take a check then you have a
check number and this is kind of getting
it all out of data probably put in
PayPal or Bitcoin or something now but
you know what's cool about this is you
can have extra information associated
with each thing so with the cash there's
no extra information but if you pay by
credit card you need to know what the
credit card type was and what their
credit card number was so the little
bits of information can go along with
each choice all right so this is really
nice so this is a real-world example of
why these choice types are really useful
because again I've gotten like four
lines of code I've conveyed quite a lot
of information about how payment methods
works and what's cool is then when you
actually need to work with these things
you have to do you have to get the data
out and you get the data out using what
we call pattern matching and it's
basically a pattern matching is sort of
like a switch statement and for each
choice you have a little handler and
what's cool though is that the as part
of matching that choice it extracts the
data in that choice too so you don't
have to say well if it's a if it's a
check cast it into a check and then see
what the check number is it's like now
you get everything in one go you you
find out it's a check and you get the
check number all in one step that's very
cool all right
so one of the nice things about this
compared with maybe if you get to model
is in c-sharp you might model its using
inheritance so you might have a base
payment method on a payment method and
then you'd have like three subclasses
for each choice say one of the nice
things about this approach is that all
the choices are in the same place
there's like three lines of code if you
if you have a kind of a subclass model
in c-sharp you'd actually have like four
files so I'd have to go to lots of
different places to try and find out
what
doesn't pay much mess in pain wrestling
here is like light in your face very
convenient and the other important thing
is a closed set of options which means
that I can't add if you know I can't
inherit from this and add a new new
option automatically I have to like
change this definition and you know what
you might say well that's a bad thing
because if I change it I break all my
code it's like yes I think that is a
good thing because if you add PayPal
that is a you know that's a changing of
the domain of often adding a new kind of
thing is a new kind of business logic
and it needs to be handled you don't
want to accidentally forget about it and
just just inherit from it and then not
have that everything else work all right
so we normally think in most kind of
programmers we think of types ourself an
annotation you know say is just for type
checking to make sure our code compiles
you know we say add one and it takes an
integer it's like okay if I passed a
string to it the pile is going to
complain so we normally think of types
and as a just for compiler just to make
the compiler happy but in functional
world we can think of types also as a
domain model at all so here we have a
deal okay so I'm modeling how to deal
something and I'm not really caring
about it's nothing to do this making the
compiler happy about compiling things is
as you're trying to model stuff using
types but the nice thing is you get both
at the same time you get the modeling
thing and you get the type checking
thing and as a result you get what I
call compile time type checking so if
you if your code does not match the
model you get a compiler error so if I'm
trying to deal and I'm not passing in a
deck or I don't spit out the right thing
my code won't compile there's a white
type checker so this is what I call you
know kind of like having compile time
unit tests you guarantee that your code
matches the model all right so typing
all the things functional people love
the title
all right so let's see what we can do
with this time system let's take it out
for a spin let's start with the optional
values that we talked about the very
beginning how can we model an optional
value so in this case the middle initial
is optional and the old ones not quite
let's see well let's say this type of
start with a simple example let's say we
have a string and we're calculating its
length right now one of the problems
with most programming languages is that
null is a valid string right so you
might say yeah fine if we have an
optional string we'll just model it
using annul well there's a couple of
problems with that first of all you
can't tell from looking at the design
whether it's optional lot because null
is a valid value for stream and this
null is real really painful because if
you think about it you know null doesn't
mean anything you can't say set phasers
to null
they're just no no it just gets in the
way it doesn't mean anything from it
from in the real world it's just an
artifact of programming and much more
but more importantly a null is sort of a
dangerous thing because it's not really
a strict from a coding point of view you
know you say there's a function that
calculates the length of a string and
you give me a null and the compiler says
here no snails are string just find
their problem and when you actually try
and ask the null for the length is that
ha I'm going to crash now exception I'm
not really a string I'm just pretending
to be a string and your compiler won't
even detect that I'm not really a string
right so nulls are not very good for
doing optional values and in fact I like
to see the null is the cerumen of static
typing it's likely somebody who acts
like your friend and there's going to
stab you in the back so now don't use no
ok so if you don't use null
ok so let's not say let's say the null
is not allowed okay we don't want no to
be used as any of our types we want to
get rid of it from that from the list of
possible values so if you can't use no
what can we do well we want to do is
model it using what we did before is say
well here's a list of
strings or nothing we're missing a
string right so we're going to model it
like this it's either this thing or is
this thing now we saw how to do that
before this thing or this thing right
it's going to be a choice type or an
addition so we're going to tag the top
one with some string we're going to tag
the bottom with nothing and we end up
with the type that looks like this an
optional string is either some string or
it's nothing now this is really good
because it's now a special type call
option of string and it's really obvious
what it is right in our code now I say
this is awesome really love this I'm
gonna do an optional string I'm going to
do an option I'm gonna do optional
boolean and then okay I think there's a
little bit of duplication going on here
so let's make a generic type okay
replace all these with one single thing
called an option of T so the little tick
T is F sharps way of doing generics and
in c-sharp you're just F of T but
basically it says to see there's
something that's nothing this is a
really really useful type any user in
their shop all the time so if we go back
to our personal name we say well the
middle initial is now an option of a
string okay now it's much more much more
self documenting that much clearer and
one cool thing in F sharp is you can
actually take a generic - stick at the
end so you can say string option which
is a little easier to read I think for
non-technical person so now we've made
it very clear that the is an optional
string and the other ones are required
so basically it's not optional it's
required but that's what we always say
that and that's pretty readable I think
all right next one single choice types
so this is something you'll see a lot of
in functional domain modelling is you
have you know a choice of one thing it's
choice of a of a an email is an email of
a string a choice of email or customer
ID is a customer ID of one choice why
would you bother to do that there's not
you're not really getting a choice thing
the reason is because an email address
is not just a string right an email
address has some validation rules about
it I mean it just might be represented
by a string but it's not really a string
from a domain modeling point of view
email addresses a special kind of thing
right the user the domaine expert
doesn't think about strings they think
about email addresses a customer ID is
not an integer it may be represented by
an integer but you can't add to customer
IDs together you can't multiply you
can't take the square root of a customer
ID you know it's not an integer
so what we do is we use these single
choice types all these wrapper types to
keep these things distinct so we might
say okay email address
perhaps a string a phone number perhaps
a string but now we've got two separate
types and an email address and a phone
number can't be mixed up there
conceptually different constant they're
completely logically different things
now you can totally do this in any shop
what's really nice about F sharp you can
do it in one line of code that makes
life a lot easier so you tend to do a
lot more in a language like a shot
because it's so concise so what's really
nice is then you when you pass these
around and you say you've got a function
that says it takes an email address
that's a parameter it takes the phone
numbers of parameters really really
obvious what it is so this is good
practice in object-oriented design - I'd
like to say it's kind of painful often
to write thousands and thousands of
classes in every op you might have you
know fifty of these and it's all fitting
in one file here's another example
customer ID an old idea of different
things you don't want to get any mixed
up right okay so let's look at how we
actually create an email address so
we're gonna have some horrible regex
that makes an email address valid and if
the string that you pass in matches that
regex they're not gonna say yes we've
got an email address successfully but
what happens if it doesn't match the
regice what you're gonna do you're gonna
turn null we're gonna throw an exception
no we need to indicate some way that
this thing might not work right so the
answer is we're gonna say okay if it's
valid we're gonna return something if
it's not valid we're gonna turn
thing okay so we're going to use this
option type we just defined and what's
cool is if you look at the signature of
this function well than saying you give
me a string and I'll give you back an
email address which is a lie because
sometimes it won't
it says actually you give me a string I
might give you back an email address
depending on whether you're the emails
about and this is a listen so this is
the again we're getting documentation in
the time signature I don't have to see
if there's an exception I don't have you
know I can actually see from the time
signature yourself that this might not
work so I know I have to handle it just
wait one of the cool things about this
is in F sharp everything is immutable so
once I pray to this email address I
never ever have to validate it ever
again I can pass it around my codes and
I can guarantee that no one's going to
mutate it and mess with it so you
typically only have to do foundation at
the very beginning of the program here's
another one spring 50 so to create a
spring 50 I'm gonna pass in a string and
if it's less than 50 that's good and
obviously I might check for you know
non-printable characters so on and if
it's not there's none okay and again if
I look at the signature search you give
me a string and I might give you back a
string 50 depending on that's better
than not here's another one this is
something I once saw on a ecommerce site
they could put nine hundred ninety nine
thousand items in my basket now I very
much doubt that's what they intended to
do I think that was a bug and the reason
it was a bug is because they were using
integer as their that's their quantity
right so don't do that
typically in when in places I were in
that in e-commerce site you can only
order like 100 items max if you're
ordering in nine hundred ninety nine
thousand you know that you either doing
something malicious or us like you know
that's not that's not really what you
should be doing so the way to solve that
problem is to create a new type as
always and you know it's easy in a shop
you should really do be doing this in
all packages but it's
you don't bother it's like it's a lot of
work to make new time for this so you
don't bother though we're going to wrap
it in it in a time and then we're going
to have a some code you know if it's
more than zero less than 99 s okay
what's cool about this is if it's zero
if it's not valid so if you say if you
have a decrement thing you hit the minus
button you're going to have to handle
the case where it goes to zero
you can't your code will be forced to
handle that case you can't say I'm not
going to hand it because you literally
will not have an order line come back
you'll get nothing back and so you'll
have to handle that case nicely so again
the signature is very self documenting
alright so let's go back to our
challenge first name middle initial last
name okay so we now got the middle
initial is optional that's good we've
now got these constraint i p-- switch
are much more clearly documenting and
what they do and we can also break it up
into smaller pieces really easily so in
our say a contact is a name and an email
and the name has these things and the
email has these things great okay so
that's three out of the four but let's
talk about this email verifies so
there's a zoom in on that so we've got
some business rules if the email has
been changed you need to set the flag
back to false and you can only set it to
be true by special verification services
like this logic about verifying it
there's going to be some hash that's
checked against the email and not make
sure it's good I don't want anyone
setting this to be true I want only this
piece of code to do it so how can i how
can I enforce that in the design right
and how can I make it clear that you
can't do that alright and again anyone
can say the true that could be done from
malicious reason so I could be done
accidentally you could cause a bug where
you sending passwords to people who
haven't even verify the email and so on
not good so what we're going to do is
create a new type and of course in
domain modeling you always create a new
type that's always the solution to
everything there's no problem that can't
be solved by laughing in another type so
we've got our email address already
we're going to wrap it in another type
called a verified email address okay now
what do we do with that we have our
verification
service and it's going to take an email
address as input and it's also going to
take some sort of hash and it's gonna
spit out a verified email type maybe
right you give me an email address I
might give you back a verified email
assuming that the hash matches and
you're not trying to fool me now what we
can do is make this verified email type
have a private constructor so they're
the only person who can create it is
this verification service right so it's
the typist public but it's a constructor
it's private so that means as there's
anyone else any other part of the system
I can't create my own verified emails I
have to go through the verification
service it's the only way I can get a
verified email okay so next okay so this
is and it's very clear that you might it
might not be verified so you're gonna
have to handle that case now now we do
is we go back to our original design get
rid of the boolean flag and we say that
email is either a verified email and
unverified email if there's an
unverified email it's just a regular
email address and if it's a verified
email it's one of these special verified
email address types now what's cool
about this is first of all it's much
more self documenting because there's
much clearer than having the boolean but
the other thing is I literally cannot do
the wrong thing if I if I change the
email address do you give me a new
address I think I can get an email
address type that's fine but then I can
only set it to unverified because I
can't I can't create a verified email I
can only create normal emails so if I've
given if you give me a new humourous I
have to create a none variety unverified
case I literally cannot do the wrong
thing so there is not only is it so if
documented it's also guaranteed that I
conform to this business rule without
having to buy a unit test that's very
nice
so if we look at the challenge this is
what we've got now we've got email
address verified email email contact
info a person names so on so forth which
val is optional which are the
constraints were the link fields and so
on
which values optional it's very clear
now from the design what are the
constraints
that's very clear now from the design
which feels are linked it's very clear
now for the design the domain logic is
much clearer now that we have a concept
of an unverified and a verified email so
the design is better and also this hell
this thing of ubiquitous language
initially we had one thing all the
contacts and we were using primitive
types now we have like four six seven
different things but they represent them
to main much better I mean we we now
have a concept of a verified email
addresses now represented by something
in our code and we have represented
there's a choice between these two
things and so this is good because this
is how the domain expert would say yeah
we do these kinds of things with
verified emails we do password resets
with them or something it's actually a
lot this is actually a lot better from
the domain modeling point of view so is
the code is more useful and it's more
self documenting and of course this is a
compatible code right this is not a
documentation this is code all right
it's a final thing making illegal states
unrepresentable that's a cool phrase
let's say that sometime later they
decide to have an address as well as an
email okay fair enough but they have a
new business rule okay you have to have
contact must have either an email
address or a postal address where you
can contact you fair enough so the
question is does this design meet that
business law now says no doesn't because
remember everything is required so these
two properties are both required right
now so as it stands you have to have
both okay well let's not do that let's
make them optional so this meet the
requirements no it doesn't because
this requirement they could both be
missing right now what you could say was
okay I'll have them both be optional and
I put in some special code somewhere
that validates if one isn't missing and
the other ones missing that's an error
answer no that's in the code I want to
do in the design how can I capture in
the design where you literally cannot
screw it up okay so if you think about
it so this is this guideline make
illegal states unrepresentable so rather
than saying yeah they can both be
missing and I'll put some special code
in to validate it you're asking for
trouble
like if you can actually encapsulate
this business rule in the cut in the
design you literally you never have that
thing happen and you never have to write
a unit test for it and you never have to
write any special violation code for it
it literally cannot exist so how can we
how can we solve that well if you think
about it when you say it must have an
email address or personalists there's
actually three choices
it's either gone only an email address
or it's got only a person who escorts
got both right there's three choices all
right how can we model three choices in
our code well you say it's either an
email or its address only always both so
we're just model our three choices right
there
all right and there's no fourth choice
there's no choice where they're both not
missing we're both missing so this is an
example of literally modeling it in such
a way that I have to be one of these
three things the fourth one where
they're both missing is not an available
option this is very cool and we stick
that back in our main thing and now we
have a
so this is an example of encoding the
requirements in the type so I say this
has multiple benefits I can't do the
wrong thing but more in more importantly
it's actually self documenting codes one
of the problems is having sort of your
validation logic buried in some file
somewhere is it's not clear to me as
another developer time if I'm inheriting
your code base or I'm working on your
code base it's quite easy to
accidentally forget to call that
validation logic you know this is self
documenting this like if I have this
thing I look at this like oh okay these
are things literally the only thing
things I can do so it actually helps to
document the code as well as to
constrain it now so there's what we had
before we had an email addresses to sum
of things and afterwards we now have
this new contact which has a field and
that field has this choice so now we
have again we have a new domain constant
called contact information that didn't
exist before we've learned something new
about the domain so this is awesome
static types are almost as awesome as a
cat on a unicorn white but it's pretty
cool what you can do with stereotypes
obviously you can't do everything but
the stuff you can do it's really nice it
saves you a lot of time let's just look
at one more variant on this let's say
that they change their mind and it's
like they say well actually we don't
really care that they have to have one
or the other we just want at least one
way of contacting somebody no that's
much put their Puli a better way of
doing it we just have at least we won't
have at least one way of contact you so
what I'm gonna do is say okay here's the
ways we can contact you we can contact
you by email we can contact you by
address we can contact you by phone
whatever that's the way of being
contacted and then in our contact we say
okay there's primary contact information
and secondary contact information
primary contact information is required
and the secondary contact information is
optional or it could be a list if you
want to have more than one and again
we've now documented what the
constraints are you literally
to have a primary contact but the
contact info could be email or
personalist we're not we're not
constraining that all right so let's
look at what we've covered we've got the
the original challenge the whole thing
of you becomes language and the self
document design I think we've seen that
pretty good algebraic type so there's
that kind of math you buzzwords but
hopefully you see it's not you forget
about the mathematical stuff so you can
see the concepts are really pretty
straightforward but using choices rather
inherent it's a really nice thing you
see that we used to over and over for
modeling things doing choices it's
really really it's the one thing I'm
really missing c-sharp is having these
choice types designing the types don't
use novel use options use these single
case unions to wrap things and making
illegal states unrepresentable I haven't
had time to cover a lot of stuff so
really just scratching the surface
there's a lot of stuff to do with States
state machines and state transitions
services seek us all this stuff can't
talk about it right now but I have other
talks on these kinds of topics if you're
interested so there you go thanks so
much mainland diminish all the code and
the slides and and videos are on my
website at slash DVD so if you go there
and you want to watch this video again
you can go look at the slides if you
want to know more about F sharp there's
an organization in F sharp dot org and
if you like this talk I have a book
coming out shortly it's actually
available right now as early access so
you can go and if you just search for a
domain medaling made functional book
police show up there's pragmatic press
if you do get it I'll be very interested
to get your feedback also in room six
immediately following this there's two
more functional programming talks which
look very good so if you think that's
interesting you can learn some more
stuff and I'm also doing an AMA in a
session after this interview eight I
think it is so yeah thanks very much for
coming and
yeah let me know I think we've got time
for questions or yeah I think we've got
a few minutes for questions or while
hunting we just stopped and you can come
and ask me questions separately do you
think does anyone have any urgent
questions yes right so the question is
how do you actually do the Beast private
constructors I didn't show it in the
code no it's a little tricky yeah it is
in the book yeah it's also on like it's
also on the website as soon as you have
private stuff it does become tricky
often you can get away with not actually
making it private but just by its it's
if you're lazy it's the kind of thing
where you tend not to do it anyway it's
this is you have a type you mutually say
okay I better just call the trade method
on this thing and not just like do my
hands but yeah the way if you really if
you're letting an API and I really like
an email address might be worth doing
because I really don't want people to
mess it up yeah but like phone number
maybe maybe no I don't care depends how
much you care about validation yeah any
other questions no all right well thanks
very much everyone Cheers</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>