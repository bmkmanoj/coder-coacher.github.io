<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JavaScript Metaprogramming - ES6 Proxy Use and Abuse - Eirik Langholm Vullum | Coder Coacher - Coaching Coders</title><meta content="JavaScript Metaprogramming - ES6 Proxy Use and Abuse - Eirik Langholm Vullum - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JavaScript Metaprogramming - ES6 Proxy Use and Abuse - Eirik Langholm Vullum</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/opf7xX-whIw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for coming to my talk and today
we're going to take a look at meta
programming in JavaScript and
specifically the featured called proxies
so I'm Eric and I'm an independent
consultant and I do a lot of JavaScript
training and mostly I'm addicted to
JavaScript so that's pretty much what I
do and I'm also very fascinated by meta
programming and when I hear the word
meta programming I think of these guys
like wizards doing magic at least that's
what it feels like when you try out meta
programming the first time and this also
seems to be embodied in one of my
favorite books which is this book
structure and interpretation of computer
programs which uses a language called
Lisp which is a language that is very
suited for meta programming and you can
also see this in there you can see that
they're using this wizard here as well
they have this thing called the meta
circular evaluator and there's this
wizard doing things to it and JavaScript
is actually in many ways very similar to
Lisp it has a lot of the good parts from
lift
except it's not homo iconic which is
this very mystical term which I won't be
mentioning any more because it's not
relevant so meta programming I did a
Wikipedia lookup and they have defined
meta programming to be the ability to
treat programs as data and the ability
to read generate
lies or transform other programs and
even modifying itself while running so
what are they really referring to when
they're saying all this these things so
one of the staples of metaprogramming is
macros and what macros does is that it
enables you to create your own language
constructs and your own syntax so here's
an example of a meta programming library
for JavaScript called sweet Jas where I
define some syntax and if I use that
syntax it will be expanded to whatever
that syntax compiles to so this is an
example of doing macros in JavaScript so
here I've created some of my own syntax
but you can also use this to create your
own operators so let's say that you
wanted to have a different way of
handling promises of a chaining promises
so I'm creating some sort of operator
here so that I can write code that looks
like this because I think that this is a
better way of expressing chain promises
so this is just an example I don't
actually use this but you could use this
to create a better developer experience
for yourself so all of this macro stuff
happens during compile time meaning that
all this happens before any of your code
runs and a lot of languages also have
this separate step for macros called
macro expansion time but the important
thing is that all this happens before
the code ever runs so the other part of
meta programming another branch is
called reflex
and reflection has some sub-branches one
of them is introspection meaning that
code is able to inspect itself self
modification which is pretty
self-explanatory meaning that there's
code that can change itself and then
there's this thing called intercession
intercession the definition of the word
is acting on the behalf of someone else
or intervening with someone else so
intercession that means that it's code
that can make decision decisions based
on itself so an example of introspection
in JavaScript and it could be that we
have an object here which have some
properties which again have values and
then I use this method here called
object keys to see what kind of keys
exist on this object so I've just
inspected the code has inspected itself
while it's running such as a simple
example of introspection and then you
have self modification so we can imagine
that we have just a simple function here
that is a sum function but it's a bit
grumpy because it usually returns the
sum of the arguments but if you ever
pass in a first argument that is larger
than five it rewrites itself to only
ever return zero so if I run this with
one plus one it returns two if I return
if I do it with ten plus one it returns
eleven but all of the preceding times I
I call this then it's just going to
return zero so it changes itself during
the runtime and then you could do very
simple intercession in JavaScript as
well so if you have an object which has
a property we could use this feature
called
object defined property to say that we
want to define
new property on this object and we want
to define a getter for that property
where we say that if the health property
here is bigger than zero it's going to
return a string fit like a champ
otherwise it's going to return hurt
badly based on the health of this hero
so if I try to access hero dot status
here that would be a string hit like a
champ but this sort of an assertion in
JavaScript is very limited not very
flexible because you have to be very
explicit about which fields should have
these special properties but the
important thing about all of all of this
is that it all happens during runtime so
this happens while your code is running
so now let me know what's the most
important parts of meta programming is
we can ask ourselves why is this useful
why what do we do this so I I had a hard
time coming up with a concise answer to
that but I did a little Wikipedia and
Google again and it said that in some
cases this allows programmers to
minimize the number of lines of code to
express a solution and thus reducing the
development time which seems pretty nice
but I think that the main thing that
meta programming enables is that you
want to have the ability to express and
model your problems in a way that makes
sense
and which is as expressive as possible
because what we want is really developer
friendly interfaces so that you could
use meta programming to create all these
interfaces that you would like to have
and you could build these higher-order
abstractions from it so so a general
higher-order abstraction or interface
that we're used to from the web
is proxies in the form of proxy servers
that are placed in front of a set of web
servers so a proxy server might be
placed in front of one or more servers
and it's there to abstract away some
sort of complexity it might be rules for
authentication it might be some sort of
logic for redirecting and so on but the
main thing is that the consumer can't
see a difference between the proxy and
an actual server it's supposed to be
transparent to the consumer just to
provide a single interface to the
consumer so the proxy has the same kind
of methods that a server has and
different use cases for this might also
be like load balancing compression
caching and so on everything that you
want to abstract away from the client so
this is a very specific use of proxies
in web servers but there's no reason why
we can't generalize this and say that we
could have a proxy that we put in front
of one or more just more general objects
so an object has different properties
that you can read you can get something
you can set something it might have
message that you can apply and so on so
again this is all about providing a
better interface to program against and
to interact with so in in JavaScript the
specification for this new type called
proxy has existed for for a long time as
a specification that is and it's a part
of the ACMA script 6 specification it's
its own type and
this is the feature that enables you to
do this advanced type of intersection in
JavaScript because what it enables you
to do is that you could define custom
behavior for these fundamental operators
fundamental operations like property
lookup assignment enumerated and
function invocation and so on so all of
these fundamental things that you can do
in the JavaScript language and because
of this there is no viable way to
transpile this so that you most of FMO
script 6 is just syntax sugar you could
just use babel to transpile it but you
can actually do that with proxies
because it changes the fundamentals of
the language but fortunately now the
support has become really good so you
can actually use this so fairly recently
the support has gotten really good so
let's have a closer look at this proxy
thing so the proxy is has its own
constructor and the constructor takes a
target object and a handler object and
this target object could be any type of
object it could be just a regular object
it could be an array it could be a
function it could even be another proxy
so that this could be recursive but the
important thing is that anything that is
an object could be the target of a proxy
so the nice thing about JavaScript is
that arrays and functions are just
objects underneath another thing about
the proxy is that it's completely
transparent meaning that if you take a
type of of the proxy it'll always return
the type of the target that you pass
through the proxy to create it so
there's no way for the consumer to
know that you are using that you've been
given a proxy and then there is the
handler object which is the second
argument to the proxy constructor and
this handler is an object that contains
these so-called traps traps for
operations on the object so any type of
operation that you could do to the
object it's something that you can trap
in this handler so an example here is
with a get trapped where I'm saying that
if you try to get something from this
object you should check if this property
that you're trying to get exists on the
target object if it does you'll just
return that otherwise you'll return 37
so if I make a new instance of this
proxy with just an empty object that's a
target and I set the property a to 1 and
then the property B to undefined if I
log log out the result of getting a and
B I'll get 1 and undefined but if I log
out the result of checking if the object
has the key C it'll give me false but if
I try to log out the C property it will
log out 37 because it doesn't really
have it doesn't have the C property but
we defaulted to 37 so that's just a
simple example of trapping operations to
an object and there is as I said a trap
for any type of operation that you can
do to an object so you can trap the get
operation to set the has operation which
is the operation that is triggered when
you use the in operator and you have
construct so if you try to construct a
new instance of this
object you can trap that by using the
construct trap and so on and so on so
any type of operation that you can do to
an object can be trapped and there's
also this new API included together with
the proxy which is called the reflect
API and the reflective API is an API
that has a method for any type of
operation that you can do to an object
so if I have an object here I can use
reflect that get to pull out the health
property of the hero so you could of
course in it but why you need that
because you could just access it
directly but the point of this reflect
API is that there is a one-to-one match
to the proxy traps so that if I wanted
to define a proxy that is just defining
the default behavior of an object I
could put in the corresponding reflect
methods into all of the different traps
and there's also a special type of proxy
which is called a revocable proxy so if
I create an object here and they want to
proxy that with a revocable proxy I
could use the proxy adopt revocable
method and then it takes the same
arguments as the proxy constructor but
instead of just returning a proxy it
returns the proxy and a method that you
could revoke this proxy with so if I try
to access proxy dot name here it'll give
me the name but if I revoke this proxy
it will throw an error the next time I
try to access something on this proxy
because you're not allowed to do that
anymore
which pretty much then makes the proxy
useless so a lot of this meta
programming types that you could do with
proxies is available
as we saw with object defined property
and object keys and so on but the main
thing about proxies is that you can now
overload operators that are fundamental
to the language you can overload how the
dot works how the equals works and how
function invocation works so now that we
have introduced the important stuff
about proxies and the reflect API we
could look at some simple examples of
how you would use this proxy for
something useful so one popular example
to look at is validation so we could
make ourselves a function that takes an
object and then takes a set of
validations that you're supposed to do
on that object we could return a new
proxy of that object that we passed we
can say that we want to add a set trap
so whenever you try to set something on
this object it's going to be trapped by
this proxy trap and we'll assume that
this validations object here is just an
object that contains a function for
validating whatever key it belongs to
and it'll either throw an error or just
return true if nothing if nothing is
wrong so we'll just validate the value
that you're trying to add to a set and
then we'll use reflect set to set the
actual value and then we'll just return
true because that is the default
behavior of using the equals operator in
JavaScript so then we could make some
validations here we could say that we
want to validate the age property and we
want to validate the name property and
for the age we'll just check if there's
a number otherwise we'll just throw an
error and for a name we'll just assume
that this is supposed to be a string
otherwise we'll throw an error
so with this we can now have dynamic
validation of objects so if I create a
new object here that is a result of
wrapping it in the validate function
with those validations that we made I
can set the name and age here to a
string and a number and nothing happens
but as soon as I try to set the name to
a number here it'll just throw telling
you that this is not allowed because it
has to be a string so this is something
that would have been really hard to do
without proxies dynamically like this
and then another popular example is
debugging and logging so we could make
ourselves a function where we log every
access to the object so every time you
try to get some field of an object we
could log that so we can create a new
proxy and then we could have a getter
trap and whenever you try to get
something from that proxy we could log
out that you've tried to access a
certain key and then we could pass a
second argument here if you wanted to
have some kind of string reference so
that you can know which object that you
were which was was accessed then we
could just return the result of using
reflect get to get the actual key on the
target object if you wanted to use this
you can make a self tanner and then we
could make a proxy where we pass that
object into that function give it some
kind of reference and if I try to access
H now it'll just log out access H on ABC
or if I try to access a name it'll do
the same thing so the nice thing about
this is that you're able to wrap objects
wrap functionality around objects
without the objects knowing about this
and until recently we actually used to
have a specification for observables in
JavaScript which we don't anymore
because that was that was revoked for
various reasons but with proxies you
could actually pretty easily make these
observable objects yourself so we could
make a function here that makes an
object observable so it's a function
that takes an object and then a function
that's going to be called whenever
something changes so you can make a new
proxy we could add a setter trap so that
whenever you try to set something on
this object we can do something we'll
just do the the regular thing of setting
whatever value you tried to set on the
object and then we'll call the on change
method with the key that you set and the
value you can do the same thing here
with the delete trap so if you delete
some property from the object we want to
have a notification about that as well
so now we could use this
we could have an object here and the
main difference between this and the
original object of serve is that you'll
have to override the original object
because it'll only trigger if you try to
access or change something on that
observable object so if I just wrapped
around observable here and change
something on person without overriding
it nothing would happen so that's one of
the drawbacks but now you could change
something on this object and it will
trigger your own change method so that's
observable objects which could be useful
in a lot of situations
then I found this example here by a guy
named Keith who used proxies to make
this DSL which is another thing that you
could use proxies for so this is a URL
builder meaning that we could use the
fundamental operations of an object to
just build dynamic results so we could
have we could create an instance of this
URL builder by giving it the first
argument which should be the domain and
then we could just start to say that we
want to use the Google URL builder we
want search products bacon and eggs and
then as soon as we call this as a
function that will return an actual URL
so again these are pretty pretty simple
examples and I would say that yes this
is this is nice but why is this useful I
would I would probably say that yeah
cool but I'm probably not going to use
any of this
so I haven't really looked into proxies
for a while but I've been on a project
now for about eight months where I
finally found a very real-world use case
for it and in this project we have a lot
of real time data a lot of real time
data that looks might look something
like this we have a lot of collections
we have let's say we have a set of
stories which is just a large array of
different stories and then we have a
large array of people here and if you
look at these data structures here you
can see that
just plain and this is plain
serializable java script but there is a
lot of references here so that we have a
set of stories here where every story
refers to some author every story has an
author every story has an array of
people that have that have liked this
story people who have read this story
and so on and they all implicitly point
to some other collection so there's a
collection of people as well and those
people have authored stories and they
have read stories and they have liked
stories so and so this connection is in
both directions so you might say that
this is a sort of graph like data and
the graph looks sort of like this it's
just a very big object with a lot of
collections and all of the collections
have references to other collections or
the same collection so in this project
we we're pretty we're bound to this to
this data format but what we really want
to do is be able to access this graph
here this JSON graph very deeply so I
want to be able to say that I want to go
into this graph I want to pull out the
first story and I want to find out who
are the people like this story and then
I want to find the name of the first
person that liked this story and you
might imagine that this goes deeper as
well so another example is that I want
to go into the first person and I'm
going to find out yeah maybe it's
supposed to say stories there as well so
I want to find the author and then I
want to find out the likes and then I
want to find the name of the first one
so the way you could do this is first of
all you could do this very explicitly
but just very naively so that you could
go into the into the graph you can pull
out the first story from the story
collection and then you can find all the
references to people their will which
will just be strings and then I could
map all of those I could say that okay
take all of those strings and then for
each of those strings go into the graph
again into the people collection and
then find the correct person and then
map that back to back to our results and
then we could use that to find the
actual person we were looking for and
then find the name and so on and we
could do this with the other example as
well so this is very explicit and it's
not really a nice interface it's this is
just one or two levels if you want to
access something seven eight levels down
into the graph this gets really tedious
so we looked at several several
approaches to solving this and one of
the things that kind of inspired us was
the whole functionality that MongoDB has
the populate so in MongoDB you could say
that I have a collection of strings here
which are just references to other
collections or the same collection and
then you could say that I want to pull
out this this item from the database and
I want it populated so you can so you
could say that I want all of the stories
here on a person to be populated from
the story collection so this would be
okay if you were going to do this just a
single level but if you're going to do
this recursively that doesn't work very
well and we also didn't have the luxury
of being able to use something like
MongoDB
and another thing is that we really
wanted this thing to be schema-less
so if we had a person object here where
that contains just some metadata and
then we could say that yeah this person
has authored a set of stories and he has
read the set of stories but we might at
some point want to add another field
that they have liked the set of stories
or at some point you might want to say
that yeah we want to have every person
is supposed to be able to make their own
list of stories and then they can refer
to a set of stories there as well so
that this schema might change at any
point in time which would make these
having schemas at all very hard so our
solution to this was to just go for
these naming conventions so an object
here containing a story is authored by a
person and person here refers to the
people collection so we we just said
that if you find a key that that has a
pluralized version as a collection just
try to look up that reference and then
we want that to be accessible so that we
want to go from a reference here to an
actual object that you can access deeply
and then again stories here links back
to the stories collection which could
then be populated with itself and so on
so you could think of this as an
infinitely recursive graph the first
thing we did was try to do this
naively with something like object
assigned so the code here isn't
important but we tried to solve this
using object assign and then to create
some sort of interface here where we
could say
I want to have a method called populate
which I can pass some sort of depth how
long do you want to be able to access
this graph how deeply pass the graph
itself which is just a JSON object with
the set of JSON collections and then we
could pass an object that we will want
to be populated against this graph so
now we could say that I want to have a
populated person which should I want to
be able to access three levels deep and
I'll pass it the graph and I'll just
pass the first person of the people
array alerted the people collection
because that's the object that I'm
interested in and this actually works
pretty nice so if we access this object
now or we pass this into the populate
method it'll do this but if you try to
do this more than say four levels
everything blows up because this just
grows exponentially right you wouldn't
be able to do this we want to let's say
we we wanted to be able to access this
infinitely deep of course that's going
to take infinite amounts of memory and
it's going to be insanely slow and it's
just a very naive approach to try to
solve this but it would be so nice if
that just worked and this is where you
could use the power of proxies because
now we could try to implement the same
thing here using proxies and that's what
we did with the exact same with the
exact same API so instead of the instead
of this now being the depths that this
is being populated it's sort of more
like a maximum depth for some reasons
that I'll show later but it's the exact
same thing and now this this works
the same way except you're able to do
this infinitely deep and the reason for
this is that imagine that we have these
two collections here so stories and
people here represent the graphs so the
graph is just two collections that are
in some ways linked to each other so if
we try to access the first story here
and we want to access the person and we
want to because we want to go into the
author of the story and we want to go in
and see what is the first story this
person has authored whenever we try to
access the person here instead of us
eagerly populating and making an
insanely large objects with proxies we
could just implement this as a jump so
whenever you try to access this property
it just jumps to the object in the in
the people collection and when you try
to access stories from there it just
jumps back so you could access this
infinitely deep it seems like this is an
infinitely recursive a big object but
you're just jumping and that means that
you can do these things you could just
access things infinitely deep without
without actually creating an instantly
big objects let's see
yeah that's what I mean about proxies
being lazy here because when you create
a proxy see when you create a proxy like
this with the object design version
you're actually doing this eagerly
you're creating this insanely large
object that is returned to you but when
you're using proxies you're just
wrapping a proxy around which is lazy so
nothing happens until you actually try
to access something on the object but
the caveat here is that if you don't set
a limit to the depths and you try to
stringify this proxy it's going to just
blow up because that means that it's
going to recursively access any property
that the object has so if you want to be
able to stringify or at least serialize
this in some way you'll have to set a
limit of the depth that this is going to
be populated but otherwise it works
exactly the same and for the consumer
there is no difference between how you
use this proxied version and the object
of fine version which is the important
part sorry about this so this made us
really happy because now we were able to
use this really nice way of accessing
the graph very deeply and we didn't have
to pay any performance costs by doing it
and the other nice thing is that since
this data was real-time we just always
had a representation of our data real
time as Jason we didn't really need to
do anything fancy we just needed to
update the the references correctly we
didn't have to think about this actually
being a graph it's just JSON everything
serializable so once we figured this out
I figured why not try to use proxies to
solve all of the
in JavaScript so I was going to try to
fix this undefined it's not a function
and cannot read properly undefined of
undefined so I my head a while trying to
do this so I think why don't we just
really fine what undefined this will
make ourselves a new undefined here we
say that undefined is a proxy of just an
empty function and I'll say that if you
try to get something because the nice
thing about function is that functions
have properties so they kind of look
like objects and if I define a getter
trap on this proxy I could say that in
any case if you're trying to get
something here and it's not the name of
the function I'll just return another
undefined proxy to you
so just recursively returning that to
you and if you try to call this as a
function I'll just return undefined to
you again so I can now make em myself a
function here that I chose to call
seatbelt where we return a new proxy so
we're wrapping an object in seatbelts
here and we are returning a new proxy of
that object where we have this Gator
trap and we can say that's the first
thing you can do is just get whatever
you're trying to get from that object
then we could say that if whatever you
try to access is an object we'll just
return a seatbelt version of that object
to you so that it's recursively doing
this seatbelt thing otherwise we'll see
that does this property exists if it
does we'll return that actual property
to meaning that this is a primitive type
so if it's a it fits a
I see that there's actually this is not
actually going to work now if it's false
or the number zero and for certain cases
but just imagine that JavaScript wasn't
insane so if the property doesn't exist
we'll just return our new undefined
definition and now I can make myself an
object here which I call never undefined
which is the result of the seat-belt
function where I just passed some simple
object here if I try to access never
undefined foo that has the value bar if
I try to access the the nested object
here that has the value 10 and so on so
the object works exactly like it did
before for any field that is accessible
but what if I try to access a field that
doesn't exist and then try to access
something that is not a function call
that as a function and then access
something on that again in this case
this is just a function this is just our
new undefined so it doesn't actually
crash anymore
so you can do things like this and it
doesn't crash anymore no errors so feel
like this is yeah I solved all of
JavaScript's problems and but and
there's one thing that I have not
figured out yet and that is how I can do
this what if I could just replace the
object prototype with this and this
would just be completely transparent so
I think that this is probably like the
next my next ambition here so all of
this that I've shown you here now is of
course just fully abusing proxies and
these are examples of the things that
this is an example of the things that
you shouldn't do with meta programming
because what you're doing here is
changing how the language works so much
that it's not at some point recognizable
anymore and that's usually what they
call the curse of Lisp as well
because when you start building a
program with Lisp and use a lot of
mirror programming that program is going
to have so many macros and so much meta
programming that it's kind of a language
on its own which is really the the thing
that can go wrong with using meta
programming so the really good things
about the meta programming is that you
can create this really powerful
abstractions and you can for the
fundamental operators you could get
things like laziness so that you don't
have to you could do a lot of this with
just regular higher-order functions or
other types of abstractions here but in
this case you could do it for the
fundamental operators so that it's all
of this is transparent but the really
bad things about this is that you might
introduce a lot of magic and you might
end up making especially if you use
macros as well that's going to be your
own language at some point and there's
also performance so with a star here
because we use proxies to get
performance on the the the interface
that we wanted to build but proxies
themselves are a lot slower just regular
functions and objects and so on but in
this case it made something that was
impossible possible because of our
proxies work so the main takeaway from
this is that you should you should
imagine what would be the perfect
interface to interact with this to
consume this and then try to build it
instead of just instead of just being
with what's available in the language so
that's about it I guess I see that I
have 10 15 minutes left so if anyone has
any questions I can do them all either
an hour afterwards I guess yeah yeah
that's that's the issue that you saw
with the observable as well as right
because with that version of an
observable you aren't able to observe
something that you haven't created so
that's that's and that's an issue so I
see that someone solve this by
overriding prototypes and let's say that
they wanted to proxy the console log
function they override the console log
in the beginning of their application so
that feels really hockey so yeah that's
that's one of the limitations I guess
that you'll have to work around in
slightly hacky ways I haven't found any
good ways to solve that at least yes
they are at let's see I can press escape
here and let me see so if you go yeah
it's lights calm
I take LV I'll see if I can maybe get it
a bit bigger here let's see
yeah so all the code as well so the
whole the whole grass population thing
is something that we're open sourcing
because we've think that it's a really
interesting idea and we didn't find
anything and that really did the same
thing and we're also trying to implement
this with the JSON API spec so that you
can get automatically if you have a huge
amount of like JSON API with links that
that also is something that's just
populate about that so you can access it
deeply so I guess this also kind of
overlaps with what all the graph
databases are going to do now or like
graph QL at least so yeah yes yep
yeah that's you mean if I wanted to
override how json.stringify accessed it
or yeah you can do I don't have the link
right now but you can do some pretty
insane things by using the with
statement and proxies where you can then
then you can sort of get the things that
the first question asked about working
as well but it's yeah it's a it's a bit
edgy but yeah some people are doing
pretty insane things with proxies
so yeah passing some kind of context or
at least because with what you want to
do is be able to proxy all of the global
the Global's in JavaScript I want to be
able to proxy object or object prototype
or and not have to pass that further on
it kind of like you you you want to be
able to override all those things or at
least yeah proxy them so I think that is
like the next step of this yeah
that is I'm guessing that I actually
haven't looked into how you can do that
in code in that sense but I know that if
you go for example into the console of
of Chrome you can see that this is a
proxy so there is a way to override this
it's just that it's the benefit of
proxies from the consumer perspective is
that it's transparent but I'm guessing
that there is just as you could access
the underscore underscore proto in most
of the JavaScript engines there is a way
to do this in proxy with purchase as
well but I actually don't actually
haven't figured that out yet but yeah
that would also be helpful yes
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>