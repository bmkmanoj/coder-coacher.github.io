<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Broken Crypto is Broken - Erlend Oftedal | Coder Coacher - Coaching Coders</title><meta content="Broken Crypto is Broken - Erlend Oftedal - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Broken Crypto is Broken - Erlend Oftedal</b></h2><h5 class="post__date">2017-03-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HZ3sYta9yrg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I want to
congratulating you guys because you must
be the bravest people at NDC coming to a
crypto talk just after lunch so thanks
for that the goal of this talk is to not
to dive into like how a es or some other
encryption algorithm works internally
but rather talk about how to use or more
how to not use encryption so quickly
about me I'm I work as a developer most
of the time but also do security testing
you do some bug bounty hunting and I'm
also the creator and maintainer of
retired yes if anyone has used that and
I'm head of a weapon or way but and also
i'm not a crypto expert I couldn't
define an encryption algorithm if
someone asked me to but I know a bit
about how to use it because I've studied
it for some time ah Bruce Schneier says
anyone from the most clueless amateur to
the best cryptographer trying to create
an algorithm that he himself cannot
break and this is something you should
remember never ever try to invent your
own encryption algorithm it's super hard
and the people who are actually
designing algorithms they're usually
like they build something then they ask
someone else review it and then they
find all kinds of slow us and then they
go back and forth like this forever so
ah don't invent one yourself if you want
to learn more after this talk you should
go do these like these crypto challenges
these are super good and you can learn a
lot of the stuff that i'm going to show
you by doing these and a lot more than
that as well i'm going to use a bit of
code throughout or later in the session
this is just some javascript stuff that
i use so that i can do stuff like this
so i can have a variable with a string
secret message and i can generate a key
which is 16 bytes and then i could do
some encoding and stuff that's just to
make things a bit faster when i do the
demos so if you don't find these
functions in regular jas it's because
they're not there but let's start so
first a couple of words that we need to
know when we talk about crypto already
using the words i'm going to use like
plain text that's the message that we
want to send the actual data the
ciphertext is
the encrypted data we have a key which
we can use to encrypt or decrypt or sign
we have an IV and nonsense those are
basically salts if you think in terms of
passwords those add noise symmetric
encryption means we encrypt and decrypt
with the same key and asymmetric
encryption means we have a public key
which we can publicize anywhere and then
we have a private key that we ourselves
holes and then someone can encrypt the
message with the public key and only we
can decrypt it and then the same thing
holds for signing we have hydro
symmetric or asymmetric signing so why
are we using crypto well there are a
couple of things that we want we might
use it because we want confidentiality
so we want to be able to exchange secret
messages we might also want to make sure
that data hasn't been changed or they
can't be changed and we also often use
it for identification typically we sign
tokens and we pass those around and
those kind of prove that we are who we
claim to be the next guy I'm going to
quote is a person called August
kirchhoff's and if you see when he was
alive it's quite far back what he said
was a cryptosystem should be secure even
if everything about the system except
the key is public knowledge that means
that if you have an encryption algorithm
that doesn't take a key it's not an
encryption algorithm it's encoding so
the key is the thing that's going to
protect those not knowledge about the
algorithm itself so all the algorithms
that were using today like a s and all
the other ones of course everything
about how they work is probably get the
key that protects us when we're going to
create this key we need to have a secure
random generator not something like this
but people are failing at this so there
was a couple of researchers that we're
looking at hard drives and they figured
out that some of these cells encrypting
hard drives they're not doing it in the
right way so one of them was actually it
was opposed to generate a big key but
that key was actually a small key
repeated four times
so it the actual entropy of it was like
32 bits instead of what we normally
would want which is like 256 bits or
something like that another thing is for
instance if you're using the non-secure
random functions like this is the one
from Java if you get two inch from that
random like you ask it give me an int
give me another int and then or actually
give give me along because along is two
inch just a pendant feature then you can
reverse-engineer the state the internal
state of the random function and there's
even some github code for it where you
can test it yourself I played around
with an application this is quite a few
months ago I was trying to start an
application in docker and the
application wouldn't start and I was
like what's going on why won't my
application start and it turned out this
was a this was a web application and was
trying to generate a key for sessions
but the docker container didn't have any
entropy it didn't have any random source
so just it was just hanging waiting for
more random so it could actually seed
and start the application so that that
was a problem either it's not a problem
with dr. anymore but it used to be like
you couldn't get any random in there and
this has also been a problem with debug
devices like a Wi-Fi routers where they
would generate like these instead of
every one every router coming with
security disabled they would have liked
these default passwords but some of them
they were generating these passwords in
the wrong way and so they were easily
trackable when we talk about like the
length of a key we often end up talking
about the birthday paradox so if there
are 23 people in a room that's enough to
be quite sure that two of them have a
birthday at the same time which is kind
of counterintuitive if you think about
it because like 365 days you would think
it was more around like half of that not
23 which is fairly low but the thing is
we have to take into account that there
are many things that has happened
already so not only can you have the
same birthday as this person but you can
have the same birthday as every other
person in the room as well
so the if we try to sort of calculated
it looks something like this and it's
fairly close to the square root so we
often use the square root as an
approximation and this means that if you
can choose from 10,000 values you're
going to get a collision at after around
100 and if you have a key that's 2 to
the 64 you're going to get a collision
after two to the 32 seconds which is
also quite weird ah this is me just
calculating numbers between 0 &amp;amp; 999 and
seeing how many times do I need to do it
before I get a duplicates so is here the
average I got here was 116 and not a
hundred so but that's just the actual
number is a bit higher than hundred but
i got i found that wicked somewhere
after eleven here after 27 after ten and
sometimes i have to go higher than
what's expected and I can do this many
times the last number there is just the
average so i can i can just keep going
and it stays at around the same place so
I'm just doing numbers so once we have a
key now everything is super good like we
create a master key and everything is
fine and then we have this this tells us
something about the keys that we have
and how we should handle them if it's
easy to get the key then it doesn't
matter if we encrypted stuff really well
so if we encrypt a lot of stuff and put
it in the database and we also put the
key in the database sequel injection
will extract all of that and it's back
to zero but ok so let's start trying to
encrypt something so we're going to
start with an attempt at defining what
we want so given a ciphertext it should
be impossible to find the plain text so
if I want to communicate with one of you
it should be impossible for everyone
else to to figure out what's going on
the first thing we could do is we could
share some keys up front so this is a
one-time pad from Wikipedia we get also
and this was this is kind of used to
substitute letters but we can do it in a
more
computer friendly way so we can generate
random key and share that key so we we
have columns of it and then we can X or
whatever we want to send with this key
we just excerpt the letters together and
then the crip shin is the same we just
excerpt the ciphertext than with the key
so we have a plain text which is a
message we generate a key and we take
the values that's all day the hex values
of the letters and we XOR them and this
is the hyper text that we get that looks
nice ok is there any problem with this
well first let's look at how extra works
by the way so we do it bit by bit so if
a looks like this and a lower case I
looks like this and space looks like
this we see the difference between the
capital a in the locus days it's
actually just the the third base is 0
and a 1 and the space character is
actually the exact same thing so if we
XOR an a with space we at locating which
is quite funny and we can do the same
with all the letters even just crazy
Norwegian letters that we have here
works for them as well and there are
some rules there as well if we XOR a
letter with 1 1111 we get the exact
opposite if we XOR it with 0 we get the
same thing back if we exert the same
thing with itself we get 0 and it you
can switch them around it doesn't really
matter and also if you have one thing
that's exerted with something and you
XOR that with one thing that's extra
with the same thing the 2 a's fair in
this case they cancel each other out and
so the end result is the excerpt would
see this sounds a bit why am I talking
about this we'll get to that in a second
because the one-time pad its
confidentiality but wise quite secure
for a single message it's super hard to
break it because I mean the key that we
are using it could mean anything right
there are a lot of different valid
values that could come out once we do
the X or it could be secret message as I
jordans just earlier or it could be like
a Britney Spears song with hit me baby
one more time or whatever it doesn't
matter it could be anything so we don't
know
but the problem is we can only use the
key ones that's not a nice thing for an
encryption scheme that's why it's called
a one-time pad and how do we exchange
the key because the key actually has to
be the same or longer than a message we
want to send so we need to have some way
of actually transferring these fees and
and for like all the encryption systems
they used to have these like long long
paper things we're with the pads in them
and they could transfer them upfront and
then they would have a secure messaging
system but this is not very computer
friendly for us why can we only use it
once well if we have obtained text and
we exert with the key and we get a
ciphertext and we do the same thing with
another plane txt what happens if we
make sure the two cipher texts well the
keys cancel each other out and what we
end up with is the one plain text
excerpt with the other that doesn't work
well and if you have a lot of these then
you can start looking at these in
combining them and you will actually be
able to get back the original data
that's one of the tasks on these
critical challenges that you can play
with also if I know one cypher text and
one plain text I can explore them
together and then I get the key which
also isn't a nice feature and yeah if
the message is longer than the key then
I would have to repeat the key and then
I'm actually using the key more than
once so that doesn't work but all right
there's also another problem here if I
can submit data to a system and have
that system encrypted for me and get the
encrypting back well I could just send
in a bunch of zeros and I would get the
key back which is also not a nice
feature but for sure no one is doing
this right unfortunately that's not true
there was an app called into walls which
was I think in android apps and it was
used it had lots of downloads and it was
supposed to encrypt everything you had
on your phone but first of all it only
encrypted the first 128 bytes of each
file and the way that it was it took the
password that you entered
and it took the hashcode of that and it
did an and operation which means it's
reduced it to a single bite so now you
have 256 different case so it's actually
easier to brute force the key than to
brute force the password that's not a
nice feature all right ah this doesn't
really work let's try to find a better
definition so given a ciphertext it
should be put impossible to find the
plaintext we want to stick with that one
but we want to have a reusable key one
that we can use more than once and we
also want to be able to have a plain
text that's longer than the key and
there are a couple of ways we could go
there are basically two types of fibers
or are actually more in this but two
main types stream ciphers and block
ciphers in a stream cipher we generate a
key f key stream from a key so we take
the key as input we generate a long key
from it and then we can do exactly as we
did with the we can do exactly as we did
with the one-time pad we kind of just
extra stuff together and then we get
some of it one example is our c4 but
that's not something we should use
anymore because it's been probably
broken it it has a tendency to have one
of the bits the one more or more often
than a serial or the other way around
that's enough to break it it does
support having a plain text length
larger than the key size because you're
sort of stretching the key out ah it
does however kind of leak the plain text
link so if we look at this this is a
voting database where we have four
different boats and I'm pretty sure you
can figure out who voted no so I
encrypted all of them with the same key
alright so let's encrypt them with
different keys well you can kind of
still figure out which one voted no
because it's shorter than the others all
right let's look at block ciphers
instead so the way block ciphers work is
we split the data into blocks of a given
size and we encrypt each block
separately so AES is an example of this
or des or crippled s is also an example
of this the first way we could go was
something called the electronic cook
mode so we take our plain text and we
have our encryption function that takes
a key and then we split the plain text
into blocks we pads the last one we move
run them all through this encryption
function and there's our cipher text and
when we want to decrypt it we spit it
back into blocks we take the decryption
function taking the same key run them
through remove the padding and we have
our plain text back but the problem is
what happens if two blocks are equal now
AES is a for instance is a deterministic
algorithm there's no randomness involved
so if you have the same key and the same
plain text you get the same ciphertext
block which means if you encrypt the
linux penguin you can easily from the
just studying the bits you can sort of
reverse engineer the picture that's
buying it all right so what what is the
natural next step was to find some other
modes where we kind of add some noise
this is where the IV comes in so there's
something called CBC cipher block
chaining mode so we start out the same
way with better spit up and we pad but
then we introduce this IV and what we do
with the IV's we XOR is with the plain
text before encrypting and then we take
this first block of ciphertext and we
expert that with the next one so we kind
of propagate the noise that we got from
the IV throughout so we go ahead like
this and we get our ciphertext and we
usually then send it together with the
IV to the one who wants to decrypt it
and it goes like this so we run it
through the algorithm we XOR it and we
get it back and then we take this thing
and it works like this fairly simple now
we've propagated some noise through it
should be it so now we won't have the
linux linux penguin problem anymore but
there are some other problems here so on
the on the left hand side here we have
the ID that's the i0 i1 that's the
individual bytes of the IV and on the
right hand side with the say you have
the ciphertext cybertek spikes and when
we decrypt this we first get what we
call an intermediate value and then we
extra it with the IV and outcome
the plaintext fairly simple so if we
change a single bit up there in the
ciphertext because of the way it is a
decryption algorithm work that will
completely change the intermediate value
it will become something completely
different and thus when we exert with
the IV the end result is probably going
to be garbage however if we change a
single bit in the IV we will only change
a single bit in the results and this is
something we can use so let's say we
have something looking like this so this
could be like a signed cookie or an
encrypted cooking i'm going to say
unencrypted cookie with the adjacent
there's a user ID five if we change the
eleventh bite of the IV we would change
the outcome of the eleventh bite here in
the plain text so if we remember the
extra stuff we could say okay so the the
letter five has an ASCII value of x 35
so we know that I 11 and d 11 that
becomes certified and we wanted to
become a 1 because we want to be user
with ID one that's usually the admin so
we can calculate it and figure out that
what we want is just to take the
original value up there we XOR it with
35 and 31 and thus it becomes one so but
this is this is boring to just see on
the slide so here I have this nice
little application where I can log in
and out with a password but I own I can
only log in as Homer because that's the
only guy I know the password for but
there's a cookie here
and okay so there's something called
session 2 and something that looked kind
of like some some encrypted stuff at
this base 64 so we could go ahead and we
could try to to grab that one so we can
say okay I'm going to split on a spit on
the semicolon sign take the first part
played on the equals take the second
part and that would give me that value
okay and then I can take that and I can
base64 decode it so this is the
functions i talked about earlier and
then convert it to a bike a ring like
this i'm going to store that in variable
so i can play with it so now i have the
the ciphertext as a x derivative so now
i'm going to change the letters so I'm
gonna take the H up there maybe this is
a bit too small i'm gonna try to make it
a bit larger so i'm going to take the
age up there and I'm gonna XOR it with
the a then I'm going to first expert
with an H to get it down to zero and
then with an A and then I can do the
same thing with the next one because I
want to become the admin of course so I
can go I'd love em in admin and Homer is
at the same spots I'm not going to touch
that one I'm going to change the 12th
one and the 13 1 so just doing the same
operation all over again and then I'm
going to pack it back into the to the
cookie like this i'm going to take the
i'm going to set a new cookie called
session to so i'm going to overwrite the
old one i'm going to take this array
that and I've changed and i'm going to
create a string from it and then
basically four encoded and when I now
refresh hopefully I've become the admin
so I've changed the countenance and I
wasn't supposed to be able to do that I
would get so that's that's not exactly
what many people are expecting when
they're encrypting stuff like that okay
so we can change stuff that's not good
but encryption isn't the same as signing
that's why we have two different things
called signing and encryption and
encryption doesn't imply signing in many
cases not for this one-time pad I
because we could just flip it and I
would flip the end result all right when
we're patting this this is also
interesting there are many ways of
padding data to make it compliant with
the block size one of the most common
one is called Kiki pkcs7 and we
basically add let's say we needed to add
seven padding bytes then we set all
these 27 and if we need at six with
seven to six and for the last thing if
it if the main tech actually is at the
block sites we need to add an entire
padding block because it or else it
wouldn't be able to separate if the p7
here was a seven and it then would think
it oh I need to remove all the all the
padding and it would be wrong so then we
need to add an entire padding block so
why is this interesting well a lot of
frameworks if you do if you mess with
the padding so here it says they're
supposed to be a free and according to
do this then there should be 3 33 but
here is 3 10 5 and then we will
typically get an exception so the
decryption function will say hey the
padding is wrong I try to remove this
but the first one is a 3 the next was a
10 that doesn't make sense and we'll get
like a padding is invalid or something
and this is actually enough to decrypt
the data because we can abuse it so
again I have the same setup I have the
IV on the left and the cipher text on
the right but now I know nothing about
the values here so that's why there ? so
first I'm going to take a copy of the
original ID up there because that's the
original idea that was used to encrypt
it so I'm going to take a copy of it
down there and then I'm just going to
randomize put a completely different I
be up there which is very likely going
to cause the end result of the
decryption to be garbage and then I'm
going to get a padding error because
it's likely not going to be a valid
padding the thing I'm going to do next
is I'm going to start the last bite of
the IV i'm going to start flipping it
i'm going to start at zero and then go
all the way up to 255 at some point i
will get a valid padding because then
this thing
ba1 so let's go ahead and do this I'm
not sending a request to the server
sending lots of requests through the
server and you can see it's going up
it's going up it's going up and at some
point it will tell me hey this will this
was a valid padding when I get a 1
sometimes it happens early sometimes
it's happens at all the way to work
again we'll see how lucky we have to
bathe looks like it's going to be all
the way to our say okay so there if I
sent in da there I got a 1 so now I know
that this is the one and then I can
excerpt that with da to get that value
and then they can exploit that value
with this values to get this value I
know this is kind of hard to grasp and
went just after lunch and everything but
it's that's the way it works so now I
know that it's a three and i know that
this one was padded with three the
original message then I change this one
to become a two and I try to brute force
the next character to change this one to
become a two I simply have to take the
last slice and extra it with the one and
A two so we go back to zero and then we
go to two and then I can start reversing
the next one and this is speeding up now
so it's not going to be as slow as it
was for the first one because it's it's
going to take a bit of time to brute
force all of them so the cool thing
about this if you've seen a movie where
they're attacking something and they
come up to door and they have this card
that they're sticking in and like oh
yeah now we're going to get the password
back and you get this they guess it's
one character at the time well this is
the exact thing that's going to happen
here right now look at this it's finding
one letter at the time you can see now
it's now is speeding up so it should be
but look at the request count over there
so I would have to spend a lot of
requests to the server to do this and
soon we will have the very boring
message that was actually encrypted here
the funny thing is this is actually
running in the browser right now
almost there and there we go so stolen
secret that was the plaintext so by
using this we were actually able to get
the original message back without
knowing the key just by abusing the
padding so why why is this important
well there has been boxed around this
like in in two thousand 2010 there was
this problem with the way that files
were being downloaded from or actually
Ajax and JavaScript files were
downloaded using asp.net the thing is
you can actually use a padding Oracle
also to encrypt messages so you could
change this to be the file that you
wanted for instance web config and you
could download that by using this this
error and there's been a lot of them in
TLS and where ssl as well example hair
poodle which is padding Oracle on
downgraded legacy encryption so there's
padding Oracle again and there was one
last year which someone called lucky
negative 20 or something but it was also
a padding Oracle problem in TLS okay so
let's let's kind of try and avoid these
padding Oracle so let's do something
like this can anyone tell me what's
wrong with this code make sense right we
okay so if the decryption fails we get
up adding exception and then we return
not found and that's the same thing that
we're going to yes it takes a different
amount of time because if the value is
correct we're going to look it up if
it's not correct we're just going to go
straight down here so we have a timing
problem this was actually a timing
problem the one I just talked about and
there are a lot of other of these sides
channels as we call them as well it
could be response time or computation
time it could be cpu usage it could be
power consumption if you can measure a
power consumption that's something they
often do if they're attacking like chips
on smart cards or things like that it
could be electromagnetic leaks it could
be the size and more stuff so here's an
example of a size problem in this case
the headers of an HTTP request
are compressed so if we create if we are
as an attacker can make someone's
browser do a request and we can observe
the links of the data as its flowing
over the wire like let's say we're
sniffing a a conference network we will
see a difference in the encryption here
or actually on the size because of the
compression so the first one will say je
session equals a and then an excellent
such a session equals B but if we get
get it right it's sort of shrinks a bit
and that's enough to also decrypt data
and then there's this thing I found the
other day I'm going to assume in a bit
by measuring the targets electromagnetic
emanations the attacker extracts the
sacred decryption key within seconds
from a target located in an adjacent
room across a wall that's kind of scary
just by like measuring radiation from
your laptop they can get the encryption
key all right but what if we kind of
could get also our integrity from
encryption there is something called
authenticated encryption and what we're
doing when we're using authenticated
encryption is that the encryption
algorithm also generates a tag or a Mac
on the data and that proves that it
hasn't been tampered with so that would
foil our previous attacks an example of
such algorithms are AES GCM or a sec em
you've probably seen a GCM used on the
web now it's often used in TLS
connections but it has some weird
properties as well so both GCM and CCM
are based on something called aes
counter mode and a is counter mode works
like this so we take the plaintext and
we generate a non a number to be used
only once we split it into three blocks
because we're gonna need three blocks in
this case and this is the counter that's
why it's called the counter mode because
this essentially becomes the counter so
the first log is of 0 1 2 etc and then
we encrypt these counters to generate a
key stream and then we remove the stuff
that we don't need from the key stream
and then we excerpt them together and we
get the ciphertext
and we send that off and then the
receiving party can do the same thing it
takes the nonce adds to these numbers
and encrypts them and you can see it
happens in parallel that's why a lot of
people like to see em because you can
encrypt the individual blocks in
parallel in cbc you would have you
always needed a result from the previous
operation so it's not paralyzed able but
this one is and then we have the key
stream we drop the stuff that we don't
need we exert them together and then we
get the same text back now the problem
here is what happens if we reuse the
nuns then we get the same key stream and
then we're back to the one-time pad
right if we XOR two things together so
this is how you see'em actually looks
the stuff that i just talked about it
was going on up here and but there's
some stuffs going out here and so stuff
which takes the which generates this tag
that's going on down here and we get a
tag at the end so this is what what kind
of GCM adds a to is a CTR and and
there's been problems with this as well
there was something called the forbidden
attacks on GC MHT HTTP s where it was
found that some implementations they
would reuse the nonce from time to time
and then it all falls apart the next
thing is asymmetric encryption so we're
just going to briefly talk about that
the most common one that people are
familiar with is probably RSA RSA
actually has this property that's if
we're going to take a plain text we can
only encrypt something that that's lower
than the key link i think it even has to
be long a bit shorter than the key
length but usually the way we do this is
we generate a symmetric key because
symmetric encryption is a lot faster
than a symmetric encryption and then we
encrypt the data with this symmetric key
and then we encrypt the symmetric key
with the RSA key so this is the way
HTTPS or GLS works this is a good
algorithm for doing that this is not so
good but this is very very common still
and if you have to be cryptography
professor Matthew Greene he says peaky
pkcs12 five is awesome if you're
teaching a class on how
to attack cryptographic protocols in all
other circumstances it sucks so all
right we shouldn't use that anymore if
we're going to like try to use for
instance CBC we need to add integrity to
it so we could do something like this we
could take our ciphertext we can encrypt
it and then we could sign it with a
signature algorithm and then we can send
that over to the client and then the
client should check the signature first
and then decrypt it because then the
signature will fail if you tampered with
it so we wouldn't have a padding Oracle
it's super important to check the
signature first but all right let's talk
a bit more about signing so the first
thing to note is don't invent your own
signing there's a lot of people who are
trying to be clever and they're doing
something like this so the signature
that we're going to have is we use md5
and we take a secret key that only we
know and we take the message we want to
sign and we just concatenate them
together and we generate a signature it
doesn't matter if it's sha-256 or if
it's 75 it doesn't really matter even
putting this secret at the end is not a
good thing this is why we have something
called H max we should use that instead
an example from Flickr they had an API
back in 2009 that was using this
construct of secret plus something in
the md5 and they have some other issues
as well if these were the URL parameters
it would do a normalization of that we
just remove the ampersands and the equal
signs and shove them after the secret
and then that's what would be signed the
problem is that according to this
algorithm these two are the exact same
because was it a be with this value or
was it actually bar to and etc etc it
doesn't know to briefly explain how this
works imagine let's we have some data
and we want to sign it so the purple
stuff here that's the secret that only
the owners of the side note and that the
blue stuff is the data so also md5 is a
block page so which made it up into
blocks wee pads the last block and then
we run the same function
with the previous thing as input so
first we start out with what's called
the escrow which is like a starting
value for md5 and then we run the
function on it and mix those two
together and then we take the output of
that and mix it with the next block and
then the next block and we end up with a
with this result the problem here is you
can do something called the length
extension attacked if you for some
reason wanted to have something that
incidentally had the same padding value
here so let's go back a bit so if this
thing has the exact same padding value
here these things the first part here is
equal so if we have the output of this
we can simply use that here and add new
data and add a new valid padding and
thus with added stuff to an already
valid signature this is pretty bad so
use H max if you're going to sign stuff
with a symmetric key if you're going to
do it with a private key or an
asymmetric signing you could use
elliptic curve cryptography or you could
use RSA if you're gonna use RSA use a
decent padding scheme and not this P
cases or 15 again because that's broken
there as well signatures are used in
many different places and one of them is
in XML so I'm going to briefly explain
how XML signatures work so we have this
token and we're adding a signature and
signature consists of a signature tag
and there's a signed info tags inside it
and the signed info is basically saying
how this thing is signed so first it
tells us which canonicalization method
is being used that's to ensure that the
verifier and the signer sees the same
XML because XML can be in a lot of
different ways like you can have an
empty tag that's a start tag an end tag
or you can merge them together and have
the slash at the end you could have
white space between tags and not etc etc
what kind of the canonicalization is
about and here we say the signature
method that we're going to use is our
essay and we're going to use sha-1 as
the hashing algorithm then there's a
reference and the reference tells us
which element is actually signed so in
this case it says something with an ID
of underscore 0 which is the username up
here so this one has an ID of underscore
0 so this is the thing that's going to
be signed and then it tells us how that
one is canonicalize and then it's being
hashed so here we say we're using sha-1
as the hash function and this is the
hash of this element and then what we're
actually signing with XML signature is
this find info element so we can have
multiple references in here and then we
end up signing this so we're kind of
signing a hash of something that's
already a hash of something else and
it's kind of weird but that's the way it
works what's wrong with this code who
can tell me what's wrong here it's very
obvious when you know it it's not
necessarily if you haven't seen it
before yes it's not a timing attack in
this case yeah we'll get back to that
yes
yeah we'll get back to that as well the
thing here is it says valid there's a
hint or validate all the signatures yeah
what if there are no signatures it's
going to pass right okay so we need to
be clever let's check that it's actually
signed and validate all the signatures
and then we're going to grab the
username from this xml that we have huh
but this is wrong as well and now we get
what you two guys were saying are we
actually signing the stuff that we're
using what happens if we move this user
name underneath somewhere tag that we
don't care about and introduce a new
user name of here well this thing is
still going to be a valid signature of
this element it doesn't care if it has
been moved it just looks for something
with the ID of underscore zero and it's
there so this is still a valid signature
of this element but this xpath function
at the end here will actually find this
one all right maybe we can try to do
that as well so I have a sign-in button
here and it loves me in that former
Shipton okay that's not very interesting
what they did it actually do well let's
try to look at the code will see there's
a form and in their forum it's pays its
sending in assigned XML so I'm just
going to do like this change it to text
for some reason it's actually better to
edit it here and I'm just going to add a
new user name fields with admin and
close that and i'm going to add a an a
tag around the original one see so just
a random fact that i don't care about
and now I'm login as admin because the
signatures are still valid i'm just not
signing the thing I'm think I'm fine ok
so this all sounds a bit yeah but would
anyone actually make this mistake turns
out yes the researchers from from
Germany they looked at a lot of the
different sam'l libraries some years ago
this is what they found they looked at
fourteen different ones and 11 of them
have these problems for some of them you
can actually just remove the signature
and it will work you could just so could
just become anyone you wanted to which
is pretty bad now what's wrong with this
code then in this case it's it's a
little more so it's this is a timing
attack again so where we have a
signature that's been generated and
we're comparing it with something that
looks like a we're comparing each
character and they have hopefully this
will return something that makes sense
and this is typically how the equals
functions on strings work something like
this in this case we will have an early
exit air at the first invalid bites the
first one that doesn't equal so we have
a problem okay so let's change it so
we're going to put the boolean outside
here and then we're going to change this
in here and then we're going to return
to we're sure that we run through all of
them but it's still wrong why is that
well because we have something called
jet just-in-time compilation and it's
actually going to see this well if this
one changes to full it's never going to
change back to true so I might as well
exit damn it okay so we need something
called constant time comparison so
here's the XOR and we're doing some more
stuff here and then you don't have to
understand it it's just the weight it
ensures that it just wants to come in
and mess things up so um the next thing
we could think about is JSON web tokens
because those have become quite popular
so typically when we're using addition
we're talking we should do it we can
encode it in many different ways in this
case we're using age max sha-256 so we
have a header that tells us which
algorithm is in use so in this case that
that's HS 2 326 @ h max sha-256 and the
tight is jb t and the payload is logged
in as admin and there's a time stamp
so we basically for encode these two and
we concatenate them with a dot in
between we signed that and that becomes
the signature that which we also add to
n so everything is basic different code
looks really nice the problem is the
implementations of this have not been at
the best quality sometimes so there was
a vulnerability in many of the different
jbg libraries one thing is that the JV t
standard it supports an algorithm called
none which means what it says there is
no signature so if you could send in a
token and just set it to none then you
could once again become whoever you want
it to be another problem was that there
was something called a type confusion
where you would send in something that
was was signed with RSA but the attacker
if he had a copy of it could alter the
header to say h match and the code
running on the server side would then
look at the this incoming JVG token and
it would have a key which used to be a
public key for RSA but because it got in
the token and this is okay so this is
supposed to be an age Mac and I have a
key so I'm going to use the key as an
age mackay and verify the signature so
it ended up using the public key which
was known to everyone as the signing key
which means you could once again porch
tokens and also there's been problems
with this RSA 15 stuff that I've been
talking about which was about half a
year ago there was a problem with with
this library and more recently meaning a
couple of weeks ago on this thing was
they should actually less than a couple
of weeks ago so it was January tense
this thing with issued it says there's
some vulnerabilities in these token
signing verification things in the
Microsoft identity tokens and then I
went on Twitter to figure out what is
this thing and I find this thing so if
you use our tent identity models
fighters one with symmetric signing keys
don't miss this important security
advisory okay still a bit low on detail
but then we scroll down
which means you can truncate the JWT
signature to force the comparison on
only one bite so you just stripped all
of it and left one bite and then we say
okay so the length of this H mag is
obviously one and yeah so you could sign
whatever you want it so if we're going
to use signatures we should first verify
that the signature is correct that we
need to verify that the elements we
expect to be signed are in fact signed
so we don't have this where we can move
stuff around in the XML and then we have
to ensure that they're signed in the way
that we expect them to be signed someone
hasn't like after designing algorithm to
be something completely different and
then make sure we actually use the data
that was fine so circling back to Bruce
Schneier there's been a lot of
discussion lately about is crypto good
enough right do we have good enough
crypto all with the FBI phones and all
the breaches and all kinds of stuff and
what he says is the math is good but
math has no agency code has an agency
and the code has been subverted so this
is actually what we've been looking at
like we've seen a lot of places where
the code that's using the crypto is
wrong it's not the crypto itself like
it's not a yes that's wrong it's the way
that it has been used so some
recommendations here towards the end
never ever invent your own crypto Bruce
Schneier is watching you use a crypto
library and learn how to use the
cryptographic constructs correctly so
you don't make any of these mistakes i
use the Cure randoms of course and never
ever ever ever ever put the keys in
source control don't put your keys on
github they're being scraped all the
time if you do this this could be your
application I'm going to zoom in so we
have a door with a card reader and we
have what's going on here I think I
could squeeze in there this is just like
a piece of cloth that's holding this
thing and this there's like a drywall
piece or some
this is something I show on my way to
work one day don't let this be your
application like you have something
really super secure in the middle and
then you can just like easily
circumvented to be fair to these guys
this was like a very temporal a
temporary solution a couple of days
later they could actually fixed it and
attach these things in the in the right
ways so that was better um gonna give an
i have time i'm going to show you one
more thing so this is a research
facility and then they they have some
papers that they want to allow you to
download and in this case if we click
this link we're going to get to see this
super cool research that they've done if
we look at the URL which is a bit too
small for you to see i'm going to paste
it down here we see ok so there's a URL
and there's a signature a long signature
which looks like some hex stuff ok so
what happens if we tamper with it let's
change the last the last from Oh from a
tooth to 10 bad decrypt hmm what's this
you should know this by now this is a
padding Oracle right this is a padding
Oracle staring us in our faces because
it tried to decrypt something so this
wasn't a signature it was in fact and
encryption of the filing so if we if
we're a nice enough to try to guess what
the file and was so this one is called
paper one maybe they have some
unpublished research that we could still
that's called paper too ok so let's grab
this so-called signature and we're going
to see let's just delete this frown I'm
going to hex the code that so we get
back your by doreen
and we're going to change something
we're going to a so we have to count so
like the paper that's one two three four
five letters so the sixth letter we're
going to change that from a1 to a2 which
means we need to change of course the
fifth one because that's the way it
works and we're going to say okay so I
need to change that from a 22 a or
actually from a one doesn't matter but
from a 22 a1 to a2 and now we're going
to pack it back together again so hex
encode this okay so now we have a so
called signature and we're going to go
back up here and going to change from
paper 12 paper to and we're going to
paste or modified signature and we get
access to a new unpublished document
because yeah signing in crypto and stuff
if you want to learn more there's a long
presentation called everything you need
to know about cryptography in one hour
and it's two hours long some people you
might want to follow matcha green and
dealers here do the crypto pals
challenges I'm right now trying to do
them in JavaScript but they're there are
solutions out there we can do you can
find solutions in Java and all kinds of
stuff let's go go to the go look it up
also there's a really good book called
cryptography engineering design
principles and practical applications by
schneider and the solder that's
basically it so thank you for listening
any questions
yes you'll get a microphone just a
second okay with the slides be available
yes I will make the slides available
thank you anybody else i'll be here at
the rest of the day so if you find me
and you there's something you want to
know just grabbed me and asked no
gentleman over here communities
basically you're different platforms any
specific sets of community should be
reverting to when you start and spot
these types of issues i see you at a
list of individual names but certain
communities that that are well known and
respected to be able to follow i'm not
sure maybe you'll probably find some
really good cryptic communities around
universities because a lot of crypto
research is usually academic space
around this german university in in
bottom in Germany they have a lot of
really good cryptography research coming
out the guy who found these sam'l bugs
and also one of these TLS bugs he's he's
also written a new test suite for
protesting TLS and trying to uncover
these kinds of mistakes in TLS
implementations google recently also
released a a tool for testing java based
encryption and actually the guy who
found many of the likely many of the
bugs that i've shown now especially the
pkc as 15 bugs he's called the Bison
baka I think he's involved in that
google project she will find some really
smart people there as well normal
question
nope okay you just adjusted your glasses
that's fine okay thanks a lot enjoy the
rest of the conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>