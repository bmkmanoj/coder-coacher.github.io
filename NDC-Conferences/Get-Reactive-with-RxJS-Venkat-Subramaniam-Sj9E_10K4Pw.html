<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Get Reactive with RxJS -  Venkat Subramaniam | Coder Coacher - Coaching Coders</title><meta content="Get Reactive with RxJS -  Venkat Subramaniam - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Get Reactive with RxJS -  Venkat Subramaniam</b></h2><h5 class="post__date">2017-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Sj9E_10K4Pw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good morning welcome to the
get reactive with rxjs my name is Venkat
Subramanyam I'm going to talk about just
a little bit about reactive programming
in the beginning and then I'll talk a
little X J is does and how we can make
use of some of the things it provides
best time to ask questions or make
comments is when you have it so please
don't hesitate anytime is a great time
so let's get started
well reactive programming has been
gaining quite a bit of interest and
popularity in the recent times so we
begin to wonder you know why another yet
another new programming model well one
of the things I've learned over the past
few decades is we work in a field where
we give a new name for what we already
do and get really excited about it one
more time well this time the things that
we are getting excited about are things
like microservices reactive programming
and things like that
it turns out they're not entirely
actually new at all in fact reactive
programming is something that the
concepts have been around for quite a
long time so in a way if you really
think about it it's more of a REM Phasis
of things we have already done we can
probably relate this to what extreme
programming did for example
well what did XP do XP had really
nothing new and except that probably the
only thing new and XP was REM service on
12 different practices in a similar way
reactive programming emphasizes certain
technical things that we should think
about programming and emphasizing and
how we develop applications so the
question really is you know is it really
new and and the answer is no except for
they do emphasis but what is it really
well if you really think about it things
have changed quite a bit in the past you
know maybe 10 years give or take I
almost am fearful when I think of those
nostalgic days when I used to wake up in
the morning and as my coffee part is
brewing coffee I would turn on the modem
and it would dial and redial and I can
hear the whoosh noise in my ears well
those days are long gone now we carry
with on ourselves multiple devices that
are internet enabled it's unbelievable
how much we are communicating with
applications today and in fact that's
one thing I would say has completely
changed in the last maybe 10 to 15 years
it used to be that companies made
applications for their employees and the
employees using the applications would
then
interact with the customers well when
employees are predominantly using
applications those those are called
captive users when when users are
captive they don't have control over
what the applications do they pretty
much have to use what's given to them
well clearly what's happened in the past
about 10 years is companies have started
you know providing applications for
end-users rather than their employees to
use well end-users of course are not
going to be that kind and captive as
employees do and even if it doesn't
matter what the size of a company is we
can argue that you're probably going to
have a lot more customers than employees
so which means it's an explosion in
terms of how many people end up using
applications the other thing that's
happening is the type of applications
and the interactions these applications
are having with the data and with the
applications themselves the biggest gig
that I personally know I would say is my
son the other day I patted him and
several devices fell of him I don't even
know how many he is carrying around well
we are talking about people using
multiple devices every one of us is
carrying multiple devices you know
people are talking about internet
enabled devices but forget about you
know watches if you will we are talking
about earrings and nose rings and tongue
rings all internet enabled and
constantly communicating with
applications
well that really means that we need a
greater demand we have a greater demand
on applications and how these
applications interact so how do we go
about managing and building these
applications well we can apply some of
the learnings from the last few years to
a maybe a decade and one of them that so
reactive programming really brings
together four different practices into a
single mold and the very first thing it
says is we should really consider using
elastic services to scale well that's
kind of what we have done over the past
several years is we have gone into cloud
computing it doesn't really make sense
for majority of the organizations moving
forward to manage their own IT
infrastructure in terms of systems if
you will
it just is unbelievably not only
expensive but really hard to manage
these systems well today we have learned
that we could easily spin off servers
on the on the cloud very easily without
much effort at all and of course these
servers can be brought down very quickly
can be more service can be brought up
based on the demand the demand could be
you know based on the time the demand
could be based on the load actually and
so one of the things that reactive
programming says is we should really
make use of elastic services as much as
we want to to really provide scale well
the second thing it really emphasizes is
that we should really focus on message
driven systems well I'm going to say
that having a distributed the database
or even having a centralized database
and having distributed transactions is
so 20th century it really makes no sense
to be moving in that direction we should
really think about you know disparate
systems communicating with each other
using messages that's another thing that
it's heavily emphasizing is more of a
message driven systems for communication
well then of course we want
responsiveness
why is responsiveness so important well
in the day we live in we are really
living in a world of instant
gratification the days of where you use
an application you know patiently wait
for it to respond is gone well people go
to applications of the application don't
respond for a few seconds they just
simply leave they go on to use other
applications responsiveness is probably
one of the most important things for
example let's say it's a you know kind
of a quiet Sunday morning you decide to
walk into a store and as soon as you
walk in you realize that the clerk is
busy helping another customer so what do
you do you probably wait for a few
minutes we look on the shelves look on
the floor look on the ceiling and then
you quietly leave why because there was
no response on the other hand let's say
you walk into the store and as soon as
you do the clerk who is busy takes a
pause looks at you makes an eye contact
and says I'll be with you shortly and
goes back to work with the client they
have what do you probably did because of
that you probably waited for you know
several more minutes and why is that
because you felt you are important even
though you know you're not so the point
really is that when there is
responsiveness you normally hang around
when a system is not responsive you
pretty much leave well this is what we
have learned for example with infinite
scroll depending different
remember the day that you got exposed to
infinite scroll this application has
been around sluggish and it'll slow slow
responded like a snap you're like wow
that was really fast what happened and
you scroll down only to realize there's
nothing in the bottom and then before
you could immediately realize that
something filled up in the bottom well
that's pretty nice how responsive this
application is so responsiveness is
extremely critical and reactive
programming says the goal is not to give
all the results to the customers or the
users the goal is to give them enough
for them to process while they are doing
it go back and pull more information and
be responsive well the fourth aspect
that reactive programming greatly
emphasizes is that applications have to
be really resilient
now why is resilience so important well
if application is not responsive
application is really also very poor in
terms of how it fails in an ungraceful
manner you're not going to really be
hanging around with applications so
resilience of applications is extremely
important in other words it says that we
should treat failure as first-class
citizen and program for these failures
as well in a very graceful manner well
that's pretty much what we acted
programming is emphasizing is all these
four things but what does it really mean
to develop applications in a reactive
model I want you to step back and think
about what we've been doing for oh maybe
about twenty years now and we could
argue most of what we've been doing so
you know pretty squarely falls into crud
applications and at some point you begin
to ask the question does everything
simply become crud application after all
and it turns out maybe we're gone a
little overboard with it maybe not
everything is crud applications where we
create data read data update data what
if we can think of applications where
maybe we are the middle agents all we
care about is some data that's flowing
through and we want to process some data
and then send the data along the way
we're not in the business of accessing
data from a data base in the traditional
way maybe was the intermediary just
interested in processing data as it
flows through as it turns out there's a
lot of
occasions that fit into that kind of
model for example let's say you are
interested in processing star beta well
you're not really interested in reading
the data from the database maybe there
is a flow of tickers and prices and you
want to really make decisions along the
way maybe there is a particular ticker
you are interested in maybe a price
range you are interested in and maybe
you want to take an action if it falls
in the range of price you are interested
in otherwise simply let it go through
well that could be a way to think about
how you are being reactive to data that
comes towards you or flows towards you
so I want you to think about a little
bit about data flow computing rather
than thinking about crowd operations
well the concept of data flow has been
around for a very long time this is not
new at all you couldn't possibly have
gone through the 80s without hearing
about data flow computing for example
well the beauty of data flow computing
is when there is available for something
to execute its ready to come execute
your computation so through parallelism
actually existing data flow computing so
you can actually do quite a bit of
computing and data flow that's one of
the concurrent computing and data flow
that's one of the exciting things about
it there's a lot of other things that
fit into this for example what if you
are interested in monitoring tweeds or
other messages and you want to respond
to some of the messages if they are
relevant to maybe your business or line
of work or whatever keywords that you
are looking for or what if I'm
interested in processing weather data
well I could be in a situation where the
weather changes very drastically and I
want to respond to it very quickly there
are applications that are being
developed where you're responding to
weather changes and you want to be able
to respond to it with a very high
throughput well this brings up this idea
of streams of data so in other words
rather than looking at data as this
piece of information you fetch and then
do some work and then update what if
data becomes a stream that flows towards
you and you want to be able to process
the stream of data and take actions and
maybe pass it along as in the stream for
the downstream CIM entities and
computations to take note of it and do
processing that's basically what we are
looking at in terms of how we going to
compute it so this brings up the details
about a programming model well at the
very essence of reactive programming is
this idea of observable well once again
you may notice that observable is not
nothing new at all it's been around for
a very long time well then how is
reactive programming observable
different from the observable model that
we are you know so very familiar and
used to that is probably one while maybe
three clear distinctions between the
traditional observable and what the
reactive programming observable model
provides for us well the very first
thing about the traditional observable
is you have an observable which is the
source of the data and you have of
course the observables which are the
receivers of the data and of course the
source could be sending the data the
receivers could be receiving the data
well the observable model in reactive
programming clearly sets apart two
different channels think about this as a
data channel and an error channel the
data channel would of course have the
data and the error channel would
contains of course the error well this
is one thing we have suffered with for a
very long time how do we really separate
and deal with data compared to error or
exceptions in the in the in the
programming models well we're back in
time what we did is we returned data or
the result when you call the function
well if something went wrong how do you
tell that something went wrong well we
said we could return a negative result
to say that something is wrong and then
we quickly realize maybe that's not a
good idea because some data could be
negative numbers as well and some data
may not be after all numbers it could be
something else
gosh how do we deal with it and then we
said well here's a brilliant idea
we'll return an error as a response to
functions so if there's nothing wrong
you will give you a zero and if
something is wrong maybe we'll give you
a number to say there's an error and not
what about the data itself
well we'll pass in an object to the
function which can populate the object
with the result and send it back to us
very quickly that became really unwieldy
to deal with and then we said well
here's a great idea we'll return a
result when you call functions but
something went wrong we'll throw an
exception at you that was a terrible
idea in itself because exceptions
started disrupting the call stack and
then of course that became a little bit
more expensive hard to really handle
also and then of course it requires a
lot more extra programming effort so
we've been struggling with errors and
how to deal with for a very long time
well the active programming says what if
we have a clearly two different channels
of communication one channel is the data
coming through and the other channel is
for errors so clearly you know what
you're receiving an error or a data that
comes through the second problem is this
idea of exception handling is a terrible
idea
from the point of view of functional
programming for example well it turns
our Ft programming is a nice logical
step from functional programming well in
functional programming we talked about
you know using a function pipeline and
then we talked about lazy evaluation
well reactive programming kind of starts
right there and says what if we take
this pipeline of data coming towards us
and we want to process it well in an
infinitive style of programming you make
function calls if something goes wrong
you blow up the call stack and you
retract well that doesn't quite make
sense in the concept of reactive
functional programming because you don't
disturb the call stack that way you're a
down stream and you want to keep flowing
down and what do you do when there's an
error well you don't go back you
continue to deal with the error like
it's a data and that's exactly what
reactive programming says let's deal
with data and let's deal with errors
like it's data as well and just keep
handling pushing it downstream and
handle it well that's a very first clear
distinction you got a data channel and
you have an error channel well the
second distinction is in when you have
data coming through a data channel the
minute something goes wrong you would
get an error through the error channel
and immediately the data channel would
terminate there will be no more data
coming through the data channel so in
other words it's kind of like a circuit
breaker already built into the
observable if everything is going well
you get a stream of data coming through
if something were to go wrong an error
gets emitted and there
no more data coming through the data
channel and lastly you also have a third
channel which is called a completed
channel this is a clear way for you to
tell your receivers you don't have any
more data and you're not going to send
anything more so they can do the
clean-up operations and know that they
have reached a end point in the data
let's take a look at these examples with
rxjs rxjs well so the concept of
reactive programming has been around for
a while it was actually introduced by
Eric Meyer as part of a solution in a rx
darknet well it's been around in rx
darknet for quite a while
in the in the darkness community well
you know generally one of the things
I've observed is I work on you know
multiple technologies I got my hands and
C C sharp and related technologies have
got my hands in Java and JavaScript as
well but I kind of look at these
different platforms and I noticed one
thing very clearly different across this
the darkness community is kind of
special in that they'll quietly sit down
and take solutions given and they would
get their work done the Java and
JavaScript communities are very
different
the minute you show them a solution they
wouldn't sit there and use it they would
turn around and develop 20,000 same
works around it and celebrate the you
know frameworks they develop well that's
exactly what happened
the quiet rx implementations was around
for a while until the Java folks and the
JavaScript folks discovered this and
they went on to create hundreds of
frameworks and libraries around it if
you look at Java it's so there are so
many solutions available for by
providing reactive solutions in Java
likewise there are a few in JavaScript
as well one of them is rxjs I'm seeing
rxjs becoming gaining popularity a lot
of other tools and libraries and
frameworks are beginning to use rxjs
also for example just one example is if
you're using for example angular 2 well
in angular 2 when you make a request to
the server the HTTP module internally
uses rxjs
to pull the data that is using the Ajax
calls that's not a requirement that you
have to use it but that's a default
implementation
get an angular for example so you're
going to see this in quite a few places
so you will run into reactive solutions
in one of two different ways very
quickly one is you decide to create a
reactive applications all by yourself in
which case you're getting dragged into
reactive programming quite easily
ultimately you may not care about using
reactive solutions directly but the
libraries and the tools and the
frameworks you are using for building
your applications internally begin to
use reactive solutions and you would get
dragged into it fairly quickly as well
so let's take a look at an example of
how we would create an observable in our
X years and how we would use it so what
I have here with me is a little page
which is called the indexed rjs don't
have a whole lot here but I'm referring
to the rxjs that's pretty much the first
thing you see here is I brought in a
reference to our X J's from the CDN
that's all I have
well of course I had a little page here
I'm going to simply say hi and I hit the
save and I'm going to simply refresh
that here and display it as you would
see is that display is going to simply
show that hi so I'm going to make some
changes to the application see it's
response over there I'm going to build a
few little examples and play with it
well what are we going to do here well I
want to clearly see an example of
building a little reactiveness here so
I'm going to start with a little
function call that yeast prime function
well simply put YZ Prime simply tells
you whether a given number is a prime
number or not using the fairly simple
solution it just iterates through T
number see if it's divisible by any
number other than itself and one and
then if it is it says that it's a you
know if it's not a prime number
otherwise it returns a true to say it's
prime but I want to really start
generating prime numbers as a sequence
so what am I going to do to create it
well I'm going to say a primes equals
and I'm going to go to our X and I'm
going to create an observable but I'm
going to call a create function right
there to create the observable well it
follows the model in a off rather than
using a constructor to use a static
method to really create the object so in
this case the create function is going
to really create an observable inverter
and give us the you know handle
to this particular object well of course
I want to use this observable in just a
few minutes but what am I going to do
here with them this observable well I'm
going to receive a subscriber as a
parameter to this particular observable
so in other words these create method
receives a callback and this callback
says when you call me well you're going
to provide me a subscriber and I'm going
to start emitting data to the subscriber
that's the key word to think about
either Emmett so you're going to emit
data as and when you are really
interested in emitting data you're going
to emit data so what am I going to do
here to make that work well first of all
I need a function right here to work
with so I'm going to create that little
function to to work with so what I'm
going to do in this function is I'm
going to say count is equal to zero or
let's go ahead and say index is equal to
zero
and and let's start with the one
actually and then I'm going to say over
here while index is less than let's say
about 10,000 well what am I going to do
here well in this case what I'll do is
I'll first of all say if index is a
prime so is prime of index well if it's
a if it's a prime number then I will
emit the data so I'll go to subscriber
and say next and then I will say send
the index over and then of course I will
go ahead and increment the index right
after that and then I'll continue the
loop after that well so what are we
doing here well notice the call to the
next method so the next actually is a
way for you to push data through the
data stream that I talked about so this
is where you get the subscriber and as
an observable you can start emitting
data by calling this next method and
that opens of the data channel and you
send the data through this data channel
how do we receive this data on the other
side the receiving side well here's an
example of that so I'm going to define a
function call subscribe and this
function subscribe or what this is going
to do is simply say go to the primes and
I'm going to say subscribe to that
particular primes observable and an send
a subscribe
well the minute I subscribe he is going
to send me data through the data Channel
well how do I get the data to the data
Channel
well that's my very first argument that
I provide to the SUBSCRIBE function is
yet another function so I'm going to say
prime over here and as soon as I receive
a prime all I'm going to do is simply
display the prime here on the console so
we can actually see the prime that we
are receiving from this function
repeatedly so let's just go ahead and
try this out here on the console so I'm
going to call the SUBSCRIBE method as
you can see right here and and have it
really execute things for us well it's
helpful to save this function obviously
go ahead please this one here line 15
okay so this is going to be indexing
thank you for the catch absolutely so so
so we are incrementing that and we are
so I make mistakes some integer and some
not but that helped me to know if
anybody is still awake here so that's
good so that's a good feedback so right
there is the index plus plus and of
course that's going to keep incrementing
and sending it if it's a index it's
going to omit it otherwise just
increment the index and keep going all
right let's go ahead and try this out so
what am I going to do call the SUBSCRIBE
method and of course I'm going to say
subscribe oh it's not defined it says of
course it helps to save this function so
I'm going to go ahead and save that and
of course call the SUBSCRIBE function it
still says it's not defined so let's
subscribe so let make sure that I
defined it properly that's a SUBSCRIBE
method and of course it would be helpful
to you know invoke this function as well
so let's go ahead and bring it so scrap
and I'm going to say source is equal to
the function J s that I want to bring in
so let's go ahead and make sure that's
tied in to this particular function all
right so now I'm going to go ahead and
call this particular function and have
it really evaluate it and and then of
course we'll see what it does well
there's a little bit of a syntax error
that I need to work with so let's see
what the problem here is so it's
complaining that get is well it's having
a function with the function J s so it's
complaining couldn't find the function J
s let's see why that's complaining it
functions oh did I call it functions you
are right good good eyes there we go
awesome so now that I've got that
squared out let's go ahead and call
all the SUBSCRIBE method and right there
you can see that it emitted a little
silly little example but nevertheless
shows us the point how this actually
works together so what did we just do in
this case we called upon this to give us
all the prime values as being
implemented correctly but don't worry
about it the factor is that it's
actually pulling in the data and
displaying the values so when I call the
Prime I went to the observable and I
said hey observable start emitting data
I want to subscribe to you and start
emitting data when you get a data send
it to me and I'll decide what to do
about it
well the observable itself said hey
subscriber thanks for subscribing I'm
going to start emitting prime numbers
towards view and it's sending it of
course this could be across systems if
you have two and and you can communicate
through this particular observable as
and when where it may make sense so that
gives you an idea about how to really
subscribe and start receiving data but
but I mentioned that there are a couple
of different channels to work with well
one of them is the so called completed
channel so let's take a look at what
completed really means well notice in
this case when I'm done with their data
I want to tell the receiver I don't have
any more data coming towards you so you
can say subscriber dot complete and you
can send a clear signal saying that I'm
done I'm not going to give you any more
data well just to prove the point here
because I emitted a complete signal the
way the observable is built already is
though the data being emitted to the
data channel but the minute something
comes out of your error channel or the
completed channel the data channel will
close up and there will be no more data
coming through the data channel not that
you want to keep emitting data after the
fact but just to prove the fact if I say
subscribe and I'm going to send a minus
one here just to prove the point now
clearly in this case I'll comment out
the complete and you can see that I
don't have the complete right now but if
I call the SUBSCRIBE in the very end of
this you will notice that it is going to
come in and display that particular data
well did I go to a loop actually in this
case
sorry this should be not subscribe but
subscribe doc next isn't it there we go
I'm slipping at the wheel here so
subscriber dot NYX not subscribed are
next there we go
so I'm going to send that a next command
here to say that I don't have any more
data to send you basically this is going
to be the completed request to say that
I am done with this let's actually
restart this to bring this back end so
pardon me here that's kind of stuck in
there so let's go ahead and kill that
now let's actually forcefully kill it
there we go so in this case of course
I'm going to let's restart it there we
go
so um alright so I want to restart this
little thing and ask it to run through
the SUBSCRIBE let's just fire this up
again so what am I going to do here well
clearly in this case I want to call the
SUBSCRIBE method so there we go and what
does the scribe do well in the very end
of animating all this data we're sending
the subscriber next to minus one to
signal that I have a little you know
next to pass the data on the subscriber
so so in this case let me get this
correct there we go so what I can do
though is I can send a completed so
let's go ahead and say subscriber dart
complete what does that do well it's
going to send a completed signal and as
a result we're not going to get the last
minus one being sent because the data
channel has been closed like I said but
of course on your site what you could do
is it can also receive that to handle
that so let me just put an error right
here we'll come back to the error in
just a few minutes but I'm going to say
in here well how about simply saying
done over here to signal that I don't
have any more data coming through so if
I were to go back and call the SUBSCRIBE
now you can see done being displayed
right here well that's because when the
observable emits a complete signal you
get that signal through your complete
channel and the data channel shuts up at
that point well so we are seeing the
three channels here right in front of us
on the receiving end the first line 25
is the data channel the second line 26
is the error channel and the last line
course is the complete channel and like
I mentioned the data channel will only
receive data as long as nothing has come
out of the error channel or the complete
channel that's really big then into
observable that also shows you how
observable in in reactive programming is
different from the traditional
observable that we are used to well but
on the other hand there's also times
when as a receiver you want to
communicate that you don't care about
some data anymore for example let's say
you go to a particular resource and you
are asking you to emit data let's say a
stock price you are interested let's say
and buying Google stock but you want the
price to be over 700 before you buy it
so you put a little request to say keep
telling me what the price of Google
stock is well then you suddenly see the
price just hit a little bit about 700
and you really really want to buy this
right now well now you're saying wait
I'm going to go do the trading but I
don't want the silly service to be
sending the data anymore I am done with
it I'm going to switch over to doing
some other work so in other words you
want to unsubscribe from as a subscriber
you want to say don't keep anything any
more data I don't need this anymore so
there's got to be a way to communicate
you are intent and why is that because
that can result in better use of
resources both on your side and on the
server service side as well so it gives
you this two-way communication to go
back and forth so what am I going to do
here what I'll do here in this case is
I'm going to rewrite this little example
to provide that behavior so first thing
I'll do here is I'll create a subscriber
right here on the site and the
subscriber I'm going to say this
subscriber is going to be saying I'm a
little function well if you're
programming in C sharp are your
programming in Java
typically you implement interfaces
well JavaScript doesn't have the concept
of interfaces JavaScript is dynamically
typed it's extremely flexible so you
pretty much can create a JSON object
which has a certain you know objects and
properties in it and you are good to go
with it so in this case I create a JSON
object with a function called the next
in it and this function says I'm going
to receive a prime and all I'm going to
do is simply print the prime but in
addition to doing so what I'm going to
do here is I'm going to say well yes the
prime number that I received is greater
than 5,000 I'm gonna say subscriber dart
unsubscribe and I can then say I don't
want this data anymore and I can switch
off getting the data from this point
onwards well clearly in this case let's
comment that out again for a few minutes
we'll come back to that so now that I've
created a subscriber I can say prime dot
subscribe and I'm going to send the
subscriber to that as a parameter an
argument and say here's a subscriber
want to use so rather than providing the
function in place I just gave it a JSON
object which has the next method clearly
you could also provide a JSON object
with the next complete and ever for the
three channels we talked about well
let's go ahead and try this out call the
SUBSCRIBE and in this case of course I'm
going to call the SUBSCRIBE method let's
make sure that I call this correctly so
the SUBSCRIBE method is going to
subscribe with a prime and say I'm going
to subscribe with it and pass a
subscriber to it well but what in the
world is this
prime prime is not a function it's
complaining does anybody see the error
that I did here its Prime's not prime
there we go that's why so let's go ahead
and call this again so in this case of
course I'm going to call the SUBSCRIBE
method and it went through and gave you
all the numbers until it reached 10,000
but notice in this case the minute I
reached 5,000 I want to tell it I don't
want the data anymore and I want to
unsubscribe from it so I can certainly
do that as well and say don't send me
data once it reaches 5,000 I want to
unsubscribe from it
well in this case of course you can see
it went to 5,000 three and it's no
longer going to send me data anymore
because we did unsubscribe that gives a
way for your subscribers to dictate
what's being sent versus what's not
being sent well
brings up the next question you got
observables and you got the observer and
the observer is going to keep emitting
data the observables can see the data
but what about having multiple observers
well sure you can have multiple
observers to the same data source well
if you have multiple observers to the
same data source what's the behavior of
the observable versus the multiple
subscribers are observables how does
that really work well let's think of a
couple of different examples you have a
data source that's emitting data and you
have subscribers subscribing to it but
what are these subscribers actually see
well if you are watching a public event
for example well the public event is
going to be what you are seeing and if
somebody comes along they're going to
see at the particular time the event
that is actually happening so for
example if somebody opens the door and
walks into this room they're going to
see the talk in the middle of what it's
happening I'm not going to stop what I'm
talking about because one person walked
in and say folks sorry I got to start
over from the beginning that's not going
to happen well in other words in this
case of course you are watching what
everybody else is watching and all the
subscribers are watching the same exact
role of events that is happening that is
called an hot observable on the other
hand if you're watching the recording of
this talk and if somebody you know calls
you and says what are you doing well I'm
seeing this talk on YouTube well if they
go to YouTube
chances are they going to start from the
beginning of the talk and watch you
could be in the 15th minute of the talk
but they would be starting at the first
minute and of course by the time you are
done they would be still in the middle
of the talk they are watching unless
they quit in the middle well that's
called a cold observable so a cold
observable is going to be having
multiple different sessions for its
subscribers hot observable manages those
sessions together let's take a look at
an example to see how this actually
works in here well for that purpose what
I'm going to do here is I'm going to
create a slightly different index file
work with so let's take a look at this a
little change I made in this index file
so what I've done in this index file
right now is I've created a two-button
subscriber one and a subscriber to and
of course I only have one method called
subscribe that I'm going to call but the
SUBSCRIBE method is registering
two different you know elements on the
HTML page what I'm going to display the
stuff let's just get this rolling and
then we'll come back and talk more about
it so I need a function called the
SUBSCRIBE so let's keep everything up
here until now but I'm going to create a
subscribe function well this function
takes a display as you would see but
what is this display going to do well
I'm going to say Brian start subscribe
which I don't have yet but we'll come
back to it and if you give me a prime
I'm going to simply say display dark
inner HTML equals and I'm going to
simply display the prime onto it so if
you give me a prime number I'm going to
display it on that particular display
and and show it that's all I'm going to
do but that begs the question what is
primes
well Prime's is equal to our X dot our
observable alike with it before but dot
create well in this case of course I'm
going to take a subscriber and what I'll
do here is I'll say let next prime is
equal to a function and I will also
start in this case with a index value in
the beginning so let's say let index is
equal to 1 but then what I'll do here is
call the next prime right off the back
what are they going to do within the
next prime function I'm going to say if
is prime of index well if it were a
prime number then I would say well
subscriber dot next I'm going to omit
that particular index value just like we
did before but then what I'm going to do
is I'm going to take a little break and
then repeat this so index plus plus and
then I'll say set time out and in this
case I'll call the next draw
time but after a slight delay of 100
milliseconds so in other words what I'm
doing here is when you come in I'm going
to first of all a call this next prime
function the next prime function checks
it for given index is prime it's so it
emits it and then it increases the index
and this time I remember to put it
outside the F and then of course in this
case it takes a break and and repeat
after a little time up well that's a
good start let's see how this is going
to work so I go back here to the
SUBSCRIBE and call this method to
subscribe and of course you can see that
it's it's counting the primes and
displaying it along the way but the
question is what's going to happen if I
click on the subscribe on the second one
right now well before we click on it
let's quickly take a look at what the
code is actually doing when you call
subscribe the right one it's going to
call with the display two as the element
to display into and what is this guy
going to do well this says I'm going to
call subscribe on the observable well
clearly that's only one observable in
this code because primes is the object
we clearly on line number nine so that's
one single observable but we already
have a subscriber now we have a new
subscriber coming in after all these
time units in this case so what's going
to happen
well I click on the subscribe and you
can see that it started from the
beginning well why so the reason is
there is a session being maintained by
this particular observable and the
session is right here in this function
after all remember this is a callback
function so when you go to the exact
same observable and say hey can I
subscribe please it says you're welcome
on board and starts a new session for
you right here and as a result of course
the index start with 1 for your session
so there are two sessions being managed
in this code and that's why you see them
in different times so let's refresh and
try it again so you can see that I'm
already down to 13 and 23 but
Condors you can see the lag of the
second one this is a cold observable
it's a cold observable because it
maintains multiple sessions for each one
of its subscribers there is no concept
of anything being shared between these
two but there are times when you don't
want that there are times when you want
multiple observables to really share the
same session maybe you're in pursuit of
the same data for example if you are
observing the streets and maybe there's
a car that's driving through the
Tollbooth and you trigger a little event
maybe this person did not pay for it and
trying to escape through and you want to
start monitoring this car well clearly
you are interested in the same data at
the same time you don't want a different
set of data at that point so how do you
deal with but before we talk about how
to deal with it I want to talk about one
thing that's pretty darn cool and that
is you have an observable on this end
you got a subscriber here but the beauty
is you can have an intermediate
subscriber who can be subscribing to an
observable but that subscriber can also
become unobservable to watch in
downstream this is called a subject so
what is a subject well for example let's
say the gentleman on the second row
let's say is an observable so he is
emitting data and I might be interested
in the data I can subscribe to him
directly or maybe I'm just having a
little hard time hearing and he here on
the first row could become the subject
right in the middle he could be hearing
what are you saying and then he could
amplify that and say it to me or it
could be a translator for example the
other person could be speaking at
language that I'm not familiar with but
a person here could be translating and
giving me the information so what is the
person in the middle become he becomes a
subject a subject as then here is Ana
subscriber to the original observable
but becomes an observable to me the
subscriber but here comes the charm how
does this actually work
well remember one of the things we
talked about when you have
observable and observable can send me a
completed signal at times but there is
something else that's going on to me as
a subscriber can unsubscribe from
observable well guess what the subject
is going to do now if here's the subject
he is going to subscribe to the
observable but he's going to image the
data to me at some point if he decides
not to emit data anymore
what is he going to do he is going to
send an unsubscribe to the observable
that is upstream and sent me a completed
signal to tell me I won't get any more
data and to tell the original source not
to send any more data so subjects have
some additional responsibilities
subjects not only can transform data
that flows through them subjects can
also wire up this behavior of saying
completed downstream and saying
unsubscribe upstream as well and they
can manage this interaction very nicely
well so the point I'm making is I don't
have to make any change to this
particular code to get an our heart
observable out of it so what I can do
instead is I can go to the very end of
it and I can create a subject and the
subject I'm going to create by calling
sher right here so all I'm going to do
is I'm going to just ask you to create
an intermediary which will subscribe to
the original observable up in the the
call stack and then tell downstream that
I'm going to really give you a shared
session that you can deal with very
nicely so what does this really provide
for us well in this case of course all
I've done is I call the share and if I
click on it you can see the count right
now well past 20 but I click on the
subscribe another time and you can see
that they both are in sync with each
other I didn't have to modify the
original code all I did was I put an
intermediary to say I want this to be a
shared session so the original
observable still is exactly what it
was but right now it has only one
subscriber which is the one that we call
that share the share itself in turn
became an observable and and entertains
to subscribers but those two subscribers
are given a shared session that is
managed by this in familiarity that's
one very powerful concept and reactive
programming is that you have this chain
of responsibilities and you can't have
intermediaries that are very powerful to
carry on this behavior very nicely so we
saw the heart versus the cold observable
and we can use it but I did allude to
errors quite a bit how is this going to
work with errors and how do we deal with
errors typically well to understand that
let's take yet another example here and
we will work with it so let's get rid of
this function for a minute let's get
back here to yet another example but
this time I have a little text box in
here and you can see that text box is
sitting there below that I have a
subscribe but I'm going to really start
doing some work with this particular
text box but to take this to the next
level let's understand what we're going
to do with the SUBSCRIBE method well
notice I'm calling the SUBSCRIBE
function right here so I'll put the
SUBSCRIBE function and the SUBSCRIBE
function it's going to need two things
it's going to need an input equals
document dot get element by ID in this
case the element I'm interested in is
the input element that is up here but
I'm also interested in the display
element so I'm going to say let display
is equal to and I'm going to say
document dot get element by ID but this
is going to be displaced while we are
here let's say input dot placeholder is
equal to type something so that way we
know that we clicked on subscribe so
that's a good start
so let's go back to this little example
and I'm going to click on subscribe'
right here and it says type something so
we are ready to try some little example
but let's take this to the next level we
talked about being reactive and we
talked about talked about data stream
but what can be data stream I gave a
little exactly examples I mentioned that
star
data could be a data stream and so you
register to tickers and symbols and you
got stock data that's changing and
you're monitoring a financial exchange
great Twitter could be a data stream a
Twitter is an awesome example because
you can sign up to Twitter and you can
waste the rest of the day monitoring
what everybody else in the world is
saying not do any useful work that could
be a nice little stream you can
subscribe to weather could be another
data stream but once we get a hang of
stream you then begin to ask
excuse me waters can be a data stream
whilst raelia program radio programs or
data stream somebody talking could be a
data stream time itself is a stream
after all time is endless it keeps on
ticking and so if you want a timer why
can't I use a timer as a data stream
well then you think about this there's a
beautiful language called elm and one of
the things L excuse me Elm is actually
Haskell syntax for most part and a
little bit of F sharp syntax but L
compiles down to JavaScript and elm is
touted as a reactive you I you know
programming language and one thing al
does is in elm all the things like Mouse
movement and keystrokes are all three
active streams and you can imagine if
you want to monitor somebody's mouth
movement you could subscribe it as a
stream so whenever they move the mouse
then you get a notification as a
subscriber and depending on how fast
they move the mouse and depending on how
much coffee they have had they move the
mouse in a very different pace so the
point really is you can start mesh you
know monitoring these events as streams
and that kind of bends the way you think
about it which is exactly what I'm going
to do here but in this case using rxjs
so what can I do in rxjs for that so I'm
going to say get keyboard let's say
observable and I'm going to call a
function called get keyboard observable
well I'm going to start looking at a
keyboard and and as I type stuff on the
keyboard I want to listen to them as an
event
as a stream rather than a traditional
event so for that I'm going to go to say
let get keyboard observable and you know
very well what this function is going to
do it's going to return an observable so
return our X dart observable but wait a
minute a few minutes ago I call the
create method why did I call a create
method because I was the datasource
so I call the create method but now I'm
no longer there is a source the data
source is the operating system it's
going to start emitting keystrokes as I
start typing I want to be the middleman
to take those keystrokes and emit it as
an observable so how do we do that
well that's the beauty of this I can
call a function called from event really
really nicely so I'm going to call from
event from the e input so I'm going to
pass that input as the source over here
and that becomes the import so I'll
change it to source right here and then
of course what event are you interested
in well I'm interested in the key up
event that I'm going to be generating
from that I'm going to receive that well
that's great I'm going to have this
observable given to me but a key event
is a key event but what are they
interest rate from this particular event
I'm interested in every single keystroke
so I'm going to call a map function
right there and I'm going to say get key
as a function that I want to call right
now well that begs the question what in
the world is this get key well get key
is a function and this function takes an
event and it simply returns event key
and returns the key from that particular
event so now we converted a keystroke
into a stream after all an observable
and I'm going to start monitoring that
well what do I do when this happens well
you know very well what I should do now
I've got an observable with me so the
obvious function call is a subscribed
function so I call the subscribe and at
this point I'm going to say given a key
what do we want to do display dot inner
HTML and in this case inner HTML plus
equal to and I'm
going to update the key into it so we
turned this into a little observable and
we subscribe to this observable and we
can start displaying that piece of data
well let's see if that works
actually so let's get back here and do
click on the subscribe function and of
course it says type something and I say
ABC and you can see that whatever I type
here it is displaying right there so
here's the SUBSCRIBE ABCD and you can
see that being displayed right there so
we turn that into a little event through
the observable but my goal was to show
you about error handling how do we
handle the error well to understand how
we can handle the error let's get back
to this little example and play with it
again so I go back over here and I say
well if the first of all I have a key on
my hand so let's say left key equals
event dot let's say key and then I'm
going to return the key given to me so
no difference
just a little refactoring up the code
right there just a little change to it
so ABC again you can see that it works
but I'm going to then say F the in this
case key is equal to the letter F or the
key is equal to the letter F uppercase
then I'm going to fit throw new error in
this case I'm going to say well let us
not go there right that's a bit little
error message the minute it sees the F
it says add don't do that so in this
case of course I'm going to go back and
click on the subscribe and I'm going to
say ABCD F well notice now it doesn't
have anything more coming through
because the minute that is an error
being emitted that data channel shuts up
so that is why in this example notice I
subscribe ABCDEF and sorry no more data
for you so that basically terminated the
data channel but of course I have an
error channel through which I can
receive the error so notice I got error
I'm going to say display dot innerhtml
equals error dark message and I can
display the message that
get back from it so I go ahead and click
on subscribe' ABCDEF well let's not go
there and it doesn't matter what I you
know click anymore or type anymore it's
not going to respond at this point
because error came through the error
channel that data channel shuts up
there's nothing coming through after
that so that is an example of how we can
deal with errors as well very nicely but
I did mention that a beautiful
transformation in shoes from here so a
little circuit breaker concept you saw
but I want to talk about the filter and
the map functions very nicely this is
one of the beautiful characters up here
I'm going to remove that error handling
for a minute let's come back to this
code but the beauty is I can do a dark
filter and I can say given a key tell me
that the key is not equal to the letter
Z and the key is not equal to the under
the letter uppercase Z so no sleeping
allowed here and so I filtered those out
as you can see right here so if I were
to do this then I'm going to say dark
map given a key I want to return key
dark to uppercase so I can convert it to
a uppercase as well so once again let's
go back and try this out click on
subscribe ABC and you can see type Z are
uppercase Z you can see that nothing
happens right there and then I can type
other characters after that so that
essentially is converting to uppercase
but it also filters out the Z so we
don't see that anymore so you can see
how we can do filtering that's another
beauty here is I didn't affect the
source
I am the intermediary and in this case I
said I want to start filtering the data
along the way and I'm also going to
start really doing processing along the
way where I can transform the data and
we can do some really wonderful things
with it that again comes into a very
powerful scenario well the last thing I
want to talk about here is one other
concern which is back pressure well the
reality is
that you are going to have emitter
that's emitting the data the observable
you have observers that are processing
it but the reality though is there are
times when you are maybe not as fast in
processing as the data is being emitted
well what do you do in that case well
you cannot obviously be forced to work
any faster than you can well that's
where the concert of back pressure comes
in so back pressure the key thing to
keep in mind about back pressure is
there's no one right way to do it so you
need to handle it based on the realities
of your project and application there
are a back pressure on back pressure
drop which will just drop the data if
you're too busy or back pressure buffer
it will keep buffering the data when
you're busy and then when you have less
load to process you can process and
empty the buffer well on buffer of
course only makes sense when you have
times of peak load and slow load and you
can vary your processing there are other
solutions like for example the bounds
and throttle which will allow you to
decide how many requests and responses
you want to process and the bound says I
don't want to send any more than a
certain request in a given amount of
time and if there's a response that's
happening right now and I'll let the
time pass and so I send the next request
throttle on the other hand says within a
given time you can only do this much
amount of work and if you've done more
than that then wait until the time
elapses to do the next piece of work you
can decide based on what you're trying
to do what you are interested in
handling so to give you an example of
that if I go back here let's say back in
this example let's go ahead and refresh
this and in this case let's say I'm
going to subscribe but let's say I start
typing really quickly well if you have
noticed me type so far I'm really really
good at typing badly so I'll type and
hit the backspace and type and hit the
backspace and you're like cars all these
back spaces and typing and hitting
backspace that's a waste can we just not
wait until this guy gets stable at
piping well that's exactly what I can
use to balance our product so in this
case I can say the balance time for
example 500 and notice I just threw it
as an intermediary
now what does this do well and then I'm
going to do one more change here I'm
going to remove this filter for a minute
I'm going to go back to this code and
return in this case rather than
returning a key for this event what I
would like to return is the event target
value entirely so I'm going to return
the word itself and then of course I'm
going to turn into uppercase and then
display it well in this case of course
because I put it the pounds here so
notice if I go back here and say ABC as
a word you can see that in this case I
am typing ABC and it of course displays
ABC as a word that comes in through
really nicely so right again ABC well
but notice it waited for me so I make
some mistakes I remove those mistakes I
type again remove this and then enter D
and all that mistakes I made were not
visible because I said just only frantic
let things settle down a little bit
before you send it so you can control
the back pressure and to the point I
made this is just one example there are
several other ways to control back
pressure depending on your need for your
applications you can decide and pick
whichever solution that might be
applicable depending on what you're
trying to do
like for example buffering maybe a
solution under certain contexts and
that's what you want to do if that makes
sense do what you're trying to do so
what we learned so far well what we
learned here is that it's a rebirth of
the traditional observer pattern but
there are differences as well in terms
of having a data channel error channel
and of course the completed Channel and
you have this beautiful chain of
responsibility pattern you got
intermediaries or subjects that can
themselves be the so a recipient of the
data from another observable but turn
around and become observable to
downstream and so you have nice way to
chain things so you can have an
observable design in one way and you can
control the behavior downstream based on
what you're trying to do like I
mentioned this is something we are going
to see quite a bit moving forward almost
this is something we cannot escape in a
way if you really ask me I feel like
there is a rebirth
the paradigm so I kind of remember way
back in time I was watching the
emergence of obtruded programming people
were pretty much programming in
structured programs and procedural style
and they were trying to wrap their heads
around object to the programming and of
course you can see that there were
people making mistakes we were talking
about it arguing about it and then there
was a quietness that ensured after that
and then eventually we started building
crowd applications with it I feel there
is this another time opportunity now for
yet another paradigm shift I'm not going
to say that we're not going to do card
applications anymore would continue do
card applications but I'm going to
challenge if everything we do becomes a
crowd and I doubt it actually is and I
think reactive programming is the next
paradigm shift that we are seeing and I
think we're going to start building
applications very differently in the
next about you know five to ten years
and we are just wrapping overhead around
these kinds of ideas and concepts if you
ask me this is definitely a great time
to be in this area so I hope you'll be
very proactive in looking at this
concept of reactive programming hope
that was useful thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>