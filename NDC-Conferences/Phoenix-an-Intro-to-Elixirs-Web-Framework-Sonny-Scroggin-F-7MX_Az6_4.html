<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Phoenix: an Intro to Elixir's Web Framework - Sonny Scroggin | Coder Coacher - Coaching Coders</title><meta content="Phoenix: an Intro to Elixir's Web Framework - Sonny Scroggin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Phoenix: an Intro to Elixir's Web Framework - Sonny Scroggin</b></h2><h5 class="post__date">2017-02-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/F-7MX_Az6_4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Sonny froggen I am privileged
to be here today to talk to you about
Phoenix it's a project that I've been
involved in over the last almost three
years now
and I it seems to be growing in
popularity many companies are starting
to adopt it within their workplaces
and people are really enjoying giving
some great feedback so again thank you
for being here you can catch me on
github Scroggs on and on twitter and
various places as well
apparently I have beard problems with
the microphone alright so before we go
too far we want to make sure that
everyone kind of understands what we're
going to be talking about today
so Phoenix itself is a web framework it
is developed with the elixir programming
language and elixir is a programming
language that runs on the Erlang
ecosystem so Erlang is both a
programming language but it's also a
runtime so it has a virtual machine that
is really really amazing it's been
around for about 30 years and there's
been a lot of great things that have
been written with it so most of the
world's mobile traffic is actually going
through Erlang so Phoenix if you haven't
seen we have our github is at Phoenix
framework and so essentially Phoenix is
a web services framework you can use it
for building modern web applications you
can also go with kind of standardized
traditional jason api's and things like
that's very very easy to to get up and
running with that kind of stuff but also
has some more advanced features for
building distributed messaging systems
and I think that that's where as the
modern web is taking us
so one thing that is really important to
understand is that Phoenix is not your
application so I know that sometimes
when you're building web applications
and you're using a framework you tend to
build your entire system within the the
reference of that framework itself and I
won't name any names but there are many
of them out there it simply just
provides the building blocks for you to
build an application that has interfaces
to your actual business logic and so
within this talk I'm not going to
actually show too much about how to you
know talk to databases and specifically
like building out modeling and stuff
like that but we'll show how to wire
Phoenix up to your functions that deal
with the database and and different
business logic so moving along here it's
very familiar to anyone who has used
kind of an MVC framework asp.net MVC
Ruby on Rails
Django's Python framework and as I
mentioned we have this kind of real-time
messaging layer called channels and this
is really kind of the exciting part to
me the web is kind of boring for the
most part until until now when we're
actually dealing with persisted
connections and having to build servers
that are actually online and holding a
connection all the time so that
obviously also creates some challenges
with deployments and things like that to
where you can't just take down the
server necessarily and spin one right up
in its place because you'll drop
connections so you have to kind of think
about how you want to build your system
for deployment
now because elixir is a functional
programming language with immutable data
it's really really simple to test your
services you can just simply construct
some data
Piper through some functions and you
have simple functions that you can test
so and one of the other things that
people are really loving about Phoenix
is the fact that because it runs with a
lick sir and Erlang it's very fast and
efficient and one of the reasons why
people pick web frameworks a lot is
because they may give you some
productivity gains Ruby on Rails for
instance is a really popular framework
and people are really productive in it
they get up and running and they can
build entire applications very very
quickly and scaffold out things for
prototypes and things like that
and Phoenix also really allows you to do
that as well but you don't have to
compromise on productivity and
performance so phoenix is not really
alone it's theirs it's a kind of multi
layer system it takes advantage of a few
different libraries to provide all of
its functionality and one of the main
ones is called plug and plug is a simple
kind of abstraction for dealing with
different web servers so right now the
most popular web server in Erlang is
called cowboy and this is the one that
works with plug out of the box it's a
fantastic web server it's really small
code base it's extremely fast and it
allows you to have incredibly high
concurrency where for each request that
comes in it spawns in Erlang process to
deal with that particular request and at
the end it dies and then the supervisor
will replace a new process in its place
and it's really amazing another tool is
ecto and ecto is a library that was
built to kind of give you the ability to
write nice queries for your data and
getting it in and out of the database
and we won't have enough time really to
kind of delve into that but it
definitely deserves its own separate
talk for sure
all right so I want to take a moment to
really kind of explain how plug really
is kind of the center it plays the main
stage really in in phoenix applications
so this is essentially a library that
gives you a specification for building
composable functions that allow you to
basically build a pipeline for your
requests and response so you get a
request that comes in and you
essentially have a data structure that
allows you to build a response very very
easily and so plugs are generally
reusable modules or functions you can
package them up in a an elixir package
put it on the hex website which is for
our publishing packaged packages and
then other people can pull those in and
reuse them and so the plug specification
starts with this plug con data structure
and this is essentially it's at what's
called a struct in elixir very familiar
with in other languages that have
Struck's it's essentially it's in the
lick sir it's a map it's a special kind
of map it just has a key in it called
underscore underscore struct underscore
underscore and it specifies which module
that it belongs to and this module plug
con essentially has a bunch of functions
for dealing with this con structure so
you might want to set a response header
you might want to set the body various
things like that you may need to get
something out of the session and be able
to read read a value up from the session
go to the database grab some stuff and
then you can actually assign variables
and things to this connection and this
is what it looks like it might be pretty
small for all the way in the back but
it's a pretty large larger data
structure but essentially a lot of web
frameworks and
tools generally have like a separate
request and response objects for dealing
with things and with with plug it's
really really simplified into just one
single data structure and this one data
structure is simply piped through the
entire stack of your application and so
it makes it really really simple in
terms of the API and also your functions
don't have you know multiple arguments
and things like that so so the plug
specification continuing there's two
kinds of plugs that you can create one
is just a simple function and the other
is a module plug and so function plugs
are any function that takes and receives
a connection as the first argument and a
set of options which can be any term can
be any any elixir term and it just needs
to return the connection so the if
you're not familiar this syntax down
here is I like a spec and this is just
showing the options inside are the
arguments inside the parenthesis so it
takes the plug con type and the plug
options and then it returns a plug con
type and this here is an example of a
simple JSON header plug so it takes the
connection here and it pipes it through
this put response content type and we're
just saying application JSON and that's
going to set the one of the response or
it's going to set the content type of
header on the response headers to
application JSON the other thing is
module plugs so sometimes you might have
additional functionality that you need
to build a plug properly and so module
plugs allow you to do that very nicely
you just need to define an init one
function and this is what takes the
initial arguments for options for
setting up the the plug and then all you
need to do is return the options now
whether or not you
you know actually modify or transform
those options is up to your earplugs but
you can just essentially return what's
passed into it as well it doesn't matter
and then call to is what's actually
called when calling the the function
itself it receives the connection and
then the options that was returned from
a knit one and here is an example of
adjacent header plug built as a module
very very similar
all that's changes that we've wrapped it
in the module and added the emit so ecto
as I said before it's just a
domain-specific language for writing
queries and interacting with the
databases it has a lot of really
interesting stuff in it that's very
different from other data access tools
and there's been a recent book that's
been written about it it's at 2.0 if you
go on to the plataforma tech blog which
is the company that's responsible for a
lick sir they're also writing ecto as
well so let's talk about how you get
started with Phoenix now essentially
what we have here is we have a what's
called a mix archive and you can install
this archive on your machine and what it
provides you is a nice little mix
Phoenix new task and you can just pass
it the name of your application and it
will go ahead and generate just kind of
a scaffolding skeleton of the project so
there's lots and lots of different files
in here but most of them you can see
there's like test files for testing
things it does all the the router and
and the endpoint and all that kind of
stuff once you do that it'll ask you hey
do you want to fix installed in
dependencies say yes it'll go ahead and
fetch the dependencies you'll notice
here that it's running npm install this
is an optional feature you can flag it
off if you don't want it but many times
when you're building
web applications you also need tooling
for compiling JavaScript and you know
CSS and things like that if you're using
staffs or various tools like that again
that's an optional thing you can turn it
off if you're just building an API for
instance and then just gives us a nice
friendly message here to you know CD
into the app directory run mix ecto
create that comes from the ecto library
just bootstraps the database and we run
mix phoenix cloud server to start the
server if you go to localhost 4000 you
see just a simple welcome page and with
that let's get into some code so what
I'm going to do here is kind of start
building out just a simple user
registration and show you kind of the
the building blocks that you're going to
be using when writing a phoenix-based
web application so to start off just to
show you here this is in the Lib
directory we have all elixir
applications usually have a main kind of
module it's usually the name of the
application you're building in this case
we have NDC and it is a is an
application itself so what that does is
in elixir
when this start function is called it's
actually going to start what's called a
supervisor so a supervisor is a special
process in Erlang that monitors and
supervises other processes and so if one
dies it will actually spawn another one
in its place so you have this really
amazing fault tolerant way of building
applications and you can build trees of
Supervisors that supervise other
supervisors as in the case here so the
children of the supervisor we have two
of them we have the ecto repo or the I'm
sorry the NDC repo in this case this is
our repo
and the repo is the thing that actually
talks to the database so it's in charge
of setting up a connection pool being
able to check in and out connections and
actually does the inserting of data and
things like that the next thing is the
endpoint so the endpoint is something
from Phoenix it's the actual module
that's responsible for starting and
managing the web server so it's the
thing that is the first in line for
receiving the con structure it is
actually a plug itself so there's three
main plugs in Phoenix one is the
endpoint one is the the router that
we'll see in a minute and then the
others are the controllers and so this
particular endpoint is pretty
interesting all it really is doing in
code here is setting up a bunch of
different plugs as a pipeline so all of
these plugs that are in this file will
be hittin on every single request so we
have a plug here for setting up static
assets for you know JavaScript and all
that kind of stuff for in development
mode we have a section here for code
reloading so whenever you save a file it
will automatically recompile that file
so that it's reloaded inside the VM we
have thanks for logging parsing the body
and query print are like query strings
and forms and stuff like that we also
have of course sessions so setting up
cookie stores and then the last thing
here is we plug the router so and the
router as you probably could imagine by
the by the naming it routes things so
this is the basic router that comes kind
of pre-configured when you generate an
application we have down here we have
the scope the scope is starts out with
just let's go
to the root and we have one route in
here and it's a get to the root so HTTP
HTTP verbs that you use here with the
like get post put patch delete etc are
all available for building out routes
and you simply just specify the path
that you want to load it on and some
kind of module that will act as the
handler for requests that match that
route and also these are this other
argument here index this is going to be
the function inside that module that's
going to be responsible for for doing
the action for that so and as we see on
here this is the the page page
controller index action so it's just
rendering out the simple page all right
so the first thing that we want to do in
this case we're registering a user is we
want to get some sort of way for them to
hit the register pass on a bump this up
because it's pretty small and that
didn't seem to bump up the top part all
right so we can see by kind of error
driven development here
what we need to do next so it's saying
hey there's no route for get to slash
register and so all we need to do here
is type in slash register we are going
to create a registration controller and
this one is going to go to the to the
new action so this will be the action
that's responsible for actually
displaying a blank form so that people
can fill it in the next thing that we're
going to need to do is we're going to
need to have an action for posting
our data posting our form and that will
go to the same module but with a create
action okay so if we refresh we'll see
another error so this is now basically
telling us that the module is not
available so simple enough we can go in
and create that module so registration
this is like the hardest word to spell I
get that right yep okay all right so we
create their registration controller
file and now we will create a module so
deaf module NDC registration like folder
okay so with that we created it but now
we'll see what still the same error and
you can see here it's saying hey there's
no one it one function it's undefined or
it's private so if you remember from
when I was talking about plugs a module
plug needs to have a knit one and a call
too well in the case for Phoenix we
actually have what we do here is we have
a special module in all Phoenix
generated projects called web and it's
right here and this whenever you use the
word use in in elixir what it does is
that actually call a special macro in
that module so in the using module the
module that you're saying you want to
use we'll call this macro called dunder
using so and in this case it's a it's a
macro that receives one argument and
it's just an atom and it simply just
uses apply three which takes the current
module and applies the the atom as the
function and then with no arguments
which is the empty list at the as the
third argument there
so in this case when we're saying hey we
want to use this module and it's a
controller this is the function that's
going to be called when we use quote
it's actually going to do this is done
at compile time so it's not at run time
it's at compile time and this actually
injects the functionality that's within
this quote block directly into the
module and as you can see here it's
doing an additional use its using
Phoenix controller and so that will then
open up that use statement and kind of
recursively go through and injecting
functionality all right so so now we
have our controller and we've got the
use statement there so now if we refresh
here now it's telling us hey there's no
new to function so let's set this up so
it takes the con the connection as the
first argument and then it takes some
parameters as the second argument but we
actually won't use those in this
particular function so to get this to
kind of work just to show you here we
can just simply use the text function to
render out something to the screen but
that's not too fun yet so let's actually
do some real so we can use the render
function and we can specify a template
that we want to render here and this
will be called new HTML and get that
we're going to have an error so we also
have a module that you need to specify
which is it's a view module and this
view module is responsible for a couple
of things so if we go into views I'm
just going to create this real quick and
I will explain here we go with that
registration writ again
okay so the view itself is responsible
for rendering templates it's also a
place that you can use as like view
helper functions that are for
presentation annual kind of concerns so
and so as you will see with this all we
need to do is use NBC web and specify
that is a view and now we have a
different error so what's really
interesting about this is that it's
saying hey we could not render a new
HTML for this view please define a
matching clause for render to or define
a template at web templates registration
so the the interesting bit here is that
we could actually go in here and say
render new sorry new HTML and we could
do something like this
and now we have the string hello world
and so now you can see also see that
it's actually wrapped in the layout as
well so okay but that's not what we want
to do we actually want to get rid of
this and actually you know what I'm
going to keep that in there for just one
second because what's interesting that I
want to show you is how how the template
rendering stuff works so I'm going to
check out a previously done up template
here so I'm not to type all this stuff
out okay so I've got a template in here
now for registration new HTML eex eex
stands for embedded elixir it allows us
to interpolate elixir code directly
within HTML and so this is simply just a
it's got some form helpers to help us
create forms and logs and stuff so now
if I if I reload it it's actually still
showing the original stuff and the
reason is is because at compile time it
checks to see first if there is when
we're going to compiling the view it's
it's actually seeing this render clause
for new HTML and it just doesn't bother
checking the file system to see if
there's a template there so if we delete
that and we refresh now it's actually
using the template so we have this
variable that's defined inside this
template called change set and so now
it's squawking at us that's not set so
we need to do that so we'll go into our
controller and we're going to do
something here that is already defined
previously in another module that I've
done beforehand so I have this
registration kind of context module that
is going to be responsible for actually
taking form element our form
attributes and actually saving user into
the database so we create this change
set thing that comes from ecto and we
are now going to send that into the view
so now the form actually can render and
so this essentially allows us to have
those form helpers and it works with
this change set data structure it kind
of keeps track of changes that we've
made on our on our model and allows us
to do validations and all kinds of
really cool stuff so if I submit the
form right now it's going to fail
because the create action doesn't exist
yet so easy enough we can just define
that real quick so create it's going to
take the con and this time it's going to
take we are going to use this so it's
going to take a map and registration and
then it's going to be the params here
will be another map so it's kind of a
nested map here so I also have here we
have this registration module and we've
got a function on it called register
user there we go just takes the params
from the form and we're going to pattern
match on this so this function will
return either an OK tuple with our user
or an error and a change set and this is
kind of idiomatic elixir code here we
always use usually use pattern matching
on everything as you can see here of
pattern matching in the function head as
well
specifying that I want to match on the
data structure that's actually coming
into my function and so with here in the
success case we want to take the
connection and we want to pipe it
through a series of functions so one of
the things that we want to do is we want
to put a flash message
to let our user know that they've you
know signed in or that they've
registered okay and next we want to
actually put something in the session
that actually identifies the user so
we're going to take the user ID and
we're going to stick it in a cookie
under the key of current user ID and
then lastly what we'll do is we'll just
redirect to the home page and we have
these path helpers that are quite handy
so you don't have to hard code you know
path strings in your in your code so
we're just going to redirect to the page
path we pass in the connection so that
it understands the routes and things
that are available we just specify the
index now in the case that we get an
error and a change set back then we are
essentially going to do what we do in
the new function our new action and just
rent re-render the form again with the
new change set as the variable that's
published there all right so let's go
back and a 3-run to the form and I will
register myself
all right
nice thank you
I always do that pick the wrong name to
use alright let's try this again well
okay we registered wonderful okay
so the next thing we actually want to
prove that we actually did register and
that were signed in right so we'll go
ahead and change this welcome to Phoenix
- welcome to the name of all myself in
this case because I'm signed in so what
I'm going to do here is we're going to
create in the web directory it's just a
simple plugs directory and I'm going to
create an off small and this off module
is just going to be a plug so we will
define a module called
in DC off we are going to import plug
com
just so we can have access direct access
to all the functions that are available
in there so we will define our knit one
function it's going to take some options
that we actually don't care about so
we're just going to return those options
directly we have a call function which
is going to receive the con and some
options that we don't care about and
almost there so we are going to get a
user we are going to do that by calling
a function called user from session
passing in the connection and then we're
just going to take the connection and
we're going to pipe it through this
function called a sign or a sign rather
and we're going to assign current user
to the user now if you remember we were
using at symbol variables in the
templates so that's where these assigns
are are coming from so anything that's a
sign so this current user as the assign
inside the template will
come at current user is that if your
track in there so now we need to define
this user from session it's going to
take the connection and we are going to
case on get session so this is a plug
function we are going to say hey give me
the current user ID out of the session
and two things could happen if someone's
reached the site and they're not signed
in this is going to return nil so if
it's nil we're just going to return nil
because we can have that variable just
available and if if we do any kind of if
checks on it or anything like that it
will return true or false e value so if
we get a value back it's going to be
some type of integer and so we can just
say in DC user get user from this int
okay now we need to actually plug this
in so we're we're going to do that is in
the pipeline for the browser we're going
to just plug this in at the end here and
an important thing is is that since we
are using the plug get get session we
have to do that after we have already
searched the session so what's really
cool about plug is it actually allows
you to bypass accessing fields that are
potentially expensive so for instance
reading the body reading cookies those
things can be quite expensive and for
instance if you're using like an API for
instance a JSON API you're probably
going to be sending in a token and
you're not going to be dealing with
cookies so you can bypass reading those
values and actually worrying about them
completely which is nice
alright so let's see all right right so
we need to actually modify the message
now so we will go to the page index
and I'm going to just get rid of the
marketing junk down there I'm going to
duplicate this and we'll say instead of
Phoenix here we will say current current
user name and here it will be guest and
we can just do some ifs logic here so
we'll say if current user do else I need
to get my what my I used to have a nice
event plugins for putting brackets
around things nicely alright so there
there we have it so it's actually
reading the value out of the out of the
the cookie fetching the user from the
database and presenting that to the view
itself so we are logged in and we are
ready to look at the next thing so I'm
going to clean this up it's FD and I am
going to actually I'm just going to
check out the next branch here okay
cool alright so the next thing we're
going to talk about is channels so
channels are essentially a way to route
messages with event by event to
different handlers throughout your
application via this thing called topics
so by default
Phoenix ships with support for
WebSockets and long polling if you need
that if you're still you know serving
browsers that are ancient but so we the
channels basically works around this
WebSocket connection persistent
connection and it has this pub/sub
abstraction that allows different
processes within the Erlang VM to
subscribe to topics and be notified when
when things happen so they're very
similar to controllers except for the
fact that they are bi-directional so
instead of doing request response you
get a connection and you just maintain
that connection via the socket we also
ship with Phoenix CAS which is a
JavaScript client for dealing with
building browser stuff which we'll see
in a moment
so topics are pretty simple you have a
sub or a main topic like rooms and then
you can have a sub topic and they're
just split by colons here and then
channel routing is pretty simple you
have a user socket module and you can
just plug this in here and just say
channel rooms : star so this asterisk is
a wild-card so it says hey anything else
after this is going to be some subtopic
and we can match on it and then finally
we say hey we want to route any of
messages that match this pattern go to
the room channel so the client API is of
course in this case is going to be a
JavaScript and there is a warning there
in case this is es6 javascript makes it
a little bit more friendly to work with
essentially all you have to do is import
the socket module from being brought
from the
we can instantiate a new socket giving
it the path that we want to connect to
and passing in some kind of parameters
like a token that we can use to
authenticate the user we connect on the
socket we create a new channel saying we
want to join the room lobby channel when
we actually join the channel we can
pattern match kind of on the values that
are returned from the server so if we
try to join a channel that we're not
allowed to because we don't have
authorization it'll return back an error
and we can match on that and do
something different so you can also set
up different callbacks for on clothes on
error and cetera you can push messages
to the server very easily just give it
an event so channel dot push give it an
event name as the first argument the
second argument is an object that can be
serialized into JSON and finally we have
message handlers for our event handlers
rather so in the case here we get event
of new message we're going to get that
message and then we can you know do
something with the Dom or whatever all
right so let's write some more code and
so I've only got like 20 minutes so
let's see how much I can get done okay
so
basically what I've done is I've got a
room and message model that we can play
with already pre-built let me just
restart the server because I think needs
to load all the new code there we go
cool okay so here I'm still signed in as
before but I've got this thing here this
link to this rooms and I've got a list
of rooms and I've got this lobby here so
I've joined the lobby but of course
there's no UI that's kind of totally
working here I can send messages and I'm
not on the Wi-Fi so you can't see my my
avatar unfortunately but so this is
partially working but there's a couple
problems when i refresh I don't have
that messed up message that I just wrote
it's not there on the screen so we need
to fix that and we also don't seem to
have our roster list there so let's go
ahead and see how we can fix that stuff
up so in our web directory we have a
channels directory and we have a room
channel that I've created here so just
to go over this code real quick it's a
lot to kind of pipe and explain at the
same time so I wanted to pre-populate
something that currently sort of kind of
works and then we can fix some stuff up
as as an exercise together so when you
create a channel there's essentially two
main functions that you're going to
going to create one is join and join
takes the actual the actual topic and in
this case you can see we're actually
doing some kind of binary concatenation
operation which which works in pattern
matching in this case only when it's
actually on the last bit of it it'll
work
so we pattern match on this binary of
called rooms : and then we say that
anything else after that is going to be
the name of the
room itself there's also a payload that
can be passed in but most of the time
it's just like an empty object so we can
just ignore it for here the socket is
going to be the actual state of this
channel process so every time we want to
update our state we need to essentially
return some value that has that updated
state and this is kind of the way that
airline works with processes it's just
recursing over its own state and
listening for messages so so we have the
basically fetching the room from the
room name and we use a similar function
as we did before with with the plug comm
but this is Phoenix socket and so we say
assign the socket this room with the
value of the room itself and then for
handling new messages this handle in
will work off of when you push a message
from the browser to the server so when
you push it to the server it's going to
hit the call back the handle in call
back and it's going to have some sort of
event type on here and we're saying new
underscore message and we're going to
pattern match the body out of it and we
are going to be passed our socket which
is our state and here we're just using
the assigns key in there to get out the
user and room and we go ahead and we
insert the message and when we get that
back it's going to be a it's going to be
an elixir struct it's going to be a
message struct and so since we want to
simplify what we're actually sending
back to the browser we just run it
through this to map function that I've
created down here which simply just
transforms the message itself and like
the user that's related to it into a
nice usable structure so from there we
actually use this broadcast function
and we say broadcast on the socket the
new message event and the message itself
and this is actually any anyone who's
also signed in to the same channel
anyone who's joined the same channel is
going to get the new message that's
being sent from the user so and then
finally down here we just say that hey
we also want to reply back to to tell
the client that yep we got the message
it was received it's all good
and so the client can know you can build
you is that kind of know that oh this
message should be sent but if in case we
get an error back maybe we can remove it
from the UI or whatnot so if you return
an error here okay so let's get into
solving these other problems so the
first problem is is that when i refresh
this page since I created a message I
should see the history here so what we
need to do for that is in our join
function we want to be able to send a
mess into message of all the history to
the browser once we've joined and in
order to do that we need to actually do
it after the fact after we've actually
joined the channel and so the way to do
that is we can actually send ourself a
message and so it can be any we can name
it anything but we're just I'm just
going to call it after join and the way
this works in Erlang and elixir
obviously by extension is there's a
callback function called handle info and
handle info is going to receive the
message so this is after join and our
our current state which again in this
module is is the Phoenix dot socket
structure and so in here with handle
info we need to the response of this or
the return value needs to be no reply
and socket because we're we're not
actually replying to anything we're
sending a message to ourselves and so
that's where it's going to
hit there okay so like the other one
we're going to copy and paste that from
there because we need the user and the
room and so what we need to do is we
need to get all of the history all the
messages from the room so we can take
the room and we can pipe it into room
dot with messages and what that's going
to return us is a room struct which has
the messages preloaded in there as an
array or a list actually and so what we
can do is we can use map get as I
mentioned before all structs and elixir
are just simply a map so we can use the
map API on structs and so we can just
say hey we want to get the messages key
and then with that we're going to get a
list of messages back and so we can use
the enum module and say enum map and we
want to call to map on it like that
and this is the kind of shorthand
capture syntax for describing a an
anonymous function or a or a function to
call in this case and we're explicitly
saying it is to map with one argument so
the air D of one okay so we have our
messages and now we just need to push
those down to the to the socket and
we're using push here instead of
broadcast because the difference is is
that broadcast sends it to everyone
who's connected and in this case we just
want to send it to the user that just
connected so we're going to say message
history and we need to encode this into
a structure that can actually be encoded
into JSON it can't just be a little take
lists so you say messages messages and
then
we'll essentially work so refresh now we
see our history being populated to the
to the browser which is great but now we
need to fix our roster so Phoenix
actually comes with a really really
interesting and cool thing called
presence and it was it it came out of a
history of receiving many many questions
about how to implement something like
presence where you see a list of users
that are currently online and it came
out of many people asking questions
about how to solve this problem and at
first it seems pretty trivial but after
doing some research and especially
within Phoenix Phoenix and when you're
building elixir and Erlang applications
specifically you're thinking about
building distributed systems you need to
think about how your application is
going to work when you have more than
one computer and more than one computer
is actually connected to each other over
the network so with Phoenix you simply
can spin up a cluster of machines have
them all connect to each other and
anyone can connect via channels to any
one of those machines if you have a load
balancer in front then when one person
sends a message it automatically will
publish that message across the entire
cluster and everyone who is on a channel
on that same channel will now receive
that message and so everything is
completely location transparent it just
works because Erlang so we have Earling
to thank for that okay so we're going to
use presents real quick I'm going to
show you how this works so we are going
to push a new message down the socket
the event is going to be called presents
state and we're just going to use
presents that list
socket and what this does is it says
okay hey I want to I want to go to the
present server that's running and it's
when I say server it's it's not like a
separate machine outside but in Erlang
every process is essentially kind of
like a server or a service so Earling
invented micro services by the way
they're called processes so essentially
what this does is it says hey give me a
list of all the processes that are
joined to this topic that belongs to the
socket so the the socket itself has a
key called topic which matches in this
case rooms corn lobby so it says hey
give me all the processes that are in
there and we can push down the state of
all the people that are that are in
there so and this currently still won't
work because we're not actually tracking
our process so we can use present
subtract we pass in the socket we can
give it some kind of key to key it on
which will just be the user ID and then
we can pass in some metadata that we
want to track along with that so in this
case I've created this function called
user meta and it essentially just
returns a map of the user name and the
avatar image URL which unfortunately is
not seeming to work because I don't have
an init so if we refresh now our roster
is working and if I open up a incognito
window I can go over here and I can
register as Brian hunter and I don't
know as email just left the top line so
make one up all right so he's registered
and when I click room here the lobby you
can see immediately both browsers are
now showing that they're connected Brian
can send me a message it's immediately
over there and bam
so that is channels in a nutshell
there's a lot more to learn about it
there's a lot laxer there's not really a
whole lot more to learn about it it's a
really pretty simple feature it's a
really small API but there's a lot of
interesting things you could build with
it in fact the present stuff in
particular you could you could implement
service discovery very easily with it
and if anyone wants to talk more about
that I definitely would love to chat
about it afterwards
so I've got five more minutes to wrap
some stuff up and then I'd be up for
some questions but if you do want to
learn a little bit more about phoenix
channels and present specifically i gave
a talk last year at NDC oslo on that
subject explicitly so it was a longer
talk that really uncovered all of the
details about presence and how it works
and about the details of distributed
systems as well
okay so just real quick I want to show
you the outside view is pretty cool
because you essentially you can with
channels you can implement a client in
any language you want it could be
another server for all it doesn't really
matter you could have server-to-server
communication over WebSockets or some
other protocol that you want to do
channels is actually the transport is
you can build your own transport and it
doesn't have to be over WebSockets but
it could be over just some straight TCP
kind of thing as well but the cool thing
is is that you have any number of
it's connecting when you need to scale
up you just add a server boom now you
can have browsers connecting as well and
everyone will automatically get all the
messages from one node to the next so it
doesn't matter
all of these are independent and
isolated as well but the inside view is
actually even more interesting so we
have the client on the left and the
server on the on the right hand side of
the line so when a from the JavaScript
side you say socket connect it creates a
process in Erlang process these are not
operating system processes they're very
lightweight green threads if you want to
call it that and they're very
inexpensive very lightweight hardly any
memory creates a process that's
basically the socket process and then
when you want to when you do that it's
going to register itself with the
pub/sub system and then when when you
say channel dot join some channel there
it's going to go through that socket and
the socket is going to spawn a channel
process and that channel process isn't
then going to end up registering itself
with the pub/sub system saying hey this
is the this is my Pig my process ID and
this is the topic that I'm joining and
pub/sub system keeps track of that if
you join another one it does the same
thing spawns a new channel process
registers all that kind of stuff for
each one it does does this so each and
in each individual Channel for every
single user that's on the system is
completely isolated they're all running
concurrently and isolated so crash in
one process doesn't affect any of the
others and you have a very nice robust
system this way so in the case that
another process actually broadcasts a
message out so this green one over here
it just sends a message and broadcasts
it using the pub/sub API that message
goes to the pub subsystem and it says oh
hey these these processes are subscribe
to that topic so I'm going to send them
a message and so it sends a message to
the channel goes through the code that
is going to be executed for that event
the return values end up getting sent
down to the socket layer and then
obviously sink down to the client there
so that is about it we actually have
some really nice guides as well that are
written up there's a lot of kind of
stuff that's changing within Phoenix
right now we're working on 1.3 and a lot
of things are going to change
specifically around the data modeling
stuff we used to actually ship with a
lot of tools to help you generate data
models and stuff and we're actually
going away with that because we don't
want to tie ourselves too tightly with
that that structure but you can check
out the guides for more information and
with that thank you and I think I have
time for like one question yes sir
am I on the Phoenix core team yes yes
presence is a was a part of 1.2 so yeah
I came out with Phoenix 1.2 alright
awesome thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>