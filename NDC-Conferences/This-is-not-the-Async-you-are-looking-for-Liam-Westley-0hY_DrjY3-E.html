<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>This is not the Async you are looking for - Liam Westley | Coder Coacher - Coaching Coders</title><meta content="This is not the Async you are looking for - Liam Westley - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>This is not the Async you are looking for - Liam Westley</b></h2><h5 class="post__date">2016-10-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0hY_DrjY3-E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and so just oh hello there hello big air
are you enjoying the conference more are
you enjoying the conference yeah let's
just
that's better than in English crowd and
it's certainly better than the guys in
Norway D and checking that you're here
for the right talk it's obviously this
is not the acing you are looking for and
that's what we're dealing with so this
kind of came I've given a sink talks
before but this is a kind of I keep
getting asked really similar questions
in people who can't be bothered going to
Stack Overflow and seeing that John
skeet answered it already and who sat
just there so if I get anything wrong he
can correct me or Joe can correct me
who's doing a talk on advanced async in
the next slot so yeah and they keep
asking me questions or doing silly
things and taking a server action but
you're by using async/await incorrectly
so this is where this talk really came
from so Who am I to talk about this
that's my Lego minifig given to me by
bet somewhere be from TechSmith which is
quite cool I ride this thing to work
Brandi it's only about three weeks old
it's already done 400 K so I do about
8,000 ka year to get to work which is
quite nice to be able to eat cheese and
drink beer and eat sweets far too much
and then when I'm mucking about the kids
make me do I get in spoon races and
things like that and a Victorian village
in the middle in size and so normally
what you get is a normal Juhi ID
developer comes up and goes I think we
need to do some multi-threaded
programming and this would be a good use
case what they actually do is they
actually do threaded to programming
multi need that's kind of what they end
up coding and what they actually meant
was multi-threaded programming will look
good on my CV you know CV driven
development is always a fantastic thing
in general a developer who's done
multi-threading especially we don't net
to nought type stuff
they do it once and then they tried
never to do it again because they got
burnt I know I lost I worked on a fixed
price contract for a TV company and I
worked for two weeks for no money in
order to finish my code because I put
multi-threading where it shouldn't be
and had to strip it all back out I
thought it would be really useful but it
turned out it was working fast enough as
it was so why do we want to do
multi-threading in the old days we used
to have these all the time and that's a
Windows 3.1 hourglass or Windows NT 3.51
a glass and and I'm not saying that the
hourglass came up a lot but it came up
enough you could load a different theme
into Windows and have done animated
dinosaurs is your hourglass right no
mucking about and they were really cute
especially on with the bow and so yeah
they actually disappeared with Windows 7
which no one mourn their loss afraid
it's really sad to see them again and
what we want to do in our situation we
don't have the hourglass as much anymore
so I'm assuming you're all creating
applications maybe on the server
maybe in services maybe in UI but you've
got to analyze what your problem really
is and there's two real good use cases
for desiring multi-threading one of them
is you might be io constrained maybe and
whatever it means maybe your CPU
constrained you're doing a lot of work
and wanting to do a lot of calculation
and computation so clearly the prime
example of this is making a cup of tea
right because I'm from England
I make cups of tea and if your i/o bound
there's an example of that boiling the
kettle
you are just sat there waiting for the
kettle to boil now you don't actually
sit there waiting for the kettle to boil
you can go around the kitchen you can
make a sandwich you can get something
else ready you can talk to people you
can often watch TV and wait for it to go
click which is kind of a callback that
tells you it's finished that's normally
after there's a lot of steam under your
cupboard that's kind of gone up the wall
and things like that as well once it has
boiled
of course if you were doing anything
else you become CPU banned as you've got
three or four mugs to put tea bags in
fill the water put the sugar in put the
milk in and then you're really quite
busy you have enough time to chat
someone who's near you but you're
probably not trying to put tea bags in
while making a sandwich with the other
hand because that'd be quite tricky and
because it's one of those circular and
straight things that you never get right
you'll just start spreading your jam
like this on the sandwich so yes so key
point do analyze what you're trying to
do first and think about what you're
trying to do and think about the
resources you're going to need so when
we're talking about IO bound operations
this is where async/await that came in
in c-sharp v is really good because this
is one of its prime design goals was i/o
bound type operations it's when you are
waiting for something to happen it might
be a network call you may be writing to
a database you may be fiddling around
with files something like that and the
key point is you can do something useful
in the mean time right that's a really
important concept we could keep our UI
responsive in an application we could
process partial results we might have
put requests out for 200 files and we're
going to convert them into from one
format to another and we can start
converting them before we've got all 100
on the system or we could be issuing new
requests the first file comes in it
needs a thumbnail we can send off a
message to make a thumbnail from this
file because we make thumbnails for
these types of files things like that so
it would be more productive so one of
the key ones and the easiest one to show
was the idea of a windows forms
application or a WPF application and
when it locks the UI up so we're going
to just upload a tiniest little
application in the world into vst's
moving up and I used to be vb6
programmer and I lived my life making
great forms with great buttons on time
you know and yeah so this is a very
simple form it just counts cards
mm all it does is count from 1 to 50 to
update a label on the form to show you
what count card it's on currently puts
it delaying because otherwise it do it
way too fast and in the meantime while
it's running
you could also eat something or you
could drink something you know and we
can resize the form because it's you
know two windows form of course and we
go and count those cards and I don't see
anything I can't click the buttons
anymore on the form doesn't move mm oh
now it moved and it updated but only
with the last value and we've got all
the things we clicked on happening at
the end so it's keyed of all these
requests but it was so busy it didn't do
anything so if you were in the old days
of VB you would have shipped a do event
a form repaint right in the middle of
that code to force it to do it all but
it's ok because we now have a much
better way of doing it we can actually
await things happening so I'm going to
await the delay were updating the card
count so we're saying we're going to do
the same count that we did before but
every time we do a delay we're going to
and now other things to happen while we
wait for that delay to happen so imagine
that's a network call or a database call
or something else that's not opened so
now when I count the cards I can still
write do that and I can still make my
form thing you can have shared you can
access variables between them which was
really hard in forms to marshal threads
and background threads and try and get
data between them because it's shared
state ensured States quite a pain in
multi-threading of course you want to
make sure in the multi-threaded world
you do have to think a bit about what is
allowed to happen while you're doing
this awaiting save you press the button
repeatedly like that you don't really
want to do that so that's were although
you get a quick game you do have to
think about what the consequences of ah
allowing things to happen in the
meantime
and in order to do all that all we did
was put the keyword I will make that
bigger
that's way too small is the keyword
ating and to start ball method magic
magic fairy dust and didn't await inside
and that was enough for the compiler to
create a state engine around my method
that would remember what was happening
in between linked up a callback do loads
of boilerplate code that you would want
to write and make your life a lot easier
and make you look really smart as you
demoing that to a product manager and
everything works in a way they always
used to be quite a pain so that's a
simple async await you do have to check
if you are only I over and so this is a
juggling machine that they made in the
Czech Republic
and that money just to get five balls
being juggled at the same time it's
quite impressive
probably it gets blocked at the point
where it's juggling about five yeah it
was i/o bounded that we was waiting for
the first when it was only juggling two
is waiting for the balls to come back
and he had enough time to add a third
ball they had enough time to add a
fourth ball and a fifth and then it
probably about five it's gonna struggle
because now the balls are landing at the
same time it would be throwing them and
it can't really juggle everything at the
same time anymore and this is the kind
of thing you'd get in real life so one
of our developers was doing a migration
of data so we're taking data from a
database old sequel server we're pushing
it into a revenge stream in the event
store and he tested it all out on local
DB's or works shoved it on the live DB
in production and one of our machines
fell over he basically decided to push
in 100 tasks because he botched the job
just to make sure it wasn't a complete
in a single job bashed in 200 tasks and
ended when all on all 100 of them and
the question I asked was how many CPUs
are in that server that you pushed that
to I don't know and he goes doesn't it
throttle for you automatically and know
how many CPUs you have and just do the
sensible thing and I goes no it does
what you told it which was do all these
hundred tasks
wait for them all to finish and consume
so much CPU it took every other service
out on that box so this is not a good
thing so this is where you come to a few
handy patterns unbelievably this is a
white paper from 2012 that's Steven hey
bro you need to google for a document
called tap docx
and I still have to keep pointing people
at it and say please read this because
this is really good and gives you a load
of patterns that you will really like
and so you can have redundancy this is a
very simple when any type scenario where
you can say hey I'm going for five five
share prices services get me one of them
as soon as I get one I'm happy and I'll
just use that and forget about the rest
that kind of thing so that's the easy
kind of one interleaving is where you
can do things like I've got a
long-running process and once it's
finished I could do a little bit of work
and I'll put that in between but keep a
load of jobs going in the meantime and
limit what the long stuff is but
throttling is by far the one that I see
wanting to be used most and so we'll
have a demo of that and these are you've
got to consider again now we're in the
Iowa even though we've considered i/o
versus CPU and tried to balance what
we're trying to achieve we also need to
work out which pattern would be suitable
for our usage in this case so as an
example I used to work at a start-up
that encoded mp3 files regarding a core
processor if you encoded eight mp3 files
all at the same time of ffmpeg in the
background and they're all on different
threads and use all eight then at some
point you sequel server decides to stop
responding and you can't actually write
any success that you might have I
managed to write a file out from the mp3
encoding so that's where we throttled it
back to seven and we did that not with
async away but by having services that
run as Windows services that could only
do one thread at a time and that's
rolled it back but we could have
multiple windows services which gives
you by the way a very cheap way of doing
multi-threading in the old style so
looking at those patterns we can go to
another sample piece of code
it's another classic piece of design
I'll tell you know do you do too but
fortunately for you I managed to put a
graphic on it so it's got an image see
lovely image and but it still is a grey
box and stuff so this is basically
coming from that world of mp3 encoding
so there's a band in Sheffield who have
tracks on bank amps so I decided what if
we downloaded the OGG file the flat file
the AAC the mp3 and we just copied the
files so I wanted something asynchronous
that I could demo at a conference where
I wasn't relying on the network being
available because that's the problem
with them eating a lot of people use it
with web services as a demo and
unfortunately not all conference Wi-Fi
czar equal and not every conference can
allow my 3G little dongles to work so I
decided on files so we have a very
simple interface it's got a source
directory which is here so it's going to
take files from this folder over here
and it's going to put them into a
temporary folder which is the default
Windows temporary folder for my user so
if we go and run it up I'm gonna have a
look in that folder just to show you
what's in there so we just have a load
of files we've got mp3 files we've got
flack clearly the reason I kind of did
this is because the flat files are
bigger and take longer to coffee than
the mp3s in the AAC so you can see how
the files copy much faster than one or
the other even when it's on an SSD it
takes time to copy bits around so the
simple way of doing it I will copy this
code sample straight in and then we'll
have a look at it
you get to the button all click you can
see that I do make some live coding on
server-side nowadays so there we are and
I did do the code because I tested it to
make sure it worked so let's just paste
it in to make sure so what we got yeah
it's not run it in debug mode let's show
you the code first on full screen
beautiful screen Oh shift alt enter
there we are
so all we're doing is getting a list of
all the file names to copy so we're
going to go off we're going to get a
list of all the files there in a folder
and we're doing it where we actually
iterate through all the subfolders as
well we're then going to do a copy file
async so this is quite important if you
use the standard copy file we'll get no
benefit of this we do have to do things
like use async methods using an async
method means we don't just copy a file
we actually do streams so we copy async
bytes in streams so it's not quite as
easy as just file copy we have to go in
process of stream but that's not a bad
thing that's kind of what you'd expect
and then we just doing a weight on this
and we do the really important when all
copy the tasks and then play the first
file we get now there is a temp folder
here that we can look at and we can see
all these files come in so when I do the
clinic we should see these files start
to come in there we are in they come as
little temp files and then they finally
get their proper file names coming in
you can see how the OGG files take
slightly longer and flack because there
bigger files and they eventually gets
through and plays the music your mileage
may vary on whether you like an indie
guitar bank in Sheffield pretty good I'm
a typical Indian kid so yeah so we have
a load of files copied so that was
really nice because we just said hey
here's a load of stuff to do wait till
they're all finished and it went off and
did them all it did them all as fast as
it could and it did it asynchronously
while it was doing it I can probably
move the form around a bit maybe yes so
I can still move the form around I still
had a bit of responsiveness not great I
didn't put much pauses in there but it
didn't go completely dead while it was
doing it that's fine so we've got some
of the lovely benefits of async enos but
that's the most basic thing that's the
hey let's do everything in the world
which is what we can do and I talked
about throttling and this is the much
more interesting one this is where I was
saying to that guy at work what you
should have done was do throttling
here's the white paper let's go and
write it and make sure we have that in a
way we can reuse and it's relatively
easy to do so anyone who's not used to
async I'm hoping some people have seen
anything before because I literally ran
over what when all did really is and you
get a group of tasks we can put them
into these Combinator functions when or
when any when all is the process every
task going and the when any is I'm going
to give you a load of work when any of
them's finished come back to me so that
was when I said we could be looking for
a sure price or a weather or a
coordinate GPS coordinate lookup and you
don't care probably the first ones good
enough you just went to multiple
services just to make sure you had
redundancy but the other thing we can
use when any four is when we finish
doing one we can then do something else
we could do a bit of processing but one
of the things we could do is we can
actually throttle how much work we're
doing at any one time so we can actually
say
our list of copies should only ever have
4 min at any one time so we can say hey
I'm going to put 4 things into this list
and I'm gonna wait for one of them to
get processed so first of all we fill
our little array with the first 4 copy
files that we're going to have our list
and then we're going to say if we've
still got stuff to do
we're gonna go around we're gonna if we
find we're gonna wait for any of them to
finish and we get back the task that's
finished we say so have you finished we
can get you out of that list of tasks
that we're doing and if we've still got
things to do I can add a new one into
that list so I had 4 1 finished I now
have 3 I remove it I put another one in
and then I run it again and keep going
until I eventually get no tasks left
they're really good beers you might say
ah but what if when any runs and all of
them are finished well you just get the
first one back out and if you then
called it again you get the next one out
that had finished possibly in order I'm
not sure how deterministic it is on it
and some back doesn't really matter
because you didn't care enough because
you went any anyway so who could watch
what order they finished in but you
eventually drain the queue of work so
this little bit of boilerplate normally
if you've got really intensive stuff you
might have concurrent things being maybe
the level of your CPUs maybe it's about
two times the CPU because maybe it's
mostly i/o but it's using 5% of CPU but
of course 5% of CPU over that hundred
tasks that my dev put in is more than a
hundred percent that's why the server
didn't like it so by doing this you
could easily rack it back to 10 20
whatever it was scale it depending on
the dev system a staging system a live
system and if we do this we can see it
in action
so if I get that little window that
shows me the files I'm copying and when
we do this we get four files at a time
so it does four files as soon as there's
a temp file finish disappears another
temp file appears and it gradually just
keeps going through and probably my form
is more responsive look responsive
enough it does that silly thing in
Windows where it minimizes everything if
you're doing it around and let's see if
it thank you so yeah so that's
throttling and that's a really simple
pattern that's in that white paper by
Stephen tab so I guarantee they've you
haven't read that white paper by Stephen
town and you use async/await then you
should go off and read that white paper
by Stephen time it's only about 12 pages
of your life it's less time than you
spent on Pokemon yesterday and your code
will be much better for it so and that's
just a really quick example of how
async/await can be made much better and
much more suitable for production
systems I did get asked by a developer
but surely they should have just given
us that in the library and I'm glad that
what we have now is a sensible framework
which does not overload every method
does not have every variation you may
want but can give you in these 10 lines
of code you can easily get it down to
quite a simple structure I'm sure if I
didn't do for reach and did lambdas and
a bit fancier stuff it'd be less code on
the screen and there's someone anyone do
f-sharp because they'd be going you
don't even need it it's two lines it's a
filter yeah and
and but you know that's just F sharp
really good at doing pipelines it has to
be said so what are the gotchas that I
think exists in the async/await world
well one of them is please please please
always return a task of some type from
your async methods right it's really
rude to not return anything and just
return void and if you return void which
basically is only in there for things
like UI handlers on windows forms and if
they hadn't had to deal with that they'd
have never allowed it to be put in the
system in the first place
and what you give by returning this task
is you allow someone calling you to work
out what your status to work out if you
had exceptions all sorts of things that
are handy and useful can be done and if
you haven't done a sink away and I kind
of assume who has done async/await in
here oh good you all know what tasks T
is tasks T means that it will return
whatever time you have effectively so a
method that would have returned int you
would convert into a type of task int
and then when you do things like when
any it can return you back one value
which is int and it does all the work
for you to kind of give you the generic
value and you can get the task if you
want so it's really cool how they've
matched and had a templated this stuff
you also get cancellation in an async
await now this is something that existed
in the TPL anyway it's really cool thing
you create a cancellation token you hand
it to anything that's part of what you
would consider a process that exists as
kind of a bounded context or transaction
and if something goes wrong one of you
can go hey cancel this and immediately
it'll start canceling throughout the
whole system for anyone listening to
that cancellation token and handling it
properly now the interesting one was
when I first showed someone cancellation
they put a cancellation token into the
first async method didn't hand it to any
of the calls underneath and then said it
doesn't cancel anything underneath well
you haven't told it to said but it
should magically know how to kill all my
work my
underneath and I said does it magically
know which files to remove which
database transactions to rollback all
that kind of thing because the only guy
who really knows that it's the person
who's coding it that's the only person
who can properly guess what should be
rolled back with a cancellation so I
think cancellation tokens are really
good it's a really good pattern for
cancelling multiple things all over the
place and use throughout the TPL and
we'll see it later in data flow yeah got
the Australian pronounciation I will say
data flow occasionally and so and they
are really useful you do have to handle
them they do throw exceptions and we
have some people don't like exceptions
even though they're a useful thing to
have in their system so cancellation
tokens are really cool as well you just
they're not magic though they do have to
be dealt with and exceptions async
method kind of don't throw exceptions
like you think they do so we'll do an
example of that as well
because that's a bit of a nightmare the
other thing is and someone actually
tweeted me and said can you tell
developers not to use the word async at
the end of their racing methods um I
don't know whether he was trolling me so
usually believe you shouldn't put a sink
at the end of async methods one of the
things you shouldn't do is call the
method async and don't have the async
modifier on it because that's a really
bad idea
right which is why we had a problem with
exceptions in a piece of open source
code
someone submitted a load of mocks and
didn't put the async keyword in but left
the async at the end of a method because
they were auto-generated and and that
caused a bit of a nightmare in the
testing so I think first we'll look at
cancellation because I think
cancellation is quite cool and there are
some Star Wars sound effects randomly
put through this presentation based on
the title of the presentation and that
was good look you're gonna need it
which quite often in the async world is
how you feel at first so we want the
ability to do cancellation no something
tricky
we are so
we have the ability to do cancellation
and this is in the when a first wind so
the time when you want this is in that
case where I'm going to say hey I'm
going to happily take whatever the first
result is but if you do that and you are
going to work like that what you're then
saying is what you're saying is that
when I cancel I really ought to be
rolling something back as well there's
no way that I should just cancel
something so I'm copying files clearly
if I'm going to copy files I really
don't want to have the situation that
compiles I don't want the situation
where I cancel the file copies because
I've got the first version I want but
leave all the remaining partially filled
files on the file system that's a bad
idea
so what we need to do in that case all
is we've added an extra parameter called
cancellation token into our copy files
async and one of the things it does is
it spots if it gets a operation
cancelled exception and if it does it
will delete the temporary file it's been
copying at the time and that's it that's
the ability for us to cancel all
operations so I don't have to go around
every task because this is the nightmare
you've got a hundred file copies you've
handed them all over you can't put a
cancel through do i generate through
every file copy telling it to stop and
the answer is no you handed them all the
same token and you can cancel them all
like that so that's why cancellation
token so much nicer and all we're doing
is sending these copy files with one
single token and all we do is create a
cancellation token so the source that's
going to cancel all these and give the
token in from that to all long methods
so hopefully when any first wins we
should be able to see the files come in
so it copied a few mm-hmm I think that's
mean I think vobis support of my laptop
whoops um but basically it managed to
copy that one file it needed and then
has deleted all the temp files I'll just
show you that again because that was an
error that didn't really matter that was
just a audio support format not being
supported so yeah so we get that one
file and we've cancelled everything down
and that can be really important because
some of these things some of these
things cost money so when you're going
out to services and you're asking for
information and you're saying hey we
need this information if you don't
cancel them down you'll be charged for
that word yes yep interestingly if I run
that enough that's exactly what happens
because the mp3 format file or no the
WMA and the AAC files are so close to
the same file size that about one in ten
times you will get both files and
there's virtually nothing you can do
about that
so so a good catch that did that does
happen if I run the demo often enough
but I know I can imagine someone getting
really upset about it and saying but
this is just unusable we can't possibly
have this happen and you're kind of
going well what you're saying is we've
copied everything bar if it had one byte
less we would have been ok with it but
now it has two bytes we really get upset
so and again this is like that button on
that original form which of you clicked
multiple times gives you random results
you have to be aware that things can
happen you can get two completed things
even though you really only wanted one
so probably you want to play the first
thing in that
or maybe you have a cleanup if you
wanted will clean up anything that seems
to be extraneous in that folder so those
kind of considerations have to be done
if you're going to do multiple things at
the same time you have to cope with the
fact that multiple things get done at
the same time it's one of those things
and it sounds obvious and so let's go
because I want it to be cool
obviously I've written something in
dotnet core which is always a brave
thing to do
and I did to be to the other side I
battled it for about an hour before
someone said you didn't do dotnet fetch
of course it wouldn't work it's a random
bit of syntax that I didn't know about
and so what we've got is a very simple
console.writeline so what we're going to
deal with is how you get exceptions in
the async world and this is what caught
someone out in the writer open source
project that you in Cooper my boss at
hurdle has created and someone did a
submit and they put in a load of tests
and the tests were marks so they just
threw exceptions in order to say hey
we're not implemented and it never got
to the unit test we really wanted it to
get - which was a when all because it
couldn't get to it because all these
exceptions got thrown immediately and
never made it to the loop that was going
to do the when all the bit of code that
was responsible for that so we were
struggling in and we'd spent about half
a day trying to work out why on earth
these tasks seem to get executed ahead
of time and weren't captured by the way
nor and then we realized no one had put
the async modifier on the method they
did call the async and there was a
moment where it's you're the guys meant
to know about async how come you didn't
know that I guess well if you do put the
word async at the end of your method
name I will assume it can be awaited
and it's async type modifier is on it so
let's have a look all we're gonna do is
trivially add one number to another
number
unless it's do something and then we
always return 42 because that's
obviously the ultimate answer that you
can ever have and so it's really boring
bit of code
so we'll just run it dotnet run compiles
and runs it but it was already compiled
so it's okay so we'd say yeah that's a
knowledge thing can we get 42 can anyone
read that or is it tiny fine okay
go with that so yeah so this has you'd
expect so you can start putting
exceptions in so you go right so if I
did have an exception in my console main
method that's the entry method for the
console app what would we expect to
happen because it's dotnet core so just
so you know oops
what did I do wrong
I didn't compile did it these compile
where's the rest yeah there's me fat
fingers on the keyboard
bet you I didn't save it properly either
that's better
there you are so that's an exception
coming out of your console which is kind
of thing you expect you know we've got
an exception it's in Maine so that's
fine that's exactly how I'd expect an
exception to work so that's fine so what
if we threw an exception we've got do
something here that's not asynchronous
so let's see what happens there that's a
simple thing and what we get to is we're
trying to do something asynchronous but
yeah we got an exception will not be
async for you two didn't complete we
didn't get any further either we didn't
carry on doing the non eight the
asynchronous functions either because we
just stopped dead and we got an
exception thrown it's fine we would have
handled that so what we're gonna do is
in the async method so really important
this is an async method not just because
it's got a sink at the end but it has
the async modifier on I cannot emphasize
that too much until you've seen a
seasoned architect coder X c-sharp MVP
swearing at a machine for a day just
because of this you'll realize how
painful it was so this has got an
exception being thrown in a sink nothing
right nothing came out right so that's
the expected behavior for an async
method it should not be throwing
exceptions as an exception to thank it's
well it is the design behavior so how it
works let's put it that way
so it says it will be async but it never
got to the point where it actually was I
think now this is where if you start
doing things like well what I could do
remember I said you should return tasks
from methods because I've actually
returned a task I can actually and I
have it a reference to it I can actually
go and see if there was an exception
when I run it so now I can go write
whatever an exception when I run that
and the answer is yes I have a stack
trace
so I actually know you there was an
exception when I was running that piece
of code and I can see it didn't throw an
exception like I'd kind of expect in the
same way it was a system aggregate
exception because with the TPL you're
doing multiple things at once and if you
get exceptions you kind of want to roll
them into a big bag and hand them back
going hey there's a lot of stuff that
didn't work at this point and that's the
key bit because if we actually go back
one if we don't actually
then it went all or weight all in this
case so we're waiting for everything to
be finished then we do get an exception
so this is word those tasks went or wait
all and actually do throw real
exceptions for you to catch like you'd
expect so that's how you can you really
are meant it's when you've got to a
point where this I would get a exception
makes sense to hand back to you because
you are at the point where you want to
know all the errors that would have
happened in your async methods the
interesting bit is and the final bit I
will throw in is that I can actually
make my test some ideas an async method
and if I do that and do a quick run so
all I did was put the async modifier on
and change the method name because we
should do I've now buried that exception
again it's disappeared again so you've
got to be really careful with what
you're doing with exceptions if you're
going to wait stuff really check the
tasks coming back and check things that
are handed back and make sure that
you're getting the right the thing that
you expected yes you can yes so for the
people who you obviously won't hear that
on the video helpful comment from John
skeet there and the suggestion there was
you often in methods you would do pre
checks on the variables coming into the
method in certain states that would
cause fast failure it's what I would
call it where you know you're not going
to be able to run anything so this is a
tactic where you actually do have a sink
a method with async at the end which
actually doesn't have an async modifier
so that you immediately do a load of
checks for preconditions on parameters
are correct all the state of the systems
correct that he could do the work and
then underneath that it actually does
the call to an async method that way you
get a very early exception fast failure
instead of burying them all to the end
and then you suddenly find out in an
aggregate world that you've got a
failure so that's a different pattern
that you can implement which is quite a
nice one but does have an async method
which feels like it isn't acing there's
always one exception yeah so so we've
covered io bound and I'm probably going
to run out of time to cover the full
data flow but we also have CPU bound so
there is a very easy method async/await
is the easy way of trying to get IO
bound asynchronous in synchronous
operation that kind of multi-threaded
although it's really a single thread and
it's kind of a fancy do events in my
head and but it's more than that but
then but yes so how would you do true
CPU multi-threading in an easy way that
your life is very easy to do this well
one of the things that was out even
before async/await
was TPL data flow or data flow
and and it's a it was available as a
NuGet package because it's available as
a NuGet package no one knows about it
because it's not built into the
framework and if it doesn't exist in the
actual framework it's kind of hidden
away in something you have to download
and I doubt in 2011 everyone was keen on
new get in the same way they're really
keen on it now and you're all keen on
new get aren't you you never have any
problems and so so this is now built
into the dotnet core libraries I
actually genuinely was trying a dotnet
core version of what we're gonna see I
was trying to find the package that
dataflow would be in and it wasn't there
because it's there all the time in the
dotnet core library because it isn't the
big thing actually so this is kind of an
actor based pattern
it's an impress actor base pattern if
you have all liens or ICO you can spread
it across servers but this is kind of an
in explicitly in process you can
explicitly say how many threads you're
meant to be processing at anyone using
at any one time to do work it builds in
queueing of inputs and outputs say we
can send a load of jobs out like this
and it will queue them automatically
doing the throttling for you so you
don't have to worry about that kind of
throttling pattern types it situation
and it supports all the things like task
cancellations and things like that what
you should search for is ppl dataflow GX
which appears to be written by Stephen
TAC again yes
and that's still worth reading to see
how it works and what the initial goals
of that that was and now this the actor
patent are we're going to big debt the
maniac Japan but 1973 was the first
white papers on the actor patent I was
for at that point you know frightening
and this is created by physicists who
had really big systems and wanted to
work out how to use the weather let's
say they were trying to work out how the
weather worked not how a nuclear bomb
exploded the weather for weather and but
it Maps really well on to our multi-core
architectures we have now and they and
especially distributed as well but it's
boroughs multi-core in process
and one of the biggest things you're
ever gonna have I mean multi-threading
is shirred state you have things that
you should on thread thread storage and
all sorts of nasty things to hack around
the fact that you've got multiple
threads or you locking variables that
you then unlock when you're finished
with them and things like that and that
causes real bottlenecks so this isn't a
good thing so they came up with the idea
of this active model so instead of your
program being a kind of really direct
sequence of states that built on top of
what was done before what was done
before and they could access everything
that ever happened you send messages
between little actors and actors it's
like a little black box you send some
stuff to it it processes it internally
doesn't access anything another little
block would access maybe it writes to a
database which is kind of shirred state
but you know at some point you have to
save something somewhere maybe every now
and then in a database if you want to
keep it around which means don't use
Mongo and and eventually it spits out
another message into another bit that
you can handle it so it's like joining
little Lego blocks together and as soon
as you don't share a global stay and you
don't have this whole state model you're
testing is easier
unbelievably all your testing becomes
much easier everything's more
predictable and everything is easier to
scale so we avoid all that shared state
we're just doing inputs and outputs into
these little blocks we don't have lock
statements we've got a thread state and
we only transmit things by messages and
you can't broadcast a message to
everyone because there's no every one
because that would be shared state have
a list of who everyone is
so that would be a bad move as well and
all this ends up with the guys in the
TPM adding to the TPL library they start
to flow library so we have targets and
propagators and we can do filtering and
connect blocks together so you kind of
get it's almost like going back to a
software version over like little
breadboard with circuits and you can
join all the wires together it's really
cool so what I'm going to show you is
the basic really basic one of the action
block and show how easy it
could be to add multi-threading into
your VB or your amp and into your app
really easily I made some really good
stuff in vb6 towards the end all these
projects are available on github and
will be I'll give you the github address
at the end and also there's full
one-hour videos of just TPL data flow
and there's just the patterns and
practices and they're available and you
know NDC's Vimeo sites so you can have a
look at the presentation get my stats up
and make it look more popular than it
really is yeah so yeah so all we're
gonna do here is if anyone's heard of
people over here you heard that BBC have
something called iPlayer which allows
you to do video on demand ABC you've got
their own system and someone did a talk
on it about how they've implemented it
bvz implemented it fairly simply and
it's all based on flash and they haven't
we done DRM which means that if you paid
your TV license you may may feel
justified in downloading a lot of series
of the clangers or Doctor Who or
whatever it happens to be and they're
really handy for creating an md5
checksum because it takes quite a bit of
time to do an md5 checksum so we have a
CPU intensive operation it's kind of my
own intensive because you've got to read
huge files off the file system but the
real work is the md5 calculation because
you have to read every byte to get to
the end just in order to work out what
the md5 is so that's what we're basing
our data set on we've gone from music
files and we're now into this concept of
of video files that were going to do an
md5 check on so let's do one without
data flow that would be a better one so
this is a console app you'll be glad to
know that my design skills have been
thrown away
and it's in process folder I know you
just paste that whole lot that's it
so what we have in here is a very simple
thing something that can write an md5
file to the file system that's really
dull something that can calculate an md5
which is in the is it this security
library's something like some librarian
dotnet can do it let me just say
cryptography library so that's the word
I was looking for cryptography because
nothing is better than md5 for yes
don't even start me on that these
passwords just went out with md5 hashes
all over them and it's really easy to
reverse them is it Disney just when
screwed up one of the sites has just
done it really big-time and so all we're
gonna do is process every file in a
folder and we're going to get the file
path and then we're gonna print out what
the md5 for that file path is so if I
run that you end up with a console app
that just goes through clangers one file
does it want this is not a synchronous
so there's no multi-threading in this
we're just doing a simple thing of I'm
gonna create the md5 for every file in
this directory so so that's you know it
does its job but clearly we could have
made this multi-threaded and we really
want to do it to be multi-threaded so
let's see what the TPL dataflow can give
us I'm gonna just do one thing and cut a
line out so don't look close your eyes
it's like a football with 40 results
look away now from this because I'm got
two code snippets because I'm too lazy
so what we're gonna do is we had that
piece of work that went through a folder
and it went through the files and it
carried the md5 so what we've done is
we've moved the bit that was in here
we've moved out to its own method
display md5 from file on console we've
moved it out and because of that we can
now create this new thing from the dart
flow library called action block and we
hand it eight
during which is the file path and it
will call that method with that file
path and do exactly the same thing we
did before and puts it on the console
what we actually do though is we get the
files from the folder and we post them
into that block so we're not iterating
through every file this finishes really
fast because the only way I said these
blocks have their internal queue so they
can take data just stuff it in them and
will automatically queue them all up for
you so you would post all this so if we
want to make sure everything's got done
we say hey we've completed all our work
don't accept any more messages into that
block and then I'm going to wait for it
to finish so we do all that work we've
added about 10 lines of code and we're
still only doing kind of one at a time
it was faster you see how this was much
faster
that's nothing to do with data flow
that's called NTFS file caching alright
just a warning that's what really made
the difference at the start there's 16
gig of ram in this machine and NTFS
grabs about 3 gigabit to cache every
file it can of existence so but what we
can do now we've got this action block
and this structure of doing tasks as
messages we can actually configure the
action block and we can say please use
for threads when you're processing these
files that's it all we had to do was say
to this action block use 4 threads go
ahead use 4 threads I didn't have to
think about thread pools I didn't get
new threads I didn't create them I
didn't have to think about where they
came from how we would reuse them all
that kind of thing and bang it's an
outing form at a time so I've now got a
400% increase in my productivity of
creating md5 from BBC iplayer downloads
and it's a really quick win because
there was very little refactoring to do
we took that console the kind of work
that was being done into a method shove
that into an action block and then told
the action block go ahead make this
multi-threaded
how many people are using the dataflow
library how many people have never heard
of it yeah how many people wish they'd
heard of it yeah you see yeah bit odd
isn't it and so this is what it is you
post stuff into it it gets queued it
does work and you can put the word four
on the top and it will do it in four you
know that's indicating four CPUs what
are the other things you have is
transform block so I'm going to rush a
bit through this because we're getting
near the end and but seriously there's a
great presentation on in DC is pretty
well we called it because it was done in
Oslo so have a look at that and look
through the code on github but this is
where you put in a file path and then
the outputs of file path and the md5
information for that file path this is
where you can isolate this bit is doing
the real work and then this bit is doing
a bit of UI work so the real work that
cpu-intensive we want to go across for
threads the thing that writes to a
console doesn't need to be
multi-threaded will will punt that into
a single thread so this is where you
kind of try and work out where the bits
that are bottlenecks will split those up
from the bits that aren't bottlenecks
don't try and use multiple threads to do
something like writing to a console
because it's not required and you can do
really fancy stuff so one of the things
we can do is we can take we can have
something called transform any block and
that takes many things in pumps many
things out more importantly you can I
could have left by the way a transform
block with four threads or you can split
it out and fan-out like this if you want
it to be more explicit but we can
actually start putting filters on these
blocks so you can just say hey every
time you get a message run this bit of
code and if this returns true then send
that connect this message to the next
block so it says hey I'm getting
messages I'm going to hand them over to
here and transform them and then send
them on to something and we can make
that that if it's a file I go off and
create md5 if it's a folder
directory we go back into here and get
the files again this is recursive
programming multi-threaded made easy
right
seriously much easier than trying to do
it by hand and then we go and link all
those transformed blocks can feed back
into the action block that sends
everything to a console so to give you a
theory feel for what that code looks
like very quickly because I claimed it
was really easy and it's really naughty
to say it's really easy and I'm not
going to show you the code bad of me by
the way I find it really is quite
important if you're going to do
something fancy and data foo is too
broad the diagram of how everything
joins up and don't try and code it
because I think that's quite a hard way
to start it so we have folder contents
block this is the first thing in that
diagram that was on the left and we say
we're going to link the output of this
to the folder contents block every time
we find it's a folder a not file so
anything else down here there if we get
a folder contents block we link that to
a create md5 block if we find a file so
we're wiring them all together and
that's the wiring just very simple link
to where it's going to go to and a
predicate that returns true or false and
that way we can have meshes and joins
and send things out really nicely and
that's it that's enough to make it
recursive if you're unlucky you've
managed to get one of those special
folders in NTFS that links to itself and
you'll never end but you know hopefully
it's not one of those and they shouldn't
be they're really evil should not be
allowed but it's ok now because you
won't fail quickly on that because we've
now got rid of max path so we'll just
carry on forever
whereas we used to crash really fast on
those kind of folders and so just as a
summary of what you get with dataflow
dataflow is you
action bloc word just there's something
but doesn't pass the message on you get
these transform blocks that take in a
message just something to it changes its
shape maybe and spits it back out
buffers that just butter up a load of
messages so that you can just sync them
all out into one place and then fan them
out we can do batches of inputs so we
know we're only ever going to start
processing when we get five things so
that we can actually schedule batches of
work we can broadcast to or loads of
blocks at the end so that's really handy
do you say I'm gonna I finished creating
this M this file I finished encoding it
I'm gonna send it to an orthogonal
responsibility which is a logger that
just logs that we actually encoded
something I'm going to record into
sequel that we encoded it over here and
I'm going to move the file on to this
place which is a dispatch area where we
can actually start thinking about
selling this file on a music download
site so that's how you can send off
multiple things at once
and obviously the orthogonal things like
logging to a file are less important so
that they can be on a lower priority and
less threads so so general concurrency
issues which we get is shared state
that's all we have concurrent
collections which is really good because
you can access them from multiple
threads and I would say be careful with
Singleton's there's a reason singleton
is the pattern that most people know the
most and is the anti pattern that most
people know the most and it's evil and
it can be nice it's really hard to
distinguish the two and it's a fine line
and happens quite a lot beware of
locking conditions anyone had sequel
deadlocks where someone's got translated
you get the same stuff in multi-threaded
code if you're not careful this is why
it's really handy to have wrappers like
the data flow and async and weight data
flow forces you to not lock things and
sure state by doing that you avoid these
kind of things there are useful NuGet
packages such as poly if anyone's used
it a policy engine that's really good
for doing retries and backing off so if
you do get a lock you can back off and
then come back in later and compensating
actions you have not got the ability to
just go rollback
hopefully you don't want to use ms dtc
for distributed transactions across
multiple servers please don't and it
will stop working when you go to a
modern version of sequel server because
if we doesn't like that for all its
read-only replica stuff it hates
multiple transactions distributed
transactions so you need to think about
what it means for you to fail and what
you would do if you did fail and it's
there anything you can compensate or do
you just send a message to your DevOps
email address for that team and say I'll
tell them to sort the mess out that's
just happened you know which is actually
a valid thing to do is human beings are
much better at resolving in
consistencies than your best guess at
the time that you couldn't work out what
necessarily went wrong but we've coded
for it because you can't code for
everything and the other thing is it's
important to understand how your code is
actually running
is it really multi-threaded or is there
just a load of CPU sat at the side
washing this one guy bust his backside
off getting quite hot because he starts
getting quite hot because you really
don't want to get to the point where
your server kind of does that all right
but the mean currently is that's
JavaScript well no but I couldn't
possibly say that I'm using this in
there I've seen code like when people do
mocks and what they've done is mock
everything out and there's nothing real
ever being tested anymore the we're
using threads but actually everything's
on one thread and no one's really
realized it's also reasonably common so
yes if you want to find out get all the
source code for the actor patterns and
data flow and for the patterns and
practices that are available on github
comm slash Wesley L you can also search
for Vimeo ND c liam wesley and if you do
that you will find full one-hour
presentations on the actor's life for me
and also a sync c-sharp 5 noir patters
for real-world use I didn't load it
I didn't misspell the word patterns so
whatever you do don't search for
patterns because you won't find it
it's patters which does sound like an
Aussie cricketer yeah pan is just window
crease
and but there you are that's a terrible
accent tell you know and I'm gonna have
to handle questions offline because I've
really gone over by about three minutes
but I'm Welton for anyone to come up
with ask questions and I hope you
enjoyed that and it's useful and Joe's
going to be doing which room are you in
Joe room one will be advanced a sink
topics which we well</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>