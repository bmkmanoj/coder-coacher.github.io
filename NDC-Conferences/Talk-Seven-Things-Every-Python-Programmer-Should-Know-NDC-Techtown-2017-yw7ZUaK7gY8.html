<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Talk: Seven Things Every Python Programmer Should Know - NDC Techtown 2017 | Coder Coacher - Coaching Coders</title><meta content="Talk: Seven Things Every Python Programmer Should Know - NDC Techtown 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Talk: Seven Things Every Python Programmer Should Know - NDC Techtown 2017</b></h2><h5 class="post__date">2017-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yw7ZUaK7gY8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay welcome everybody this is my second
talk of this conference so I'm already
exhausted this as I said this is very
intensive presentation and I have like
90 slides so there is no way we're gonna
get through all of this so instead of
seven things every programmer should
know this is really seven categories of
things that everyone should know and I
guarantee that even if I only get
through three categories you'll have all
learned more than seven things so maybe
we have to cheat a little so those of
you who came to my talk earlier today
will have heard me talk about the
exponential growth in programming as a
as something people do and that is no
more more true than for Python at the
moment look at the growth of Python from
this blog post from Stack Overflow
earlier this year it I mean it literally
is exponential it's huge and it's
outpacing almost everything else so
Python is hugely popular it's used in so
many different domains so data science
building software that's written in C++
configuring stuff in the cloud building
websites Python is used for all kinds of
different domains which i think is
what's behind this growth and this
growth is just incredible it's gone up
by a factor of two in five years in fact
use the the function on the right of the
screen to figure out how many million
Python developers there are in any given
year this is 20 percent annual growth
back in 2012 there were three million
Python developers estimated to being old
and already there are more than seven
million what this exponential growth
means is that most Python developers
have relatively little experience just
because the influx of new people is so
high and in any situation where you have
a exponential growth the newcomers tend
to rapidly outnumber the oldsters like
me programming in Python since 1999 so
because of that this talk is unashamedly
focused on what I consider to be pretty
basic for
the mental things that every Python
programmer should know okay because most
people just don't have that much
experience when I go to tech conferences
I'm always surprised at the incredible
sophisticated things people are
presenting and sometimes the mismatch
between that and the skills that people
have already managed to build so this is
basic straightforward stuff so seven
things number one know when code is
executed you might think this is simple
you might think Cody's executed when
it's called but it's more complicated
than that so here's some code I didn't
write this this is part of the Apache
Kafka binding for Python written by
people who really know how to code
Apache Kafka is a rare serious piece of
software so which code is executed when
we import this module everything you can
see on this screen with a yellow
background is executed when we import
this module there's a compiler directive
at the top that changes the behavior of
the language there's a whole load of
imports they're all executed when this
module is imported there's a global
attribute called log being created and a
method call being made to initialize the
attribute and the module is imported
there's a class definition class
definition is something that happens in
run at runtime in Python those of you
worked in other languages like C++
classes are a static thing they don't
even exist at runtime we have some class
attributes being created these are like
static attributes if you're used to C++
static class attributes these are being
created when the module is imported and
the method definition of init function
is being executed the body of the method
is not executed of course but it is
passed but the definition that DEF
statement is executed and as we go
through this pretty substantial piece of
Python code I've highlighted all the
bits in yellow which are executed when
the module is imported all the method
definitions executed
it's lots and lots of method definitions
in this file there's a decorator here a
property decorator that is also executed
does some work to wrap up that function
topics in a thing called a descriptor
that's out happening when we import the
module for the first time lots of lots
and lots of method definition here all
executed some more here
did you see the obvious bugs in this
code as it was flying by in the hello
bits probably not but maybe some of the
experience Python programmers will have
spotted them there are of course two
types of Python developers those who
spot the bugs and those who did so where
are they let's zoom back up here they
are there are three of them right here
bear in mind this is the Apache Kafka
binding and it's probably in production
in hundreds of important places can you
see them now so those have you done a
bit of Python probably understand what's
going on here and it's potentially very
serious because these lines in yellow
are executed only once when the module
is first imported these empty lists are
constructed only once they constructed
exactly once when the module is first
imported and lists the square brackets
are mutable data structures and so any
modifications to that list will persist
across calls to the same function okay
so you've made your function have some
persistent state beyond the life of each
function call so this really innocuous
looking thing where this default
argument of a list is actually
potentially very dangerous let's
demonstrate that with a simpler example
this is my very simple version of send
request etics some payload objects and
the actual payloads it's printed prints
out are going to include a first item
which is the number of items in the
payload list including the into
itself so let's see how this works if I
send three items I get a list with four
items in it and the foot the initial
four there is the total length of the
list first straightforward little
function this if I pass two things in I
get the result I would expect a list
with a total of three items including
the count in the first item if I send a
name list in it still works I get a list
with one item containing a count of one
so you might think that calling it with
the empty list is equivalent to what we
get in the default case let's see so
well passing the empty list in works
multiple times if we rely on the default
argument though it still appears to work
but the next time we call this we've
carried over some states from the
previous invocation of the function and
on and on non and this list will only
ever grow each time we call the function
so this is definitely something you need
to know about Python programming is that
when you are dealing with default empty
collections you really don't want to be
using a multiple collection in case that
state is carried over because that
collection is only initialized once per
run of your whole program how do we deal
with this well we could use an immutable
collection the parentheses here are a
empty tuple tuples are immutable so
we've made ourselves immune to that
particular problem and this version of
the function has much better behavior we
now don't suffer from the problem of
accumulating state across invocations of
the function this particular solution of
using an immutable tuple I hardly ever
see it and I read that people is
inappropriate because now it looks like
you have to send a tuple into the
function rather than a list so it's not
very popular even that works
much more popular and better is to use a
sentinel value non and then detect
whether the default value Sentinel has
been relied upon and if it is then
create an empty list within the function
you can see here and doing payloads will
be payloads if Palos is not known
otherwise create a new list and of
course that will happen afresh on every
invocation of that function so there's
no way for us to carry state across
calls to the same function so that's a
that's the much more widespread solution
to this problem and something you should
know about as you can see on the right
this works as expected now when we rely
on the default you might see a shortcut
for this I don't see this so often these
days and I wouldn't recommend writing
the code this way but it may be
something you need to know how to read
you can see here I'm using payloads
equals payload or the empty list and
this relies a quirk of the way the
logical operators work in Python it
reads quite nicely in English but it is
relying on a kind of oddity of Python
which we will return to later but this
has the same behavior okay number two
well in that previous version we relied
on a sentinel object known in order to
flag up the use of or the reliance on
the default argument so in this section
I'm going to expand on the use of
Sentinel objects like none and give you
some alternatives it's very important
techniques here so on the Left you don't
have to read all this code you just have
to understand what it does we have a
function called batched which will take
any iterable series and collect it up
into batch sizes that we give it so let
me give you an example so you can see
how that works will import batched well
I'll make a list of numbers there's the
even numbers up to 20
using a range so that's our input data
and I'm going to pass that input data to
my batch function with a batch size of
three and we get a list of Lists as the
result with a batch size of three but of
course because my input data isn't a
multiple of three long we have a partial
batch at the end okay so you'll notice
that the definition on the left has a
padding argument which is defaulted to
normal so let's try to do batching with
padding so now I'd like to pad any
partial batches with zero because I
don't like the fact that all of my
batches are not the same length so when
we run this you see that the final group
there has the two zeroes padding it so
it has a length of the three now I'd
like to pad it with nan instead this is
a reasonable thing to do what happens
when I pad with no it doesn't work why
can't I pad with nan because I've used
known as the sentinel value to detect
whether the default argument is in play
so now I'm doing something that in item
one I recommended you do and now we've
fallen flat on our face it doesn't work
so what we need is something like nan
that isn't none nan is just a singleton
object in Python as there is only ever
one instance of nan in the whole program
so we can play the same trick we can
make another object of which there is
only ever one in the same program and
it's very very easy to do if you look at
the top left on the definition I'm now
creating an object called unset I've put
it in capitals because it's a constant
I'm just gonna create an object that
object doesn't have to have any
particular type I only care that it's a
distinct object that nobody else has and
I'm gonna call it unset okay now in my
definition of the code near the bottom
you can see where I say if padding is
not known three lines up from the bottom
I cannot change that I can change my
default argument first so as padding
defaults to unset and now I can say if
padding is not unset and nobody else
really knows about this unset' variable
or how to get a hold of it
so no one there's no legitimate reason
to want to actually pass and set into
this function as the padding object so
now because I'm not using non with the
new version of the function okay some
numbers again do the batching and now I
can do padding with none and I get
padding with one so sometimes you'll see
people just creating these objects of
type object we don't really care about
the details of that object at all we
just want a unique object in the program
quite often that's done a global scope
out in the with no indent in the module
so that's a useful technique to know if
you need a default but you need
something that's completely out of the
domain of the values you would normally
use it also means you can give your
default a nice name rather than having
it called non so unset fits in this case
there are other cases where other names
might fit okay a very important thing
about Python listen no has scopes and
namespaces relate these ideas often get
confused in people's minds and they use
these terms interchangeably but they
have very specific meaning yeah I only
ever taught Python 3 James yeah - stream
so this is the Zen of Python who here's
a Python programmer ok who's familiar
with the Zen of Python ok everyone who's
a Python programmer you can get the Zen
of Python in Python just by typing
import this it's very nice to be working
in a language that comes with built in
poetry I'm not going to read the whole
language the whole poem to you I want to
highlight the last one there which is
that namespaces are one honking great
idea let's do more of those let's get to
grips with what namespaces are and how
that relates to scope so a namespace in
Python is a collection that binds the
names of objects to the actual objects
themselves whereas the scope is the
region of the program which a particular
name binding applies ok so it's a region
of the source code now I often say that
everything in Python is an object it's
almost which is true it's almost true
that everything in Python is a
dictionary as well almost everything in
Python is a dictionary so namespaces in
Python are also dictionaries behind the
scenes so on the left you'll see me
typing some code and on the right you'll
see the actual namespace it comes with a
bunch of built-in stuff by default but
if I do x equals 42 what that actually
does in Python is create an entry in the
namespace dictionary X mapping to 42
some things we do in Python don't modify
the keys they only modify the values
there are lots of ways of manipulating
the namespace here I'm importing a
function or class into the namespace
here I'm defining a function that puts a
function into the namespace mapping the
name of the function to the actual code
of the function I define a class that
adds another entry in the namespace
mapping the name of the class to the
code of the class I can remove things
from the namespace with del
I can even dig around in Python using
some introspection and dig out the
actual namespace object as a dictionary
and manipulate it directly so this is
really what when you do assignment this
is what Python is really doing behind
the scenes is it's directly manipulating
the dictionary so namespaces and the
dictionaries that they're implemented as
are everywhere in Python hard to avoid
so when is the namespace created in
Python well it's created every time you
import a module that module has its own
namespace that's called the global
namespace in Python
every time we execute a function a name
base is created that is the local
namespace to that function every time we
define a class or run a class definition
a namespace is created for the class and
every time we instantiate a class by
creating an object a namespace is
created for the instance so notice that
the class namespace and the instance
namespace are distinct things and this
leads to some confusion and some
idiosyncratic behavior in Python so lots
of people when they're teaching
namespaces show them as this kind of
nested arrangement of namespaces the
local namespace to a function the global
namespace to a module and a built-in
namespace which contains built-in types
and functions things like list and tuple
and string and I've been guilty of
present nested namespace namespaces in
this way but I think it leads to some
confusion because people see the nesting
of the namespaces here and they conflate
that they confuse that with the
indentation of the code that you can see
on the right hand side here and these
are quite different things so in the
code on the right I create a clove a
global variable I create a class
I have a class attribute and then I
define a method where I try to print
those things with a local variable in it
which I try to print out when we run
this although it looks like it should
just work we are met with a surprise and
the surprise is that the class attribute
can't be located
it looks quite reasonable that these
three print statements one of them can
find the global variable while outside
the one in blue can find the local
variable inside the function but the red
one fails in this kind of intermediate
space what's going on there or to
understand this we need to look at how
scopes work and how name lookup works in
these different dictionaries is
different namespace dictionaries and the
way it works in Python is that the
namespaces are essentially chained
together by two special attributes one
is called is the module attribute in
Python by the way when we have these
underscore underscore module underscore
underscore that would double the length
of this presentation if I had to say
that every time so we say dunder which
is short for double underscore so that
is dunder module and dunder built-ins
right so you need to you're smiling
because I sound stupid but when you hang
out only with other Python programmers
it's just okay so dunder module then the
built-ins and the lookup mechanism
follows the dunder module references to
get through nested namespace the problem
is is that classes on on this lookup day
proto so you can see here at the bottom
in blue we have a local method it has a
dunder module attribute which the lookup
will follow but it will follow it to the
global namespace by passing the class
namespace which is why the lookup of
that class attribute fails if you want
to get into the class namespace the
bottom center in red there then you need
to explicitly find something that is on
the lookup
and navigate back down to it so to fix
our example here is the original example
which failed to fix this we need to find
something that is on the in the global
namespace which in this case is my class
the class is two declared in the module
so to get this to work we need to put my
class dot my class attribute in there
now you might think this is a design
flaw in the language and I wouldn't
disagree with you but that's just how it
is and you need to know about it it's
unlikely ever to change so it's
important to understand the ele gb
lookup rule local enclosing which I
haven't talked about global and
built-ins the most important thing about
how you spell le GB is that there is no
C in it for class okay so if you want to
find something that's in a class you
have to find something that is at one of
these levels and then navigate back down
to the class okay number four no
trade-offs for number types this is one
of my favorite topics I work for many
years in areas with lots of numerical
computing and I kind of have this view
of choosing the right number type in any
system where the answer is actually
important which is that you you really
need to know what you're doing and it's
tradition at this point for the speaker
to say well you should just go and read
that document what every computer
scientist should know about
floating-point arithmetic the problem is
nobody ever does very few people I've
met have actually read it and fewer of
really deeply understood it and even
fewer have really deeply understood what
the implications of it are when we're
actually writing code so I'm not going
to recommend that you read that I'm just
going to show you some practical
examples and explain some differences so
the built-in number types in Python are
int which is an unlimited precision
signed integer in Python 3 so very
in Python 3 your integers will not
overflow you won't hit any problems
until your 16 gigabyte memory is full of
an integer you can do some really crazy
math with that we have a float and
pythons float is really is is exactly
the same thing as AC double alright
that's actually how it's implemented so
pythons viewer float is whatever your C
compilers opinion on double is and we
have complex which is a pair of float we
also have some two other number types in
the standard library we have decimal and
we have fractions for representing
rational numbers and these I rarely see
these things used particularly there are
cases where people use decimal I very
rarely see fraction used in practice so
I'm sure everybody here who has ever
done any math with a computer is
familiar with the failure modes of float
and people get very upset about this
kind of thing the fact we can't even do
very simple operations that even a
seven-year-old could probably do with a
computer and get the right answer and we
throw up our hands there are numbers of
broken computers are hopeless and of
course the reason this is happening is
that float numbers are inherently binary
they are base two and we cannot
represent either 0.8 or 0.7 as a base to
fraction in finite precision you can see
the bit patterns of these two numbers
here you can see the recurring pattern
and imagine how that needs to carry on
to infinity you need in order for us to
represent these numbers so what people
do is they go to stack overflow and they
get some advice I didn't put it in here
for a fear of embarrassing the person
who wrote the answer who wrote it but
the advice is goes something like this
is well if you have problems with floats
you should
just used decimal because decimal avoids
all these problems yay decimal and it
appears that we can do things with
decimal sometimes even with numbers that
we can't nicely representing decimals
are here I'm subtracting 3/3 from one
which is zero right you might be
surprised that that works in decimal but
it does but we've been lucky you all I
need to do is put two extra parentheses
in this expression to force the order of
operation to be slightly different and
it stops working and in fact decimal is
really no better than float in this
respect it's just a different set of
trade-offs oh goodness
numbers are broken and people have this
idea that decimal is somehow some
magical number type that works in a
completely different way from float and
it doesn't float is a floating-point
representation
well decimal is also a floating-point
representation float is I Triple E 754
decimal is also I Triple E 754 but base
10 the I Triple E 754 ammeter you can
plug it your number type so decimals are
included the main difference between
these two things is that one is base two
and one is based in one of them is
built-in and one of them is in the
standard library the float is almost
certainly hardware-accelerated if you
have a floating-point unit on whatever
processor you are using decimal will
never be hardware accelerated even if
you have decimal hardware like you would
have an IBM power CPU and float is very
fast and decimal it's about two to three
times slower than float so decimal isn't
the way out of many areas problems so
let's look at a computational geometry
problem I worked a lot in oil and gas a
few years ago dealing with lots of
geometric problems
I like computational geometry problems
and I'm going to show you what's called
the collinearity predicate and the code
for that so the question we're trying to
answer is is the point P on above the
line on the line or below the line well
if we draw a triangle between P Q and R
when P is above the line we get a
counterclockwise triangle when it's on
the line well we don't really get a
triangle and when it's below the line we
get a clockwise triangle
that's neat isn't it and it turns out
that by computing the signed area of
that rectangle you over that triangle
you can figure out whether the point is
above the line on the line or below the
line and we do that by figuring out the
sign of the determinants the math isn't
important here so let's do the sign of
the determinant in Python we need a sine
function distressingly Python doesn't
come with so we have to write one and we
need the determinant function there so
we haven't a shin function we can give
it P Q and R as three pairs of numbers
as tuples and it's going to return minus
one plus one or zero really nice
function very simple even if you don't
understand the math you can understand
how to use it and here's a demonstration
of it working on the top of the right we
have three points in a line 0 0 4 4 8 8
and we get 0 very nice where a 0 0 4 4 4
0 gives us minus 1 because we're below
the line great however we're very
diligent and we like to test our
functions so let's see how this function
behaves very close to the line and I
mean very close to the line right so
let's actually use the computer to
calculate every possible float in a
sequence near to the line so we can do
that
and you'll see here that we're getting a
series of wands above the line you can
see the the second coordinate there
they're 0.5 0 0 0 and some numbers are
above the line and we're getting 1/4
above the line that's great as we get
closer to the line oh then we begin to
get zeros so this function thinks all of
those points are on the line but you
know that that can't be true ok and then
you might think that the next thing
that's going to happen is that we're
gonna enter a region where the points
are below the line I'm sorry
now we're above the line again if we
were a little further now we're back on
the line
the one in green there is the only point
where we are actually on the line which
thankfully it does get the right answer
for but in the region below the line
we're still on the line now we're below
the line with the minus one there except
we're back on the line again and now
finally we're actually both the line so
this is really complex region around the
line where this function gives really
pathological behavior really terrible
and of course with different query
points you can get inconsistent results
you can get two points where you know
one of them is above the other but one
of the but the ordering given by this
function is completely incorrect so how
to fix it well let's go back to our code
turns out the fix is incredibly simple
here all we need to do is convert our
floating-point coordinates into a
rational number coordinates using the
fraction type that's the only change we
need to make I'm just replacing P Q and
R with their equivalents represented as
fractions rational numbers now when we
do this we get a beautiful answer where
consistently above the line we're on the
line at exactly one point and then we're
consistently below the line lovely
we can even map in two dimensions the
region a region around a very small
rectangle around the light and I love
the picture that's coming next so the
points in whites are above the line the
points in gray are on the line and the
points in black are below the line okay
so it's a very vivid graphical
demonstration of how floating point
numbers behave and why you need to test
these things in the regions that are
using them you see fraction gives an
exact result but there's always a
trade-off it's 45 times slower right so
you need to decide whether that's an
acceptable trade-off you might think you
know you see lots of software that using
floats that adds some kind of tolerance
value the problem of these tolerance
approach is it just pushes this fringing
effect out and you end up with a very
thick line with these horrible fringes
on the edge of it so it only helps to a
certain extent okay you need to know
some quirks of the language in Python
Pythian perfect and anyone who's used a
language for long enough learns how
imperfect their languages and yearns for
something better but what's the saying
about you know there are languages
people use and the ones they complain
about so let's look at some quirks a is
42 that's a floating-point type because
it's got the point zero in there a is
integer true that seems like a
reasonable answer isn't it B is 42 as
well B is integer isn't even supported
so you can ask floats if they're
integers but you can't ask in C if
they're integers so so much for
polymorphism and duck typing
tuple is a subclass of a thing called
sequence in Python a sequence is
basically anything we can index into
with an integer like a list or a tuple
string is also a sequence does the tuple
1 2 3 exist in the sequence 1 2 3 4 5
no I think this is the right answer
because the tuple on the right contains
integers and I am saying is this tuple
in a list of integers and no it isn't
none of those elements are tuples I
think this is the right answer what do
you think it's going to do with strings
which is also sequence oh dear
so the behavior of Python can be quite
surprising sometimes and this makes it
very difficult to say write functions
which work generically on both a tuple
and a string or a list and a string a
string has this non-intuitive behavior
where the in operator has been
overridden to do substring tests rather
than a membership test I don't want to
turn you off Python by the way I love it
it's the language I coming back to all
right I can program in half a dozen
different languages or if not more but
Python is the one I keep back to but I
do want you to be aware of the traps
here's another one a is a list lists are
mutable B is a tuple tuples are
immutable is a equal to B no that's fine
C is a set which is mutable D is a
frozen set which is immutable symmetry
tells me that this should return false
but unfortunately it returns true ok so
I think some decisions were made that
were not necessarily fully thought
through
and we just have to live with them now
for the sake of backwards-compatibility
designing languages is really hard it's
my favorite quirk so what I'm teaching
Python I was teacher I've just been
teaching a two-day class on basic Python
and I try to encourage people to use
keyword arguments when they're calling
functions which have more than one or
two arguments because then we don't have
to remember at the call site what the
arts are for seems like good advice
right so let's do that with range oh
dear
turns out that range which is a built-in
function does not support keyword
arguments at all which is really
disappointing because I can never
remember exactly which is which so as
well as knowing quirks you need to know
some idioms rattle see these quite
quickly so I don't run out of time here
are some unpacking idioms I know what I
like a is no and B is like this is the
way to swap things in Python use to pull
unpacking create a tuple on the
right-hand side and pack it on the
left-hand side with the arguments
reversed I like what I know so that's
the idiomatic swap Python without a
temporary you can use the underscore
variable in the Python repple in the
console to hold of the last result so
text is now equal to I like what I know
let's split that sentence two words when
you have the urge to iterates using a
range and then index in Python you need
to resist it very strongly it's not how
we do things in Python Python is not C++
if you want to index and the item you
should use the enumerate function which
will return a tuple of index word index
word index word as you go through and
you can use tuple unpacking to unpack
those into two variables index and word
here
in modern Nathan we have some really
quite clever extended unpacking so I can
take the I can unpack the first item in
variable and all the other items as a
list into the other variable so I can
get a head and tail like this it's very
nice that's quite new in Python and I
can use the same trick to do things like
getting hold of the first and last line
of a file and discarding the other line
so here I'm opening my dictionary on my
Mac reading the whole file with read
lines and I only care about the first
and last last items and I can ditch all
the ones in the middle so the first word
in the dictionary is a the last word is
well zero 'get on whatever that means
chain comparisons in Python if you're
doing C++ or C you might be tempted to
write a comparison like this that will
work in Python it's much more pythonic
to write it like this like you would do
it in math Python is very nice about
supporting the syntax logical operators
in Python working quite a strange way
they return the first argument that
allows the decision to be made right so
six or seven we can decide that with six
we didn't need we'd have to know that we
don't we don't need to evaluate the
seven to know that six is true right
whereas with the second example we need
to look at the seven to check whether
the whole expression is true and works
in a similar way
so you saw me use this earlier to detect
whether an argument was full-si or non
non is palsy another anti pattern you
see from people coming from C or C++ is
things like this if protocol is HTTP or
protocol is HTTP or is mqtt it's
supported much more pythonic to do this
create a set and check for membership in
the set it's much easier to read as well
and Python actually detects this pattern
and optimizes for it will make a
constant set for that last one I have
two minutes so let's see how we if we
can get through this know why your code
is slow and how to make it fast so
there's probably someone here here who
works in the oil and gas industry and
they may have at some time in their
career encountered a thing called seg-y
which is a file format dating from a
long time ago which stores all seismic
reflection data it's pretty horrible in
almost every way you can imagine not
least the fact that the floating-point
format is not I Triple E it's some
ancient IBM floating-point format so
this is a program we worked on to
convert IBM format floats in seg-y files
into I Triple E floats and seg-y files
so we have a program converts sample
type which uses a library we made called
seg pi so the first thing to know is
that in order to profile a Python
program all you need to do is run it as
you normally would
and pass - M C profile and - and
optionally - a switch tells you how you
want your output to be sorted so
everyone who's using python has a Python
profiler you can run it and you can see
here that the total time which I've
sorted by there are two functions at the
top
one is IBM flute and wanting to convert
sample type they are both using most of
the time they're the functions which are
consuming most of the time but all of
the functions at the top of this profile
are very tightly related I've just put
the call graph on here so you can see
there are lots of functions working
together to do this conversion and they
together are responsible for almost all
the time this program is taking so what
can we do about it
well I'm going to start by focusing on
this convert sample type which has the
underscore transform function in there
and the main way to make computers go
faster is to get them to do less stuff
all right I mean you can be smarter
about how they do what they do but it's
much better if you can just arrange for
them to do less work so to do this it's
nice to be able to disassemble our
Python to figure out what's taking the
time back into Python bytecode and
python also includes a disassembler
which will we can just import this and
pass a function to it and we get the
disassembled Python bytecode and the
thing to look at here is you see we have
load masked self and load fast self
shows up several times in that
disassembly and that's because in the
transform function in yellow on the left
there you can see we're doing several
attribute lookups through the self
object through the instance and that
takes time loading self is fast but then
searching self which is a name space
which is a dictionary takes time and so
looking up instance member variables in
Python takes time is the dictionary
lookup right so most of the time that's
fine the cost is worth paying sometimes
the cost is excessive so I'm going to
rewrite this function by not having it
as a method because it just that it's a
method makes it quite significantly
slower so I've moved the construction of
this method in
- the dunder init function here so now
rather than attributes I can use local
variables
I've also specialized the definition of
the function you can see I have if data
sample format is some kind of integer do
this where some range checking is needed
otherwise no range check is needed and
we can have a much simpler
implementation so this is a case where I
am able to do much less work in certain
cases and avoid using local variables it
takes a bit of time to process this code
so if you're interested I would go back
and look at the slides afterwards but
when we've done this we're only 22%
faster so now we want to go really fast
how do we go really fast we go really
fast by not using Python nobody uses
Python for performance right if you want
performance you use C or C++ or rust or
something that's actually compiled down
to run on a real processor and so if
you're particularly interested in this
kind of approach you should go to my
colleague Austin Bingham he's sitting
here in the front row he has a session
tomorrow on how to integrate Python and
C++ so Austin here did this integration
where he took this function IBM float
which I will show to you on left in
Python and he rewrote it in C++ and all
he told me that he literally took the
Python code pasted into another file
went through put some types into it then
we have to do a bit of work to build
some glue so that Python knows how to
call this right but it's entirely
possible it's very straightforward when
we do this the program runs 86% faster
so in this whole system there are
probably 10,000 lines of Python and we
can replace what 20 of them with C++ and
go 86% faster so it's a very successful
approach we've been using to build
systems is to build most of them in
Python
is fast we can write code fast in Python
and then we can write code in C++ in the
very small parts of the system where
performance is actually really important
so I'm a few minutes over time I'm going
to stop here these are the seven things
knowing excuted know how to use Sentinel
objects know how scopes and namespaces
relate understand the trade-offs for
number types become familiar with some
quirks of pythons so you are less
confused when you get hit by them
understand how to write idiomatic Python
and learn how to use the filer and the
disassembler which are included with
Python and you all have already for free
I'm going to stop there if you want to
know more of this kind of thing you can
come to one of our training courses or
you can buy our books there are some
token URLs at the bottom there which
includes these books at a special NDC
tech town reduced price thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>