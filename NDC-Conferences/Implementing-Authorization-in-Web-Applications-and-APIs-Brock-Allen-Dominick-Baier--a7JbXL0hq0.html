<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Implementing Authorization in Web Applications and APIs - Brock Allen &amp; Dominick Baier | Coder Coacher - Coaching Coders</title><meta content="Implementing Authorization in Web Applications and APIs - Brock Allen &amp; Dominick Baier - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Implementing Authorization in Web Applications and APIs - Brock Allen &amp; Dominick Baier</b></h2><h5 class="post__date">2018-02-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-a7JbXL0hq0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay welcome back I guess who was in our
talk before okay good
so the first talk was all about identity
server right an identity server is all
about authentication so you know you
want to know who the user is and you
have probably simple to complex
requirements how that happens right from
names and passwords over Federation of a
business partner p2p b2c or all kinds of
requirements so that's what identity
server is really really good at right
it's it's small as a turnkey solution
that that implements the most common
things out of the box and if you want to
implement something which is not so
common you have to the extensibility
points to do that but once you are done
with authentication you inevitably will
hit the problem okay so now I know who
the user is
what is he allowed to do okay and you
know our customers were asking us like
so can't you just build something else
like that you know we just put it in our
pipeline and and and chop is done and it
turns out that this is not so easy right
so since we had these questions over and
over again for the last couple of years
so for the last 12 months so we did an
interview a year ago here in London and
said 2017 will be the year we we think
about authorization like dedicated ma'am
and yet what we did and we basically
started by am observing how our
customers want to implement
authorization and and how they do it and
how they have done in the past and how
they would like to do it and so on and
to just get a better understanding how
that would work right and always keep in
mind there's there's this problem
between what can you generalize and what
is so application specific that it
doesn't make sense to generalize it okay
so it turns out all four as a she's hard
did you know that
so all the systems we looked at yeah we
saw things like you know roles and
permissions and maybe actors you know
access control list some some some you
know inspired by by what Windows is
doing yeah where you attach permissions
or rights to objects in your database
things like that with all the problems
like orphanage and and inheritance and
so on x a como has anyone ever used X a
camel he extends a extensible applicant
role markup language right
I recently complained about that I I
don't want to formulate my business
problems in XML and someone said oh they
support Jason now as well anyway so you
know whenever I asked people is anyone
using XML I see one or two hands in in a
comparable crowd so that tells me not
many people are using it and I think
they exactly had their problem they
wanted to do too much right they wanted
you to model business rules in XML or or
Jason yeah but the problem is you ended
up with like sidelong XML stuff for a
problem that you could solve in two
lines of c-sharp code right so again
there's a blurry line I think between
authorization and and business rules
yeah and I think business rules are
better implemented in the language and
in the system where the business is
actually being implemented as well there
are other things can be externalized and
I think we did the only two things that
we identified across the board of all
the people we asked is roles and
permissions right role based
authorization for more coarse-grained
questions and permission based
authorization for more finer grained
authorization decisions you know where
you basically have users users are in
application roles and you map
permissions to roles right and so you
get like you know a multi-leveled
abstraction okay now the the
architectures we typically work with
look like this right you have multiple
client applications you have back-end
services spec and replications and
typically when we are done you will have
an identity provider okay and this
identity provider as the name implies is
for providing identity right identity is
something Universal yeah so I am the
same Dominic wherever I log into in this
application ecosystem so it's a very
tempting a very tempting idea to now put
all of your authorization logic into the
identity provider right so we have we
now have this central thing right and we
have this new Hemmer called claims now
everything will become an ale
yeah and and the problem I see with that
as I just said identity is universal I
am the same Dominic wherever I log in
but permissions of something very very
application specific right so you know I
might have different permissions in
application 8 and an application P but
they all share the same identity
provider so mixing the two concepts
together of identity and permission will
lead to problems yeah I wrote a blog
post two years ago I think which was
called like this identity is not
permissions and I got lots of feedback
from people agreeing and disagreeing
with me okay but to give you really
simple example that's how I remember it
right on my on my national ID card there
is my date of birth right there is no
field saying he's allowed to drink
alcohol because this rule is very
application specific right depending on
which country I go to to which bar I go
to the end point the barkeeper yeah
we'll have a different interpretation of
the date of birth claim yeah so putting
that on my ID wouldn't make sense and
that's the same exact problem with this
right
if you mixing up permissions and
identity it will get you in trouble
especially if your system is crowing
beyond what you initially planned for
okay so this is something I often see
that that's an example of how an
identity token
would not look like okay so we are on
the top we have the usual stuff right
it's an authentication metadata like
who's the issuer when it when did the
use authentic a how did he authenticate
and the audience meaning at which
endpoints can this token be used okay
keep that in mind because that's the
problem
and then we have clearly identity
information here like the subject that
he added a unique ID of their user maybe
some you know name email address
whatever you want to you know couple
with the identity then we have stuff
that is clearly authorization data right
like delete data manage customer that
that's all you know around a little
Hospital scenario we have from one of
our customers can change the treatment
plan okay and that is clearly violating
what I think is identity information
should be separate for example right and
then there's some some crear eeeh in the
middle which are roles okay so many
people use roles in my mind there are
two types of roles identity roles which
come from the identity system yeah so
again my customer from the hospital they
have exactly free roles doctor nurse and
patient and there is no situation very
user is in more than one role okay and
there is no situation where a doctor
will be a nurse depending on where he's
logging in right they wouldn't like that
so roles can be okay if they are
identity roles but if you're using the
roles purely for authorization then
again you're crossing that line of the
separation between identity and
permissions now if you're coming from a
ws star background W is security and so
on the architecture was typically that
you get one token for each physical
service you're talking to okay
in the overworld that's different you
can see the audience claim up to on top
here you typically want to avoid having
to make one round trip for each service
you're talking to you you are saying hey
give me a token for API one
- okay so what now if the user is
allowed to change the treatment plan in
API one but not an API to see a problem
here how do you want to distinguish
between the two use cases okay so I
think that'll lead you to two trouble
okay
what about how many permissions API one
has an API - that's the other thing
right you want you might want to reuse
the permissions between the different
applications but different users have
the same user might have different
permissions also do you want to extend
this token endlessly for your 500
permissions and then send it on every
single request to the to the API the
next thing I guess I have an issue with
this I'll just go one back is how do you
update the permissions now right so
let's say you know your admin changes
the permission to your you're not
allowed to change the treatment plan
anymore
when will this change of permission be
effective well the next time you log on
to the system right because these tokens
get created at log on time now Windows
has the same issue where you know you
log on in the morning and admin puts you
into into some group yeah and to make
this group membership effect if you have
to log off from Windows and log back in
again because these tokens get created
at log on time okay again I don't think
a security token is a good place to put
permissions yeah it's it's it's clunky
okay yeah and then you know with this
token you go to different API s now and
as I said already there's a chance that
the same user might have different
permissions and different api's so I
don't think this is going to work I
actually we had to fix a couple of
systems like brand new systems right
brand new identity server all new modern
applications but they made this mistake
in half a year later they realized and
well you know it's very easy to add a
claim to a token it's really hard to get
rid of it again because now you know a
claim is a contract between the issuer
and the consumer and if you change this
amend
six or the existence of that you're
gonna break stuff
okay so you know just don't do it okay
that's that's what I said I think cool
so what we think you know thinking
deeply heard about the problem is that
identity a.k authentication and
permissions aka authorization should be
separated okay
separation of concerns we think the
identity should be the input to your
authorization system and what comes out
of that will be the authorization data
okay so basically what we prototyped so
to speak is a separate logical role
right there's the identity provider
which will provide the identity of the
user and again this is universal right
regardless where you go to you are the
same user but depending on where you go
to you will have different permissions
right and that is an authorization
policy if you like and there in our mind
we think it's right to have a separate
service on your network that takes the
identity as an input and remover and
returns the application specific
permissions for a user okay
so that's what what you put a typed
basically the idea is you know the user
first goes to the identity provider
doesn't authentication request gets back
to tokens and then the application for
example can go to the policy provider
send that identity and can back get back
the permissions for the UI right a uie
has different different authorization
requirements or needs than an API in the
UI it's all about you know enable this
and disable that and so on so yeah this
will have different permissions than a
back-end service so when you now call
the API is with this token what the
backend services will do in turn is they
get to the book go to the policy
provider and get their API specific
permissions okay
and the nice thing on top of that is
that you want to have a nice management
story around that right so maybe you
have a management API right where you
can dynamically create roles permissions
put users into roles assign permissions
to roles or a management UI where maybe
a non-technical person or you know like
at least not the developer maybe can go
and assign users to permissions and so
on and that should be completely
separated from your actual you know
business logic so a program I sat down
after we before that this is the right
way to go from our point of view at
least yeah and and wrote the code okay
so what in essence fell out of that are
a couple of of of pieces here first of
all a client library something that you
can plug into your applications to make
it as easy as possible to talk to this
abstraction okay and then the client
library talks to a client API and the
input to that client API is the identity
of the user okay
and now in inside of this client API
there's an engine that can now map the
incoming claims to roles and map the
roles to permissions okay and there were
a couple of things here you can do a
static mapping for example from the
subject ID to a role or maybe you have a
rule saying you know if he is a
contractor he is I don't know
goes to the to the role external for
example so you know an external has
different permissions you know things
like that so that's one thing and on the
other hand as a management API that
allows you to do everything pramatta CLE
you know the whole management maybe you
want to create resources on the fly
there are things like that so that's
that and obviously in front of that
Jesty admin UI okay so while writing
that code yeah we we went pretty quickly
I think
from the idea to something we can show
okay so if anyone has seen our
nd see Oslo talk from last year we
showed a very first prototype we didn't
ever UI it was all basically you know
chasing files by the time we didn't have
you know doctor full thing and we liked
it and we showed it to people and they
liked it too so we realized to actually
implement it like really really
production-ready
male like with all the bells and
whistles and install us and
documentation and client libraries for
multiple platforms and caching and all
the things you would expect that's a lot
of work so I had to ask where a profit
question do you think we can afford
another open source project it's tricky
the answer is yes and no so what we did
is basically we took everything that you
need to implement the pattern right the
separation of concerns the the
separation of identity from permissions
you know like sending identity somewhere
getting permission Specht client library
and so on so forth that is going live
well it went live ten minutes ago or 15
or 20 maybe yeah so that's on get up now
get up complex policy server and that
gives you everything you need to
implement the pattern okay so if you
think this pattern is useful for your
applications having that separation
which makes it easier for you to grow in
the future
just take that and there it is if you
want the advanced features like
banishment server management UI client
libraries for the platforms you know
support for Redis and blah blah blah
blah blah you know whatever the real
product needs yes as a commercial
product now launched 20 minutes ago okay
so for for this for this talk we will
only use the open source version so you
see basically what what you get and you
can have a look and you know pull
requests and and all you know all the
things issue tracker and so on is all
there and then at the end I think we'll
have five or ten minutes just to show
you the
more advanced features that that you get
with them you know lift product good so
what we're gonna do is look at and by
the way we're calling this policy server
local so the the open-source version so
what we're gonna do is look at that so
the the thinking is ok how can we now
use this abstraction this decoupling of
mapping into your application so as
Dominic mentioned the first approach for
doing that is basically giving you a
library in your application that you can
call to this mapping layer to establish
what the application roles and
application permissions are so you'll
often get the user somehow take that
user call into this engine that will map
this and give you the results and it
really results in a list of roles in a
list of permissions and again these are
application specific roles and
application specific permissions so part
of the design of this actually there
will be some upfront time in your
application thinking about what are the
roles of the users in my app and what
are the types of permissions that I do
want to assign to them ok so that's the
first thing is a client library and
that's just straight up using this this
this new library that we've developed
then the next thing is then some other
techniques for incorporating that
information throughout your application
and we'll see an asp.net core that there
are a few different ways to do that we
can do your traditional authorized
attribute or utilize the new policy
system from asp.net core ok so this word
policy does get a little overloaded
right we have this policy server that's
about the mapping and then asp.net core
has policies as well and you can use
those together ok so the first thing is
what we have is a project this is
actually the code that's right up on
github and we have the library here for
policy server local this is added in
then to a sample application and
actually the first thing I suppose to
show is just logging into the sample
application we have a very simple
account controller where you can log in
and we're decoupled from what the
identity system is so this approach and
this technique that we're showing you
you can use with any identity provider
it does not have to be identity server
it could be
you know Active Directory or Azure ad or
something else so right now we're just
hard coding some users and in our
example I think Alice is ultimately
going to end up with dr. sort of
permissions and Bob is going to end up
with nurse permissions and this last
user whoever else unfortunately falls
under the patient role so we're gonna
have this this application where the
user logs in obviously to enable
authentication what we have are the
cookie handler in asp.net core 2 so then
to pull in this policy mapping that
we're talking about we have to define
these policies somewhere and so actually
I think in Oslo what we showed is the
hard coded version we didn't even have
Jason's support at that time but now we
have this ability to express these what
we call policies in in JSON file and for
this version we only have you know one
policy and the idea is that the policy
allows us to define roles all right
these are the application specific roles
and we're gonna have a doctor and a
nurse and patient and we have ways to
map the user from the identity system to
these application specific roles so you
could simply list the users identifier
their subject identifier right that's
the users unique ID and user ID one and
two well those are both doctors in this
application we also can map from the
identity system the role of the user so
there's the centralized identity system
maybe you're you know a doctor in the
the centralized Active Directory they
put you in the doctor group when you get
into the application though the
application may have slightly different
names for what these application roles
are so there's the identity role that
gets mapped to an application role so
that's a different way to do mapping so
in this case it looks like our identity
system centralized make all the user a
surgeon but this application just has
the notion of a doctor okay so we also
have nurses so these users and I guess
RN is not well known over here that's a
registered nurse that's the abbreviation
in the u.s. frequently for a erse and
then we have patients as well so that's
one way to do some mapping we're going
to take the identity
map it to these application-specific
rolls we also have the notion of
permissions and so then the application
decides what are the the functions that
we need to protect all right certain
users can do certain functions and
that's where the permissions come from
so based on your application role you
can utilize application specific
features expressed with by these
permissions so some users can see
patients some people's users can perform
surgery and so on and so forth okay so
this configuration system then gets
loaded in to our application at runtime
so we're gonna start up our application
we will load our Jason configuration and
load it in memory and use our extension
method to put the services that we need
into di and the main service that we're
putting into di then is a client library
that your application can use to query
for the current user which application
roles and permissions they're allowed
access to so to access that C server
client the API then that we surface to
communicate to the mapping engine is
this thing called the policy server
client and it has a couple of api's
right you can see for the current user
are they in a role do they have a
permission and here's actually the main
engine pieces where you feed the user in
this is the currently logged in user and
you get back their results which again
conceptually very simple it's just the
list of roles and permissions that
they've been mapped to it actually can
also be another user if you want to it
doesn't need to be the currently logged
in user you can evaluate for another
given user in the system which is also
useful so what we have is then the
client we can evaluate for the current
user and we get back this result
the result has the roles and the
permissions like this so what we'll do
is we'll just pass this to our view and
we have some code in the view that will
show that okay so I'll go to my secure
page I'll log in as Alice okay
again remember Alice from the identity
system is just user ID 1 and name Alice
okay but that goes as input to the
policy system and the policy system is
simply map the user to these application
roles and permissions okay so now you
have that data for that user right
specific for your application what do
you do now to do your authorization well
you have some information right here so
you could do whatever check you wanted
to programmatically right you've called
the system you have some of that those
results okay so that's calling the
client library and getting that
information back ok now again you could
always write your own authorization code
at that point check for this operations
being performed does the user have the
particular role or permission but we're
in asp net core right and in ASP not
core you know we have the good old
authorized attribute so what we can
start to do is figure out how to take
the policy system that does the user
mapping and start to then use the
built-in authorization features provided
by asp.net ok so how many guys use the
authorized attribute with the roles yeah
people love that right so what we're
gonna do is go have a method where only
nurses are allowed to you know use
perform this action ok and so we can use
the good the good old authorized
attribute to do this now right now the
current user that's logged into my
system does not have that information ok
in the users claims list right right now
the logged in user just has a name and
we're just printing out the fact that
they're mapped to this role so to
actually leverage this style of
authorization that user has to have the
role claimed in their their current list
ok so there is a technique for taking
the the claims that are in the cookie
right for the current authenticated user
and when the request comes in to the web
server add additional claims or augment
the list of claims so that the
application can look there for them
rather than calling this this custom
library okay and so that's called claims
transformation and we have a mechanism
where the claims transformation can use
as the source of the additional claims
all right our client library to map
those so what we can do is put into the
middleware pipeline right after
authentication has been performed right
the request comes in the cookies read
turned into the claims principal with
just the subject claim write our policy
server claims transformation will then
add those claims to the user so you can
take advantage of the built in role
checking that's provided also if you
already have existing investments into
the built-in API so you know like a
claims principal don't find first find
all has claimed you know all the the
built in claims API is from from dotnet
and you want to keep them that's how you
would do that yeah so actually what this
is now showing is that the user coming
in from the HTTP context now has some
claims coming from the cookie and now
these claims that have been mapped from
the policy system okay so now the
current user does have the role doctor
on the user object and now if I go to
the nurse's action we oh we're actually
nowhere a doctor
exactly right so that worked so yeah
nurses only right shouldn't be allowed
so if I log out can I am can I into so
Trina can you do surgery you should be
able to us nurses only right we can get
in there okay all right good evening
again well the usual a small rent at
least about the authorized attribute iam
not not about the authorized attribute
in particular but about using it with
this in this style right
I have seen a lot of customer projects
where this was extensively used there
and then you have like 10 controllers
and 20 controllers and 50 controllers
and suddenly you have authorized
attributes everywhere right role equal
tees role equal their role equal
something else now I think this leads to
very hard to maintain code right
especially if you're your boss walks in
says hey by the way can you give this
random guy from the marketing department
access to whatever you have to you know
to them calculate a mess in your head
like what's the intersection of dead and
dead and you have to go to every single
authorize that you could update it
correctly don't make a mistake right and
so on so forth so I personally don't
like the approach I totally acknowledge
that many people like the approach that
that's why we added support for it right
but I think it's hard to maintain I
actually have one customer who wrote a
command-line tool to scan all
controllers if they have the right
combination of matching strings over
that and I don't think you want to be in
that situation to be honest ma'am so the
main complaints are it's just hard to
maintain you have this code maybe
sprinkled in multiple locations for the
same logic right because you might need
to have some code in the UI that hides
or shows the button and then the actual
action method has to have the exact same
logic to actually enforce the logic so
duplicated it's also the big complaint
is it's hard to unit test yes right if
you actually need to unit test this you
have to run a real server and make real
HTTP requests I mean how would you
automate a test that makes sure you have
to write rolls over each controller yeah
it's it's it's not trivial that's why
actually you know we've been talking to
the 8-minute core team for many many
years or the asp.net team I should say
before they were even core and show them
an alternative way of doing
authorization and you know they didn't
really feel like adding that to the old
days Peter net but now with the new a
speed core where they have the chance of
doing breaking changes and stuff they
added this new authorization API and
it's called policy based authorization
and you know kind
that's what inspired us right because
think of the HP policy API a nice
client-side API against our policy
server back-end so to speak and the nice
thing about basically that the policy
API in a build core solves my biggest
complaints it's better it's easier to
maintain because you can centralize your
policies it is you can have a separation
of concerns between business logic and
authorization logic and it's testable
and that was my biggest you know wish
that I can somehow ride automated code
that it runs on a check-in that makes
sure I haven't messed up my
authorization policies okay so there are
a couple of different ways to use the
policy system the first way we're going
to show you is kind of a the simpler way
and it works okay for demos I suppose so
the idea is that you have this idea of a
policy and there are certain
requirements from your user that the
user must satisfy to be allowed to do
whatever your operation is so in the the
DI system you will add the authorization
services and then you can define these
policies so a policy has a name in this
case prescribe medication and then on
the policy you go and express what you
expect the user to have and if the user
has this then they will be satisfying
the policy so I require that the user is
authenticated and that they have a
permission called prescribed medication
for example ok the nice thing about it
is that you define the policy only in
one place and if you change the policy
all the controllers will just get
automatically get this new policy right
you can even think of putting the
policies into a separate assembly and
then being able to version the policy
independently of the application for
example so there are some benefits in so
in this particular example it actually
works well with our user mapping our
policy server mapping in the JSON file
because what I'm requiring from the user
in this cases of permission so what
we're going to leverage is our claims
transformation from our mapping from
policy server to produce the permission
and then we can leverage down on the
right the actual authorized attribute
and the version of the authorized
attribute that you accept a string to
the constructor that's not a role that's
now the name of the policy that you
expect the user to satisfy to be able to
access this action method you know the
other thing is that there's a layer of
indirection here so maybe being able to
prescribe medication means you have to
have the permission and something else
right and you can bundle it up basically
into a reusable thing called policy and
as you'll see in a minute this all is
also extensible so you can plug in your
own custom requirements that can go to
custom data stores and so on so let's
actually go back to our secure page and
I don't think patients were allowed to
to prescribe medication but doctors and
nurses I think were actually we could
take a look here would be we added
patients could do that yeah so there we
go well they can request pain but yeah
okay so yeah our doctor and our nurse
should be able to now access the secure
method whereas anyone else should not so
if I run this I don't think I'm logged
in as anyone right now so we'll go to
secure I'll log in as Alice okay and
again we get here that worked great
because Alice does in fact have
performed surgery if we log out sorry
yes prescribed medication sorry log out
and go now and login us Joe and yeah
Joe's not gonna be allowed to do that
okay so that's nice okay because we've
now decoupled the two right and we are
now in a little bit better position to
maintain that code what are the other oh
yeah this is actually really nice thing
about this is that you can also use the
asp.net core authorization system
programmatically instead of just
declaratively you can invoke it
imperative lis so maybe somewhere in
your code based on logic that's
dynamically occurring you need to
execute one policy over over another and
that's the key to testing right so now
you can just write unit tests your paw
you create a claims principle that has
to shape and form that you
that you want you pass it into a policy
and you make sure that the expected
result comes back right and then if
somebody changes to policies down the
line that the test will succeed or break
right and you will get immediate
feedback if something has been broken
daddy you know change the behavior so
instead of doing it declaratively like
that what we could do is authorize we
pass in the user and we indicate here
our prescribe medication name the most
common question we get when we showed a
new HP no authorization API is oh it's
the reversion available for older
versions of asp.net because you know I
like it but we don't do a spirit core
and indeed there is yeah the the links
on the slide and you have to send the
slides on speaker deck there's a guy
called David parks 8 on github that back
ported the whole thing to a speed of net
4.5 and the API good so now we have a
programmatic API to tap into the asp net
policy system which you know in this
case is good to be able to achieve your
unit testing the other nice thing then
is that you could also use this when
you're building your UI right you have a
view model that has a flag for whether
or not a button should be enabled
something like that you populate your
view model and now you can you change
the code centrally and both the where
you enforce it and where you display it
well both well both pick up the change
actually even this am way where you can
now use dependency injection directly on
fuse so you could in theory get the
authorization service directly on to
your view and then execute policies and
depending on that render your UI I'm not
sure if I should recommend that yeah
the the DD approach that proc describe
is much better to have a view model
right but let's say you want to do stuff
on the layout page then this is maybe a
handy thing if you want to you know
change the global the global navigation
whatever based on who do
um okay all right so what we've shown
here is in our sample code is defining a
policy okay and then having the benefits
of that centralization and in this
particular example like I said we are
matching it well with our user mapping
coming from our policy server except one
problem with this is that notice you are
now basically doing a one-to-one mapping
of the permission from our jason mapping
to a permissioned a name in the asp.net
core policy system okay and if you have
ten policies this can start to become
tedious or twenty or even more or ten
permissions rather so this becomes a bit
tedious so it turns out that the policy
system is extensible the authorization
system back on the home controller when
you're invoking authorize they think and
you pass in the name of a policy
internally they have a lookup mechanism
to go find that policy and that lookup
mechanism is itself extensible so you
can just register an interface in the
authorization system that receives this
string dynamically and then you can
dynamically create a policy so it turns
out that we have that support as well
here we've added that into our local
local system so I can get rid of the
manual one-to-one mapping of this which
makes sense if all you want to do is
just one-to-one mapping right if you
want to have higher level policies then
you can still map them you know
statically but for one timon that's just
done automatically now so we have this
extension method which will register
this authorization of policy provider
and so we are implementing the
microfiche defined by Microsoft we can
come in here and look at this
implementation it's it's pretty
straightforward when the request comes
in for a policy we go look to see if an
existing policy is is already registered
maybe you've already done a hard-coded
policy great we'll leave that one alone
but if the policy is not there
we will look it up from our our
authorization system based on the the
permissions for the user so we're
dynamically then creating a policy
requiring the the permission that that
you indicate in the string okay and
actually we use our client library
directly so we're not even looking at
the current user object we actually call
into the client library to go to go look
that up so to use this actually we could
do a couple of things now that we have
this and it's going directly to the
client library we no longer need to map
these policies directly and then
actually you know fact we don't even
need to do the claims transformation
anymore okay wait it's about style I
guess yeah some ppl you know that's the
other thing I learned when talking to
our customers is that everybody prefers
a different style so that's why we
basically give you the choice you have
options so if I run this it should still
basically work the way it was I'm
currently logged in I don't think I'm
not logged in as anyone here secure oh I
need to have a basic authorized
attribute it's actually an interesting
difference here so the very first time I
came in I wanted to be denied but logged
in so the first time I want the redirect
to the login page
once I'm authenticated then if I don't
satisfy the policy I want to be taken to
the forbidden page so that's what I was
missing here okay secure Alice should be
allowed great we're in and of course our
other user Joe should not be good so I
mentioned earlier that the policies team
is also extensible so you just you don't
have to just go for claims right so you
can also have your own custom
requirement so basically what a policy
is it's really just a list of
requirements and some of these
requirements are built in like you know
require indicated user require a claim
whatever but you can model whatever you
want right so let's say for example we
have a custom requirement where we want
to authorize on what kind of medication
the nurse or the doctor wants to
prescribe and how much of it right could
imagine that this is something that
could be real yeah so you know the code
is not really necessary maybe just
switch directly to the implementation or
how to use it but the point is now that
you can create these higher-level
requirements you could implement the so
called requirement Handler and this
handler is invoked at runtime by the a
spirit core system and then inside of
that handler there's a handle method or
yeah that allows you to write arbitrary
code yeah so on one hand you could call
the policy system curing permissions and
roles but on the other hand maybe you
need to look up some web service
whatever to you know and both things to
get up will become your ultimate
authorization decision yeah yeah so this
particular example if you want to be
able to prescribe medication will first
see if you have the permission from the
policy system and then based on the
amount we'll do additional role checking
for example okay so it allows you to
write arbitrary code and again you're
mixing a little bit of our policy server
logic with a little bit of your own
custom application logic this class does
need to go into the DI system so that's
one last thing I need to do is go in and
the code then when you are trying to
actually enforce this we have now a
prescribed medication action method we
build up our requirement and based
passing the user and based on the type
of the requirement that's what triggers
this method to be or this correct
handler to be invoked because of the the
generic argument there and that generic
argument is again back in the handler
passed in to you that's where you you
get the additional data so I broke
something now
oh did I comment that out what it a very
equal to break ah too much commenting
out so I think I'm logged in as Joe and
Alice good and so there's a link of
course ah here we go good it's much
better than me typing it so we have one
where you can prescribe 1020 or placebo
so I think a nurse can can prescribe up
to 10 a doctor should be able to
prescribe up to 20 great that works but
if we come in now as Bob the nurse right
Bob can do ten that's great but now
twenty tonight so again did you mention
this is now since it's in the DI system
it's now testable and and and your
handler class and can take any other
dependencies it needs so one of the
things that's commonly you know need to
be done as you might need to look up
stuff out of a database for example yeah
the very last thing is that
authorization for can also work globally
right so it's it's basically you're not
forced to opt in to authorization what
you can also do is have a global
authorization policy and then opt out
wherever you need and so let's say for
example you know like a very common
thing is that you only allow
authenticated users but there could be
arbitrary complex you have the full
power of the a spirit core policy system
here and you can create our jury complex
policies which you know define the shape
of the user before he can even use the
application and then you can use local
policies as well on top of that okay I
don't think we have to show that okay
good let's go back
so yeah
so we showed this to a couple of people
yeah and to get some feedback and so on
and and again keep in mind yeah that the
ultimate a question was can we create a
turnkey solution so to speak for
authorization I think the ultimate
answer is you can't
yeah no one can because at a certain
point authorization becomes business
logic okay so what you can do is you can
definitely use a standardized or a
general authorization component to
define who is allowed to access my
application that's easy
yeah that's a global policy you can
authorize on who has access to certain
features of your application and I think
again you have the choice of being you
know role-based more coarse-grained
right and if you drill into the feature
like you know maybe you know ten ten
milligram versus 20 milligram whatever
that could be a permission thing yeah
but once you drill even deeper yeah like
I don't know now is this patient
actually allergic to anything inside the
aspirin yeah is that really
authorization logic I really think that
that's business rules at this point yeah
that's why we stopped here some people
asked us can you go one step further and
then we were suddenly in the exact amol
dilemma right where we started to have
the need of expressing business logic
inside our code where I think you are
much more effective expressing it in
your own code okay but that's I think
where we ended up with we have ten more
minutes so maybe you want to just show
quickly a couple of the advanced things
which are not in the you know on github
button right in the UI right so what we
have here is also then running locally I
have our management UI for policy server
so now this is the centralized version
if you will of what we just demoed
so the idea is that the centralization
of this allows you to put your policy
definitions you know in a database you
can have an
traitor come and you know if you're
onboarding a new user you can start to
go to the different policies for the
applications that the users allowed or
should be allowed to and start to map
them to these roles and permissions but
again it's done through this UI so yeah
we have our this is our first version if
you will of our UI hey we have a few
policies already here that we're gonna
map again these are stored centrally so
what will happen is then the client
library the one that we just showed you
that you can call directly in your MVC
code there's a different version you can
swap in and this different version will
then connect to the centralized policy
server instead your code really
shouldn't have to change in your
application now that you're centralizing
this so we have one one simple policy
here modeling our emergency room
scenario this is kind of our doctor
nurse and patient scenario and so our
management tool allows you to define
roles for this application so the idea
is that you'd create different policies
for each of your applications and do
your mapping to your users from your
identity system so in this case we have
our doctor and notice our doctor can be
assigned from some identity data so just
like we had before the users unique ID
maybe in this case it's Alice if you
want to do the identity role assignments
maybe right
surgeons are allowed to come in here and
do this okay so now surgeons are mapped
to the doctor role in the emergency room
another thing we have is again the user
ID or identity roles that's a good for
start and that's useful but you know you
might want to have your own custom logic
based on their identity information to
decide how to do this mapping so we even
allow you to to put in an expression
here so this is actually accepting a
lambda expression right and you can
actually put in a c-sharp lambda here
and we actually will evaluate this at
run time based on the claims coming in
while you're executing this policy okay
so you don't have to do one-to-one
mappings right if you know that certain
users will always come in with a certain
identity
you can automatically assign them to
roles and permissions without having to
change it all the time so if not that
I'd want my sick users to fall into the
doctor role but you see that that is now
in there okay good
so it's same same mapping logic just a
couple more features so then down below
we have the notion of our permissions
and same thing you'd model the the
actions that a user may or may not be
allowed to perform and then based on
what your roles are you can simply
indicate right if the user should be
allowed to do that okay so that's the
this is a simple version if you will
very much like our JSON file again
what's maybe different about this is
then it is in fact centralized and we
have our management tools as part of the
commercial product there's more though
than this because you know you might
have this notion where well I might be
building multiple applications and the
design here is to have a different
policy for each application it's
supposed to be you know application
contextual so the problem with this then
is that of course well if all of your
identity mappings are the same but maybe
each app has different permissions it's
tedious to redefine all those mappings
so we realized that if we're gonna be
build something here that's actually you
know production-ready
we're gonna have to have the notion of a
policy hierarchy okay so the idea where
you can actually define a parent policy
and then have a child policy that
inherits configuration that you've done
upstream so this particular example
actually is attempting to model that
where we have maybe some hospital system
that you're building and then there are
child policies beneath that and in this
particular example the child policies
represent the application so we have a
medical records application and an
accounting application okay they share
the notion of roles and who is in the
roles so if you're a doctor in one
you're going to be a doctor in another
but you need a separate configuration
because they have different concepts of
permissions so what we've done here is
we've modeled our role mapping at the
root of this policy hierarchy at the
hospital level and so again our doctor
we have users mapped to the
to roll and then as you navigate to one
of these child policies right you are
inheriting the notion of these roles but
this particular policy has permissions
so this is an example of the application
specific permissions and certain users
are allowed to do create of medical
records or whatever this represents okay
all right so that's another example of a
feature that's in the commercial product
is this notion of hierarchy in the
policies so it turns out there's another
use case as well I had a customer that I
built some authorization engine for
several years ago and they basically
wanted to model a scenario it was
actually a fire marshal submit scenario
where like a fireman would come into a
building to inspect all of the the
safety equipment in the building and so
they had very strict rules about which
fire marshals were allowed to inspect
which floors of the building or which
rooms in the building okay so they
needed to have a hierarchy to model the
building and who could be assigned to
the various floors and rooms and devices
in that room for this inspection purpose
so that was another scenario that we
wanted to be able to accommodate in our
policy server so this other example is
an example of the hierarchy and it's
actually sort of the inverse of the
prior hierarchy so the first hierarchy
we defined the roles at the top that
were the same mapping across all
applications but different apps had
different permissions in this particular
example we have the notion of roles in
an application okay that are defined at
the top but what we're doing is we're
doing the permission mapping at the top
and then down the hierarchy the
hierarchy now represents resources in
this particular case the hospital so
maybe a particular emergency room you
know a particular nurse could be
assigned to that emergency room but not
some other room maybe not the operating
room in the hospital so our hierarchy in
this particular example is actually
modeling physical things so there are a
doctor or a nurse they have the
permission to work
in a particular room in the hospital so
the permission mapping is at the root of
the hierarchy but notice at the root of
the hierarchy okay we don't have anybody
assigned yet where did these are just
placeholders to model the the roles and
then if you actually go to the emergency
room right what we've done is at the
emergency room done the role mapping so
maybe right now this nurse named Alice
is assigned to that particular level in
the hierarchy so again for this
particular emergency room this person
can be the nurse maybe there's an
operating room maybe there's actually
even nested you know further hierarchy
so room operating room one we have Bob
is assigned to operating room one but
maybe for a different operating room we
have a different assignment so the point
is basically what you can do with this
system is also to outsource you know
like when you're building an application
where your users can create resources
dynamically you can outsource that
permission management to this here and
don't have to build it into your own
code yeah think of things that get
happier where I can create a repo right
and then in my repo I can assign proc
push access to it right so that that
could be also done with the system and
that's what we had in mind here right so
backing the management UI here is we
have an API so the management tool is
using the the Web API this is an API
that you could be tapping into as well
from your application if your
application was dynamically modeling
these resources and doing assignments
okay cool that's it so if you are
interested in that well okay can you can
you bring up the slide with the URLs
again so you can goat with the URLs of
policy server oh we have not yeah we're
just go on up in the middle yes yeah
okay so if you're interested in that
play around with the open source version
if you're interested in using that
commercially let us know there's a
different website with a link to a
contact form and so on so forth and and
give it a try okay
thank you thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>