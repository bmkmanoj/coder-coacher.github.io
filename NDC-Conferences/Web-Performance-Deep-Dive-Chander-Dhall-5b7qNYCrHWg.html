<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Web Performance Deep Dive - Chander Dhall | Coder Coacher - Coaching Coders</title><meta content="Web Performance Deep Dive - Chander Dhall - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Web Performance Deep Dive - Chander Dhall</b></h2><h5 class="post__date">2017-02-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5b7qNYCrHWg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good evening London it's amazing
past 4 p.m. and I have a roomful I am
already honored thank you so much so
what we're going to do is we're going to
pretend that we're happy because we
don't know what happens after the talk
but at least right now we're happy you
want to take a picture all right Wow
I'll probably have to do a panorama
that's a lot of people standing room
that looks even better
let's get them before they sit down
perfect awesome so that's my email and
that's my Twitter if you love the talk
tweet about it if you do not email me
here's some information about me these
are things never you never want to do
these things if you want to be a
billionaire do not do any of this all
right all you need to do is go to school
and then drop out because every
billionaire does that drop out in the
last semester and you're definitely
going to be a billionaire do now follow
me I do work we just acquired another
company Caston and if you were tired of
working with non-technical recruiters
give us a call on the CTO there also
engendered a link it's not a one-person
company just so you know it's been
challenging to prepare this training
because this is one hour and we usually
do a two day training on this subject so
bear with me hopefully I don't get a lot
of red cards I'll buy you dinner if you
want to give me a green card Steve
Souders one of the most phenomenal
people out there a lot of good work on
web performance saves one really good
thing great developers know why things
work so we're really going to focus on
the why because it's really easy to
understand the house how is in fact you
can Google Stack Overflow and everything
is there but the why is important
today's agenda
we're going to try to do we're going to
try to understand web performance and
then identify bottlenecks and then go
back and try to see if we can make it
faster as long as we have time and then
you have - - time and the while loop
continues so before we get into tips
let's see some code
here's an example of a Fibonacci
sequence and is that is that good enough
is the font size good working perfect
just kidding
making sure you're not sleeping yet you
know you will sleep by the end of the
talk but at least not yet right so
here's the Fibonacci sequence of 40 and
all I'm doing here is getting the start
time and then the end time and if you
run this
I actually have it open right there so
you see the time taken in milliseconds
is about 1407 and the count is pretty
big it's a really big number I'll show
you the code in a second before that
we're going to change this to the fast
algorithm run this again and you see the
time taken in milliseconds is two and
the count is only 39 so let's look into
the code so this is a very simple
Fibonacci sequence you've got you know
zero one two and that's how it continues
so what you have to do is kind of see
this as a recursion and that's how it
works now this is not just JavaScript
it's going to work the same way in any
other language but we're doing a wrong
thing here we're doing recursion and
recursions adding a lot of overhead in
our code so there's a technique called
memoization I'm not going to get into a
lot of detail there but all you're doing
is if you already know the Fibonacci
sequence if you know the value of it
you're adding that in your memorizer
right here and that's your array and you
start adding those values so all you
need is for 40 this executes only 39
times whereas in the previous case we
saw it took a while so whereas it was
like two milliseconds the other one was
more than a second and that's a huge
difference it is just a small change in
your algorithm we're not going to get
into a lot of details in algorithms
because you know how to figure that out
that's easy but it just tells you that
in JavaScript this is an expensive
operation let's take another example a
lot of times I see this in code
everywhere I go it's good to use
underscore because underscores faster
but if you use underscore in the wrong
way you can get in trouble so one code
that I see all the time is this here's
an A for each which is more like an
underscore each underscore is just a
library that does certain things better
and faster this is more like a for each
and it says this value is 5 then say
exists is true and then console dot log
that particular value now if you were to
see the result of this thing
you can see that the value found was
five even though I have a return
statement
I still go six seven eight nine ten now
I imagine a list of catalogs on a big
fortune 500 company imagine your product
list imagine any other lists list of
your users would you really want to go
all the way if you already found your
user let's say you have ten thousand
users in the list and you found the
third user which is exactly what you
wanted you still want to loop through
the entire loop and this is a common
mistake in a lot of JavaScript code
that's out there a lot of big
corporations a lot of other people have
code like this a good solution is using
something like this which is dot every
which is also part of underscore and you
can use this and say return not equals
to five and I'm going to go ahead and
comment this I'm going a little fast on
this because this is stuff you know
because there's a lot of good stuff
coming run this thing again and you see
it's got one two three four five a lot
of times when you go from Donette or
java to javascript you assume it's going
to work the same way as your other
languages would but javascript was a
language that was created to make good
and smart people feel like they're not
smart anymore and they did it right they
got it right so there's a good job at it
here's another thing which is important
is a lot of times we make this mistake
of having dynamic scope without
realizing it's dynamic so for example in
this case we have a function execute
which is getting some kind of dynamic
code that eval is going to execute now
this looks pretty good and for the most
part we'll always get back the window
object except something like this where
someone might send in code that already
overrides the window object so in case
number two window is just a string and
now I won't see that right so this is
dynamic code and the problem a dynamic
code is it's more expensive so if you
use with statements you're going to see
that if you do try catch the moment you
get to catch e^x or error
or whatever is part of cats is also
dynamic so that's another problem evals
are good only in couple of cases
everywhere else you'll see that they are
a problem dynamic code in general is a
problem all right
back to PowerPoint because that's what
we love arguing for code or PowerPoint
we're going to do books don't worry
so some JavaScript tips usually you're
better off with accessing a local
variable or member over something that's
part of an array or a bigger object
because that's going to be faster and
then you also have location or href it's
actually going to be faster to use this
over this even though there are the same
things because you are adding a global
scope and then you're going all the way
up and then getting to that value now a
lot of this does not make much
difference nowadays because you have
browsers that have their own engines and
they're optimizing this for you so a lot
of times when people go I want to make
sure that my performance is great
do not spend that eighty percent of the
time without already knowing that this
is already supported in a browser so if
you run this thing thousand times and
you're only getting one millisecond
benefit it's probably not worth it why
do you want to avoid with the same thing
we talked about every single function is
more like an object in memory and that
object has a scope chain associated with
it when you use with what happens you
actually create another set of you know
variables in memory and now you make it
part of the first scope chain which
actually talks to the second scope chain
so it becomes slower again the dynamic
part of it so anytime you use with you
know that you're slowing down just a
little bit this is important
amazon says that an extra 100
milliseconds of delay on the response
time can cost them 1% in sales and
google says 500 millisecond increase in
latency and that's just latency which
you can't easily change that much causes
the traffic to drop by a fifth
that's billions of dollars if you look
at it that way and that's a huge huge
huge problem so what are we optimizing
at if I were to ask you what do you want
to do what's the response time that
you're looking at a lot of our clients
try to achieve something like 250
milliseconds and there's a lot of things
to be done to get there and it's not
just JavaScript code there's a lot more
other things associated with it here's a
study from FD comm it's a very recent
study they did it last year Financial
Times what they did is they
intentionally slowed their website and
what they found out was that the pages
per session kept dropping so the same
users were now reading less articles if
you were to see more detail page load
time here's a 7-day impact and that's a
20 day impact 28 day impact and it's
about 7.9 percent that's huge loss in
viewership later and that's going to
actually lose they're going to lose
customers later and if you want to see
what's happened in case of mobile tablet
and desktop the studies online you know
you should read about it very good
insight into how a user interacts and
the difference is not really much you
would think oh it was just one second
but in one second
you are losing your customers let's take
an example where we talk about
performance versus perception a lot of
times I've seen developers they only go
for performance however at the end of
the day it's perception that matters
more let's take an example this is first
scenario this is scenario number 2 let's
say you've got this you barely have
anything on the page and then you have
just one header pop up and then you have
the entire page in three seconds fully
loaded and the second scenario is where
you have this one page you have a little
bit rendering with a you know header
here which is a little bit more than
that one and then you have half of this
but then it takes you four seconds to
get the entire page in this scenario
you're probably better off picking this
because there's a big difference of one
second and we just saw that one sec
it's very very very important let's take
example number two very similar in
rendering very very similar and then in
number three you've got the entire page
and I'm really talking about the page
where it's I'm not talking about
scrolling down you still may not have it
but at least this page that a user can
see and relate with and this is half a
page and then you have this full page
right very easy we're still going to
pick that one this is just a mobile view
of the same example we just saw another
scenario where we have one second we've
got nothing going on in both of these
frames and then we have a header just a
little bit barely anything here and then
we have these full pages which one are
you going to pick perfect top one
everyone's going to do that right now
rendering partial rendering is very very
important another scenario where we have
same amount of rendering here we got
some rendering going on here and then we
have some rendering here and it's 3.2
seconds keep in mind this is completely
empty right here and then you have the
entire page which one are you going to
pick how many of you are going to pick
the first one very good what about how
many of you're going to pick the second
one completely outnumbered so everyone
as I can see 99% of people in this room
wanting to pick the first one so that's
where perception becomes more important
than performance and it's really the
difference it's just point two
milliseconds
oh sorry 0.2 seconds in this case so
we'll pick number one 214 rules of web
performance these are easy this book was
written I think about seven eight years
by Steve Souders you should grab a copy
read about it we're not going to get
into a lot of details about all this
because this is simple stuff we're going
to talk about the improvement on this
stuff which have been there lately keep
in mind those recommendations were
written for HTTP 1.1 how many of you are
already on HTTP 2 so this actually might
apply we'll talk about HTTP 1 - don't
worry so one of the most important
things to understand is that
at latency and bandwidth a lot of times
we go well I have really good bandwidth
all my customers are about 10 megabits
per second I don't really need to worry
about anything right if you actually
notice after five megabits per second
the bandwidth doesn't make much
difference the increase that you get in
your performance is barely any so
latency happens to be actually more
important and I'll explain that you in a
second time to reach the congestion size
of size n is uses this particular
formula so let's talk about this
receiving window 128 kilobytes
congestion window or receiving window
means if a sender has to send a message
to someone it says look I'm going to
send you something with 128 kilobytes
it's going to send an S Y N or
synchronized to the receiver and now the
receiver says okay either I can take it
or I'm not going to take it depends on
how much congestion the receiver has
right and that's how TCP works we're
going to see that in a second then you
have a round-trip time from San
Francisco to New York you have 42
milliseconds from San Francisco sorry
New York to London we have about 28
milliseconds right the round-trip time
is going to be double of that it's about
56 milliseconds so latency is 21
milliseconds round-trip time is 42 in
this case and then we have segments one
segment has four hundred and fourteen
hundred 60 bytes it's a lot of detail
here do not worry about it
divide that and you get 90 segments all
we need is 90 segments to transmit this
data over and if I get you the log of
this thing it's about 3.1 now this
particular thing is more like a roundup
so it's not going to be 3.12 it's going
to be 4 and right so in this case it
ends up being 4 so we multiply this by
42 and at 160 milliseconds for what just
128 kilobyte of data first time when you
connect even though we just have 128
kilobytes really barely anything just
because of the way TCP works even with
something that's small
as in a round-trip time of just 42
milliseconds we still took hundred and
sixty milliseconds so that's one thing
that we have to consider now this is how
you can see a three-way handshake how
does it work you have a thin or
synchronized and goes all the way to the
sender so this is our you know so it
doesn't really matter it could be either
ways because it's TCP anything could be
a sender or anything could be a receiver
so in this case you get 21 milliseconds
and then you get the acts the act gets
back to you at 42 milliseconds and then
you actually make the real request
assuming it takes about 50 milliseconds
on the server to process now you've got
your bytes and the bytes thought about
you know what we talked about so in this
case first thing what's going to happen
is 14 600 bytes they go all the way here
that's about 10x now previously TCP used
to have four segments now we have a 10
segment that's why 14 clicks into 10
bytes can go all the way here next time
it increases it doubles so now it's
going to be 29,000 and then it doubles
again it's going to be 58,000 bytes
right and then it doubles again but we
don't need that does the double of that
number is 1 1 6 8 0 0 but all we need is
29 200 bytes so we're going to be able
to deliver all this back in about 240
milliseconds if you see that bandwidth
would not really help you as much it's
really your latency so if you are very
close to your you know
client you would have gotten there way
faster even with 100 megabits a second
versus 10 megabits a second you're
better off if your servers are actually
closer to your user
because otherwise you're still going to
do what TCP does and it takes a lot of
time so a lot of people come to me and
say look I'm having a big issue with my
mobile and I'm like what's going on
well we're having 3 seconds 3 second is
our average request time I'm like is it
on the first load they're like yeah I'm
like are using 3G they're like yeah well
3G control plan could take up to two
point five milliseconds it might not
actually be your code you might be
better off taking them over to 4G or LTE
in certain cases you have clients
willing to pay
for these people to upgrade which makes
sense a lot of times you have clients
that are actually on Windows XP do you
have those we have those in state and
they're making you millions of dollars
you might actually just get them a
better laptop or pay for their internet
connection alright just kidding so
optimizing TCP now how do you optimize
ECP first thing upgrade your servers
because the last update was made in
about 2013 and a lot of people did not
really upgrade their servers one thing
you might want to do is go to ten
segments rather than the for the
previous one so that's one thing you
must do upgrade to the latest version
increase your initial windows size the
congestion window size which is your
receiving windows size on the sender
side you should increase it make it as
much as you want you can also enable
your window scaling it used to be 65,000
bytes and it's currently one gigabyte
that's one thing you should definitely
do now what slow start after idle so
here's what happens if you are idle for
a while then TCP goes back into an idle
mode and then start slow start again
what that really means it's still going
to go from smaller you need chunks of
data and then it's going to double it
and it's going to double it so if you
disable it then you're good because your
next connection would already be taking
a much bigger chunk of data that's what
you want to do so disable this makes
perfect sense you can also do TCP fast
open which is a better way of doing it
so now you can have more data back and
forth of course these two are important
things if you can eliminate a redundant
data transfer that's where your code
comes in you can also compress your
transfer data again you can gzip it or
something like that keep in mind most of
this is actually related to network code
is really a very small part of it at
this point of time at least and then you
want to reduce your round-trip times
again that's something you could do in
your code be smart about how you're
doing this and then you reuse your TCP
connections wherever possible so
fetching data using 3G versus 4G there's
not much difference in fact 3GS are
getting better too so it's SP a network
is getting much better so when you
you hear like 4G and you're like what
we're stuck with it should be a network
don't worry because it's also getting
better but the control pay plane says it
might take up to 2.5 seconds that
doesn't mean it's always going to take
2.5 seconds you can also have 3G
connections with less than 200
milliseconds totally depends on how
congested an entire thing is so more
tips reduce DNS lookups this is really
bad a lot of websites I go to they have
for example comm and it's going to MX
ample comm you've already lost 300
milliseconds right there so you don't
want to do that you can always have a
mobile version of it on the same domain
and then try to make fewer HTTP requests
gzipping is important if you were to
take one thing from the talk do it go
back home do it and you'll see how much
faster your entire website gets of
course use a CDN you want proximity and
CD ends are great for that you don't
want your own servers a lot of times use
them they're public
pretty awesome and then optimize it
optimize your images per device a lot of
times I've noticed to go to you know
companies and what they have is they've
got everything going on so for example
here is this big large chunk of image
which works on a desktop and what do
they do they're going to use the same
image compress it for the mobile view
that's not a very good idea you want to
you want to do it you want to have
separate images for separate devices
because Mobile's phones are not just not
just about space right it's about their
memory it's also about their battery and
you don't want to use their resources to
do anything with your data have your
mobile phone do the least amount of work
and you're going to have a happy life
adding etags so that you don't fetch
multiple data you don't want to do that
you want to create versioning that's
where you use e tags and then test on
actual mobile devices a lot of times
people test on emulators and emulators
are running on a desktop and a lot of
times you're not going to understand
what's going on especially when you
don't want to know what's the effect on
battery there's a study from Pandora the
data ever they were sending to like a
song or you know dislike a song was just
point two percent the data was pretty
small but it was sending beacons
when the beacons were being sent he was
taking 48% of the battery so they
decided to not do it at that time
because on a mobile phone the second
most important resource is a radio the
first one of course you know the most
intensive of all is your screen because
your screen is taking the most battery
but what's the number two resource
that's really it radio so what you want
to do is not use the radio as much so
you've got the screen you've got the
radio and in order to say a battery you
want to prefetch data what you don't
want to do is something like this you've
got a list and then you go okay well
let's number one here's a preview click
and the preview shows up and you make
another call to the server now you're
talking to the radio again
and it's slowing your user experience
down if the preview is small and you
have let's say 10 items bring all of
that data that's called prefetching data
a lot of people will be like lazy
loading is the best thing or not in that
particular case now if you have a lot of
data that needs to be pulled
well that better be a next page in
general because it's a mobile phone
anywhere and that's perfectly OK in that
case so minimize your data request and
then HTTP to you don't even know you're
using HTTP - if you are not right so for
example Google Gmail Gmail has been
running on speedy for a while and that's
really the precursor to HTTP - and it
doesn't really take a lot of effort but
HTTP 1 had a lot of issues for example
it wasn't the best protocol to download
multiple things because PCP would only
have one connection and now you can't
just have multiple downloads could you
do things like have a request and
response happening with the same
connection you just couldn't do that a
lot of those things are already fixed
for you in HTTP 2 and it's also
compatible its backward compatible so
moving here is not hard at all so this
is really good because they've got
binary framing which actually is faster
it can compress your data I mean it's
smaller and it's faster at the same time
you can have requests and response with
the same session then you also can do
parallel requests now previously there
was a limit I saw there is a limit I
think it was two for multiple downloads
and with
different browsers at 6:00 and 8:00 and
things like that but with HTTP 2 you can
have a lot of multiple downloads at the
same time which is pretty smart and then
it does header compression server push
is another really good thing so for
example you have a client and the server
wants to push a lot of data we don't
allow that right now just because we
don't want to overload the client with
HTTP - you can do that but the client
has a right to say no I don't want this
data so if the server already knows that
these are the 54 different files that I
want to send to the client and the
client is willing to accept it HTTP 2
allows that with HTTP 1.1 there's not a
really good way of doing it and then the
last thing is stream prioritization just
because you're sending multiple
resources at the same time you have to
understand that you need to be able to
do weight and dependency so we know on
the other side what order these
resources were supposed to come to us as
in the client right am I too fast I'm
trying to cover a lot of things today we
can also slow down and cover 50% of that
or you want me to go fast and cover most
of it fast looks like everyone wants me
to be fast perfect can't believe you
guys are awesome this is almost 5:00
p.m. you should be sleeping right now
all right
so critical rendering pot and this is
very important because it's really the
time taken to get to the first of render
up the page I'm not talking about the
first byte time taken to get to the
first byte as we saw is way faster but
sometimes the first render could even be
5 seconds later so how does it work
behind the scenes we just talked about
the network so if you are going to HTTP
2 you will not have to deal with a lot
of problems with HTTP 1.1 assuming we
got that fixed
we've got HTML and then we have CSS and
we have javascript with HTML we create a
Dom which we all know and then with CSS
we create a CSS object model and till we
take these two things and create a
render tree if we have any JavaScript
that's also part of the render tree but
what's really important is not the Dom
tree what's really important is the
render tree because there are two
different things and then we have the
layer
and then it gets painted to whatever
device you're part of and if you have to
understand performance all you need to
do is understand this particular diagram
and you're good to go let's take an
example so HTML you can do progressive
rendering so the way it works it gets
downloaded and by the time it's got till
here
we're already creating our Dom right and
this is going on it might not have even
got to the link element yet so you can
see I don't have the right-hand side of
the equation this is how this is going
to look at this point of time the title
will show up actually and then let's go
a little further than assume that we got
everything else in this case what
happens is we get our CSS which is here
so we've got the div and that says hello
world and we have a paragraph which says
hidden and it's really a display:none so
if I were to go back it has a
display:none property so this is part of
my Dom but this will not be part of my
render tree right because that's exactly
what we're trying to paint so if I were
to go a little further and go look at
this diagram now we have the render tree
and the render tree is going to be just
this guy we won't have this part is that
clear so now render tree is really
creating the layout which gets painted
to whatever device were part of so
that's what's happening here
so we don't see hidden but we see hello
world so tip stream HTML because it's
progressive so what you want to do is
let it come down as it is and it's going
to start progressively rendering itself
right when you're doing progressive
rendering you also want to make sure
that you want to do server-side render
HTML because what you don't want to do
is have the client-side render your
first HTML page because it's going to
take a little longer right so the first
page at least has to be server-side
rendered after that you can choose what
you want to do then you have critical
CSS why do you want it inline if you
read Steve Souders book he actually says
that what you want to do is you want to
package all your CSS and bring it back
together which is a great idea for HTTP
1.1 but you still want your critical CSS
in line because what you don't want to
do is wait forever before your render
tree gets populated critical CSS is the
minimum CSS you need on your home page
right and that needs to come in inline
it's going to increase the size of our
HTML a little bit and that's perfectly
okay but we're only talking about the
critical CSS now keep in mind CSS also
blocks you so if you got 20 different
CSS files together in one CSS file it's
going to wait for the entire file to
load and then it's going to create the
CSS object model because it's not you
know because it has to take in account
that there could be another file that
has some Styles that have to be part of
the render page so that's another tip
you might want to make sure that if you
have any critical CSS on that set couple
of files you might want to just coalesce
those two files and leave the 18 away to
come in later right so that's one thing
because we need progressive rendering
now javascript is important and this is
very blocking the reason is simple
that this can also change the DOM and it
can also change the CSS object model so
by default it must be blocking so let's
focus on this part now javascript if you
want to make sure that you have
something third-party like analytics you
want to make it async why do you want to
make anything because you don't want it
to block it now this will block so a lot
of times you'll see that people will
tell you that hey take your script and
put it at the bottom right here right so
right before the end of the body tag
which i think is a very good idea for
the most part but what if you have a
single page app your angularjs code it's
not going to lie in here right it might
have to be somewhere here so that's
again part of your critical JavaScript
and it's okay to put it up there but
remember it's going to block a lot of
things now what happens with the async
file it will also execute when it's
ready so that execution will take time
so let's say this is about 120 kilobytes
and you're not going to use it on home
page
but you might use it on different page
in a single page application scenario
what you're doing is you're also paying
for that execution right so that's one
thing to keep in mind in this case we're
already paying for blocking parsing and
executing it's going to happen and
nothing is going to happen before that
right so we're making it wait now this
is a design question for you guys and
you can take your decision in your own
way in the order browsers if this is the
timeline this is what happened external
script one came down and then you had
parsing and execution which is taking
another let's say 500 milliseconds and
then you have another let's say you know
500 milliseconds of download another 500
milliseconds of execution and parsing
and then you can get these so what's
interesting is they did not even allow
you to download anything because it's
all blocking and they're also not doing
anything
multiple downloads in this case this is
older browsers well then one fine
morning they realize it was not the best
thing to do so what they did was all
right we're going to get all these but
we're going to wait and then we're going
to execute them even though we can get
all of them in parallel we're going to
still execute them in a certain order
which kind of makes sense so you parse
them and execute them and then you have
the other things coming down now if you
want to play with this there's a really
good resource gazillion created by Steve
Souders so you go to kazillion com you
can say here here's an external script
and then I'm going to put an inline
script external stylesheet and image
sorry
oh you see it something like this and
then say create and before that I just
pull up my network tab wow that takes
forever
that's our Wi-Fi and you can check the
timeline you can see a lot of these
things so if you did not have a script
then you could have had CSS and you
could have add the image downloading in
parallel which is perfectly okay alright
so look at this because it'll give you a
good idea we're not going to get into a
lot of detail here back to our
PowerPoint we can cover a lot of these
Wow
okay technical issues it's not as fast
as our website yet PowerPoint is not
fast as fast as our websites right we
pee it faster websites than the
PowerPoint
just kidding was a joke next time I have
a joke I'm going to raise my hand so you
know it's okay all right
so Gmail Mobile they did a very good
technique there they realize that there
could be script for example you go in
Gmail mobile and you say okay compose
and you may not just use it you might
just be checking your emails and on that
page you might never use compose
so what's the point of getting that
additional 100 kilobyte of code and then
executing it so this is what they did a
very smart hack so they went inside
their script tag and you know commented
their code and anytime you wanted to use
it all that it is get the script tag
element from the Dom and remove the
comments and then eval their own code
now evals not good for security reasons
but evolves completely okay for your own
code so that's not a bad hack but it's
interesting because now they're saving
time on execution which is a very smart
idea there's another way to do this too
you could also do script type equals to
you know source equals let's say your
javascript file dot XYZ now you change
the extension because the browser's not
going to execute it you can get that an
async download and you change that
extension and then you can change the
extension back to j/s and execute it
when you want to execute it especially
something that complicated like a gmail
on a phone
you want to create you know keep your
resources so there's something called
control yes you can look at it Steve
Souders created it very good library
does very similar stuff now javaScript
can block CSS it can block the Dom so
you want to use a thing but you want to
avoid document dot right in the middle
of the page you document all right it's
going to block everything else so if you
have to force something right
that's when is to be blocked that's when
you use document all right so document
dot right has a picture as part of it
well then you're blocking the execution
and if you want to do that only then use
it so you can before everything except
the critical script everything else can
go back to the body tag which is a good
idea again
all for HTTP one so critical rendering
path let's talk about layout and paint
so this is where you have 60 frames
equals to 1000 milliseconds what that
really means is one frame should be
rendered in just 16 milliseconds now how
does that work in order to get a frame
rendered really what you have is your
code and then you have garbage
collection then you have layout and you
have paint not necessarily in that order
what you really have about 1011
milliseconds because the rest of the
time is going to be used by the browser
what happens if it is beyond 16
milliseconds your frame gets dropped and
that's not a good thing so you need to
make sure that you're always checking
this so do you want to see an example of
this so here's an example from cnn.com
and the way you check this is you know
you go to your performance tab and look
for these red signals did recently
changes so I'm going to try this all
right so if I were to pick any of these
red bars I could come in here and hover
and you see it's 5 frames a second
that's really bad right now you can come
in here and go here and you can just try
this and it will be like one frame the
second year there's really nothing going
on there one frames a second I mean and
this is how you can check your entire
code
actually that just happens to be that
particular segment that we're not even
getting anything that's good so that's
an example here's where you can find out
your frames and then get more details
about it and you can also dig deep into
it where exactly you're having that
issue right here and work with it but
this is one thing I would do maybe part
of your testing now speed is a feature
for us a lot of times speed it just
happens to be one of the things write
performance has to be a feature it has
to be part of your agile you know chart
basically like okay well here's the
story on performance and that's where
you might want to take care of a lot of
these things so how does the layout work
so when you are resizing you know you're
adding or removing nodes you're changing
styles at that point of time you're also
changing the layout so let's look into
this that was a simplified view of a
frame but let's take an example like
this so for example you have elements
and you're going through elements and
you say alright element are styled left
equals element offset left plus one what
do we do we're making changes here first
where we're actually creating this value
then second were updating this when we
update this it's forced to actually
paint so this layout is now forced so
what's happening if you look at the
color green that's the layout right so
got my code and then I've got my layout
then I got my code then I got my layout
imagine this happening let's say a
hundred times now I'm doing that here
right and it's a very expensive
operation and then finally paints going
to happen so this is not a very good
thing so when you're applying your
visual styles really you create the
bitmap and then you pixelate the screen
and that's really paint right so the
previous one was layout this is the
paint process so what do you want to do
you want to update the minimum area
that's needed and then make sure that
some styles that are more expensive we
take care of them in a different way
we're looking
some examples so something like this is
a very bad idea because it's actually
doing reflow which we'll talk about in a
second so we're doing that one two and
three so we're doing it three times now
this is expensive because you are
forcing a layout we're forcing a paint a
better way to do the same thing would we
take something like this you have a
style and then you have a CSS text or
even you can even have a class name here
and say well add it to the particular
class and then you can add a colon
semicolon here and then add the style to
the class or you can override a class or
you do something else but now we have
everything in one line and this is going
to be one operation to paint the same
exact thing right
a lot of code like this is everywhere I
mean you just go to almost every website
out there right click on the view source
and you'll get a lot of code like this
but it's an expensive operation the best
thing with html5 is that we have the
same spec across all browsers so
previously there was a lot of difference
but now most of them will handle it in
the same exact way I'm talking about the
primary browsers so it's very
predictable here's another example this
is inefficient because here's what I'm
doing I'm getting an offset left adding
pixels to it and then I update that
value right here so I'm also looking for
that value and then similarly updated
and then I do the same thing here and
then if I'm checking for this particular
value which I've already used here so
what should I really do I should cache
that value because why would I want to
look this value up every single time I'm
using that's a really good pattern in
JavaScript in general anytime you're
doing this for example document dot you
know get elements by tag name and you
have a bunch of elements what you don't
want to do is take that and then look
for element number nine every single
time you do that what you want to do is
take that value put it to a local
variable because that's now cached so
this needs to go in a local variable
that's the first thing so we take this
out we see at a local variable so now
we're not doing a lot of lookups and
then we can say left is this and then
top is that and now we're checking for
this
this and that's how you're saving
performance here right and then if it is
greater than 500 do something with it
the most expensive part of the entire
process here is paint so what do you
want to do you want to make sure that
you use it the least amount of times
right anytime you change the property
it's going to trigger a paint now keep
in mind layout automatically triggers
paint so anything we did right in case
of layout needs to stay with us because
if we change the layout paint anyway
it's going to happen now
it can also trigger paint without layout
if you change the background you change
the text colors you change shadows so
there are a little bit more expensive
the shadow is a little bit more
expensive than a regular style for that
particular reason so reduce the paint
area one good way to look at how to
reduce the paint area is now that takes
forever all right
so we go back here let's say you have a
game right this is where you can see it
so you go to these tools go to more
tools and then go to rendering and this
thing pops up and then you click paint
flashing you can see if I remove this
the green color is going to go away so
what's happening in this game is that
the entire block is getting rendered in
fact the entire page is getting
re-rendered which is not a very good
idea so let's just go to something else
let's say google calm actually let's
just do it right here so in case of
google calm you can see that the green
layer is just over there so that's the
only thing that's going to change so
that's the only segment that changes
whereas in the previous one you have the
entire page re-rendered every single
time and not a very good idea right so
those blocks you can identify those
blocks in your code and then work on
fixing those one by one
you
so reflow let's talk about reflow
whenever you resize a window this is
going to happen right so when you're
resizing a window let's say you have one
tree one render tree and you resize the
window let's say you go from a tablet
view to a mobile view this is going to
happen right when you change the font
this is going to happen when you change
certain classes like hover change the
class attribute you can also calculate a
offset width height and this is still
going to happen and reflow is very
expensive
when reflow happens what happens next
first of all if reflow changed an
element it's going to change all the
child nodes it's a really bad thing
second it's also going to talk to
everything that's following it and it's
going to reflow the entire thing so it's
repainting that entire things it's not a
very good idea effectively the entire
page is read rendered after that element
so there are certain ways you can
prevent that now we remember that one
thing we talked about was that if you
don't if you have something as
display:none or it's hidden it's not
part of the render tree and anytime you
work on something that's not part of the
render tree reflow won't be triggered so
what you could do is change the
visibility to hidden work on it and then
replace it back and say visibility block
very smart technique but you've saved a
lot of your overhead your performance is
going to increase drastically so let's
take an example for reflows you can also
use a fragment so you go to document or
create the document fragment you take
that fragment and say okay here's my
element which is P and I have contents
of that element I've got all of that in
my fragment go append that particular
Dom element now and then append that
fragment to the Dom this way we didn't
manipulate the Dom and we did not cause
reflow to happen which was actually the
more expensive operation so this is
another way of doing the same exact
thing
you can also clone that particular
element so for example you have
container and then you clone the
original element work on it once that's
completely done replace it back right
here and you can do the same exact thing
keep in mind it only is a problem if
you're working with something in the DOM
if you are working with something in
memory it's not a problem but these are
very simple things you know a lot of
times you look at this code you can
oversee it because your junior developer
might not know what he was doing but
these are certain things that you want
to talk to everyone in your company in a
brown max session and say look we have a
policy we're only going to do this and
you can show how expensive it is by just
showing one of the chrome developer
tools or any other browser you use so
here's another one that I talked about
where the display was none we make some
changes and you can do any amount of
changes right over here you can actually
go and do another 10 15 lines it's not
going to make any difference remember
previously we had three styles and I
said we don't want to do it three times
so let's get into a class in this case
what I'm saying is it doesn't matter it
could be any amount of changes at this
point of time you can have 10 15 20
doesn't really matter once you've done
all of them all you're saying is display
block so you can choose any of the three
techniques right one thing you have to
remember about the document fragment is
if you have a form you can get into
issues with it because there's a lot of
things going on in an actual form so be
careful with that approach thought
leaders to follow the really good people
they've got a lot of free content out
there I think more important than any
books that you want to read because most
of them are actually outdated these are
the right people to follow maybe take a
picture of this and you can take my
picture if you want ok and yeah I mean
there's got a lot of good stuff and then
books you've got computer networks by
Tenenbaum I highly recommend it I read
it during my Master's it's very very
good there's a lot of good stuff that
you still don't find anywhere else it's
got the fifth edition now you know and
it's updating you your Gregorek has
written a very good book I think there's
a little bit overlap there but
this book is still worth reading a lot
of good stuff especially about networks
as a developer you might not have ever
gotten into networks as much especially
if you're not done computer networks as
part of your courses a good refresher
and he's updated the content quite a bit
it's also I think this one is available
online for free high-performance
JavaScript a lot of what he talks about
is great for when you wrote the book I
would highly recommend testing a lot of
things because at this point of times
browsers have got better so a lot of
times you'll see is like she'll give you
ideas which I think are good ideas but
at the same time those things have been
fixed in most of the browsers so when
you read this book I would also do my
own testing and then high-performance
websites and I think he's got a second
book - so this was 2008 I think or nine
and then later he comes up with another
book which i think is another really
good book where he has a lot of update
whatever you see here is great but then
he's added a lot to it later and we
touched upon a lot of those concepts -
all right so let's talk about some code
because we have some time I believe how
much time do we have we have 10 minutes
perfect all right so let's take an
example here I've got something called
an car object it has images length a lot
of times you'll see this in your loops
and keep in mind loops are not always 10
I've seen loops that are sometimes
10,000 which unfortunately exists in a
lot of actual code so what you want to
do is do something like this where you
know you get the images now you have
card or images because imagine in this
case you're always making that call even
though you're part of the same loop the
value shouldn't change but you are
assuming that they might and that's why
you're looping through it so once you
cash that object everything else becomes
easy so that's a typo it should be
images length and sometimes you're even
better off cashing the length you can
just take the lens out why do you want
that length to be you know calculated
over and over again so really what you
do is more images equals card or images
and then you can do images of length
equals two images of length I is less
than
and I plus plus and then do whatever you
want to do here so that's a little bit
more efficient another one oh we
actually I just talked about that so
second example is just building on the
first example where now I'm caching the
length and now it's less than Len Len
equals 2x dot length you could do it
part of the loop you could do it outside
the loop inspection time so for example
here you have elements and you are
trying to get all the elements this is
not a very good thing because it's a
star and assuming you're dumb is big
this is a disaster so here you have all
elements and then you're going to loop
through all the elements all the length
and then if that particular guy has that
particular attribute then do something
with it right so in this case what you
could do is document dot get element by
ID and go for that particular ID and
then get elements by tag name now I
still I'm not a big fan of stars anyways
because if you really have a way to
locate what you're looking for you can
also say well maybe it's a div but if
you know it's but they've only or it's
multiple things you're better off doing
that rather than a star but the point
here is that you're trying to zero in
and reduce your overhead by making a
smart decision up front about what
exactly that element could be is it is
if I already have the ID and then I know
the tag name which is a div or something
then I have a much more specific search
and it's going to be having less
overhead so var I equals zero is less in
length
I mean it's same exact code and it works
perfect XPath now XPath is actually
faster than going through the Dom so if
it's supported you're better off using
that sometimes it could be twice as fast
right so that's another thing that I
would I would look for not all the time
you need it because you know you could
actually catch the Dom and do some use
some of the techniques that we use
previously but it's also available there
there's more detail here that was the
source and then avoid keeping alive
references this is very important thing
a lot of times in JavaScript we keep
things alive that we shouldn't
and that's very important so for example
you have an iframe or you have something
else right now that's a remote document
and you also have now a reference to
that particular remote document and then
you did something with air you got the
element by D you got the content and you
have the remote container and then you
know you create the element and then you
appended the child and then you clear
your text node and you add that content
and now you're really done with it you
got to make sure that you do this at
this particular point of time right
making it now now a lot of times people
also use delete keyword to delete these
and sometimes they do no so I'll tell
you only one pointer there if you
actually go on your regular you know
global scope I'll just show you that
example in code
so let's say you were here and you've
got some kind of script going on and you
are in the global scope and if you do
water x equals 10 s equals 10 and VAR y
equals to 20 can anyone tell me what's
the difference oh sorry
can I tell me what's the difference now
oh my god it's an S and a y is the hope
you're looking for so London is amazing
and for the last three days I've been
sleeping around 4 p.m. and today I was
supposed to talk
that's called jet-lagged anyone
different why they're both global that's
actually a trick because a lot of times
you'll think that one is global right
they're actually both global because
they're part of window object right now
if they were in a function then it would
be a different story but currently
they're both Global's is there part of
script anything else wild guesses it's
not an easy one so I'll show you this so
we're going to do F and then we got y
Thanks can anyone tell me what's the
answer we're going to print four things
what do you think are the values all
right let's try this
you see that Y is not defined but I was
able to print s second time even after
bleeding it
so what's amazing is that I've asked
this question in more than 25 different
cities in five different continents of
the world no one gets it right that
tells you something about JavaScript it
is not you trust me this should not be
this way put it that way so here's what
happens if you actually use a VAR and in
this case you had used wor with s and it
said Y is not defined because Y got
deleted but s didn't get the leader
because used a var if you use a var in
the global scope you can't delete that
particular object it's interesting so
that's why I use the approach in that
case to say S equals null in the last
slide I do not say delete F because
that's I'm not going to call it bug
because this is the specification of
Xmas trees right so but this is one
thing you need to know now imagine you
had a really big Dom element like an
object with let's say 35 different
tables that's not possible only 32 right
anyway some things have big you can't
delete it and that's good to know right
so what you could do is either make a
null or even make an empty string
whatever I prefer no that's what I would
do
cool that's it any questions yes
right so the problem is reflow is it's
an expensive operation and it's going to
rent read under everything every single
time so reflow anytime that's being
called it's a better technique to do
something else now cloning I know it's a
it's a big thing in that case right so
that particular example is not the best
example what you could do in that case
is just hide it and then convert it back
to block simple it totally depends on
where your object is placed let's say
you are the last thing on the page then
you're perfectly okay but if you're
somewhere in between then your rear end
during the entire page pretty much right
so even that one reflow is really bad so
I would not do two because it will
happen very quickly twice oh yeah every
single time but if you clone it the way
I explained is it's only going to happen
one time
okay so for one property that might make
sense but for two it may not so question
does anyone know what the question is so
the question is that do we do it
whenever the reflow happens you know it
happens just because we did something as
in we change the style element or
whatever and what is that trust hold you
know so basically like do we wait if we
have three different changes to be made
and we do it that way or we just do it
every single time right so I would still
go with the same approach that if you
have style changes then do the first
thing that I showed which was don't
worry about anything just one time
create a class and add all those Styles
in a line and then push it over that
would be my first approach because that
doesn't require you to do hidden or any
other thing that I showed because
there's three other ways you could do it
right so what anything small like that
do something like this which is very
simple you don't need to do hidden you
don't need to do fragmentation or
anything else right now what's the
second approach where you really want to
deep clone the object because there's a
lot of changes you're needing right in
that case and that's perfectly okay so
that's my take on it
I would not overdo it right but remember
every single time you have that line
it's reflowing the entire thing which is
a very expensive operation and if you
have that pattern in your code you want
to kill it and let everyone else know
that do not do it because you might
start with one but someone else might
pick it up and add few things and now we
have another problem because you can
always look at the entire code right I
mean it's two to five million lines of
JavaScript code average in newer
applications now so I can't personally
check the code my team is doing with 200
other people any other questions
I'll stick around but you are a very
amazing audience thank you so much have
a good day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>