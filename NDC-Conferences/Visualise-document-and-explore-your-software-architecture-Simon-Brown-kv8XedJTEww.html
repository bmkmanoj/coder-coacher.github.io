<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Visualise, document and explore your software architecture - Simon Brown | Coder Coacher - Coaching Coders</title><meta content="Visualise, document and explore your software architecture - Simon Brown - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Visualise, document and explore your software architecture - Simon Brown</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kv8XedJTEww" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everybody thank you for
coming on this talk is about a bunch of
different things related to software
architectures about visualizing
documenting and exploring said
architecture I'm going to start by
taking on a short journey imagine the
year is 20:57 and we finally invented
teleportation hooray
so now more airplanes jet lag is still
an issue of course and I teleport that's
all right now to there where are you
LaRue yeah France is a very good guess
there's a looks like as a French road
here you have a couple of ways to solve
this problem option number one is you
walk down this leafy Lane and you try
and find somebody to speak to you say hi
I'm lost where am I
and they can help you out the other
option is to cheat for those of you who
went to the opening keynote there's a
thing called GPS we now have so you get
your smart phone out you open that maps
app and it tells you you are here
where are you still doesn't really help
does it
we're still a wee bit lost here we can
see our precise location accurate to
them within a few meters of course but
we're still really none the wiser so in
order to solve this problem we need to
zoom out so this is where I live this is
Josie the Channel Islands so small
island just off the coast of France
anybody been to Jersey maybe a couple we
can fix that don't worry this is a very
cluttered complex looking picture isn't
it it's got lots of greens lots of
textures on here it's kind of hiding
lots of the detail it looks like we
don't have many roads how do we solve
this problem let's take off the
satellite imagery so now I have a
slightly different view of Jersey and
now without that satellite imagery we
can see the intricate networks of roads
and lanes so now we can potentially
navigate from one side of the island to
the other if you don't know where Jersey
is you have to zoom up one more time if
you don't know where Jersey is still you
have to keep zooming out and zooming out
and zooming out to put Jersey in context
so those you who have not been to Jersey
before when you come to Jersey in the
summer for your summer holidays when you
should because it's beautiful I'm not
being paid by the jurors and Jersey
Tourism Board when it comes to the
reports you should pick up one of these
things it serve Vista map and the
visitor map tells you enough information
to start exploring our beautiful little
island so very very simple small map
because it's a small line of course
looks kind of like this and it's a
simplified view of the world it's mostly
accurate has all the major place names
the major roads the major routes has not
got all of the intricate details if you
flip the map over to its back there's a
summa of the town view now we can see
some street names and some place names
again it's mostly accurate you see this
thing here so that's a marina and it is
blue because there's water in this
marina but there's water here for half
of the day only we have huge tidal
ranges in Jersey so if you kind of drive
your boat in and park your boat there
and go shopping in town if you come back
six hours later you'll vote your boat be
on its side on the sand so again this is
a mostly accurate map contrast this with
an Ordnance Survey maps so this is a
much much more detailed model of Jersey
to visualization of a model created
using or now we'd use drones of course
but aerial photography and site surveys
and all this sort of stuff and it's got
lots and lots of information on here the
different textures represent different
types of land we've got contour lines
we've got every shape of every building
this is super super accurate super
precise but it requires a bit of
intelligence to understand what this
thing is showing you the thing that all
these maps having in in common of course
is points of interest so when it comes
to Jersey you should go and see a bunch
of sites points of interest one of these
things is called a list with Castle it's
a small island just off the south of our
Island it's a it's a castle built in the
15th or 16th century
beautiful looking cars so lots of
intricate granite stonework basically
built to protect Jersey from the French
or the British whoever is invading at
time and this happen like Jersey's
history of course and when you take a
walk along this castle there's a natural
high point where the towers are so they
can survey you know everything around
the castle and if you get closer and
closer and closer you start to see
something very very weird you have these
beautiful granite stone work things and
this really weird-looking concrete thing
stuck on top can anybody have a guess as
to what this thing is where it came from
so the answer is in the history and when
you go and walk around the castle
there are signs telling you about the
history and it turns out in World War
two
Jersey was one of the only places in
Europe occupied by the German forces the
German forces imported a lot of concrete
and they refortified the existing
fortifications and that's why when you
go and drive around Jersey you see lots
of gun emplacements and all these sorts
of weird-looking towers and the history
tells a story so if I sold you on Jersey
you go buy your ticket you go through
Oslo Airport you have to connect through
London of course and you pick up
somewhere on route a travel guide book
and the travel guide book tells you
everything you need to know it's a nice
short lightweight piece of documentation
tells you the sights and the points of
interest it's got a bunch of maps in
there the maps help you navigate tells
you the practical information some stuff
about the history and the culture and so
on and so on
cool
so that's my introduction to Jersey
somewhat randomly but I promise you
we'll come back to stuff later so we're
into web software architecture
specifically visualizing documenting
exploring software architecture and we
should first step back and say well why
is this stuff important and of course on
any software team on any software
project there are a number of different
types of stakeholders who might want
information about your soft
systems that you're building technical
people non-technical people and
everywhere in between of course so the
primary use for diagrams and
documentation is is really learning and
communication so that new person joins
your team they want to get up to speed
quickly it's also to a degree about
architectural improvement so if you have
a good set of diagrams of your software
system and these diagrams are somehow
connected to your code you can use these
diagrams as a tool for doing
architectural improvements especially
large-scale architects refactorings for
example social web visualizing first one
of the things I do is fun my day job is
I travel around the world and I run
architecture workshops and as part of
these artists workshops I give people a
set of requirements as a two-page
handout I say break up into groups of
two to four people go away for an hour
and a half draw some pictures to somehow
you know visualize the design of this
thing that allows you to design and it's
fascinating because I get all sorts of
crazy pictures so these are real
pictures from real workshops I promise
I've not made any of these things up
this is just a bulleted list of
technology choices in a diagrammatic
format this one here is like a boxes of
no lines diagram because as boxes and no
lines you notice at the top there's an
asp.net web app doing something with no
users which is a bit odd this is one is
what people often refer to as a
functional view it's just a list of
stuff imagine you've bought a nice plot
of land somewhere and you've hired an
architect and you've asked your building
architect to draw you a functional view
of your new house eating sleeping dining
entertaining or just you know bathroom
whatever it's not particularly useful
diagram this one here is one all-time
favorites the central spine kind of
makes sense the central spine of this
diagram shows you that we are importing
some data with performance and
calculations we're generating the
reports and then we're just using these
reports
and then all hell breaks loose so that
thing there is really important and I
know it's important because everything
somehow connected to it this is like
Frankfurt Airport Schiphol airports
London Heathrow Airport it's a big
Airport hub lots of routes around the
world on the other side it's just a
complete car crash we've got different
shapes and colors and line styles and
all sorts of craisins going on this one
here represents every single software
system you are currently working on
today the red box is your system
boundary inside your system boundary you
do a bunch of stuff and most importantly
somehow you do some business logic yay
this doesn't even tell you anything like
the business domain that we're operating
in here this next one is what people
often refer to as a logical view again
it's just a list of stuff it's a very
fluffy very high-level very conceptual
picture doesn't really tell you anything
interesting this one here is you know it
has some good points but there's no
technology choices on this diagram
whenever I run my offset to workshop
it's really funny we spend the first 30
minutes of the workshop discussing
architecture and everybody in the room
agrees that architecture is about the
significant decisions significant
decisions includes technology choices so
everybody is good with this when they
get to do all the diagrams there are no
tech choices ever which is fascinating
you've heard of pocos plain old C sharp
objects I imagine this is the Homeless
addition the ho Co homeless old C sharp
object at the bottom there is a sequel
server database at the top there is a
box labeled application console c-sharp
and all of the other boxes on this
diagram are basically annotated c-sharp
so there's a logger thing a data loader
calculation manager so we have just a
bunch of c-sharp things objects or
services kind of floating around I think
what this diagram is really trying to
say is there is a c-sharp application
talking to a database and all of that
stuff
lives in it so I want to draw some
boundaries to give all these c-sharp
things at home essentially this is
another one of my all-time favorites
when I was a kid we had the story books
ever called fighting fantasy books they
would choose your own adventure books
you would start from page one read
through ten or twenty pages to set the
scene create a context to the story and
then as the reader you get to choose
where the story goes next depending on
which page you turn to so you have a
choice this diagram is the same type of
thing you start the top you go down
through the diagram you get to follow
different paths through this system
there's the fail events the complete
events the reject events over here when
I read these books as a kid my character
always died super annoying because then
you have to basically start from the
start again the diagram is essentially
the same because no matter which path
you choose they will lead to the trap
it's no escaping the trap it's all one
color it's showing a much more kind of
complex asynchronous event-driven style
of architecture there's some funny
symbols it's just it's just lots of
stuff going on here this is what a lot
of Micra services architects just look
like now by the way all of this stuff
for look adding two numbers I like
people on diagrams because people show
me something about how how people
interact with the stuff you're building
but we need to give them a name I'll
always they're just storm troopers their
faces clone somehow attacking the system
this is very bad of course and white
boards are useful always we get pictures
like this so yeah we don't need this
thing here we'll scrub it out we don't
need that line there oh yes we do we put
it back sorry and we say that naming
it's hard yep take this to its logical
conclusion you get stuff like that this
started out life as an entity
relationship diagram you can see the
little crows foot symbol somewhere on
the on the left hand side the box and
the sensor I think was important because
it was placed in the center and
everything links towards it
and then this group in their infinite
wisdom scribbled out that middle box now
the diagram makes no sense whatsoever
however they still delivered it as part
of their deliverable pack and that stick
you know is the feedback a I have
I'm not kidding like 15 gigabytes of
diagrams like this I could show you but
we've got more important things to talk
about when I'm running these workshops
especially if I'm doing in an
english-speaking country I can kind of
listen in to what people say and
sometimes when I'm listening in to what
people are doing in their groups they'll
often say this so if we're doing a box
or a shape or a line or some symbol and
they'll say this doesn't actually make
sense but we'll explain it later and
unfortunately later never comes because
what I do is a really nasty trick and if
any of you who have been in my workshop
you will have yurov experiences
firsthand what I do is I get groups to
swap pictures so each group is working
like an hour and a half in their own
little bubble in their own context
they've created their own notation their
own color coding their own symbols an RS
each group to go and review someone
else's pictures and guess what happens
they can't do it and sort of say well
okay you don't understand the pictures
tell me why and they say yeah we don't
in turn the color coding we don't
understand the symbols and the lines and
their notation and just the whole thing
it doesn't make any sense and it turns
out this exercise pretty is pretty tough
the design part of the exercise is dead
easy - really really small set
requirements but the visualization
aspects are super super complex
apparently when you ask people what they
find challenging they say things like
yeah we didn't really know where to
start we didn't know what types diagrams
to draw one notation to use what level
of detail we go down to both in our
design thinking and in the visualization
aspects and so on and so on now I should
probably add at some point I have
absolutely zero empirical evidence to
back anything up in this talk nothing so
that's my cards on the table moment I
have known probable evidence I've done
no academic research no studies nothing
however I run this a bit in 25 plus
countries for thousands and thousands of
people all around the world so
anecdotally I can say that people
generally struggle with this and now if
you're in a software team and you want
to move fast you want to be agile or
have lots of agility you need good
communication and it turns out that
architects really struggle with
communicating architecture what's funny
about this thing is that sometimes I run
my workshop and an organization will say
Simon we're going to send our best
architects along and I'm like oh no not
again
because what normally happens is that
these people fail the the most are doing
this task because they're the furthest
away from the code often and usually
it's the most unions developers who have
a much much better handle on the code so
they're able to produce a lease
architected diagrams that make some
sense in the real world context if
you've never done this sort of thing
before you could go and ask some friends
and colleagues I've been asked to and
I've set two diagram help what I do they
may or may not be able to help you of
course or you could just go cheat and
ask Google if you go and ask Google what
it thinks an architecture diagram looks
like it gives you that and you carve the
page after page of very pretty colorful
block pictures seen these things before
do these look like diagrams on your
wiki's yes I have also sinned
I've drawn these pictures in the past
but now I have seen the lights look it's
bathing me currently these pretty
pictures drawn a vision PowerPoint
whatever exhibit a lot of the same
problems I see during my hand-drawn
workshops now you might be thinking well
we have a notation in the software world
called UML and UML is possibly the
standard way to do this stuff so who
here uses UML let's try this now I
reckon that's like maybe 20 percent ish
respects question.what announce that we
are seeing of course again I've asked
this question all around the world I
have no academic research backing this
up it's about the same sort percentage
some country seem to be much stronger
than others so if you go to the
Netherlands in Germany you tend to see a
high percentage I don't know why I'm
seeing a lot more organisations now when
nobody knows anything about UML and I
can see this because some of the
universities are no longer teaching UML
because they realize that industry
doesn't use it just like a vicious cycle
of death almost for UML let's be fair to
UML here there is lots of good stuff in
UML I do use your mail but I don't
necessarily use it for doing
architecture and there are a number of
reasons to this one of the most simplest
it doesn't often have the abstractions I
want to talk about if you want to draw a
picture showing a user using a software
system you end up well there's no
software sister box in your mouth of
course so what you end up doing
something like this you use a component
symbol with a software system of
stereotype and that's allowed but it's
just a bit funky pinnacle Christian back
in the late 90s peering created this
thing called the 4+1 view model of
software architecture and he basically
says this to describe a software
architecture we use the model composed
of multiple views or perspectives this
is what the four plus one model looks
like basically what you do is you take
all your important scenarios and you
document them you describe them from
four different angles the logical view
is like the high level fluffy functional
conceptual building blocks the
development of you talked about how you
map that stuff to code there's a process
he talks about concurrency and that sort
stuff and there's a physical view to
expect infrastructure and deployment
that's not the only approach a couple of
friends one in London own woods and it
rozanski they wrote this book here which
I'd highly recommend software systems
architecture and they have a model a
called viewpoints and perspectives and
what they've done is they've taken four
plus one and they've extended it
and in extending it they've also changed
and tweaked some of the names because
they felt their names made more sense so
you'll see here a functional view points
rather than a logical view every
architecture book you read will do
something similar they'll change the
meanings of these views I hope that's
not a fire alarm it's just someone
honking their horn outside so one of the
things you'll notice about lots of these
approaches is that there's a separation
between how we view a system from a
logical perspective and how we view a
system from a developmental technical
perspective and that's kind of weird
I don't exactly know where this has come
from but my suspicion is if you go back
20 years we used to do like a logical
design phase so that logical design
phase was done by architects so you get
a nice high-level logical view of your
system and then they would hand that
over to a team of developers who would
do a bunch of lower-level development
stuff so maybe the previous and prior
separation of roles led to this stuff
happening but the problem with this
separation between the logical and the
development view of a system is that you
get diagrams that don't match code
anybody seen this yeah so you have these
beautiful a zero plots of printed
diagrams from 10 years ago because
they're too hard to reprint but they
don't match the code anymore in fact
they never did in the first place this
is something that a friend of mine
George Fairbanks calls the model code
gap and again this is a great book if
you're interested in software
architecture the model code gap is
essentially you have a bunch of diagrams
high level model of your system and
these things never match the code why
very simply because when we're talking
about architecture in air quotes we're
using abstract concepts like components
and service and subsystem and so on
quick show of hands who's a c-sharp
developer here I'm guessing that's
pretty much everybody excellent so in
c-sharp is there a component keyword
no in c-sharp is there a layer keyword
no yet these are two terms so component
layer that we often use when having an
architected discussion and because
c-sharp for example doesn't have the
same terms that the mapping between our
architecture diagrams and our code is
often not clear that's essentially what
the mario code gets all about this is
not a new problem you can trace this
right back in time first through opening
paragraphs this paper tell you all you
need to know you ask any engineer to
draw a picture of their system you get a
nice high level picture that's the way
that they think about their software
that's their mental model if you were to
find some tooling and reverse engineer a
diagram from the code you get a very
very different picture that very
different picture of course this very
low level it's very precise there's not
necessarily how the engineer or the
developer thinks about their software
system it's the moral code gap so that's
where we are now and we have a bunch of
problem to solve here and one of the
most fundamental problems here I think
is we lack a common language even in
2017 I think we lack a common language
to describe architecture and
specifically static structure we think
we have a common language but we don't
so let's try a quick quiz what is this
to map off although on the map of ortho
what is this blue thing what's the blue
thing water it's River and what is a
river
what's a river just a moving body of
water right so we know the river is we
now have it simply represented on maps
we can use this knowledge we hopefully
learnt as kids to go and find other
rivers what's this one here floor plan
floor plan for a what bathroom excellent
given that this is a top down floor plan
for a bathroom what is that why people
laughing what's this it's a toilet what
is a toilet and now there's silence
nobody want to answer the question of
what is a toilet so we all know what a
toilet hopefully again this is something
else we learnt we were children and we
can now fly outside and we can use this
in order to go and find other toilets
are there any electrical engineers here
people dabble in electronics cool a
couple of ways you can represent circuit
diagrams what is that thing there it's a
resistor what is a resistor resist stuff
stops produces flow cur I'd know
somebody if I had a box of electrical
things here at the front with capacitors
and resistors and switches and LEDs do
you think you could come to the front
and find me a resistor yeah and if you
knew the color coding you tell me how
powerful that resistor was so again we
know the resistor is we can identify it
touch it feel it
let's change tack slightly what is that
yes
this is our world this is a UML
component diagram showing components for
some sort of university scheduling
system given that this is a UML
component diagram what are all of the
boxes components yay what is a component
it's entirely up to you and that's a big
problem we have here so what have we got
that thing there is a database component
so that sounds like a database the boxes
on the left hand sides are stereotyped
application so they sound like
applications but I'm not sure if they
are mobile apps or web apps or desktop
apps or bat chaps who knows and the
stuff in the middle is just vague I
don't know if these are standalone
components like microservices are
separately deployable or whether these
components actually sit and reside
somehow in the applications there's just
a lot of ambiguity here component can
mean many many different things here's
another example this is a real example
from a real modeling tool and it's one
of their example diagrams it's
horrendously bad the one I like the most
on here is of course the business object
component what a great way to describe
what you're building people this answers
essence basically the word component
means parse or something bigger let's
imagine you're building a software
system that software system is itself
comprised of a web application talking
to a database we could use the word
component virus dictionary definition to
basically represent the web app so the
web app is a component of the system we
could also say no the login component is
a component of the web app so we can use
the same term to mean very different
levels of abstraction different levels
of hierarchy it's the irony of ddd
domain driven design we talked about
creating a ubiquitous language between
us as developers and the business people
set domain terms that we all agree upon
so we all talk the same language
the RNA here is we in this room right
now do not have your business language
that we can use to describe software
architecture and that's what we need to
fix so I think you have now tried to
solve this problem to degree if you look
at UML that has a bunch of common
abstractions it also has a bunch of kind
of standardized boxes and lines and
notations to represent those
abstractions whenever I see people using
UML they're normally abusing UML and the
typical classic example I see all the
time is we draw a UML class diagram the
boxes on a class diagram should
represent classes or interfaces and then
something to say well that box said
that's not a class that's another system
or a message bus or something like what
then we need to step back for a second
Park UML and say let's focus on
abstractions first let's let the
notation we use evolve and this is what
happened with UML 20 years ago and if
this sounds somewhat foolish let's go
and get two maps of also and put them
out side by side the front the two maps
of Oslo will show the same things
central station car your hand there's
parks the district's tram lines the two
maps have also will show the same
abstractions the same things but there
might use a different notation to do so
different shadings colors line styles
icons and symbols how do we decipher a
map well there's a key or a legend in
the corner so great lets us use this so
map is a real nice simple example of a
self describing piece of documentation
it's something that can stand alone to
some extent anyway so how do how do we
do this how do I do this well whenever
I'm thinking about a software system for
me a software system is made up of one
or more containers now it's a bit
unfortunate that docker became popular
because I'm not necessarily referring to
a docker container here by container all
I mean is something like an application
or a data store something that you know
you can deploy in it runs your code or
something where you saw data web app
mobile app desktop apps standalone app
file system s3 bucket database schema
whatever so it's a separately deployable
thing if we look inside the containers
and we decompose them for me they are
made up of components I want to use the
word component very specifically me to
mean something running inside a
container runtime environment it's a
grouping of related functionality with a
nice clean simple interface on top
because we're mostly c-sharp people here
if we look inside our components they
are ultimately built from C shop classes
in this case and then we have it this is
a really nice simple hierarchical way to
think about the static structure of a
software system software systems built
from containers contains contain
components components built from classes
and we're done this works great for
c-sharp and C++ and Java another other
languages this doesn't necessarily work
for JavaScript because there you don't
have classes so with Java scripts maybe
you take the same hierarchical approach
and you you blend it you kind of meld it
towards the text that you're using so in
JavaScript maybe its components and
objects or modules and objects or
modules and functions you choose in F
sharp its modules and functions so again
take the same hierarchical approach and
map it to the tech that you're using
once you have a set of abstractions you
can draw some pictures very very simply
at each level and turn and this is what
I call my c4 model you solve the system
context diagram here's your system in
the middle stuff around it in the
outside world you then zoom in to show
containers you then zoom into each
container to show components and then
you normally stop you can go deeper if
you want it you can start to show
classes or code so um our class diagrams
for example I don't normally do that
because that's the stuff I can get on
demand for my tooling I'm really
focusing on the high-level diagrams here
and I'm also only really focusing on
static structure
and this is describing the static
structure from the level of the code up
to the software system is a box we can't
see inside off with a couple of levels
in between that contains the components
and what it turns out that once you have
a good simple static model of your
system you can draw other views around
it very very simply if you want the
document a feature or a story or a use
case you know how that works a runtime
you draw a UML collaboration or sequence
diagram that shows how elements in your
static model interact at runtime if you
have a map of your infrastructure
physical servers virtual servers
containerized servers you show how your
containers map onto infrastructure
that's your deployment mapping quickly
some will just kind of concrete
everything when I moves back to Jersey
in 2008 I built this thing here it's
called tech drivers je it's a simple
content aggregator for the local tech
industry I've recently taken this site
down but store its destroy sourced and
all this site basically did was list
local people businesses blog posts
tweets events and jobs this is a context
diagram for the tech tribes system the
Box in the middle that's the thing I
built next tech drives the system at the
top are the various types of users at
the bottom are the other systems that I
depend upon so Twitter github and blogs
in this case if this was like a Google
map going back to my instruction about
Jersey we could select the tech drives
box and almost pinch to zoom in so this
is level 2 this is the container diagram
and all I've done is I've expanded out
and exploded out that that system
context to show you that contains the
living side the tech troves boundary in
essence there's a web app at the top
console up at the bottom and some data
stores in the middle this diagram
doesn't tell you anything about
deployment or you know failover and
backup and clustering this is just a
logical view of the containers that make
up the system that these things aren't
separate deployment units again if this
is interactive we can select it pinch to
zoom in we get to see the components
sighs the content update application
here and it's the same deal we select
that thing there the tweet component we
zoom in we see code so it's very very
simple set diagram is to ultimately
navigate down to code from a high-level
picture and the diagrams are like maps
it's the same thing you open up your
smartphone you come to Jersey you press
a little GPS button all you do search
for Jersey you get a picture sometimes
you have to zoom in or zoom out
depending on what information you need
so I do think about the diagrams as
being maps that you can use to help
people understand large and complex
software systems sure I could just drop
you in a code base and let you explore
like launching you down that leafy lane
or hoping you bump into somebody but we
have a more sophisticated way to deal
with this there's a whole bunch of
detail about notation so I'm not going
to talk about during this talk if you go
onto YouTube and do search for my name
and the art of visualizing software
architecture I have a much more detailed
tool the talks much more about notation
and that sort of thing so that's diagram
sets visualization let's talk about the
stuff that nobody really wants to talk
about ever documentation we used to see
a lot of documentation being produced
almost too much
and of course in 2001 the a dramatic
fester came around and it says this we
value working software over
comprehensive documentation and this
makes perfect sense but the unfortunate
misinterpretation is don't write
documentation ever and I have seen teams
generally flip-flop from one extreme to
the complete polar opposite and when I
go and visit them and say so how much
documentation do you have the guy and
not much by which they mean none and
that's great until people start leaving
as a still instead this morning during
the keynote you know why does this work
or how does this work or you know why
have you done this way you have oh I
don't know it's always been like that
and that stuff templates written down of
course a lot of people say well you
don't need documentation because the
code tells you everything and that's not
simply true that you know the code
doesn't tell you the whole story even if
you have nice short methods variable
names that make sense you know you've
got nice and tender method names and
everything there's still a bunch of
information missing from the code and
that's the stuff I really want to
capture here typically we use something
like a sad to capture this it's funny
that this is called a sad because that's
how it makes us feel especially when you
have to write these things and you know
nobody's ever going to read them ever
again I like the typical content if
these document in these documents but
the implementation strategy is often
somewhat lacking now these are really
boring dry documents there are hundreds
and hundreds of pages are really hard to
update and they're stuck on some
SharePoint some site somewhere so what I
do is I say well let's go back to the
travel thing we like travel guidebooks
travel guidebooks are nice and lean and
lightweight they give you enough
information to get some context to
understand the major things that
happening in the city town country uh
visiting they give you a good basis to
start exploring so let's use that same
metaphor so I like to think about my
documentation is being like a software
guidebook this is a piece of lightweight
supplementary documentation that
essentially describes the stuff you
can't get from the code it has a bunch
of maps the maps help you navigate
that's where the diagrams come back into
play of course most software systems are
really boring they're just the same
pattern repeated over and over and over
again you can see this especially with
web applications you know it's more
viewcontroller four thousand times
let's not document the four thousand
occurrences let's document the
interesting patterns and say this
pattern is repeated everywhere that's
all you need to know things like history
and culture so how did your system grow
to be how it is today sometimes you can
walk into a project and it looks like
it's been designed by two very different
architects and maybe that's because it
has been designed by two very different
architects you know maybe one quick one
joined and then there's all the
practical information how do you support
and deploy and operate this thing
and my simple advice here is basically
describe what you can't get from your
code it's as simple as that resist the
temptation to describe how the code
works and kind of take it up and not
take out the level and for me this is a
constantly evolving thing so we're not
going back to the comprehensive document
driven world of waterfall you know
create the documentation at the same
time you're creating your software and
the scope of this thing is a single
software system and the reason I make
this point is very simple I have a
customer in the UK and I have a 20 year
old system that runs their entire
business a few years ago they did not
have a single document that describes
how that 20 year old system worked what
they did have however was 20 years worth
of projects documentation imagine you
going during that organization on Monday
your first job is literally to read
through twenty years worth of
documentation doing the diffs in your
head as you go through the years so to
try and figure out what you've got today
and how to work with it so for me the
documentation refers to a product or
software system and every project is a
change set to that single source of
information there's a whole long
discussion here about what type of stuff
do I include in my documentation this is
my very kind of simple starting point
for document template it's describing
something about the context of the
system where we're working with
something about the architectural
drivers so what are the key functional
requirements the key quality attributes
security scaling performance what are
the constraints of the environment what
principles are you trying to adopt as a
team that tells you how you people got
to the design you talk about their
design itself from different levels of
abstraction and then we talk something
about the infrastructure deployment
operational aspects you might also want
to keep a decision log of your major
significant decisions maybe just using
free text or Michael Nygaard
architecture description records sorry
architect a decision record is
is a good way to do this that's my
templates very straightforward very
simple arc 42 is another popular
template you might come across again
same type of content slightly different
naming slightly different order I don't
care which one you use that you know
they're both they're both pretty much
the same anyway people often ask me how
long is this documentation be what I
really want is imagine I joined your
project team I want something I can read
in like one or two hours with one or two
of Rob Ashton's very very nice coffees
just to get a nice basis for exploring
your codebase so to give me a good
starting point for jumping off into the
code I don't think it asked how do you
keep the stuff up to date from a process
perspective if you have a definition of
done for your tasks or stories or
features you add a line to the bottom
and all it says is have you updated your
diagrams and documentation and then the
changes are very very small Delta's we
can also throw tooling at this which
we'll talk about in a second and
similarly with formats what format we
use again it doesn't matter the content
is the important thing here so let's
quickly change tack onto white tooling
because when I've done this talk in the
past people are always asking afterwards
you know what tools you recommend for
this stuff in terms of diagrams what
will take a kind of diagram centric view
of this when I'm doing an upfront design
exercise I will always use white boards
and pieces of paper because it's just a
much bigger collaborative space to do
you know pair architecting and
collaborative design once you start
writing code or once you need to start
formalizing your diagrams your
documentation taking photos of white
boards is okay but people often like to
start using tooling to convert this to a
slightly nicer format and this is where
tools like Visio come into play so there
are a whole bunch of general-purpose
diagramming tools out there Visio
OmniGraffle Gliffy for integration with
confluence lucidchart draw the i/o
correctly there are millions of these
things out there with great power comes
great responsibility
you can draw anything you want in these
tools
and because the diagrams I showed you
briefly I just boxes and lines that's
all you need to do you need any tool
that supports boxes and lines these
tools are a bit clunky more importantly
they are just static diagrams if we have
three diagrams like we do at the top
here and let's say there is a github box
at the bottom and I want to rename that
across three diagrams I have to rename
it three times there's no underlying
single definition of it every box so
that's the thing you have to bear in
mind here I see a lot of people
migrating towards text-based tooling
these days stuff like plants UML with
sequence diagrams why UML none more how
you pronounce it basically what you do
this is web sequence diagrams you write
some text a stereotypical Alice Bob
example and it generates some diagrams
for you
this one is quite nice because this
developers we like text and we have lots
of tooling to support text so we can do
things like the version control the
diagram sources and we just type some
text we can do search and replace on
these texts files to you know do Global
replacements and names and things you
get a lot of power these tools you don't
necessarily get much control of the
resulting pictures but there's a lot of
interesting stuff you can do there's a
whole bunch of stuff you can look up on
Twitter called it's at Doc toolchain
raffle model is basically building a
whole set of tooling around these types
of tools to embed them into asciidoc and
markdown for example so you can plug
these tools into build script one of the
downsides with the text-based tooling is
you're still building individual
diagrams they're single static diagrams
there's no underlying model there and
you can't query these diagrams and ask
them questions if you take this concept
one step further you get to something
called architecture description
languages let's try this has anybody
here ever use an architect's description
language I saw one
- these things are basically horrible
the concept is beautiful though because
waste basically what we do instead of
drawing pictures you write some text to
create a model of your system using a
very you know interesting
domain-specific language I say
interesting I mean horrible these things
not really used much you'll find them in
academic and research some circles if
you go and look up any of these names
you'll often end up on a webpage that
really looks like it's come from 1997
and that's because these things are
basically stuck in the past so really
interesting concepts you write a textual
model of your system and then you use
other tooling like graphics or yet to
describe and visualize those graphs so
nice concepts implementation that really
works we should probably talk about
modeling tools of course there are a
whole raft of modeling tools out there
different notations of course you've got
UML you've got sysml which not be many
people have heard of you've also got our
key mate which is pushing more towards
the kind of enterprise architecture
space sparks Enterprise Architect is
probably the tool I see the most out
there it's relatively cheap it's not
particularly easy to use but it's one of
the more popular ones rational rows back
in the day was just awesome of course
nice yellow boxes with pink outlines for
some reason tooling looks like this
and again what you're doing here is
you're creating a model what you have to
often have to do with these tools is you
have to basically this is your model
over here so you're creating a
hierarchical structure of elements you
often have to do lots of clicking and
right-clicking and opening properties
dialog so these tools can be quite hard
work to get information into but once
you have a model of your system you can
do a bunch of interesting stuff with it
there's also a category of static
analysis and defense analysis tools that
can help you visualize your code base to
some extent start to 101 end pen Latics
and so on and so on these are really
used to help you understand
structure they're not normally tools
you'd associate with creating
architecture diagrams especially the
type architects diagrams you want to
show to new joiners or doing a sales
presentation or something like this so
the very low level very technical very
precise once again there's a really
interesting article on infocomm a few
years back a few years about 2009 it was
a virtual panel on the future software
architecture documentation bunch of
famous people here are in words Grady
Booch LEM bass I've highlighted some of
the points they raised there and
everybody kind of says yeah it'd be
really interesting to get architecture
documentation for free with the push of
a button to embed information into our
code bases to create the type of
documentation that a new developer good
easily and readily understand and this
is in 2009 and I still don't think we're
there yet we often do this silly
comparison between software in the
building world so let's do that the
building world does not use Visio if I
were to task you to go and design me the
next tallest building in Dubai you don't
get Visio out hopefully you probably use
a modeling tool like AutoCAD you create
a three-dimensional model of your
building and you surface different
visualizations based on the data in that
model you know the irony with this only
we are software people build these tools
for other people to do modeling but we
can't do modeling ourselves how crazy is
that
it's worth pointing out here of course
there any diagram you create manually if
it's not connected to the code it's
basically useless as far as architecture
improvement goes because it's really
easy to lie and I see this all the time
I work those organizations and let's say
they're building an asp.net web app and
I say here's a whiteboard draw me a
picture of your web app and they draw
this beautifully you know strictly
layered arced it's a diagram
presentation business data and all the
arrows go down which you're like oh wow
this is amazing
and then you look at the code and all
the hours go up and down and all sorts
of crazy ways like
lie to me didn't you and that's the
problem with manually drawing pictures
of course we could reverse engineer
pictures from the code anybody tried
this what happens get mess is that
because your code is a mess sometimes
it's normally because the the tooling
doesn't really know how to present the
data in a good way here's a really small
sample code base and look at the
automatically generated um our class
diagram is hopeless this is a toy app
with 30 classes imagine this is you will
enter eyes out with thousands and
thousands of classes this is showing the
wrong level of detail this is like me
coming to although for the first time
getting outside Central Station being
completely lost opening up Google Maps
on my phone and switching to Street View
so now I have the Street View here and
Street View on my phone it's a stupid
way to navigate an unfamiliar
environment what I need to do is zoom
out to get back to the top down view so
I know where I'm heading at least so
that's a quick summary of the tooling
now I really like the architecture
description language concept but I
implementations are horrible so what
I've done is I've created my own why not
the key difference between the one I've
created and the other one is that you
can run mine so I have an executable
architecture description language and
this is a couple of open source projects
your phone on github called structure
Isis one for Java one for dotnet and
what I'm trying to do here and this is a
little bit of sales pitch so I do
apologize in advance what I'm trying to
do here is is provide a way for
development teams to easily create a
good rich model of their software system
using this tooling that they typically
use day-to-day it's the docks as code
thing you might have seen people talk
about I have a website called structure
Iser structure Ivory's micro startup
company so again apologies in advance
it's a short loss sales pitch it's a way
to visualize document and explore
software architect essentially it's an
implementation of the C for diagrams in
a software-as-a-service format in
essence what you do is you use the open
source library to write some code and
your code
cribes what you'll get out with the
diagram so in the in the dotnet class
library there are a bunch of classes
representing people software systems
contains components and you basically
insensate them create objects and wire
them together so that's how you create
your you'll graph your object model if
you're sitting there thinking this is
absolutely stupid why on earth would you
want to write more code to create
diagrams the answer is because once you
start writing code you can use things
like reflection the static analysis so
you can write a lot of program write
some code the easiest reflection this is
all built into the structure eyes of
dotnet library and you can go and find
components in your codebase so if you're
building an asp.net web app and all of
your web app controllers you want to
treat its components and they all end
that the names of the classes all end in
the word controller it's really easy to
use reflections go say right go find me
all of the classes that end in the word
controller so you can you can extract
information from a set of assemblies you
don't have to use my tooling my
web-based tooling built into both
libraries there's an exporter for plants
UML so you can create your model with
structure either open source libraries
you export it to a plant UML diagram
definition and then you throw that
through your regular plant you might all
the benefit of doing this is now you're
creating plant UML diagrams based upon
the model you change the name of an
element in your model the change is
reflected across all diagrams once you
regenerate them this is not something
that exists currently but suddenly sent
me a bunch of screenshots awhile ago of
an exports from the open source
libraries to DG ml DTM L is the directed
graph markup language and it's natively
supported in Visual Studio and you get
this nice kind of clickable hyperlink of
all set of diagrams and magically expand
so again that's another interesting
thing you can do to bring documentation
back into this I'm a big fan of using
lightweight tools for documentation I'm
seeing a lot more teams using markdown
and asciidoc so again something you can
do with the open source library so you
can bundle the markdown and asciidoc in
there as well
so you're creating a single model of all
of your stuff
and because it all live together you can
do things like embed diagrams you can
also plug all of this into your build
systems so again this is a very very
simple way to keep your artifacts up to
date so it's all I quickly finish on
exploring a code base and of course once
you have a model here you can do some
interesting stuff with it the structure
is calm the software services a free
plan you can sign up for and all of
these visualizations are available in
the free plan and these are really
simple JavaScript DT relations that you
can do yourself as well so this is a
tree structure showing you the static
structure the building blocks that make
up a system in this case so here we have
a system software system it has a couple
of containers this tier here our
components and all of these things here
are the code level elements the
interfaces and the classes that were
found during a components can we zoom in
I've applied some different color coding
to highlight different things so that
thing there is the interface associated
with that component these two classes
here are only used by that component and
the gray classes are actually shared
code so these classes used by this
component and others so again you can
start to apply some kind of interesting
heuristics on top of code base once you
have a model if you have a container
with a bunch of components inside it you
can draw things like dependency maps
really simply so this is a dependency
map of the component society web
application the size of the blob refers
to Uncle Bob Martin's instability metric
this is the ratio of afferent and
efferent in bounded at bounds couplings
and dependencies if you have some notion
of size size could just mean lines of
code you can draw some nice bubble
diagrams like this the big blue circle
is a container the medium size circles
are components and all the small circles
are code elements and what you can do of
course you can say right well show me
where this code element is shared across
other components you can look at this
another way this is a force directed
graph each of the large blue blobs
represent components
the small blue blobs the circles are
code elements and the gray ones are
shared code again so this is another
interesting way to visualize it and you
can see that you know that code n when
there is used by a lot of other
components
maybe that's intentional maybe it's not
because you have a model you can say
right well let's highlight all the
public types only so forget all of the
package protected internal types let's
only look at public types and now you
can start to see interesting things like
well we have a component here and it has
a public class and that public class is
only ever used by that component why you
can look at this data another way now
here's a usage counts of all of the code
elements the interfaces and classes in
the codebase and again the blue ones
here are public using some nifty red X's
we can say things like write forget all
of the domain and utah classes because
they are going to be shared show me all
of the other public classes here and so
you can see that you know these classes
here are only ever used by one component
but the public why so this is a great
heuristic you can start applying to code
bases as early right let's reduce the
accessibility of a lot of our code to
give us a much more kind of modular
style of element of course
so that's exploring the code base when
you have them all of your code base you
can do a bunch of interesting stuff
couple of sides of the finish shop
number one the 1990s called and once is
turning back right please stop using
general purpose tools for doing
architecture work Visio OmniGraffle
Gliffy just don't use general purpose
diagramming tools we need to start using
tools that are better suited to doing
modeling and that's something I do want
to promote I want to promote modeling
over just drawing diagrams if you look
back 10 or 20 years we used to do a lot
of modeling a modeling completely fell
away when out of fashion when we
switched to doing you know agile stuff
we threw the baby away with the
bathwater I think creating model is a
good way to get some more intelligence
about your software system and it
doesn't need to be a very large complex
and bloated set of UML tools you can do
you know you can create
although very simply and no matter what
type a diagrams you draw no matter what
type of toning you draw focus on the
abstractions first when you go back to
teams and you want to draw a set while
sets of diagrams sit down for five
minutes and start the meeting understand
the abstractions that you want to use to
describe your software so work out your
hierarchical set of building blocks
write those on the wall somewhere so
everybody knows exactly what they mean
so create that ubiquitous language and
they let the notation you use evolve as
a secondary thing but basically me if
you want more information about any of
this stuff I've got a couple of books on
lean pubs there's a bunch of help
documentation on structure Iser if you
go to my Twitter profile that I've
pinned this tweet to my profile and
there are a couple of a3 kind of posts
or cheat sheets around visualizing
documenting architecture that you can
grab I'm around all day if you have any
questions just come up and grab me later
thank very much enjoy the rest of day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>