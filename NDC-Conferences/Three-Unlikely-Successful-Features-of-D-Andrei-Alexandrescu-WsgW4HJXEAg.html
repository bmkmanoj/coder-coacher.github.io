<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Three Unlikely Successful Features of D -  Andrei Alexandrescu | Coder Coacher - Coaching Coders</title><meta content="Three Unlikely Successful Features of D -  Andrei Alexandrescu - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Three Unlikely Successful Features of D -  Andrei Alexandrescu</b></h2><h5 class="post__date">2017-04-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WsgW4HJXEAg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay thank you mm-hmm my 30 second rule
was you know like you don't watch the
first 30 seconds of any talk because
it's like nothing interestings they just
keep the first 30 30 seconds and you're
still good you have the talk my rule was
to make the 30 seconds the most
interesting of the talk by staying with
the bank but all this microphone thing
kinda messed that up so there goes the
plan I'm going to talk about it just
change the title a bit because yeah it
kind of you know unexpectedly success
whatever second to tell you three
stories related to the D language that I
think are just very interesting to wit I
have like you know kind of half a dozen
folks in the audience which is awesome
by this by this conference is standard
this is not this is not the languages
conference I'm very happy you came I
hope nobody's going to leave before it's
like ah I can't put up with this anymore
so I'm going to give a bit of
introduction what the D programming
language is all about and then I'm going
to give you like few anecdotes about it
that I think are just interesting in
general not related to the D language in
particular or even to any language
they're kind of you know you know
telling about program psychology so let
me bring to your attention a company
called
the red telephone company and it was a
company developing itself in Australia
in the 60s and 70s and they're just like
you know the typical phone was literally
read and they had going and they had a
brand with it was a nice it was a nice
company and they would they would do
good business there until some
regulation changed and the way the
regulation changed was the the
competition and sort of the the weight
of for regulation worked at that time
imposed that there is a constant cost
per talk not per minute
so you would as a subscriber to a phone
company you would pay the same amount of
money whether talk for a minute or ten
or half an hour okay so that was a
problem for derpity jerk-off model which
was they would pay the provider of cable
whatever they would pay by the minute
so the year was like 1971 and they were
looking desperately for a solution to
that problem and you know how do we make
our customers talk less which is kind of
a interesting problem to think about
because you know what would you do like
you know ideas please from the vast
audience in this room yes sorry stop
yeah break the call and then of course
you're going to have the risk of losing
customers if you kept on doing that so
that was not a very good solution but
definitely is one one of the things you
may think about as a possible solution
what other ideas do you guys yes make
the phone call what so yeah so you kind
of make the phone call of poor quality
so people get tired of of that so that
was that's actually very interesting is
a kind of it's a it's very telling that
you came up with this idea because it's
actually related to what they end up
ended up doing so they brought a
consultant and the guy said you know
what make the phone the handset heavier
so they put like a piece of lead in the
handset I'm not kidding so they put like
they made the handset heavier and people
will like talk for one they're like ah
you know I'm tired like I'll talk to you
tomorrow right because it's just
starting to hold so that was very
successful and kind of prolong the
lifetime of that company and then it was
acquired etc etc but it was a very nice
idea coming from a completely unexpected
angle and ultimately realizing the the
goal so my purpose here is to tell you
three similar stories and you know my
hope is that by the end of this
oh yeah so that was kind of an
interesting segue into these three
stories awesome
so let me talk a bit about be in sort of
in a in a general sense so systems level
programming are still a necessity
there's quite a few application
categories with what people call like if
refer an economist I would say elastic
demand for performance so what does it
mean like elastic demand for performance
who knows like who's being who's been
doing economics in cottage isn't nobody
ok great
very happy me neither but I happen to
know this term which is elastic demand
means the more you have the more you
want right like you know to some extent
what can you think of that is has
elastic demand drugs awesome that's a
good one
so I hope the camera is not going to see
who that guy was but was something okay
something of more of a staple that would
would have an elastic demand to some
extent actually food kind of the big
food companies have shown that the
demand for food is a bit elastic in the
sense that they keep on increasing those
coca-cola like the glass cups right but
for example taxi rides the cheaper it
gets the more you write and that's what
that's that's uber like uber was
successful because they figured out it's
amazing so they figured people are not
going to stop using cabs if they get
less and less he says it's all they're
going to use more and more cabs which is
amazing now there's a there are quite a
few domains in our realm in computing
where the demand for performance is
elastic can you give me examples Shawn
Photoshop thank you very much genius yes
I bow to you so of course in Photoshop
you have past year you mentioned does
one particular test that took 8 minutes
to complete and in all likelihood it you
know the does an iteration going so
people wanted to do continue doing other
things after date minutes have passed so
if you reduce those 8 minutes to 6 for 2
that would be a very significant
increase of productivity
is under there's actually literally no
limit to how much you want to crank up
that computation because then you get to
do a lot more things with Photoshop
other other applications other domains
in which there's not enough power I can
graphics yes so that would be related
yes animation what have you used I mean
yes broadband the more you get the more
you want definitely and actually there
may be situation point I'm thinking like
to make like a resolution like you know
5k how much more do you want so probably
this is kind of an I limit there but
anyone low latency so yeah indeed but
they're like more money making kind of
alternate instincts and come on huh
memory know that in computing what
algorithms what kind of domains of
computing what applications of computers
have this elastic demand for performance
I would say money making trading money
my money you know market analysis I mean
here's the thing when the market closes
a lot of companies have until the open
the market next day to crunch numbers
and the more numbers you give to crunch
the better models you have it's like the
relationship is clear there's no limit
to how much you can do don't be like a
lot of other applications such as like
pretty much any compilation speed like
if you use C++ this there's no limit to
how much speed you want in compilation
because it's so terrible to start with
all right so then we have this one
tendencies like you know we have
systems-level program we still necessary
because of this elastic performance
demand and then we have ever grain
modeling so we're not we don't want only
access applications we also want larger
and more complex applications to develop
and for a four language that that
assistance you want to kind of keep all
in the same language as opposed to
across multiple language languages and
the alternatives to D are missing for
one or more fast compilation fast
generated code which is a complete
different matter modularity of code
expressive power enabling parodies
paradigms and safety so if you look at
the landscape of for CSS foreign
languages or programming languages in
general you're going to find that some
are going to feel fulfill some of these
points but not others for example you
know common French C++ which of these
doesn't quite fulfill and which does it
very well at first compilation I'm
seeing like knope's speedo generated
code awesome
I really nice right so here's like
modularity I'm kind of translating for
the camera the body language and getting
from the vast audience here so majority
has like a number of things to it one of
them being like the compilation model is
against modularity for the you know that
pound include model which kind of
exposes everything and this white box
boxing of files and that kind of stuff
so you know there's multiple aspects of
modularity and the process has quite a
few issues they're expressive Thorsen
enabled paradigms C++ pretty good pretty
good not better compared to like a lot
of the competition safety you're being
very nice there I mean come on right
you're being super nice okay so alright
so there are other languages such as
Roth which comes from the safety angle
and but kind of the first module first
compilation expressive power kind of
justice quick set alright great so we're
looking at working with D for language
that would kind of light up these are
these basic de-spawn Dementor
requirements and my personal story goes
the following way as some of you may
know i'm a big kind of c+ responded from
years back and i've been coming from
from that from that angle so I was very
happy that she was has good modeling
capabilities as an efficient
underpinning very nice together the
whole C memory model and kind of
paradigm was very nice the problem I'm
kind of found like for example are the
meta programming C++ even though it does
things that at the time we're like
pretty awesome
it's very arcane for example there's no
if during compilation and I picture that
you're using any language and they say
whenever you need an if you need to call
a different function it you would say
please don't do this to me because I
have a life to tend to so no you don't
want that you don't want to recurse or
overload or kind of go somewhere else
whenever you need to do a branch in your
program like if it's sort of the most
basic thing you may want to want as a
facility in a language unfortunate for
its compact and she processes note there
is no such thing and you have this
letter of phenomenon because of their
kind kenai involved in in doing meta
programming C++ it led to this trick but
not user serviceable libraries such as
good portions of the boost library like
you know essentially inscrutable from
user perspective you have no idea I've
had quite a few experiences with boost
where like where is work being something
a problem I want to look at the source
code to see what how hard can it be how
difficult can it be to say I'm using
this library it has a source available
all I need to do is look where the
source the work is being done so I can
figure out what's happening
well yeah I'm seeing this oh my god so
I'm kind of again I'm doing for the
camera unsuccessfully your beautiful
face here um so you know I did this and
there's this whole what was it were like
scaffolding in boost that you look at
and you go through and you have no idea
where the work is being done because the
life of code that actually do work are
very few bike by sheer numbers by as a
fraction of the the total code because
all is it so like you know redirection
template and you know let's stuff
so I do like that ideal like that see
processors poor introspection which I
think introspection is one of the
fundamental things that allow you to
write good and fast software
introspection meaning you you have like
code and you get to actually inspect the
code and see you know how many what are
your methods you look at the struggle
class see what our message enumerate the
message for me please so I can see them
by name and what arguments they take etc
and all of this should be done during
compilation so you can use the object if
you so and the computation model is
impractical we have a whole team at
Facebook which I was a part of for a
while which you know it was a full team
of good engineers and me they lost me
who had any task like make builds work
in C++ so the parallel system thousands
of machines they get to making all the
engineers in now at Facebook write C++
code and build it fast it had a lot of
caching going on there's a lot there's a
lot of engineering that went into that
parallel build system simply because the
model of compilation is start with in C
processes bankrupt it's terrible it's a
mess actually it's an amazing feat of
technology that hello world works and so
many things happen if you just pre
process hello world do you know how many
lines you get huh nineteen thousand
depends alike I got 55 57 thousand with
clang which is awesome it's very little
but just like a five liner and you look
at the comparison who has to rummage
through tens of thousands of line
megabytes of code to get to the point
where actually generates an object file
and in an arcane format it to itself
that's a dis kind of a whole different
problem and then it gets linked with
another Cane format and then it gets
interesting secure oh that actually
works
the fact that that whole pipeline even
works is an amazing feat of engineering
congratulations
we're amazing I mean the sheer fact that
we got this to work
is fantastic alright so okay um and then
I kind of concluded as a correlate to
these issues I was having I was trying
to express these difficult meta programs
in C++ and I figured actually what I'm
getting is modest results with
disproportionate effort so there's kind
of this this misalignment between what
you put in it and what you get so I was
I happy with that so yeah I said you
know let me let me actually try this
other language and work on it and
improve it so the principles of of D are
we want to leave no room below so you
don't need to escape into a different
language to do performance work which
make sense
it's multi-paradigm imbalance it's
practical and principled and avoids
arcana and why would you want to look at
it well the party line is three things
convenience modeling power and
efficiency which again it are difficult
to find together they are easy to find
like two of them are easy to find in
other languages the actual reasons I've
been discussing with people are actually
what I like is that it compiles quickly
and produces fast binaries so that's
what that was I think that also people
appreciate it's easier to get into than
other languages and it's fun to work in
so the fun factor is definitely there so
it's not it's not something negligible
is it you know the fact that the
language is fun to work with is
definitely a good sign
why not why don't you want to get I mean
every language proponent that has gotta
have the slide if a language if a
programming language has only pluses or
minuses that the lie it that can't be
right so definitely there's minuses
there's no party line to why you
shouldn't use D right that's why I left
an empty bullet there right and the
actual reasons I heard from people was
actually these poor informal education
it's unclear you know it's not very well
defined there's little corporate pick up
and support there are only a handful of
large companies using there at the
moment
along with larger
but not huge sort of grassroots
community I would estimate that the user
base of these couple of orders of
magnitude behind the likes of Java C and
C++ which is still a lot of folks but it
is not as huge as the consecrated
languages not many libraries in it's a
large language to learn
now first anecdote from Turtles to
dependency caring code all right who
knows the joke with the turtles turtles
all the way down tell it to us actually
I'm going to tell you because I have the
microphone is difficult yeah so the way
it goes I would need to repeat
everything you say so the joke goes
physical scientist gives a talk the
physical physicist right gives a talk at
the kind of layman audience and gives
our talk about universe and physics and
you know kind of planet whatever kind of
big things astronomy whatnot
and the general talk there's this old
lady coming to him and says oh you're
all wrong young man you got it wrong the
whole universe sits on a turtle on the
back of a turtle and the guy says okay
so I have some I have a fun conversation
ahead of me the the scientist thinks so
he says well what's that turtle sitting
on oh it's a different it's another
turtle and the Gator how about the
editor and all the uses are you trying
to fool me young man it's Turtles all
the way down so she had this nice
infinite regression in going on instead
of mind so that's up the story with the
torus all going going all done is a good
examples of what's called infinite
regression in science and it's one of
those things that kind of go like
fractally go all the way down and I'm
going to show you an example of using
this principle in programming language
design and I'm going to take that too
dependency carrying codes and I'm going
to define that so let's start with hello
world
okay so hello world has I put like a
scripting line there they can I
you run it like a script with the
shebang line and everything
very nice has an import which is you can
imagine it's like pretty much like in
Python or like pound including a C++ or
what have you or in Java and any other
c-sharp whatever and we have a program
that's void main' and does the right
line and just does pretty much the
program and well there is a few
questions why didn't you import for
everything why don't I have just a
one-liner that does it all for me there
are answers to that but I don't want to
focus on that I want to focus on
something different which is a slight
change to this program which goes this
way what is the change I push that I
push the import inside the main function
so I kind of made like an of a sort of
file inclusion or water library whatever
the hell you look up saying I put the
library use inside the place where it's
used which is odd I mean if you do this
in C a kind of a pound including set of
function it may actually almost work but
you would not be up for promotion after
the next review cycle at your employer
this is not going to push your career
forward my friends right it spawned
include inside of functions are no
knowing C and C posture gets even
weirder and see it actually can make a
lot of things work if you Bonnie Chris
at a function among which structs are
non-local can you find a struct inside a
scope in C you can but not in C++
because you can't it's different it's of
the whole huh yeah you can but that
different semantics what I'm saying red
as opposed to because usually when you
include something is you include for
linking purposes so then the whole
symbol mangle is going to be different
all right all right awesome now in
Python actually there's a thread there's
a discussion going on about the merits
and demerits of doing this in Python
which is undecided at this point my
understanding is in the Java and c-sharp
it just straight doesn't work
right so now the abstract that I'm
putting the import the inside the scope
is I want to do anything everywhere and
that's the way the way of the D language
is you put anything anywhere in D you
can actually put functions instead
functions types instead inside functions
you can put generate you can put
whatever you want inside everywhere else
and that's infinite regression because
you get to put like in any scope no
matter how deep down it goes you can
still put anything in there and that's a
nice design principle this fractality of
language constructs but it didn't apply
for import then one morning I sat down I
did this and I tried it ended in compile
so I call Walter Brite the inventor of
the D language and I said Walter I tried
this and it doesn't work he said let me
look through the compiler source said
well the first line in the compiler is
when I type check import you check that
it's at the global level otherwise it's
just an error it just abort compilation
and I said well why don't you comment
that check out and see what happens so
he commented out in the rest essentially
it worked so you're kind of working like
it was a removal of a limitation that
what made things work as opposed to
consciously designing a new feature so
remove the limitations word and we had
you know we did some more work with type
look up with the name lookup and stuff
to make things proper so it just worked
so that was it how big a deal do you
think this is it is bigger it is small
it looked like a small deal alright so
and then we we said well how about you
put importing structs and classes and
whatever you have a scope you can put an
import that should be natural and it is
so that goes on that goes for those two
and it got a very interesting point
where you can say actually the
definition it's the input is actually
dependency is what makes this particular
widget or function or whatever work is
its condition by the existence of that
particular
it doesn't have to be a standard import
it can import any other library that you
may have or may not have so that means
the definition of widget here is
carrying its own dependencies and if you
move it around it's got the dependencies
are going to go with it which is
fascinating because you don't this is
not traditional traditionally people
think of dependencies this file depends
on the file and that's how make works
and that's how all the tools like make
work right it's like oh I have this file
and what what are the dependencies of
this file oh it's like these other files
and these other files in turn depend on
these other files but actually with this
you get to completely change that put it
on its head and say actually it's not
the file it depends on the file it's a
definition inside the file that depends
on a different library file so you know
that's kind of weird hmm so you know in
all likelihood there's consequences to
that and indeed they are when you get
into templates so now we have a template
called functional log like not
mathematical log but I'm talking about
logging something to encounter or
whatever so I'm going to write a generic
function called log which takes two sets
of parentheses and that's how you define
a template function in d s-- much more
concise then in C++ with the temporary
keyword so you say are the first round
of France's are like my compile time
parameters and the second is like my
classic run time parameter so I'm taking
any type T and I'm taking one value of
that any type team so okay fine inside
the long I'm going to import these guys
then I'm going to do whatever you know
the right so I'm going to write the
current time and I'm going to write some
stuff and I'm going to call log within
the file so within the main fine now the
question is for everybody of the vast
audience in this room if I comment out
the codes log should I even look up
those particular libraries that log is
using I shouldn't right I'm seeing I'm
seeing negative nots here
indeed there should be no business if
I'm not actually you falling the tree in
the forest if I'm not cutting the tree
for not using the function log internet
that's a pun log right trees come on you
guys form happening there huh yeah joke
hand yeah I got a get a get my drug hand
going a joke hand going there so if I
comment out the Colts log it means the
dependencies are not even realized
they're not looked up the those files
could be missing is what I'm saying
which is very awesome because hey at
this point I get to this point where I
are like okay so what I could do is
deploy a large library of artifacts each
of which may depend has its own
dependency whatever it is whatever
necessities I have but if I pay as you
go if I use nothing of that library to
start with I pay nothing because I just
paying the parsing of that particular
codes which is nothing like in the
economy of a build parsing of the decode
is like nothing it's actually nothing
incisions parsing with improvements in
technology has gotten to the point where
it's it's very low very low cost even no
tradition to it was very high so now we
have this um this nice setup in which I
deploy libraries I don't think of file
dependencies and stuff i all my focus is
I'm gonna give you the generic
components and you essentially whatever
you want and at that point the
dependencies will be realized meaning
the files are going to be looked up and
imported which is where the because is
very interesting
of course was a bit of engineering you
get to kind of once you you actually
open an imported file you cache it so
you don't need to open it twice in two
different functions yes like if you
import like that a CD dates time in two
different functions and instantiate both
of course you don't want to open the
whole file again and parse it again and
everything it just cash it and that's
that's trivial engineering so now I have
like juries that are faster to build an
import and which leads to an interesting
thing which is less pressure on the
linker which goes the following
who knows how linker works Shawn there
should be nobody because you have a life
to live right you should not know how a
linker works I'm really sorry for you
and myself that we know a bit right
because it's a lie kind of this right a
little so let's see what does the
linking process look like so have object
files and have library files so does it
go have a bunch of tables right so the
point being that with the object files
whatever symbols get resolved inside the
object file that's a quick process
because they're right it's in memory but
when you whatever unresolved symbols you
get those remain for the second step
which is looking at in other tables
which are archived they're kind of
there's an archive format for libraries
and there are many object files kind of
collapsed together and you kind of look
up load a bunch of files large files and
look up those tables and stuff and so on
and so forth that is the long part of
the run the link process that is why
linking takes a long time because you
have this you have these these large
files to consult if you get to resolve
most of your symbols within your object
file you're good and guess what with
this model of compilation that's what
you get to do you get to resolve a bunch
of your symbols immediately and it cost
you more to come compile those functions
but it takes you less to link and it
turns out with guess which is fascinate
the other right so you completely have a
bunch more control of anything it can
actually make it a lot faster so that's
less pressure on the linker to
essentially this time span to a linking
code and more time compiling code which
is a good trade-off to make so we got to
this point that is completely weird
because we started with something
completely innocent which is like I want
to put an import inside the scope it was
a very one of those nicey-nicey things
to do and it led us to some unexpected
point
but wait there's more I'm going to
measure what happens if you take a large
library and convert it to this approach
and I'll there's one obvious large
library in the de languages its own
standard library so a lot of people have
done a lot of work in converting the
standard library to the new format which
everybody now recognizes is superior
I'm sorry for bothering with the camera
there but I gotta watch you because I
think this is very interesting
so that led to the reduction of 4.45
times in the speed of importing a
library suggest you type import to do
nothing else and it just accelerated so
you got to down to 64 milliseconds which
is next to negligible and even better it
got when you do this kind of dependency
tracking or carrying code it got to
actually smaller object files because
when you import the library is going to
get its static initialization yes
you know libraries are like these you
need to initialize some things in some
libraries and it leads you to additional
code that you need to build in and it
leads you to more dependencies being
realized and it leads to kind of an
avalanche of other things and guess what
you get reduced object file size because
dependencies are on demand only not
compulsive so you got to reduce the
object file size as well and of course
that means the faster linking and
everything so that's actually a pretty
hard measurement of something that
looked very wishy-washy in the beginning
sorry awesome so the consequence is not
that we have definitions that carry deer
on their own dependencies to them that
means refactoring is a lot easier
because you get to move the code
wherever you want in the application
without worrying oh I need to go to the
top and you know pluck those imports as
well yes now you have like you get to
the physical design meaning layout of
files any way you want you don't have
the political strength anymore they're
automatic it's just bye-bye yes
doesn't mean we're going to have runtime
exceptions if the dependency is not is
incorrect no you're going to have
compilation time kind of instantiation
time which is during compilation or
exceptions for example if you use log
and the dependency is not there for
example missing a file or whatever you
try to build it's not going to build so
it's not going to be delayed all the way
through runtime but if you like you
imagine like my point here is that log
function could be one of thousands of
function in a large library right and if
you like you don't use like all
thousands of functions is like five
right and only dependencies for those
five that you actually use are going to
be executed try to instantiate it so
that is where you win you win during
built I'm not not that it's not a
runtime issue great so now I have this
place you go paradigm and it led to fast
and scalable built for large projects
because it turns out that in it's a very
common patterning project to import the
whole library use a small part of it and
then you have a different module in for
the whole large library it's another
part of it and so on and that's the way
that's the way the cookie crumbles and
only you just get this pay-as-you-go
structure for large projects which is
amazingly efficient you're looking at
you know the orders of magnitude in the
limit improvements of of all build speed
which is awesome so we had the saw heavy
handset effect remember the red
telephone company story and this weird
consequence which is you know the heavy
very shorter call times natural lexical
scoping leads to sell faster building
small object files which is highly
surprising great story number two big
laugh this brought down the house is
like macular Concepcion thing is like oh
my god that's so funny I can can't stand
myself alright so what I mean by that
well let's recall
the definition of a pure function pure
function like you know Haskell right
function programming what is a pure
function doesn't have any side effects
thank you so pure functions like
produces the same out from the same
input now or whenever it's independent
of typical examples of your functions
sorry
all of maths sine cosine log X
what-have-you
although that's not entirely true
because sums that they're not that's
ridiculous but anyhow so in general like
pure math does not what else print that
and not printer prints to the screen you
can't it's going to do a different thing
so Oh to string yes it's brain produce
the same string from the same from the
same year s printf yes s printf would be
okay printf would be the sort of the
antithesis of a pure function because it
does something every time you call it
and does it put in a different place in
whatever great so mighty sizzle is the
following it is difficult to write the
whole programming kind of in a pure
manner
it requires advanced understanding of
type systems such as monads and things
like that and so it's kind of a
difficult thing however I sustain that
if you get to write fragments of
programs in pure style this is easy and
useful because it allows you to very
easily analyze and understand those pure
functions much easier than if they were
kind of part of a big mess that was like
all Global's and all crap like my
stitches here and you know kind of to
add my seat back here pure functions
generate better code because for example
the same pure function called twice you
get to the what there's a key word here
memorize yes right memorize you get to
memorize the function because you know
it's going to return the same result
every time so if you call it the same
two times the same argument you just
remember the first call and you're done
so all right
the problem is how do you interface pure
with impure code because they work very
differently all right so let's take an
example here we have a functional
factorial so if you actually I'm gonna
try this stunt right now
you're right where's my cursor okay but
I've never done this okay functional
programming examples we chart the top
three results you think quicksort
factorial which is the one with
discussing end factor again and there's
one different one huh but I search maybe
not but I baited that within the first
page we're going to see Fibonacci all
right see all right should be fun
all right so function programming a
practical introduction function front by
example all right okay this is kind of a
long chapter now I just go to with the
Wikipedia page here and let's see go at
an example here history recursion
all right length systems data structure
so come on
okay printing first time people watching
numbers iterative printing first
function expression style all right very
nice alright now if you watch again come
on something else
oh it's just things you watch all over
like no D there you go somebody
introduced that as well okay let me try
out the second hit here I don't know
what is this special program basics
squint okay this is not an example
square resolve okay awesome okay this
goes on to show if you if you try
something like this so kind of going
online in the middle of your talk and
try to prove something is never going to
work so we we have the Fibonacci we have
the increment come on squares range
people height oh come on man
this is incredible function for examples
examples okay that should be interesting
but I suppose is our rather advanced
reduce okay awesome well I'm going to
declare this as a qualified failure
because my hope was within the first
page I'm going to see factorial
Fibonacci and quicksort all of which are
computationally problematic so they're
not to wit this is not the way the
factorial functionally this is the wrong
way of doing it and that comes with sort
of the advanced like you okay here's how
if you want your recursive recursively
nicely but actually this is not the
right way of doing it what do you think
is bad about this particular function
well it's what they call P space it
takes space proportional to the input
because in order to actually compute a
factorial you need to compute all of the
previous values and have them as
temporaries the problem being I need to
compute factor and then I need to
compute a multiplication and only then I
have access to the result so it's going
to take me space proportional to the
input and that's not efficient it's not
computationally smart it's not a right
thing to do so that's table
however the nice thing what is pure
because it doesn't change any variable
it doesn't use any any assignment or
anything it's just computes the thing in
the
so it's pure so notice I put like like
the pure attribute there on to it which
is great the way it's actually thought
like the right way of doing factorial is
to use a helper function which I call
conveniently crutch like it's a helper
which is going to actually thread the
temporary result through the computation
in such a way that it allows me to use
what's called tail recursion and
therefore get rid of the space cost so
the way this works is I'm going to start
quite with n + 1 which is my first
intermediate result and then I'm passing
that into the function and then crutch
is going to recurse to itself
with n minus 1 now the question to you
for you is what is the difference
between crutch and the this approach and
the previous approach that makes this
more efficient and desirable yes
why is it a recursive how can it tell
right so thank you so that how you
identify these cases is that the
function ends up with a call to itself
where is a final result it doesn't end
up with a call to itself plus some more
computation like here because here calls
itself factorial and minus 1 but it
needs to the multiplication after it
knows the results of factor and that
breaks this pose the whole party so
alright so you know what this is not how
it's defining the math manual in the
math manual is defined with a big pie
right it says pie from N equals a equals
1 to N of I it's a product it's an
iteration it's not the in math they
don't teach you this they then they say
oh if you're if you're really among the
smartest students you're going to get to
do this which i think is ridiculous
because you know as you know I was a
student I want to see like the math and
I want to see the mapping of the mass in
software so I want to actually see an
iteration and this is how like
this is the iteration it's a product of
all numbers between two n of n right so
that is that's what it should look like
but is not pure because it changes the
result during the working of the
function it changes the result
iteratively many times until it gets it
and then but that's not pure because it
changed it has it kind of has a sign
month it has this star equal I which
destroys the whole mood here right
well now you not I got to a point in my
life where I got to question everything
you know I couldn't find I'm saying you
know what I'm not going to accept any of
these preconceived notions of purity and
things and whatnot so therefore allow me
to retort what does the pure function
look like cultural reference yes you get
it you know oh come on you guys you're
too young Pulp Fiction did the movie to
watch you okay after this homework you
gotta go and watch it okay alright by
the way you have like 12 minutes 12
minutes ago thank you alright so what
does the pure function look like I mean
what is what is pure really well we said
pure functions always return the same
result for the same argument which is
sort of the teleological the purpose
oriented definition of purity is not the
implementation minded version is like
you should modify global because
otherwise you know the big but the you
know the big boo-boo is going to come
and get you right it's not it's not that
it's you should think of it in terms of
effects your functions always return the
same result for the same inputs nice
that means you shouldn't read and write
global variables global constants are
okay you shouldn't call impure functions
but who said anything about local and
transient states inside the function
that nobody gets to see who said
anything about that stuff why can't I
actually be a little impure in my
bedroom
I mean as long as I appear to the
society as a pure law-abiding taxpaying
citizen who cares what I'm doing within
my own quarters right now I'm looking at
the vast audience you like left and
right yes thank you very much
so I mean pure is as pure does its
effect oriented it's not implementation
it shouldn't worry about the way
implementation goes and actually you
know so once we got to this point in the
day language we had a chance of
redefining what pure means so we said
you know what actually this should be
pure this is a pure function it does
iteration it does mutation but that's a
private state by the end you get to see
any effect of any result of the function
the fact that it's implemented with
iteration recursion crutches or whatnot
is irrelevant
and therefore I'm going to be able to
put pure so the type checker in the D
language has actually a very fart that
make sure that anything you modify is
local and private and you're good
because it's look at result it's kind of
a local variable so pretty awesome
all right let's push this one one up
let's write the function reverses an
array like STD reverse in HDL in C++ yes
reverse an array and my question to you
is this kind of a classic image rotation
but my question to you is should
reversing an array be a pure function or
not no you shouldn't why should it it
changes say that outside the function is
not private yes however however let me
ask you this if I pass the same array to
a function a million times is he going
to do the reverse is he going to do the
same thing if I pass the array Shan
parent a million times I'm going am I
going to get the same result I can't
pronounce it but it's going to be the
same like terms of birth to the
this is deterministic so we have kind of
an interesting concept here which is how
do you define the same input is it the
same pointer is the same address of or
is the same content of the array so
actually get to push a relax purity even
further and say actually this is pure as
well because it has the same effect for
the same input so long as you define the
input as the you know the reachable
content from the parameters it does not
use any Global's it the what it does is
not influenced by the time you call it
right so obviously possibilities to
disallow but actually we explain we
experimental with this and we figure
that it's amazingly effective to just
relax the rule and operate with the
transitive closure of State reachable
through parameter which is kind of a
simple way to put it is whatever it gets
to starting from a their the array is
you define as your input as long as all
uses the input and all Global's you're
good so this is an interesting superset
of purity and it's all in the signature
so it does no need for other kind of you
know super pure you know weakly pure
whatever it just put pure there and it's
understood so you get two very
interesting points where actually you
can implement pure functions for
user-defined types such as begin which
is like an unlimited precision integer
in the D language is the standard
library so you get to say oh I'm
defining a vector for big int and big
int is written properly with the
appropriate pure primitives and then it
just just works so that's pretty awesome
and actually don't even need to put put
the pure attributes there by hand
because for a bunch of functions the
pure attribute is deduced instead of
being written by the user we figured
that if we ask people to write pure
they're just not going to do it that you
know people aren't you know they don't
want to put in an investment now for a
future possible benefit so the compare
is the best tool to just do it for you
so very interesting the after and here
the affirm a series of purity is like if
probably reach
of state and we have this relaxed pure
notion now global is no input and output
and no impure calls and the parameters
are indeed immutable then you have like
pure like in Haskell is the same thing
so this is very interesting because you
can use the relaxed pure functions to
implement the strongly pure functions so
that's pretty awesome this has been a
very interesting very interesting
exercising kind of questioning the the
pre preconceived authority on what
periods and what it is and shouldn't be
and we feel that you know as long as
it's private and etcetera and then we
get to the parameter and you've got to
combine impurity with miserably it
improves both because you get to write
more elegant implementations of sort of
classic pure functions so some of you
have this the last question I'm going to
say in like five six minutes we have
left is a string regenerative
programming this job brought down the
house you know about string Li type yes
in like number of languages string Li
type programming as opposed to strongly
type it's a player words because they
use strings to express pipes that was
completely useless because you all knew
that right apologies all right it's for
the general audience I'm not sure
millions of billions of people are going
to watch this and you know I'm
explaining for the sake of them so what
is generative programming code that
generates other code and for my money
this is the most fascinating area of
computer science I'd highly recommend
you consider looking into this deeply
because it's just a lot of generous
interesting things there so alright so
that's generated for you and the
specification of these thus cottager is
cause is often present in what I call it
via what's called a DSL which is thank
you domain-specific language so can you
give me examples of domain-specific
language thank you that you may use on a
daily basis ha Grado that's a bill
system right yes bill sisters make
Gradle and what-have-you right I'm a
you see make what it's all DSS which is
what others huh legs yaks thank you
excellent sequel domain strategic
language also actually give to embed
sometimes sequel you have you have even
like in c-sharp you have this awesome
link with AcuRite very nice embedded
language others okay didn't you didn't
elevate like my favorite which is
regular expressions yes it's a very
concise DSL for expressing patterns in
strings and stuff of tamata and stuff
like that so let's just plank plenty of
it even printf is a DSL because you get
like the percents and you know the dog
goal was weird
formatting slides that everybody knows
or needs to look up every time they use
them your expressions B and F grammars
helix and yak port of expression
grammars a newer thing that is like B
and F SQL everybody mentioned this like
this is amazing so now if you don't if
you get expresses in your own language
such as Ruby C++ Perl or Python or
what-have-you
you're going to get the same syntax for
all of these languages which is
unpleasant yes here what we want to do
is use with their own native grammar
process during compilation generate
decode which would be comparable with a
sort of a static compile time cheating
just-in-time compilation let me explain
first of all a bunch of these usable
during compilation which has been cargo
cultured into other languages as well
and this is awesome because I get to
compile factor of ten during runtime or
I get to say static uranium and in that
case is going to actually run the
function in interpretation mode during
compilation and this is very nice
because I get to decide when things are
done yes the very nice artifact that we
can also it has a has a loop as mutation
has things and all of these are going to
be interpreted and actually there's a
there's a guy in Germany who works on a
JIT during compilation which is going to
be like
thousand times more more fast than just
interpreting the HT of the function so
very nice all right and then we have
like another thing which I'm going to
say is the string Li part in D you have
this keyword called mixed in and what
you get is like like an idiot you get to
put a string in it and come here give it
to the compiler to compile it for you
which sounds ridiculous right so the
first big thing that I'm saying mix the
right line and we do escapes and
everything I get to write line hello
world which is nothing of interest but
the second use is more interesting
because I get to call a function during
compilation he gives me a string and I
compile that string into D clean tube
assembly into machine code so wait a
second wait a second I mean we have we
can evaluate both any function during
compilation and we can transform any
string into code wait a minute I mean
this is I mean there's something here
right you have like any function and you
have any string and any function
produces any string you get to make into
code that sounds alike like you know a
SN de Jas and scriveners you kind of
generate a string that's going to be
interpreted by the you know JavaScript
compiler and it's going to be very fast
and very nice and so something similar
is going on here
and all of a Sun it opens you the door
for a bunch of generative libraries such
as big fields which are not present in D
but are present in C and C++ and with
this way bit feels like that Bank syntax
is instantiation is instantiated
template which interest is going to
generate a string which is going to be
compiled by the compiler and I'm giving
two bits Assange given please lay me out
a UN called X of two bits long an int
called Y three bits long and in Z and so
on and so forth
and the mixing is a user level function
not a compiler trick
it's a user level function as going to
generate me guess what string for all
that shifting and masking that needed
for doing all that bitwise work and then
I'm saying me mixing here chasing in the
string the string I compile and I get
code that I use like regular code so
okay so that's a good start
so yeah so under there comes a guy
who'll write wrote a whole parser like
that thank you
so he wrote a whole parser that does
that whole thing and you get to use it
you put a grammar you write the native
vbn F so let's are just the Peck syntax
you write the grammar in a special kind
of dsl syntax any generates the parser
for you and it actually scales because
you get from 1,000 lines of Trance eyes
d grammar you get route generator parses
3000 3000 lines so it's like a
compressor and it's much easier to
maintain so you can think of it as a
highly integrated legs in yak another
last point I wanted to make is the work
of Dimitri so our regular expressions so
in num the D standard library gets two
kinds of regular expressions one is like
the classic reg X and the second is
compile time reg X which takes the
string during compilation and generates
a specialized automaton exactly for that
string for that pattern how much faster
do you think it is compare these two so
this is like a generic automaton for all
strings and this is kind of a
specialized for one particular reg X
which is faster Sean I see orders of
magnitude it can be a lot faster of
course depending on the regex and with
this I'm going to finish our e2 is the
main contender and I'm actually using
old results here because Dimitri just
sent me literally like last night he
sent me a message I'm beating everybody
I'm beating everybody
so the decompile sums engine is the blue
and right now it's kind of a parity
sorry too but actually with with Dimitri
latest work which is not committed so I
didn't show it it's actually the fast
the fast as possible and talking about
parsing URLs emails and and dates the
typical benchmarks for regex
so with this we actually get to JIT that
regular expression for date for example
for URLs into a very specific piece of
code that's going to know exactly that
pattern and with this you actually get
results that are better than the best in
the world in a very highly competitive
area with this I'm done thank you very
much you've been great thank you
Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>