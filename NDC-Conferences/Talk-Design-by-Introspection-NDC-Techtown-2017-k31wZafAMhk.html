<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Talk: Design by Introspection - NDC Techtown 2017 | Coder Coacher - Coaching Coders</title><meta content="Talk: Design by Introspection - NDC Techtown 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Talk: Design by Introspection - NDC Techtown 2017</b></h2><h5 class="post__date">2017-12-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/k31wZafAMhk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this is my singing welcome to my
second talk of the day in the conference
it's a it's a distinct honor to be a
sort of a repeated guest of this
conference very much appreciated a few
folks of you have seen me in the pre
conference workshops so today I'm going
to talk about something that I'm very
distinctly bad at which is a methodology
right so you know I want to I'm the kind
of guy who puts code on the whiteboard
and kind of discusses code and very
concrete things but this is gonna be a
bit more fluffy well it's that kind of
thing like we're gonna let me tell you
about like design patterns and policy
based design and so you know there's
still a chance you can go to those two
other rooms whereby interesting things
are happening so you know what's the
deal with the link D language so almost
it's kind of funny because in my heart
of interests the B language becomes more
of more of a solid substrate like more
like a core for doing interesting things
on top on than an interest in itself so
it's a primary language that I've been
working on for 10 years since it's a
very expressive language to which I've
contributed a fair amount and the most
most interested in things that happen is
after you kind of have crystallized the
finish of the language and it figured it
does things that no other language is
doing and that's where you know what
does will read the fun begins this kind
of the so what'll you deal with this so
that's sort of an initial motivation
Walter bright create the crit of the
language I was frustrated with the
existing languages because a well
systems level programming is always a
good thing to to be into because there
are many applications in which there is
really no limit to how much computing
power you want there's this uh-oh is it
yeah I didn't write this on the slide
because I was ashamed anybody knows
about a last
big demand this notion okay I'm very
happy nobody knows so now right now I'm
gonna take him elastic demand is a turn
from economy economists say that kind of
stuff
elastic demand which means the more you
have the more you want right is an
elastic demand for our drinking water no
you cannot drink as much no come on
right I argue with me on this is there
an elastic demand for yes beer is there
an elastic yes
is there an elastic demand for beer yes
yes let's go I see me tonight giving an
example of that happening by the way do
you know the job with the man who
deserves a beer every man is allowed the
beer but then he's a new man is a
different man pause all right that kinda
stuff anyhow does not part of the talk
by the way should edit that please take
it out so he done a number of
application domains in which there is an
elastic need for performance such as
yell at me talk to me
gaming yes what else
yes hft yes here here's the he's a
traitor among among you you know lynch
him high-frequency trading what else
statistics AII right so you know if you
know if you're doing your personal
website or blog or whatnot proud of the
speed with which it loads whether it's
ten percent faster or not it's not it's
not instrumental right but if you're
designing a site like Amazon or Facebook
you know a few percent are not gonna be
a lot less or more money right consider
this this interesting factoid every one
percent performance on the facebook.com
site where I work for six years on
variety of teams so every 1% you
accelerate the interpreter of the PHP
language which is really it's a lot
applause this application so every 1% is
two million dollars a year how we're
from thank you park you know the need
for power so essentially just power in
provisioning is going to cost you like
two million a year for one each one
percent so you know I was I was working
a team at fist guy maybe I improve
things by 10 percent while I was there
they owe me big money I should I send me
royalties here and the other engineers
who you know did quite a lot more
actually great so um there would be such
a need but also like you know for Hyper
phones there's always see and there's
always plus plus now the distinguishes
itself by saying you know what you do
have money for performance but you also
have a need for what they call modeling
so the applications become also larger
and larger and more difficult to reason
about and C++ would not be a prime
candidate for for making things simple
so that's what kind of deep positions
itself it's actually a fast development
language but it's also generate very
fast code so the design principles so
that was the initial motivation but that
kind of became its own thing as it so
happens it became its own beast and the
language grew into a multi paradigm
imbalance language pretty practical
principles and featuring Turtles all the
way down who knows the anecdote with
Turtles
yes a few of us I gotta tell it for
everybody I'm so sorry
this physicist famous tile Academy's in
physics gives a talk at the popular
science conference so you know it makes
a popular science talk about planets and
universe in a Big Bang Theory and
everything so then an old lady comes at
him after the talk and says young man
young man you are completely wrong about
the universal that stuff the whole
universe is resting on the back of a
turtle and the man says ok well how
about that or what does it stand on and
already said bits of
it's another turtle you know well how
about that adulterer what does it stand
on and only say you're not fooling me
young man it's Turtles all the way down
perfectly example of you know infinite
it's kind of infinite regression so that
all turtles all weight down Minda means
in program languages the following thing
let me share simple super simple script
which traditionally as always says hello
world on the standard output thank you
very much yes I know it's a fantastic
accomplishment so first of all like you
can script things like with Python or
Ruby so you can script things you just
put a sheet bang there it's just type
the thing it just works right so it
imports some it imports some library and
it says main it says write for me this
text
no problem I'm fine but then you know
this twist he can put on this you can
move you see the difference I'm gonna
kind of switch back and forth a couple
of times so it was a difference right so
the second version like does something
pretty it distinctly stupid it puts the
import inside the function are you
supposed to do that like in C who's ever
done it in C alright so here's a career
destroying self-destroying move here's
the guy who's not gonna get that that
bonus right this year so in C it's kind
of almost always a bad idea and people
very rarely I'm sure it all extended
idiot on a special occasion with with
the in certain circumstances and stuff
and sometimes it's it's a it's a thing
to do most of the time you don't want to
do that how about Python who's coming
for Python do you want to import things
in other things yes is it a good thing
right this guy's like all about equal
opportunity codebreaker same person
actually there's an open debate so I
should ask Robert next room like it's an
open debate is my understanding of
whether it's
the stupidest thing ever the spawn of
all Devo or devil or the awesomest
things thing ever so but let me tell you
what I mean by this with the turtles and
everything what I mean by this is the
following what you want to do is this
design the language in such a way that
whenever it makes you have feature a you
have feature B and you want to use them
together they should just work
agreed rights like Lego blocks or
whatever all those good things features
should be simple and easy to combine and
that's a that's kind of a natural thing
to do so you know moving in that
direction say well you know I should be
able to import the library inside the
function or inside any scope if I so
wish right if it's my in my mood I just
want to put things like inside as a post
at the top of the file because then you
know there's the properties of scoping
you're not coping with the curly braces
or in Python with the indentation and
you know depending on so there's a
scoping thing which is I'm isolating
things and isolation is good right come
on give me nuts
give me nuts come on give me nods yes
thank you thank you hands - I hope it's
not it's a thumb not a finger right so
but okay so we have this nice idea I
want to import libraries but I want to
import libraries in a isolated scoped
data hiding nice manner right great so
because I want to do that I want to be
able to do all the stuff and the
question is can you do it
so actually try this you know that that
was of years ago I tried this in the D
language I typed the code and it won't
compile because he said you're not
supposed to do that so I had a great
tool to solve that which is called a
telephone so I picked up the telephone I
called Walter bright the inventor of the
language and the guy who implements the
compiler for the language the front end
so I call Walter I said Walter I tried
this and it doesn't work he said let me
look it up and he said well in type
checking the import statement the first
line there says if you're in if you're
not at the top level
frozen arrow right it kind of stops
compilation it says you you're not
supposed to do that and I said why don't
you come on that line out see what
happens so he okay so that you know the
rest is history so what happened then
was actually it worked beautifully and
it became a very interesting feature of
the D language you can actually import
things now this is not this is just the
beginning I want to tell you how
something that is you know it's what
like in those stories of virtue and
stuff so if you do things the right way
a lot of good is gonna come your way you
know it's kind of that you know the gift
that keeps on giving the Karma you know
and all that all that Zen stuff right so
the zest of that happened afterwards was
the following
well so first of all let me tell you
this it does have to be mainly any
function any import whatever so then you
know people do very often this
refactoring they move functions from one
place to another in a large application
right well if you have the imports at
the top then you move the function and
you gotta kind of copy the imports to
the top of the new file right whereas
like this the function carries its own
dependencies sort of a sudden you switch
from the model in which we have files
that depend on files
ladies and gentleman right it's not like
that anymore it's functions depend on
modules right so it's a complete
different a much more granular
fine-grained approach whereby you have
dependencies that are the minimum
possible you know whatever that you know
you don't open that file unless you
actually need a function so the
functions become nimble and easy to
transport around and they're on their
own right they carried their own stuff
with them so that was interesting and
let me take it just one step further
because it keeps all things kept on
character going down the rabbit hole so
this would be a generic function because
it has two sets of practice that's how D
does general functions you say log that
will name the function and it takes any
type T and it takes any one parameter of
type T right so you can lock anything
you want a string
number whatever anything else writable
so inside the log we want to write the
current time so we're gonna import the
module date time and you're gonna import
a module standard output so we can write
it to the standard so I'm gonna write
the current time scuse me and a space
and whatever we we wanted to write and
then main would be driving this the
simple function now here's the
interesting part
what if I actually never used this
function and the phenomenal question is
do I ever look at this these two files I
open this is the file system going to be
read for these two particular files date
time and stdio what do you think should
happen yes sorry
it's very leading and manipulating the
situation indeed so actually shouldn't
it's like the tree in the forest right
if I'm not if I comment this line out
the compiler has no business kind of
eagerly compiling the log function and
all that stuff
it should say you know what good I'm
gonna just pause the function which is
like zero cost really and then I'm going
to not do anything because I don't need
to resolve dependencies for something
that nob nobody depends upon right now
who's using C++ alright what is the
largest applause was library using
probably boost is boost I know the
standard library like him he include one
thing in a standard library and you
looking at 20 megabytes of text right
like hello world uns you know standard
output C out whatever boom it explodes
into like thousands and thousands tens
of thousands really of lines of code we
can megabytes of text I really the sheer
fact that say our fellow world you the
preprocessor takes hello world like into
Brussels right it pre processes into
like 20 megabytes of code and that's
what the compiler see
the compare doesn't know that you wrote
five lines the compiler knows that
you've read 65,000 lines right now guys
our case I'm gonna look through this
stuff to see what's going on
so it's Kumar's gonna just rummage
through all that stuff is going to
finally get like main and see how this
is the code and then it's going to
produce an object file which object file
is going to have a dependency on like
see out and stuff and standard library
is going to link and the linker is
another piece of amazing technology and
it's going to like link that thing and
then the linker is going to produce an
executor or binary which when run runs
like it's gonna print hello world to the
standard output the sheer fact that this
whole thing works is the most amazing
accomplishment of humankind like in it
no it doesn't work once it was every
time in under two seconds now I guess we
should all wake up every morning say wow
that was awesome
Wow hello let me check that he still
work like this morning yes it's still
working it's amazing and you know people
say the tsipras compiler is slow no the
c-plus was comprised the fastest
compiled in the world it just has a lot
to compile that's the problem right so
arguing second so now you multiply this
by like a million you take this stuff
does you think this little reality that
well if not used it's not gonna be
looked at so you multiply this by a
million which would be a large library
and that means you all of a sudden have
a means to distribute a library that is
not going to inflict pain on the
compiler because parsing is cheap type
checking is expensive that's the problem
so you parse this but you don't open any
dependent files so you have a mechanism
for distributing libraries even better
yes
pre-processed
link model so it's disingenuous to say
this problem the problem oh yeah this AC
processor has a problem so the comment
was Justin just for the record you know
I can use it in the lawsuit that's gonna
follow that's a joke right so the
comment was well it's not a problem
property c++ leads from its pre
processing model which is inherited from
CN but I totally agree I mean you know
there's no disagreement there so anyhow
so we get to this point where instead of
distributing library says you gotta kind
of shoot first ask later like include
all the texts and then look later you
have this model whereby you know you
kind of include the minimum and then the
dependencies are going to be loaded or
not right look at ona so I have a better
scalable model for deceiving libraries
and indeed I've run a bunch of
measurements and the D standard library
so by the way this was like walled fair
it was like once the feature was in
everybody wanted to use it so they
people rebuilt the standard D library
which is like a large like I forgot the
the size broke two hundred thousand
lines of code so they took the large D
standard library and they put all the
imports inside right so they kind of did
did this work and it turns out that
improved the build time by an order of
magnitude of the library itself right so
that would be a good proof of concept
but wait there's more who knows how
linker works
who knows how a linker works we're like
five lights in this room right now
because nobody knows our linker works
right and nobody nobody should claim
they know even people who wrote the
linkers yeah magic yes that's about
right so you know I can kind of
speculate a bit on things so in essence
the linker loads you know give it object
files and it's going to rummage through
the object files resolving those
dependencies
but at the end of this this step in the
linking process there's going to be at
the end of it there's gonna be a few
symbols that are not resolved they say
right
those are referring to things in the
library that you link with libraries
that you link with and outcomes again
the linker brings a big hammer which is
I'm going to go to LD library path yes
open those fine libraries that I have
pretty fine and specifying the command
line what not all that it's amazing how
much stuff is going on right so opens
the libraries does linear search in
libraries looking for symbols and then
it finds the symbols and it's done which
means that actually it's kind of bizarre
if we have more code in libraries it's
gonna link slower and I'm sure some of
you I'm seeing kind of I'm seeing a few
kind of eyebrows you can yeah that's I
remember that so what is the longest
link linking time I've ever witnessed
like did you see like things like
minutes take the linking only right all
right so I've been doing consulting
companies the type make and you compile
in half an eye links in two more hours
and that kind of stuff right so it's
amazing how much how long linker can
linking can take so then when we have
this it's actually less pressure on the
linker because you resolve more symbols
in that early stage of linking which is
cheaper right you don't go to the
libraries you can have have the code
immediately available you pay more in
compilation but you pay less in linking
it turns out it's a great trade-off
because you have a control over a
compiler you can't nobody can control
the linker nobody ladies and gentlemen
so you know following this this is
notion emerging of well make a language
features simple and easy to combine
right so that'll be a nice thing to live
by and of course all languages would
wish to like every language designer
would wish to do so it's not that easier
obviously but I'm going to give you a
few illustrations of this for example
consider the study keep statement in the
D language which if you're familiar with
the C preprocessor is pretty much like
Pontiff right
they pound if whatever put this code in
otherwise don't put that what they'll do
something else what not so what you know
what do you think would be the major
liability with the pound if pseudo
whatever statement in C and C++ what
would be a yes sorry no another problem
with using it the problem with its power
of expression if you are if you wish it
knows nothing about the language so if
you try to if some expression that
includes like a double precision number
or it's some string or whatever is just
gonna work out it's a very limited sub
language that you can use in the
expressions so that comes okay so if you
have a static if statement straight in
the language no preprocessor then you
know it's not having things like like
this so people started to do stuff like
that
stroke rubbing hash table this is
actually production called from a
company in Tel Aviv called wei-cation
and it's it's probably the most the most
interesting and large application
written in the D language it's a startup
that does data storage and they're
actually the fastest in the world so
Robbie hash table key value and it takes
a maximum length of the of the array in
the hash table and yes like the static
if you know max length less than usual
dot max which would be something linked
to the type system it's not something in
the pre-processing stage it's something
that is proper to the type system is
like give me the maximum value of an
unsigned short and it does a little
calculation or it takes the size of here
and divides by it and whatever say does
some simple arithmetic and now it's
interesting because this particular hash
table here and that's more there's more
kind of on the other case whatever so
what's interesting here is that you have
this highly integrated Pontiff whereby
you kind of look at things that actually
received as template parameters and
depending on the qualities the features
of these key and value types that you
receive you
lay out your lay things out different in
memory in the hash table in this case
they pack more I think they pack more
the stuff they pack one neck stop by
because they have they have room for it
so okay that's interesting and can do
this in see who's who's with yes yeah
that doesn't matter
yes so okay you know there's no size of
in the pre-processing that kind of stuff
say you gotta read research like really
complicated templates and stuff so you
can there are ways to do this by the way
how many possible layouts do I have
there's two static if statement each has
its own else how many possible layouts
do I have depending on the key and the
value
- ^ - right because there's four
combinations of layers that can be right
it's to ^ - you can have if one else on
each branch right so all of a sudden we
have four layouts in very few lines of
code so this was all fine and dandy but
then it gets you - it gets you to want
more because you know I want to do with
static if what I do with if right I mean
I want to study gif and I wanna call a
function right
I'm just static if and I want to kind of
create objects and do loops I want to do
loop I want to call a function that in
turn is gonna do a loop in a static if
so that puts pressure on the combined
ability actually check this is in a
dictionary
that was a supposed to be funny it is in
the dictionary so it puts pressure on
your ability to combine features in the
language because once you have static if
is like you've had a beer you have the
right to another beer right so you have
the right to ask more for what
expressions you can test within that
static if so that takes you to well what
if expressions can eval a statically and
initially could the very things like
size of and +1 and - whatever they could
simple arithmetic but this so the the
pressure of doing things in you know you
know
turell's manner you know easy to combine
manner got to the point where you know
what let's allow an interpreter running
during the decomp compilation stage what
language should the interpreter take yes
d thank you yeah that's the right answer
one hundred dollars for the gentleman
why not have static well the have static
affirmative it's a good question
question notice the following
interesting part you see there's a brace
here and there's a brace here right so
let's say this is true and you have an
alias which is really like a type def
right okay using if you wish I'm going
to alias you short your essential to
this this name here but you know notice
that once I'm here door can I see cell
ID X it will pretty brain-dead if I
didn't see it right I mean it would be
purposeless so once you do a static if
you don't want that brace to count as a
new scope you want that brace to count
as the current scope and that does
happen in if right so with it feels like
I'm gonna open a new scope if that is
true and it's all dynamic and runtime
but we static if I want to stare the
scope and by the way what do if I do
want a new scope we static if what do I
do
I put two braces and this is an idiom
like you put you double the brace here
if you double the price their brace
there and it looks pretty awesome so it
looks like was I have this double
mustache right now right so actually you
do want you distinctly want static if to
evaluate things and then put in your
scope because that's what you want to be
you want teaching inject definitions and
code and things in your in your current
scope by the way that it is my opinion
that that was a fellow mistake that the
c-plus standard made with with their
incarnation of this feature which is
called if Const exper it does introduce
a new scope which makes a nine percent
useless so so the
got so high that actually we went to the
following thing notion we said you know
what here's the thing if you have access
to the source code of a function in D
you can evaluate it in compilation
period but not if like open files and
stuff right
so there's gotta be some limitations to
the power because you don't to a friend
to give you a file and say oh why don't
you compile this for me right sure and
it destroys your hard drive right you
don't want that to happen so you want to
allow things during compilation you want
to allow an interpreter for a subset of
the language right not the whole
language we can't call like primitives
in the operating system to RM - or -
that kind of stuff right so that was
very interesting so if you introduced
this whole notion of compile time
evaluation and that was like a huge a
huge thing for the D languages like oh
my god so now I can write everything
that I wrote already I can also evaluate
during compilation those of us who
who've been like with C process for a
while you know that does this for this
classic example of for example factorial
function or singly linked list or you
know these are this example of
computations and here's how you do it
for a runtime thing in his idea for
compilation thing it's complete
different languages right the template
language versus the runtime language
very different right
so it the key is to make it simple and
allow the same exact language to be to
be evaluated during compilation or
runtime and more importantly this is the
focus of the rest of our conversation is
what can I look at in the program
because I don't recall yet sighs often
this Lance is here I don't to look at
the simple things I want to look at like
you give me a type and can you call the
function it can't does you'd implement a
method called it right and if so I'm
going to use that part of the interface
and if not I'm going to make an
alternative decision so this takes us to
the more interesting part which is well
how about introspection but first let me
take a real
short detour into design patterns and
friends so um there's this thing policy
based design which was very surprised so
you know I didn't invent the thing but I
did invent the term so I gave it a name
if you wish it existed and the funny
thing is I I looked at it a couple of
months ago and I figured that it's
actually made it in on Wikipedia so it's
a thing if we say in Wikipedia there's
like 7076 programming paradigms in the
world and one of them is called policy
based design it was like introduced with
my book - applause design and that made
me dubious dubiously happy right it's
kind of an odd honor to have so anyhow
so the whole idea of of policy based
design is that well you have design
patterns and these ways of doing
software and with policy based design
you use the template ability of the
compiler to generate code for you to wit
this prominent member of the of the
program community made this comment
which I found very interesting and
telling the design pattern solution is
to turn the program into a fancy macro
processor the moment you tell me these
three working together I'm gonna be all
over it like white alright it's I'm like
you know what I want to be there fancy
and macro and processor this is
everything I trained for ok
this is amazing do I get the same level
of enthusiasm from this ok so
essentially it's kind of interesting
because you are doing something that by
the very very adduced can be automated
so that was the premise of Polish
business yeah I don't want to be the Mac
I want to be the guy who writes and
controls the fancy microprocessor
aforementioned right so that's where I
want to be so ok this brings us to on
other interesting quote by firemen feel
great physicist physicist so fireman was
was wrote a paper in which there is this
code what would happen if we could
arrange the atoms one by
the way we want them and then title of
the paper is plenty of room at the
bottom and the field started by the
paper was yes sorry
no quantum physics predated Richard
Feynman yes
nanotechnology thank you so he made the
paper in which he argued actually you're
not breaking in laws of physics if you
could arrange atoms by hand you know as
opposed to what we do right now chemical
reactions and stuff and catalysts and
all that stuff that I have no idea but
I'm making up things as I go right so
the problem with putting happens
together is our hands are too big right
we have two big hands well except tromp
tromp has more hands but that's an aside
and you know the only challenge then
therefore remaining is to build devices
that are small enough to be able to
arrange these atoms
you know manually if you wish so that
translated to the whole design and
design patterns thing takes us to the
the following core idea well how about
I'll look at the program elements that I
have at my disposal and I assembled them
by hand by you know introspecting them
and that's the whole notion of design my
introspection so in design patters the
programmer expands their own mental max
I have a factor here visitor here know
what to do observe whatever fine and in
the police policy design I go the I'm
the programmer I have a library of
patterns I have a library of my own
stuff and I combine them by means of
template metaprogramming well we thought
these are my two species it's actually
much simpler because what you do is you
look can you do this can you do that and
let's put them together let me show you
how to be able to do that kind of stuff
you need an input which would be
introspection do you support this method
what are they Tomas right list me all of
the methods you have tell me all the
signatures of the functions in that kind
of stuff
right so that would be the input to such
a design then we have processing which
is like I need to be able to do things
with these and you gotta have compile
time evaluation that's a given
I mean see how it's this is not smart
this is consequence you want to do
something and therefore you need this
right so it's not it's not invention as
much as following the thread you know
path of last last release returns and
output you gotta have a means to
generate the code and it turns out you
have means in in d quite easily to
generate code by means not only of
template expansion but you can expand
cause for Strings
that you compute during compilation
turns out a very popular thing indeed to
do is you take a regex regular
expression you look at it during
compilation you generate on automaton
for that regular expression and that's
your regular expression engine it's not
an engine that works with any you know
any string any regular it's a regular
expression engine that works with that
particular one the advantage being it's
gonna be much faster because it has a
loop that does like you know it's a very
specific and very fast engine sorry it's
not for partial programs no it's not but
I'm gonna save that for later so anyhow
we want to be able to do these three
things in order to have the
prerequisites of design by introspection
so you know in the de language there
will be like this in the language you
can always inspect his right tip Olaf is
going to give you everything there is
data in o-type all the data members
names types everything things like
traits give me our methods give me this
give me that you know that there's even
like the the sledgehammer of
introspection is the following
would this code compile I'm not kidding
and the funny thing is it appears in C++
as a semi proposal every couple of years
or so people say I wish I had that it's
a bit of a brutal thing but it has its
use and people read the
the following way what if I tried this
will you compile but he came back off
from that decision it's not a compile
time error it's a boolean which you do
study keep on and guess what if static
if you dot-com pulse I'm gonna do that
very thing right I'm gonna try that you
know if I can I do but otherwise I'm
gonna you know wait a second so you can
do this kind of stuff which is extremely
powerful then you have prop processing
with compile time function evaluation
staticky phone whatnot and you have
output you have template expansion you
can mix in mixing would be you pass it a
string it just oh you give me a string
I'm gonna take the string compile it as
code right so that would be the regex
thing so with regex you parse the string
the regex
you generate code as a string and then
you mix it in great so let me talk we're
not gonna kind of realize this real real
in detail but let me tell you about
something that I like a lot which is
optional interfaces who here has used
Java right or C++ with like in
interfaces like the way conventional the
people the interface in C++ a lot of us
tell me one thing is it better to have
large few large interfaces or more
smaller interfaces what is the the best
way to go about it who is with a big fat
interface right you vote for everything
like I'm gonna say yes to everything is
like in that movie right who's with like
several smaller interfaces you should
issue raise your hand - actually turns
out that commonly given advice in design
with interfaces to keep your interface
not too big because then you you kind of
you commit to a lot right you can meet a
lot of stuff by committing to a large
interface it's kind of unwieldy and
difficult to to mess with so small
interfaces are good however here's the
interesting part
how about you had a procedure of way of
doing interfaces that was in fact with
optional functions I
you could define it or not it's up to
you so the typical design by
introspection interface is going to have
a few required primitives maybe zero
I've actually a couple of designs in
which the zero required requirement the
zero required Fung methods in the
interface and we have some other
optional primitives which means you
define an interface as all the functions
are optional all the methods in the
interface are may or may not be and the
interesting part is that if they're not
there that information it means this guy
explicitly emphatically does not support
this particular primitive so that means
for the absence of information is
information it see what I'm saying you
see my point so how many possible
interfaces do I do we have I turn back
so you don't see the slide so if you
have an a method in possible internet
each can be or not be
how many interfaces that are distinct
are you going to be able to generate yes
its explanation is it's it's a power set
to ^ M right so it's you can you just do
one specification but you get this many
possible interfaces so you know what
ever since I got into this
this design my introspection thing all
of my interfaces are humongous because
because if the cost is nothing the the
fixed price of doing I think one more
method is zero right I don't need to do
anything so okay that's interesting so
um you have linear code but you have
exponential possible behaviors and that
includes state variances as well and you
know I can't insist enough about the
static if which like remember I
mentioned this company Weka that I own
they're like really powerful code in
their code base and I actually looked
browse through it and you know every 10
instruction every 10 statements there's
a static if no exaggeration I've got
appreciated just how much and you know
they complain about the de lengua so it
has bugs and whatever incident you know
this
problem that problem and I say well you
know how about why don't you do it in
C++ if it is so difficult and they said
we couldn't hope to approach this
project in C++ we don't have enough
engineers and time and Link our time
right so it's you know the fact is that
they have they understood they had such
a huge advantage from this very
particular feature that they they use it
everywhere and that the nice the nice
thing about static if is that it's
really it's it's really the Fourier
transform of if like by which I mean the
following if is a multiplex in time like
say it's a fork in time so if something
happens then you do this otherwise you
do that and that's in time right it
happens at runtime and as the program
evolves is gonna do an if and it's gonna
do two different things depending on the
boolean that comes all right fine how
about the design time and you have
static events the design time it's
there's no more time domain nothing
happens in time at when you compile it
it is I mean takes the compiler both
wild but it's not material to your
execution so it's actually each static
if interest and you design because it's
like you'd make a decision of laying
things out or doing things that is
statically chosen depending on whatever
boolean you have so each is of static if
doubles the design space covers I'm I'm
very very excited about this particular
feature so anyhow um there's been a
number of realized designs which I'm
going to leave you to to Google for if
you wish all of which are very small for
what they do that's the point
have a experimental memory allocator
which is a bunch of allocated designs in
12,000 lines of code and sort of the
closest the closest equivalent in a
traditional design jima lock which is
one allocate and forty-five thousand
lines of code by the way it's a great
allocator so this is good right but this
like includes that and a lot more right
so it's there's a collections you can
find on youtube or talk buy buy my
student and there's there's this
interesting check teen type that that I
wrote recently let's see how were on
time so it was supposed to finished 45
okay so I'm gonna leave the rest to to a
quick exposition let me see
so we've had sorry alright so we have
the domain of I want to check integers
for you know are they overflowing is
this good or not and I'm sure that you
know there is um where is it baselines
I'm sure you know about one of these I
breeze Mozilla checked in Microsoft safe
teen like the death star of checked
integers like humongous library safe
numerix which is like boosts candidate
right so these libraries are
implementing these generic checked
integers in in in C++ mostly except for
this last one and the problem is like
you have so many possible behaviors that
it's very difficult to design one class
and it usually comes like humongous very
very large and very unpleasant to to
look at and the interesting part about
design by introspection is that you
can't do this
in Bleacher like an order of magnitude
less code and with this I'm going to
show you the
i'ma give me just one second here I'm
going to share something about the state
of these checked integers because it's a
it's an interesting point whenever I
want to have a checked integer you want
to have a payload which is your integer
proper and you want to have a hook which
is going to do the checking sometimes
the hook needs state sometimes it
doesn't so sometimes it does it sound
like you know how many times did I
overflow some ties in doesn't and here's
where static Eve comes to place say well
I'm going to have us a hook if it has
state but otherwise I'm going to just
have the pipe hook without any without
any further state being occupied which
makes the whole thing efficient so
anyhow always this I'm going to kind of
finish early here jumping to conclusion
with design by introspection
you have an assembly of you gotta
rethink the way you do things because
instead of doing things that run time
you're mostly doing doing doing
compilation and you use for this for
tools one is static if one is compile
time introspection one is compile time
code evaluation and the last is code
generation once you have this at your
disposal you can harness yet another new
wave of designing things thanks very
much thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>