<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C++17: The Library Features - Nicolai Josuttis | Coder Coacher - Coaching Coders</title><meta content="C++17: The Library Features - Nicolai Josuttis - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C++17: The Library Features - Nicolai Josuttis</b></h2><h5 class="post__date">2017-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ELwTKHiKZS4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everybody once again I talk about
plus plus 17
superstar 17 language features now we
talk about the library features and as
you know it's a little bit difficult to
separate between these two because
sometimes the library has support for
the coffee chest so but again let's see
what I present so to some extent I'd
left make sure that if I have two hours
that one fits the first hour and the
other fit second hour so we are moving
more and more towards library pure
library features yeah my name is Nicola
you do distill also of some suppose last
books 20 years involved in C++
standardization and so it's partially my
fault what we see it the first thing I
want to introduce as library features
are so-called vocabulary types which is
to some extent we are extending the type
system of C++ 17 maybe again because in
in the old center we had something like
like string and pair and couple which to
some extend are now well you can
consider them as part of the pipe type
system although implemented as a library
but they are so deeply involved into the
system yeah so that you can consider
that so and the first thing I want to
introduce you is string you string you
is a new string class or spring like
class the idea is that copying a string
is expensive because part of the string
is the allocated memory to hold the data
so the characters so that means extreme
object is just the object itself and
referenda pointer to allocated memory
usually allocated on the heap unless we
have special allocators involved and
that makes copying a string very
expensive so if I copy this string
I have to copy the allocated memory
there is optimizations in C++ 11 to say
when I don't need the original I can
steal the allocated memory but it's
still expensive and the idea of a string
view as that we don't care for the
management of the strings of the
characters we have an object that
represents an existing sequence of
characters which hopefully has at least
the same lifetime as this object so as
you see on the right typical application
which is already then in many
applications is to say for example we
memory map data from a file in our
program which means more or less we get
direct access to the data on the on the
file system and instead of allocating
memory for it we just have a reference
to the address of the storage and we
handle this and and send it around so
that we save a lot of copies that means
that a Springview is faster but it also
has a couple of constraints and all
these constraints make it more
complicated to use it you have to be
more aware that you do the right thing
if you use it so one County or one thing
is it's not guaranteed that it ends with
backslash 0 yes you can let it refer to
something that ends with a null
terminator but if not you must beware
that for example here on the right if
you say I have a string dear to the
string data which is part of a longer
character sequence that after the last a
there's no vector 0 so if you use it our
parser to see something surprising will
happen another interesting thing is that
the default constructor for string view
arm
initializes the string you as I am NOT a
string as a null pointer so that means
that's the difference to string string
if I use a default constructor as
energized by the empty string this is
not the case for string view so you can
see it if you ask give me the data it
refers to and the data will return null
pointer so don't use data without
checking the size because the size will
tell you 0 and then you can use that but
that's that's coming from both things
because no guarantees there first use
size and then use the data never use
data without using the size and there's
no allocated support so we don't have to
allocate anything though that's easy we
have some support for that it came in
very late in the standardization process
so I think we don't have enough time to
integrate spring you everywhere in the
library so everywhere else in the
library but we're but we have some
support for example we have arm a
literal operator for it so if you have
some string literal and it ends with SV
you convert it to spring view so you can
initialize an auto s with this we have
the ability to use quoted coded for
Strings means that it writes out the
string with quotes and escapes backs etc
so that's also possible for spring view
and we also guarantee that the hash
values of string and steering you match
that make sure that if we if we hash in
in some containers that that the bring
and string view updates are placed at
the same location or are equal that's
also pretty expensive but fear for
example have no integration for example
for the records library the record
library does not understand a spring
view arguments
now that raises the question can we use
one as the other
and the decision is that we allow to use
a string as a string view because that
sheep I simply say ma'am or let's say
well I refer to the data that anywhere
start in a string but I don't you can
use string view as a string without
explicitly saying it so there's a
conversion but it's explicit so I have
to explicitly convert a spring view to a
string and the reason is it is expensive
because it educates memory and here you
see some example what it's for example
means if you initialize functions with
string literals if I have spring nickels
and I want to pass it to a who object
taking a string in the past we have to
compute the length allocate the memory
and copy all the characters that's now
better with string view because we only
have to compute the length because we
keep the length but that's all we don't
have to allocate memory and copy all the
characters but yeah but of course you
have to beware of lifetime issues here
patents a green roof you know it's a
literal the question is is it is a issue
it's the length really computed or is it
is there some special constructors there
are special constructors if I say this
is a C string with this size I can
deduce it directly but if not it has to
be fine so it depends on which
constructor you you use if you use a
constructor just using this string
literal I'm according to the standard
this is computed so we have to find the
Dex s 0 but I assume that under the ass
if ooh this can be optimized by all the
compilers and I'm not aware that we
haven't a special constructor for string
literals here you say if I have no no
you say I need a template constructor no
that's not true I could have an array of
characters not being a string literal
and it has the same type to that shown
that doesn't work yeah we we still have
all the problems we got some C ok the
question that came up again and again
one should are you string and which one
should I use it cheaper but may be more
dangerous screen view and one thing we
say is well if you have an API that uses
the value of the spring then it's at
least something to consider to use a
string view and that means look here I
have fee for example function you
getting a prefix a prefix spring which
of course usually we would declare this
to be conference string and then here
for example use some time point
computing to wizard took to the turn of
string representing the current time
with this prefix that's what this
function does so it's for example
pewds account time converted to a string
then the string contains a new line at
the end that's trade here and then
return prefix plus the arm computed time
string so if i want to come convert this
to string you yeah by the way this is
not exception safe but it's read say so
but if I want to now benefit from string
view I can do that
I can perfectly say I want to have a
string you argument and the
recommendation is to use it by value
because it's sheep it's only two two
elements or a length and a pointer and
then I can also use a string view to
initialize what see time gives me again
it's cheap I can hold it and then by the
way there are some special functions for
example here we don't have resize speak
we have but we have something like
remove suffix to say I'm on a shorten
this a little bit and but then when I
return it of course I have to use a
string because the string view would
refer to some data local in the function
and that would be a huge problem so I
would use something like that by the way
we currently have no operator plus yet
we are still discussing whether we want
to have sex or string view so that it
implicitly throwing you plus springle
returns of string that's something we
can't be discuss whether this is a good
or bad thing a lot of arguments in both
directions okay so here yes I think we
are not aware of all the consequences
about introducing string view we will
find out over the next year's be careful
bits using it yeah reference saying
string without any modifications
understand if you can't change the
underlying items what do you say a
string do is like a Const ring reference
so you can't change the underlying data
but the only thing is I can't modify the
elements of a string view are you sure
we I'm not sure about that but so for
the moment I'm not sure about that let's
double check that we had in discussion
also string span with things yeah let me
double check that you might be right
yeah I should know saying this is one of
the first times I present this library
and I also learn what I don't know yet
good we have new other basic data
structures and these are optional
variant and any if you come from booth
you might have heard them all but beware
optional in any is like in booth variant
is not alright this is significant
different it has same ideas but it it
will there will be differences so let's
let's talk about them optional means we
optionally hold the value so having a
week you can say we transfer various
semantics to reference semantics so that
we can also say there's nothing and very
end this you have we have a multiple
predefined types and our value can hold
at one moment one of these predefined
type and any is that you don't define in
a head which types are possible you can
help help hold anything in these objects
and now let's look into details so this
is SCD optional as I said pretty close
to boost optional you can say I have an
optional string if I don't initialize it
with something that means the string is
empty and excuse me the up
Phyllis MP that means it does not have a
string even not an ultimate an empty
string and if I initialize it with a
string it gets that value I can change
it by assignments according to some
rules if I wanna find out does it
contain a value or not I can ask has
value or excuse me
you see the conversion to buoy if I want
to use the value I call the member
function value and if there is no value
there is an exception bad optional
access and you can make it empty again
with reset so some interfaces there you
can see what this means if my function
can return a string but it might be that
it does not return string we can have
three cases we can return an optional
initialize by noting that means we
return null string we can return a
string that is empty which is a
different case of different state and we
can our have a string that's non-empty
and now if I use it then I check check
again I check the s and if it gets true
there is a value I can print it but it
might be empty though it covers these
two cases and if I have no value I I
have nothing yet question there
sin equivalent to boost none I think
none is I have something in mind that
there is something but good question
I have to write it down
maybe I learn more here than you value
all value all yes value or Y value are
here now I could again take good variant
variant is an object that can hold one
of several predefined alternatives it
differs from very antic in something for
example it does not allocate memory
anymore like boo stuff and it the the
prices that it under some strange
conditions it can become empty usually
it's not empty it it is one of the
specified various so if I have a variant
in spring I initialize it with 42 then
it's clear because that's meand this
variant holds an in-country and an end
and unlike the variant let the Union
language feature it's not that bits are
interpreted in different ways I know
what it helps it's not a trick to have
type conversions over bits it I can just
hold one or the other so I know that I
held an int now and if I assign a string
I know that I now hold the string and I
can ask for that I can ask what is the
index and if the index is 0 it's this
type if it's money at this type I can
ask please give me this string and if it
contains the string it's fine otherwise
I get an exception or I can say give me
the first or second element and of
course there has to be one otherwise
this is
an error the if you don't initialize the
object the default constructor of the
first type is used to initialize it so
and if you don't have a type there you
can use yourself the first alternative
called mono state and model state is
just a trick to be able to declare these
objects and that they hold state outside
every other alternative so that's the
way it is used here that here's some
error handling well first of all I
should say it can have multiple
instances of the same type so a variant
can hate can hold one end or another end
of string so you can have different
semantics for the first and the second
end and then of course it's a problem if
you have give me the end that's of
course not possible but you can still
say give me the first or the second
element in of this variant and if you
assign a string then it's clear that it
is this one so that's possible so if I
try to get a double that's a
compile-time error because we have no
double if I get the fourth alternative
that's an error if I get in that's an
error because I have two inch but this
is okay and and might throw in runtime
exception is currently the variant
contain something different yeah and you
have visitors as in boost you can say I
want to I'm on a deal with all the
different alternatives I have so
whatever my my object has I have a
wizard tour that I can call visit with
and say for this object please depending
on what the type is use this or this or
this arm function to deal with it
the third one is a CD any has to be any
is again maybe maybe I have enough time
to show you one thing because no that's
not to say a variant one thing I want to
show you the case when when a variant
can become empty it's usually not
possible unless you you have an
exception which you don't handle
probably and because that's possible
a variant can become empty and you see
what how you can do that you say for
example I have a variant of float int
initialize by a float then I call here
arm here a function that initializes is
with an int but it throws an exception
doing that so while assigning a new
value I get an exception and the
question is what is then the case and
that's the case where we say oh we don't
have a value because why it assigning a
new value an exception was thrown and
then this read leads to to semantically
an empty state but we don't call it
empty we call it value less by
exceptions so you can check for that and
yeah so we have that it's yeah it it's
something you have to keep in mind but
as I said it's not the outcome of
typical code but it can happen any any
other firms like booth any an object
that is possible to hold any type unless
the other two types you to have no clue
what it holds all information has to be
checked at runtime for the other types
you can find out at compile time whether
this is a valid type or valid value or
not to some extent if the type system
allow
you hear we can have just any type the
trick is that internally we saw the type
ID of what we saw and we saw the bytes
that's all and so if I say I assign the
strings or hear this then I have later
to test is there value so any can empty
be empty again
and then if the type has this type ID
then I know that this is the type and
then I can cast it to this type and then
I have to value inside and that's that's
the whole trick
it keeps the type ID plus the value
and spare us the question of whether its
equivalent to the type idea of Lloyd I
don't know I have on my list that I have
to double-check what happens with void
types while these types I don't know so
I think it has very itself returns the
boolean as well
you mean that if I don't have a where
you is that the same as type saying I
f-type I'd avoid I don't know yeah I
don't know I don't know yeah I don't
know sadly you can have move semantics
but you can't use types that have own
that have no copy semantics so copy
semantics is required but it's not
mandatory so you can have something like
this you can move something inside and
in the end you have to move it out this
with this syntax out but as I said if
you try to use this with move only types
this will not compile
okay
some other libraries armed here we have
the objective data here we have two pure
new library that's a real library that's
again from boost coming boost file
system if you are not familiar with both
file system it's a library that tries to
get to standardize the way we deal with
file systems even having an account that
there's open VMs and UNIX and windows
with all the differences they have and
here you'll see some example what you
can do this is an example that more or
less you can exactly use with boost so
you only have to exchange the header
file and you have to change the
namespace so here I use now STD file
system path and set of boost size system
path and I can initialize a path coming
from the command line if there is
something I can check is it a regular
file I can ask for the file size is it
the directory if so I can iterate over
the directory now of course with the new
modern C++ things like Auto reference
sets and directory and pre iterating
over all the elements the trick is that
the directory iterator it says provides
begin and end and then we can use the
path again to print or to to do further
things and maybe one interesting thing
also is if I print P a path it's usually
quoted so it it is at the beginning and
the endless with double quotes but as I
said that's nothing that changed from
boost it's less standardized here you
can modify things you can say here I can
I can declare path by the way with the
operator / let's the path operator that
works and it's not back session windows
by the way it's still this syntax in the
source code and I create a directory I
create a symbolic link I have the yeah
extend the path operator I can convert
it to string and if I want convert the
so string that's what I need when I for
example open this as a Oh Oh Xtreme we
have not known a real integration now
for F strings with path elements I think
that's still an issue but as usual we we
come up to standardize the different
libraries and putting things together
sometimes we learn sometimes you think
about it sometimes not yeah some some
some things to tell you about that so we
we have to take in mind that different
file systems have different definitions
of what is the past and what is a file
so we we have a root name and windows's
might be see column in many or all
systems that are UNIX or POSIX like of
standardized universal I don't know the
name Universal pass syntax is double
slash host then the root directory then
a directive separator which might be
flesh of XS or dots sometimes and then
we have file name consisting of a so
called stem and an extension and you
have to deal with that and what this
means is for example that if you use
this program I have full that bar behind
I print this out under UNIX at foo bar
and the windows its food backslash bar
and if I take this path I print it I
would print this path but when I make it
make preferred I use the preset syntax
of the Kansai system so that would mean
here at the UNIX is this on the windows
this and I should write your openvms
that would say in square brackets food
dot bar and then afterwards data dot B
Steve for example to give you something
totally different and then we have root
name root directory with the different
syntax and maybe one interesting thing
is is this an absolute path and the UNIX
the answer will be yes and the window
the answer will be no because an
absolute path requires that you can
start from some root and we have C :
they start and we have D : this path so
this is not an absolute path on the
window
and we don't hide that in the library
because the carpet it's not an absolute
part under windows so that's something
we keep in mind and sometimes leads to
surprising behavior
yeah the UNC path is supported that's as
I said that that's that's more or less
the syntax yeah that can be used here so
in Windows there is a absolute path if
you start with a UNC path yeah and then
you can have something absolutely yeah
we have made some changes when we adopt
the vice of some library let me go here
to show you the example then that's
better to explain it so there might be
we might break some compatibility if you
just switch from boost to C+ or 17 for
example we no longer say that dot git is
an extension in the old existing
language this was considered to be an
extension and not a fire name so if you
ask for stem remember a file name is
stem plus extension stem both empty and
this will not no longer be the case and
now here we say this is now define a
means get stem is get the extension is
empty and this was different before
another interesting thing is here we
have in the existing library we say foo
bar dot is the same as full bar and
sometimes the dot gets automatically
appended and if you ask what is the sign
name of this you got dot we thought this
is very confusing and this was a source
of confusion when you use booth and we
said this is the last moment we can
clean it up and we set now this is the
finding is empty here here's the file
name dot here is a fine name empty and
this has a couple of consequences when
you deal with it for example has fine
and will now get false here previously
it did yield a true so there are some
changes and but we now consider in
sup working group of the library working
group that this is more consistent it's
still not adopted it will be adopted in
the next meeting all these changes that
make this consistent as it is I
hopefully it I hope it will
and then we cared about one thing that
everybody who uses file systems has a
problem everybody has relatives paths
compute the path between two absolute
paths almost everybody has a helper
function implemented and they all have
their floss it's really complicated
because you say if I have a path ABC and
another path a B so what's the way to go
from an a B to C and the answer this
would say is C so what is the problem to
have a function to compute a relative
path between two absolute paths well
there are a lot of problems one thing is
should we normalize this so if I say sup
that dots up dot should this yelps up or
this how to deal with symbolic links
this becomes very interesting if sub
dots that is not the same as up because
here's a symbolic link involved on
family you switch to another place in
your file system and what does it mean
to deal with dot and dot up what if the
path exists or is it important that the
past exists or not and what if there is
no common route it's for example you you
want to have the path between two things
these two things what is the relative
path between these could be gives you an
error or should be just gives you
instead the absolute path so a lot of
questions they still cook us a lot of
time I know it because I was partially
involved into writing that and just to
tell you at least one thing sometimes
things are surprising if you have this a
CD it's a symbolic link to this a B and
you go into a UNIX shell and say CD a de
you are here but if you asked your shell
the shelters say you are an a de prepare
that and you can say something like LS
dot dot e because you are you are going
here and then back here but you are you
are here and daughter and then e what
should not work it's a courtesy of your
shell that this works but it's a lie and
if we have a vise system library we of
course have to think how to deal with
that you by the way you can do this by
use PVD meanness - big capital T or C D
minus P and you will see the real path
you are in other you can you can you can
after a CD command C the real path you
are in I didn't know that before I
started to standardize this little
function I was very surprised maybe you
are also so depending on that we decided
that we say well if we move around here
if we want to go from here X Y that to
here ABC test fire what without knowing
anything about symbolic links we should
go up now with symbolic links without
knowing anything about so buildings we
have to go up up up ABC test fire but
because this is the same as this we only
have to go up and then BC test fire and
the consequences we have a couple of
functions to deal with rival at this
pass some are lexically they don't don't
take the existing symbolic links into
account some are you take the existing
file system into account so it became an
interesting issue yeah I think that's it
so that's the most important things that
change about file system library
another thing parallel execution of STL
algorithms why we have support and in
modern c++ for concurrency we don't have
algorithm support in a way that we can
say if i call an
algorithm like for each of salt even
better thought that and I have either
multiple cause of multi-core CPUs or
whatsoever that I can benefit from the
fact that I can sort and parallely
different areas of my containers of my
ranges and this is done in an so-called
parallel STL and this was part of the
so-called parallel T acid it now became
a part of C++ 17 and I'm a stupid
application programmer so I started to
find out what is the difference because
we have now three different strategies
and guarantees we can give and this is
what I came about and unless somebody
proves me wrong this is a poor man's way
to explain the different policies the
first policy we have now is when we want
to compute a deal with all elements and
with each element we have to call a B
and C that we first call for the first
element ABC then for the second a b and
c and then for the third a b and c in
our container
so that's sequential that's what we have
already for all the algorithms but now
we have two other ways the one one thing
is parallel is sequenced and the other
is an sequence execution and sequence
execution may I can in parallel start to
process a B and C for different elements
but it's guaranteed that inside my
thread I have after a for the first
element I call B for the first element
and then C for the first element while
here even that is not guaranteed I can
say I can start in my sweat with the a
for the first element then a for the
second element is on them here again so
so I have different paths here to go
through my Processing's
and of course different guarantees are
given this this is you have this
guarantee then you can use the parallel
or vectorized execution but if you have
a lock here a lock go block a twitches
unlocked here this will block of course
and cause a big trouble so you have to
know the tools we have to give some
guarantees so that the execution of the
parallel divers they can do what I can
use this or this policy to deal with
them and anything else is implementation
define quality of implementation yeah
yes you simply have a new argument at
the beginning saying power
I'm sequence parallel or sequence
sequences like not having the argument
parallel is yeah if you have a lock or
something like that you should choose
that one in here if you really have
nothing if the D computation here can be
done for one element and then for the
other element before you go to this
second statement so that's that's okay
splicing certain maps we have some new
support to deal with the fact that I
want to move element from one set or one
map to another here you can see how it
happen I have a map initialized with
these three elements here I have another
map with this element what I can do now
I can extract this element or I can use
a iterator or find the element by value
like he and then I can insert it in the
other map the point here is that we keep
the memory so usually when I take an
element out of a set of map and insert
it somewhere else the new element gets
new memory but here we get it with
extract we get a handle including the
memory for this element so that
inserting it somewhere else becomes a
cheap operation that's that's small as
all with some error handling issues for
example if I extract 3.3 years and I
insert it here this is a map not a multi
map so this is an error then you have a
special state which that you can use
here you can you can get the information
which key and map is the end and whether
this was succeeded so inserted as false
here and you can deal with that so let's
take this example like here one thing I
want to show you is one interesting side
effect here is that you can now keep
change the key of map elements you can
say here I have a map one two three
different fruits I extract the element
this - this is a handle the type is auto
and then I can set the key to four and
then I move it back into this map and
then I have the new map and the
interesting thing again is I have no
memory allocation here involved at all
it's just changing the key and then
inserting it again somewhere else so a
cheap way to change the key of man
and by the way it can be used in sets
and maps it can be used to move elements
between a multiset and the set and also
it applies to unordered elements
elementary string conversions for those
who write low level to implement low
library low-level libraries yet another
way to convert integers and floating
point numbers to strings and back and
forth so that we don't have to use
printf or something like that because
strings are far too expensive no
allocators involved so it's not like
like the two string AP hi we we already
have there this is a low-level interface
so we can say I have a range of
characters here to begin and end and I
want to convert this decimal into a
sequence of characters containing four
and four I do that and one interesting
thing is we guarantee round-trip ability
so if we say convert this floating point
number to a character sequence it's
guaranteed if I read it back with the
corresponding from jaws function it will
have the same value on the same platform
it's not guaranteed everywhere because
it depends how many digits have to be
written to be guaranteed that the exact
the same value comes back that's
platform depend and it might be might be
a pretty long list of numbers though
depending on your platform by the way we
have new shared blocks in when we
standardize in modern C++ new Texas and
locks we had a great example written by
Howard Hinnant and now we adopted a
little bit or 50% in C plus at 11 then
20 more percent in C versus 14 and then
now maybe 10% more in 6 or 17 we'd still
not adopt at all let's see what happens
in the next standard we should have
adopted everything from the beginning
because it was a cool design so what we
have now is we have readwrite locks
which we both introduced in Super
supporting but only two as this
times new Texas now we have shared mutex
that that can't be time and we have
support for them
atomic for atomic we have the C
interface we hate C interfaces so we
have something new and we now have a
context bull atomic is always log free
we decided that this is good enough it's
usually not that interesting whether we
know it's sometimes or is it's always
actually so it's never lock free so in
here these constants might have one of
three values this is good enough in this
movie to have C++ support so c++ syntax
for this question and then we have a new
type trait note we have a lot of neutral
pivot but we also have a general way to
use the tripe traits if they return a
value you might know already that if I
have something like that yet attack for
example the corresponding constant type
or of something that I can instead of
writing make cons or remove cons I hope
this is exactly the name I don't know
I'm not sure that instead of writing
colon colon type at the end I can now
write make on underscore P and now we
have same thing for the value type trait
so instead of writing is constantly
colon colon value I can now write ISKCON
where you of P which makes something
like this a little bit shorter more
convenient it's by the way an
application of various so-called
variable templates which were introduced
in C++ 14 where we can say this is this
is a shortcut of a variable for this
member of a structure so that's a
typical application of variable
templates
we have new numeric library functions
I'm not really an expert here so if
somebody tells me now we have Bessel
functions or elliptic or polynomials I
have no clue what this means in detail
but if you care you probably know and we
have the greatest common divisor and the
least common what is M multiplied yeah
so a little bit more new numerix library
features now and then we have a couple
of other things let me see how much
slides I have to this yeah it's edit
template actually I don't know we could
look yeah I don't know whether it's
generalized as a template I would
consider yes but I have to double check
and then we have a couple of other minor
fixes we have so string has now non-comp
data member which was missing we have
new search algorithms like Boyer mu and
Boyer muha spool for those who know what
that means that it's better algorithms
to search something we have full support
for memory soft management's or special
classes where you can say I have I want
to I want to have my memory management
and want to deal with it in this with
what's helper functions I I don't know
the details here for yeah exit alignment
I showed you in the talk before so we
have new new new functions so that we
can align now data that we allocate on
the heap and we have a couple of new
type traits one thing is is callable its
negatives and
something that it has unique object
representations what does that mean that
means that I said for any value of my
object it has always has the same bits
to represent to the value it's only a
unique representation of bits to have
that value that means you can hash over
the bits instead of the two to hash over
the object and get a unique hash number
so this is useful when you do hashing it
doesn't work for for values where you
can say I have different bit
representation for the same value for
example like and like in float or in
strings or so then then it's a problem
but for anything else I can do that to
hash over the bits of an object and get
a unique hash value yet it if it tests
if it is a struct that has turned in
inside as far as I know it has on the
platform a unique representation it's
always the same value has the same
format of bits so it would answer yes
you have you go if I have padding then
you can't do them in coffee true yeah so
I would assume that it returns false
that's the whole idea here but I have to
double check or maybe you doing send me
an email
good
okay for the catch called the cash
alignment okay yeah okay so you say the
support for the execute the language for
evaluations of Sukesh alignment you say
okay thank you very much you find out
exactly where I have no clue about some
things of the library yeah
how much can I pack in one cache line is
a is the okay yeah last one is what do I
have to do to make sure that okay so how
much I have had so what do I have to do
and to make sure that they are not on
the same cache line to avoid force yeah
I have to repeat because that sounds
familiar
I'm happy to explain it better in future
once I understood it in detail
thank you you would share pointer now
has support for for arrays so that you
have that automatically the destructor
called
delete square brackets instead of delete
without square because we had that
already in unique pointer and everybody
was wondering why we don't have support
here for shared pointer for the same
thing
yeah we have some some bug fixes or
fixes in general some things yeah I I
just can tell you so one thing is for
for memory memory for the memory models
we have some policies to place memory
barriers and it turned out that nobody
did implement memory order consume
special so the as a consequence it's
currently discouraged until we find out
what we really mean and then bring it
back to to the compilers so that it's
exactly like that
so temporarily discouraged is this value
for memory order management yeah and
then yeah sometimes some some functions
return a reference to what they were
inserted because we were not consistent
there for example because for insert
functions we have that we have in sed
function no longer support allocators
and shared from this we fix some things
because it was not guaranteed what
happened if shared from this is used
without an one object that never was
hold by a shared pointer the old
standard was simply not clear about that
and now we know that this rolls the bad
weak pointers of that is this is a weak
point and we saw the corresponding
exception if we if we use a weak pointer
that refers to nothing adding expression
in a huge number of places really a huge
number I think every meeting come I
don't know ten papers about we should
act context for here and here and here
and yeah share pointers now provide a
weak type maybe one thing is undefined
behavior for type trades now if there is
no behavior and that was interesting if
you had a reference or pointer and you
said make
signed we behaved about undefined so
because the specification was it's
required that this is an integer and if
it was not and a reference is not an
integer it only refers to an integer
make an site has undefined behavior so
if you use that you could have on one
platform one thing and the other
platform and another thing and here
thanks to some guys I think from Russia
and we now have the guarantee that
instead of having undefined behavior we
say this is simply an error to use it
because this is not part of the code and
we don't lose anything here if we say
this is an error sometimes in the
standard is actually has a tendency to
give freedom of implementation to the
platform providers but we should not
give this freedom in cases that they are
obviously wrong in on all platforms so
this is a good example where we fix that
yeah that's it probably I missed two or
three things I'm pretty sure of that but
that's that's what I learned so far from
the standard I think a lot of
interesting things are coming and as
usual I showed you some of the
combinations of these features we will
you will find out in the next three
years what we missed with all these
libraries and the language features I
didn't talk about some things like londa
or other things but you might have heard
there there are still some strange
things really happening in the standard
and in the communication between car
guys and library guys where I yeah
usually I'm sitting down and just
wondering about what people are talking
about that's my problem as an
application programmer anyway do we have
any questions I'm hopefully can answer
if not that's it thank you very much
again and good even have a good party I
would say thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>