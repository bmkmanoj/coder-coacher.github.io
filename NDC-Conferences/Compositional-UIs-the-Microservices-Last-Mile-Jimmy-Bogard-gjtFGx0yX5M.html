<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Compositional UIs - the Microservices Last Mile - Jimmy Bogard | Coder Coacher - Coaching Coders</title><meta content="Compositional UIs - the Microservices Last Mile - Jimmy Bogard - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Compositional UIs - the Microservices Last Mile - Jimmy Bogard</b></h2><h5 class="post__date">2018-02-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gjtFGx0yX5M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well good afternoon everyone hope you
enjoyed lunch and everyone was able to
make it to the pub next door as well
it's so close so today I want to talk
about composite UIs
you know what I think of it as is the
microservices last mile so this is one
of those topics I don't hear really
talked about a whole lot and have a
couple of theories behind this one
theory is that I know a lot of companies
talk about micro services in terms of
the back-end architecture so we'll have
API is doing different stuff and it's
very self-contained and autonomous and
things like that when it comes to the
front-end I don't see anyone talking
about that at all and I think one of the
reasons is that's a lot of companies
secret sauce like how everything comes
together into one single coherent user
interface so I don't see Netflix
engineers talking about this I will see
Amazon engineers talking about this
Facebook talks about a little bit but
when it comes to that last little part
of the user interface that's the stuff
you don't see many open-source projects
about many presentations about so a lot
of with this topic is about in this
presentation is partly a bit of my
experience in building these kinds of
applications with these composite user
interfaces things that I've done into
projects for my clients but also I it's
a little bit of me taking those
engineers out to drinks during
conferences and then giving them
probably more than I should have and
then like nailing them down to the floor
and say you've got to tell me how you
actually built this and so that's some
of their some of what I have in here as
well as some secrets I've learned from
how Amazon and Netflix build user
interfaces as well as some of my
experiences in people I've talked to so
I want to take just a little bit of time
to do level sets on microservices
biggest thing one one thing that
developers are really good about is
agreeing on the definition of things
right right like rest has a literal PhD
dissertation saying exactly what it is
but no one actually agrees about what it
is anymore so that's that's all our
fault I think so let's let's do a little
bit of level set to say what do we mean
by micro services
well Forster first of all micro services
is not going to be a specific technology
or stack so micro services
does not mean docker it does not mean no
does that mean as your service fabric or
whatever thing they decided come up next
doesn't mean lame to functions it
doesn't mean rest it's none of those
things and in fact anyone who says so is
trying to sell you something
so someone coming doing saying oh you're
not doing docker you're not doing micro
services check to see if they're a
docker consultant they probably are so
well what is a micro service and
unfortunately it depends on who you ask
so the definition that I try to go from
is the micro services book now there's a
micro services website and some origin
behind the term so I try as much as
possible to go to something that was
written down well unfortunately that
definition wasn't too specific either so
for the micro services book by say I'm
Neumann it says two things one it's
small and focused on doing one thing
well and the second part is a ton of
that it's autonomous the end so even the
micro service definition is micro as
well so looking at first definition its
small and focused on doing one thing
well I could argue about any one of
those terms about what exactly they mean
well what is what a small mean to small
mean the number of lines of code maybe I
don't know because I've seen some F
sharp code that is pretty crazy to fit
everything on one line it's all just
like weird characters and glyphs and
stuff or if you have like a Java micro
service it's 99% XML so who knows what
that actually means what does it mean to
be small focus on doing one thing what
is one thing is that one function is it
one database table is it one controller
with one action there's no real
definition here so what I tend to think
in my head of what a microcircuits small
and focus it's the smallest focused
autonomous boundary that we can make so
we're trying to make something as small
as possible that any smaller that we
would go then it will no longer have
this property of autonomy so that brings
us to the next definition what is
autonomy autonomy has a few different
properties one is independent ownership
availability and delivery that means
that this thing can live on its own and
take care of its own stuff without
having to go to anyone else to be able
to performance work it manages all its
own information
so that means that doesn't share anyone
elses database it has its own data that
it manages it can handle any failures
related to that service and finally it
has some contracts about how it talked
to the outside world now my cursor
verses were originally defined as a
contrast to another kind of application
this big bad monolith and no one wants
to have a monolith right that seems
really bad and monoliths aren't these
things that are the catalyst for human
evolution which is what I gathered was a
meaning of this movie monoliths are
these really big ugly applications that
are just giant big balls of mud and some
most applications that I'd work with
looked something like this
there is the app and the database and
I've actually had companies I work with
they call their database the database no
again this works for a lot of companies
right you can you can you can you can
live a long time have a long life within
a company of having an application like
this it just serves the entire
enterprise but over time what happens to
this application it turns into one of
these and usually one of these like the
store procedures that are 10,000 lines
long you have the the store procedures
that have like ten levels of nested
triggers they're like no one knows what
the hell's going on so no one touch it
these applications over time tend to
grow with functionality behavior that
they can no longer serve the purpose of
everyone trying to use it so what do we
do we got to split it up right so let's
spit it up between the front end and the
back end so now we have a front-end
application picked with whatever front
whatever spa technology it was was the
choice of that year well there was
backbone five years ago or what's today
view Jas is that what we're doing today
I don't even know anymore I don't try to
keep up but again what happens over time
is I have these single applications
these single layers trying to solve
everyone's problem and again over time
we run into this now three big balls of
I think that's chocolate ice cream right
so okay now we need to split something
some things up some more and so what I
see most people do when they're building
micro-service base architectures as they
start to split things up into these
individual verdict
applications where each vertical
application is taking care of every
single behavior from the front end to
the back end almost but not quite
instead what I usually see is something
like this where I have a single
monolithic front end talking to a single
monolithic usually API gateway which I
see is like the new BizTalk or it's
basically a news bit stock but now it's
rest instead of whatever it was before
and then that that API layer where it's
using graph QL or rest whatever that's
the thing that's actually talking to the
back-end services there's a problem here
right I've now replaced and made thinner
those other pieces but I still had these
really big applications that span every
single service so while the backend
services may have independent isolated
features and autonomy to autonomy
between each piece I still have those
big balls of mud all the way at the last
mile in the front-end user interface so
this is where I like to roll things back
and say how do people solve this problem
when faced with it before computers ever
existed how do people do this 50 years
ago 100 years ago when they still had
all these different isolated pieces so
looking back then I could see that we
would try to have some sort of ideal
world in this ideal world I would have
very independent isolated groups of
people within my company that pretty
much worked on their own and over time I
would build systems and applications for
those independent groups of people
inside the company so any company I go
to basically works like this where they
have a lot of different applications but
those different applications are really
focused within one group or organization
inside the company so I may have a sales
organization that has an NBC application
and a sequel database I may have that
orders application that is going to be
react and MongoDB I may have the
shipping application but that needs to
be used by people actually in the
warehouse so that's going to be a
Windows desktop application talking to
sequel and finally ERP because its ERP
is an a s400 mainframe and it's user
interface I think is also the as/400
mainframe usually with varying levels of
green and black as a user interface and
the people
using each of these applications only
ever use those one application they
don't really go from application
application
and anytime I need to perform some kind
of business activity between those
different applications we have what's
known as swivel-chair integration that
is the actual business process is on is
on a piece of paper or notepad that
travels from person to person or what I
usually see today the comments field out
of some kind of record you have it those
comments field the words like some text
there and then like someone has
someone's initials and a date and like
more comments and initials than a date
and that's where the actual business
process is that's because those
applications only deal with those one
single group inside the company but we
don't have anything that spans across
all those different applications so for
these back and kind of see back in kind
of services and application autonomy I
find is pretty easy because those
service boundaries that are defining
each of those pieces typically follow
it's known as Conway's law this is not
Conway Twitty the country singer with a
really weird get-ups this is no Conway
and way in the 60s he defined this what
he called the Conway's law which is any
organization that designs a system will
produce a design whose structure is a
copy of the organization's communication
structure or what I tend to think of it
as the application a company builds more
or less matches the organization
structure of that company for the
companies that don't do these big single
monoliths that tend to have applications
that just follow the company
organization boundaries and because
company's organizational structures
never change those applications always
work right no one has a reorg every two
years right that's the enterprise thing
to do is time to do a reorg we have a
new CIO the how else is it gonna make
his mark other than breaking things up
and rearranging the chairs so for a long
time we can get away with this that we
can have all these independent isolated
applications with these organizational
structures that may not change too much
over time and for a long time this can
work when I'm looking at the arrows
between each of these pieces the
communication styles and and constraints
add
not really changed over the years so I'm
looking at two different organizations
needing to talk to each other 100 years
ago
they may use the same kind of
integration methods as they do today
it's just a lot faster than it used to
be so latency has shrunk between all
those different disparate applications
but it's still not zero and as long as
we don't make silly or stupid choices
where we ignore the fallacies of
distributed computing then everything
should just hopefully work as long as we
don't pretend like the speed of light is
zero
or there's not actually any distance in
the earth between like Hong Kong in the
US we should be able to make good
choices about how we build these
distributed systems okay I know you what
you're thinking right we're about ten
minutes in and we have yet to talk about
any sort of composit UI's now the comp
is you don't affect those back-end
systems because none of those actually
face the customer so again this was
where I take a step back and say okay
compensate you eyes can't be a new
problem it's like something that was
just invented by the micro service
people how did we have solved this kind
of problem a hundred years ago so
looking at a normal company that had
some kind of customer interaction a
hundred years ago the good at the best
example I could think of was a
department store this department store
is Selfridges which i think is still a
thing right it hasn't been bought out
multiple times yet and called like pairs
or something like that so this is
Selfridges around I don't know the 20s
or 30s or something and inside of there
they had a composite user of interface
when you walked into the department
store it looks something like this much
much fancier than it is now but they
still have the people that spray the
fragrance in your face even though you
don't want it that's still a thing this
is the complete aggregation and
composition of all those back-end
services to provide a singular user
experience whose sole goal was to get
you to buy stuff behind the scenes there
are tons of different groups and
organizational structures to build this
composite user experience there is the
shipping department that is making sure
that the goods are getting actually into
the to the actual store they're actually
the people that design these front-end
experiences so they're the people that
figure out which products need to be to
be put where
which department should we organize how
should we organize the different for
someone's figuring all that out there's
of course sales and orders and
accounting all these are things behind
the scenes that are not directly exposed
to the end-user when you walk in here
you don't know how shipping occurs you
don't know how orders come in you just
come in and see here's all these
products for me to buy here's my credit
card or whatever and then you walk out
with with walk out with your product so
if I look how people solve these
problems 100 years ago what I typically
find is that the fundamental
compositional challenges remain the same
it's just things have gotten a lot
faster we have computers and we have
those kinds of systems but fundamentally
the same division of systems and
division of responsibilities that exists
at 100 years ago still exists today so
this is why I think of those
compositional UIs as the last mile
problem and actually looked it up like
it's still actually called the last mile
problem no matter what the country it's
not called the last kilometer problem
although I think if brexit go through
right you're going to go back to the old
units right make the unit's great again
isn't that gonna happen so this last
mile problem we're taking all those
services and delivering it to the final
end-user this can be the hardest problem
to solve but the last mile is actually
the most important parts because if we
didn't deliver that final service to the
end-user there would be no business to
conduct so what's the point and we don't
solve that last mile problem we'll never
have the actual revenue and income to
build anything in the first place so we
have to solve this problem well if we
expect to be able to conduct business in
the future
so what might this look like typically
we have all of our back-end services
that are doing all their independent
things and then on top of it we have to
put some kind of end user user interface
the thing that's going to be shown to
them that hopefully hides all the
complexity and madness of all the
services behind the scenes so from here
on out I want to switch gears and see
what are the different options we have
to be able to take all these back-end
pieces
and lift those pieces up into the user
interface to have something coherent and
cohesive that actually entices them to
buy something now I would say like the
very first option we should consider is
to not compose anything so what would
that actually look like to the end-user
and you've probably ran into this in
businesses you've worked with in
e-commerce businesses what this might
look like are completely independent
applications and in fact you've probably
gone to a dot-com website and you meet
you may have noticed that the URL the
domain actually changed as you went
through the website you started with
just the regular store com website when
you went to the pieces that wanted to
sell you something you notice the they
may have noticed the URL changed to
store or sales test or calm when you
want it to actually place an order again
the URL change to orders that store calm
we want to see how to ship something
shipping and finally well probably not
ERP because no one knows how to hook up
an as400 of the Internet right that's
not possible yet hopefully each of these
different applications has their own
independent isolated database so we do
maintain autonomy we're not doing cross
chitchat between these services
hopefully but probably so to be honest
and then the thing we may share between
all these different front-end
applications that are directly exposed
to the end-user is maybe just content
things like common templates
maybe CSS maybe fonts maybe images these
would all be served up through this
common content delivery network now this
gets us quite a bit of the way there we
can share a lot of those assets to make
things kind of look the same but what I
typically find is that each of those
groups wants to be completely
independent about how they design the
experience of those applications and
when that when that's exposed directly
to the end-user we know it we see these
like janky websites like well the colors
are the same but man when I went to this
part the menu was up top when I went to
this part the menu is on the side like
shouldn't those people be talking to
each other about some coherent user
interface and that's what I find it's
it's it can be pretty difficult to fake
a composite you I want to have all these
disparate applications the user
experience usually suffers
and even before computers you probably
saw this I especially see it whenever I
call in to a customer service hotline
because something went wrong with an
order and usually those customer service
hotlines you are directly exposed to the
insanity of how their back-end systems
work like you'll be transferred from
department to part of a department yes
my fight is incorrect I need to book a
new flight okay let me transfer you over
to claims department ok claims I don't
care about your departments I just want
my flight fix oh did you did you buy
this via miles and points well I got to
go to the remediation department ok so
you get transferred again and transfer
no transfers you are directly exposed to
whatever kind of back-end systems and
departments this company has and it's
not a good experience for you this is
where you usually go on Yelp to complain
about things right to say oh god their
customer service was horrible I really
liked the cheap airline fare but man
with anything goes wrong it just goes
totally off the rails and you can't get
anything fixed by calling the customer
service hotline so if you don't want
that kind of experience where people are
leaving you bad reviews on Yelp then
you're going to try to build this one
coherent user interface that is able to
aggregate all these back-end services to
provide a single nice user experience
for the end user
so once you've swallowed the red pill or
blue pill maybe just swallow both pills
and just take your chances you figure
out that you actually do want to build
one of these composite apps and now it
comes a challenge where are you gonna
actually compose how are you going to
pull these pieces together and how are
you going to actually deliver it in a
meaningful format to the end user so we
have to decide based on our application
where are we going to compose now
unfortunately I have to say that it
depends and I'm actually legally
required to say this as a consultant it
depends because that's what gets me more
contracts and stuff so I choose
something I have to do this my my
consultants motto but we have to drive
our decisions about how to pull things
together based on the application and
user experience we're trying to deliver
for the end user
so let's first assume that I'm building
a web application because I already got
to say that it also depends on what kind
of application you're building if you're
building a thick client desktop
application first
I'm sorry for you that that's still a
horrible experience it's gonna depend
highly on those tools and technologies
what's available for you so let's just
assume we're building a web application
and see what are the different places
that we could have some kind of
compositional behavior now ignoring any
kind of technology stack whatsoever I
could say that all web applications
basically look like this I've got the
initial dot-com like domain entry to the
whole system and then once I'm inside of
there there is the browser that's going
to render HTML to the end user so that's
a place that I can control as a
developer to pull things together next
part is the server the browser has to
call back into something to show and
display HTML and JavaScript and all
sorts of widgets so that's another place
I can look at to compose in the server
and finally I can compose at the
database level to say maybe this data
needs to be composed and aggregated
before it's shown to the end-user so I
want to look at each of the each of
these three areas to look at what are
the possibilities for us to compose in
each of those areas and figure out based
on the problem space which of these
right areas is correct for us to compose
and again what what I'm really trying to
shoot for is I've decided to go micro
services and the whole point of
microservices is I could have
independent isolated autonomous
applications or services so that I can
build and run different services upgrade
them independently and not worry about
breaking anything else so we want to
make sure that as I'm looking at the
compositional areas here that I'm not
reintroducing coupling and making things
again a big ball of poo or mud or
chocolate ice-cream whatever you want to
have it I don't want to re reintroduce
that coupling and have another problem
in the future
so let's look first at the browser how
can we compose in the browser well we
have to start with the user experience
so let's go look at one of the most
famous composite UI is that you'll
probably use on a daily if not maybe a
weekly basis which is of course
amazon.com and I just happen to look at
one of the pages of a history don't pay
any attention to the actual thing I'm
looking at her but
when I'm looking at this I have to
decide how am I going to build this
application how am I going to put
everything together now us as developers
we have to have meetings to decide these
sort of things so the first thing we
need to decide is what is the front in
UI technology we're going to use to pull
these pieces together and so this is of
course time we need to choose our
framework one of the most exciting
discussions we have as developers right
like what is the most up-to-date thing
what is the best thing that's gonna look
on my CV to make sure that if this all
goes up all goes bad that I can at least
get a job using the thing I'm using to
break everything so we could look at
angular angular has a concept of modules
and components so that may be something
that we can use to have these
independent pieces react has components
those are those individual component
types pieces for the screen aralia
which someone told me once it's still a
thing has a concept of components or you
can just pick your favorite non je s
components that has some concept of
building independent isolated pieces to
be able to display it on the screen but
there's a problem here when we decide to
pick a single front-end UI technology
that everyone is going to need to use
that's actually going to introduce
coupling and frameworks are coupling
we're forcing everyone to use a singular
technology that we know is going to
change in six months right like six
months from now there's gonna be a new
awesome JavaScript framework that
everyone should switch to but we just
picked this one and it's now when now
we're stuck right even if we picked
angular when we went from one to two to
three nope not three to four was there
five they just got rid of version
numbers like we're not even gonna
version anymore you're just gonna break
you all the time this is not something
we want to force on all the people
building these components we want to say
like oh man we really want to move to
angular
are they going to colors now maybe
angular plaid version that has them like
now they support some new html5 stuff
that we want to be able to take
advantage of or maybe they support the
newest version of es6 which i think has
also moved to color so there's like yes
red now or something I don't even know
we want to take advantage of those
awesome features but
by forcing us to go on a certain
framework if we want to upgrade that's
gonna force everyone and our system to
have to upgrade their individual
frameworks there's not some there's not
really great ways for us to isolate
those different pieces from each other
I've seen people try to say like well
you know if rating you like one page
we'll have to decide to use a specific
version of a framework and for a
different page you'll have a different
version of a different frame and perhaps
so inside those pages maybe we can agree
but what I typically see is that no one
agrees on anything when it comes to
JavaScript frameworks so let's see if we
can just get away with not picking a
JavaScript framework oh I know so what
does that mean like raw as they were
like written raw JavaScript in the last
five years I actually I have it it's not
too bad anymore I am when I was writing
a web application the first thing I did
was bring in jQuery because Dom was
horrible well it turns out like with all
the work being done with html5 and all
the new web standards that have come out
that the experience of working just raw
HTML and Dom isn't too bad so I'd go
look at it see is there some way to buy
packaged together components in one
single widget that it can then easily
distribute and and push out to the front
end well it turns out there is something
new very recent to be able to do this
and it's known as web components
now web components are a very new thing
in html5
I think the spec is finalized ish if
anything has ever finalized in html5
specs and if you go look at the browser
support for web components it's
basically like Chrome and that's about
it but there are some ways for us to
build web components and have them
delivered through polyfills so we'll
look at some tools to be able to do so
as well
now what web components do is package up
all the different pieces that you could
have in a snippet of HTML which would
include not just the HTML itself but it
also include any sort of styling for
that individual piece so again be
careful about styling because styling is
global so you want to pick styling that
may not have a global dependency
maybe maybe it's okay just to have style
directly in HTML but that's the safest
thing to do in case someone upgrades
bootstrap and breaks everything that's
not something we want to depend on so
CSS may be highly localized to this one
individual components if it's a if it's
a data-driven component that HTML may
include a template and with templates we
could just use the JavaScript string
stuff that came along and what is it
called the new string stuff literals yes
thank you
interpolated strings so yeah we could
use those as a means to provide some
kind of tip lending ability for for
pushing out data-driven components and
finally we define an element that says
all these things together can be
represented in your actual final HTML as
my custom HTML element so this one for
example is a custom toggle button that
behind-the-scenes has all of the HTML
behaviors and JavaScript and CSS
associated with it but it's delivered to
the end browser as this one single HTML
element so we could look on our page and
say okay right now that we've got a
means to package together these
individual pieces we can break out these
screens into the individual components
I'd see so there could be a cart
components it would just be like a cart
HTML tag on the page there could be a
catalog component for however crazy that
thing needs to be the account component
at the top that tells me I'm logged in
or not and the shipping component to
tell me how expensive or not the
shipping price would be for individual
product backing all these individual web
components would be some sort of backing
services so the cart component could
talk to its own API the cart API we'd
likely have a front-end back-end team
delivering those two pieces so the same
team that's responsible for delivering
the API would be the same team
responsible for delivering that final in
widget that we see in the screen and we
break up and tie all these different
components to the correct back-end
services using them that when we finally
get to the front-end interface we start
breaking up all these different pieces
into their individual HTML elements so I
have the promo HTML the account HTML the
images HTML the different formats that's
comes in and stock and cart over there
on the right
the last piece for these HTML components
is to actually deliver them to the
front-end rendering pipeline so that it
actually can go out the door and this is
again one of those pieces that like no
one's really like really documented well
and everyone has their own kind of way
of doing things but the best way I've
seen it is to leverage existing
packaging and delivery techniques things
like using NPM so we could use each
individual service team building an NPM
module with it contains that's the
cain't contains that web components and
then finally when it comes down to
rendering that to the end-user
since web components aren't actually
supported in all the browsers we can use
a really great tool known as polymer the
pulp from the polymer project that's
able to render those web components and
polyfill them for legacy browsers or
just not even legacy browser just like
all all the browsers that don't exactly
support this so the front end rendering
for store.com
they would just have those individual
web components on the page and the
backend service providers would be
responsible for defining what those
individual widgets look like the code
associated with them and now the
front-end is just like a basically a
template with all these little
placeholders that are going to be
delivered by these back-end web
components again those web component
going to be talking to those individual
api's directly that have those complete
autonomous services behind the scenes
this is still like a thing that no one's
I've seen people like talk about it a
little bit but I still don't see like a
solid great example of someone using
this in the wild this again is just what
I've hear people kind of kind of kind of
talk about but no one seems to actually
have put all the pieces together here
for the most part what I've seen is
people building composit UI building
capacity wise because web components are
still very new that they tend to try to
go for server-side rendering so Amazon
for example like there's basically no
JavaScript on that page maybe we just
like hover things that show reviews but
for the most part they've kind of given
up on browsers because it's like slow
and stuff I guess and done back in
rendering
Netflix does do some client-side
rendering so they've got like a
proprietary version of something like
this because again they can't rely on
everyone having up-to-date browsers
because that would just be lost money to
them so hopefully as web standards
improve and as adoption increases that
we can use techniques driven by things
like the polymer project to use these
web components to really define these
highly componentized pieces they can be
still 100% independent from each other
now I will say like you got to make sure
that you draw these boundaries well if
you find yourself having components that
talk to each other and have dependencies
between their individual pieces this is
reintroducing coupling that we don't
want to have so be really careful about
when whether it's whether you just say
we're gonna go angular and and do
angular 4 components or react or
whatever be really really careful with
explicit dependencies or implicit
dependencies between those individual
components on the page because and then
that's just something they can break in
the future all right so maybe maybe the
browser site composition wasn't right
for us so let's go look to see what we
could you do on the server side so as
like as unfortunately messy as the front
inside was the server side is actually a
little bit Messier and the reason why is
that it's highly dependent on what your
service side stack is so while the
front-end we could say don't pick
angular because you should never pick
angular I'm here you go with just react
whatever unfortunately we can't do that
on the server side there's like no
there's no standard just completely
agnostic server-side framework even if
we use like middleware between different
components we really have to worry about
we're on the page we're going to put
these pieces together and that's highly
dependent on the server side stack we
have and even if we pick a single
server-side stack from there we have
different areas in that server-side
stack that we could actually compose
most applications today I see are built
using model view controller
NBC or should it really be like CMV or
MCV I know they got the seem label
letters on order here but we have some
kind of MVC framework typically in
charge of actually rendering
that mod that's HTML to the end-user so
even we pick server we actually got
three more choices for how to compose
applications and by the way this if this
is making your head hurt this is this is
why people generally don't try to do
this because again it's a hard problem
that not a lot of people talking about
but it is definitely a solvable problem
so if we look first here at the model
why would we want to compose at the
model side well if I go look at the end
user experience which I should I want to
see what are the reasons why I might
need to compose different pieces
together into a single model before I
give it on to the individual view here's
a good example of that in this case what
I have is a search result from the
Amazon Amazon comm website so I when
searched just a very popular singer
popstar and this is one of the first
results that popped up but on this
individual on this individual result
here I have a lot of different pieces of
data coming from a lot of different
sources but it's needs to be rendered as
a single cohesive element so I can't I
can't really use the same kind of
compositional techniques I use in the
browser side because all the data really
comes from really one needs to come from
one cohesive source so that when it
comes to render this HTML I'm not having
to call these different services when
trying to put these pieces together so
ideally by the time it comes to render
the HTML I've already got all the data I
need and now I'm just concerned with how
to format it together to a single and
user experience so if I looked at the
data on the screen I would need to
figure out where all the different data
comes from to figure out how should I
pull these pieces together to be able to
show to the end user interface so in
this one single the cohesive model which
would be like the Product Search Results
the data inside that model would come
from a variety sources it could come
from the product catalog
that would contain maybe some product
information I would need to include the
price information to say this is how
much going to cost you to have to listen
to Bieber all the time
it would include ratings for that
product which certainly haven't
Duff by the record industry whatsoever
I'm sure those are all actually real
ratings and finally recommendations
about if you look to this product maybe
would like one of these other products
these are highly disparate data sources
behind the scenes that need to come
together to this one single model so
that when it goes out the door filing to
be rendered at the view that I don't
have to worry about where exactly all
this data came from I've got this single
one model to work with now for this part
actually did talk with an Amazon
engineer to figure out how they put
these pieces together and it turns out
it was pretty ingenious about how they
did it unfortunately no web framework
has this kind of composition built in or
I have a single blast version of the
model I need to go to a bunch of
back-end services to pull the pieces
together so you can you could handle you
can you can hard code it right I could
say in the product search controller I'm
going to explicitly call all these
different services and poke in the data
all into my model and finally show it to
the end-user but that's hard coding a
lot of information if anything changes
whether it's where the service changes
or how we need to call the service or
where that service is located I have to
go change that controller action so
ideally if any one of these services
changes then that service team could
deliver the new way of doing things
without affecting anyone else so the way
the way I've seen big dot-com e-commerce
websites do it is they they they do kind
of a pipes and filters architecture that
I first start with just basic raw
request information and then I ask all
the different services that may match
this request information hey if you got
any kind of model data that we want to
show on the screen now is your chance
and they're able to handle things like
what if one of these services blows up
then I just don't want to show that
piece of information on the screen so
like I said no MVC framework has
something like this built in so this is
we have to put on our architect hat and
figure out what abstractions do we need
so one of the things we need is some
ability to based on a specific route
information the ability to say hey I can
do something with this one so we might
have a very simple interface like this
this actually came from the one of the
courses I do here at so if anyone was in
my class last couple days this actually
came from it but it's a very simple
interface that just says based on the
request context which includes route
data user information really everything
do you match and if so return true so I
could be looking at the query string I
could be looking at the path I could be
looking at cookie data whatever it might
be that could enhance the data that I
finally render I would say ooh that's
for me I'll go ahead and render then
well the next piece after matching is to
actually fill fill stuff in and I got a
more knee this is the somewhat ugly part
that'll tell you why here in a second we
want to have ability to append data to a
view model so we'll have in this case a
view model appender the view model
appender is also a route interceptor so
it can't say I'm matching something and
then as part of matching something
next we'll say okay you've matched well
go ahead and start appending data to the
view model so I'm able to get that
additional the original request context
into get request data if I need to and
finally I have something that most
c-sharp developers hate which is the
view model as a dynamic right well when
I talk to a lot of people that are doing
doing copies at UIs
they're almost always like hipsters
using node and rails and those languages
are dynamic that's just they're
inherently dynamic so it's nothing from
them to say yeah I can just append some
more data to this object because you
know we're we're hipster developers we
can just do whatever we want so what I
don't want to have happen is to
reintroduce coupling by some statically
typed view model thing that everyone has
to know about because they would have to
know about it at compile time when
they're building their component and
again that's just more coupling that I'm
introducing so I'll use those c-sharp
features that usually try to avoid here
in the dynamic view model which behind
the scenes is just a fancy dictionary
that's all it is just a fancy dictionary
that I can put properly I can stuff data
into and it makes it look a little nice
where I'm going but if you don't like
that they can just use a dictionary
instead this just gives us like a
pretend
the facade over a dictionary that looks
something like actual programming but
it's really just a dictionary so all
those search results I have to implement
my view model my I'm sorry my route
interceptors so those route interceptors
need to look at request data to figure
out hey is this something I need to
attach to now for normal MVC
applications how do we know how route
information is going to attach to some
specific executing code well that's the
route information the route data that
MVC just kind of hard codes to say well
you're going to go to this controller or
this action so you're going to execute
this class and this method but we're
throwing that away now we don't have a
controller in action anymore we just had
this kind of loose view model appenders
so we don't we don't have that ability
to just use MVC routing anymore to
figure out which needs to execute so the
code is going to look a little ugly
about explicitly pulling out controller
information and action information so in
this case what I'm looking for is make
sure that it's a get method not a post
look for the controller value in the
route data and make sure it's matches
orders and then finally make sure the
route data value includes an ID that I'm
looking for a specific specific order
information now once I've matched a
specific request then my view model
appender kicks in to say now you have
the ability to do whatever you want to
do I don't even care do whatever you
want to do to be able to fill in that
information for that individual view
model this piece right here should be
delivered by the service delivery team
not the front-end team because they
don't want to be tied to every single
whim of every single service this is the
service delivery team saying hey when I
need to fill in data for example this is
order details I am going to in this case
what are we doing we're calling a we're
calling an API a REST API to be able to
pull in information and finally all for
the information we get from that other
API I'm attaching the order number and
order items counts onto our view model
now I know I as the author of auto
mapper I didn't actually show it here
but so I won't like bore you with those
details you could use
tools but again be careful that's also
more coupling I try to keep these as
explicit and obvious as possible so
we're just gonna be very explicit about
those pieces were setting the next
appender would be able to attach their
own data so in this case I have the
shipping service that's going to call
some shipping API and pull in the
shipping information in this case it's
pulling in the shipping status for your
order as well as they courier associated
with it now if you don't want to use
rest you can do really whatever you want
here if you want to use G RPC because
it's a lot lower latency and and faster
overall you could certainly do that as
well
but your choice to do so is now
encapsulated inside of this appender
completely separated from everyone else
if you want to call directly to a
database you can do that it doesn't
affect anyone else in the pipeline of
rendering out this view model now I know
they're there there are some people in
the audience that are looking at and
saying well gosh you're using a dynamic
so you don't have that strongly typed
model anymore so that kind of you lose
some cool points there and the next
piece you have is well how do I make
sure that two people don't write the
same value to the same dynamic object
but it's this thing called slack we can
actually just ask each other hey are we
both setting the same value and usually
it's pretty obvious sometimes people do
like name spacing to say this is the
shipping status courier and the previous
one was the orders number item Cal so as
long as you're not a jerk then
everything should go okay but you know
we're developers so there's there are
some jerks out there I know I know this
whenever I leave my computer unlocked
some jerk comes by and does something
weird so finally when it comes time to
render the HTML someone has to be
responsible for this and so I typically
see this as kind of a separate team
doing this there is the front-end team
that's responsible for that nice pretty
user interface I don't want orders and
shipping teams to be arguing about which
needs to go where someone needs to be
responsible for the final render and so
this would just be one single block of
rendering HTML where you get that final
composed view model push glom everything
together give it to the in this case
this is using razor templates and render
that one single cohesive block of HTML
to the end user when one of those
appenders needs to change
then we just deploy a new version that
appender the existing you my application
one change whatsoever and now it will
get the updated version of pulling in
that data from the outside world or a
different service that is so we had to
make up that abstraction unfortunately
there really wasn't a way around it
because model composition isn't really a
thing and MVC frameworks it's really
just on your own to just make up your
own abstraction but that's what we like
to do anyway right we like to make up
our own abstractions so it's actually an
opportunity to do something that you
don't normally get to do or probably
shouldn't normally do make up our own
abstraction for view model composition
now I'm gonna strip I'm gonna just
completely skip controller composition
that doesn't really do anything like the
controller for me is just a means of
describing and overall routes but
otherwise there's nothing else going on
so we're there's there's really nothing
to show on the controller side for
composition that's not really a thing so
what we'll do is go ahead and skip to
view composition how do we compose
different pieces on a screen with a view
well you've probably been doing this for
a long time you've been using master
pages and asp.net or view templates in
asp.net MVC and now MVC core so for us
we actually already have ways of
providing a template on the screen and
having individual pieces fill in now
that works for like easy scenarios but
what if we have scenarios where the data
for each of those different places in
the screen needs to come from different
places so over here on my my original
screen here I've got a really complex
user interface where I have different
pieces of the screen coming from
different places I could use view model
composition but that view model would be
so wonky with all these different data
that had nothing to do with each other
so if I wanted to keep those pieces
separate and say you know what let's
keep like the top widget separate from
the side widget separate from the main
widget in the middle separate from those
side widgets I don't want to glom all
this together into a single model that
all comes all at once instead I can
treat I can I can reach for one of the
other lesser used extensions with
asp.net MVC core now this extension did
exist
old asp.net MVC as what was known as
child actions a lot of other MVC
frameworks don't have this as they view
them as like they've even typically bad
because they don't perform well but an
MVC core these these these individual
rendering pipelines actually perform
really well in an MVC core they're known
as view components something that not a
lot of people use so again this view
component is a replacement for child
actions of MVC old which had a horrible
name and didn't actually perform that
well and they encapsulate a single mini
request for a section on the screen that
includes the invocation of some code the
building of some model and then filing
the rendering of HTML so I think it was
like a very mini NB C pipeline just for
a single section on the page these view
components can have their own parameters
to pass in like here's the order ID that
you need it to actually render and their
own business logic to do really whatever
they want to be able to Rend that
information on the screen and the way
these get invoked is usually from a view
inside of your layout so what does this
look like if I was looking at the stock
information widget that shows me if this
thing is in stock or not this is highly
specialized to that one answer that I
need for the question of is this piece
since is this product SKU in stock or
not I can encapsulate the ability to
answer that question inside of my view
component I was waiting for someone to
take take a picture just to change the
slide right then it was pretty awesome
anyway so this is the code for a view
component notice that it has its own
dependencies I can depend directly on an
entity framework DB context or you can
depend directly on a dapper Dapper do
whatever thing is in dapper is or pet a
poco database really whatever this thing
needs to do to get the data it needs for
rendering it's 100% encapsulated inside
of my view component the vid component
has a single method invoke a sync
because it's async like everything that
means we have to put a sync on all of
our methods so invoke async and this is
going to pull into the database look at
the stock for a single SKU see if it's
in stock and finally show return a view
result that is going to our view
component
excuse me for the items that it's pulled
out now so this looks very much like a
controller controller in action that's
very deliberate the only thing that's
different is instead of me inheriting
from a controller base class there's a
special view component base class that
only has the things on it that you
should care about if you're just
rendering this tiny little widget on a
page and nothing else so trying to keep
those two things very very separate so
inside this Mini NBC pipeline we return
a view with a view model and so that
means we need to actually render that
HTML on the screen and so that's what we
have here a tiny little snippet of HTML
that's going to render in this case a
list of stock items that has the HTML
necessary to be able to render that
stock information out on the screen now
again we have to worry about CSS because
CSS is global so we have to worry about
the styling of this thing so we might
have those endless discussions about
which version of bootstrap you want I
mean that bootstrap may be just like one
of those layout CSS and we just do our
own thing that's really up to you just
keep in mind that the coupling side of
things but inside of here it's just up
to us exactly what we want to render
here finally when we need to invoke this
view components that's done from the
parent view and it looks something like
this where I say invoke component invoke
a sync with the name of the component we
want to invoke and then finally the data
we want to pass through so that the view
component can get that information and
be able to render something on the
screen so I'm looking for the stock for
a specific SKU so that's what we pass in
the SKU from the parent here or there's
a new way of doing it that looks
something like this and this starts to
look very similar to web components
right web components encapsulated the
rendering HTML calling of any kind of
back-end service to be able to render on
the screen this is the server-side
equivalent of that exact pattern we saw
on the client side now there is one last
piece we need to do here which is
actually package this thing up to
deliver to the front end team to be able
to show it on the screen unfortunately
there's not a great way of doing this
you can use nougat packages or if your
fancy new J packages to be able to
package all these pieces together
to be able to ship to the front-end team
there's not a great way in asp net MVC
core or most MVC architectures and
frameworks i've dealt with to be able to
just kind of pull in other kinds of
rendering pieces and other kinds of
extension points and be able to just use
them immediately so you'll have to do a
bit of playing around to get with the
way that would work best for your team
but the general idea is that whatever my
delivery method i want to be able to do
as independent as possible from the
front-end team we don't want to
introduce yet another bottleneck or set
of coupling just because we decided to
build these composite you eyes okay so
we've looked at the browser way of
composing applications through web
components we've looked at the server
side of composing applications through
model side composition or view side
composition the last piece is to look at
database level composition this is
probably going to be the scariest part
of the talk because this is usually
where things can go really really wrong
for your enterprise trying to compose
things at the database level because
that can be introducing another
monolithic part of your application so
when i'm talking about database level
composition I don't mean making the
entire system use one single database
when I'm talking about this for a single
purpose or a single function or single
part of the page that the only possible
way we could serve that function is to
pre aggregate or compose data into a
database so what part of the application
that we typically run into would need to
have things pre aggregated or pre
composed in order to provide a coherent
user experience for the systems I run
into that's going to be the search page
the search page pulls in data from a lot
of different places in order to perform
a coherent search typically using a
bubble diagram I think's the elastic
search yeah elastic search to be able to
provide a search database that is super
good at what it does searching and be
able to show that information on the
screen
now the reason why we need to pre
aggregate or pre compose is none of the
services that provide this data are
particularly good at searching like
catalogs aren't good at searching
they're good at organizing but not
searching unless you like sequel
full-text search right or just select
star from products where name like
percent value percents that performs
well right always know we put that
information inside a tailor-made search
database so that this thing could do its
job well which is doing searches and
providing relevant information to the
end user but there's not there's a
problem and that's the data that exists
in that search database doesn't actually
belong to the search service so this is
an example of a document pulled out of
an elastic search database now I
actually just made it all up but you can
imagine that came out of an elastic
search database and it's a document or
in a database so it's going to be JSON
looking stuff and everything that's
going to search is going to be inside of
that document where you can have the
ability to also add search indexes for
certain kinds of search we can provide
relevancy and ordering to say you know
these these products were always
purchased so bubble them up to the top
and these products were never clicked so
maybe bubble them further down at the
bottom we could prefer certain kinds of
fields over the others that's really
what these search databases are about
again the problem is though like in the
other set of data it doesn't own any of
this information on the screen so like
this stuff at the top the ID the name of
the artist that's actually from the
catalog service this image URL that's
from the image service the content
delivery network maybe pricing
information and the format's that
available in is from the format service
and finally the review data is from the
review service so all this information
that has to be a in the search database
actually belongs to our the services and
so this brings up the data duplication
monster
we now have duplicate data from our
services duplicate it up to the front
and up to the search database and again
this is where usually DBA is like oh my
god duplicate data this is what we want
to avoid because now I've got customer
date to details and three databases and
that's been okay yeah it's usually bad
usually the services I build I try
that data leaked out of my application
and to others I think I heard the quote
this morning is that data is the
pollution of the 21st century because
it's easy to create data it's hard to
delete it and so once my data gets out
into the wild it's very hard to like
oops actually that's been updated you
need to change it on your side Oh No so
we have to be very very careful about
this and put it in then both support
appropriate chain appropriate places now
because we're basically required to do
this to duplicate some data into the
search database we have to figure out a
good way of doing it and in fact one of
the one of the engineers they used to
work in Microsoft and now works at
Salesforce Pat Helen had a great paper
and presentation talking about this very
problem and his paper was a immutability
changes everything and the basic idea is
that because because data still needs to
have a specific owner it should be okay
for me to share that data as long as all
that come all the all the different
services services that take that data
treated as immutable and read-only and
don't ever change it so as long as my
service doesn't like decide oh that
Bieber CDs should be a hundred dollars
not ten dollars haha we should be okay
just honor the immutability there's
other pieces so looking at the ownership
here search owns the shape of the data
it owns the SLA of the response to make
sure it's correct and comes back quickly
it owns a relevance to make sure looking
at which comes first but it doesn't own
actually of the actually any of the data
behind the scenes so what we need to do
is take all of these services data in
whatever way we can get it feed into
some kind of normal D normalization
process and stuff it into our search
database so that by the time the dot-com
website hits that search database all
the data it needs to be able to search
is already in there now this is where
you can run so prom enterprise because
you have to get that data from all those
services into your search database and
the enterprise architects may not want
you to so in the immortal words of dr.
Ian Malcolm Malcolm life finds a way or
as I think of it developers find a
so I have to go to each of those back in
services and figure out how can I get
that data out and you have to be
creative so I looked first at the
catalog service the catalog service I
know is a known quantity that comes
existing as a once a day updates so what
I'll do is I'll just have some service
that calls the API and pulls that
information into my search database in
one gigantic gnarly for loop just like
loop over all the products call the
catalog service and feed it into my
search database the images service I go
look at the return call from the catalog
and if I wait a minute the image is the
image URL is actually already served
from the catalog for whatever reason so
instead of me trying to call the image
service I'm just go ahead and sever that
connection all together just like sorry
image service you had your chance and
I'm not going to call you the formats
now this the format's whether it's a CD
or audio but I guess basically CD or LP
I guess this is something that actually
rarely changes once it's set up once I
never see that change over time the
other thing we found is that this
information could be serving many
internal clients so we could just look
at how those other existing clients are
already doing integration and so we'll
do something like consuming a shared
drive of a CSV file once a day I just
like happen to talk to the developer and
say oh you're actually already pushing
out the list of formats on a CSV file
once a day well we're just going to call
that and call it a day finally the
reviews this one's a more difficult part
because that is data that actually
changes frequently and you as a consumer
would probably be a little freaked out
if you added a review and like it didn't
show up immediately in the screen so
this is something I need to react to as
it happens so when it happens I need to
make sure I get that information
somewhat quickly update my cache inside
my search database and be able to do the
updates so in this case I may have to
get creative where I go take the DBA of
the review service out for lunch or
dinner buy them a few rounds of bourbon
or Scotch whatever they like and say hey
would you would it be cool if you
actually like like maybe put a database
trigger in there and when that database
trigger hits you send us a message and
let us know the data
maybe so yeah we can use something like
messaging to update when that other
service changes so as the database
changes we'll have like a Hokie database
trigger that pushes out a message and
pushes that information into our search
service it all these all these different
mechanisms are basically integration
patterns so we want to choose based on
those individual services what is the
appropriate integration pattern to use
in order to get their information out of
their system and in tarz
so just to wrap up with some key
takeaways first of all don't compose
unless it's necessary you've probably
noticed from this talk that composition
is a hard problem it's been solved by
big companies so maybe you should take a
step back before you decide to go down
this route you need to make sure that
you don't just choose one compositional
model for your entire enterprise you
really want to choose the compositional
strategy based on what's best for the
user experience for that individual
experience don't just pick something
global for everything you really need to
figure out what is the best solution for
any given problem and again it depends
right so we have to make sure we
understand the problem as always the
fallacy is the distributed computing are
called fallacies for a reason don't just
pretend they don't exist and build a
system that's not actually possible to
run in production as opposed on your
local machine and finally something to
keep in mind is that front ends can
become their own individual service
boundary with their own data and their
own autonomous pieces so treat them as
such as well so that was composite UI is
the micro services last mile I'm Jimmy
Bogart I hope you have a great rest of
the conference thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>