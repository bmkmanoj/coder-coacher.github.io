<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Accessing the Google Cloud Platform with C#  - Jon Skeet | Coder Coacher - Coaching Coders</title><meta content="Accessing the Google Cloud Platform with C#  - Jon Skeet - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Accessing the Google Cloud Platform with C#  - Jon Skeet</b></h2><h5 class="post__date">2016-08-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WGNDIXzKnV8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning folks yes that's on very
definitely on okay welcome was the party
good last night
good I went to see Aladdin
which was fantastic I know Scott
Hanselman went to see it as well I
didn't see him there
but hopefully he had a good time as well
before I get into my talk just to notice
I'm sad again I go to conferences and I
get very sad when I look at the gender
diversity or lack of it in conference
halls can I just remind everyone it's
our problem to fix
okay we should not be asking women and
other underrepresented people to fix the
problem themselves and go out and be
women in tech conferences strangely
enough the women in tech won't do the
tech stuff as well right rant over okay
so today is the first time I've
presented this talk and it's the first
time I have talked since taking on a new
project at work and this is basically
the new project this is partly yeah I'm
sure my manager or my product manager at
least um would like me to be showing off
how easy it now is to connect to Google
cloud platform services with c-sharp
that is a small aspect of today's talk
and I hope you do go away and if you
haven't thought of looking at Google
cloud platform which I will call GCP
after this because it's much simpler if
you hadn't looked at GCP before have a
look
try the beta of the code that I'll be
showing today please give us feedback
but that's not really the point okay the
point is I've been writing c-sharp
professionally for a bit there are and
the context in which I'm writing code is
fairly interesting in itself and we've
been having to make various design
decisions which have not been easy it
wouldn't it be lovely if programming
involved think think think
get the right on
sir move on to next problem it's clearly
not that way there are trade-offs all
through we'll be looking at some of
those trade-offs and basically I want
you to think about how the same
trade-offs may be relevant in your
projects think about where you don't
have to think about these decisions
because you're in a simpler situation or
maybe you have to think about the same
decisions but with completely different
inputs and if you've got different
inputs if you've got different
stakeholders then don't expect the same
output so this is in no way meant to be
a guide for how to do things if you go
away and take all of our decision points
and apply them in your own projects that
would be a bad thing if you go away and
think about all the design decisions
we've made and how you might make them
the same way or might make them
differently that's good so a little bit
about me
you probably how many of you use Stack
Overflow yeah right so you probably know
me from that other community things
blogging writing book I'm also a
armchair language designer I'm fortunate
enough to be the convener of the ACMA
standardization committee for for
c-sharp which means I get to hang out
with experts on c-sharp and the c-sharp
language designers which is great fun
but I'm not really a language designer I
can sort of nitpick holes in what other
people have done and now I've been in
Google for eight years and out of that
eight years I've been working in Java
mostly for seven of them but I've still
been going to conferences and speaking
about c-sharp and i've normally had to
say i am not speaking on behalf of
google so please anything I say
that's stupid assume that's just me and
not Google the latter latter bit is
still true so when I say stupid things
because it's bound to happen assume
that's me not Google but I am sort of
speaking on behalf of Google today
because I get to talk about my work for
the
last year I have been on a team within
Google whose basic mission is to make
GCP better for dotnet developers in all
kinds of different ways I happen to be
working mostly in the client library
side of things and my mission my
personal mission slated sort of
informally is if you're a c-sharp
developer looking for a cloud to build
an application on then I want to make
GCP the most obvious natural choice
because that's where you will succeed
best because we provide great c-sharp
support and the services we support that
we provide support for are fantastic as
well from the opposite point of view if
you're a GTP developer you know if you
know that you want to be running on GC p
in one of the various flavors and you're
thinking which language should i use the
code then i want to make it that c-sharp
is the obvious choice because we all
know it's a fabulous language and when
it's properly supported and you know
deployment a doddle and debugging works
end to end and it's all lovely that
should just be the obvious choice for
everyone so all of that can be summed up
as i want to make GTP rock for c-sharp
developers that is my mission now to
take a little bit of a step back and i
will try to use terminology consistently
in this talk when I say API I mean a
cloud service so something that you talk
to such as Google cloud storage or data
store or stack driver logging something
like that so that's the API which can be
accessed from various different
platforms languages etc when I talk
about a class library that's your a
specific usually c-sharp for this talk
code that is running on your machine
that will talk to the service sort of
via the API the only cover that is when
I talk about API reference
documentation that's just class library
documentation but it's so commonly known
as API reference Docs that I'll stick
that way so API is in google out of
interest how many of you have used API
is from Google yeah from c-sharp a few
how's it been it's been okay okay that's
probably about as good as I could have
expected how many of you remember
something called G data or just one a
couple so there have been a few
iterations of API sin in Google there
are probably various iterations that I'm
not aware of but G date is quite a long
time ago
we then had quite a lot of rest api's
beyond G data which all used the same
sort of code generation and were aimed
to be restful and very resource oriented
and the client libraries were is also
oriented but a bit of a pain to use to
be honest relative to where we want to
get to let's say you can definitely be
successful with them but it doesn't feel
like sort of rowing a boat down a river
with a gentle breeze on your face it's
more like sort of paddling a bit bit
hard in a kayak so Google Cloud Storage
is still available as a REST API then
the new hotness is what are called G RPC
api's so they can be accessed via
Google's RPC new RPC protocol which is
not Google specific so the G of G RPC
yes is Google at least as far as I'm
aware it could be general RPC you can
use it it's open source you can set up
your own G RPC server you can talk to it
from entirely non Google code it's
basically an RPC protocol typically over
HTTP - it's one of these things where
the protocol itself
doesn't mandate HTTP - it just so
happens that is the lines really really
well with HTTP - and I don't know any
other transport that's actually used so
you know take from that what you will
likewise you don't have to use protocol
buffers how many of you are familiar
with protocol buffers to some extent
okay I'll talk about them a bit more
later on
they're basically a serialization format
that Google has used for many many years
so you don't have to use Google's
protocol buffers with G RPC but every
example I've ever seen does so now more
api's are being exposed over G RPC and
when they're exposed via G RPC they're
also exposed as restful resources so
that you can access them and typically
from JavaScript you would access them as
restful resources so there's this sort
of duality between do we want to be as
restful as we can but it's still access
fire RPC as well so an example of this
is Google pub/sub which is about what
you'd expect you create a topic and then
you or someone else creates a subscriber
for that topic a subscription and when
something publishes a message to the
topic the subscriber gets to see the
message and all the other subscribers
for the same topic do as well I will be
using pub/sub in some of the examples
just because it's really really easy to
get scripts with there aren't very many
G RPC api's at the moment but more will
be coming on stream and in the spirit of
open source you can see the service
definitions for these G RPC AP is
everything's on github but we have at
least three different organizations on
github so if you go to github comm slash
Google api's slash Google api's then
you'll find a bunch of protobufs in
there and don't worry about remembering
that come and ask me afterwards I'll
show you I would show you now but I
don't think I've got any kind of network
connection worth
worth a damn okay so we do have Co Jen
already for the RESTful API s over HTTP
one-one they work and I'm still
responsible for maintaining both the
code generator for that and the sort of
support library one pattern you'll see
here many times is code Jen with support
library that provides things that the
generated code talks to so they still
work we still support them but we think
we can do better partly by looking at
the patterns that we're using in API
design to get a better semantic
understanding of what these are PCs and
what these resources actually mean I
will get to code fairly soon I promise
so we're mostly going to be talking
about the G RPC stuff today because
that's the new hotness and that's where
I've been spending most of my time and
obviously in greenfield development
that's where you tend to be able to make
design decisions by the time you've got
something that's been going for a few
years there aren't very many design
decisions other than how few people can
I break to get more people new goodness
so within here the blue parts are code
generation or generated code the orange
bits are per API manually written code
that's me and my team and all of you
because as I say this is all open source
it's lovely being able to work in open
source because later on I can just bring
up the code that I've been working on
and show it to you all and you can say
hey I'd like to fix that and say right
send me a pull request so the orange
bits are per API things and the green
set over on the left and are the support
libraries so Google Doc Pro tough is the
supports for protocol buffers so the
actual serialization part
GRP Secor and google api is off and
google api score are used by the G RPC
layer and Google API gaxx that gaxx is
Google API extensions which is I realize
somewhat to autologous in this situation
that provides things like support for
extra call settings for retries for page
streaming which we'll look at in a
little bit the idea is you should
relatively rarely when using these API
is you should relatively rarely need to
do anything with the code on the left it
needs to be there and for you're likely
to see Google lock protobuf bits and
because you'll get repeated fields that
you want to add elements to but most of
the stuff on the left you don't need to
care about the middle part G RPC
services most of the time I hope you
won't need to care about you will need
to care about the protocol approach buff
messages you probably want to care about
the pattern aware resource oriented
layer that we're generating and if there
is a hand-written abstraction over the
top then you will definitely want to
care about that
okay probably relatively little of that
makes sense until I show you an example
so let's skip to visual studio so we're
going to show you I'll show you three
ways of getting a subscription in from
pub/sub and this is the lowest level so
this is using still using generator G
RPC code so I guess in theory you could
do all of this without any code
generation at all by manually poking
bits down a socket you definitely
definitely don't want to be doing that
but let's just show you the bits that
are required for a single
subscription call so a subscription
knows its own resource name and the
resource name for the topic that it's
subscribed to nothing in the pub sub
side of things actually matters for the
purposes of this talk I'm I'm only
explaining enough to explain the
examples obviously if you want to know
more about pub sub come and talk to me
afterwards so we create some credentials
and the fact that this is five lines of
code is slightly annoying but boy is it
simpler than it used to be this is
finding the default application
credentials from your context which is
if you are running on a dev machine you
will probably have downloaded the G
cloud SDK and then run g-cloud off login
or G cloud application default login I
think we're sort of moving from one to
the other and if you're running on cloud
platform in some form or other so
compute engine or App Engine flex and or
kubernetes then it will use a metadata
server to find out basically who your
project is and it will connect on behalf
of your project to pub/sub so that's
getting some credentials we then create
a channel which is sort of a socket it's
not necessarily exactly one socket
because it will lazily connect and it
will reconnect if things drop and in
some situations which I've never
actually tried myself yet it could use
multiple sockets for load balancing and
things but mostly you don't need to care
so we create a channel by saying we're
we're connecting to as you can see over
HTTP and converting these credentials
which are generic Google credentials
that could be used in the restful api s
as well and we want GL PC channel
credentials so we want to have a call
invoker you never need to see this when
you're not looking at this low-level
you will never need to see this call
invoker business
likewise the marshallers so I mentioned
that protobuf was sort of optional in G
RPC you need to tell G RPC when you're
trying to create when you're trying to
serialize a request then call to byte
array on it and when you're trying to
deserialize a request which okay it's
not going to have to then use this
parser and likewise for the response so
having set up serialization of requests
and response we now work out there's a
unary method so a unary method is one
that takes one input and gives one
output and it's to this Google pub/sub
the one subscriber API and it's the get
subscription method and it takes a
request so it takes two requests
Marshall ER and the response Marshall or
so that sets up the method that we're
going to call then we can create the
request and the request is fairly simple
its itself this gets subscription
request just says fetch the subscription
with this resource name depending on
time I may talk more about resource
names and resource IDs later on we'll
see see where we get to so this is an
existing subscription and then finally
after all of that I can call the method
asynchronously and await it the null
here is for I can't remember I was going
to say it was the call options oh
there's the the host so you can override
even though I would normally call in to
this channel and you can say for this
call I want to call a different host
passing the request get the response and
the response is in this case just a
subscription that's all a bit painful I
think you'd agree and you definitely
don't want to be doing all of that work
every time you make an API call let's
have a look at the with the generated
code
for GRP see so that was using you could
get away with that by using the
generated protobuf code for get
subscription requests and subscription
but other than that just plain G RPC you
would never do that if you wanted to use
just the the G RPC generated code then
it's slightly simpler I haven't bothered
will the set up of the channel because
that's exactly as it would have been
before but you can create a subscriber
client and the client has generated code
that says hey I know that I'm going to
be given a get subscription request and
I'm going to return a subscription as
the response so we can just await it and
we have a pub sub subscription good
still slightly painful you know why am I
having to create this get subscription
request it's all a bit annoying so let
let me just switch back to the slide
very briefly what I've seen what I've
shown you so far is using just the
protobuf messages and G RPC call and
then the second example was using the G
RPC services and then when we use the
the actual wrapper library
I either the bit that I'm more
responsible for so I'm not on the G RPC
team so so far I've done the protobuf
stuff but the G RPC team is responsible
for the previous example you showed
using the library that that you can just
download from nougat you can say I want
to subscriber client confusingly this is
not the subscriber client class that you
just saw I'll talk a little bit about
naming later on the good news is you're
unlikely to get confused because the G
RPC generated one is a nested class
within subscriber so it should stay out
of your way this is a top-level class so
just creating a subscriber client
notice how there's nothing about
channels nothing about credentials it
just I assume that most of the time you
want to use the default credentials if
you don't you can pass in a channel here
it's a little bit of a pain if you just
want to pass in a credential I'm going
to fix that but basically I just want to
client we then have this next line for
the subscription name if you remember
the big long string here this project
Stransky to be project subscriptions
demo subscription that's quite big and
hairy we still need that but we can use
generated code to get the full name from
the bits that we're likely to care about
which are the project ID and the
subscription ID so we're saying format
subscription name john ski to project
them in subscription and then we just
say I would like the subscription please
nothing else okay so it's gone down from
quite a lot of code not just in terms of
lines but hairiness to four lines
including a console.writeline
which reasonably straightforward I don't
personally like the fact that we have to
do this but we can talk about that later
on so any questions so far on you know
what that abstraction looks like I
haven't shown you yet any handwritten
layers over the top because for pub/sub
it's sufficiently simple that we have
decided having looked at it that we
probably don't need an extra layer over
the top for datastore which is another G
RPC enabled API now we do have a layer
over the top I have a little layer I'll
show you that a little bit later but do
you get the general idea of what we're
trying to do okay back to slides so what
decisions have we had to make even in
what you've seen so far we've found that
there are various tensions in API design
this is not massively a surprise you
know it's not like I came into mid-2015
and thought API design is really easy or
library design is really easy but it's
been interesting to me to see exactly
where the difficulties lie and it's
mostly several different flavors of the
same kind of problem which is that
there's no one-size-fits-all we've kind
of concentrated on making you productive
in five minutes so the last example that
you saw you should be able to see that
sample copy paste it get going it it
will probably take you longer to sign up
for Google cloud platform and get an
account and you know maybe download the
G cloud SDK that should take you longer
than running the sample and by the time
you've done that once when you use the
next API it should be just like that but
does that necessarily mean that it's
going to be entirely useful for your
real application how many of you have
seen great demos of some platform or API
and then thought I'm going to go and use
that at home or rather at work and then
found you know it doesn't quite do what
I want and it turns out that it's been
built for demos it's remarkably easy to
do and maybe I'm just not
I don't think it's actually a cynical
ploy on the part of tech companies I
think it's because when we've been
trying to make API decisions we've
looked at fairly small examples thinking
how does that look versus something else
and we haven't been building my job is
building a class library it's not
building an application that uses
pub/sub in the real world in a hardened
way
etc and I haven't got time to do that
for every API that I want to cover which
is a shame it would be lovely if I did
have the time to do that but it it does
make it tricky so we try to make
something that is simple and not scary
you shouldn't look at anything within
the samples and go wow that's hairy
there's no way I could come up with that
for myself or modify it to do exactly
what I want or understand it later on
it's got to be simple enough to look at
for the simple situations but also
flexible enough for real-world use so
chances are in a production app if you
are writing Pokemon go and calling into
the API you may very well want to tweak
the retry settings did I show any retry
settings up there not at all but they
should be sufficiently discoverable
however that manifests itself that when
you need it it's there so part of that
discovery is working out how our users
are and when we're talking about Google
we have a huge variety of users you may
well be in a simpler situation most
companies yeah this is not bragging but
most companies are smaller than Google I
think that's fairly simple statement so
you may well know your users better if
you're providing service to them you may
well have a better feedback loop than we
do so you can judge how experienced they
are one thing that I found very
interesting is trying to work out how
much documentation someone is prepared
to read and have any of you done user
studies for developers where you've
shown someone a class library and and
given them an example and said right you
now have a task to know get a
subscription or list the subscriptions
for a topic or something like that
and have you done that
if you have users who are using your
code do it it will scare the living
daylights out of you right I shall take
this example remove all the useful lines
and then say I don't know what's going
on yeah yeah you removed all the useful
lines so how much documentation are they
going to read if you could get them to
read for one minute what is the absolute
most important thing that you want to
tell them beyond the the people what are
they trying to do in terms of
portability now we don't currently
support unity there's a trade-off there
in terms of the resources we could spend
to support unity for these api's and
that's in terms of my class library you
can definitely call these api is from
unity probably with the HTTP 1.1 stuff
that's all fine these particular class
libraries we don't support unity right
now we don't support net core this beta
release I'm hoping the next beta release
we will know how much does that matter
to your users I'll be actually only
talking about asp.net net that asp.net
devs who are running servers maybe from
Azure you know we're not we're not proud
it's fine you can call our stuff from
adder or from AWS we'd like you to be
calling it from GCP from compute engine
but they're not going to stop you from
calling it from wherever what are they
trying to accomplish and what's going to
be helpful and what's going to really
get in their way back to the user
perspective so that there are I think
it's worth distinguishing when you make
design decisions think about the
application they're trying to build
which is a hard thing so it's it's not a
soft skills business and then think
about the person who is using your code
and those are very very different things
aside from anything else there could be
a hundred people all building the same
application
some of whom are interns who are
learning c-sharp for the first time and
some of whom are industry veterans
who've seen all of this before how can
you make a last library that works for
both of them are some of them using the
same API s so using pub/sub for example
also from Python and from Java and from
go and from PHP and Ruby or some subset
of that so they would like consistency
they would like to see things that look
kind of the same in every language
versus other developers may be using
pub/sub and cloud storage for example so
Scott Hanselman in his talk yesterday no
it was just before his talk he was
showing bits of a show monitoring he was
saying he had a queue and when a an
image was uploaded into Azure storage he
would get something on a queue and he
would run something to run pudding crush
or whatever to compress the image and
then pop it in somewhere else so the
equivalent of that for GCP would be
uploading to Google Cloud storage and
then you have a pub sub Q and then
something notices hey I've got something
to do
fetches from GC GC s pad storage runs
pin crush uploads it to Google Cloud
storage so we've got two AP is there I
believe that many of our users use
multiple API s so if you're using
multiple API is from one language you
want those to be consistent with each
other and ideally idiomatic for the
language that you're using but someone
else might be just using the one API
from multiple languages and they have
kind of different not requirements but
different desires let's talk briefly
about documentation I would show you two
let's let's just see whether Internet is
working and I can show you the docs that
we've got
how many people here publish whether
it's open source or for work have some
library that they publish documentation
for how happy are you with your
documentation medium they are fairly
right I'm never happy with documentation
so whether that's for nono time the open
source project that I write and or our
class libraries here do out this isn't
going to work but there are again
competing concerns do you want your Java
documentation to look like Java doc and
then if you're using the same thing from
Python it looks completely different or
do you want some sort of consistency
between those two even though at that
point it's not fully idiomatic for
either the Java user or the Python user
hey these are not obvious questions that
can be answered with a yes no answer
what TLDR do you provide that that sort
of one minute if you read nothing else
please read this what level of
conceptual documentation do you provide
and how high do you aim that no one is
going to read documentation or very few
people are going to read documentation
and say I'm not an advanced user so if
there's a simplified version that's
that's what I'll read everyone's going
to say no I'm really smart I will read
the the smart people's advance
documentation and quite possibly get
lost so how do you provide things that
work for advanced and inexperienced
users what do you give us samples I
mentioned earlier on I haven't built a
full pub/sub application I did build a
sample little chat application which I
gather now isn't really the aim of the
pub/sub API but I haven't written a full
application but what kind of samples can
we give we have I have colleagues who
are writing sample web applications that
do you
a variety of AP is so that's kind of
useful to see it all in a big context
but then to get the full benefit of that
you need to clone the repo and run it
yourself and then you know maybe step
through relevant bits tweak it a bit
versus here's a sample that's
unrealistic you know it does one thing
it says I will list all the
subscriptions in this project okay well
that's not terribly useful in itself but
it is good as a if you know that you
want to list the subscriptions just
seeing that one thing is great the other
thing that we've been exploring is what
to do in terms of examples within an API
reference so I'll show you an example of
this how many of you have used dock
effects at all or heard of it no okay
well if nothing else I can provide you
value today by saying go explore dock
effects it's I believe it's what's used
for the asp.net core documentation it's
from Microsoft it's sort of think of it
as a successor to sandcastle ish and it
works with dotnet core projects it works
with CS proj project we've had to do a
little bit of work ourselves to add a
bit more flexibility but basically we
wanted to provide examples within our
reference documentation which we knew
worked if you write code within xml
comments it will fail it's bound to it's
not refactoring proof it's just not
going to work so we have a bunch of
examples here so let's okay these are
written as tests some of them genuinely
are tests in that they will assert
things at the end they will all run they
will all compile so if if I ran these
now they would fail because I've got no
internet connection but that's good
because it means that it proves they're
trying to exercise something and they're
exercising something that would fail and
within this room
and then we've got the snippet here and
ends nip it and that means I run a
little tool it extracts just that chunk
of text and puts it somewhere else that
can be extracted later on by another bit
of process the pipeline and so if you
look at the list topics method within
publisher client you will see that
example okay that's quite nice in the
future because hey this is c-sharp and
we've got Roslyn just showing that
snippet isn't terribly useful you want
to know what using directives are used
so in the future I'm hoping to take that
snippet take all the using directives at
the top create in memory a program that
just contains that see you it should
compile and then I can see which using
directives are actually required and
then put all of those into the snippet
as well things like this using the good
stuff that is coming in the dotnet
ecosystem really can help us build
better documentation so I would
encourage you to look at doc effects and
think about how you might use that it's
still sort of a bit preview ish the
default template doesn't have the
greatest Styles in the world for example
but really think about your
documentation it's it's one of those
things that is very rarely anyone's top
priority if you can persuade your
company to get someone whose sole
mission in life is to make your
documentation awesome and not that this
isn't sort of application documentation
this is if you're exposing an API then
your users will love you for it
okay so on to sort of less soft things
another design decision we had to make
early on and we've protobufs as well not
just these client libraries but we knew
from the start that protocol buffers
would be used within our client
libraries I have
a pro too - we've recently moved from
pro - to pro two three and ages ago as a
20% project I had an open source project
supporting proto 2 for c-sharp and it
was pretty much a port of the Java code
with some c-sharp idioms and the Java
code is all based on immutability we
love immutability within Google how many
of you are basically familiar with the
benefits of immutability yeah so we went
a different way for proto 3 because we
looked at the simplicity for getting
going versus long-term benefits and we
thought you know what there aren't quite
enough long-term benefits to justify it
being a pain to get going and frankly if
being a pain all the time that it's an
ongoing source of low-level friction
there are definite benefits and maybe in
future versions of c-sharp I gather that
records are no longer part of c-sharp 7
come to my talk later on to find out
more about C sharp 7 but you know it's
highly likely that a future version of
c-sharp will have better support for
immutability but at the moment it's just
a bit of a pain so we decided basic
rewrite of our c-sharp code for proto 3
which is now no longer a 20% project
it's fully supported part of the Google
slash protobuf github repo it's full
Google supported code let's have a look
no go away I'll just show you the
difference so these are not quite the
same proto's because the underlying
protocol
this is a sample proto for an address
book where an address book consists of
people and each person has an email and
a name and also a mobile phone number
but I haven't shown that so we get all
of this annoyance so just to build and
address this to start with an address
book we have to say I'll create an
address book
older and then set some properties on it
with an object initializer and you know
we can still do things this is a
collection initializer with in it I'm
trying to use as much c-sharp goodness
as I can but we still got build all over
the place I could have added an implicit
conversion from the Builder to the NAM
builder but that feels like that would
be a step too far and would surprise
people too often and would stop you from
using var where you basically wanted to
so we have all of that and suppose we
wanted to set the ID for this single
person well we've got to convert it back
to a builder and get the person that
we've created and convert them to a
builder as well change their ID rebuild
it set it back in the list and then
rebuild the whole address book that's
not fun I don't like having to do this
kind of code in the new in proto 3 we
have this so obviously you could squish
this code up if you wanted to but the
main thing is no builders anywhere and
we just have a collection initializer
and when you want to mutate something
you just do and this would make me sad
for some scenarios because there are
again definite and benefits of
immutability thread safety all kinds of
stuff but it makes me very happy that we
can write something as simple as this
this was hotly debated within the team
and I was personally resisting for quite
a long time
partly because and this is a lesson that
I want to pass on and it's it's not an
easy lesson we have biases ok when you
have written v1 of the code and someone
is suggesting a complete change of
direction for v2 you will resist it
because that's human nature we we like
what we've built and I resist it for a
long time I think this was the right
decision right now as I said when
c-sharp gets better
support for immutability in later
versions we might make a different
decision
any questions on immutability before the
next design point no ok paid streaming
ok this is one of the features that we
support I mentioned before that the
generated code above the G RPC service
layer is sort of pattern oriented so we
have a style guide which is either
public or going to be public for G RPC
for for the services that we will expose
and one of the patterns that we have is
if your listing resources such as
subscriptions in a project you may have
thousands of subscriptions we don't want
to necessarily return all of those in
one our PC so we have a pattern where
you do a list subscriptions request and
you can say how many items you want per
page and it will come back and say here
are the that many items or maybe a bit
fewer and here's a next page token and
then you can make another request and
say I would like to do the same kind of
thing I still want 10 per page here's
the next page token and you get back
another page and you keep going until
the next page token is empty a little
bit like calling in fact very much like
calling stream not read you know you you
can detect when you've reached the end
by there's no next page token you don't
actually have to make an RPC that
returns no results we've got one for
your RPC that you the knew would make
stream dot recalls but if you've asked
for 10 results you may get back 5 before
the server may notice our I'm about to
overflow your timeout so I'll return you
what I've got in the next page token and
you can continue if you want to does
that sound like a fun API to use
directly from your application code the
answer's no okay
I'll show you what I mean so did a
manual page streaming okay so it's not
so bad okay it's the kind of thing that
if you do once you don't mind too much
so this is just printing the
subscription name and the topic name for
each subscription in the project and
it's a do-while loop and this is not
terribly difficult but it is I wouldn't
say it's a page of code because you know
clearly I've got a massive font but it's
it's 15 lines of code it's annoying
so we want to make that simpler for you
so in the generated layer above we and
we knew right from the start that we
wanted to do this we will just expose
some sort of iterator and you can just
iterate over things and we'll do this
next page token stuff in the background
for you great so what design decisions
does that throw up the first one that I
honestly actually now can't remember the
answer to is what do you do about a
timeout if you're saying list
subscriptions and you give me a timeout
of 30 seconds is that per request is it
in order to get to the end what is it in
our case I believe we treat it as a per
request and because everything's lazy
this this returns let me show you the
actual thing the return value from list
subscriptions here is lazy so actually
calling this subscriptions there's
almost nothing out of interest how many
of you are surprised by that
a few come and talk to me later and say
how how we could make that more obvious
so from a link point of view it
shouldn't you know if you've used link
and used data tables or whatever
sorry not base tables but the tables you
get from EF or link to sequel or
whatever
it shouldn't feel surprising but I can
see that you're calling a method saying
this subscription should do something
damn it and it's even worse with
datastore where we have run query which
doesn't run a query it gets ready to run
a query as soon as you start iterating
over the results I'm fairly confident
that it's the behavior we want but for a
while we called this list subscriptions
page streaming and it was pointed out
that no one really wants that no one
wants the the extra hassle so this is
one of those things that if I could if I
could tell developers like five small
things it would be when you're doing a
list
it's deferred evaluation you're almost
certainly not going to see the
difference because why would you call
this subscriptions and then not use the
result but it does matter in that you
don't want to call this subscriptions
and then call count on the result and
say there are counts up suppose I did
listing subscriptions count
subscriptions okay then you may expect
that to list them once so it just needs
system link you may expect that to list
them once in terms of our pcs and then
display the count and display the data
but know just as it would in link link
to think well or whatever that would run
through everything to get the count and
then run through it all it's it's
preparing a query it's not actually
doing it but beyond that this feels kind
of nice I'm listing the subscriptions
great but that may not be the only use
case so if you just want all
subscriptions that's fine what if you're
doing a Web API that's how a web
application and you're trying to list
the subscriptions and you want to list
them one page at a time this doesn't
help you at all it seems okay because
you're trying to display the next 50
well we've no way of saying in what I've
shown you so far
okay just give me the first 50 and then
I'll display the next 50 after that and
how do you display the next 50 well we
do have a way of doing that
we still call this subscriptions but
then where as the the type of
subscriptions I'll just make it explicit
here so that you can see it in decent
font come on ah no sorry I had to launch
Visual Studio in Safe Mode because for
some reason it crashes when it launches
without the network and it looks like
the autocomplete to do explicit
declaration doesn't work um but anyway
this is an i paged enumerable of T
response T resource where T response is
a list subscriptions response and the T
resource is subscription and that I page
numerable hasn't as pages method and the
idea is this basically gives you back
instead of a sequence of the
subscriptions it gives you back a
sequence of the RPC responses so it's
still doing the page streaming for you
it's still providing value but it's sort
of a little bit lower level and this way
you can look at the page tokens yourself
and that's kind of useful ish it's still
not great for a web application anyone
think why if you're doing a web
application you probably want to display
ten twenty at a time and if the API
happens to give you back five you don't
want to display a page of five you want
to display the next 20 so this was
another use case that we considered and
we can actually do after doing as pages
we can currently do with fixed size
ten whatever it is and this will make
sure ya nor the compiler as it changes
the return type obviously at this point
there may be extra properties within
each response that we no longer give you
because we're doing extra work on your
behalf so it could be that one fixed
page that we return you with ten results
came from two different responses so
we're not going to give you a respond to
more but you will get exactly ten items
until you reach the end of the list
obviously and you will get a next page
token that will let you get the next one
so that should work for web applications
so those are the use cases that we've
come up with of I want to see the
responses I want to just see the
resources because I'm dumping them in a
console app or I'm doing some batch
processing or I want to get them with a
fixed size and it took us it's taken me
five minutes to explain it all it took
us a good few days of working out how do
we want to expose that we're still not
sure is it better to have as pages dot
with fixed size or should we just have
subscriptions dot as fixed size pages
aside from anything else if we did this
we could get away with I think to fewer
interfaces which I don't care about
having more interfaces in terms of my
code maintainability it's it's simple
but I don't want to pass that conceptual
burden on to you folks so there are
reasons either way okay I'm running out
of time Jeannette I came this morning
thinking I do hope I've got enough
material for an hour whenever I watch
someone else's presentation an hour
feels like a long time even if I'm
having a great time but it's amazing how
things change when suddenly you're
presenting right so I will go back to
the slides and work out which of the
slides we should look at most so naming
versioning inheritance repair right
I can probably cover both quickly so
naming and versioning when you download
the pub/sub NuGet package that is called
google doc pub/sub v1 and the current
version of it is v 1 beta 1 is that
confusing okay
darn it's still the right thing to do I
think because the API version is Google
pub/sub v1 we may come up with a much
better way of accessing it with all
different code gen that is a completely
breaking change and that would be Google
pub/sub v1 version 2 unfortunately in
theory it wouldn't finish there because
we could be using different versions of
the prototype codes and different
versions of the GRP C koujun there are
various orthogonal axes here for
versioning but we've decided that the
the client library version you get is
separated from the API version that
you're accessing that's bad in terms of
it's confusing it's good in terms of
flexibility at some point I'm sure there
will be a Google pub/sub v2 you don't
want to automatically update to that
from nougat because it may be breaking
it may have some different features they
may remove some features or rename bits
and pieces we've had an interesting
discussion about what counts as a
breaking change within an API that seems
like it should be obvious and I mean an
RPC API it feels like it should be
obvious but it's really not if I have an
enumeration I don't think there were any
in pub/sub but in datastore for example
there are read options and you could say
I would like my read to be read
consistent eventually consistent or have
a transaction well what if they had a
fourth one is that a breaking change or
not like well if it's only something
that the client is going to give then it
fine to add stuff because if you don't
know that the option exists it's not
going to hurt you if it's added if
you're getting something back then you
might have a switch statement that will
break if it doesn't see any of the
options that it expected in that
particular case we've decided that the
backward compatibility requirements of
making enums sort of a closed set is so
limiting for API producers that no you
as clients should always understand that
there might be new values coming back
deal with it it's kind of a pain but
it's better than stifling the innovation
on the server side there are other
things that obviously you know if
someone makes a typo in a field name and
that's generated if if you had maile
seconds instead of milliseconds well
that's that until the next major version
we're not going to break people just
because we made a typo I mentioned
inheritance it may not be entirely
obvious how inheritance maps onto this
versioning thing but one of the things
you can do in in a version 1.1 of
pub/sub would be which would still be so
I should go back google doc pub/sub b1
would include anything v 1 point 1 v 1
point 2 etc until we get to V 2 or V 2 V
2 1 or whatever and so we're aligning on
major version numbers of the API so I've
referred to publisher client and
subscriber client various times so I
haven't realized I hadn't switched away
Bob right
initially we wanted to have I publish a
client and then an implementation of it
yay I love interfaces they're great
they're mockable if you really want to
mock or we can provide you some fakes or
would be good
unfortunately it breaks so suppose we
have this ie cool API client where the
look funky method and then version 1.1
adds a new method you can't add methods
to interfaces that's a breaking change
because you met you while we could
provide you a fake you may have written
your own fake that implements the
interface
I don't want version 1.1 of my client
library to cause your applications to
fail to compile so interfaces are out
okay what about abstract classes then so
we could create an abstract class with
the methods and that still breaks for
exactly the same reason if we add a new
abstract method to a public class that
is a breaking change so the pattern that
we have come up with and this is largely
to do with code Jen basin bear in mind
that these are sort of examples of
things that we're going to generate and
we don't want to have to look over every
single change that's added to check that
it's not breaking we need to design for
non breaking this in the code generation
this is what we've ended up with we have
the base class which is what you will
all talk to and that's what you should
fake and there are there's a static
method on it to create an instance and
then there's the implementation and the
default behavior of any of these virtual
methods everything's virtual and it all
throws an exception and then in the real
implementation it doesn't you may ask
well why not just have the
implementation class well because then
you've got to have a G RPC client and a
channel and all kinds of things that
don't make sense for a fake
so I'm not sure has anyone seen this
pattern before in other class libraries
no that is a concern to me I haven't
either by the way this isn't that you're
missing something but when we've come up
with a pattern that no one else has come
up with before that's always a concern a
it means it's unfamiliar to you so I
need to explain it and B it means maybe
there's something that we've missed it
may be too late to change this now if
you think that this is a really bad idea
we have thought about it quite hard but
I would certainly rather know if you've
got a better idea for something that
wouldn't end up breaking if we add new
methods but it's still testable Fae
Keable where necessary that would be
great right I am now already three
minutes over time I have I have more
stuff I would love to talk about I will
take two minutes for questions now sort
of wide open and then obviously come and
talk to me afterwards yeah ah so for the
paging why not use take and skip you can
you can absolutely use if you call this
subscriptions and then say skip fifty
then we will make the API calls to fetch
those fifty and then ignore them and
then because it's just link so it's just
an ienumerable it will all work but that
makes RPC calls that you don't want if
you're if you've got to page a thousand
and are getting the ten thousandth
subscription you don't want to make all
those API calls behind the scenes I
don't think it would be quite hard for
us to intercept skip and take calls in
order to do exactly the right thing and
the roared RPC API is don't provide
numeric access you can't say I want to
skip to result 30 so we would have to
work out you we've got to have a page
token we are limited by what the RPC
is provide and there are there are good
reasons to not provide numeric access I
think some api's do but yeah generally
we don't any other general questions
nope do come and talk to me if either
you want to see the rest of my slides or
want to are something that you didn't
want to ask publicly thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>