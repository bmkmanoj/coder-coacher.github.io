<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Walk Through Electron's Internals -  Brendan Forster | Coder Coacher - Coaching Coders</title><meta content="A Walk Through Electron's Internals -  Brendan Forster - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Walk Through Electron's Internals -  Brendan Forster</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oTDjyMTZU1s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so hopefully
on time they'll be probably a few more
top
coming in the back welcome welcome for
this talk today I'm going to walk you
through some electrons and channels and
show you some stuff under the hood and
ultimately what makes a tick out of
curiosity who here is using electron at
the moment I've got one hand up the back
so what's people aren't excellent
excellent
we'll keep that in mind so for those you
who don't know me my name is Brennan
Foster
I work at github engineering under the
Klein apps team and I've been spending
the last few months with electron
previously I was a dotnet David doing
WPF so the probably the first thing to
cover it off around stuff is probably a
lot of questions about electrons seeing
how and you saw one hand for the talk
you know what is this thing why should I
use lo habla what should I use inside an
electron app this is not that talk I
hate to be the bearer of bad news but
there are lots of other things out there
to look at for those resources and I
wanted to put up this talk mostly for
fun there was a talk yesterday at the
conference by Christian and Mahesh
talking about the the why and the how
for building out electron apps so I
recommend you guys look at that
so this talk will be diving into what
makes up electron the various bits and
pieces that are there what happens when
the electron app runs up how it plugs
into your app and how you get to the
stuff underneath and a little bit about
the packaging at the end this is where I
rant a little bit bit about the magic of
the frameworks that we use I love kind
of understand what's going on underneath
because they at some point in time you
will need to go underneath and
understand what's actually happening
when your frameworks are running oh I
didn't put it on repeat anyway you get
the idea the other part about wanting to
do this talk was all the stuff that's
electron related is open source and so
I'm just going to walk you guys through
the stuff that's there and show you guys
where to find stuff if you want to dig
deeper into electron so I did not start
my timer so before we dive into the
source code I want to give you some
backstory on electron and how it came to
be so you might have heard of atom the
editor that get her put out it was
awhile ago February 2014 we published it
out as a private beta and then we open
sourced it a couple of months later but
history on this actually goes back a bit
further so fearless leader of get
and current CEO chris wanstrath was back
in 2008 experimenting with using web
technologies in a desktop scenario he
was inspired by Emacs in the crazy
extensibility stuff that's there but he
didn't want to write stuff in lisp and
so he built something out with WebKit
and JavaScript behind the scenes to kind
of prove out this idea but unfortunately
one of his other little ideas that
became github McCann took off and so
this thing sat around for a while until
he came back to it and hide some other
people to do the job and the stuff that
was in this project that was called
atomicity became Adam and so when we
published that out we got a lot of
interest from people doing other stuff
to the point where the core of it what
was called atom shell over time deserve
to be its own project in its own right
and so about twelve twelve months ago 18
months ago atom shell was renamed to
indicate that it was a standalone thing
and so since then we've had Microsoft
come to the party and use the default
Visual Studio code we've had slack do it
for their chat apps brave the browser
using electron all these other people
are building stuff on top of it so it's
been a really lovely wonderful journey
so it went 100 back in April we had a
big announcement to say like this is our
point where we're going to do some API
stability and build on that one from
there and ultimately there is a lovely
website called electron atom IO if you
only go find some more resources there's
a lovely introductory stuff and
documentation there and that's where
we're going to start cool so electron
atom IO so the current version is one
point three point two and we call out
some very important components no
chromium and v8 for those of you who are
probably familiar with node it's a
framework written for doing JavaScript
and traditionally for server side apps
but we use this thing locally to kind of
let you guys do desktop apps but using
JavaScript chromium itself has a whole
sordid story which I'll explain a little
bit and then there's a thing v8 the
JavaScript engine that's in Chrome so
components are all important to what
makes up electron and so I'll walk you
through how we actually package up
electron and explain all the components
so like all good things the do vo
electron release starts from a crime
release so the chrome team has their
stable canary beach channels and they
will announce stuff fairly frequently so
this was from you know a couple of days
ago a couple of days ago the one I'm
looking for quite often is the stable
channel so on Wednesday they popped up a
new version of the stable channel we go
cool right now it's time to look at
upgrading electron the big problem with
this stuff is that they don't make it
easy for us to consume the source code
yes there's a tag and the get repository
and if you go and look for the chromium
chromium source
ah one second
fantastic so it's not the repo on github
it is this one here so it's very
intimidating to go navigating the
chromium source code and finding out
what stuff you need you'll see these
numbers here that look a lot like chrome
releases but ultimately this stuff is
not easy for us to consume and so the
fearless leader of the electron team is
EC Benz has set up a repo so he mirrors
the releases that come out from the
github from the other going up from the
Google Blog we can see three and
eighty-six them here and you'll package
up the source for every stable release
that's interesting so here's the one at
the top
chromium 50 3.0 so that's probably
something that we'll pull in later for
evaluating the next release we make the
stuff easy for us to consume but it's
literally a starting point for
everything that flows out of it because
we need to compile the stuff for Mac
Windows and Linux there's very sorts of
build concerns as well but we won't go
into that because you guys don't wanna
hear that do so when we're looking at
the chromium source repo here I was plot
master to show you this tree fantastic
so this is literally all the stuff that
goes into the core of the Chrome browser
so if you look at this stuff here you'll
see like networking PDF rendering like
this this is where the magic of chrome
happens so we can actually package the
stuff up and use it elsewhere content
module there and there's a lovely doc
inside the chromium project explaining
like what stuff is in this content
content library versus the chrome itself
so the Google team will take the stuff
from chromium and they will package it
up with things like extensions they'll
check you know form fillings and it's
stuff things aren't related to rendering
HTML page that's an inserts on top and
becomes like the Chrome browser we're
only really interested interested in the
content self and all the stuff that the
content API needs so it's not really
written
we call this thing Libba chromium
content and the next project that we
have that's related to electron is our
fork of Lib chromium content so this is
we pull in the sources from our our
stream of releases and we will patch the
premium content there are scripts inside
this repo so you can do the same thing
just go bootstrap and build that's the
conventions that we've got and if you
have a look inside this build script
here this is tool called ninja so ninja
it's part of the depot tools that the
chromium team used for all their bills
so for a lot of this stuff we will take
and reuse the stuff that they do just to
be consistent like the same stuff that
they do we get benefits from straight
away with rather than reinvent the wheel
we're just going to kind of use the same
stuff that they've got there again I
don't expect you guys to be building the
stuff but it's it's not that hard to do
it does take a lot of time however so
for the demos I'm not going to make you
I'm not going to show you building
chromium because it takes like a good
hour on my demoscene and so coming back
to the content module docks here there's
a slow guy v8 at the end so this is a
big problem when building electron
because both node and chromium need this
this is fun in terms of how these things
can get out of sync and just making her
that because we'll come back to it but
at the moment there chromium project is
on a version like - miner builds ahead
of what node is on so yeah keep that in
mind sure thank you so Lib chromium
content has a specific version file so
we bumped this file we then go off and
pull down the source code for an
Associated release we even can then
build and package that stuff up we then
put those artifacts back up and then we
can go on to the next step to give you
an idea of what that looks like
we have pool quests for these things
crazy you know open source
so the chrome 52 release we have just
some tweaks as my version update and
then we have these these patches so we
want to patch the chromium source stuff
and it's literally applying a git diff
most of the stuff is simple
switching api's aren't switching api is
are hiding stuff we don't intend to
rewrite a whole bunch of the chromium
stuff we just kind of want various
things that we need further up the stack
the note here around the MAS build we
have support for the Mac App Store
there's also support for the Windows
Store as well which is documented but
I'm not going to cover in that because I
don't think we need to do anything
around this around supporting stuff is
low down and so most of the stuff we're
just rewriting the same patches to fit
the changes of source that came from
upstream chromium so that one went away
that's excellent and literally like this
is the boring stuff that makes the magic
happen later on question yep yeah yeah
and as functions move around upstream
okay so for the recording john was
asking so you have to reapply these
patches for each release yes we do
that's that's the annoying part and like
if you look at these the actual details
for the diff here like the hash has
changed the lines change the contents
change like that's yes it's tedious but
ultimately it's it's not that bad I've
not been privy to those discussions
whether it's been thought about on our
side most of the stuff comes down to
chain and so I should probably have a
beer with him and discuss what his
thoughts out
so after that just to show you a bit
more magic of the scripts we have the
ability not vendor
cool so at the end of this build script
Chang will go and upload these compiled
bits to an s3 bucket which we can then
pull in further down the chain so the
last part of this is a little project
called
bright ray if I could spell so bright
ray has one simple boring purpose to
make it easier to host chromium and so
there's a whole bunch of stuff under
browser which supports api's for
initializing chromium and then callers
can can just invoke that stuff I'll talk
about how we use the stuff in an
electron in a bit later but ultimately
we need to then compile this guy against
Lib chromium content and so the the
chain moves further along so node itself
when I was talking about v8 node will
document the version of v8 that they
depend on so creamy and can't do
chromium project using 5.2 at the moment
node uses 5.0 at the moment so this is
an incompatibility so this is why we
build node from source as well
we have our own Fork of electron and
there's some stuff in there as well but
I'll show you guys how we change this so
for the most recent release I go into
electron and then find the window and
anode so as part of this release the
last release 1.32 we bumped the sub
module from one tree to another it's a
little bit not so it's not so well
documented so I'll just give you the
cheat codes to find that
so the commute 179 I know and blah blah
blah so you can see here the starting
point for node was the version six so
release officially done upstream and
then we apply various patches on top so
again this is little stuff that we just
want to expose an electron that node
doesn't do by default and it's things
that again upstream kabhi doesn't make
sense a SAR support is something
specific to electron which I'll touch on
in a second but little things like
changing our processes launch because we
want to embed node in this app we don't
want to call no Daleks II and have some
extra stuff happen you know hiding in
the console window when things launched
like little things like that that just
make the electron experience more
polished and that we can also embed in
our app so this is where we get really
really deep good stuff so as part of
bundling node we will hook in and say
like we want to compile the single asar
so even this low down when we're
building node we want to kind of expose
stuff up to atom sorry not atom electron
I'll come back to this guy in a bit
because he's very very interesting so
we're almost ready to build electron
from scratch so I cloned down the repo I
bootstrap the project and I open up the
source stream so the interesting bits
here are these folders so atom itself is
a whole bunch of C++ code that will
compile in on top of chromium end node
we have the chromium source which is the
snapshot for stuff we want and then Lib
so Lib is a whole bunch of JavaScript
API is that become available when your
app loads up so how the stuff hangs
together is what I'll touch on next but
ultimately those are the bits that are
going to be your interests to you guys
oh thank you thank you
do have my tabs no it doesn't matter
and like all these other projects there
are script folders for the stuff that we
need to build there's vendor stuff the
same sort of structure flows through all
of these things and so in theory I could
come in here and bootstrap the thing but
it's going to download the premium
content and no one wants to watch
progress bars so I'm just going to say
that I can I can build this so I'm gonna
switch over to the electron sample app
so this is just a sample app that was on
the main electron site if you haven't
got started with electron at all
literally it's a three step thing find
the repo down NPM install NPM start and
you'll see hello well
tada literally the most boring game I
like that I can think of and there's
just some stuff in there around the
versions of the app that I'm running you
know everything is nice and boring so
I'm going to now make it a bit
interesting and open up processor and
open up pokÃ©mon how many of you have
used pokÃ©mon before do I need to a
quick demo love it so for about
two-thirds of the room for their hands
up and I'm not even gonna bother
explaining cool so I'm gonna close that
out launched up again cool we do that
I'm just gonna poke the process tree so
what happened there magic of NPM start
launching node which then goes off and
passes the commands all the way down
until it hits electronics II so lots of
people complain about Adam in particular
doing the same thing they're launching
off a number of child processes from the
main process itself so this is another
bit of chromium that we we follow on the
Adam site so chromium has the concept of
this it's so poorly named so the browser
process and the renderer process the
browser process is the main process that
the app uses and then it will spawn a
number of renderer processes if you
think of the browser and tap analogy
each renderer processes associated with
a tap and so they made the decision a
while ago so that if the tap crashed for
whatever reason it wouldn't bring down
the whole app we're following that an
electron because it's literally easier
to do then fighting with what they've
done this is will we've reflected a
number of API decisions later on but
keep their mind in distinction browser
is main thread renderer is the Louise
thing that gets displayed on the screen
and if you want to understand more about
this
there is literally a webpage on this
about the chromium project literally a
webpage on the chromium project members
so this means in terms of your
application when it's written an
electron there's there needs to be some
way to talk between the renderer process
and the main process again I'll show you
that stuff and how that works later but
this is decision made upstream that we
then follow an electron cool a couple
quick notes here that I meant to mention
before so the benefits of having the
processes isolated means that the on the
browser side in particular the sandbox
for the browser tab is a lot more secure
we don't really care about that much
with electron but the more the graph the
greater benefit is when a process goes
down that the whole application is able
to keep going so that's where the
renderer the renderer terminology that
flows through the rest of electron that
comes from the tree when the process
launch it launches it knows it's a
different type so enough talking about
slides the setup of the code is what we
need to look at so inside electron
source what is actually responsible for
setting up everything the most probably
the most predictable name here browser
main parts this guy is actually part of
bright ray so while saying before about
how bright ray is therefore setting up
chromium and all this stuff this handles
all the cross-platform issues that come
up so x11 the windows manager for linux
we pull in some files from that you know
the windows sort of stuff building stuff
for different platforms means that we
need all the header files and stuff from
these related projects and so this is
this is the life that we've chosen
and so ultimately we go down further and
the main the other row benefit of having
this sort of component is that we have
hooks to do stuff at the application
level so initialization that will keep
being set up
don't worry about the terminology here
but we get to things like the message
loops so having v8 under the hood means
that there's various message alerts that
need to be set up so we can do that
stuff in briar tray and then we can
tailor the behavior within the
application itself anyway barbar any
stuff
atom itself oops atom itself extends
browser and main parts into a more
creative the imagined name called atom
browser main parts so throughout the
codebase you'll see mentions of atom
we've been basically moving stuff over
to electron but we haven't renamed
everything in source most of stuff is
internal to electron and so like we'll
probably get to it someday but for now
these are just legacy it's not intended
to be a branding exercise for us so this
this is where the magic really kicks in
so as part of setting it up bright ray
goes off and initializes chromium and we
initialize malloy bindings and atom
bindings the bindings are platform
specific because of some stuff with v8
but what's interesting here is that I go
I dive into node bindings and then I
have this hello hello referencing
modules so as part of starting up atom
browser main parts we have a number of
modules that we want to pull in this is
where the features that we have an
electron get registered and so then we
can utilize those at a later point and
like before going further down here we
go
resources so no bindings again browser
thread render a thread we initialize
these in a slightly different way
because we want to expose slightly
different functionality the renderer
threads will be displaying stuff the
browser threads do not like that sort of
distinction we want to make clear at
Build time
anyway see mentions of UV that's us
configuring libuv and if you've never
seen what the libuv event loop looks
like i will give you a quick peek before
I go further here remember how I talked
about asar
so we have a package that's deployed up
by default with the electron app we then
go through and run this script so if you
were doing a node app you would
typically call node you know and then a
path to a javascript file we're doing
that inside electron the same and so
this energy Assael has a lot of the
magic around declaring everything else
again I haven't explained the ASR format
but I will spoil that one fairly soon so
creating their environment you know
declaring some extra environment
variables we go through and then load
the node environment you know then the
message loops kick in so just for
example I want to show you the lip UV
look beautiful my font size so wait for
something from Libby V if it's done exit
otherwise Pole if it's done exit wake up
like literally bad as the essence of
Libby V and yeah yeah but
right okay wait we're going off-script I
love this no it's fine so bud wanted me
to quickly cover off the polling of
events in Libya V so control shift F
thats go yeah so from memory I'm not
sure where that stuff is hiding here we
go no searching searching searching all
right I will come back to that bud let's
cover that later thank you and now I've
lost my bearings
cool so on top of the node bindings we
have what was called the atom bindings
so after an underscore binding starts AC
inside here it's a similar sort of thing
but we're bringing in style bring in
methods so get processing memory info we
want to make that available to your app
so you can understand what's happening
and maybe help with profiling so v8 has
this concept of an isolate it's the
current running v8 environment and so
you grab that and then you start
manipulating it we can see here a couple
of examples of so by hooking into a
method called get working size under the
hood we'll call this get working size
method very very one-to-one in terms of
stuff but this becomes a way for us to
expose my charity to apps themselves so
we get down to the end after all these
little methods there's our little UV
constructor and then we have this thing
called bind to so these methods will
actually find those ones in in the J
aside in a little bit but ultimately
just keep in mind again this gives us
the ability to compile in platform
specific stuff and also expose the
versioning of that so where's the stuff
appear
of a process so the very core of note at
the running process we see all this
stuff so this may get processed memory
and foe there's my get system memory and
foe if I poke the methods there that's
not one yeah it's just a memory info
it's a function
it's native code under the hood but that
this is where you find this stuff when
your application runs up so if I go
process dot versions so you know atom
library we looked for the versions
property and then we added in a couple
more of our own and you can see those
here the atom shell the chrome version
all the stuff is where this this is how
we expose stuff to the app itself coming
back to no bindings we declared a bunch
of stuff at the top of this file with
that reference module macro we see
browser again we see common again this
is again following kind of like the same
consists of structure of browser
renderer a common these things map to
source files up here so app itself is
not of interest to us we have browser
slash API so the features that we're
looking for are all under the type of
process that we're running and then API
so I do love the good app example
because that's at the top so atom
browser app becomes browser API atom API
yet so inside here a similar sort of
setup but because we're no longer
dealing with the Lib Eevee bindings
we're more just defining functionality
and attaching it to wherever we want so
still some platform specific stuff
mapping things from v8 blah blah blah
blah blah blah let's just go straight
down to the bottom of the file because
otherwise we'll be here all day
cool so at the bottom here there's our
atom browser app name and so this is how
node lets you register native modules
and so you say I want to register it
with this name and I want this method to
run so like before we go and grab the
isolate for the current via environment
in this case here we have app just a
whole bunch of other extra options there
but it's not off my process it's
somewhere else and so what I'm going to
do next to show you guys where that
stuff is organized and why things are
where they are so the last thing I
glossed over before was our little
friend asar so SAR K is a little project
that came from the need for us to
package things and I gather you people
know about the tar archiving format you
guys you know I don't see make beats in
the crowd but that's fine
very much tower inspired but ultimately
it's a read-only archive we want to make
it easy to pull files out within your
app but ultimately just have one file
for the ease of deployment and so
there's a library on npm that you can
use for creating your own packages but
ultimately we bake this thing into node
because we believe it's supervised a lot
around the deployment that's going to be
coming up but ultimately don't worry
about that it's just a another repo on
github that we use cool so the demo app
itself
just gonna open up the demo project in
Adam and just show you guys the various
parts that make up the app it's
literally a minimal thing that you need
cool there we go
possibly fantastic so the parts there
are of interest to electron itself the
main JavaScript file which is the entry
point to the app the index file
something to show for the end-user and
the JSON file so the JSON file you can
specify the main entry point of the app
I think by default it's going to choose
index J s if you don't we have some
scripts to run stuff up but ultimately
the bit that's come out scroll there we
go so rather than having to build
electron from scratch like you would
with other native dependencies in node
we should have a pre bit version so what
this does that install time is that it
downloads the version that you need
rather than having to pre-compile up the
main J's file again fairly simple just
there to kind of do the hello world
basis but it looks very much like a node
app so we require a module we have a
look at some of the api's that are
available to do we scroll further down
we listen for events that gets raised
and we do stuff about it it's all very
conventional if you've ever used the
event emitter stuff in node like this
this API is as should be familiar cool
so I'm just going to drill down into how
this magic works because at the moment I
don't actually have an electron module
defined in my list I don't even have any
actual dependencies this this dependency
here electron pre-built is the dev
dependency where where where is the
stuff so switching back to the atom
source you remember how I mentioned in
at jeaious before
Adam bindings nope I'm just going to
know by an extra careful so this in a
J's file is responsible for registering
the modules that the application needs
again because it can be browser or
renderer there's actually two different
files that live in the source code and
to ensure it's been packaged up at
runtime there's that stuff there but all
this stuff is under Lib so Lib in this
case here let's go with browser and
let's go with inner Jas let's pop this
baby open so we have some common file
and functionality to both but then we
dive into the module global paths hang
on a sec what's this guy so initializing
electron means that we will actually
define some exported ap is again the
stuff follows the convention of stuff
being under API so the example I'm going
to look at API exports electron J s so
we have one for the browser thread we
have one for the row sorry browser
process we have one for the renderer
process and this electron JS file is
actually kind of boring so we pull out
the common exports we then add some
extra exports on top each of these these
files is associated with each of these
properties is associated with a file
further up again requiring stuff pulling
stuff in just composing everything
together on the client side
I say client side because J aside in
these files here I'll just look at app
again because that's a good example
just regular JavaScript files magic that
comes up from atom binding I'll explain
in a bit because that's then going back
into some native code ultimately you
know this stuff is just JavaScript code
which we then make available to your
apps so as part of the requiring step do
do very simple very straight up yeah so
that's where all this stuff is and if
you want to start poking what acres are
available that's cool and to show that
there is no
a secret trick here I'm just gonna
launch the app again cool
so there's the features that are
available
unfortunately app isn't there so I was
in the browser thread here earlier
you know that's possibly there but this
is me actually hitting the renderer
process so when you run up an electron
app your chrome dev tools if you pop it
up for your browser window it's going to
be associated with the renderer thread
so the renderer sorry is a rendering
process the render process has more
limited functionality available than the
browser process and so if I go require
electron dot app it's undefined and so
that's that's this is where the
separation is between both functionality
and access to resources
so back in my up J's file I have this
thing called Adam binder so Adam binding
hell I'll just go straight to the common
one
so shortcut it's under Lib common the
demo gods don't like me so this is going
to be under Lib common API no you know
Jess as soon as it comes good of course
beautiful
so processor Adam binding hooks into the
existing way for resolving bindings in
node again same browser same trick of
like do we have a browser process or a
render a process version if we don't try
the common version this is how the J's
files are getting access to features
that are defined in native modules and
now I'm in Dixon files again I love the
demo gods today so yeah so the fallback
behavior for looking for the common
process the common functionality versus
the browser specific sorry the process
specific behavior yeah we're hijacking
what no does initially so when we were
registering stuff in the node bindings
we can then go and resolve it here and
I'll just go find the file myself thank
you
beautiful
cool so the thought if you're curious
about understanding what the binding
behavior does we roll through the
current environment we try and find a
module that matches the name list you
like key value look up the stuff what's
interesting about this is that the it's
a void returning method but if it's
successful it'll set the return value
very esoteric C++ stuff but it's BA so
we're not going to argue with VA we get
down to the end here yep so well
everything that same stuff in electron
to do features in the same way again
being consistent
cool and like before when we were
setting up stuff an electron node itself
attaches methods to the running process
and that's the magic that for binding so
I talked about asar at least from a
conceptual perspective what I'm gonna do
here is flick back to the PR you do and
show you guys how we're doing this stuff
so from memory we're doing process top
binding going to load a module from the
electrons side and we're going to call a
method on it jump up to atom common I
say oh sorry no API gotta follow the
rules atom API a Sardar CC so that's the
model there and inside here there's some
code for getting things set up there's
some code for defining methods on
objects that return we get down to the
very end here I'll just go find the
method because I'm impatient cool so
here's our method in us in asar support
there it is being defined by it being
registered by the module again like now
the stuff is available if a node runtime
which then calls all the way up back up
to Adam to register the stuff it's a
little bit of a crazy hairy architecture
but all we're doing in here is just
passing in a script and compiling some
to v8 to compile some stuff it's totally
fine
the script is related to yes you know J
yes who knows the filesystem module and
node we are kind of they said it here
monkey-patching FS to add in SAR support
so when you pass in a URL that has an
asar extension in it we're like alright
cool we got this and so this is just the
set up for that we're literally
hijacking processed up binding to then
change how FS module works if we want to
find that stuff it's going to be
yeah
so the SAR JavaScript module there we go
we're loading in some of the native
stuff path dot util when I found the
stuff I was kind of like half crying and
half laughing at myself
beautiful there so what I want to find
that's one of these methods no it's not
you're not found so exports dot wrap FS
with a SAR so this this is where we're
getting into what is happening here
so all the relevant methods on the FS
module we will wrap essentially so l
standing a file synchronously we grab
the original version and hold a
reference to it we then write our own
version that has a SAR support if it's
successful there yo will go from around
it otherwise we'll go and use the
default behavior this is this is this is
where I kind of was yeah feeling a bit
uncomfortable but ultimately most people
don't know it gnosis stuff is just
transparently there in the background
and things just work okay so we've
talked about hot patching of node
modules at runtime we've talked about
the processes of sharing stuff with
native and exposing in J yes let's go
back to my sample so in here in my main
jeaious so we've found out how to get to
our app property of course this is on
the browser process rather than the
renderer process we saw that fail before
we then have things like browser window
so coming back to my electron exports
so browser app auto-update a browser
window here we go so the contents of
this guy are in a file imagine imagine
imagine I can't even pronounce words de
creatively cold browser - window je s so
like before we get access to the
bindings for window we then add a bunch
of functionality so like before we can
create a browser window there's also
just a bunch of static methods further
down what's interesting here is the hook
for web contents so web contents API is
kind of like the raw access to chromium
if you want to hook into events on that
you do some stuff there this little
example here is if a new window pops up
in the background sort of thing actually
hook into it and and actually do some
behavior with it so for things like you
know making a page automatically pop up
like we need to do this some of that
stuff in electron to make its make it
actually work there a whole bunch of
custom events that electron services
around managing stuff yo the electron
space prefix you shouldn't be just
opting in for those in your app but
they're there if you if you're
definitely curious so switching back to
well was making it method cool so this
is the little little example of
initializing a browser window if you're
on OS X setting the application menu oh
if you're not on OS X setting the
application menu and then before if you
have a pop-up window that appears doing
some stuff with it the fun stuff comes
let me switch back so browser window we
go Naropa browser window we then have
various events on these browser windows
so IPC kind of pervades a whole bunch of
the electron stuff it's magic strings
but it's fairly easy to then hook into
stuff behind the scenes so if you go and
Google for Amit
just for reference I'm searching for
this little magic string in all the C
C++ code so Amit is ultimately where the
stuff comes in from the native code and
there is just it's yeah this is this is
the easiest way for native code and J's
code to just basically ship pass
messages around most of the I'm doing
good today with the demo gods yes
so this stuff there this is definitely
how the renderer thread can communicate
back to the main thread and if you're
looking at the example code from before
this is this is how the events flow
through from yo when is appropriate for
me to raise a window to pop a window
when is appropriate for me to close like
the IPC stuff is based on what's at
least in the event emitter side on the
node bits
this stuff is yeah and thankfully I'm
having a lovely day with the demo gods
no I'm good I'm going to ignore you so
coming back to I'm gonna solve buds
little question about the polling of
events in Libya V and pray that I
actually have something that works any
questions while I and I also pray
yeah yep
yeah yeah that is a good question okay
let me recover my dev environment
yeah so in the aten bindings we were
just calling poll events like that is
then probably going to the default
implantation of that I don't know why we
would do things differently it seems
crazy so anyway so just for curiosity
can you say again what you were seeing
and versus what you're expecting to see
so you talked about things like set
timeout and set immediate
yeah yeah hmm yeah so like skimming the
code here like it mentions being
implemented by derived classes and I
can't find an example of that here so I
don't but I'd love to understand more
because I don't know enough about Libya
V's internals to kind of Hutton specify
either way yeah yeah so no I don't have
a good answer for the polling event
stuff but I don't think we would do
anything dumb
cool yeah any other questions at this
point
what sort of integration would you were
you thinking of yep
so you would you could do the same thing
as we're doing is like register a node
module declare it the examples that we
have here so if you all look interested
in doing native not app sorry browser
API I'll get here sorry
that's what my API so if you're
interested in doing the same thing here
this magic the node module context-aware
built-in this is how you would declare
some native functionality so you could
then do the same trick that we're doing
in registers and J's files as well to
expose that stuff you could absolutely
do that same stuff if you wanted to an
electron app how that stuff will get
hooked in I'm not how to % sure I've
already discussed with someone today
about the ability to build electron from
scratch for doing that stuff I don't
have a good example of doing that stuff
with vanilla electron but if you want
you can chase me up after this and I can
I can do something so for those of you
who aren't that familiar with this API
there is a lovely blog post floating
around
it was cold this cool so age is an agent
needed to go node has had a problem with
the context for these things so in the
release notes here the event loop here
would be a weird sort of context
when things were executing ultimately
they worked out that this is just the
API that module authors should use and
so like just use that and everything's
fine
of course that was like node 0.12 so
that was Oh 2014 cool so that stuff's
been there for a while but ultimately
this is just how all the node modules
will declare their external code how am
i doing for time
I've got about five minutes here any
other thoughts Jason you look so that
would be the bright r8 project so right
ray is the so this is still C++ code
holding hosting chromium if you wanted
to do that stuff yourself this is the
project that I'd use there is an example
project here imagine that we call bright
ray example so this is a little demo app
that we've done to show about the
hosting site yeah I reckon if you want
to understand how briar I could be used
I'd have a look at that one I think it's
still C++ but yeah that's that's the big
we we mostly do C++ stuff because we
know it's going to be cross-platform
with a little bit of compilation magic
of course
all right yeah well I'm gonna hang
around some people on hit me up for
stickers after come say hi otherwise
yeah thank you for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>