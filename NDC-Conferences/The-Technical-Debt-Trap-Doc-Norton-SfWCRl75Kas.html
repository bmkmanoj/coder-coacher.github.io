<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Technical Debt Trap - Doc Norton | Coder Coacher - Coaching Coders</title><meta content="The Technical Debt Trap - Doc Norton - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>The Technical Debt Trap - Doc Norton</b></h2><h5 class="post__date">2016-09-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SfWCRl75Kas" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right
not exactly standing room only it is
lunchtime is it not all right well thank
you for coming this talk is the
technical debt trap throughout this I'm
going to ask a few questions of the
audience and I am looking for some some
exchange just a little bit of question
and answer type stuff so you know just
as a warning right for those of you that
don't know me I am doc Norton I'm the
co-founder and CEO of a consultancy
called CTO - we do process and
leadership coaching for companies mostly
in the US but certainly around the world
this talk is technical debt you can use
that hashtag if you want of course we're
at NDC Sydney and I am doc on dev and
I'm doc on dev everywhere just all the
things whack doc on dev I got lucky
enough to get almost all of them and the
ones I don't have don't matter right so
I said I was going to look for some
interaction with the audience and I'm
gonna start off with that first thing I
want to know from from folks here what
is technical debt when you think about
that what is your definition right and
we have anything that comes to mind for
them unsupported code code that's no
longer fit for purpose any others
things you should have done but didn't
and then kind of deferred and five years
later you still haven't done it and yeah
yeah so how many of you know where the
actual phrase technical debt came from
who coined that phrase Ward Cunningham
he did yes
so what Ward tells us by the way if you
don't know who Ward is go study that now
all of the things that you know and need
to know trace back toward right
basically everything we do today didn't
exist until Ward came along but
technical debt in 1992 at upsala Ward
published a white paper and in that
paper he was talking about his
experience with a client and some
interactions that he had with them and
he had told the client look shipping
first time code is it's like going into
debt right and a little debt actually
speeds development and as long as it's
properly paid back with a rewrite yeah
we're okay but the danger occurs when
the debt isn't repaid every minute we
spend on not quite right code counts as
interest on that debt now I've known
Ward for a few years now and one of the
things I find about Ward is that he's
very deliberate with his words but often
times it's a little subtle people miss
what it is that he's actually saying so
I want to zoom in on this particular set
of words this phrase that that Ward uses
right the danger occurs when the debts
not repaid it's just pointing out a
couple of words first of all he chooses
the word danger he doesn't say the
challenge the hurdle the concern he
actually uses the word danger danger in
my mind is fight-or-flight type of stuff
right this is something we should be
seriously concerned about not just you
know there's a problem here the other
thing is
he tells us every minute every minute
that we have this debt there is danger
so it's not every year or quarter or
release iteration every single minute
that we have this debt there is danger
and what is this debt it's code that's
not quite right not messy or shoddy or
sloppy or crappy or thrown together it's
code that's just a little off not quite
right and every minute we have that we
have danger but ultimately tactical debt
is good
why is that well with Ward's
definition technical debt is actually a
strategic decision right what we're
doing is we're making a decision to do
something with the implementation that
allows us to actually get code out
faster to get quick feedback from the
market and maybe to correct our design
to correct the implementation as we
learn so kind of talking about MVP type
stuff back in you know 1992 right
sometimes technical debt occurs as an
indication of learning so we didn't do
it on purpose but what happened was when
we released this thing to the public
when the customers actually interacted
with it
we then learned that we needed something
else right that our implementation
doesn't actually match what we now know
to be the requirements now technical
debt is actually just a metaphor right
in this case that's a metaphor for here
be danger and the reason that Ward
actually chose technical debt among any
other number of things that he could
have chosen was that customer he was
actually writing a why cash portfolio
management system so his customer was in
the financial sector and he chose
wording that they could relate to write
what they wanted to know was why is it
that your team is going back and working
on code that's already done and he was
explaining basically incremental and
iterative development and and the the
cost of having your code be out of sync
with your noun own requirements but he
chose technical debt because that's what
resonated with his particular customer
and I wonder often if Ward had been
working for a medical institution or if
he had been working for an arboretum or
something else if we'd have a better a
more rich metaphor where we could
actually talk about care and feeding
health etc versus debt right but
ultimately he chose this metaphor
because it actually made sense to his
customer and in that regard
metaphors absolutely rock right we
reason by analogy so if you and I are
talking about something
it's a domain that I understand but
perhaps you don't through metaphors I
can explain what it is that I mean I can
I'm talking about this particular
subject I take this replacement object
that we both know and I compare them
right and now we have something of a
shared understanding if I tell you that
code that doesn't quite match the
implementation is like having debt and
you're in the financial field in you
know the 80s and 90s and you understand
debt as a decision but typically a risk
that's a decent metaphor but sometimes
when we're dealing with metaphors what
happens is we almost forget entirely
about the actual subject and we continue
to debate the properties of the
replacement object as if that were the
real thing right and I call this
metaphor Phasis this is fundamentally
when metaphors go wrong
how many of you been in a conversation
where someone says something along the
lines of you know you want us to fix
this code and keep everything live in
production it's like you want us to
change the tires while we're driving the
car down the road and ten minutes later
you're actually arguing about the
possibility of a tow truck that can lift
the car off the ground and maintain
speed and right you're talking about
something completely different from what
was the actual subject write this in my
opinion is what happened with technical
debt it underwent metaphor Phasis people
heard the phrase didn't know exactly
what was meant by it but went oh well I
know what debt is let me explain to you
therefore what technical debt is and
over time we started talking about
things like short term debt and long
term debt and high risk and low risk and
loan sharks and fraudulence and you know
the inadvertent reckless debt in the
third quadrant which in fact is a thing
we will look at a little bit here right
and this became so common in the
industry that our leaders started to
refer to technical debt in the same way
in this in this quick and dirty cutting
corners hacking it in sloppy right and
eventually this led to arguments about
what is or isn't debt etc and Martin
Fowler came out with the technical debt
quadrant how many are familiar with the
technical debt quadrant all right we got
one so we'll walk through it fairly
quickly and fundamentally Fowler's
argument was look these discussions
about what is or isn't debt aren't
valuable what we should be talking about
is where did it come from and how do we
remediated right so he introduced the
the quadrant and in this quadrant he
says debt basically is either the result
of prudent behavior or reckless behavior
right
so either we are behaving professionally
we're behaving well or we're behaving
unprofessionally and we may be doing
that deliberately or inadvertently right
so we may get debt on purpose we prudent
and deliberate we actually made a
decision to go with the lessor
implementation right so yeah actually
let's walk through this so inadvertent
and reckless would be things like you
don't know about good architecture right
don't know know about good design so you
you actually aren't sure what it is that
you're doing right deliberate and
reckless on the other hand is you've
you've intentionally decided to skip
good practices right so we don't have
time for design or whatever that might
be right
prudent inadvertent and this one
actually was difficult for me to
understand it for a while because ice
thinking like how can you be
accidentally prudent but that's not
really what this means what this means
is that we behaved
and later discovered that we had debt
right so you know we we wrote good code
we tested it while we put it out there
and then we came to learn that that's
not what the what the actual business
needed that's not what our customers
needed and according to Fowler prudent
and deliberate is shipping now in
dealing with consequences right so he
kind of tries to break it down into like
oh there's different types of debt
there's this stuff that's prudent
there's this stuff this reckless and
deliberate and inadvertent and so he's
actually advocating for this this
expansion if you will of the technical
debt metaphor which kind of already
happened in our industry so now years
later it's 2009 and Ward kind of raises
his head back up and looks around and
goes what the hell have you done to my
metaphor this awful lot of you were
explaining this metaphor and confusing
with the idea that you could write code
poorly with the intent of you know
cleaning it up later doing a better job
later you have confused the debt
metaphor with the idea that you could
write code poorly but the ability to pay
back debt depends on you writing code
that is clean enough that you can
refactor it as you come to understand
the requirements clean enough to be able
to refactor so what is to refactor code
what's refactoring moving code around
okay any other simplifying when we are
refactoring code are we changing the
behavior a typical classic definition of
refactoring we are changing the
implementation without changing the
behavior right so I might extract a new
method I might in fact create an entire
new class but from the actual behavior
from from a user experience etc nothing
has changed I have manipulated the
internal functioning functionality of
this code
this class of this method but it still
behaves exactly the same still produces
the exact same output how would I know
having made a change to the code it
still behaves exactly the same how could
I guarantee that I would have tests yes
I would have tests so interestingly
enough what's happened with this
metaphor over time is it has come to
mean any kind of code that we don't want
to have to deal with it it has come to
mean crappy code but when it actually
meant was clean well composed code the
original definition of technical debt
clean code is a prerequisite for
technical debt you have to have clean
code and you have to have test coverage
in order for you to have technical debt
so his last kind of statement on this on
Twitter he said look dedi dirty code is
too technical debt is a pawnbrokers to
financial debt you guys want to go with
this metaphor great let's go with it
don't think you're ever gonna get your
code back so the questions still in my
mind is do we or do we not have
technical debt right how do we know that
we've got technical debt versus
something else so I've got a bit of a
heuristic that I kind of used to say yes
it is or is not technical debt right one
is the code clean is it tested is there
a learning objective or event so did we
do this thing on purpose we did not
implement you know the ability to bundle
things in the cart because we wanted to
learn if people are even going to buy
these items right or was there an event
we implemented it this way and then
learned later that the market actually
didn't care for that particular
implementation right is there a pant a
plan for payback and when I say a plan
for payback I don't mean like well
someday
get around to it maybe kind of sorta I
mean have we actually talked about okay
there was this learning event and now
we've actually learned this here's what
we're going to do and when we think it's
going to happen in terms of priority of
all of our other work and is the
business truly informed this is a very
difficult one oftentimes developers like
yeah the business is informed because I
told him if we keep doing this it's
gonna be really bad and I mean do they
really understand what it is that's
going on were they a part of the actual
decision if you look at this list and
you can say no to even one of them then
you don't actually have technical debt
so what then do you suppose you have you
got a mess right this isn't a bad just
this isn't a bad definition for what we
have right disorderly accumulation state
of embarrassing confusion right but I
found a better one cruft it's an
unpleasant substance is the result of
shoddy construction or according to the
dictionary it is redundant old or
improperly written code so cruft
is actually the proper definition of
much of what we actually call technical
debt these days right now I've given
this talk a number of times I've had
people who say to me well look that's
that's all that's all well and good doc
like you know I hear you you have an
opinion but really it's just a matter of
semantics right I don't think it is it's
not just semantics and here's the reason
if we agree that technical debt is good
and we also agree that quick-and-dirty
is technical debt by the transitive
property of technical debt
quick-and-dirty is good and I cannot
abide by that right I've never seen a
project that was done quick and dirty
and actually sustained at some point we
had to call for the grand rewrite at
some point we got ourselves into you
know serious trouble with this thing
right I want to go back for a second
here to this technical debt quadrant cuz
it was something that yeah
it couldn't be so the question was at
you know he said yeah I said at some
point we go through a rewrite isn't that
a good thing it could be right but I've
also seen systems where an app's an
actual complete overhaul rewrite it's
never necessary right that we're able to
iterate on that design over time and
able to actually you know extend it flex
it retire pieces of it and at no point
and we have to actually freeze code and
go for parity match to completely
rewrite the thing because it became too
arduous to actually you know work on the
existing code base so I want to go like
this technical debt quadrant because it
the when it came out so there was two
thousand nine that Fowler actually wrote
that that article and was interesting
I'm not gonna pretend by any means that
I had a whole lot to do with any of this
crap but I had recently written an
article that messy code is not technical
debt shortly after that Uncle Bob wrote
a very similar article and shortly after
that Fowler
came out with the technical debt
quadrant and shortly after that
word came out and said shut the hell up
this is what I meant but when father
came up with a quadrant I was actually
sitting next to him at thought works and
when we talked about it for a little
while and it it bothered me from the
very beginning but back then I couldn't
articulate what it was about it that it
just didn't set right so over time I've
kind of figured out a few of these
things one the prudent and deliberate
right
we must ship now and deal with
consequences that actually doesn't sound
prudent to me it certainly sounds
deliberate but it doesn't sound prudent
and I would much prefer that it actually
said let's deploy and gather more
information right that sounds more like
prudent deliberate behavior to me but
that's a minor thing what really
bothered me about this was the second
half kind of the reckless half of the
quadrant it just didn't set well with me
and it took me a while to figure out
why and the way that I figured it out
was I started thinking about okay let's
take this metaphor let's take this
concept and let's look at it in other
industries in other fields and does it
still make sense so technical debt in
some other fields construction can you
imagine if you paid two hundred fifty
three and a thousand dollars for this
thing to be built and the general
contractor says to you well you know
what we encourage some structural debt
in order to meet your deadline right we
should probably discuss that debt and
set a plan for paying it back in the
future
automotive right
we occurred mechanical debt to stay in
budget medical well we incurred some
health debt along the way right you see
it's like we paid for the surgery with a
credit card instead of a home equity
loan right when we look at this in other
fields it it doesn't resonate the same
way it doesn't it doesn't make sense you
might say oh well that's because they're
there you know these are it's the
physical world versus the digital world
I think there's more to it than that so
if we look at these things the two on
your right
those are reckless and deliberate
behaviors right in both cases you know
maybe the building settled but I've
looked that photo and over and over and
over again and there are not stress
marks in any of the bricks they put the
damn windows in crooked right and
clearly the vehicle you know that wasn't
they finished it and went woops they
knew they were doing that right so
that's reckless and deliberate work and
we're gonna give the one on the left to
the benefit of the doubt and we're gonna
say that that's reckless and inadvertent
right they didn't mean to do it but it's
still not good stuff
so let's map that back to our quadrant
that's what those are right reckless
deliberate reckless an inadvertent are
there other names for that kind of
behavior what else could we call that in
my opinion
we're talking about irresponsible
behavior and incompetence so we're on
that we're on the reckless end we're
talking about irresponsible and
incompetent behavior and wrapping that
in the warmth of the technical debt
metaphor is a pretty risky thing to do
this
prudent behavior actually is the only
behavior that results in true technical
debt so it's kind of heavy right let's
lighten it up a little bit let's play a
game who wants to play again all right
so the game is called crofter debt all
right so we're gonna go through three
rounds they will get progressively
harder and all I need from you is to
tell me if the code example is cruft
or debt ready for round one does that
cruft or is that debt
that's got to be Croft right you don't
have to be a programmer and you know
that something's wrong with this so
let's take a look at it and we'll go
through this fairly quickly first of all
let's just collapse all those Curly's
down so we can actually read it there so
now it's so much better right all right
so basically what we're doing is is
there that we're iterating through like
every freaking table and every column
and every row and every like that
stuff's unnecessary right so let's
assume that we don't have multiple
tables in the data set let's assume we
don't to actually iterate through all
those columns right and that we know
that we're looking for if if you read
through this we're looking for an agent
ID and we're looking for a queue name so
let's just eliminate all of that
overhead and pretend that we actually
know how to interact with the database
so it gets a little bit better right and
now what I'm gonna do I'm not gonna show
you the code for this but we're gonna
we're gonna actually just introduce some
abstractions I'm gonna create some
classes that receive data sets and
return collections of objects basically
what I'm doing is I'm gonna introduce an
ORM which any one of us would would
typically use these days right or or or
we wouldn't right but I'm gonna I'm
gonna get rid of some of this stuff
right okay so now it's getting better
like we're actually going to the point
where we almost can read this and figure
out what the hell it is that it's doing
and if we actually go through this it
looks as if what we're doing is we're
looking at this agent and we're
determining if it actually has these
skills recorded in a particular table if
if so then we're actually calling this
set agent Q skill and we're returning
back this record set that fundamentally
says here's all of the skills that this
agent has right so this code shouldn't
even exist this should be a view in the
database you shouldn't have to do any of
this
so all of that was completely
unnecessary code didn't need to exist at
all you could have done all of that with
you know basically two lines of code a
simple join in the database itself all
right so the next one cruft are dead so
round two what do you think on this one
cruft do I have any debtors cruft why is
that feels feels like it's crop D yeah
yeah so here's the thing about this
right if we look at this we have no idea
what class this is in we don't have any
idea what method this is in right so it
might be a little bit difficult to say
what exactly is it that this is doing
and I can read this I can see that I'm
looking to see if the customers state is
Alabama if their type is a general agent
if they've got a revenue over a hundred
thousand dollars right I can read all of
that
so it's readable but I have no idea what
any of that means I don't know what this
code is actually doing right from a
business perspective I have no idea
lucky for us there is a universal fix
for that at a comment I now know what
this code does right fixed no longer no
longer cruft now if if we can do with
this right there's the another thing
about this we know that this code does
not in the customer class right and how
do we know that customer dot customer
dot customer customer dot right what are
we doing we're interrogating the snot
out of our customer we're asking it a
bunch of questions in order to make a
decision this seems a little overly
intimate all right there might be a
little bit of feature Envy going on here
there's something else
this probably belongs in the customer
class itself we can actually ask the
customer are you federally regulated and
it should know that and in moving it
into the customer my guess is that this
code would actually get much easier to
read with much B would be much cleaner
and that's actually I think what we want
to do with it right now easily readable
all right last one
last round bonus points anybody gets the
joke hidden in here
a little Monty Python for you right
so as this cruft or as this debt
it's hard to say isn't it that's
actually the answer the answer is it
depends right this comes down to a
matter of a strictly opinion right what
do we have here we've got a switch
statement with three options to it right
fundamentally this is a nested-if just
we've you know made it a switch so it
looks a little bit better so we have
relatively high cyclomatic complexity
for this particular method right that
may be a concern for us we may not want
that complexity in the code hi
cyclomatic complexity directly
correlates to hi bug count we know that
but the fix is you know polymorphism
right which means that we're now we've
got base classes we've got when we've
got you know inheritance et cetera et
cetera and leaving out some of the
details that fix looks a lot more like
this now I've got three different places
I have to go look to figure out how this
actually works etc so the point here
being at some point that case statement
whether it's 3 7 142 at some point that
case statement has too many options in
it for us to consider this to be a good
piece of code anymore and we need to fix
it using this technique right is that in
the first else is that in the second
else that depends on what your team
decides on what your team agrees on what
your organization agrees on right if you
listen to Uncle Bob then you should have
you know done it right away
right but that's not always practical
so cruft
it's a bad decision right one we're
professional developers this is what we
do right we get paid to do this and the
expectation is that we are professionals
and that we're doing it well
we get paid pretty well for what it is
that we do and you're gonna create
unintentional cruft you can't help it
it's unintentional right you will you
will come to realize six months from now
that the guy that wrote this code was a
complete idiot and then you'll realize
it was you right and you're gonna have
to clean up that existing cruft it's
gonna get in your way
so the trap becomes when we actually
start off writing crufty code because
what we've done is we've set a precedent
for speed over quality right we've cut a
few corners here and there to get
something out the door just a little bit
faster in the short term and we've set
this expectation that this is how fast
we can move and many of us work in
environments where you know we're agile
of some sort right we're agile ish and
what's one of the magic promises of
agility one of the reasons that
management wants the agile installed is
because they read a book and in that
book it said after three weeks your
velocity will go up it doesn't say how
but it says it'll happen so this is
expectation that we're going to be
getting faster as we get better as we
come together as a team right but the
cruft starts to slow us down so our only
option is to write more cruft in order
to keep up in order to meet those
expectations and eventually what happens
is we have to ask permission to do our
job correctly now I talked about this a
little bit earlier this tends to mask
itself right we tend this tends to be we
have to call for the grand rewrite well
you know Java eight blah blah blah blah
blah blah right it's usually we're kind
of blowing smoke the truth of the matter
is if we had done this well we could
upgrade a Java eight without any
problems but because it's poorly written
it's really hard so
it's just easier to redo the whole thing
right so how do we manage cruft well one
of the common things I see is a is
actually a failing strategy and that is
this idea of a cleaning sprint right now
how many of you work in organizations or
I've worked in organizations that do
this so we we go along for a while and
then we then we have a you know
hardening or whatever some period where
we're gonna like clean all the things
right so we actually scheduled an
iteration for cleaning up the code and
and what ends up happening is we're
deferring quality to the cleaning sprint
so we can move as fast as we want right
now and then we can clean it up you know
a little bit later right and we're
focused on speed velocity at all other
times well studies a little old but but
studies been done and what they found
was this so we got three lines on this
on this three colored lines on this
graph right the top one black is
basically an application with no
refactoring no cleaning and what we're
looking at is over time the actual cost
of change in the application so we can
see that over time it goes up right and
and they're showing like at nine years
it's right at this inflection point
we're around eleven years it just goes
straight up in the air right so we've
gotten to a point where it doesn't
matter how hard you try you basically
can't add any new features because the
code base is just too hard to deal with
the purple line is the cost of change
for organizations that do these cleaning
sprints so we can see that every once in
a while they actually go through and
they clean up the code right but the
rest of the time they're thundering
along at you know at a high pace there's
an interesting phenomena that I see in
these types of organizations at the end
of every single cleaning iteration at
the end of every single cleaning Sprint
what does the next sprint look like it
is at least 50% more loaded than it
should be because we just spent
two weeks four weeks delivering no value
in the businesses in a panic right so we
come right out of the gate cutting all
of the corners and what ends up
happening eventually is we just can't
keep up so then the green one is if
we're refactoring continuously and we
can see that eventually off in the
distance somewhere just because the code
base keeps getting larger and larger you
know it does get more expensive harder
to actually work on and the reason that
I actually point out that this is an old
study is this is in years so they're
basically showing that at like ten years
the code base will become hard you know
too difficult to deal with that's no
longer true today the rate of change is
accelerating the amount of the amount of
time to think about think about for
those who that are in the field for a
while right so I've been doing this for
thirty years there was a period where I
started on you know Java for whatever
right and I could write an entire
application and we could go a decade and
upgrade it once or twice whatever and
introduce no new technologies today
we're constantly changing we're
introducing new stuff right you're
thinking you're you're introducing a new
technique on the front end you're
introducing new tiers in the middle you
know it's the world that we're in is
much more complicated much more complex
and the rate of change is accelerating
so what's wrong with this graph is now
it's at about year four without any
refactorings that you get yourself into
the point where we can't make any more
changes sorry if that's a losing
strategy what's the winning strategy the
only one that I've actually found is to
just constantly clean right don't make
an intentional mess monitor your
technical debt and I'm using the air
quotes there because we're really
monitoring is our cruft but the entire
industry calls it technical debt follow
the Boy Scout role who knows what that
is the states every knows what it is
what is it yes leave the campground
tighter than you found it leave the
codebase
better than you found it right over time
that starts to add up so you go in you
do your thing you add the new feature
that add the new functionality you do
that well and while you're in there you
go hmm you know what I could abstract
this out or gee that variable names not
very clear maybe we shouldn't have these
magic numbers in here right just
something small but if all of us do that
over time the code base gets better and
what areas of the code base get better
the areas that we work in the most often
improve the most so our day to day lives
get easier right so you may have some
some area of the code that nobody ever
touches and it´s still crufty and nasty
and and a little bit scary that's fine
if no one's ever touching it right and
remember the quality is your
responsibility and don't ask permission
to do your job correctly right we as
developers need to stop abdicating our
responsibility to the business right the
business wanted me to do it faster
they're always going to ask you to do it
faster the expectation is that you are
going to behave professionally right I
want my plumber to cost less when he
comes in I want the job to be done
faster but I don't expect that the pipes
are gonna start leaking you know two
weeks later and he's gonna charge me
again or explained it was my fault
because I didn't give him enough time
right I expect him to be a professional
we are professionals this is what we
should be doing monitoring cruft how do
we do that
code coverage code complexity coupling
and maintainability so there are a
number of static analysis tools out
there for you know whatever platform
you're on right a couple of things I
would say monitor more than one more
than one metric I like coverage I like
measuring complexity
a complexity can be measured in number
different ways so there's their
cyclomatic complexity there's ABC
complexity at which basically are
they're similar it is weighted of
determining the number of logic branches
in your code and there's a direct
correlation between cyclomatic
complexity or ABC complexity and bug
count the folks at code climate they
have been running analysis against
literally thousands of code bases for
several years they started off in the
Ruby space and now do Java and
JavaScript and a number of different
things right so they have they have
analysis against millions and millions
and millions of lines of code across
hundreds of thousands of projects and I
was talking with their CEO a couple of
months ago and he said that they've
actually dropped cyclomatic complexity
and ABC complexity in exchange for lines
of code there's a direct correlation
between the number of lines of code you
have and the number of bugs you have in
the application and it's much faster to
count lines of code in that you know
than it is to actually run through an
entire mathematical calculation that
fundamentally doesn't tell you anything
other than lines of code right if you
think about it logically the more code
you have clearly the more bugs you have
so when he first told me this I laugh my
ass off because I was he said you know
well one of the metrics that we think is
really important is lines of code and I
said whoa what do you mean that's a
metric we dropped in the 70s because we
learned it wasn't a good idea but
there's it's that's how they actually
determine complexity coupling efferent
and afferent
but if you don't have that just the fact
that there's coupling in the application
right what's dependent on what what's
you know what are you dependent upon
what's dependent upon you
right and then maintainability how many
of you are in the dotnet space I think
this is a fairly dotnet heavy right so
they solve the maintainability index
right yeah so the maintainability index
is a single number that applies to the
code base that basically takes
a few different static analysis metrics
and aggregates them together and it
gives you a single number that says the
code is you know this maintainable on a
scale of like 0 to 99
I like combinations because if you look
at any one of these in isolation it can
be gamed right not that we as developers
would do that intentionally but any
metric creates a change in behavior
whether you want it to or not and I've
got a whole talk on that but what I
found is with coverage complexity and
coupling I challenge you to deliberately
game those metrics the only way you can
do it is to accidentally write better
code so that combination helps us write
but very important monitor the trends
not the points do not worry about do we
have 87 percent coverage and if we don't
fail the build right don't worry about
is the complexity at this exact number
or that exact number what you need to
concern yourself with is is it trending
in the direction that we expect is it
getting better is it staying the same is
it getting worse there are times when
you will make the decision that the
quality should go down we need to hit
this deadline we've got to get this done
we don't do this we don't get the 10
million we don't get the 10 million we
don't have jobs but monitoring those
trends and understanding it is going
down we expected it to go down it allows
us to also then have the conversation
about ok now it needs to go back up
right as long as it's training the way
you expect it to I think you're in
pretty good shape so I want to make sure
we have time for Question and Answer I
think we'll have about 15 minutes left
so I'm just gonna do a quick review here
right so technical debt it is a
strategic design decision it actually
requires the business to be informed and
it includes a payback plan cruft happens
it needs to be monitored and cleaned and
it is not technical debt in the last
point that I want to drive home never
ask permission to do your job correctly
thank you I'm in advance to slide one
more time just so you guys have this
then we can do we and we can do question
and answer so all right if you send an
email to CTO to at send your slides calm
with the subject line technical debt I
will auto reply with a version of this
talk as well as links to all of the
research behind this so the reports that
I showed links towards videos the OOP
slip paper etc etc etc so thoughts
questions feel free to call
so under slides before I think when when
you have the craft and you have like
coverage and so on it's on
isn't that means the craft becomes a
technical death because then you have
code coverage you have you actually be
able to refactor and pay that back ah so
so if if we have coverage then it
becomes technical debt right by the
actual definition yeah I suppose that I
suppose that could be true right if if
what we're dealing with is we have clean
code it is well covered and we just know
that we need to actually do some
refactoring or we need to make some
adjustments so that our implementation
matches our our known requirements yes
but you may have twenty seven percent
coverage right you might know that this
area of the code is in is in very bad
shape that it's actually crufty it may
turn out that from a business
perspective and strategically it doesn't
make any sense to change that right
oftentimes they see this where you go
into an organization and there's a
certain core core piece of the code that
just works it just does its job no one's
touched it in you know in ten years when
you get in there it's ugly and it's
scary and no one's really sure what
happens how it works or what it's doing
but as long as you want to touch it you
can leave it all right it's still cruft
but it's safe ish
we gotta go in the back too
thank you I've worked in a few
organizations where we've tried to do
the technical debt sprint yeah and what
I've observed is it never happens
teams get really invested in building
products and I will we'll just do one
more feature sperm we'll just do one
more feature sprint you know we'll do
the time that spring will do -
technically a sprint and what starts out
as team spending like a quarter of their
time all up paying down technical debt
or dealing with craft whatever it is
ends up being absolutely no time just
wondered if he had any kind of
observations on that so that's part of
the reason that so when I talk about
these the metrics right what I want us
to do with those is actually fold those
into conversations with the business so
we're looking at them in in sprint
reviews we're looking at them in
retrospectives we're posting them very
publicly within the team room if at all
possible right so they become a part of
the broader conversation what we really
what I really want is I want everyone
involved in the decision to incur this
debt or to generate this cruft right
having folks that are driving product
forward understand the the the effects
of these decisions the outcomes right so
if we can consistently see iteration
after iteration after iteration the code
quality is getting worse and worse and
worse it leave can ideally had leads to
a reasonable conversation the other
thing I look at is cycle times and lead
times and I've got another talk that's
just on metrics alone and sometimes an
organization will actually show them
look I've done these studies in other
organizations and what we are actually
finding is the higher the code coverage
the lower the cycle time in other words
clean code actually leads to faster
delivery
the problem is we're never making that
investment so we're not ever seeing that
return and ideally that leads to a you
know a better conversation about all
right let's start cleaning this up and
it's gonna take some time but you're
gonna actually see
you know better throughput in the long
run so yeah it's getting all of that
information in front of everyone
involved especially the business he had
one yeah I hear a lot of stuff around
chaos engineering where they sort of
like on the on the quadrant kind of
thing it's kind of intentional
engineering yeah are we talking about oh
come on
say it again okay ice monkey no well
this was more about that the fact that
they don't actually know the strike yet
sometimes we can get into a mindset
where we need to know the domain like I
might know the domain right in order to
structure our code efficiently well so I
I it's an interesting argument right so
the idea that that you know in order to
instructure to code well you need to
actually know the domain you know at a
very at a very deep level and I'm not
sure that's actually valid right so I'm
trying to think of the I'm trying to
think of the gentleman's name and I
can't and I really wish that I could but
to you is a company out of New York and
they are involved in education space
which is not really material here but
I'm just kind of trying to get synapse
to fire they have been building a micro
services ecosystem where anyone on the
team can build a very discreet service
and add it to the infrastructure and it
either does its job or it doesn't and it
either like gets used or it doesn't and
it's a very interesting approach right
so they have they have actually
absolutely no idea what this end thing
is going to look like but they're
writing code in teeny tiny discreet
you know functionality and then
basically releasing it into this
ecosystem but all of it is is well
composed well put together
I will admit though that they are not
doing any kind of unit testing because
the pieces are so small that it seems
you know that there's there isn't a
point to it right
this service itself is so tiny the
testing is does the ecosystem accept it
or not but I think if we are if we're
thinking about the the composition of
the code and you know we're designing it
well so that it is actually extensible
that it's malleable that we can easily
change it over time that's all kind of
part of this agility right but as we
learn we we can more easily move in a
particular direction so the idea of
emergent designs emergent architecture
all comes from this delivering small
pieces incrementally and I don't know is
we really need to know the whole picture
right we kind of learn as we go along
and and designing and delivering in this
way allows us to do that I was the lead
on the rewrite of Southwest comm and
there were many many times where that's
exactly what we did we were not sure
what this this thing was gonna look like
but we had some general idea and we just
did small pieces and kept moving along
and the advantages there were things
like new federal regulations came in and
we were able to respond to them very
very quickly because we had written it
in a very malleable way and because it
was well tested and all that so I don't
know if that actually addresses what
your
other thoughts well cool thank you
everybody I'm around if anybody wants to
chat more</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>