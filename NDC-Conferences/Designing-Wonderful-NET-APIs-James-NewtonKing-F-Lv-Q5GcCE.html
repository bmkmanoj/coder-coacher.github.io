<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Designing Wonderful .NET APIs - James Newton-King | Coder Coacher - Coaching Coders</title><meta content="Designing Wonderful .NET APIs - James Newton-King - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Designing Wonderful .NET APIs - James Newton-King</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/F-Lv-Q5GcCE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to wonderful dotnet API
design and to get started I'm just going
to talk about Who I am my name is James
Noonan King
I'm a donut developer from Wellington
New Zealand and these slides were
originally made for in DC Oslo I'm a
developer at a New Zealand company
called antigen if your Institute
interested in working in New Zealand you
could come work for us but what I'm best
known for is Jason Don is aka the
library that forced you to learn what
binding redirect is and today I'm going
to be talking about Donette API design
and I'm gonna be talking about lessons
I've learned both from my day-to-day job
working on products and websites and
also Jason Donette so to get started
what is don''t API design well what is
it don't need API first don't need API
is types so its classes it strikes at
interfaces
it's the properties that you put on most
types its methods its constructors its
events I don't know a dotnet API is the
public boundary between your internal
implementation and what a user sees when
they consume your code so you can think
of it as a user interface it's a
difference between asking someone to
make toast with a toaster or giving them
the internals of a toaster and asking
them to make so this one will lead them
to success the other will probably burn
the house down and electrocute them so
the goal worth don''t API design is to
create an API that communicates with
developers if you could stand over the
shoulder of everyone who used your code
you wouldn't need to worry about Donnie
API design because if they did something
wrong if you just say hey that's not how
you do it you use this method rather
than that method so the aim is to create
don''t types and methods and short of ly
communicate with developers about how
they should be used so let's just
imagine an example we're talking to the
database someone's used single
connection and they have over met
connection they've created a command in
their return
something so they're successfully used
the a do not near API to do something
but there's a problem with this code and
the problem is they're opening a
connection but they're not closing a
connection the user might be
inexperienced with using sequel data
they don't know that this is something
they need to do so how do we communicate
with the developer that there are
resources that they need to clean up and
the answer is I disposable so I
disposable indicates there are unmanaged
resources that you need to handle
cleaning up by placing I disposable on
these types and these types do have i
disposable we indicate to the developer
via documentation and also maybe via
code analysis something like FX co-op or
resharper all say hey you're creating
this sequel connection
you're never cleaning it up you need to
do that for your program to succeed and
of course they see that they wrap it and
using statements and now they're
successfully cleaning up their
connection as an example of dotnet API
design and practice
why is API design important so I've just
seen a brief example as the difference
between happy developers and confused
and discouraged developers or wasting
time through trial and error if we
created an API that works that does
stuff they they get stuff done they're
achieving their tasks good API design
creates productive and happy users API
design is important because API is good
api's are forever so you might have
heard about URL design and there's some
things which make good URL versus a bad
URL one of the things people talk about
is cool URLs don't change if you have a
website and you've got a login page from
that website and you sent perhaps in an
email to all your customers with the
links to that login page two years later
they would expect to be able to come to
that email click on that link and go
directly to the login page if you send
them to a 404 that's not a good
experience
likewise if people are using your donate
framework your library whatever and you
update to a new version and suddenly
everything
greg's that's not a good experience for
them so ideally like obviously you can't
do this all the time but ideally I
shouldn't break and putting some design
effort upfront can help reduce the
amount of breakages that you'll put upon
them there's sort of a gradient of how
easy it is to break an API if you're
using something within a project say for
example you're talking to a database and
you've got a user repository so the user
repository people can interact with
their bake the user repository will go
off to the database and return a
strongly typed object if you're using
that within your project you're both
creating your API and you're consuming
it it's quite easy for you to break it
because you're fixing it at the same
time now if you're taking your user
repository and maybe you're putting it
on nougat for other people to consume or
some other way of distributing your
library suddenly things are a bit harder
you're breaking it but other people are
responsible for fixing it so in that
case avoiding breakages and keeping your
API stable becomes more important it
becomes even more important when you're
new yet library isn't isn't not just out
there but it's also become a dependency
for other libraries now if you break it
the user is in a position where they
can't they can't fix the nougat library
that was subpoena upon your library to
fix it themselves they need to wait on
someone else so they have to just not
update to your new version so the older
mental ultimate example of this
situation is me so Newton soft are Jason
this is a graphic that was put together
by someone on my nougat team and at the
bottom of every single NuGet package
hierarchy Jason Don it exists now if I
introduce a sudden break and change and
Jason Don it I can just knock the bottom
card out of that entire stack and
everything falls over to give you an
idea of scale
Jason Don editors depended upon by about
10,000 other new gear libraries if I
introduce a breaking change that's
10,000 new get libraries that need to be
updated before people can successfully
use it again
it's important to think about when
you're designing an API every piece of
code that uses it is a further
investment on that it's enhancing the
value of that API and you don't want to
destroy that value by introducing
unnecessary breaking changes so API
design is also important because
everyone is an API designer so obviously
the team at Microsoft at the dhaniya
framework when medizone your base class
library the API designers the asp.net
team when they're designing asp.net core
their API designers when I'm designing
jacent on it I'm an API designer but
every developer is creating code that
other developers are consuming or that
they're using but they're using it in
multiple places they're reusing it so
it's important to put thought into this
so you create the most easy to use
library for your fellow developers you
keep them happy there they are confident
and using your code when you say hey
here's this user repository via
confident that it's well-designed and
that they can get up and running with it
quickly and it's not some awful thing
that a junior graduate developer put
together and they need to completely
remake so what makes a good API so the
first thing that makes it makes a good
API is it's easy to learn so an easy to
learn API is consistent with the
platform that it's on so it follows and
the case of Donaire it follows the donut
naming centers it uses similar
terminology as the dotnet framework so
if Oracle is introducing a new way of
well F Oracle's writing an Oracle
connection object they call it Oracle
connection they don't call it oracle DB
pipe for words only they use similar
terminology also a good API it should be
consistent with itself so if you have a
user class and it has is disabled and
then you have a subscription class which
has is disabled
and then something else which has
enabled that's confusing for people you
want to try and try and strive to be
consistent you want to strive to
minimize the number of logical concepts
that new users of an API need to worry
about also an API should be easy to use
so it should be well named
you should try and use strong typing as
much as possible and tele sense is a
fantastic way for people to explore an
API and discover what is on it
conversely an API should be hard to
misuse so if a user does something wrong
you should tell them straight away you
shouldn't sit on an error or hide it
away and when you give them an error so
if you throw an exception you give an a
descriptive excrete descriptive
expression exception you tell them what
we've done wrong so they can then fix it
themselves so a couple of years ago I
needed to implement this program which
use XSLT - so the dotnet framework the
XML library supports XSLT one but
version two I needed to go off and find
this Java port to do the same task and
as soon as I started working with it
I knew I was in a lot of trouble so the
naming was slightly off so this is a
fairly faithful port of the Java library
that the naming it fired
Java's naming standards used constant
strings and set of enumerations Java
supports enumerations now but back when
they port of its library it doesn't so I
needed to look at what these strings
were where to find them
they had copied it and cross this custom
file adapter way of working with files
rather than reused the don''t stream way
of doing it so I need to learn about
that and just little stuff like you use
getters and setters instead of
properties I mean other stuff which you
can't see in this code example so there
was no intellisense documentation
because they hadn't ported over the Java
Docs
and I used its own custom configuration
files so I need to learn that so
obviously as soon as I say I working
with us my immediate reaction was oh god
I hate this please let me find something
else but unfortunately I had to use this
thing as much as I hated it so also when
you have an API you want to encourage
code that consumes it to be easy to
understand and then maintain so this is
a slightly advanced topic but an example
that I've come across back when I first
started working with dotnet is in
hibernate so in hibernate that's another
copy from Java
so in hibernated say object relational
mapper so I'll map database tables to
donate classes and you need to map
between the two of those in the way in
hibernate did it at least some initial
versions as it had an XML mapping file
so here you can see we've got a class
and we're mapping it to a table we're
mapping or properties and we've defined
an ID there are a couple of problems
with this first is as verbose so we're
forcing people to have a database table
in a c-sharp class then a mapping file
that sort of duplicates everything in
between it's also brittle so if we come
along and change our c-sharp class later
our application is going to break
because it no longer matches up what's
on this mapping file so a better way of
doing it in my opinion is you could use
attributes so you could take your c shop
class that you've already got you put
attributes on it and the case that a map
store table that this column is an ID
this is a property and then using
reflection it's able to infer the name
of the database table or my database
columns so we've just straight away
we've reduced the amount of typing by a
third or reduce the chance that people
can introduce an error and also there
are other benefits like by having this
information in one place if some other
developer who's not familiar with in
hibernate
comes along with future we may see the C
sharp file it's immediately obvious them
that if they introduce a new property
they need to put an attribute on that
property meanwhile if we look at our
mapping file that's sitting off in a
completely different directory people
don't know about it until probably they
run their application up and either the
new property isn't populated or they get
an error so an API should also be
sufficiently powerful to meet
requirements so obviously your API needs
to do what you want it to do if you've
got a user repository it can actually
get users from the database but API
design is quite often a balance it's a
balance between conflicting alternatives
of simplicity and power so it's a bit of
a challenge to create a library that's
powerful enough to meet the broad to
meet the needs of a broad range of
developers but also still keep it simple
for that generalized use case and we
imagine if we've got a pocketknife we
can go absolutely crazy introducing more
features to it we can add a nail file we
can add a magnifying glass we can add a
pair of scissors but our pocketknife can
no longer fit in our pocket so it's
important not ruined simplicity by being
overly powerful and if you do want that
power hide it away I keep your like a
and easy to use primary user face and
then hide their power where people who
need it can access it a good API can
also evolve so we talked earlier about
we don't to break things when we
possibly can avoid it so good API will
allow bugs be fixed and features to be
added without breaking existing users so
an example of this as the dotnet
framework so we don't need framework
it's about 15 years old now so since
don't net two or even even back to
dhaniya one
Microsoft has just been continually been
able to add new features and fix bugs
without introducing major breaking
changes obviously now at
cawww babe they put a line in the sand
and they said we can we can't evolve
this any further but 15 years that's a
pretty good run and now that they have
put in a breaking change we've had to
put an incredible amount of work with
knit standard which has just come out
and it's standard to to be able to allow
developers who have been investing and
missed previous Stoney inversion
previous donut framework version to move
their code across to donate core so yes
good good API so they can evolve and by
evolving you preserve the investment
that people have made in earth so I'm
going to talk about a couple of general
design principles when designing a
doughnut API now these are generalized
any language but we'll talk about them
in the context of Donette so I think one
of the most important ones is what's
known as a pit of success so the pit of
success was termed by a Microsoft
employee so it's up there I'll read
through it the pit of success and stark
contrast to a summit a peak or a journey
across a desert to find victory through
many trials and surprises we want our
customers to simply fall into winning
practices by using our platforms and
frameworks to the extent that we make it
easy to get into trouble we fail so when
you're designing a framework when you're
designing an API you don't want to force
users have to trek across a huge
mountain so then figuring out incredibly
complex configuration or processes you
don't want your users to have to trek
across a desert write tons of bought
boilerplate code like that in hibernate
mapping file we saw earlier or maybe
wade through swabs of documentation to
find the right method instead what we
want is we want users to just be able to
simply fall into a pet of success it's
easy to fall into a pet we want to make
it easy for our users to be successful
so our goal when designing dhania api's
is to make it easy to succeed and make
it hard to fail that's the idea of the
pit of success so another general
principle is the wall of complexity
so the wall of complexity is the idea
that you should your API should offer
developers a steadily a steady CRO
should offer developers a steady slope
of increasing difficulty as their needs
become more complex so if you offer like
a sudden jump in the difficulty and
using your API just so perform a minor
additional task that's an indication
that you've got a wall of complexity so
I'll give an example of that who has
used web forms or still using wave forms
there's a lot of people so I used wave
forms a lot so the idea behind web forms
that Microsoft came out worth many years
ago is we want to make web development
really simple we want to make it as
simple was developing a VBS except and
just our developers they won't even need
to worry about the fact that we were on
the web it will just be as far as
they're concerned they're making AV b6f
but it's sitting in the cloud and they
did this by hiding a huge amount of
complexity behind web forms like a huge
amount of thought within two web forms
and it's a fascinating technology but
the idea was our users should be able to
see at what you see is what you get HTML
editor within visual CEO there should be
a tool box with controls and our users
should be able to drag a text box onto a
web page and they should be able to drag
a button on the web page and they double
click that button and now they're on the
code behind and there's an event handler
and they just type the code for handling
the event in there and as far as they're
concerned HTTP and post spec sets or
stuff it doesn't really exist
the problem with web forms as as soon as
you had a moderately complex task so for
me that moderately complex task was I
have a repeating list of dropdowns that
I'm data binding so I want to post back
to that page and I want to have the new
values that I selected be populated in
most dropdowns now as soon as I try to
do this I'd fail and that's because
suddenly you need to worry about all of
this
you need to worry about the web forms
page lifecycle you need to think about
when initialization is happening when
viewstate starts being tracked when data
bind happens when unload happens when
the form values are applied to the web
forms web page you need to worry about
all this stuff just so that you can get
your drop down to buy in correctly so
this is an example of the wall of
complex so you want to try and avoid
this so a library which does avoid this
and does a better in my opinion is
asp.net MVC so the successor for web
forms so MVC it requires a bit more
knowledge from the developer it assumes
that you're going to know how to do HTML
it assumes that you know a bit about
HTTP and URLs but beyond that if you
start doing more complex things the
slope of difficulty is relatively
steadily increasing so if you need to
start worried about custom routing and
having pretty routes you go off and
learn about routes and you can introduce
that into your app if you need to worry
about maybe returning JSON rather than
HTML you can learn about action results
if you want to think about authorization
now you just start putting authorization
attributes on your on your controllers
and actions the slope of difficulty is
steadily increasing there's no sudden
huge monumental jump like there is and
web forms and of course there's the
anti-pattern or putting all the
complexity upfront so an example of that
entity pattern with them the dotnet
ecosystem as WCF so I don't know about
you but whenever I work with WC if I
could I just don't know how to do about
configuration often told my head I'll go
off to maybe Stack Overflow or the last
project they use WCF worth I'll copy and
paste the configuration and and I'll
sort of try and cross my fingers and
hope that it all works so WCF assumes
just to do a simplest thing just to get
a like a simple post
Dora sample gate using basic soap with
north indication even that requires a
huge amount of knowledge about um
addresses and contracts and bindings so
of course WCF the the f sense of fail
windows communication fail so the last
general principle we'll talk about is
the power of sameness so the power of
sameness this is another one from a
Microsoft employee and the idea behind
the power of sameness is by creating an
API that by creating API is that use
features that developers already know
developers can get up and running faster
than having to learn new features so a
real-world example of this when you sit
down to drive in your car or you're
getting into a new car like do you need
to read a manual about how the door
works like locking and unlocking like
every car it's pretty much exactly the
same like there's probably exceptions
but 99% of cars the way the doors work
locking unlocking it's just exactly the
same you don't really need to read a
manual when you rent a new car so this
is the power of sameness by reusing
existing concepts by making our locks
and work the same as other cars locks
we're not introducing a new concept that
people need to learn and we're able to
get them going faster we can play the
same thing to add donate api's so we
want to do things like we want to use
features from our framework in this case
dotnet we want to use its naming
standard we want to use its interfaces
like I disposable to indicate the vero
resources we want to clear up clean up
if you need to use configuration we want
to use web config if or a speed on it
korkin fig if you're using that so the
more that you keep somewhere the faster
people are able to master your api the
list new concepts you're making them
learn
okay so jumping into getting started
with creating an API so when you start I
recommend you start small and focus on a
solid foundation so for a couple of
reasons why you want to start small and
focus on a solid foundation so the first
one is like generally incremental
improvement is better than delay
perfection and the reason that's a bit
of a delay perfection is why starting
small and getting something out there
you're getting your users using your
library you're starting to get feedback
about what they like what works what
doesn't
now if you focus instead on a big bang
like in one year I will introduce a new
thing which does a speech you complete
the problem is your idea of perfection
might not match up with what a user's
idea of perfection is so by
incrementally improving your getting
that feedback quicker and you're able to
implement that feedback into your app as
you're making it so by starting small
you're also giving yourself with freedom
to do things right
by doing this little as possible at the
beginning and then when you no more do
it better so obviously you want to
listen to user feedback in my experience
of JSON Deneb is a bit of an art as a
maintainer of jacent on it there's a bit
of an art of listening to user feedback
and deciphering what they ask for versus
what they mean so let's just imagine we
have our list API with some names on it
and we have a sort on it so by default
this sort alphabetically so users will
quite often we may have a problem they
all suggest a very specific solution to
their problem so say for example where
someone out there alphabetical sorting
doesn't work for them and instead they
want to sort by whoever has the most
valves in their name goes first or the
most litter II some crazy user sort what
they'll do is they'll say you've got
their sort method I want a crazy user
sort method it's always exactly my
problem so as someone who's building the
API it's your job to take
user feedback and try and generalize it
so it fixes not just their problem but
everyone's problem well everyone who has
this issue with doing customized sorting
so what we're saying is rather than I
need a method which does exactly what
they want is I have a need to be able to
extend sorting to plug in my own
functionality so in this case we would
introduce a delegate which takes two
parameters and they can plug in their
own sorting functionality and they can
go crazy
so that handles not just the 99% use
case of people doing alphabetical
sorting but all those different 1%
people they now have the freedom the
ability to plug in their own sorting
functionality so an example of that
within json dotnet quite often when we
serialize an object from c-sharp to
jason c-sharp tends to use pascal case
with properties JavaScript people tend
to prefer a camel case with properties
people would always ask hey I want the
ability to do camel case can you
introduce a camel case equals true
Ã§etin and that would just so exactly
what I want instead I saw gradually
introduced things first I introduced the
ability for the customization of any
property name where an attribute and
then later once I was more confident I
introduced a contract resolver which
could change all properties to be camel
case so expects make mistakes so in your
initial release you're really just
guessing what a user want once like it
might be an educated guess you might
have a pretty good idea but like you're
just like hoping that this does the
thing that they want to have happen so
again starting small and releasing early
means you give that feedback as quickly
as possible
so there are always cases when yes you
do legitimately make a mistake and you
have stuff that you want to remove like
it's completely broken people shouldn't
be using this how do you handle that
situation so what I do with JSON Donette
is if I have an API that I no longer
want people to use or market with the
obsolete attribute so obsolete attribute
is natural you becomes Werth's done it
and you place it on a class or a method
and you can give an optional message and
when people compile their code and
they're referencing those obsoletes
methods or properties or classes Visual
Studio will give them a warning and it
will give the message that you put a
meta attribute to the user so you can
say so the user hey this thing's
obsolete how about you use this thing
and said and then people will just
gradually move over to using that new
not obsolete API and then a year or two
later and once I'm fairly confident then
people are no longer using it and then
at that point I remove it so that sort
of reduces that Big Bang of people
update jacent on it and then suddenly
everything's broken so don't be afraid
to say no so I've seen some people who
are very open source they're big open
source advocates since they're talking
about how to grow your open source
project and I'll say you should accept
every single pull request if you get a
pull request you should have that accept
button straight away that idea scares me
a bit there are some features and pull
requests that are just not a good idea
maybe like that the other person
probably has the best of intentions
they're doing something which solves
their problem and they think it will
solve other people's problems as a
domain expert of the API you might know
better you might know that hey if you
introduce this feature and your pull
requests performance for everyone else
is going to drop by 20% or by
introducing this new API into JSON
Donette it will prevent all these other
scenarios that I'm thinking about adding
in the future so although people are
suggesting features it's up to you to
exercise common sense and your knowledge
to say what will work and what is really
actually a bad idea and probably
shouldn't be done you're taking
responsibility of that and just be
cautious when people do suggest stuff
whether it's a good idea or not at the
end of the day you're responsible okay
so let's jump into some dotnet specific
recommendations so but don't need naming
guidelines generally I recommend
following all of them as closely as you
possibly can and the first couple we'll
talk about is pascal case parameters no
camelcase parameters pascal case
everything else it's actually quite
simple when you think about it so given
some code we've got some parameters
there
those are camel case everything else is
pascal case so you'll notice i didn't
talk about our private field so i I
happen to prefer prefixing them with an
underscore the fact that it's private it
doesn't really matter what you name it
it's not part of your API users don't
see it only you see it so within the
privacy of your own classes you can do
whatever you want but if you use
Hungarian notation
I'm not going to contribute to your
project I want to make a special shout
out about no shouting constants so this
is something which people coming from
Java tend to do with Annette we just use
Pascal case they're just properties so
we have string dot MD and Dom X value
add a time now we don't have strings
shouty md shouting max value shouting
now while I have this platform I want to
say to my coworker Ben Fox is a big
JavaScript developer I'm sick of seeing
your shouting Constance Maidana code
stop it so when you're naming your types
and your properties
avoid acronyms so acronyms can be
confusing for people who aren't familiar
with the acronym so some acronyms are
okay well knowin acronyms things like
HTML XML HTTP a few PS SSL FTP like
these are all well known acronyms and
you're probably thinking to yourself
what makes a well-known acronym there's
a simple test just
go to google put in the acronym ever
gets tens of thousands of results and
the front page is dominated by the
acronym chances are it's a well-known
Akram and you can use it if it isn't
like within New Zealand we have SAS and
GCSB those are spy agencies since you
guys are from Australia mostly you're
probably not familiar with them there's
maybe an example of a not well-known
acronym so yeah if it's well known use
that otherwise just don't try and save
keystrokes and just type out the entire
thing and don't abbreviate at all so we
live in a world of ideas with
auto-completion C sharp is a strongly
typed language we have four K jewel
monitors with enormous resolutions don't
abbreviate just to save some space or
just keystrokes we write code once we
read it maybe dozens of times so can
anyone tell me what this method does it
comes from C does anyone know what it
does so that method is multi byte string
to white character string so NBS multi
byte string to mean WCS white character
string so now that I told you you know
what it is but someone coming along to
this code or this method for very first
time they're going to be very confused
they're going to have no idea what's
going on they're going to need to look
up documentation they're going to need
to ask their coworker so abbreviations
and like it's you're just saving
keystrokes to introduce confusion and
then is just a whole bunch of other
naming guidelines stuff prefix and faces
with an eyetie parameters of a T you
might have noticed all exceptions in
with the word exception all streams in
with the word stream like always follow
these things that just as just the power
of sameness it produces a number of
things people need to learn when they're
looking at your api's
so interface some base abstract based
class design service interfaces and
abstract base classes are one sort of
the primary way of introducing
extensibility would to a donate API and
they're hard to get right so I'll just
talk about some common pitfalls you can
have when introducing interfaces and
abstract base classes so the first one
is too many methods or properties so I
don't know about you has anyone used
membership provider from donut to sew
some hands going up so membership
provider sort of provided a an abstract
base class for talking to any form of
membership like we're back in sort of
met it like it could be a sequel
database it could be Active Directory
and this is something the donut team
provided that asp.net team and it had a
huge number of abstract properties and
methods on it so this is resharper
saying hey if you want to implement this
class you need to generate all of these
different abstract methods and
properties now every time i've
implemented this class a type of
membership provider say for example i'm
giving it to some other library so I bet
other library knows how to talk to my
database I've only ever implemented two
proper methods on us so I validate user
and get user everything else I've been
leaving is not implemented exception
just because they're not being used so
if you're if you're hit with your solid
the iron solid is interface segregation
principle so this is an indication that
your your interface is doing too much
you want to you want to focus it down
and asp.net identity the asp.net team
they've reflected it from one enormous
abstract base class and to many smaller
ones so they've realized that this is a
problem effects
so another common pitfall worth
interfaces or abstract based class
design is creating one which is
impossible complex for someone else to
implement so you're probably asking what
what does that mean so the example I
think of is writing a link provider so a
link provider has a like it kind of has
a God method on it saying given an
arbitrarily complex query I met query
could have anything in it you can call
any method you can do aggregation within
it you can do skips and takes all kinds
of crazy stuff expecting people to be
able to implement that method it's
really hard like even Microsoft with the
in TV framework when they're converting
from our c-sharp expressions to sequel
like may a lot of scenarios they don't
care what probably most scenarios they
don't cover so that's an example of hey
maybe you're trying to get a person to
do too much so a link provider someone
just carefully suggesting hey just write
a link provider that's really tough ask
not saying that iqueryable is a bad
design maybe it's appropriate in this
case but if your interface or abstract
base class make similar requirements of
people just take a moment and think is
this a good idea so there are a couple
of tips to some help you avoid problems
when designing an interface or an
abstract base class so the first one is
you want to provide an implementation
and you want to provide consumers of
that implementation so by doing both
you're thinking about both sides you're
thinking both about both how someone
would implement it and how someone else
maybe it's just you will consume it
there's an example with them the donate
framework of where this didn't happen so
I cloneable so i cloneable was
introduced and on yet one and the idea
behind i cloneable the guy who thought
it up was hey let's just provide a
method that classes can implement and
I'll just create a clone of themselves I
I'm sure that's going to be useful and a
whole bunch of teams they went ahead and
make implemented I cloneable like the ad
on it team um you can try and clone like
a data table or a data set I believe the
other thing is as we may introduce Tonia
one no one actually used I cloneable
like there was no API with Annette
they said I take an AI cloneable when I
need to do Cloney things and because no
one had used it
no one was consuming it not a lot of
thought well not enough thought had been
put into how it should work and I
cloneable like it obviously takes a
clone of the object you pass on to it
but what about the objects therefore it
references say for example we've got a
customer object I mean our customer has
a collection of products on them if we
clone their customer are we also cloning
the products and that as an answer that
wasn't thought about when they designed
I cloneable and part of a reason was is
because no one was actually using AI
cloneable so now I have an interface
where we don't exactly know what it will
do will it clone just the top-level
object or look coin or all objects and
because of that and that lack of thought
for when into I cloneable when it was
designed
no one's ever used cyclone of all it's
just a didn't face as in interface
because people they just don't know how
it works in um the signs or enumerations
so enumerations are great for closed
small sets of choices so let's give an
example dev week it's seven days of a
week and it probably won't be an eighth
we're probably not going to introduce
friend day or schmooze day an example
that isn't a closed set might be windows
version so they're always going to be
new versions of Windows I've got Windows
10 now we've got a new service pack for
Windows 10 now of God creators edition
of Windows 10 the number of Windows
versions is constantly going to grow
that indicates that it's probably not a
good choice for enumeration if someone
does have Windows version as an
enumeration and a new version of Windows
has put out
like how do you indicate that it's a new
version until you update library like
you're kind of stuck like a better way
of representing Windows version might be
a version number method design so put
some thought into obviously the the name
of the method but also the name of its
parameters so this is important today
more than ever
obviously you have intellisense so we
can see down there we've got name we've
got URL we've got default we've got
constraints showing up in the
intellisense but now with named
arguments and c-sharp they also show up
in our code
so like renaming a parameter name has
always been a bit of a breaking change
because of reflection now it's real
breaking change because you can have
these named arguments and putting
thought into parameter names there's a
difference between someone having no
idea how to use a method and someone
getting it right the first time those
parameter names they can help them
succeed first time without having to go
look at documentation so prefer
enumeration over boolean parameters so
an enumeration enum perimeter with a
descriptive name is much much more
obvious and what it does than a boolean
parameter so here we've got string
equals like we've got a an action which
is a string we've got to get we're
comparing them like what what does that
true do is it saying ignore culture
it's like saying ignore case they're
saying ignore lead leading and trailing
whitespace like just reading my method
unless you know how strings are equals
works as an immediately obvious it's off
we then take that same code and we
replace it with an enumeration now it's
immediately obvious that we're ignoring
case if it's a little bit more work for
you as an API designer you need to
create a state enumeration that's been
passed in and you need to put some
documentation on us and you need to then
use it I guess it's a bit more work
compared to just taking a boolean I mean
to
whether it's true or not but like we
want to focus on making it readable and
usable rather than a few keystrokes when
we're writing it don't be afraid to
create helper methods so the goal of the
pet of success is to prevent users from
making mistakes and if we're making them
write lots of boilerplate code and
that's just more work for them it's more
work for them to consume your library
it's also more opportunity for them to
get things wrong so this code example
we're loading a J schema services from
JSON Donette it's a JSON schema from a
string so we've got a schema JSON string
we're wrapping in a stream reader string
reader within wrapping their string
reader in a JSON text reader we're
building a schema builder I've got a J
schema resolver when building a JSON
schema it's all boilerplate code we
could get rid of all of that we could
introduce a J's schema as method it does
exactly the same thing but we do it for
the developer and they don't have to
write a vet and after remember they
don't have to learn it we're just
helping them fall into a bit of a
success by providing one helper method
so designing properties properties
require a bit more thought than you
would think
so although internally properties are
really just a getter and a setter I
means metadata to indicate a very
property users don't have that
expectation developers don't have that
expectation developers expect a property
to behave like a field because it looks
like a field they expect it to behave
like a field so how does the field
behave the first one is a field as fast
if you're trying to get a value from it
it should be instantaneous imagine if we
had a DB context object and we've got a
a products property on it now a user
looking at that class so it would expect
properties to be fast because there's a
property products be fast because
there's a property but say if products
was loading the database
from the database every time you access
sir now we have got a four loop which is
accessing the database every single time
we're accessing it and if it takes a
second to get the properties from the
database the products from the database
then this loop might take seconds
minutes depending upon how big of a
collection is instead of having a
property for someone which is slow you
should have a method now if we change it
to a method and we look about same code
it starts to look a little dodgy like I
don't know about you but if I saw that
code I would probably rewrite it and my
initial impulse would be to take for a
result of that method put it on a local
variable and now use that variable so
what could have previously taken minutes
and ground the application to a hold now
it takes one second because we're
fetching the products once and we're
just using that and memory cache so
another aspect of fields as fields are
also consistent we may return a value so
your property should tend to want to be
consistent when they get a value if you
get a value and then a second later you
get another value from it property you
may be a little confused if it suddenly
changed so example gooood new good
I bet probably every time you call it it
returns a brand new good which is
randomly generated that isn't really
what a property is for if you've got
that situation you should probably just
change it onto a method and another
aspect we have with fields is there's no
such thing really as a field but you can
set a value on and you can't get a value
from like we have the opposite we have
read-only fields so and we also have
constant fields but a set only field
doesn't really exist and likewise you
should avoid a set on your property so
say for example we've got a user and he
has a password property on it and when
you set it we hash that value and store
save the hash value like obviously if we
added a gator to password like I would
return the hash value
you can't undo the Heche because as a
hash but like the users expectation is
when they see that properly on me user
class they're they're expecting both to
be able to set the value to it and get
the value from it and we're sort of
breaking user expectation and it's
always a good clue when you're breaking
the users expectation it's chances are
you're making something uninsured of and
you're making it harder for them so the
way around that is quite simple you just
change it to a set of property and now a
user it's immediately obvious to them
that you can set the password but
there's no way for you to then get the
password so constructor design so this
is about performance this one
constructors should be lazy
so the idea what the constructors is you
really want to defer the work until you
need to do it and generally that isn't
with them a constructor so let's come
back to another example
say for example we've got an XML file so
this is of like an abstraction over how
we load XML files from disk I doesn't
really do much all we're doing is I'm a
constructor we're giving it a path to a
file and then with them a constructor
we're loading that file from disk I mean
you can call get XML later and it's
returning that XML document the problem
with this is then a few maybe right
links Eamonn like this maybe their
directory has hundreds or thousands of
XML documents within it there's some
simple looking links a man is now
loading hundreds of files from disk it
could be killing performance and if then
we then only use one or two of those XML
file objects so you can get the XML from
them and we load it we're loading a
whole bunch of stuff from disk we're
doing a whole bunch of work that we
never really use it's of a way to fix
that is we've change it so that we load
when we need it we defer the work until
we actually need to do it so our
constructor is now just initializing the
path and when we call dot get Excel we
actually use the path to load the XML
document and we just cache it just so
that we don't need to load it multiple
times
so throwing exceptions this is a bit of
a passion of mine with Jason Donette I'm
of the opinion that failure is important
and specifically how you fail is
important so in my experience users
don't read documentation users they
learn through experimentation and
failure and if they can't experiment
their way out of a problem and they keep
getting failure then they'll go off to
stack overflow so the most common error
but people tend to get with Jason on it
is there's a mismatch between the type
that they're deserializing onto and the
value of a vide serializing so in this
case we've got a person object we have a
collection of hobbies the person's
trying to do serialize a string into a
collection that's not going to work like
the user thinks it's a collection
because it's got commas in it and then
like in their head they're thinking I've
got a collection of hobbies I'll be
sterilized so a list of strings but in
the end this will fail because there's
no way that Jason and Donna can reliably
you convert from one to the other and
the original version of Jason on it way
back when you used to get this kind of
error expected Jason or a contract got
JSON string contract which to a user
like to me is the guy who wrote Jason on
never like that makes sense I know
what's going on to a you person who's
using this library like they've been if
it isn't helpful there's something about
strings and something about arrays like
I I don't see any array in there I was
I've got a list but I'm got an array so
by far and away this was the most common
complaint the fix was to improve that
exception message I improved it to error
converting system that string to type
list of string which improved the amount
of support requests and number of people
asking you for help around this issue
but it didn't completely solve it so I
went further and I change it to this so
error converting value then I give them
the actual value to the type and then I
give them a path to that value so it's
the hobbyist property and then because
some JSON documents can be enormous
thousands of lines I gave them the line
number in the position so if you compare
those two exception messages one a users
not gonna have a clue what to do with it
and the other one tells them what they
did wrong and they're able to fix it in
themselves so also with throwing
exceptions as you want to fail fast so
don't let an object get into an invalid
state and then fail later you want to
fail when you get into that invalid
state when the user does something wrong
with your API you want to tell them as
soon as possible not sort of hide it
away and let it come out later where
it's like completely separated from
where the original coding bug was
introduced so this summation example
we've got a report service so our report
service takes some credentials so our
credentials in this case we're
accidentally passing a null if we then
at a later date want to validate want to
actually generate a report using a
customer and we do that and then at that
point we get a null reference error so
and you developers immediate impulses
just find the line where the error
happened within their code and I'll see
if it happen to generate report now
thank Oh silly me I've passed in an old
customer and to generate report the
customer's valid the problem was as they
passed a null credentials so what you
want to do when you're designing your
API is you want to fail as soon as
possible as soon as someone does
something wrong does something wrong you
want to tell them you don't want to wait
until a later date where the kids taking
is shopping cart full of muesli and
sweets up to a checkout and tell them
that we've done something wrong there
you want to tell them as soon as they
put it in no you can't have that okay so
designing for extensibility this is
actually quite complex so there's a
choice between having interfaces and
abstract base classes we as developers
we love interfaces interfaces are a pure
representation of exactly what we want
anyone can implement our interface
abstract base classes they're dirty like
you have to inherit from our class
maybe there's some yucky behavior that's
along for a ride there's a problem with
interfaces meds interfaces don't version
at all so there are some ways you can
get around this so if you have a user
service so v1 the red one over on the
left and you have a couple of methods on
it like you can't just go and introduce
the lis user onto it because everyone
who's implemented I user they don't have
they're not guaranteed to have a delete
user method on their on the interface
and if someone then tries to call delete
user on a method which doesn't have it
you'll get a miss missing method
exception so the way to get around this
as like you have I use a service and I
use a service to which implements I use
a service I use a service 3 which
implements the previous two and then
people at runtime can sort of
interrogate these type to discover
exactly watch what interface of
implements I mean sort of try and like
work out exactly the behavior at that
point I it's not simple to version an
interface the alternative is abstract
base classes now I've yet to actually
regret implementing something is an
abstract base class rather than and face
like I've regretted implementing an
interface because a later date I've
wanted to add something so it I've never
really regretted implementing an
abstract base class so something which I
chose to have as an abstract base class
and Jason Donaire is Jason convertor so
Jason bird is probably the most popular
way that people used to extend Jason on
it and I needed to add the ability to
have Jason convert of it was only used
for reading Jason and a Jason a bit of
it was only used for writing Jason now
because this is an abstract base class I
can just introduce virtual methods onto
it so in this case I introduced two
virtual properties and in this case they
just do nothing but return true because
the default behavior of all existing
Jason converters as they can both read
and write Jason but then if someone
wants to say this jes converter it only
reads
they can override Kenwright and they can
return false and set and then
materializer will look at Ken right it
will see false and we'll skip over it so
that's an example of abstract base
classes versioning and interfaces not so
much and finally we'll just talk about
this is like we're getting into my
opinion a little bit but I much prefer
composition over inheritance for
extensibility
so Jason serializer it's the main
probably the main most used class within
Jason Bohn it jason serializer is
incredibly customizable and composable
and extensible but if you actually look
at Jason's sterilizer there isn't a
single virtual method on it everything
is done by a configuration and
composition so if you start with a Jason
sterilizer but default behavior you can
plug in your own custom converters say
you want your in ohms as strings rather
than numbers you can plug in a camel
case contract resolver so you want your
properties camel cased you can pay plug
in a memory trace Rider so you want
trace messages written to a coming in
memories for you to look at default
serialization binder svet spool mapping
between type names and strings and type
names at runtime but by having
composition is allows people to easily
swap in and out behavior of they want
someone might want Java Script a
converter to convert Doni dates of
JavaScript dates someone else might want
them converted to ISO strings if we try
to do all of this worth inheritance you
look at all the different permutations
that you can see like it might take a
dozen inheritant classes inheriting from
Jason serializer to be able to handle
all these different situations well with
composition we can just plug in behavior
as we wanted and the great thing is
about composition as in other people can
come along they can implement their own
trace writer maybe someone wants a
log4net trace writer they can write
their own version they can put that
within a new
package and you could consume it and now
Jason Don it is writing trace messages
and will get written to your logging
framework and this has happened with
Jason Garnett so people who use F sharp
they have written their own set of
extensions for Jason Don it there put it
in their own NuGet package Newton soft
Jason dot F sharp and then people are
able to reference that NuGet package and
then use those converters with JSON
dotnet so it's it's a lot easier and
provides a much better way of providing
customization compared to just
monolithic inheritance of Jason
serializer
so that's all I have for you today if
you're interested in learning more about
API design I really recommend this book
so it was written by a couple of guys
who work for Microsoft it's quite old
now a lot of the concepts like the power
of sameness the pit of success like I
was ice will last forever there is some
out-of-date stuff in it and you won't
see new topics talked about like there's
nothing about async or link or dynamic
but so I recommend looking at it if
you're curious and there's also a great
presentation I have seen from someone
who works for Google so there's some
Java examples in there but like this API
design everything you've learned today
well not everything but most of what
you've learned today you can apply both
net you can apply to JavaScript you
apply to Java you can apply to any
language and that's it I hope everyone
has learned something enjoy the rest of
in DC I'll be sticking around for come
the rest of a conference if you want to
ask me any questions I think we're
running pretty short on time but yeah
thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>