<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Patterns and practices for real-world event-driven microservices - Rachel Reese | Coder Coacher - Coaching Coders</title><meta content="Patterns and practices for real-world event-driven microservices - Rachel Reese - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Patterns and practices for real-world event-driven microservices - Rachel Reese</b></h2><h5 class="post__date">2016-09-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pyudECD-AfQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so before I go ahead and get started how
many of you folks here are actually
using microservices production Oh a
couple how many of you are considering
it cool cool
anyone here yeah familiar with f-sharp
much fewer okay okay there's a fair
amount of f-sharp in this talk as well
but I will go over all the pieces that
you guys will need so today is patterns
and practices for real-world
event-driven micro-services sometimes I
throw a cloud based in there there's a
few other you know good buzzwords that I
like to fill this title up with just to
make it extra fun but to start off I'll
usually actually define all of these
pieces so for real world I mean I work
at jet comm we are a shopping site we
are competing with amazon.com in the
States we aren't available even we're
only available even in 48 states are not
available in Alaska and Hawaii yet but
we have over 25,000 orders per day 10.5
million items on the site
we are the number four marketplace
worldwide we're behind Amazon I believe
Walmart and maybe the other big one I
forget but we're number four for
marketplace and seven hundred micro
services I usually say 700 but that's a
bit of a made-up number the last year
around this time I I was pretty
comfortable in saying we had about 300
and you know as time went on I ping the
different teams the different developers
and say well you know how many do you
think we have now or we may be up to 400
or are we at 450 at some point
everyone's like we don't know my team
has 22 my team has 47 my team has 8 and
so I sort of you know did average the
numbers over all the teams and figured
it's probably somewhere between 400 and
a thousand microservices 700 seems like
a nice round number so we have a lot of
micro services and the the code
definitely for all of our micro services
and the vast majority of our code in
general is f-sharp
maybe 90 95 percent of all of our code
we do use a lot of technologies the we
are very heavy users you'll see the the
top section of a sure and if you recall
from the last slide we are taking on
Amazon so we are not heavy users of
AWS but we use you know their websites
Active Directory the the service buffs
topics the blob storage we use a lot of
what Azure has to offer the F sharp
section in the middle in green again the
vast majority of our code is an F sharp
so packet and fake we use a lot of if
you haven't looked at packet and fake
packet is a package manager which sits
on top of nougat and is absolutely
wonderful
fake is a build system also fabulous and
again absolutely wonderful but F sharp
data FS plug sequel provider F sharp
async I know the sequel provider and F
sharp async we actually have folks on
staff who contribute very regularly are
the maintainer zuv both of those so we
again we do a lot in the the F sharp
space or in Python for our our data
science note in angular on our front end
and then the bottom section of purple is
sort of everything else we use go very
heavily
we have console and Kafka again
microservices xamarin sequel you know
apache hive and Tezz we're very much a
right tool for the job company and we
use whatever makes sense so micro
services you know that's that is our
real world we are you know very much
using all of these things in production
it is a very large site we do need to
handle these things at scale so micro
services I found as I started speaking
about micro services that I really
needed to define what a micro service is
what that means to us a jet and for us
for the definition it's an application
of the single responsibility principle
at the service level so if you don't
hope that means a class should have one
and only one reason to change to us a
micro service isn't any one of these
other you know it's not just one
function it's not you know the amount of
code that a to Pizza team can write in
just a week and a half you know it's
none of those other metrics it's just
simply the microservice itself should
the micro service itself should have one
reason to exist one one purpose the
benefits of using micro services very
very easy scalability when you have such
a small piece of code you can obviously
scale that up and out very very quickly
if you for independent release ability
again a very small piece of code it's
very easy to release just a single piece
just that one piece of code it's not
going to affect nearly as many pieces
you don't have to has run run as many
checks and tests and verifications and
and all of this before you release
though you do need to run those those
checks and verifications but it is a lot
easier to work with a small piece of
code there's also a more even
distribution of complexity and that
excuse me that really means that we're
shifting the the complexity from the
business logic to the infrastructure
working with micro services as the few
of you who are know this is it's very
you know it's very difficult to do it
there's a lot of infrastructure there's
a lot of you know infrastructure that
you need around the services you need to
handle discoverability you need to
restart them at will there's a lot of
things that you need there that that
really come into play and it that ends
up being a lot heavier it's still I
think is a lot more a lot less difficult
than handling a giant monolithic
solution one of those things where you
know it's been three years and
forty-seven developers sort of all cross
their fingers and over a week you
progressively released you know the
website I've been involved in those and
those are very difficult but having
having the infrastructure around micro
services and using micro services is
still a lot more simple than that so
cloud-based obviously we use
I sure as I mentioned and if you're
working with a or microservices are a
very natural natural choice because it's
very easy to loosely couple things that
you know with the cloud and everything
but cloud base does mean you know that
you need to consider failures failures
will be built into your system there'll
be times when the servers are down or
your network is down and for that you
really should have a chaos engineering
program one of those you know if
availability matters then you should be
testing for it it's really a a best
practice is sort of move so this is my
first pattern for for micro-services and
what is chaos engineering a lot of folks
think it's just wreaking havoc with your
code because it's fun and you can and
you know really what could possibly go
wrong if you decide to do that chaos
engineering is really talking about
controlled experiments so small small
changes to test out what would happen
because there will be inevitable failure
there will be failures in your system
the network will go down there will
there will be lots and lots of issues
that you can't control because you are
using a cloud provider and by doing
those small tests and building
confidence in your system you start to
you know you gain a few benefits first
you're awake if you're running a test
that is bringing down a specific service
or a specific server the outages are
going to happen when then when you know
we're all awake when we're ready to deal
with a failure you know it's it's 10:00
a.m. on a Tuesday morning and you've had
your coffee and you're you're ready and
awake it's not 4:00 a.m. and you've just
been paged and you have absolutely no
idea what's going on and there's an
error message you have to wake up and
understand everything and suddenly fix
it you're prepared you can handle this
you know it's it's a lot easier at that
at that point and we found that folks
also start to design for failure so you
know that these tests will happen if
you're running a chaos engineering
program I'd you know I and you start
thinking about well you know if this
service if the service actually goes
down
how should we handle that what should
happen what should that look like you
know upstream and downstream and where
where should we put in checks for all of
that so you start to think ahead and and
handle all these issues you also you end
up having much healthier systems because
you're dealing with these ah because
you're pre checking for this and so you
went to pavatt you know you're you're
preventing later outages by by having a
small a small thing go wrong at 10 a.m.
on a Tuesday morning you're preventing a
much bigger disaster from happening at 4
a.m. you know six weeks from now there's
also a fair amount of self-service it's
it's similar to the designing for
failure but once you start once you
start doing this once you start checking
for failures once you start really
thinking about how these things are
going to happen you sort of want to you
you want to know if you know you want
your service to be the best one so you
start thinking not just in advance we're
designing for failure but what is
everything that can go wrong not just
the thing the four things that I know we
test for but let's start getting
creative and what if you know an entire
region in agile as your goes down or
something ridiculous and what would
happen then and so you you we found
sometimes start getting really sort of
competitive with themselves to make
their services better and better yeah
and so that's you know chaos engineering
obviously is my first recommendation so
jumping back now still definitions
event-driven and event-driven
just basically means the focus of your
application code is reacting to actual
events can be single events can be an
entire stream of events in our case it
is a stream but it event-driven just
means reacting events that are any any
significant change in state that's
happened in your domain should be past
tense it should be immutable the
you know the an event here maybe all of
you folks woke up this morning you got
dressed you came to NBC Sydney and you
decided to come to my talk those things
have happened you can't change your
decision you can't pretend that you
decided not to come to NDC Sydney or to
my talk you're all here like it that's
that is immutable it's it's a fact ah
it's also the last one contains only
relevant you know the actual event
itself only relevant data to the
transaction it doesn't matter what color
shirt anyone is wearing here today
the important thing is there the
important information for this event
that you actually showed up that you're
in this room that either you're at NDC
Sydney or maybe you're at this hotel but
you know it doesn't matter what color
shirt you're wearing what type of shoes
that's all irrelevant data to this
actual the actual transaction and one
confusing point the term events tends to
refer to both the actual event itself
you know showing up at this talk as well
as the notification message that's
passed around to the rest of the system
so as notification as notification
messages be excuse me B F we have a
simple you know push based notification
we have an event emitter and the events
travel through an event channel and then
are consumed by an event consumer which
is very similar to reactive it does
anyone here actually use any of the RX
extensions or yeah cool a couple people
so the reactive manifesto if I can
recall it was that modern applications
should be responsive message driven
resilient and elastic um but basically
you know event-driven is a very reactive
concept events can be thought of as an
observable
and when they are you know the the
microservice input of them you know when
you're reading these events you can be
you can treat that stream of events as
an observable an event source that so
does anyone here do event sourcing okay
a couple people have the rest of you
folks heard of event source
couple folks okay so event sourcing
slightly different than or definitely
different than event driven it's more
about how you're modeling a domain it's
it's a an append-only
sequence of events you generally just
keep track of each of the events as they
happen so that you have you know one
giant stream of events and keeps track
of all of the state changes a excuse me
a very common way of explaining this is
you know thinking about folks ah
customers when they move you can have a
a standard database would only handle
the most recent customer address but an
event log would you would see all of the
past events you'd see when the customer
moved what the previous address had been
and a flow of events through that and
you can end up replaying those streams
yeah so you know a relational model will
only have the the latest information but
you can end up replaying these streams
very similar to an account history a
ledger a bank statement sort of idea
where you can go back you know if you
you're one of those people who you know
keeps every single statement that you've
ever had I used to be one of those
people I am not that person anymore
but you can go back through all of your
statements and you know since the
beginning of time from your you know
when you started the bank account and
see exactly what happened and make sure
that you know your version of the
information is in sync with what the
bank's version of the information is but
for example maybe the date here
maybe there's there's additional
information you wanted to capture the
time as well you know if you think of
all of this as just one giant stream of
events you can replay all that
information and you know add on the time
assuming that that was captured to begin
with and just cut off so you can you
know replay and adjust if you if you go
through all of this say you you found a
bug in the way this was handled if you
you know needed to update the sequel
schema of the tables that this
information was writing to maybe you
needed to
index you're searching but there's lots
of different reasons and ways that you
might want to rerun this event stream so
how did jet actually decide on micro
services and this is actually one of my
favorite stories we didn't we decided it
on f-sharp we sort of and I will tell
that story soon actually next but once
we had decided on f-sharp we decided you
know we F sharp being a functional
language and you're being a mutable DEP
by default most well the vast majority
of functions that you're writing in F
sharp are proper functions they have
inputs and they have proper outputs and
the micro services to us are just one
large script so they act sort of like
one big function there's some specific
inputs there specific outputs they
should be immutable in general and we we
also named things you know if you're
writing a bunch of micro services you
don't want a name thing you know have
maybe you know and import new items so
we have an import SKU service the proper
naming conventions dictate that you'd
want to have have that called import
SKUs not import SKU service and we were
doing that because we weren't thinking
of anything as services we were just
thinking well this is the import SKU
script and this should be importing SKU
isn't it you know it has a few inputs of
you know places to look a stream to
follow and you know specific outputs of
you know that excuse themselves perhaps
but there was no actual meeting where
everyone sat down and said as a good
architectural decision let's do micro
services we built a bunch of f-sharp
scripts and accidentally woke up one day
and had micro services so then why did
we choose f-sharp
well the
the CTO attended a conference ages ago
well first of all this the CTO is a big
Microsoft person had always worked with
with c-sharp was very comfortable there
and so the original plan was was to just
use a c-sharp and he attended a a
conference years and years ago when
Edwin F sharp was fairly new maybe 2012
and heard the same story that a lot of
folks have heard about how f-sharp is
good for math and science and you know
you should a lot of the banks use it for
financial purposes and you know that
that's sort of f-sharp sweet spot and he
decided that you know as part of the one
of Jetts big things is that we have a
very interesting pricing engine it can
it double checks which merchants you're
going to be purchasing from and if
you're buying two or three things from
the same merchants it will bundle those
together you can save a little bit on
shipping the merchants can save a little
bit on shipping and we pass those
savings on to you but we don't you know
we don't really know who you're going to
we don't know which merchants you're
going to be purchasing from until we
have the final basket because at that
point then we do all that matching and
see see if we can get four things from
one merchant and two from another as
compared to you know for individual
items and to from a single merchant so
that pricing engine the the CTO realized
is a really interesting for f-sharp that
seems like a natural there's going to be
a lot of math e things there and so some
of the very early developers the first
you know two or three were f-sharp
developers well of the first two or
three developers for developers there
was a and f-sharp developer to work on
the pricing engine and as you know the
the architectural discussions started to
happen and as things you know moved
along they started to have more and more
discussions about well should we maybe
be using f-sharp for this piece over
here what about this part over here
there where does it really fit should it
should the process be expanded or not
and they started to realize that they
weren't really sure and as a very very
young startup they're like hmm
we have time and let's just let's let's
see where this goes we'll build one
complete solution in c-sharp and one
complete solution in f-sharp and see
which one is better
so f-sharp obviously 1 but it was the so
that there were several factors a lot of
them are the the same things that you
hear about F sharp the-- there's less
code leaving to fewer bugs and you're
able to to keep a lot of that in your
head and and all of these these good
things that people do hear about do say
legitimately about f-sharp the type
system is really wonderful it double
checks things for you but the big thing
this sort of the straw that broke the
camel's back was our our cross-cutting
concerns library we you know as one does
you know we needed something to handle
validation and logging and then all of
those things and the standard way of
handling that in Web API and a few other
libraries is by using attribute you
inject an extra function call before
boyar before your functions I know that
that several frameworks do this but we
needed a way to handle these
cross-cutting concerns for services that
weren't always based on HTTP and that
was really difficult to do in a generic
way that wasn't something that that
c-sharp really handled well at all but
with f-sharp it ended up being just an
extra for the folks you know f-sharp em
just an extra pipe statement you're just
making an extra function call and then
continuing down the statement so I will
show you guys some F sharp code in a
minute but the the concept of piping is
very similar to powershell or if you've
done any unix shell scripting the the
output from the previous function is
piped in as a parameter the last
parameter to the the part after the
function or the the pipe
I met being able to just add a separate
step in that pipeline made it basically
completely trivial to handle these
concerns for us and that was sort of the
the big reason we ended up switching so
a few reasons on why people chose
f-sharp in general first people love
programming and functional people love
functional programming B I don't know if
you folks saw the the recent sort of
recent at this point was April
stackoverflow survey but swift def sharp
Scala closure Haskell are all you know
very high and the the list the seventy
percent of people just really love
programming in that language
seventy percent of the responders said
they loved it that doesn't seem quite
right not sure where those seventy
percent are coming from but it's awesome
people love it so productivity I know
yon this year he actually spoke
yesterday but when he was working for a
company called game sis I know they do
some Facebook games I'm not sure exactly
which ones but obviously very very high
numbers of users need to be very
available he discovered f-sharp thought
this is really cool I think it's going
to solve some of my problems and rewrote
the entire back end of the project that
he was working on at work he was able to
go from you know concept into production
in six weeks and he replaced an entire
team of nine Java developers when I
first heard his story I thought it was
like four or five but apparently was
nine and it only took six weeks but you
know he would stand he was able to
maintain the entire back-end of this now
himself so he is around if you guys want
to talk to him about that expanded
feature set there's a lot of really
interesting features in F sharp that
really have made it useful both for
micro services and for jet in general to
really you know scale up so quickly
first option types option types are a
lot like nullable they're they're a lot
more powerful they at first it's you
know you can you can have an option type
of
anything not just you know Interpol's or
you can have an option of a string an
option of a custom type the option of
entire function you can you can anest
option types you can have an option of
an option of an option type it's not
always pretty but you can do it you can
also there's a you can use mapping and
iterating and another other such
functions over this so if you have you
have an option type and you want to
maybe an array of options and you want
to double check you can you can
basically map the entire thing and and
keep the the null ones null and the ones
that exist exist and then this joke
comes from when you're using an option
type to actually get to the value you
need you're forced to handle that null
check so because you're forced to handle
that null check
you're basically obviating no reference
exceptions entirely there's also a
really one of the most useful features
especially in bringing down you know
producing code size discriminated unions
so on your right
we have a discriminated union transport
type if you think about if you just
think about car bus and bicycle then you
can think of a discriminated union as
sort of an enum type it works very
similarly when you add on the extra bit
of information the make and model and
route then it's a lot more like a a
simple object hierarchy so we have the
the c-sharp on the other and on this
side there's a transport base class you
know a car bus and bicycle each and
Herot from it obviously in c-sharp this
would take four separate files b but
they do contain basically the exact same
information i say basically the c-sharp
version still actually lack structural
equality
you'd have to override equality in
comparison and get hashed like it'd be
complicated to add in all of that every
time it's also not properly immutable
its idiomatic but it they're still a
private set so you could set it the
backing field technically probably
should be read-only but the the f-sharp
then has more happening in these four
lines of code it's also very very very
easy to pattern match on and pattern
matching I know that c-sharp I think 7
was supposed to get some powder matching
I know they've scaled that back I don't
know exactly where that stands
but the without any pattern matching in
c-sharp then the only way we can hit the
only matching that we could do and say a
switch statement would be on the top on
a constant whereas f-sharp has all of
these other ways of interacting with
your data and handling you know just
working with it to faster and easier get
to the information that you actually
need so this is what that would actually
look like we have this get there via it
takes in a transport will match
transport with the first case you have a
car which is a you know takes a specific
making a model you have a bus which
takes a specific route or a bicycle if I
for example add on a train because
trains are also a valid type of
transportation then we would the next
time immediately if you're something in
the same file or every time you compile
you'll get a warning that you have
incomplete pattern matching expressions
so rather than having this pop up again
you know at 3:00 a.m. when you've
suddenly been paged and the you know the
pager duty alerts are going off like
crazy you just automatically know that
you get a whole bunch of warnings when
you compile you can see those you can
see all the places that you're supposed
to update that code and the compiler
just sort of has your back and is
watching out for you tie providers are
also one of my absolute most favorite
features of f-sharp and this is like I
mentioned we have one of the maintainer
so the sequel provider that works at jet
type offenders are also a really
they're just really wonderful they the
first there what really sold me on
f-sharp it's and I I post Julie's book
not to make fun of Julie there's a lot
of very hard work that went into her
book and the nine hundred and twenty
pages length I think is valid to make
sure that any framework is actually
running and doing what you want it to do
takes a lot of effort to really make any
framework do what you actually wanted it
to do to begin with but the so nine
hundred and twenty pages for Julie to to
explain how to how to properly use
entity framework and then thirty-one
lines here we have really lines thirteen
and fourteen are connecting to a type
provider and then grabbing the the data
context so the the first line really
just does all of that connection for you
the starting at line 16 we have a quick
query starting at line 26 we're
inserting information back into the
database and it's it's almost trivial to
use the type providers because it really
is only one or two lines up set up each
time you have to you know include a
library and then connect out to it type
providers also aren't just for sequel
server you can have a JSON type provider
an XML type of ID or a CSV type provider
there's an R type divider for folks who
are working with data science which is
has been really interesting and and fun
to use you can basically run R as long
you have are installed on your computer
you can write a bunch of f-sharp scripts
and run our from f-sharp so again type
but we do make heavy heavy use of the
sequel provider and it has been really
important units of measure also and the
I don't know if you folks remember this
but there was a two of the teams on the
the climate that the Mars climate
orbiter didn't actually communicate with
each other well one was using metric one
was using English English units and the
entire craft exploded because they
didn't communicate this to each other
whoops but UNIX would measure don't
necessarily just have to be a scientific
thing it doesn't have to all be meters
in seconds they actually jet uses them
and the
the warehouse code to to verify you know
wind wind or stocking products is this
actually a single unit of something is
an entire pallet of something you know
just because we say we have one of
something doesn't mean we actually
understand what that means we need a
unit along with that so it can be used
for in a lot of cases to just make sure
you you're really clear on what you're
talking about
so F sharp also I think personally is
very very readable this is you know one
of my favorite examples of F sharp being
readable I'm kidding that to Perl but it
is one of my favorite examples of Perl
not being readable so Ramon tweeted this
a while ago being he's basically doing a
technical talk he had some F sharp in
there and one of his games his friends
came along later was like you said you
were gonna have code in that talk what
up dude the this is the actual code he
had in his talk he had his entire domain
model there and it's pretty clear what
and that's what the wasn't the actual
tweet at the bottom the picture he had
but it's pretty clear what's actually
happening here you have a discriminated
union the top of booking basic which is
just your plain or a combo or the full
pack you're getting a plain hotel in a
car sure you're booking a you know
travel the the type and and and B this
is a way of defining all of your types
at once you don't have to say type in
front of each one you can just say and
and they're all together but you know
next we have a plane and that plane
needs an outbound and return both date
times and destination apparently only
need a destination country you don't
need to know which city you're flying
into that seems complicated but there's
also combo so you are either with the
hotel or with a car it's it's one kind
of combo the hotel again needs an
arrival in the departure and a country
the car again needs a from Anna to how
long you're renting it and the country
then the country specifically is a
specific name and an iso i an iso code
which is a char that char start char a
tuple tell you define the show the type
for a tuple so again that's pretty easy
to glance at
actually see what's happening I have
another story friend of mine did a very
similar thing after you know a quick
meeting he jotted down again like this
the the domain model for the what they
the the new feature that they had just
described and the business analyst who
was in the meeting asked him to send
around his notes so that the rest of the
business analysts on the wider team
understood what they were building he's
like it's not notes I just actually
wrote the domain model it was F sharp so
very easy to read and again as an
example of shorter code which has been
one of the huge ways that we're handling
lots of feature lots of being able to
handle a large amount of functionality
in a small thing like a micro service so
this bit of code was an article that
came out on code project a few months
ago while ago now maybe six months but
basically a somebody had taken a bad
example of c-sharp and I will show you
that code in a second it was pretty
awful it doesn't describe anything you
have no idea what's happening and then
rewrote it to be fully refactored you
know properly properly worked as you do
it was very well very descriptive very
you understood exactly what was going on
and the original so this is the original
code you can see you know two class one
you're apparently calculating something
and the the original result is zero but
there's some different types that are
involved in some years but it's really
unclear what's actually supposed to be
happening here so it was refactored and
cleaned up in c-sharp still and it went
from 25 lines of code to 118 lines of
code and they removed the tests and
again why why why what what is this and
there's also you know there's an I
Lowell T discount calculator and an IEEE
account discount calculator factory and
it's just it's there's a lot of overhead
for just showing off this small bit of
code
there was also a second approach one guy
saw this article and was like that was
some awful c-sharp here's some better
she's sharp so he rewrote in 252 lines
of code which is not bad he also caught
an additional error that the original
expander didn't didn't properly catch
but he noted that the factory method
yeah and and strategy patterns were
we're totally irrelevant this is to
Ralph Ralph Westphal in his blog post
redid this so this was his bit of code
you can see it's a little easier to read
it a lot clearer to properly understand
but the f-sharp community someone took
this and rewrote this into 30 lines of
code and here it's actually very clear
what's actually happening so the top we
have we're taking a a year and just you
know aliasing that type it's just an
integer we have a unit of measure as a
percent because what's actually
happening is we're taking a discount
percentages off for customers who are
valued so we have a discriminated Union
which is an enum type for in this case
acting as a valuable and most valuable
and just basically you know there's
there's another discriminated Union for
account status if the customer is
registered and how long they have been
registered or if they're unregistered
and then the customer discount this is a
shorthand way of pattern matching so we
have you know our function and then if
it's a single then they get a 1% or a
simple 1% discount
valuable they get a 3% discount you can
see how you simply tag the units of
measure here and very quickly can just
go through and see at a glance that this
is a percentage and not some other type
of integer so the the years discounts
you know what when the years are greater
than five you get an actual 5% discount
otherwise you multiply that and you get
you know one two three four percent
discount but I I won't continue on with
the rest of it the it comes down to the
very end the the price we reduced the
price by the customer discount first and
then pipe it in reduced the price by the
year's discount next and again
it's very clear 30 lines of code to see
actually what's happening so the f-sharp
way also has a few tests you can very
quickly get a few numbers and and you
know one two three four five lines of
code also run some tests so final reason
why to consider f-sharp and why why we
chosen why it's it's so important excuse
me
you definitely don't need a PhD and
f-sharp has this reputation of being you
know the complicated thing but this is
my friend Shawn and when Shawn was eight
he spoke at NDC Oslo actually has his
first talk on f-sharp and it was a
lightning talk I believe but it wasn't
just a little like here's my hello world
program and you should clap for me
because I'm eight and that was adorable
and I gave a talk he actually did some
very interesting things using 3d image
modeling so you know he's eight and he
is very much able to handle this
obviously he doesn't have a PhD so now
the guidelines on actually now that we
have all of this background we can
actually get into the proper guidelines
and first you're gonna hate me be
functional this is why I go and talk
about F sharp so much that F sharp and
microservices are such an easy natural
fit just makes so much sense the using
data in data doubt transformations at
the beginning I said that it's really
important to have you know we we built
our our services as f sharp scripts may
have inputs they have outputs you know
exactly you need to know exactly what
that transformation is in the meantime
and you know think about what that
mapping should be there's also you know
start prefer mutability the if you're
doing thing you know if you have inputs
and you have outputs and you're looking
at that transformation you will
naturally create an immutable general
service and you know those two things
fit together very naturally very easy
but the Void state changes and
side-effects immutable data as much as
you feasibly can it's really really hard
do it to do anything excuse me
concurrent and to scale when you have a
lot of mutable data
around and just a mutation makes things
difficult treat functions as Univ work
think about passing around a single
function rather than you know passing
around an object and again if you're
making things immutable and you're using
these data and data of transformations
that sort of comes along fairly
naturally the same thing with using
recursion at least for things it's
difficult to do just one of them you
have to sort of jump in and and do all
of them all at once but next don't try
the abstract micro-services are small
for a reason they're it's very easy to
create a single microservice that will
connect to a vent store and a single
micro service that will connect to 0 mq
don't try to mix and match the two if
you try to create one service that
handles all of these things you'll have
to cater to the lowest common
denominator and it's going to do all of
that sort of mediocre Li for all
services you're not going to be able to
use the unique features of you know MSM
Q because sequel server doesn't
necessarily have half of that stuff so
they're small right a single service for
each one now where you can't actually
remove side effects because life you
know they happen isolate them as best as
you can if you have say a submit order
micro service where you know somebody's
just placed an order they've hit please
buy this on the shopping cart and you
need to go and handle all this now you
might want that to first update sequel
server and then second Sunday thank you
for ordering email don't do this because
as I talked about all of our all of our
service services are event sourced we're
reading from an event stream if we go
and replay that and rerun you know that
event stream and re handle all these
micro services when we do that we are
going to do when we replay everything
we're going to one update sequel again
because maybe we've changed the sequel
schema something like that but we're
also going to resend all of those emails
from all time back out to the customers
that's bad
so separate them again microservices
should have one purpose one one small
thing
so set two separate microservices one
that inserts actually does the insert
into sequel and one that sends this
thank you thank you for ordering email
and then when you need to replay
everything you'll replay the sequel
service you don't need to mess with the
but thank you for ordering email yeah
service and you won't get snafus like
that one also use a backup service so
have two services in production you know
service one is running in production
perfectly fine and normal backup service
is in production up-to-date but if you
want to replay all of your events do so
in your backup service wait until that
one is is up to speed and is ready to go
then you can automatically switch over
to that one and have no downtime sort of
like having a staging server just flip
that one on and you're ready to go the
important thing though is to stage a
copy of you know any aggregate any data
store that you have until the stream has
continued replaying if you're basically
to isolate your side effects if you're
doing something like handling accounts
maybe you're you have a service that
will will turn off and on account
because you think they're fraud whatever
may be there are a few customers that
argued with it with you they weren't
actually fraud you determined that they
weren't to see you turn their accounts
back on every time you replay those
events if you're doing that against a
live database you're going to be
trimming those accounts off and then
back on again it might only take you
know 30 seconds it might take you know
an hour a day depending on how much back
data you have but you will be turning
somebody's account off and then back on
again
and if that happens to be at a time
where they're trying to purchase
something they're just gonna be really
angry at you and you know having that so
if you staged that run through
everything update as needed and then
switch both pieces over to live at once
you'll be much better off
so what do our services actually look
like I mentioned they're actually F
sharp scripts and they basically look
like this most importantly I've talked
about how we need to have inputs and
outputs and how and after this this
f-sharp script is sort of like one giant
function this here we have our are in
pits we have as so this this service is
a a demo a little service that I wrote
up that connects to some magical Nile
website and does a price check on a
specific item that's sent in that's
funny I know it's a terrible awful joke
please laugh so yeah so Nile there's
some input so we have a specific product
that we're going to be sending in and
saying double check the price on this
product for the outputs we have two
cases discriminated union the first case
we send back the the full product
information plus a decimal for what the
price was on the the external site we
also have a failure case product price
check failed in which case we have you
know a message some information about
how what that failure was and how that
happened next we define how that input
transforms to the output so again sort
of one giant function we have inputs we
have outputs we have a transformation
you have Handl here's where the real
meat of the microservice really is it's
just a you know I this is this is where
that transformation happens I've you
know as this is a demo I'm just
returning a successful case I'm
automatically creating that I'm using an
option type and specifically creating a
a valid or a success case for an option
but I have a skew and an my amazing
product and a cost per and then you know
it's 3.96
yeah on the external site then once we
have how how that transformation happens
we need to define what we're actually
going to do with this output we have
this interpret function so we're sending
in you know the output and ID and we're
doing our pattern matching here
excuse me so we match the output with
first the successful a successful
completion of the successful case and
maybe in this case we want to write to
event store and it's you know just
continue on yes we actually were able to
get this price we know exactly what's
happening we connected out successfully
to the API and and have a valued value
returned so in the next case we have a
successful completion of a failure case
so we got a response back but we got a
failure so we might want to log that
maybe it's a failure we know how to deal
with maybe you know there's either a
timeout or a specific a specific issue
there was you know extra space on the
end and we know that we can just
truncate it and try again
but in this case we we might log and/or
try again in the last case we actually
received no response at all and we have
absolutely no idea what happened but
something went terribly wrong so here
again you know we have our options we
have you know the success this is just
cases to begin with what we have this
third option where you know it just you
know it completely failed and here we
might log the failure but we wouldn't
have the additional information to know
what actually happened finally so we
have in our event store Q consume which
is one of our internal functions
basically takes in the original product
information decodes that properly sends
the handle and interpret functions along
to this consume function and we're able
to consume this stream of events
properly for our micro service to be
able to handle all that so being
functional just means that this
composition here is very very easy and
it works together and flows together
really nicely
so micro services also shouldn't control
their own life cycle it's we ended up
rolling our own product a lot of folks
use docker or console but you know
scaling and availability and
discoverability all of these things
really should be handled by outside
products we were able to and we rolled
our own we were
to deploy a new build in about 30
seconds rather than 15 minutes that it
had been taking us we also wanted to
scaling really should include like an
entire VM with assorted or relevant
related related services automatically
rather than just scaling one or two
services on their own so we built a
product that handles the top it's purple
things in the top eight things we're
working on the bottom three things and
probably will open source that when
we're done we so the product we built is
called torch at jet all of our products
are app named after superheroes so this
is torch who is fire and not a do you
know I had flashlight but each one of
the micro-services has an Associated
gamma file that that helps torch sort of
understand what you know has a few
configuring options what version of
torch there it should be using what that
subsystem is you know what which things
should be scaled all together in that VM
a name a description a version whether
or not to auto start whether or not to
compile H a stands for high availability
whether or not it's it's active active
or active passive active active means
that all of their nodes are up at once
and if one of them fails then the the
traffic that should have gone to that
node will just be we're just
redistributed over the rest active
passive means you have two completely
separate setups one is live and the
other one is waiting for this the the
live one to go down but it is fully
fully redundant the so we have a script
path and the library path a few
arguments the you know if we want to set
up a specification config this is really
especially useful for our data science
group they can part of that Jason config
tells tells them how to transform that
data into a specific Kafka topic and by
modifying just a couple lines they can
completely transform how they're looking
at that data so then yeah mol I thought
was really fun I I
double check what it actually meant to
make sure I knew what I was talking
about
yeah mile eight markup language so it's
a recursive acronym just always fun
those make me happy but it also used to
mean yet another American language which
is the exact opposite of what it
currently means but it was back renamed
which is a new word I learned to clarify
so it's it's not like you know github
markup language it's you know data
oriented markup language totally
different so in summary don't abstract
if you have one service and you want to
and you know you know you need to you
know don't try to have that cater to
several several different things
Micra services are intended to be small
so have a single micro service for each
each specific thing be functional
obviously I've talked at length about
that sharp but it is it's very important
to our story and the the two things are
so intermingled for us that that it's
almost crucial we we wouldn't be able to
write micro services as easily as we do
if we weren't you doing them in a
various functional manner isolate your
side effects as best as you can and you
know where you can't separate separate
the service you know so you have one
specific one specific service that
handles just a specific side effect use
a backup service make sure you have
something that's you know chugging along
in production you can replay events into
that service and then just switch over
as needed and you're ready and good to
go
use the consistent formatting it's I
showed you what our services look like
and that doesn't have to work for you
but it has been very useful to us to
have a similar format across teams folks
can can jump in and you know it's very
clear what's what pieces of the micro
services are meant to do use an outside
product to control your life cycle again
we built our own but it you don't have
to use but use some sort of outside
product don't try to handle this all on
your own and then make sure you have a
chaos engineering program because
anytime you're doing especially if it's
you know cloud-based micro services but
anything that that's going to be this
this scale this you know is going to
have failures is going to have issues
you want to make sure you have
confidence in that system and you know
exactly what's going to happen
especially with you know something like
us a a website but you know folks are
dependent on if something's going to go
down you know we need to make sure that
we're handling this correctly we can be
back up to speed as quickly as possible
so for more information
definitely check out from microservices
Martin Fowler comm micro-services dad I
owe both really good places for f-sharp
there's an F sharp foundation F sharp
org lots of really really good
information on how to get started once
you join in it's free to join the
foundation you can pay if you want but
you don't have to once you've joined you
can join the F sharp org slack channel
there's there is a couple other slack
channels that Twitter is also a really
good place to get F sharp information
but by far my favorite one is the F
sharp org slack channel it's a really
good group of very responsive people
also F sharp for fun and profit Scott
flashin this conflation z-- explanations
are fabulous and right on point for
event sourcing honestly pretty much
anything Gregg Young has ever spoken
about but these two talks in particular
are quite good and that's actually it
but I will leave up this slide of more
folks on take pictures and any questions
yes you mentioned that the team's use a
chaos engineering and you gotta learn a
lot of learnings from that how did they
feed back into when you do development
of new micro services so did if you have
templates or they just have it like sets
of standards so my yeah how does how
does the team take take what we've
learned from chaos engineering and and
sort of bring that in as far as I know
the the teams don't have any specific
standards or or templates I I was on it
a team when I first started and I've
switched over to full-time evangelism so
the team that I was on at the beginning
did not but that was also very much
before we
the Kaos program was even in place but
it's my understanding that we don't have
anything specific it's sort of on the
image dividual developers - you know
remember what happened last time anyone
else all right thank you guys very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>