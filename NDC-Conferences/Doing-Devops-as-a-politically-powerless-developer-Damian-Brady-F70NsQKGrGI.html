<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Doing Devops&quot; as a politically powerless developer - Damian Brady | Coder Coacher - Coaching Coders</title><meta content="&quot;Doing Devops&quot; as a politically powerless developer - Damian Brady - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>&quot;Doing Devops&quot; as a politically powerless developer - Damian Brady</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/F70NsQKGrGI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">just checking hey thanks for coming I
know this was kind of a last-minute
change or an addition so it's good to
see and for the people here as well
which is good so yeah thanks for coming
along I am Damian Brady who basically
I'm an Australian guy who talked about
DevOps stuff pretty much I started
explaining like what company I come from
a little while ago because it got
confusing but I used to work for a
company called octopus deploy does
anybody use octopus here well that's
like half of you it's awesome um and
then about a week ago I moved to
Microsoft so I now work for Microsoft
I've actually answered more questions
about octopus wings working at Microsoft
and I did like the final weeks of
working at octopus it seems that
everybody just wants to know the octopus
stuff which is fine because that's
totally in my in my wheelhouse I'm
allowed to talk about it to new
Microsoft I don't have to talk about
just Microsoft things anymore which is
awesome so yes I am here this is the
team I'm working with so if you know
Jonathan Brown I'm on his team with a
couple of other people who are yet to
join that have been announced so this is
really exciting for me um today's talk
though is pretty much born out of
questions that I keep getting asked at
the end of all my other talks so this
even happened earlier today which is the
reason I'm doing this now as like an
additional talk the questions are
usually things like I know this stuff is
important that how do I convince my
manager that this is something I should
spend time on there's this difference
between what you understand is the right
thing to do and what your management
understands you should be spending your
time on so I've kind of tried to pull
together a whole lot of little things
that you can do now even if you don't
have the power to make huge changes in
your organization so if you're a
politically powerless developer so is
everybody here a developer by the way
that's pretty much all the hands anybody
in kind of management
a little bit okay I'll try not to offend
you very much in this but there is a
section where I'm talking about
subversive kind of techniques to get
around management so you might need to
watch out for that and fire some people
anyway so what happens with them
organizations that do DevOps often is
actually the drive to do DevOps comes
from management down rather than
organically from the developers up if it
comes from management down sometimes it
doesn't work very well because the
managers just want that buzzword and I'm
saying managers as like a global the
business decides that it needs to do
DevOps and therefore it's in there a to
word we can add to our webpage so what
often happens is the manager will come
up to you and say something along the
lines of hey vo hi there human resource
because you don't really need a name you
just a human resource so we need to tell
our shareholders that we're doing DevOps
so off you go now you can do DevOps but
you still need to still need to involve
the Change review board which has 28
people on it and we want quarterly
releases because any more than that is
confusing and also we need to sign off
from all the 25 department heads every
time you do release as well is that okay
so we still do DevOps that we still need
to do all this stuff right which is not
really what give ups is right um it
gives it gives the developer to a toll
now now we're doing DevOps right this is
a this is our culture this is the thing
we need to put on the website but don't
actually change anything the problem is
that DevOps requires change like if
you're not doing if you're not doing the
stuff that DevOps involves then you're
not doing DevOps you can't just add the
title to it and the same thing happen
with agile as well talking about in the
previous session I did yesterday when
agile came about people were like we
need to do agile now that means
everybody stands up in the morning so
ten minutes and now we're doing agile
also we don't need to write any
documentation anymore that's our job
um so it didn't really it doesn't really
work that way as everybody knows
even saying that DevOps is a culture
change is great in theory but if you've
ever been in an organization where they
tell you that the culture is changing
that doesn't work right
if anybody's been in a company where the
management comes in and says by the way
we are an agile culture now that you
don't change culture by telling people
that the culture has changed so you
really need to change the way that the
way that things work but as a developer
in these organizations you don't often
have the power to do that so let's just
quickly look at definition of develops
is always useful to put at the start of
the talk so union of people processes
and products to enable continuous
deliberative value to our end users so
it's all about actually doing things
differently to deliver value so not the
same way that things have been done
before and as much as you want to do
that like I said as a developer you
probably don't have a lot of power to do
this so today is really about the things
that you actually can do as a developer
to try and move the needle in the
direction that you want it to go even if
you can't institute organizational
change I'm going to break it into about
into four sections I'm say about it's
exactly four sections and there are
technical changes that you can do and
these are kind of the base level even if
your job is literally taking tickets
from the left-hand column moving into
the right-hand column and following a
really specific specification there are
things you can still do from a technical
point of view to make it easier to to
move in this DevOps direction later on
to make it easier to push stuff at the
production faster so these are the base
things you can do immediately I'm going
to have a look at a bit more of process
change and I don't mean company-wide
process I mean your development team
process so again you don't need a lot of
political power in your organization to
change the way that you as a development
development team and user developer
actually works on a day to day basis so
there's a few things there then I'm
going to change tack a little bit we're
going to talk about how to talk to
managers like how to deal with the
management who doesn't know the same
things that you do and just have an has
completely different player
and then finally just for completeness
we're going to talk about the stuff that
is still going to be a problem right not
everything is rosy there's still a
couple of things that are going to hurt
it's worthwhile just mentioning that all
right so let's talk about technical
stuff so literally the code that you
write day-to-day and how you can change
that and this is all about getting your
software into a state where it is easier
to make a change
the biggest problem from the technical
point of view and if you're trying to do
DevOps is that it's hard to change stuff
safely you know that software is written
in a particular way where when you make
a change it's a little bit difficult to
make sure that that's absolutely going
to work the way it's supposed to work
and you know definitely going to not
cause problems in production
the problem is when this stuff starts
happening when there are bugs and stuff
like that the traditional way of
handling that is to add some more
bureaucracy and some more governance and
sign offs and things like that which
leads to this kind of bureaucratic
deployment cycle or to talk about which
basically goes like this the deployments
are so far apart because there's so much
change in each deployment there's so
many things we have to approve and
there's so many things we have to
approve because the deployments are so
far apart like we're pushing stuff to
production irregularly which means that
there's so much risk in every single
release as so many changes which means
that it slows down this this is a cycle
that kind of feeds upon itself and
things get slower and slower and harder
and harder
um strategies like or frameworks like
ITIL does anybody do I tool in their
organization ITIL no hand
that is awesome I hate idle so am i till
is it's kind of a complete opposite of
DevOps right the idea is you do as much
planning and as much preparation up
front to make sure that nothing can
possibly go wrong when a change goes
into production which means that when
something does go wrong when a change
goes into production because it still
will like we know it we know it does
it's just really really difficult to
make changes to fix that
problem meanwhile the idea behind DevOps
is to move fast and to move in a way
that if the problem does make it all the
way to production it's really quick to
fix that problem like the the idea of
the closer you are to danger the safer
you are so the more the more you do this
hard stuff the easier it gets so things
like ITIL and making sure that you do
all of this preparation upfront to make
sure there are no problems just makes
fixing those problems a lot harder
otherwise maybe there's fuel problems
but they're still going to be problems
and the same thing happens with with
agile like we've learned that lesson
that planning everything upfront and
then just doing one big deployment at
the end of the entire project doesn't
work we want smaller iterations so small
changes more frequently so from a
technical point of view when you're
writing code the idea is to make change
easier and safer and the best way to do
that is have decent testing strategies
so I spoke a little bit before about
this but the ideas of test-driven
development and red green refactor when
writing tests so test-driven development
is essentially just you write your tests
before you write your code so you have a
requirement you write a test to prove
that whatever code you're about to write
is going to work that test is obviously
red to start off with because like it
fails to start off with because you
haven't written the code yet then you
write the code and make sure it passes
your tests the reason you do that rather
than the other way around is because you
have a tendency once you've written all
of this code and now I need to write a
test around that code you test for the
thing that you just wrote so you have
these expectations in your head you've
kind of lost sight of what the actual
purpose of the functionality was so
write the test first and then you write
the UM you write the code and prove that
that works the point here is that you're
not going to introduce any new bugs you
have a test around at the prove that it
works you know that that test is going
to fail if it doesn't do what you're
supposed to do so you're trying to
reduce new bugs that you introduce red
green refactor is kind of similar if
there's a bug rather than just going
ahead and fixing that bug you would
write a test too
prove the existence of the bug so it
goes read the testifiers
and then you fix the bug and make sure
the test goes green this is about not
introducing any old bugs so you know
that you fix this bug now and not only
that you know there's a test that will
tell you if you ever regress and
introduce reintroduce that old bug so
this is all about making change a little
bit easier because you have this proof
that the change you've made has hasn't
solved the problem you're supposed to
solve so this is something you can
literally do even if you have zero power
in the organization
you just write tests around the code
that you read you don't necessarily need
to go back to all your existing code and
start writing tests over it just do it
for the new stuff next next feature you
write just write some tests around it
it'll continually just improve the
software and make it easier to make
changes for larger changes so really big
things that aren't just writing the
function or fixing a bug I would say
that abstraction is your friend so
rather than go into the actual
definitions of abstraction I'll kind of
I'll give an example so imagine you have
a application that has a page on it that
tells you the weather or something based
on based on where you are and to do this
you use Google's weather service I don't
even know whether Google has a weather
service ocean too so you have this
google weather provider in your code so
all of your code talks to this Google
weather provider and it provides
information back now if you needed to
change that to for example of being
weather provider then the tendency is to
say right we just change all of the bits
of code that talk to Google and we
change it a bit of being we rename files
and we do all that kind of stuff it's a
better idea to try and abstract that
away so your code that it was calling
into the Google weather provider if you
can refactor that and put an interface
over the top or a any other way of doing
that an abstract class or something like
that over the top of it and resolve that
at runtime using techniques like
dependency injection what that means is
as you're starting to replace this
functionality you can just write Oh
being with a provider that implements
the same contract so now your code just
knows what a weather proof
a weather provider looks like you have
the implementation you've been using and
you've started to develop another one
this makes it a lot safer to make
changes because you're not changing any
existing code that existing code stays
where it is you just write a new
implementation and then when you're
ready you can flick a switch and make
that resolve to the new version if it
doesn't work you could turn that back
off again and go back to the drawing
board
so changing is much easier if you
abstract these things away as part of
the work and of course you need to go
back and fix that up later remove the
old one and that is generally not a
technical problem that's a process
problem but you just need to make sure
that you clean up this code later on
this is a great way of them generating
technical debt too but yes so you need
to make sure you clean up after yourself
if you want to do this kind of stuff
make changes even faster than the idea
of feature flags is a great idea too
so feature flags are typically there's a
few different ways they can be used
often they're used for kind of marketing
purposes so you release a feature and
then you can launch that feature at a
particular time just by turning the flag
off but you can do it at a much lower
level as well in combination with
abstraction to to make sure that code
you've written is able to be used but if
it doesn't work you can turn it off
again so feature flags are essentially
just like glorified if statements but
the status that if is set outside your
application so you would have your
existing code and let's say that box in
the middle of the blue bit is your
existing code you write this new being
weather provider and have that
implementation and then the flag
determines which which implementation
gets called so if you if you are ready
to go ready to change that code over you
turn the feature flag on and start using
this new code and eventually maybe you
just always use that new code remove the
feature flag remove the old code and
it's fine so this way it means that
changing things is much easier because
it's not it's not preventing anybody
else from deploying you've got this half
done unfinished code that's
it can still go to production because
it's not being called it's never being
called until you are ready to turn it on
and say this is this is right so this is
all about making it easier to make
changes and changes less risky which is
something you can do right now even if
you're not deploying a hundred times a
day this means that it's much easier to
deploy faster because you know that the
change isn't going to ruin everything
and destroy your production system so
from a technical point of view there's a
few things you can do the idea is to
make smaller changes and make them more
frequently but to do that you need to
make change BD so test-driven
development regulatory factors some some
kind of testing strategies that you can
use just to make sure that the changes
you make are more likely to succeed and
less likely to introduce bugs into
production so people trust them more
using abstraction and dependency
injection is a great way of actually
making change easier because you're not
replacing any code you're not
overwriting stuff that's already there
you're implementing it in a new like
implementing a new version of it and
then when it's ready to go you can say
right now use the new version this is
generally a really worthwhile thing to
do and then of course feature plagues as
well if you can do that now again you
don't need to expose these flags to your
managers or to your department heads or
anything like that this can just be a
feature flag that sits in a
configuration file and even when you
compile you can set that flag to true or
false and just release things it doesn't
have to exit your kind of development
environment it can still be a purely
technical thing so this is that's just a
few things you can do
even if day to day is just development
and you don't have a lot of power if you
have a little bit more control over the
way that your development team works or
even the way that you work as a
developer and then there's a few other
things you can do a lot of the problem
with changing the process especially of
development teams and in established
companies that have established products
is that you know people use excuses like
this is the way we've always done it or
we can't do that here because something
something something
No all of these basically just translate
to it's too hard and I want to do it
making making changes to the way you
work is is pretty difficult and it's you
have this momentum you've always done
things a particular way now I have to
learn a new task it's really difficult
I've been reading a book lately actually
which talks about this and the idea of
when you when you explore new things and
when you just sit back with the things
that you know and this the idea of older
people are more established people in
the industry saying I don't want to
learn that new framework because you
know it why are we always changing these
things I just like the way that I work
and then that's a legitimate decision
that people who have been in the
industry a long time like I don't want
to learn angular 2 or angular 4 or
whatever it's up to now is probably
change while I've been on stage um I
don't want to learn that because I know
the way that I work and it's not worth
investing my time and that's really what
this is I don't want to change the way
that we work because I mean I've tried
heaps of stuff I don't want to learn a
new thing um that if you want to
actually as a company if you want to
actually compete the bit better you need
to start doing this stuff now it doesn't
mean that every single developer in the
organization needs to be on board
because they won't as long as there's
somebody driving up who who can show the
benefits to people who are skeptical are
going to end up being dragged along or
they were self-select out of the
organization as being in organizations
before where this exact kind of thing
happened where we were like we need to
change the way we work got heaps and
heaps of resistance from people who had
been there a long time and eventually
once the change is happening anyway they
either go along with it or they go and
find another job it's not ideal
obviously you want them to stay but they
can self-select out of this if they
don't like it the number one thing with
this as well if you say well it's too
hard in our organization because
something something something you're not
your organization is not a snowflake
right it's not the one organization that
this stuff can't work in
if Microsoft can make a change so that
they had 70,000 developers now using git
and one engineering system doing trunk
based development then they move to the
windows codebase over to get and now
they use the wing that the people who
have been working on Windows are now
working in get they even had to write
like a git virtual file system because
it didn't handle the size of the windows
codebase which by the way is about 270
gig not of compiled code that's 270 gig
of source code I it doesn't handle that
very well
natively so they wrote this whole get
virtual file system thing just to
improve the usability of it so if
they're able to do that stuff then there
are you know there are people out there
who are who are finding it harder to to
do this kind of stuff than the newer
company is it's just a matter of
actually going to do it I'm
interestingly that git virtual file
system thing the reason they had to do
that is because a git clone of the
Windows repo to twelve hours which is
not great for productivity even a git
commit like if you made a change in you
commit it that was half an hour it took
so they had to make these changes and
just to operate but they can do it so
there's a company right now who's who's
finding it harder to do DevOps then your
company will and they're still making
inroads one way that one way that this
can succeed is trying to get back to
trunk based development the idea of lots
and lots of branches and people working
on independent bits of code that never
really get merged and everything's a
disaster when it does merge that is
really bad for for a DevOps process like
you need to be able to deploy basically
as fast as possible and if the merge
process is weeks of effort then that's
going to slow you down so ideas like the
continuous isolation which I spoke about
in the last one where your branch is so
isolated from production from the master
branch story that it's really really
hard to merge that back
and this happens with long-running
branches and with complicated branching
strategy so that diagram represents get
flow which is actually not a bad bad
branching strategy it's just that it can
get quite complicated there's you know
feature branches that get modes back
into devs and then those get nodes back
into a release branch and then the
release branch you know that gets
released and then there's a main branch
that has patches against it
it gets complicated and the tenancy as
well is to defer this kind of merge
because the merge is hard like the merge
is the hardest part of any of these
branching strategies which means that
you should do it as much as possible
which sounds a bit counterintuitive but
they're sooner you do it the easier it's
going to be so the best way of doing
that is to be developing on that same
branch as much as you can feature
branches and topic branches and stuff
like that perfectly fine but just don't
let them sit there for months at a time
try and develop on the same trunk based
development my trunk branch as everybody
else as much as possible that will allow
you to speed things up it means that
when you comes to deployment time it's
not a case of well I'm not looking
forward to this merge and the testing
strategy that needs to come after it
because it's going to go horribly wrong
because it has every other time you know
ahead of time that um that node is going
to work because you've been doing it
constantly um the other thing in terms
of your process is to automate
everything you can so if you do a task a
handful of times like build copy those
files to a server or to a test server
restart is something like that that's
something you should automate and that
allows you to just write code I guess
developers if that automated process
means that you can get stuff out to a
test server automatically immediately
that's going to free you up so easily
for for actually doing the job that
you're hired to do and if you so we're
talking again about politically powers
developers so putting in this automation
is something you can do as long as it's
kind of local and
and reserved to you you may not have the
political power to say we need a build
server so let's you know provision a new
VM this is stuff that you may just not
be allowed to do so tools like team city
and octopus for example can be installed
locally if you're using TFS or Team
Foundation version control they have
build servers and release release
servers in them so you're already paying
for it you may as well start using it
but yeah if you can't do that stuff then
you can spin it up locally you can run
some things locally have a pipeline that
just sits on your machine which is not
ideal but at least you know you know
ahead of time that you've broken the
build or that this deployment isn't
working anymore you need another step um
if you have it's like Visual Studio
Enterprise or something now not MSDN I
can't remember I'm looking at the
Microsoft people because I don't know
these things yet if you have these kind
of resources you have an azure account
right now with with money in it you can
use that to just spin up VMs try some
stuff and then shut them down again you
can restrict this stuff pretty
significantly too so if people are
worried about you deploying deploying
your half-finished application out into
some public cloud
there's network security groups that you
can set up to really shut these things
down so it doesn't actually go outside
your organization if you want to but
using Azure for just quick provisioning
of servers and being able to write and
code commit it and it gets to a running
server so you can test it out it's
really powerful and can speed you up in
terms of your process the idea here is
to create this pipeline so you're just
writing code and then the rest of it
kind of happens and a pipeline is a
great opportunity to to add to what we
were talking about before making change
easy by knowing immediately when
something's gone wrong so there's all
these phases during a good pipeline
where you have the opportunity to make
sure that everything is okay so you know
a build phase does my code merge with
everybody else's code and compile
do all my test bus when I deploy it to a
server did that work did the test still
pass can I talk to the database is there
some schema mismatch that I didn't
notice and then that means by the time
you get to production you've already
tested the code as well as the
deployment process you know that the
deployment to production is almost
certainly going to work well not really
but you know the deployment of
deployment to production is very very
likely to work because you've done it
before right so having this pipeline
allows you to basically stock the world
if something goes wrong and not have to
do it in a manual way so the idea of
having this pipeline that does
everything for you and all you do is
write code and you'll be alerted if
something's gone wrong with that code
that you weren't going to expect rather
than waiting until your deployment which
is three weeks later all goes wrong and
you realize it's because the
environments are subtly different
between production and your local dev
machine has anybody installed vehicle
studio on a production web server by the
way I'm putting my hand up because I've
done it a while ago obviously yeah which
is I mean it's a solution to a problem
you deploy to a production and it
doesn't work because you're using
resources worked perfectly fine on my
machine what do I do I'm just going to
install Visual Studio on production
having a good pipeline means that that
emergency kind of aren't it worked fine
here but it doesn't work in production
that kind of goes away of it because
you've done the deployment to a
production like environment and you know
really early that this isn't going to
work so yeah the idea of stopping the
world if something going goes wrong
before you get to production is pretty
old so hum this guy's Sakichi Toyoda who
is the kind of founder of Toyota car
company he was a prolific inventor and
invented a power loom
so as bloom being like a I'm not really
up with this stuff but a loom basically
being a weaving machine right something
like that where you have lots and lots
of thread and you you have this shuttle
that goes back and forth and builds a
Capitol or something I don't know I'm
clearly not my not my area of expertise
so these automatic machines to do this
weaving had been around for a while the
problem was they basically needed an
operator at each of those machines even
though they were automatic because
something could go wrong and the machine
would just keep running and stuff would
just you know you'd waste a ton of
thread because the Machine didn't know
that there was something wrong to stop
so his big invention was this power loom
which stopped as soon as there was a
problem in other words this pipeline
we're talking about this was kind of one
of the really early implementations of
that idea
you didn't need an operator at every
machine anymore
you had one Operator for a factory floor
a loom would stop working because you
know the thread got tangled or something
like that he could go fix that and then
start the process again so stopping it
as soon as you possibly can is the idea
it's been around for a long time the
next thing I'd say we're done process
just to change tack a little bit these
are a way of treating the software that
you write as well the way you work
working with an idea of you writing a
product rather than doing a project so
now this doesn't need to come from right
at the top the management can still be
doing projects right but in your
development team if you treat what
you're doing more as a product it means
you are thinking about your code as this
thing we're going to deliver and build
on and improve and end all that sort of
stuff the tenancy with with treating
your software development like a project
is that you feel like there's this
development phase and then you deliver
the project at the end and the project
finishes like a project has a fixed end
date so you don't think about it running
in production until that fixed end date
whereas if you think of it more like a
product something that evolves and you
keep improving on it it changes the
mindset in your dev team to we're
building this thing and we want to
improve it constantly there are
consulting companies back in Australia
that I used to work with and for
we're day 1 of a new project for a cup
for a customer day 1 is write hello
world and build a pipeline to deploy
hello world - if not production - like a
staging server so that's day 1 after
that point you're just writing code and
it goes all the way through the
production if you add a feature which
means that you have to do some more
stuff during your pipeline then you can
add a little bit to the pipeline then
but it becomes this product mentality of
what we were already deploying this
thing we just need to improve it now so
doing that internally even if it's just
within your dev team can be really
powerful for for that kind of mindset
and make it really easy to actually make
change and push change out to production
so in terms of changes to process so
first point is another snowflake number
one try and do trunk based development
so try and be working on the same code
base as everybody else because the merge
at the end is really hard and if you're
doing that merge just before you do a
deployment you're you're kind of leaving
that pain until it's absolutely the
worst time to to address that problem
avoid continuous isolation in favor of
continuous integration so make sure that
your code is integrating with everybody
else's code as early as possible and as
quickly as possible so this is a bit
along the same lines as the trunk base
development but make sure you're not
working on a branch that hasn't touched
master for a very long time because that
mode is going to suck make sure you
creating a pipeline and automating as
much stuff as you can which means that
you can just write code and you'll be
alerted really early or as early as
possible if something is going to go
wrong when you deploy and try to think
of the code that you write as products
rather than as projects now all of these
things as well it may sound like you
need management buy-in to do some of
this stuff but this can all be quite
local like this can be just stuff you do
in your dev team even if your pipeline
builds to a machine which just sits in
the corner over there and maybe doesn't
look anything
production it's not ideal you want
something that looks like production but
at least you know you can deploy it
somewhere automatically and you know
that when you can encode the break stuff
you'll be alerted that you can break
stuff so it doesn't really need to go up
the chain very far to implement some of
this stuff hopefully the organization
will get on board and they'll start
letting you you know deploy to your
production server or your QA server or
something like that
at which time you'll be ready you're
already doing that stuff locally so you
can start moving that needle now even
though you might not have management
buying yet speaking of management buying
it's kind of the next part so this is
the biggest problem really is that
managers have different goals to
developers and let's say they have
different skills to develop as well
essentially they have their own
pressures and their own requirements
they basically are under pressure to get
the dev teams to write code and to
deliver features they also need to know
exactly when those features are going to
be developed which is a kind of eternal
IT problem the UM Hofstadter's law or
something like that which is something a
task will always take longer than you
expect even when you take into account
Hofstadter's law so it's a nice
recursive thing um so the idea of
developers saying oh this is going to
take this long but we better triple that
estimate because we know it's going to
take longer and then you only slip by a
little bit so they want to know this
stuff in terms of the intricacies of how
you actually write your software and
deliver it and things like that
that's totally they don't care about
that at all so why would they let you
spend your time building this pipeline
and when you should be like moving this
ticket from this column to this column
like that's what they're paying you for
why are we wasting our time sharpening
the saw
rather than just chopping the trees
right it's a little difficult to make
those arguments sometimes not least
because software developers are
notoriously not very good at
communication right and managers have
their own kind of language this business
languages buzzwords and things like
we have our own buzzwords and there's
not much overlap between the management
buzzword and the developer buzzwords so
making these changes is a difficult
communication problem you need to be
able to communicate why this is
important why we should spend our time
on it and what the advantages are and
things like that most of the change
that's happened in software development
and IT in general kind of follows this
pattern of analyze what's going on
acknowledge that there's a problem with
it and make an adjustment to fix
whatever that problem is so if you think
about everything like agile was a with a
acknowledgement so it analysis of how
projects were going an acknowledgment
that we can't plan everything upfront
and be correct when it goes to
production for example and then an
adjustment to how we work well maybe we
should do smaller changes and little
little iterations and things like that
even things like virtualization was went
through this cycle like an analysis of
well it takes a really long time to
build a new machine we acknowledge that
the problem now how do we adjust how we
work to fix those problems and then
containerization it takes that a little
bit further so this cycle is is the
thing that leads to change the problem
is the acknowledgement that this is a
problem and the adjustment is not
necessarily something that you as a
developer and as a politically powerless
developer can affect you can however
really affect the analysis stage so if
you start feeding your manager
information to prove that there is a
better way of doing stuff or to prove
how much time is being wasted with
governance and bureaucracy and things
like that that can at least push them in
the direction of acknowledging that
there's a problem so coming in at the
start is a good way of starting to
encourage change even if they don't
quite understand the intricacies of of
what you're doing day to day the first
thing you need to do though is actually
measure stuff you can't fix what you
don't know is broken like an old adage
so measure what's happening in
production measure your mean time to
whatever so mean time to repair
in time - what do you want to mean time
to repair mean time to deploy mean time
- whatever so so measure how long it
takes from the time that you commit your
code all the way through to when it's
running in production that is a period
of time that you should be able to
measure and save your manager this is
how long it takes to do this stuff and
then if you can measure how long the
different stages in that take that can
go a long ways for a long way towards
the manager kind of understanding that
then maybe there is a problem here if
you say it took me like 12 minutes to
fix this code but then it didn't get to
production until six months later and
the reason is there's this process that
happens we had to wait for this thing to
happen we were blocked on this other
process you know feeding this
information actually coming forward with
data on this stuff can be good for
convincing your manager that you need to
change kind of a key with this as well
is that you need to convert to a story
that your manager understands one of the
things that I've said in the past is
that if you tell your manager there is a
risk that something will go on it will
go wrong okay that doesn't translate to
anything actionable if you say oh the
way we're doing this like we're not
writing tests there is a risk that we're
going to introduce a bug and it's going
to cause big problems they're like moves
down either bug like why are you writing
bugs stop that but if you say look based
on the data that I've collected so far
we're introducing this many bugs like
we're trying really hard to prevent that
but this is what happened so we're
introducing this many bugs I would
anticipate that if you extrapolate from
that at some point we're going to
introduce a bug that does this I would
say you know 90% possibility that we're
going to introduce a bug that does this
that brings it down for six hours for a
bring production down for six hours
you know how much does six hours of
outage cost this company so we could
write tests and it might increase our
development time by 50% but in terms of
developer salaries is that better than
this loss of income that you get from
being out for six hours every
you know two months or something like
that now I just made those numbers out
just then and you can do that too it's
not actually apologies to manager to you
but it's not actually that important
that you're completely correct with your
estimations here as long as you show
you're working and it's believable right
that this is like I'm not saying lie to
your managers right but you know you can
say things and not do truthful
it means successful for several people
in very high positions at the moment in
different countries the point is the
point is if you can if you can convert
to a language that they understand
you know developer time spent waiting
for a particular team to do something
whether you can't be productive or but
like the frequency of bugs and the
outages that that caused that causes
turn that into a money figure or a time
figure or something which is universally
understandable rather than talking about
risk
I think ISM is really powerful and one
thing as well I just point out this
tweet so Jeff lisanova mentioned
something about he'd obviously been
asked a bunch of questions about how do
I actually like convince my manager that
I should be writing tests and his
reaction and Donovan my new bosses
reaction is more or less why are you
asking permission to do your job
properly I that should just be what you
do that's how you write code and if
they're not letting you write your code
properly then that's not a great place
to be working you've got to have some
freedom in how you're writing your code
I would even go so far as to say if
you're in an organization where they
don't let you write tests then leave
like that is a terrible organization to
be in you should at least have the
ability to do your job the best way that
you know how so don't ask permission to
do stuff
one of the corollaries of this is if you
estimate that something is going to take
you a particular period of time like
three four hours and you finish it in an
hour maybe don't tell them that you've
finished it yet and work on some tests
or build a bit of a pipeline or
something like that
I mean if your micromanage to the point
where every single hour needs to be
accounted for then again it's not a
great place to work but just doing this
stuff and then asking for forgiveness
later is probably a better idea it means
that you can start doing things properly
be proud of the work you're doing and
not have to ask permission to write your
code properly anyway that's a little
rant sorry the other thing which is
really effective with this and it comes
back to the monitoring and converting to
UM to money and things like that it make
it really clear that the business is the
bottleneck not the developers so that
example before of it took me 12 minutes
to write this code and then six months
to deploy because you have this process
in place so I think a told a story
earlier about a DBA at a government
organization I worked with who
accidentally runners ran a script
against production and brought
production down so we're supposed to run
it against the test environment ran it
against the production database brought
production down took us about 10 minutes
to work out how to fix that so here's a
script that's going to fix this problem
but then it took six hours to find all
the managers who needed to sign off on
this thing so productions down for six
hours not because well I mean because of
the mistakes sure but it could have been
fixed immediately it's just that the the
waiting for people to sign things off
and this process made it really hard to
actually implement that fix so if you
can make it really clear that your
manager is the bottleneck or the
business is the bottleneck and not the
developers then that's pretty that's a
pretty good scenario to be in it's going
to start adding to that analysis part of
that and analyze acknowledge and adjust
part now all that stuff doesn't work and
your manager is kind of you know still
skeptical of doing anything properly
I would suggest showing that manager
some Gardner because managers love
Gardner SCADA is just one example this
is like a research organization they
publish papers about you know here's the
way that DevOps should work in an
organization and he
the you know top ten news I don't even
know whether they do the clickbait
titles but top ten reasons you should
hire something or other in this position
you know all of this all of this
business publication stuff the good news
is that all of the literature like the
the business journals and things like
that they're on our side now they've
actually started coming around to the
idea that doing things in a kind of
DevOps way is genuinely beneficial and
they have figures around this they have
research around this to say this is
actually correct
even better so here's one example from
Gartner
there's an article they've got called
the science of DevOps decoded and in it
Gartner's research director has this
sentence like towards the top the bold
bit followed by a plan to do things
differently to take the country and
company into the future I'm doing things
differently does not mean you know still
doing things the same way but don't make
that mistake next time it means changing
your process so if you can start feeding
them this kind of literature this alien
and the business journals that you read
are telling us that we need to do things
differently
again that can kind of kind of help out
a bit there's a state of DevOps report
that gets published every year um by an
organization called Dora's its DevOps
research and assessment as well as
puppet I mentioned it in my last talk
and forgot to mention the puppet does it
as well so they collaborate and produce
this thing is supported by a whole bunch
of other companies as well it's produced
by Nicole fours Grimm who is kind of a
genius in this in this area statistician
and actually gathered all this data from
27 thousand companies every year for
this thing as well as jazz humble who
wrote the continuous delivery book and
the DevOps handbook I think it is and
Jean Kim who wrote the Phoenix project I
think I got all that right anyway if you
haven't read the Phoenix project by the
way it's really good as well that's
something else you can just leave on
your managers desk
maybe they'll read it and say we need to
do things differently
and yeah if you make it sound like the
managers idea that's also another tip
that I don't have in here but generally
if you make the manager feel like it's
their idea to change the way things work
and it's much more likely to take effect
anyway the 2017 DevOps report which I
think that released last week around
middle the middle of last week has all
of these statistics in it essentially
they categorize these 27,000
organizations that they interviewed into
low performers median performers and
high performers from a DevOps point of
view and high-performing DevOps teams
are ones who can pretty much deploy to
production on demand there's always a
version of their application that they
can deploy at any one point in time this
cycle time between actually fixing
something and getting out to production
is measured in minutes or hours not
months so versus like the low performers
who maybe deploy once every three to six
months for example the stats on this are
pretty impressive especially things like
that they spend like 44 percent more
time on new work meaning that idea of
your job is just to move your ticket
from here to here like you can do 44
percent more of that if you're starting
to do this DevOps stuff properly so
these kind of stats can go a long way to
convincing management that stuff needs
to change as well the Gartner even had
an a prediction so Gartner does like
future views of stuff so they do
predictions as well I think they
predicted that 50% of CIOs who don't
make organizational change to do DevOps
stuff 50% of CIOs who don't do that are
likely to be like let go by their
companies in the next 12 months that's a
hell of a prediction I if you can say to
your CIO hey if we don't do this you'll
probably get hit fired that's I mean
anyway you're probably not in a position
we can do that but that is pretty
convincing I think anyway working with
manager so there's a few different tips
here um think about the fact that
this change only happens through an
analysis acknowledgement and adjustment
kind of cycle and try to affect the
analysis stuff as much as possible
measure everything you can mean time to
actually get stuff out make it really
clear that the process is getting in the
way of moving stuff to production which
means monitoring and then doing a cast
to money or like putting it in terms of
the that management will understand so
money and time is kind of a biggest
thing there um try to not ask permission
to do stuff just write tests and if they
ask why your estimates have slipped
you're just saying well the bugs have
gone down as well right or just say yeah
it's a complicated thing you wouldn't
understand so but don't ask permission
to do your job properly I have a bit of
confidence in the fact that you're your
employee because you are a great
developer right if you think that this
is the right way to do something then
they should let you do it that way so
just do it and if they bring it up later
know deal with that problem then I make
it really clear that the business is the
bottleneck if the business is the
bottleneck and if all else fails hand
them Gartner reports and business
literature because it's actually on our
side in this respect well so the last
little section was just kind of a bit of
a butt so you've got to be aware that
even as you start to do things better
and and be able to deploy more
frequently and make these changes not
everything is going to be rosy you're
not going to see benefits really really
early
I showed this graph in the last talk as
well but this is from the 2016 state of
DevOps report and it's the it's a band
of the change failure rates so the
number of changes so the percentage of
changes that go in that sail solo
performers fail about between fifteen to
thirty percent of the time so 15 to 30
percent of their changes go bad if
they're a low performer which means
they're deploying every six months or
something like that
medium performers which can probably do
which deployed between days and weeks or
something that's how fast they can get
stuff out
it actually gets worse for them so as
they're trying to get better at DevOps
they actually get more failure happening
this is a problem especially if you're
just starting to try and do this stuff
better if you're if you're saying to
your management hey we need to do DevOps
because it's hugely beneficial and we'll
get all of these benefits from it and
things start getting worse you that's
very difficult to convince them that
this is that you're going on the right
path so you really need to be aware that
this is going to happen one way of doing
that which I'll talk about and set is
just making sure you make small changes
so don't try to do this as a big bang
thing right now we're doing DevOps fix
one thing at a time
do it really carefully and expect to
fail and fix that failure and things
like that the good news is when the 2017
version of the state of DevOps report
came out it changed a little bit so it
turns out that median performers in the
2017 so they were actually doing almost
as well as high-performing teams now I
think this is probably because the
tooling has got better and the problems
that kept occurring with people just
starting to do this stuff have gone away
a little bit because we understand a
little bit more about what problems can
be there so it's not all bad news so
this whole like that it's going to get
worse before it gets better
now the literature doesn't support me on
that either but the message is still
there that you still have to move slowly
and expect that things aren't going to
go ideally every single time and build
that into your convincing strategy as
well don't say if we start doing this
everything is going to be amazing
immediately be aware that it probably
won't
it'll it's hard to do all right so I
kind of went through these these four
things the technical changes so it
changes to make your code easy to change
basically so things like abstracting
stuff away actually writing tests around
things to mean to make sure that when
you do introduce a bug you know about it
as early as possible process changes
like trying to work on the same branch
it means that these big merges just
before
builds aren't going to be as much of a
problem everybody is working in the same
same direction and even like treating
your your code that you write as a
product rather than as a project project
has an end date so you don't worry about
it's running in production until that
end date a product though you start to
think about it as a thing that you
deploy straight away and then improve
speaking to managers is a little bit
there's a few different things there
make them aware that there's a
bottleneck just do your job and don't
ask permission to do it properly
give them literature what else was there
a few other things so a few little
strategies there but be aware that it's
not all going to be amazing
right right out of the gate so make sure
you can cope with things going wrong so
how does problem with some organizations
as I say we're going to do DevOps now
let's spend a month and do it all
properly and then at the end of that
months do is stuff is still going wrong
and they say well that was a waste of
money let's just go back to the way we
were doing it you really want to avoid
that and the only way to do that is to
do things really gradually and carefully
so hopefully there's a few things in
there that you can actually take back
and start using particularly the
subversives kind of management stuff I
think people like that and if yet
hopefully there's a few things that you
can take and it will improve situations
at where you work as well so thank you
very much so I think there's like five
minutes or so for questions yeah if
anybody's got questions I'm going to
move to the back of the stage because
then I can see people yeah
so I mentioned the change management
boards that had other product business
boards so I'm first to me that I know
what that is and isn't
right so the the board that decides
what's going into the product what the
product is made of and things like that
Oh yep so what the what the features are
for each release and what what we're
working on next and things like that so
how do you deal with them right so
dealing with the people who decide the
work that you have to do is difficult to
do and if you don't have any control
over that as long as they're feeding you
work one of the ways that you could
probably convince people in that role
that things need to change is again make
them aware that they're the bottleneck
you're like we're pushing this stuff out
of production what's next what do you
want us to do next and if you're pulling
that work from them they're like oh okay
well maybe we need to be a bit more
reactive the other thing is the the
measuring stuff that's happening in
production so I was talking about it
there in the context of measuring how
long it takes to get changes out but
measuring usage in things like that in
production is really really handy if you
release a feature that they have decided
is really really important and you can
come back to them and say yeah this
thing that you made us spend all this
time on by the way nobody's using it but
people are always in this area and
clicking around it looks like they're a
little bit lost maybe there's something
we can do there I mean that kind of
measurement is really powerful for for
an organization to start doing some of
this stuff but I guess from a
development point of view as long as
they're feeding you tasks they're
feeding you things that you need to do
then you can still deliver those things
at a more rapid pace using these
developed techniques yeah
did that kind of enter
awesome any other questions
everybody's hungry interesting to eat I
think awesome yup
yeah so have you handled developers who
don't believe in this stuff but yeah so
the testing stuff and the deployment
space and the integration stuff I think
to some extent if if you could try to
bring people along with you and they are
just not following like they just don't
care like we don't need to change this
at all why am I putting in all this
extra work why am i learning these new
things as long as there's some people
who can kind of just do it anyway either
that will be forced to do it like
they'll be forced along that journey
with you and hopefully buy into it by
seeing it being effective but if they're
not and they're just hating it and
resisting everything sometimes they kind
of leave or decide that this isn't the
place for them so I was in consulting a
couple of jobs before and the first
first gig I had as a consultant for this
company I got brought into an
organization where and they thought we
were basically brought in there because
the developers didn't agree with each
other about how they should work and the
more senior developer said we should get
these consultants in because they're
just totally going to agree with me and
we went in there we did not agree with
him he was operating very much in a I
just do the code that I do and then I
have my own stuff and I'll build it and
if you break it then that's your problem
they wanted to start doing scrum like
the organization had heard about scrum
and so we tried to train them in this
and this one guy was just this is the
stupidest thing ever why are we doing
this I'm not I'm not going to be a part
of it we tried really hard to get him on
board in the end we ended up putting him
in his own team and everybody else all
the other developers were doing scrum
and he had his own stuff it was still
painful because he was still working on
the same code base but everybody else in
the company was on board with this being
except for this guy eventually the
company decided that they needed to
restructure
to fix this problem so they restructure
to change the job titles and things like
that and made everybody reapply for the
new version of their job and this guy
who was stubborn was like no way I'm
applying for my own job how dare you
like when I see an apply for your own
job then you can't get it and so he
didn't and he left so I mean really he
self selected out of it like the whole
company was doing this stuff he was on
the other he's in the minority he's
going to eventually say well this isn't
for me I can go somewhere else
um so yeah it kind of fellow will get
out of the way kind of thing it's
supposed to be lead or get out of the
way but you know join the crowd or get
out of our way and people will do one of
those two things in general so that was
long-winded as an answer yeah
yeah
so the comment was it's really important
to find the stakeholder find somebody
with a bit of power and they like what
somebody who's driving this stuff and
ignore the other people yeah and that
can be you even if so this is about
politically powerless developers but if
you have a junior developer who's like
we need to try this stuff and they do it
and you see it succeed and you like I'll
tell you well so as long as there's
somebody there with the drives to
actually make this change or somebody
who believes in it and they push at it
people will come along I think if stuff
works then it works I mean you can't
argue that yeah yeah good comment point
awesome all right I will let everyone go
you should eat
thank you everyone and yeah have a good
rest of the conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>