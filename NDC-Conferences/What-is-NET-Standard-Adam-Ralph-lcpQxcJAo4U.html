<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What is .NET Standard? - Adam Ralph | Coder Coacher - Coaching Coders</title><meta content="What is .NET Standard? - Adam Ralph - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What is .NET Standard? - Adam Ralph</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lcpQxcJAo4U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">for those of you don't know me my name
is Adam Ralph I work for a company
called particular software where the
makers when service bus I'm not going to
talk about that too much
but I will say that particular software
is a 100% remote working company so we
do not have an office everyone works at
home and I originally come from the UK
I'll be living in Switzerland for a very
long time but right now I live in this
this is actually my home and my office
so a couple of months ago my girlfriend
and I decided to take the whole remote
working cling on the road and she's now
a remote worker too and we're going to
see how that goes for a few months and
if you're more interested in that
hopefully when I get back from Oslo I'll
at the time to start
I've finally start my blog about it and
I may well do a talk about this next
year if you're interested in seeing how
this works and what the tricks are that
you need to make it work back to more
relevant things I look after a few NuGet
packages on nougat gallery and these are
probably the most the more interesting
ones fake it easy is a mocking framework
which you may have heard of X behave
dotnet as an X unit dotnet extension
like guard is a guard clause library
everyone knows what one of those is it
allows you to write things like God
against null through in your methods and
there are hundreds of these things but I
find it really useful to maintain a
guard course library because it's a
really trivial package with one liner
one file of c-sharp and it allows me to
try out things break new things like
project Jason and the new CS proj and
multi targeting and things like that on
a really trivial package which I then
release and people actually use so if
you want to play around those things in
real life with it with an easy package
then startup agar calls library okay a
few more won't hurt and in my day job I
look after the
rabbitmq integration for rent service
bus because then service bus works
across men
different transports RabbitMQ is one of
them and it's the one that I happen to
look after in my day job and in terms of
dotnet standard support fake it easy
already does support on this standard
version 1.6 and compared 1.0 like god
1.0 unsurprisingly and n services
RabbitMQ not yet that is work in
progress but more on that in a minute
so dotnet standard what is this dotnet
standard Sybil gotta get that right so
full how many Norwegians here yeah so
did I get it right more or less it means
I go dodgy it is it naturally means
rubbish annoys I don't really want to
say button that standard rubbish but
it's the only Norwegian word I know so
there you go
so what is dotnet standard in order to
explain what that standard is the best
way I think is to look at what problem
is trying to solve so in the old days
things are very simple we had the dotnet
framework so you compiled against the
dotnet framework and you ran against the
dotnet framework right really simple
these days it's not quite the same right
we want to run net core as net on dotnet
core on Linux and Mac OS and on phones
and on various Windows devices and does
anyone know what Tizen is yeah I saw one
comes up you want to shout it out what
is it
right so it runs on television ativ CLR
that Samsung have developed for things
like Smart TVs and smart watches and
things like that so it said another yet
another dotnet platform but the point is
that we want to run dotnet on various
different places now it's not the same
net as it used to be and when you're
writing a dotnet application you're very
soon going to pull down a gene and you
get packaged from the nougat gallery
you're going to you're going to do that
fairly early on lending trying
non-trivial application so you want to
be able to use NuGet packages in all of
these platforms and the solution for
that originally was a thing called
portable class libraries anyone remember
these I still around or as I like to
refer to it the portable class library
Fiasco and I'm sorry that sounds a
little bit harsh but I'll explain I'll
explain why so as I said in the
beginning things are very simple you had
the dotnet framework and that was it
and then this thing came along
Silverlight or as I noticed I misspelled
tits sliver light but that has a certain
ring to it so for the purpose of this
talk it's going to be is going to be
called sliver light and with these two
were these two platforms in place
immediately you want to be able to try
and use NuGet packages on both of the
platforms because the dotnet framework
had an enormous amount of NuGet packages
available for it maybe not so much in
this time frame but nougat was a thing
and none of those packages works on
Silverlight so the idea was that we
would take the intersection of the two
platforms because there was a large set
of types and methods what was what will
refer to as api's which exists on both
platforms and we'll call that profile 14
I do not know where the number 14 comes
if anyone knows what this 14 means
please tell me that they don't seem too
many real
these numbers but anyway that was called
profile 14 and the idea there is that
you compile against a set of reference
assemblies for profile 14 which I only
define the types which would affect
which were actually in both platforms
and then you will be able to take that
compiled package and install it and run
it on either of these two platforms
right kind of makes sense when you
introduce a third platform to the mix
dotnet core 4.5 and that anyone remember
that that was a thing at one time I
don't know what it was but yeah dotnet
call 4.5 was a thing and the
intersection of dotnet framework for
and.net core 4.5 was called profiles 5
and the intersection of all three was
profiles 37 for one reason or another so
there was not a there was not a profile
for the intersection of these two for
one reason or another so they don't
always exist
but only for some ok that that works
let's introduce a fourth platform to the
mix we've got Windows Phone 8 down here
and there is a fundamental problem with
this diagram can anyone spot it the
clues in the diagram I didn't have a
place to put profile 14 figure because
there's no one on this diagram where
there is an intersection of net 4 and
sliver like 5 right so it turns out that
this is embarrassing for me because I
did max at university I should know this
stuff I'll just go back one slide this
is a Venn diagram a Venn diagram is a
diagram that map's
all the intersections of all the sets on
the diagram this was first described by
a British mathematician called John Venn
from Hull in England and he described
these in the 19th century this is not a
Venn diagram because there is no
intersection of dotnet framework for and
sliver like five
all right this is actually an Euler
diagram and this was first described by
a Swiss mathematician called Leonard
Euler in the 18th century and this is
another example of an Euler diagram so
as I said I'm originally from the UK so
whenever anyone asked me where I'm from
I say England isn't that part of Great
Britain I say yes doesn't it part of the
UK yes it is so and and Northern Line
applies so all I have to do is verbalize
this very simple diagram and and and job
done so back to this this other oil a
diagram that we're trying to draw there
is no space of profile 14 so I then had
to resort to Google and try and find a
full set Venn diagram and this is what I
found this is actually a 4-step Venn
diagram all the instructions are shown
and I can reapply the platforms and
profiles and indeed we get a place to
profile 14 and we've got this new thing
called profile one through six which is
the intersection of all four and now so
ok great so that's four platforms right
it's still kind of understandable but if
you look at this list sorry guys in the
back this is not too readable for you
perhaps but this is actually one two
three four five platforms right there
are there are there are profiles which
support five platforms and of course
it's not possible to draw a Venn diagram
with five sets also I thought
so yeah when you when you draw when you
draw a diagram for five steps you have
to resort to this kind of Frankfurter
inside of wasabi bread roll kind of
thing but this actually does work you
can't be splint your eyes you can kind
of see the five sets and they didn't get
really silly this is six sets this is
seven sets starting to look quite nice
now and in in 2012 a really group of
really clever mathematicians from the
University Victorian British Columbia
drew for the first time ever a 11 set
Venn diagram which looks like that and I
reapplying our platforms to this I I
don't have I can't follow this anymore
I made that I made that profile number
up as good as any of the others Fiasco
right this doesn't work this doesn't not
scale and again apologies Fiasco's a
little bit harshly my apologies to the
guys that come up with this the
intentions are really good you know and
given the same situation I have may have
done the same thing but clearly this
isn't scale because every single time
you add a new platform you potentially
double the amount of profiles right so
and I don't think anyone really
envisioned it so many new platforms
would do it would be released so now
we've got things like net core and
Theismann and all kinds of things coming
out the woodwork so the number of
profiles that you need explodes and the
numbers will get longer or longer
eventually so a new solution was needed
and that solution of course is dotnet
standard I actually submitted this as a
logo but the team attained not me back
I'll try again so don't let standard
aims to do this instead of looking at
all the intersections between all the
balls from platforms are coming up with
a thousand and one different profiles
and I'm making it really really
difficult to decide which profile trees
and Target or targeting multiple ones of
them
you've now got just the intersection of
all the platforms this intersection
right in the middle and don't let
standard tries to take as bigger subset
of that intersection as it can so what
this is saying is dotnet standard
defines all the AP is or at least a
subset of all the AP is that are
available in every single platform so
not just the intersection net framework
and UWP or dotnet core and Samri and iOS
but the stuff that exists on all of them
just that bit in the middle what this
means is is you only have one thing to
decide the target a version of.net
standard and then your library will be
available on it will be usable on all of
these platforms and the versions have
got nest and the kind of look like this
each version of.net standard is a
superset of the version before it so
don't let standard 1.1 is dotnet
standard one with a few more api's and
so forth net want a standard one point 2
1 4 3 1 4 4 4 6 dotnet standard 2 is
actually a lot bigger so this is this
ISM that's why I drew a circle a lot
bigger and what that means in terms of
platform this is this these URLs by the
way don't bother trying to memorize them
now
just memorize the URL to my slide deck
which was on the first slide and on the
end slide and you'll be able to follow
all this so what this means is that for
dotnet standard one your NuGet package
that you compile against dotnet standard
one will be usable against all of these
platforms all of these platforms and
these versions dotnet standard 1.1 it
will be used against all of these and so
forth and so forth all up to 2.0 which
is dotnet core 2.0 which is coming for
the dotnet framework 4.61 which exists
and the next version of those other four
now one thing worth pointing out here is
that when you want to target a version
of.net standard don't go for 2.0 unless
you have to because if you target 1.0
your lot your package will be
it will be as portable as it can
possibly be all right so there's always
the temptation for us developers to go
for the new and shiny so if I'm creating
a new project I'm going to package it I
might think oh I'll get it done that
standard - that's the newest it's got to
be the best not true it's a trade-off so
I spoke to one I spoke to someone who
told me that when they create a new
project and they're going to package it
though first of all targets on their
standard one and when they find some API
they need which doesn't exist and on
that standard one they go to understand
one point one and then they lose support
for Windows Phone Silverlight Act which
helps it doesn't really matter and when
they find they can't find something and
don't set that standard 1.1 they go to
one point two and so forth but at some
point you have to make a decision about
where you want to stop or where you can
stop so it's a trade-off but lower the
version the more portability the higher
version the more api's you have
available but the less support ability
and of course the the ramifications of
that will change as time goes on right
now it really doesn't matter if you drop
support for these three platforms at the
bottom right the kind of dead platforms
but when you switch from or I don't know
1.2 to 1.3 you've you're shutting out
net framework 4.5 users which I guess
some people are still using so it's a
matter of trade off another thing about
the versions so 2.0 was originally going
to be a breaking change the declared
intent was the dotnet standard would
follow semver so when there's a breaking
change they would up the major version
and originally to point I was going to
be breaking with respect to 1.5 1.6 so
it rather looking like this it was going
to look like this so don't let standard
2 was going to cut out some api's which
were introduced from 1.6 and 1.5 but it
remained compatible with 1.4 and when
they announced this the community
through its toys out of the pram and
disagreed with
decision and that was actually reversed
and they decided to make it compatible
with 1.5 and 1.6 back to this but they
decided to keep the 2.0 right so
actually don't less than the 2.0 in
terms of December only needs to be
called 1.7 because it is just a feature
edition but they decided to stick with
2.0 because it is a major release and
more on that in a second the
documentation around this is really
really really good if you follow this
URLs like these you can see the
difference the actual difference is in
an MD file in github between each
version of the data standard so this is
the difference between 1.3 and 1.4 it's
very very small it's actually the
smallest difference at all and all I've
done here is a data type added another
type and added a few enum members so
that that's really good documentation
how does this work
right so the first thing is two separate
compilation from runtime these are two
completely different distinct scenarios
when you compile all you effectively do
is link your C shot your your C sharp to
framework dll's and compiler enter yl
you don't actually run anything
obviously and compilation is very simple
you have this thing called net standard
DLL and the next standard deal comes
with the version of.net standards and
all it does is as fine types it is an
empty is an empty assembly apart from
class definitions and method method
definitions now actual method bodies and
I can actually show you that quickly
just to prove it this is this is that
dotnet standard so this is don't let
standard to net standard DLL and if I go
into this say anything really at the
main right so just completely empty
these things these things don't actually
do any photos or events so most slightly
different array that's good luck
yeah after has to do
something in methods that return
something because you can't just have an
empty because then it wouldn't even
compile did you know you could throw
null interesting huh it's actually the
the the constraint of throwing only
exception type is a c-sharp thing only
the CLR actually allows you to throw
anything you could throw false you could
throw one two three
so clearly this wasn't written using the
c-sharp compiler this is generated
generated il and guessing but anyway yet
so that's that is that there's an empty
assembly and it's only used compilation
at runtime things are slightly more
complicated so this is say a dotnet
framework application on that frame at
14.6 let's say and this references our
dotnet standard class library now the
important thing to remember here is that
the definition of a type internet is not
just a system object it's the assembly
and the type name so it's say MS core
lib system object is the system object
that you know love the dotnet standard
class library is not looking at MS core
Lib system object it's referencing next
and dll system object however the dotnet
framework application recognizes system
object as being MS poor Lib system
object so what happens at runtime is the
CLR looks at the dotnet standard library
the dotnet standard class library is
pointing to not net-net spam of dll this
is not the net standard dll that was in
the previous diagram this is net
standard dll that ships with the dotnet
framework it's another net standard dll
all the types and method definitions are
the same but this assembly is different
this assembly uses type forwarding type
foldings been around for a very long
time I think since botnet 1 and type
forwarding is a way for an assembly to
say hey I've got this object when the
runtime ghost that assembly it says all
right
that tell me about that object says I'll
know actually it's in the seventh
Assembly over here as simple as that so
when the runtime says to the dotnet
standard class library oh you are a C's
oh you're returning system object which
is net standard DLL system object it
looks and that standard the office
system object this net standard DLL says
actually it's an MS core Lib up here
does that make sense yeah I see a few
nodding heads so just to show you what
that assembly looks like it is in here
and as you can see this is all right
this is actually the dotnet call one so
that diagram is exactly the same if
you've got a dotnet core app so dotnet
core also ships with a version of net
standard DLL that points back to its
assemblies and you can see here this is
a not net core app version of net
standard DLL and all its doing is tight
forwarding everything right there is
actually no there's actually just
nothing in it at all apart from type
forwarding and if I click on say action
it's actually pointing at system runtime
which is dotnet cause assembly that does
part of what Emma's call Lib does in the
dotnet framework makes sense more or
less yeah alright so back to this so
back to the version so I talked briefly
about dotnet standard - and as I said -
is a major release and the motivations
behind - were came from the feedback
that was given for dotnet standard one
the main feedback that was given for
dotnet standard one was good great but
limitations and paralysis and I'll
explain what I mean by that
so limitations you may have noticed in
this diagram here that these circles are
fairly big excuse me and this circle is
fairly small
and that is a reasonable representation
of the truth because dotnet standard
that the various dotnet standard one
versions only define real a relatively
small subset of the api's that are
available in all the platforms and the
complaint there was well look I really
want to support dotnet standards one of
the dotnet standard one versions but
there are just not enough API is there
for me to use
I just cannot achieve what I want to
achieve using done that standard one so
the idea of not that standard to is to
do something like this right the white
circle is now much bigger than it was
before and what this essentially does is
define a much larger set of API s and
what that has we also the another effect
of that is that it brings all these
platforms much closer together there is
a much larger set of common API I need
to they all need to support therefore
they are actually they actually come
much much closer together and we've now
got way more api's to target there to
use in our you know in our packages than
we had with Dauntless standard one and
the difference is vast there are
something like thirteen and a half
thousand api's which are basically
methods and properties in dotnet
standard 1.6 and don't let standard -
they're around 33,000 right so i think
it's some like a hundred and forty two
percent increase on dotnet son at one
point six which is quite huge and I
showed you this difference earlier
between net one point their standard one
point four and one point three if you
try and look at this for dotnet standard
two and one point six github just gives
up it is just they're just too big to
even show to even render so the
difference is vast so that takes care of
the limitations hopefully and and I
think it does I think now and don't let
standard to you've actually got pretty
much all of the api's that are useful on
all the different platforms defined in
dotnet standard to paralysis
so this is a very simple graph of nougat
dependencies so for instance fake it
easy depends on the cup castlecore
package n service bus rabbit obviously
depends on service bus and RabbitMQ
climb and service bus itself depends on
auto FAQ and surprise surprise Jason
don't let so the problem here is that if
I if you want to support not net
standard in your package you kind of
have to wait for all your dependencies
to support it as well
because otherwise you can't write if you
try and reference a dotnet framework
package from a dotnet standard project
that would just blow up and say system
objects is in the wrong place and things
like that and this is a problem because
the community is kind of waiting or
everyone's kind of waiting for someone
else to support on that standards before
they can support it we had to actually
had to wait about six months to support
buttonettes tandem to take it easy
but we have to wait a really long time
forecaster calls to support it and and
obviously everyone had to wait for Jason
gotta net right but Jason net does now
support on that standard so that's
probably sold and eighty percent of the
problem but this paralysis does continue
there are still packages which are
waiting on other packages which waiting
other packages you know you can imagine
dependency graphs can get quite deep you
can have four four levels the five
levels deep etc so the solution to that
is very simple you can reference
anything right you can now reference
from a dotnet standard package I don't
net framework assembly this actually
does work now and at this point I to
have to say well you know just go and
watch this video but the preview bits
were released about about a month ago so
I can actually show you this in action
now so let's give that a go
I'm running all the preview bits on a VM
which is here and we've got the solution
called dotnet standard magic now
we've got here is a dotnet core app and
a dotnet standard library I've got that
core 2.0 app.net standard 2.0 library
and what I'm going to do in here is I am
going to install I really old NuGet
package called power collections this is
a it's a pretty cool package it's got
some really good really powerful
collection types in it but the last
release of this thing was a very long
time ago I think it's like 2005 or
something and this is a guess we've got
it open here this is a dotnet to package
this is dotnet framework to not thought
that saying that business the thing from
or there you go it's this is business
from 2005 that's a really really old so
I am I am referencing a dotnet framework
assembly from a dotnet standard project
and I'm going to go and handle actually
use it using and that does compile with
any luck yes it has compiled I'm now
going to reference from a dotnet core
application I'm going to reference that
dotnet standard project and again I'm
going to use this so I'm just calling
into the net standard project with the
net standard class which exists there if
you're using statements and if I run
this
it works right so we've just we are now
from a dotnet core application calling
into a dotnet standard 2 project which
is calling out to an old dotnet
framework assembly right Perales has
gone because I can now build a dotnet
standard project referencing any NuGet
package which exists in the gallery
which supports not that framework right
that's pretty cool
now when I was doing this I thought well
why don't I just cut out the middleman
well I just cut out the next standard
library and just try and reference the
dotnet framework assembly from the
dotnet core out so this is completely
irrelevant to this talk because this is
this what I'm talking about on that
standard and this is just don't let core
but I couldn't resist the temptation so
let's give it a try so I'm going to add
and you get packaged again alright so
this is this is just a dotnet core
application right and I'm installing I'm
directly installing a dotnet framework
package and again let's just use it a
couple of using statements all right who
thinks this is going to work
almost no one who who thinks it's not
going to work more of you almost half of
you and quite a few undecided alright
let's give it a go
it works wow that was my reaction too
you can you can write a dotnet core
application now and the reference any
NuGet package it targets a dotnet
framework Wow
right hey that's pretty amazing yeah I
couldn't believe it but it actually
works so these guys have done something
pretty cool under the covers now one
thing I get asked at this point is well
what that's all well and good but what
if that button that framework assembly
cause something is not available in
botnet core right yeah that's the gotcha
right so I thought I'd give that a try
just to see what happens and this is in
the rather tellingly named no magic
solution so what I'm going to do now is
I'm going to reference n service bus
because M service bus does not yet
support does not yet target botnet core
or dotnet standard so that service bus
okay so it installs which is good and it
will eventually okay
and I'm going to go ahead and use it
don't worry about this code this is just
a general conflict boilerplate for and
service bus I'm going to some musings
again
all right so let's see if that compiles
and it does right compiles let's use
let's reference the next standard
project from our dotnet core app so this
is similar to the first solutions just
dotnet core app calling that standard
library calling dotnet framework
assembly and let's call into the dotnet
standard project from an that core app
were using and let's see what happens
no magic right so yeah we've got a
runtime exception in this case I was
actually hoping it was going to it was
gray actually call into a tight which
doesn't exist to find out what happens
there but in this case it can't we're
getting a system but configuration
cannot be found error because there's no
there's no equivalent of system
configuration in dotnet core so it blows
up so runtime exceptions is what's going
to happen so if you're going to do this
testing is probably quite important so
you know this is this is a this is a
great piece of magic but it is it is a
stopgap you know it's just to unlock
that paralysis it's just to just to
allow NuGet package support that next
standard early before though that before
their dependency support it but
hopefully in the future we'll have a
situation where all you get packages
support on that's standard and the need
for this kind of hack will go away so
let's see let's just have a look at what
oh yes I do try it I go to these URLs
those are the solutions
so something pretty built for you to
give that try and if you're going to try
it make sure you install dotnet core to
preview one before you do it I was a bit
confused about what had to install I
thought I could just install Visual
Studio preview and it would work but it
didn't you have to install this as well
and then you can use it in any in your
idea of choice and it should work so
what is this sorcery how does this work
right so again separate compilation from
runtime right these are the two
different scenarios you need to think
about compilation right so we've got our
dotnet standard library which exactly
right before is referencing next
standard DLL that hasn't changed we've
got our that is referencing the dotnet
framework class library and the dotnet
framework class library is looking for
MS core Lib okay in the.net framework
assemblies however this is not the MS
Court that the MS core Lib that is in
here is not the MS core Lib that you
think it is
it's one that ships with dotnet standard
right and again it's using tight
forwarding so let me get this straight
so I still don't have an intuitive to
follow the diagram to remember how it
works
but when the when you when the compiler
comes along and says oh don't let
framework class library you want Ms call
libs
system object it looks this special
version of MS core libbets in here and
because this was shipped by the desert
by the by dotnet standard it says oh
actually system object is in that
standard dll so it makes sense kind of
but that's how compilation works alright
and at runtime it's a bit more
complicated again this is all type
forwarding it's all this kind of type
forwarding magic and this is that so
this part of the diagram but these four
boxes at the top is the same as what you
saw before this is the dotnet core
application referencing the dotnet core
assemblies it's not a mess call
everything is system dot runtime is one
of the main ones there where I think
that's where system object lives and the
version of netstudy ll that is shipped
with dotnet core says the system object
is not actually here it's actually in
here right so that part of the diagram
works here we've got a dotnet framework
class library and that is looking for
system objects and MS core Lib these
dotnet framework assemblies are actually
shipped by the platform by dotnet core
so the MS call it that lives in here is
saying Oh system object actually lives
in system runtime up here does that make
any sense at all if there are certain
donning heads that's good yeah as I say
I always have to look back to the
diagrams to remind myself how it works
it's it is a bit complex but you know if
you want to try and understand a bit
more go grab
slides afterwards and have a work
through it and you know when you think
about how tight forwarding works it
actually does make sense and and it's
cause it's a great piece of magic so
that largely takes care of the paralysis
problem right because you can now
reference anything and in a nutshell
that's what dotnet standard too is it's
more api's 33,000 api's versus 13,000
and you can reference anything I put a
star here because anything's a little
bit of a lie the paralysis caught is
caused because the packages that exists
on the Newgate library reference they
did typically reference the dotnet
framework and portable class library
profiles so the platform's don't ship
those hack those hacking forwards bails
for every single platform that's out
there they tend to do it for the dotnet
framework and furred and for PC else so
the idea is that for any of the new
platforms you'll be able to pull down
the package which references the dotnet
framework or portable class library
profiles and that should just work so
it's almost anything so how do I port my
package so all well and good I've got a
done I've got a package which which
targets the dotnet framework how do I
port that to dotnet standard well
there's a really good tool called dotnet
API port and what this will do is it
will take your assembly and it will look
at all the pools you're making to say
dotnet framework API s and you can
choose which platforms or which versions
has not expanded you want to analyze for
and it will tell you what percentage of
the api's are available in each platform
that you need and this comes in two
forms it comes in again don't worry
about the URLs that are online you can
grab my slide deck later this comes as a
visual studio adding it's just project
right click analyze project portability
and this is actually I think going to be
bundled in the next version of Visual
Studio so you don't even have to install
it explicitly or it comes to command
line form you just point it at your DLL
and it goes off and reference it
analyzes it and it produces of all
things
an excel file I think you can make it
you can't make it out to HTML and Jason
as well Tamila but anyway this excel
file tells you something like this it
says n service bus targets net framework
4.5.2 and unsurprisingly the dotnet
framework 4.5.2 has 100% of the api's
that it needs but not net standard 1.6
and use isn't so good it only said not
net standard 1.6 only has 66 percent of
the AP is that n service bus requires
all right so 1/3 and missing not too
good dotnet standard to the situation's
a lot better
we've actually got 87 percent of the AP
is a tensor business needs available in
dotnet standard 2 so in that situation
what do you then do what are we having
to do for n service bus to support on
this data to which is our goal
well you can change first of all so
there are two things there are two types
of changes you can make you can make an
internal change where you might be
achieving something using some api's
which which exists in the botnet
framework but there are another set of
API m-net standard which can kind of do
the same thing so that's that's nice
that's an internal change no public
change to your API or you can make an
external change if you you might be
returning something from dotnet
framework which doesn't exist in botnet
standard and you might have to return a
different object that's a public
breaking API change so you're going to
have to rev your major version assuming
you're using sender the other thing you
can do is separate this is really useful
so for instance and service bus has MS
mq support built into the core because
that was the original original
underlying transport Emerson qnu exists
and windows so MSM Q support doesn't
exist in dotnet standard because it
makes no sense for Linux and Mac so what
we've done is we've taken the MS MQ
support and put it into a separate
package that's going to be the next
version because a lot of people don't
need MSM q
so that's a really good strategy if
there's some pieces there's some large
section of functionality which you know
only 50% of your users use the other 50%
don't take that out to a separate
package make that package skill target
only got that framework but make the
core target bill net standard so that
people who don't need that other package
will be happy running dotnet standard
that's a really good strategy and at the
end maybe just throw it away you know if
there's some simple you don't need or
you think is really irrelevant or you've
been looking for an excuse to get rid of
that API which is only 1% of people use
just may be in it check it out but maybe
you want to consider change and separate
before you do that API zone versions
of.net this is a really good resource
for when you actually want to make the
changes so one thing I didn't mention
was in API port in the excel sheet that
you get in the second sheet it actually
lists all the methods that you call and
it tells you which ones don't exist in
the platform's that you've analyzed for
and which ones do if you don't want to
find out well which shape which methods
and classes do I need to switch to this
resource is really really good this
actually lists every single API that
existing net on every single platform on
every single version of.net standard and
you can search for things like a data
reader and it will tell you a little bit
about it what method exists etc etc and
then it will also tell you what
platforms it is available on and you can
see that it's available in most versions
botnet core obviously every version
of.net framework it only exists in
dotnet standard - right so this has been
reintroduced it is one of those missing
api's in one point X has been brought
back so that's a really really good
resource right dotnet standard versus
net core the eternal question so the
confusion unfortunately still exists
between these two things and I still get
all the questions about you know what is
what is one what is the other I'm hoping
that during the course of this talk
has become more or less apparent so
dotnet standard is effectively a
contract dotnet standard says well if
you want to support dotnet standard you
must have these types and methods that's
effectively all that dot next and that
is it is just a contract to say that
which just outlines what you need to do
in order to support net standard it has
no no body of itself there's no
implementation of itself and there are
obviously various platforms which then
support on that standard dotnet
framework you WP xamarin iOS Samer and
Android
Tizen dotnet core right dotnet core is
just another one of the platforms that
supports it and unfortunately things do
get conflated together like for instance
this is the release schedule for dotnet
standard and they're actually sticking
to the schedule right this is actually
released on May 11th of May the preview
right snack bound middle q2 so things
are looking good for the actual RT M you
know I'm actually optimistic we're going
to get it in q3 but if you actually look
at this URL you don't actually see this
you see this right and this is actually
in the core repo and you know that
they're all listed together so you know
don't let poor and don't let standard do
get kind of conflated together in terms
of release schedule and and and timing
and that kind of thing and development
but they are very very separate things
you could release dotnet standard right
now without dotnet core and vice-versa
and this is just another way of trying
to represent this so David Fowler who's
who's here speaking about things like
asp.net core he put together a repo
which actually has an analogy to dotnet
standard than the platforms and what
he's done is to find an interface to
represent the version of.net standard
and then inheriting types from that to
represent the platforms so you can see
here that dotnet stand is 1.5 inherits
and dot nest and and 1.4 because botnets
end and one proposes superset
and dotnet core wrap inherits from gone
next standard 1.5 as as a marina and
Android on that frame but 4.6.1 Harrison
dotnet framework 4.6 and Harrison
version of.net standard and so forth
I hope haven't just confused you but
some people do find this analogy quite
useful that's another quite good thing
to look at and some feature platform and
this is a really important point because
in the world of portable class libraries
when a new platform came along that
would result in a new set of profiles
being generated and in order for my
NuGet package to support that new
platform I would actually have to
recompile it against one of those new
profiles and re-release it but the
beauty of dotnet standard is that my
package now it just supports this
version of.net standard and any platform
can come along and say hey I support
that version gotten that standard and my
package is now usable on that platform
right so that's why I've written here's
some future platform like Tizen can come
along and all the sudden you've got like
guard running on your TV alright which
is which is pretty cool so it makes
things much more portable and much
easier as NuGet package maintainer z'
don't let stand a 2.1 2.2 3 what's going
to happen in the future
so another thing I've been asked is that
every version of.net standard is bigger
than the previous one so does that mean
that as the new versions are released
it's going to put a lot more burden on
platform providers to support those new
versions that is our net standard and
the answer to that question is yes it is
going to put more burden on them when
2.1 is released it's going to have some
new api is compared to 2.0 and in order
to support 2.1 I'm going to have to do
some work and I'm going to have to
support those new API s if I'm to
support dotnet standard 2.1 however the
difference between net standard 2 and
nets 10 the 1.6 is vast and I don't
think there's going to
be as vast a release again the reason I
say that is because botnet standard 2
captures an incredibly large subset of
the api's which are useful on all the
platforms so all all the api's ring net
framework 4.6.1
that makes sense on mac and linux and
phones and TVs does already exist on
that standard - so what's not that
standard 2.1 going to be it's going to
be small it can be incremental right I
might be proved wrong but this is my
prediction 2.1 probably will exist 2.2
probably will exist but there will be
incremental change 3.0 I'm not sure if
there ever will be a 3.0 I mean the
marketing guys would probably disagree
with me but I'm not sure there will ever
be as a real technical reason to say 3.0
I don't think they're ever going to
break by the way they tried that with
2.0 and that wasn't much that wasn't
really received very well so the only
reason to have 3.0 is like well big
change loads of UOP is I'm going to
stick my neck out and so that's probably
not going to happen I don't think I
think there's going to be a reason for a
vast new set of api's is a vast new set
of API suddenly going to appear that
makes sense on all the platforms maybe
something like the new spam stuff that's
being developed something low-level like
that but you're not going to get this
massive set of changes again and there
is a dot though there is a body called a
dotnet review board which consists of
people from Microsoft xamarin and unity
and other other organizations and this
board very carefully considers new api's
for inclusion in dotnet standard so I
think what you're going to find is a lot
of really exciting new API is being
introduced in things like dotnet core
and then if those api's make sense on
all the different platforms you're going
to see them submitted to the board and
the board will say yeah okay that makes
sense on all the platforms let's bring
that in or no this really only makes
sense for you guys let's let's leave
that out so I don't think you're just
going to get loads of stuff being
chucked into the dotnet standards like
that because this review board is there
to sanitize anything it's going to be
added so how did I do
who here now thinks they have a
reasonable understanding of what dotnet
standard is awesome okay that's really
really cool that's almost all of you I
didn't ask that question you came in of
course but I'm going to give myself a
Bennett for the doubt and say that like
I did help out in that in that
understanding someone who here has a
good understanding of what dotnet of the
difference we've gotten that standard
and on that core as almost all of you I
do see a that's not 100% of you so I
guess some of you still have some
questions remaining so I guess we've got
a bit of time for questions if there are
only I mean does anyone want to throw
anything at me not right now that I
haven't answered it already yeah</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>