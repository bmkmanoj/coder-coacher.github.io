<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ETW - Monitor Anything, Anytime, Anywhere - Dina Goldshtein | Coder Coacher - Coaching Coders</title><meta content="ETW - Monitor Anything, Anytime, Anywhere - Dina Goldshtein - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ETW - Monitor Anything, Anytime, Anywhere - Dina Goldshtein</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ZNdpLM4uIpw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay hi everybody welcome just want to
say this is my first time at Embassy
also and I'm so excited to be here it
really is an amazing an amazing event so
as I said my name is Dina and I'm going
to talk to you today today about etw and
all of the cool things that you can do
with it
so etw is a monitoring framework so the
first thing that we're going to do is
that we're going to talk a little bit
about the challenges that we face when
we try to use traditional performance
and profiling tools and then we're going
to introduce etw and see what you can do
with it and how it addresses all of
these challenges that we have using
traditional tools and then what we're
going to do is that we're going to
embark on a very long demo or rather
multiple short demos through which I
will try to show you some and definitely
not all of the things that you can do
with etw
and which tools are available to you for
this purpose so let's begin as I said
the first thing that I want to do is
talk about the challenges there are many
profiling tools out there but I think
that one of the most problematic issue
with these tools is that they're usually
very invasive a lot of them actually
inject their code into your application
you know so that they can profile
whatever it is that you're doing and and
so that means that you have to recompile
your code or at the very least most of
the times you will need to restart your
application and these two together cause
quite a large overhead for example if
you're familiar with the Intel parallel
studio profiler it's really a great tool
but the lowest level of profiling that
it gives you causes an overhead of a
factor between 2 to 20 if I remember
correctly and that means that if you
have let's say a one minute scenario but
you want to profile then let's say on
average is going to take about 10
minutes to run
okay maybe we can live with that but
what if it takes about let's say five
minutes just to get to that point in
your application where you want to start
profiling well obviously that's not
going to pass now the next problem that
we have is even if the overhead is
inconsequential and we don't why middled
mind waiting and all that still in some
cases we just can't restart our
application what if your product is the
stock exchange or maybe your product is
some military system while in your
development environment you can restart
your application as many times as you
want you need to do whatever you want
with it
a lot of times on production it's just
not going to pass so we can't use that
and the last problem that we might
contact encounter is something that at
least from my experience developers
usually don't think about or don't care
about and that's licensing a lot of
these tools don't allow very
distribution to clients and that means
that if you use it on development it
doesn't mean that you can take it to
your client or I mean like maybe you
could just take it once for a one time
debugging debugging case but you
certainly can't redistribute this as
part of your application and even if
redistribution is allowed still you
usually buy one license for yourself or
maybe multiple licenses for your entire
development team but a lot of times your
product runs on tens hundreds or
thousands of production servers or
clients or wherever it is that your
product is the port so obviously you
can't buy licenses which are usually
quite expensive by the way for that many
machines so with that without population
in mind it turns out that there's a
solution for all of these problems and
it's not surprising because after all
that's why we're here talking about it
and that's etw so it
w event racing for windows is a
structured logging framework
incorporated into Windows which supports
hundreds of thousands of structured log
messages per second and of course it
doesn't have any of the problems that we
just talked about
it doesn't require any changes to your
application
it certainly doesn't require
recompilation but it also doesn't
require restarting your application in
fact you could just turn it on on demand
whenever you want without having to do
anything
and it's overhead is very very low if
you don't turn it on at all the overhead
of each cycle is a few cycles and if you
do turn it on then well of course it
depends on the amount of data that you
want to emit from this from this log and
one of the best things about it is that
it's actually all over the system as I
said it's incorporated into Windows so
you don't have to do anything to get it
it's just there lurking around your
system in user mode and kernel mode it's
in services it's an dotnet it some
drivers it's it's even in third-party
components in fact a while ago I found
out that even chrome can emit etw events
if you ask it nicely now although we
don't have to go into much detail in
order to understand the rest of my talk
I do want to spend a minute or two to
give you an overhead an overview of the
architecture and how egw is planned and
structured just so that you know you
understand how the tool that you use is
working so the three main components
that you need to be familiar with our
providers controllers and consumers
their names are pretty indicative
providers are those objects inside your
Windows system which are responsible for
generating the log messages for emitting
them from
locations in the code the controllers
they're the ones that you use to
start/stop configure all of your logging
scenario and consumer as well they
consume
they're responsible for logging
analyzing processing these log messages
the relationship between these three
components is it's not surprising what
happens is that the controllers create
an event session and this event session
receives events log messages from
multiple producers and for performance
reasons it buffers them into an end
memory buffer now the consumers they can
register on these events and consume and
analyze these events from the event
session now just one thing that I want
you to notice here is that from this
design it follows that in some cases
some events might be dropped because you
couldn't consume them fast enough or
there were too many of them coming into
the coming into the session so the
session actually holds the number of the
dropped events and you can configure the
size of the buffer pools to a larger
size if you think that it's necessary
for your scenario okay now this is a
screenshot from some of the providers
from the etw providers that I have on my
Windows machine the font is small it's
okay if you can't read it the point is
is that this is just a little part of of
all the providers and in fact on my
machine I counted slightly over a
thousand providers etw providers and
each of them can be configured with
different keywords and different
verbosity levels so there's there are
quite a lot of options that you can
configure and get exactly what you want
from the system so now that we have
no understanding about what etw is and
how its constructed let's do a little
overview of different scenarios where
you can use EDW to get information about
your system so I think that the most
common thing that you can do with ET w
is profile your application CPU wise
what does it mean CPU wise which are the
functions are the heaviest ones on your
system now what you can see here is a
screenshot of an application called
perfu we will talk about it in greater
detail later on for now just know that
it's an application that allows you to
easily analyze etw
log files and specifically in this case
you can see I highlighted two functions
one they both calculate prime numbers
one is managed and one is native and
together they take about 90% of the CPU
time of your of my application now the
reason I have here both managed and
native is that I wanted to show you that
this infrastructure allows you to
monitor and profile both managed and
native applications and that's very
important because obviously a lot of
times our applications are not purely
managed you can also use etw to get
information about garbage collection you
can get a list of all the garbage
collections that occurred in your
application how long they took how much
memory was was freed how much memory was
promoted what was the reason for the
garbage collection that occurred which
generation it was furthermore you can
actually get the call stacks of where
each such garbage collection occurred so
for example in this case we can see the
garbage collection was called an excuse
me 20 times due to GC add memory
pressure and that probably means that
our application is using a lot of native
memory
also garbage collection was called 13
times during allocating objects and that
means that probably our application was
using enough memory to cause pressure on
the CLR so that it felt that it needed
to invoke garbage collection while
allocating objects what's even cooler
than that is that you can get cold facts
for the allocations of each specific
object type so what we see here for
example is a screen shot again from
perfume of all of the places where a
certain WPF application allocated
strings and it turns out that this
application allocated a gig and a half
of strings and some indexing function
now maybe it's okay in this in this
specific application maybe it's not
that's not the point the point is that
for me as a developer of this
application this is very useful
information if I want to analyze debug
and understand memory traffic issues in
my application I actually see where most
allocations occurred and that's amazing
in my opinion you can also analyze long
startup times by getting information
about images which are loaded by your
application you can also get information
about the JYP's times you can also get
information about file accesses that
your application that your application
does again all of that is very useful
when you need to understand what's going
on inside now I will go back a little
bit to the CPU profiling scenario it
turns out the etw not only samples the
CPU but it actually provides all of the
information per core and that means that
you can analyze your applications
concurrency efficiency so this
screenshot is actually taken from
Visual Studio concurrency visualizer but
there are data that it uses to produce
this image is taken from etw so what we
can see here is an image of our course
and green means that the core is running
and red means that it's blocked so we
can deduce from this image that there's
probably something wrong with our
locking model because it looks like
although we have for course the facto
only single core is working at each
moment in time in here we can see
another image where it seems that
locking is better and the workload
distribution is better but it's still
not perfect because I can see that an
entire core is working all the time
while a different core finished its job
and half the time
so again egw allowed me to see this data
and understand that I have something sub
optimal in my application ok so that was
an overview and screenshots of what we
can get using etw let's now go into
little more detail into some of these
scenarios so going back to perfume
perfume is act as an application by
Microsoft it rather recently became
open-source so it's available and github
for you you can view both the you can
just download versions or look at the
forest code whatever works for you and
you already saw that it's not very
visually appealing however it provides a
very convenient and functional UI for
configuring all sorts of etw collection
scenarios you can quite easily configure
the providers that you want to to
monitor the keywords that you want to
monitor the verbosity level that you
need and in fact it also provides you
quite easily to analyze these log files
later as you already saw using multiple
built in statistical views inside the
application now
let's see let's see something in action
I want to profile the process of
starting Visual Studio just starting
Visual Studio itself no solution no
project no files anything just visuals
to you so saying the profiling usually
takes a lot of time and specifically
open visual studio can take a very long
time I have a video of this demo so
let's look at it
okay let me just stop it for a second
whoops okay look like that okay so here
I have perfume and what I want to do is
configure collection so I go to the
collect menu and here I can select all
sorts of stuff for example the size of
the memory buffers I'm going to make it
a little bigger
just in case although I didn't miss any
events and this is Visual Studio so you
know I'm going to click dotnet and I'm
going to click kernel base which is
going to give me information about
context switches in the system and I
want CPU samples because I want to
profile CPU performance and I want to
see what files it accesses that might
help shed some light on what's going on
I'm going to tell it to collect symbols
because I want to later look at the call
stacks and see the functioning and I
will give a different file name it
doesn't really matter and then I just
start collection now I'm collecting all
of this data and I can start Visual
Studio so I will start my visual studio
and of course I edited out all of the
waiting time believe me took much longer
to start and now that my scenario is
done I stop collecting and then perfu is
just going to load all of the files into
it and I can start looking so I will
look at the CPU stacks and I will still
at select specifically Visual Studio and
we can see that it actually took I don't
know if you noticed you take it a little
back
it took about 70 seconds until I stopped
until I stop the recording Visual Studio
ran 70 seconds through you throughout
this time so let's understand what's
taking all the time I'm looking at the
list of functions that were called
throughout starting Visual Studio and I
will go to code to the code tree
and that's my mentor main thread and I
see that the main thread ran for 40
seconds which is a little better than 6
feet and I will just start drilling down
the tree and this is the main function
again 36 seconds going further down the
tree the call stack tree takes a little
while
so lot of data there and further down so
by the way this is Visual Studio I mean
I didn't write it so of course these
functions don't mean a lot to me but if
it were my application that would be
very interesting information and then I
get to this place where I see that
jetbrains takes about 15 again I'll go
back a little I apologize and we can see
that a JetBrains function takes about 15
seconds from my load time and again I
want to remind you that I didn't open
any solution or project or file I just
opened Visual Studio from scratch an
empty Visual Studio so just putting it
out there what else can we learn about
what's going on let's look at JIT so we
have all the JIT times from the dotnet
applications and again I go to the
visual studio area and this time I'll
open the data in Excel and I will sort
it by by the time the digit 2
and you can see this JIT well this is
actually pretty long times but still it
might seem like a not very long time but
it actually adds up and considering that
it's all happening on the main thread
this is quite a problem that we might be
interested in what else can we see we
can see file accesses or image loads for
example again specifically we select the
visual studio we can see all the images
that were loaded into our application
and again when it's visual studio we
don't have much to do about it
but if it were our own application we
can you know maybe find a way to
optimize this and it's sorted actually
by the size of the image so we roughly
know what are the heaviest images that
we load and which don't incur as match
cost as the others okay that was useful
I think so I do have screenshots here in
case something didn't work with the demo
and so that later on when you look at
the slides you don't have to download
videos with it so we'll just continue to
the next section what we did now was
that we used perfu in order to define
our collection session but what if we
want to continuously monitor our
application on production and not not
just come to the customer one time and
you know turn it on do whatever we do
and go back to the office we want to
continuously monitor our application for
performance issue well it turns out
there the solution for that as well and
in fact in fact there's a nougat a
library you can get it's called trace
event it's developed of the same guy
that develops perfu and actually perfu
uses that library and this library trace
event it provides a programmatic API for
configuring starting analyzing etw
sessions
and so for example what you could do if
you wanted to say money for your
application for high CPU performance
usage you could do something along the
lines of monitor continuously your
application using performance counters
which just provide a numeric value right
so you know let's say every second how
much CPU your application is using and
once you detect that your application
passes a certain threshold you can
immediately configure an etw session and
collect some data for a while either
until the CPU goes back down or for just
you know a certain predefined amount of
time whatever works for you so you
record all of this data and then you
just you know shove it back to
development and analyze it and see why
suddenly your application was using so
much CPU and I do have to mention here
that I gave specifically the CPU example
but obviously it's not valid just for
CPU profiling you can do similar things
for any kind of limited resource for
example if you have suddenly high memory
usage you could you know see where
objects are being allocated or if you
suddenly have a lot of threads you can
monitor where treads are being opened so
let's see a code example of how we can
configure such continuous monitoring so
it turns out that an etw you can't use
the same session for kernel events and
for user space events so we're going to
have to define two sessions one for the
user self and one for the kernel stuff
next I will need to define what it is
that I want to record in each of these
sessions in each of these providers so I
didn't have room in the slide for all of
the keywords that I wanted to use in the
kernel session but we're interested in
processes in treads and file i/o and
then specifically since I'm going to
monitor a managed application then I
know that I need to turn
on the CLR provider because I need
information about what's going on inside
the CLR and specifically I'm going to
turn it on with the verbal level and the
default keywords are going to be enough
enough for me at this at this point now
the session is going to be closed when
this one's disposed is called so you
know I just need to wait for something
to stop collecting it again it can be
either that enough time has passed or
you know the threshold of high resource
came down whatever it is that's good for
you and finally since I want to be able
to later analyze managed call stacks I
will need the jet information the jet
rundown information which will allow me
to translate the addresses into into
dotnet managed functions so I will need
this information and getting this
information is actually quite easy
again using etw it turns out that there
is a provider called JIT
CLR rundown provider and what happens is
that once you turn it on it just starts
emitting all of the Jets rundown
information that the CLR saved along the
way so again I define a session for this
JIT run down provider at CLR run-down
provider now this is a little silly but
the best way I could find to figure out
that all of the information was written
to my file is the to check that it
stopped growing so again this is a
little silly I didn't find anything
better but the point is that after this
is done I know that all of the
information is written to my file and
that's it so I have the kernel
information which gives me sampling of
the CPU which gives me information about
context which is about processes I have
the CLR information which is going to
provide me information about the memory
usage and stuff like that in my
application and I have this jet rundown
information which will allow me to
translate
into function calls all of the all of
the CLR stacks okay so again let's do a
demo and again since I don't want to
waste a lot of time I'm going to show
you a pre-recorded version with a lot of
stuff edited out so I have an
application here cell for filing
application and what it does is that I
have two buttons or two groups of
buttons one where I can start you know
crunching CPU time using my application
and another where I can start an ADW
session and stop it so actually the code
I showed you before it was taken from
this application so we'll run it for a
while I started profiling now I'm going
to start crunching CPU and you can see
that there are high Sigma you know CPU
percentages and then I stopped it for a
while once I finished my collection I
can see all of these files are created
these files are the ones that were
created for these sessions that we saw
before the kernel the CLR and the gist
and and the CLR run down and now I open
again using perfu my application and I
see our two is prime functions so this
is indeed the way that I got the screen
shot from the beginning of the slides
and well not surprisingly it turns out
that calculating prime numbers by simply
dividing them but by all of the numbers
that are below them is not the very
efficient way of calculating prime
numbers now while we're talking about
looking at CPU information I want to
show you another very useful application
called WPA windows performance analyzer
this is also a tool which is available
for free
from the Microsoft website and straight
away you can see that is much more
visually appealing it's a really pretty
I would even say and it provides a lot
of similar functionalities as perfume
but what I mostly like about it is we
have this area here which is very
similar actually to the dot trace
Timeline view where you can very easily
select parts of your process running and
zoom in and out of them and get
information which is relevant just for
this time interval and why do I like it
so much it's actually possible in perfu
as well to define time intervals that I
want to reduce my data to but here
looking at in a visual way you can see
straight ahead okay in these five
seconds I have a problem right I don't
want to get call stack statistics about
a range where I both have a problem and
not have a problem because then the
numbers that I've seen the call stacks
are not correct they don't describe the
problem and in perfer in the wpa it's
very easy with to see with our eyes in
you know in a split second where the
problem is reduce my range to this area
of my applications run and then analyze
it the problem is that this application
is much less light weight than perfume
and so it might take longer so after I
loaded symbols I can start now going
down the call stack tree very similarly
to two per few and even though I catch
some of the I edited out some of the
parts here you see that it takes more
time to load but eventually we will find
our prime both native and managed
functions
this in this fuel and in fact another
thing that you can see here is when I
click on them it actually selects the
areas here on this timeline that shows
where these functions were cold so
that's another reason I like this view
and now we can zoom out and the table
here will be updated to include all of
the data again and you can see that when
I click ascribe you can see this was
only cold here and here so no calls to
is prime here in the middle now another
cool thing about WPA is that it supports
a different view of showing us CPU usage
and that flame graph so essentially
flame graphs are visual hierarchical
views of coal stack trees and well this
is obviously a lot of information you
can't get much out of it but you can
zoom inside so first of all I'll filter
just to my application so this is a
little better but what it gives us is
again with a single glance an idea of
what's taking most time because actually
all of the information is here in this
visual tree and the higher the tree is
it means that the call stack is deeper
and so the bottom is like the main
function that we call and you can see on
top of it all of the sub functions that
it's called and the width of each bar
signifies the amount of time that this
function took and so again visually it's
very easy for me now to look at this
look at this display and understand what
what is the big picture here what's
taking most of the time and if I want to
drill down it's ok I can zoom in and you
know see all of that stuff ok it
restarted good
cool so again I have some screenshots
here just so that you can later see that
so until now what we found the demos is
how we record log files and then later
analyze them using you know some
available tooling but it turns out that
you can actually analyze your data in
real time and not just in retrospect
using these tools again we can do that
using the trace event library that I
mentioned before and the idea is that
there are classes parsers which are
familiar with the internal data
structures with how the payload of the
different providers and the different
events looks so for example you would
have a CLR trace event parser which is
familiar with the GC event and it knows
that the GC event has let's say a type
property and a generation property and a
reason property and there's a kernel
trace event parser which knows that
there's a process started event and it
has a command-line arguments property
and it has a process name property and
you can write your own these are
actually available built-in inside trace
event and you can write your own parsers
but if you don't feel like it you can
always fall back to using the dynamic
trace event parser which just provides a
dictionary like API for accessing any
payload you want from these from these
events so let's see an example a code
example this is actually taken from the
official trace event documentation and
what we're going to see is how we can
monitor all of the processes that start
on our system in real time so we start
with creating a trace event session
that's not surprising and notice here
that I don't pass a file name I'm not
going to write it into a file I'm going
to consume it in real time I will also
register on the cancel key to make it
stop because this session is going to
stop running once we stop it otherwise
which is going to continue forever so I
want a mechanism that would allow me to
stop and since we're interested in
processes which start and stop on our
system I'm going to specifically enable
the process keyword in this in this
session and of course I also need to
tell it what I want to do whenever a
process starts
so since I'm using the kernel provider
parser it actually has a process start
event and this is a typesafe event which
has intimate knowledge of what's going
on inside the EPW process start event so
like I said before it knows that it has
a process name property and that it's a
string and it knows that it has a
command line property which is also a
string it also knows that there's a
process ID which is a number and so on
obviously I didn't have room here for
all of the properties but that's the
idea and now we actually want to start
processing so we call session process
and this starts passing the events to
our event handler and this call actually
blocks until we call session stop and so
that's why I had to register on
something to stop collecting if I don't
ever want to stop collecting that's also
fine now using what we just saw it's
quite obvious now that we can write our
own tool or incorporate it into our own
application that we can write or
basically anything we want anywhere
anywhere we want
using these api's and well luckily for
us we don't have to do it ourselves
because someone already did that for us
and there's an open source project
called eat race you can find it on
github I put a link here and it provides
a command-line interface for configuring
these etw live monitoring sessions so
let's see how it works
excuse me okay there we have it so we
have each race already compile it
beforehand and what I want to do is that
I want to want it for all the processes
that start on my system so I tell it I'm
interested in the kernel provider and I
need the process keyword and the
specific process that I'm interested I'm
interested in is process start and from
this specific event I'm interested in
process ID the image file name and the
command-line arguments so I'm going to
run that and I'm going to start a few
processes on my machine
I think that's enough and if I go back
to my command line I can see that
although the information was logged to
the screen now the next thing that I
want to see is to maneet or GC events
which we actually already saw before so
I turned on the GC monitoring and I
started this specific WPF application
and by the way I have a tiny comment
about this okay good so we can see again
that events are printed in real time and
this time I didn't pass in any specific
fields that I'm interested in so it just
prints all of the information that the
event has now just a tiny comment I want
to say do you remember that application
from the beginning of the slides that we
saw that it was allocating a gig and a
half of strings so that application is
actually WPA maybe that's the reason
it's not very performant I don't know
maybe the WPA guys should run some etw
on their own tool but anyway so we have
all of that GC information here we can
also do something similar that's a lot
of GC ok yeah
so we can also do something similar to
what 4-perf perform excuse me
Kasia forgot its name in sysinternals
there's a tool which provides us
information about file accesses that
application do I found lip the name for
my for my memory anyway so we can also
use a trace to my poor file accesses
that we do on our on our machine and so
for this specific case I want to monitor
file accesses specifically opening files
and I want to filter it just to DLL
files so I can also provide a filtering
expression for my for my tracing and if
I run it and I'm going to open Internet
Explorer if I remember correctly yes
and now I get all of the dll's
that Internet Explorer accesses while it
it opened so also a lot of stuff it's
actually not just limited to Internet
Explorer but you can see that Internet
Explorer is what's called a cause this
search of opening files now I do want to
mention at this point that you can't get
calls back information in real time and
that's because getting calls back
information depends on sampling the CPU
over time and then later analyze and get
along with the symbols information that
you have in order to create the call
stack the call stack trees so what you
can do in real time is money for just
the events themselves and if you need
call stack information you can record
this and then later analyze it with the
symbols and all the tools that are
useful for this now the last thing that
I want to show you is that even though
so far with the live tracing using a
trace it actually also supports
analyzing files so I have a file which
contains a asp.net information about
asp.net requests and the reason it's
here it's both that I want to show you
that you can use a trace to analyze
files but also that there's interesting
information in etw regarding asp.net
dispatch servers so I ran it on my file
and I can get all of the requests that
happened during that recording now again
I just want to say I'm showing this just
to show you that it's possible but I do
think that if you have a file which is
already recorded unless you absolutely
hate you know visual you eyes I would
probably use either perfu or WPA in
order to analyze existing log files the
command-line interface is very useful
for doing real-time for Monica
boring so again we have here screenshots
of our demo so the last demo that I want
to show you today is monitoring and
profiling booth performance that's
actually something which is extra close
to my heart because that was the first
thing that I did in my current job I
investigated booth performance quite a
long time and this is how I learned most
of what I know about etw so we're not
going to show a demo because I don't
want to start restarting the computer
and stuff like that so we'll just look
at screenshots so WPA windows
performance analyzer
it comes with a with a complimentary
tool called WP our windows performance
recorder and what it gives us is a very
nice compact UI for configuring all
sorts of etw collection scenarios and
one of these scenarios is booth
profiling where you can select booth and
you select all of the resources that you
want to monitor while your application
is booting now remember until now what
we saw is how we record etw sessions way
after the machine already booted and
it's already running and everything is
in place so we just start a session you
know recreate reproduce our problem and
then analyze it but how do you analyze
booth you know you can't wait for the
machine to boot and then start an etw
session you somehow have to make it
record while it's it's coming to life
and there's a there's a answer to that
and that's using Auto loggers so
basically you configure some voodoo in
the registry and I mean it's not really
whoo - it's not very complicated
you basically say
what's the file that you want to save
the etw session to you specify all sort
of parameters like the buffer size and
the max file size because you know you
don't want it to record forever and and
finish your disk and then you also tell
it what are all the providers that you
want to record and for each of these
providers you can also configure the
verbosity and key words and so on so you
can figure this we do in the registry
and once the computer starts the ones
once Windows starts booting it just
starts emitting all of these providers
into the file that we configured and
after the machine is booted you can look
at these files and see what was going on
while the machine was booting and what
wpr gives us again window performance
recorder is just more convenient UI for
configuring this registry guru now I do
have to say though that the UI is
limited it doesn't provide us all of the
functionality which is possible with
this but just you know for monitoring
basic resource usage scenario it's quite
enough so I configure wpr to monitor my
boots and I booted my machine and I open
the results and windows performance
analyzer and windows performance
analyzer similarly to perfume it also
has a lot of built-in views which I
encourage you to explore later for
displaying all sorts of information from
our log files and in this specific case
it knows that we recorded booth and so
it creates this special view called
booth phases which shows us the flow of
booting the machine so for example we
can see how long it took for the session
to initialize and how long it took for
when log on to log on to the machine and
how long it took for Explorer to
initialize and all of the user are
pretty fast but then there's some
called past boot which takes quite a lot
of time now in general terms I can I can
say that past boot it's kind of like the
time that it takes your machine to calm
down after its boot it's like you know
you start to Windows and you want to
open some applications but like the
computer is busy and you have to wait
until word opens or also Accord whatever
so pass boot is the time that takes your
machine to go back to relatively low
disk and CPU usage levels and this time
is very long so I want to use WPA and
the information I got from the etw to
diagnose what was going on on my machine
during this time and why it took it so
long to go back to normal CPU levels so
WPA also allows us to see a lot of other
things that happen during boot and can
show us the drivers that are loading the
processes that start running so for
example there is a view called
transients transient process tree and
the displays us all of the processes
that started and stopped during boot
that's very useful information now in
this specific case I highlighted the
process called rabid watchdog and it's a
little not fair at this point because I
wrote this process and I know that
that's the problem
so I highlighted it for you however how
would you find out what the problem was
if you hadn't known what was going on so
there's also a view displaying the CPU
usage colorized by the processors and
here it is very very obvious that this
rabid watchdog is what's taking all of
the CPU time during my boot process now
again I wrote this process I know what
it's doing but say I didn't know or you
know maybe I did write the process or
I'm just not sure what on earth takes so
long in my process that it consumed so
much TP
so I could use wpa2 drill down to the
call stack tree but I already mentioned
that it's not very efficient and it
takes a long time so I prefer using per
few to do that and if I open my eat my
log file me GW log file with perfume I
quite conveniently arrive to this point
in the call stack tree and I see that
99% of the time in this rabbit watchdog
application is spent getting processes
running on the system so I guess that
the process deserves its name okay cool
so we're almost done here that was our
last demo what are the main takeaways
that I want you to get from this from
this talk well first of all I want to
say that etw is an omnipresent component
in your Windows system it's everywhere
it's in services and drivers it's in
your applications even though you didn't
ask it to be there it's just there and I
actually didn't mention it but you can
write your own etw logs and thus help
your production engineers or whatever to
more easily monitor your applications as
needed its performance is very good and
in fact I didn't mention it but more and
more profiling tools nowadays turn to
etw as their source of data I know for a
fact that the dot trace uses etw at
least for some of its information we
also saw in the talk that the visual
studio concurrency visualizer uses etw
as its source of data about CPU usage so
it's very convenient and flexible tool
and again it's free you can use it in
production
not limited to the number of computers
where you want to use it you don't have
to decide beforehand if you want to use
it you can just come there turn it on
whenever you want and collect your
performance data so that's it the final
word that I want to say to you about
this and from this etw is that
unfortunately and that's I think the
major drawback of using that is that
there's very little or even none at all
documentation about etw so for example
when I was researching booth performance
basically what I did was like you know
turn on all of the providers all of the
keywords everything recording everything
and then started like you know manually
going through log files trying to
understand what the different properties
mean what's what's you know what's
useful for me what I don't need what's
the minimal number of providers and
keywords that I need to configure in
order to get the data that I need and so
if you decide to use it W you are
probably going to end up doing some
digging and trial and error in order to
get to find the information that you
need however I hope that it did you know
show you enough advantages so that the
next time that you have a performance
mystery the next time that you decide
that you need to monitor your
application you will ask yourself can I
do it with etw how can it help me thank
you so much I hope your hooks don't need
to W now I think we have a little time
if you have questions I'd be happy to
answer
yeah so the question was how we can see
all the sessions unfortunately there is
something wrong with my Windows machine
so I can't show you but it's somewhere
there in the configurations under if you
go to perfmon there's a list of data
collectors or something like that there
and if you know that I'll try let's see
if I can turn on my windows and see what
happens but in any case there's a list
there and you can see all of them and
the information and pretty sure you can
also see what's turned on in that
specific session if you can ask if you
want more questions you can ask while I
open my my Windows machine is it safe
another question is it safe to disable
them all you know I don't think your
computer is going to explode and so in
that sense it's safe but Windows itself
does configure stuff I mean like if you
just you know even if you don't
configure any session of your own and
you open this view with the sessions you
will see that stuff is running and
moreover you will also if you go to the
registry to the area where the auto
loggers are designed you're going to
find quite a lot of entries there and so
you're going to ask yourself thing where
the does come from so you can turn it
off then obviously the application
that's using that data is not going to
be able to do its work but I don't think
anything is going to explode
so okay good event race sessions and
here's the list of sessions you can see
which one is running you can see
properties you can see the keywords
which are configured inside so the
information is available for you I
wouldn't stop at those so you know
windows wants it so let it have it okay
cool thank you so much and I hope you
enjoy the rest of the conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>