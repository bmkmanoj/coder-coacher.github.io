<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building Reactive Services using Functional Programming - Rachel Reese | Coder Coacher - Coaching Coders</title><meta content="Building Reactive Services using Functional Programming - Rachel Reese - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building Reactive Services using Functional Programming - Rachel Reese</b></h2><h5 class="post__date">2016-09-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lCT5uGOkxOI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon everyone and welcome to
building reactive services with
programming I'm Rachel Reese um so today
I'm obviously gonna speak on the
reactive services and by this I mean
generally services that adhere to the
guidelines laid down by the reactive
manifesto and this is a technique that
we use a lot at comm where I work and so
a quick spiel about us we are taking on
Amazon we launched last year where
startup we aren't actually available in
Australia but we'll hire Australians but
we have over 20,000 orders per day our
Apple and Android apps were rated really
really highly you know 600,000
first-time buyers in our first think
that was our first two or three months
so we use a lot of technologies we're
very much a you know right tool for the
job kind of company we are very heavy
users of azor and in case you noticed we
are very heavy users of Asia because we
are taking on Amazon so we were very
much not heavy users of AWS but you know
we use vm's the the DNS sequel Azure
Active Directory where we use a lot of
the Azure technologies we also use a lot
of f-sharp the our back-end is probably
90 or 95 percent f-sharp so it's we are
we've sort of doubled down and we are an
f-sharp shop like a lot of folks say
they're a c-sharp shop we have node
maenge Euler on our front end our Python
at SAS on our for our data science and
the green down here is sort of
everything else we have we use some
xamarin we used Kafka vent or
microservices puppet Jenkins you know
we're like I said very much a right tool
for the job company so this does focus
on f-sharp and on how how we make some
of those our services reactive so the
reactive manifesto and there wasn't
updated well updated one in 2014 I don't
know if there's been an updated updated
one but B you know today's modern
applications should be responsive
message driven resilient and elastic and
I will go into what they mean wait for
each of those so responsive ah almost
every program has to handle event
whether it's clicks in the user
interface or listening to sockets in the
server events are really just a reaction
to a change of state and in F sharp we
have some really convenient features of
events they are immutable so they don't
change from underneath us and you know
concurrency of any form is wicked
difficult if you're trying to handle
mutable data they uh they all do
implement I observable so events or
value are events are values of type I
event of T they inherit from I
observable and you know this is used in
other libraries the reactive extensions
the because of this though importantly
they implement I disposable so we can't
help prevent some memory leaks they're
also first-class so events similar to
functions in a functional language
events are values we can pass them
around as inputs we can you know in
parameters and outputs we can filter
them we can transform them we can they
are first-class and we can treat them
like that it's really very convenient
they're also composable not only can we
filter and transform all of these but we
can compose all the operations in the in
the event module so similar to this here
we have a very simple and very real
world example of a program but it it
basically loads up a little button if
you hit the button quickly it'll only
add one if you click it very slowly it
will add four useful example but you can
see we have Evie is our event that we're
taking in and we are transforming this
we're taking the event typing it into an
event map grabbing the date time this
scan is where we handle the the either
the four of the one then we're taking
the the first item and adding that on
and printing out how many clicks have
been set and then doing an event add to
actually set the text to show how many
clicks have been handled but we're able
to you know compose all of these things
pass the event around as if it's just an
ordinary parameter you'll also notice
all of the piping that happens in F
sharp and F sharp piping is is huge you
will see it in almost every piece of
code that you will encounter in F sharp
almost not all of it
it's so important to the f-sharp
community that when they read then when
they created a new logo a couple years
ago they took their design from the pipe
so it's important but mapping scanning
and adding as well as you know adding
choosing filtering these sorts of things
are actually called Combinator's we can
actually create our own of these and
this here is how we would use you know a
Combinator that we've created called
using and the code at the top is how you
would actually create that but because
we can create our own we can you know
it's very extensible what we can
actually do with event so that was
responsive message driven is the the
more for the fun part of this talk so
before we move on to message driven
properly let's talk about async
workflows and what those are is really
just an application of F sharps
computation expression syntax and which
is that I will show you guys so before
we actually look at that first to talk
about async versus concurrent versus
parallel a lot of folks you know since
since we're gonna be talking about you
know async workflows let's get that
straight
asynchronous is just non-blocking
usually it's in reference to i/o
operations it can be something else but
it just means actually non-blocking
concurrent means multiple operations
happening at the same time so they might
necessary
they're not necessarily in parallel it
might be on one thread it might be a
little bit of one thing happening and
then a little bit of the next thing and
then a little bit of the first thing
again so they're happening basically at
the same time but they're not happening
fully at the same time whereas parallel
they're actually processed
simultaneously
so there's maybe two threads and two
things are happening at the same time so
the computation expressions now since
they're basically a
a mechanism that will execute a
controlled series of EV of expressions
so it's invaluable
they are they can be monads and this
will could scare folks that are not
familiar with functional programming but
they're actually more generic than that
they are not just monads you know and
that if you have seen there's there's a
famous example where folks compare
monads to burritos and that's how you
know famous blog post but if computation
expressions aren't just a burrito
they're an entire buffet of food there's
all sorts of things you can do with them
it can be m1 Mahanoy door an additive
monad so lots of different things and
you can come talk to me afterwards about
what those actually are but the point is
we can do lots of really cool things
with them so async workflows basically
simply make it really easy to work with
async ah it's very very easy to convert
be it events are breeding very similar
to your classic linear code and because
of that it's very easy to understand
what's actually going on so we take a
simple example create a new web client
we download some data based on a
specific URI and then we out output the
the data length here I'm a slightly
longer but very similar with a
processing agent that you know starts in
an async loop and in this well true we
have here we have a new URI and then we
have this web client and then we have an
async download string and at the end we
print out the a set of information the
main difference is here that we need to
actually have the async computation
expression so we need the async and the
curly brackets around it this is one of
the few cases in F sharp where you will
actually see curly brackets and then we
have a LED bang instead of the standard
let and F sharp let is how you sort of
define everything whether it's a value
whether it's a function it's that's how
you start yeah let bang we'll start the
computation immediately whereas let
within the async work flow
will create an async object for use
later so the main difference is between
the top and of coating the bottom are
that it is in the async workflow we have
this let bang and then we have an async
download string instead of the download
data which is not asynchronous so it is
very similar I mean let web pine people
new web client the HTML is very similar
and then here we're using a printf and
instead of an output stream right but
it's very very similar code mat and then
what this would actually print out is
you know if we're Google Microsoft and
MSDN then those are sample numbers that
we would be looking at so within an
async workflow yeah we generally have or
base that will have a recursive loop
around this and have you know well here
we're awaiting an event so that we can
grab these these clicks we also have let
in addition to the let syntax we have a
do and a return syntax they they perform
similarly async sleep is very similar to
at you know a thread dot sleep except
it's obviously asynchronous there is
also possibility of doing a back pipe
it's exactly the same as a front pipe
which if you folks have done PowerShell
programming or any Linux programming
it's the same concept you're taking the
output of the previous information and
passing that in as the final parameter
into the next set of information ah so
that's how that that back loop works in
general back piping is really only
necessary if you're trying to avoid
adding parentheses so you could write
async that start immediately start
immediate parentheses loop one so
message driven since we're talking about
message driven message driven is really
done using the actor model in F sharp so
what that is it's a model of concurrent
computations using actors the the main
sort of tenants of it the dynamic
creation of actors
solution of actor addresses in messages
interaction through only through the
actual message passing and no
restriction on message arrival order
thank you
middle button thank you so the the after
model was originally created from it was
modeled on a a well it was first
implemented in the the programming
language Erlang and Erlang was first
developed properly to be used out with
telephone systems Ericsson telephone and
the the concept of an actor model fits
very very nicely over this one of the
most famous folks who originally
developed the idea said that one actor
is no actor and Carl Hewitt I believe
and if you think about it the idea of
having one telephone is sort of useless
you can't really call anybody if you
only have one telephone you can't really
do any I mean these days you could play
you know use your your telephone to to
act for apps and and other such things
you can't call somebody you can't text
somebody else if you're using the only
telephone in the world so a lot of these
concepts make a lot of sense if you
think about telephones well dynamic
creation of actors you can create more
telephones and give them away to to more
people
inclusion of actor addresses you need a
telephone number to be able to contact a
specific telephone interaction only
through a direct asynchronous message
passing passing through the only
interaction with telephones really is
through you know calling or maybe
texting or maybe Bluetooth but there's
we go with texting you know the the only
interaction there is is some form of of
texting there it's not like one
telephone can reach out and grab the
other telephone and shake its hand no
restriction on mess of message arrival
order again if you think about text
messages sometimes you know you you go
through a slightly dead dead zone and
you come out and you get messages all
out of order from one of your friends so
the actor model actors themselves the
the telephones you might think of and
dependent computational and entity
contains a cue and receives and
processes messages that's all they
really do they you know there is this
you can think of them as basically a
mini queue another way I like to think
of the actors in the actor model it's
sort of like a subway system or metro
this is actually the Tokyo subway but
you can think of each station as a
single actor the trains coming in our
messages and so you have you know a
message will come in the actor the actor
will process it some of the folks will
maybe stay on the train continue on to
another station some folks will get off
and transfer trains and continue to a
different section and some folks will
get off the train as their final
destination so that's the sort of
processing that will happen for each
actor there's also some terminology
actors are generally theoretical agents
are often how Erlang refers to them and
many other folks mailbox processors are
what they're actually called
in f-sharp for all intents and purposes
they are basically the same thing there
are some differences if you really want
to get into the nitty-gritty but
basically if you're trying to Google
Basics around them they they are good to
go so with actors agents and mailbox
processors but mailbox processors
specifically they use async we're close
to be able to handle the message passing
and processing so here's an example and
so you have all the agents here we're
creating a hundred thousand separate
agents and we have a mailbox processor
we're starting the implementation right
away we have an inbox which is where the
messages come into obviously and within
that we have an async workflow within
the async workflow we have our loop here
we have a well true we can have a more
functional style loop if we need to both
work perfectly fine you don't have to
strictly adhere to a functional style
and again we use our let bang to receive
the messages
this obviously will wait until there is
a message to receive and then for every
ten thousandth the message of the
hundred thousand just print yes I got a
message so it's it doesn't actually do
very interesting processing here but
it's a very basic example it shows you
the structure of how agents are what
should look and then to actually post we
need to know for each agent in all of
these agents do an agent outpost so
agent here is excuse me is the actual
address of this agent the telephone
number that we're posting to and then
the output will look something like this
and these don't necessarily come in
order I've run this code sometimes and
had you know six thousand and six
hundred sixty thousand and seventy
thousand messed up the other thing about
agents is they're they're very very
lightweight I can run this code and spin
up a hundred thousand of them on my
laptop they're not threads so they they
are much more much more lightweight so
there's a few more interesting things we
can do with agents we can actually get a
reply back so agents as they stand don't
necessarily you send a message off to it
and you may never hear from anything
again so for this for this example and
we have our mailbox processor we send in
a string and an async reply channel of a
string so that gives us a way to have a
reply there's a channel through which we
have this reply again we're starting
right away and our inbox this time we're
using a recursive loop and we have our
async workflow and here when we receive
the message we have to receive both the
message and the reply channel together
at once and we can do a reply channel
don't reply yes we actually received the
message this is what it was and here
we're just continuing to loop and then
we're calling the loop so instead of
doing an agent post now we have to do an
agent post and async reply and send in
an actual reply channel so the the
important bits here are we need the
async reply channel we need to decompose
it out of the receiving the message and
then actually use it to reply and then
when we call the agent we do a post and
async reply
so obviously this just repeats the
message that was sent into it again very
real world example oh one more thing
that's important to you know a message
driven setup is actually being able to
scan an agent's queue so here we have
this these two and the these are taken
from a very small app that basically
uses a couple actors to simulate being
able to to monitor and then cancel jobs
that are being created so it it
automatically spins up about ten of them
and then holds some of them holds all of
them in the in progress agent and it's
just a it just holds them there it
doesn't actually process them in any way
so that you can scan and see what's
actually happening but then you can scan
and actually cancel some of them so when
they're completed yeah it will we have
the same you know we have our recursive
loop we have our async we have an ID and
a result coming in for the receive and
then the result of this so this is what
will print out when it's actually when
it when it actually finishes the board
this the actual cancel job will contact
the in progress agent and do a scan to
basically scans the entire queue sees
what's there and sees what what options
there are here we just do a quick source
dog cancel and if that actually exists
then run that action that we've just
created otherwise don't do anything so
if we find the the job that we're
looking to cancel in once in this scan
then we will actually cancel it and then
obviously the important part here is
just the scan
so one major difference from Erlang the
F sharp two agents don't actually work
across process boundaries so only within
the same process app in many cases in
most cases that I have done and this is
coming from somebody who doesn't
regularly use Erlang using F sharp
mailbox processors has been completely
fine it's been sufficient for our needs
but it obviously is not always but there
is a library cricket which used to be
called F sharp actor which does handle
and across process boundaries and and
some other really interesting things so
the way you use cricket actually is very
very similar to the way that you would
use just regular mailbox processors we
have here we have just you know a
greeter it'll print hello world in a
couple different ways we have an actor
instead of a standard asing workflow
then you have to specify a name for it
because actors need to have a name by
which you can communicate with them and
then the body here will have again a
recursive loop which will handle the
messages it needs to have a message
don't receive because you need to
receive messages into your inbox so that
they can be processed and then
processing section so we we're just
doing a simple pattern match here we're
massing massive matching the message
with either a hello we're print hello a
hello world who prints is hello world or
a specific name and then we run actor
dot spawn instead of actor dot start so
and the the message type obviously is a
discriminated union of hello hello world
or name of with a specific string and
then the way to call this is you call
greeter with a back arrow and name and
it with print hello from f-sharp actor
the way to handle remoting is calling
actor host dot start you subscribe to
events and then you enable remoting with
you know by sending up a tcp transport
and tcp actor registry transport and
making sure you have your endpoints in
your the registry discovery so it's
it's not that complicated it's just a a
few actual lines to get that properly
set up and then you can do fun things
like this the we have a ping-pong game
built with the two actors so we have an
actor here this is just the ping actor
there's a similar pong actor and they
will just loop back and and post you
know ping and pong and go back and forth
to each other but the actor internals
are the exact same here as the non
remoting so there is nothing different
we're still receiving a message we're
still matching that message with a you
know a pong or it's receiving a ping
message from ping which is is bad
otherwise in in something some other
case where it's either not pong or
paying something is terrible and you
should stop but there is nothing here
that's different when you're actually
using remoting so that's how you would
handle message driven the next step is
resilient so resilient you know as it
says the system should stay responsive
in the face of failure so I one of the
major tenants and and points of Erlang
is that it's it's self-healing it can
work with itself you know know what sort
of errors are happening and try to fix
itself so this obviously is very
important especially to highly highly
available mission critical systems but
also to anything you know if if you have
an app that's that's not responsive it's
you know throws errors all the time and
can't figure out what's going on it's
very annoying and obnoxious to use so
error handling is an important part of
being a a resilient responsive
application so here we tend to want to
use async well test to the run using
async run synchronously should report at
any of their failures back to the
controlling thread and specifically to
do that we use we'd want to use async
catch I think start with continuations
which is another
of running an async workflow also has an
exception continuation that's another
really good way of handling exceptions
within async there's also a supervisor
pattern which is common again in Erlang
and very very useful with within the
actor model so async catch here we have
it
you know I not the most real-world
example again but this is really best
for for async workflows but here we have
a and we're doing an async start we have
two and we're basically trying to write
to a file immediately after reading and
if we do this quickly enough we'll still
be reading the file when the code comes
to try to write to the file it'll still
be open it should fail and you know
exception occurred reading from this
file and can't access it so you try to
call right to file so first we call you
know read file and then immediately we
call right to file and we use an async
catch and then an async run
synchronously and if we there either
you know two options either it
successfully worked which happens
actually in most cases or there is an
exception because it went too quickly
but this is a a good quick way of
handling an exception excuse me from an
async workflow so async start with
continuations if if you're using for
example a a reply then this is a good
way of of handling that that reply so we
have you know our message async here we
have an async post and reply handling
gathering the reply channel and then
async start with continuations we send
in the message async which is you know
doing the post an async reply and then
we have three separate options there's a
continuation for a successful case
there's a continue exception for when
obviously there is an error or some
something goes terribly wrong there's
also a cancellation case so with the the
code that was running the the jobs this
is
the sort of the sort of handling that we
would use we'd have an a cancellation
option here which would go and
specifically cancel that job that was
running so another example for I start
with continuations within the the same
the same bit of code when we're actually
doing the scanning this this is the
agent that will actually start start
running so from the same code where they
double checks the that's starting the
job
so it'll specifically start the job
it'll post to the in progress agent so
that you know the the agent is actually
in progress and then will call a start
with continuations on this specific job
and first the successful one we have a
complete agent so we posted the
completed agent when this has been
successfully completed in this case we
don't have an error clearly nothing will
ever error here but with some content
obviously this is yeah non production
quality code but here we would have a
proper error handling here and in this
case we have the cancel exception so
here's where we actually go out and
cancel this this properly using this
token and we loop around but this is how
we would use be to start with
continuations to be able to handle
errors more effectively the supervisor
pattern so our supervisors when you
think when I first discovered agents I I
wanted I wanted to solve every problem
with agents I thought they were very
useful very neat and you know very
typical developer response I can do
everything with agents I I wanted to to
write a quick sort of demo app and the
problem that we currently needed to
solve at the job that I was at at the
time was how to handle all of the emails
that we we needed to both process and
specifically send out it was a company
that handles helping brick-and-mortar
grocery stores go online so there were
signing up and me you know making sure
your order was going to be delivered
there were you know please come back and
order from us again all sorts of very
standard emails that you want to to send
out and they need to look a little bit
different so I wrote a a quick demo with
five or six agents where some of them
would handle a list of email steward
types coming in and you know people that
needed to have an email sent to them a
template that needed that the email
needed to follow and miscues me a 1:1
agent that would actually specifically
process all of the emails one that would
actually send them and then this one the
which would actually handle theory
so the error agent is you know oh we
have you know I at least everything to
agent the agent is just a quick little
agent that takes in a message that has
both an integer and a system exception
and a specific agent ID and an error
message hmm and in the application again
it was a quick little proof-of-concept
so so that one's actually next because I
didn't actually read my code and I
switched my two examples all right I'm
gonna come back to this one so in my
email type I this is my agent and I have
three different email types here which
makes a lot more sense uh and you know
type one might be thank you for your
order type two is something else but
just again it was a proof of proof of
concept and the point that I was going
to go into the proof of concept was the
way I handled simulating errors was any
email address that I needed to send two
that had either an Ian and end together
or an A and an end together errored no
matter what just to just a double check
that I was handling all of the errors
properly so like I said a very real
world
example but here we're just handling you
know we have a message type and this is
how we're going to handle changing the
in one of the cases we believe it's a n
yes it's if it's a and then if it's if
it hasn't eaten n together then it fails
permanently if it has an M then together
then it replaces that and retries the
entire process so here's where we
changed the email if it has an A and an
end together then we run this the change
function actually change it and then
just return the message so still within
the error agent now we come to our
actual recursive loop our async again
here we're scanning but them as they
errors to see what's going on so we we
first scan and then we replace if if we
can if that's this is our action that
will take and let me look at all of the
data that we have and we choose the
specific one and we do a replace a n
because that's how we fix our failure
and then we repost to the the filtering
agent which will figure out which
template it needs and it will restart
the entire process again but basically
it's recovering from a failure
automatically because we know exactly
what error just happened in the en case
this is similar simulating something
where we have no idea what just happened
and something something actually went
wrong and we're going to need to
actually go and discover that log the
failure and come back to it later so if
the the message contains cannot send
then specifically retry with an A n if
the message contains something about
templating then the the issue is an en
mente and it should fail specifically
and then run this ation run this
synchronously so the easier example with
supervisors is a a much more simple
example where basically in this down
here if the the the so for each of the
agent we
frig now for each of these agents we
post message to agent whatever with an
agent ID and we created a bunch of
agents specifically and so if the
message contains agent 99 and we're
creating 10,000 of them so it's actually
agent 99 and then nine ninety and nine
thousand nine hundred anything in there
that actually ends up failing or the
actually ends up having agent 99 will
specifically fail again a contrived
example but we'll show you that if you
understand the type of error that is
happening you can attempt to fix it so
up here anytime anytime that they were
actually happens we just send to this
agent error we do an an error agent post
and along with the age-specific agent ID
and the actual error we call agent agent
dot start and then then rerun the whole
loop at the beginning so any questions
on supervisors because I know that's a
little much to to get through all right
so here so next we have elastic and this
is very very important elastic is one of
the big important features of having
reactive services because the system
really needs to stay responsive under a
varying workload I at jet we have you
know Christmas season hits at some point
and people around Thanksgiving I start
to start buying everything in the
everything on the planet and the web
site becomes comes under tremendous
tremendous load and the same time well
not the same thing but a similar thing
happens you know during the course of
the workday
it's the load is a lot lighter at 9:00
a.m. than it is around 2:00 p.m.
people get bored and start shopping and
you know you have to hit those after
lunch blues somehow you go out and make
sure your your groceries are handled or
whatever you need and then you come back
to work for a little while but we need
to be able to handle all of this
workload
specifically and so you know reactive
systems need to direct to all these
changes increasing or decreasing these
resort resources and you know
automatically so you need to know how to
handle all of that
and especially with agents it's very
very very easy to scale agents on demand
so here we're looking at a very similar
example to the the first example that we
had that here in the middle we have a
processing agent but here we have our
actual URL list and the square brackets
is how you define a list in f-sharp so
we have a list of tuples so we have
Microsoft comm MSDN and Google strings
of identifiers and then strings of the
actual URLs fun fact when you list the
the items in a list out on their own
specific lines you don't actually need
the semicolon if you had listed those
all on one line then you still would
need the semicolon so we first have the
processing agent and this takes in the a
tuple for its message which is going to
be the string of the name and the the
URL and for our inbox but you know we we
start it right away and we have our
inbox in our async loop this time we're
using a while true like I said it really
doesn't matter if you're using recursive
or not so we used our let bang here
we're decomposing out both the name of
the the system and the URL we're doing
an inbox received to get those we're
creating a specific URI from the URL
that we're creating a brand new web
client and again we're we're using let
bang to asynchronously download in the
string from have all the information the
HTML on that that page and then excuse
me and then just printing out the
characters that have that
red for the length of the HTML for that
you know red so many characters for
specific name so the scaling agent then
if we wanted to do all three of these at
the same time rather than one running
one at a time or maybe we have a list of
500 websites that we need to get through
and that's going to take a lot a lot
more time to handle those all at once
instead we create this scaling agent
that specifically takes an agent and
then now within our async loop we have
an inbox receive we take the the message
that we've gotten and then iterate
through the whole list so for each one
of these items in the list we create a
brand new agent which handles the
processing for each one that which just
is an instance of this processing agent
and post the information to that new
agent so we're just you know iterating
through each one of those we could also
if you wanted to do make this an array
and do an array dot parallel and process
those in parallel but the point is we're
automatically spinning up a new instance
of this processing agent for each item
in this list just at will as we need to
we could do this for you know if there
are 50,000 items in a list we can spin
up a new actor for each one of them
handle all of that
a synchronously and then come back and
it's it's a lot easier to to
automatically spin this up and that's an
important feature again of reactive
services and then from here then we just
post the entire list to the scaling
agent which handles the scaling for us
by calling each one of the processing
agents any questions on the scaling yes
this will if you are a list is a
different size each time then this will
automatically account for that so if you
have three items in the list the first
time in a thousand the second time then
it's not necessary to spend up a
thousand each time yeah it's it just
automatically will handle that and since
I forgot to repeat the question the
question was just what the difference
was between those anything yes what if
we wanted to talk about limiting how
many of those scaling agents we have at
each time so if we have say network and
we got a million in those list if we do
a million HTTP requests across a
firewall will probably break the
firewall is there I met is there a
mechanism there that you can specify
throttle thank you the question was is
there a mechanism to specifically limit
those instead you could you can do the
same specifically I spin up an exact
number
you could also yeah you could do a
another like the the list comprehension
the for agent in agents you can do
something like for one to ten
until the agents run it or you know that
so yes there is I would say by using a
list comprehension and just like setting
a maximum and running through that until
you've utilized as many of this you need
there's not a specific built-in
mechanism that which is I think is what
you're looking for so there are ways
around it but nothing very yeah yeah
nothing pretty any other questions
all right I went a little bit quick more
quickly than I wanted so I was hoping
you guys had more questions yeah so some
general resources for f-sharp
specifically f-sharp org is a fabulous
resource the there's all sorts of
information on how to get started on the
foundation itself the foundation is also
running a they're gonna start back up
soon a mentoring program they help out
user groups I know they have a speaker
program so the speakers can can go out
to the different user groups so if you
guys have their speak or run a user
group or want to definitely look into
that the Twitter hashtag f-sharp is also
fairly well monitored still a lot of
folks will will jump in and if you
hashtag something with f-sharp hashtag
f-sharp
I have personally never tried it I yeah
it felt weird to me and then I
discovered that people just spell out
the sharp so yeah then as far as I know
that is not one that is monitored is the
hashtag FF hashtag there is a measure up
channel on the functional programming
slack there is also one run by f-sharp
org that I didn't list here as soon as
you join the organization and it's free
to join you will get an invite to the
f-sharp org f-sharp slack channel which
is a really a really great resource as
well I would also highly highly
recommend f-sharp for fun and profit
it's Scott flashin is one a fabulous
speaker if you haven't seen him speak
definitely go check out his videos but
even even if you don't do that go check
out his website he explains a lot of a
lot of f-sharp concepts everything
really from very very basic ideas to
very very complicated like he has a
13-part section on monads I think it's
it's amazing but even even basically
like why is it important that F sharp is
immutable by default so hey he hits all
levels it's very easy to understand very
very very good material there's also
f-sharp weekly it's just a weekly blog
post digests that you can get that lists
out the latest you know new releases of
a
sharp projects new talks or blog posts
that have come out lately just basically
a a weekly update of the f-sharp
community it's a really useful resource
to to keep an eye on what's actually
happening with the rest of the community
there's a few mailbox processors in
general a few really good blog posts
here the the c-sharp async gotchas is
excuse me is is by Tomas Petra check he
wrote he wrote a blog post after one of
history I don't remember which one one
of his trips to Microsoft ad probably
for an MVP summit but to talk to he's
talking there was a talk there on some
of the folks by some of the folks I
think that had worked on the c-sharp
async and they were just going over a
few you know make sure you really
understand what you're doing if you
think you're typing there if you think
you're working with this bit of code
you've you could accidentally do this
because it's a little unclear here and
Tomas went through in his blog post and
for each I think each one of the things
that they had presented in their their
talk he went through and showed that
basically f-sharp the the f-sharp
compiler prevents you from actually
making any of those mistakes the and I
don't definitely go go check out the
series there's it's a two or three blog
post series but in each case it's in
almost every case it's basically not
possible to make that same mistake
because the f-sharp compiler cleans up
after you and I was like whew a second I
don't think that's actually what you
mean go check something else is there a
question sure hi sorry I'm actually
quite new to functional programming and
getting my head around it obviously very
strong and object oriented there was a
previous talk about pure function as an
impure functions and the testability of
pure functions just wondering if there's
the same kind of concept of like
visibility like private-public for all
those functions or I mean how do you
protect a pure function so that the
entire application doesn't access it and
you do it once with it you can do you
can set things as private
I have theirs I tend not to as much
because a lot of as an evangelist a lot
of the code I write is actually demo
code but it's absolutely possible and it
is obviously recommended in many cases I
know there's private-public there's yeah
I I definitely there are ways absolutely
and I think for I think almost
everything actually corresponds to the C
sharp ways but don't quote me on that
because it's been a really long time
since I've actually looked at c-sharp
also okay so there is an F sharp control
reactive the project definitely check
out the cricut project as well it's a
really really good there's also
additional extra library based projects
that it also are really really good and
very well maintained within the F sharp
space I happen to show off Cricut but
don't you know don't take that as an
endorsement of that over any of the
others but definitely go try to find the
the C sharp async gotchas post and that
is it for me if there are any other
other questions thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>