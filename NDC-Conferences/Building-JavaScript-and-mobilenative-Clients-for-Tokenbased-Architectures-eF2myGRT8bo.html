<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building JavaScript and mobile/native Clients for Token-based Architectures | Coder Coacher - Coaching Coders</title><meta content="Building JavaScript and mobile/native Clients for Token-based Architectures - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building JavaScript and mobile/native Clients for Token-based Architectures</b></h2><h5 class="post__date">2017-02-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eF2myGRT8bo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay cool so how many of you have been
to the last talk okay
so Brock and I have been working for a
long time and our interests have been
well it is what we started with has been
on the server side so we created this
thing called identity server which is an
implementation of Open ID Connect in
OAuth because we think that is the you
know that's the right architecture for
writing modern modern applications and
after that was done we had more and more
customers actually want to use that
right so we have a client so that the
server is not good enough right you need
someone to talk to so so with the next
thing we got interested in is like what
would be the best way or the recommended
way of writing clients that connect to a
token-based back-end and we indeed
independently of each other
wrote client libraries one me being you
know historically more like a native guy
started working on a native library
brach being strangely attracted to
JavaScript here so yeah we wrote these
libraries and it turns out that if Ed
all our V Vaughn's weren't that good so
we had to do a v2 and learned a lot
while doing that and this talk is
actually you know basically about what
we learned and how these things work and
what what you would need to do manually
if these libraries wouldn't exist okay
good so so this is kind of the big
picture as additives Dadd the reference
architecture we're talking about
it's basically we have a couple of api's
and a couple of that applications and
you have a couple of different client
types native clients browser-based
clients either you know like the classic
web application where the code lifts on
the server and the sparse tile where all
the code lives on on them in the browser
actually and you have native
applications
applications and and and mobile
applications and they all want to you
know participate in in this architecture
so the thing we you know recommend doing
here because to manage all that
complexity is sector out all of your
authentication needs into a thing called
a security token service and then you
know all the clients will go first to
the token service or get a token you
know authenticate the user things like
that get a token and then talk used to
token to talk to the APS right so this
is kind of like the that the optimal way
to to remove the security complexity
from the actual endpoint move them to a
separate service if you like
authentication as a service so to speak
okay now now to connect your client
applications to that thing called a
security token service they need to talk
some protocols okay so we have two
protocols we are primarily dealing with
here one is called open ID connect and
that's an authentication protocol so
whenever your client application wants
to know who is the user that is the
protocol to use we also if you wanna
know who's you know who's the guy
holding me in my hand right now yeah or
you know who is who's sitting in front
of the browser or open ID Connect is the
protocol that that authenticates the the
user
ma'am the second protocol is used for
talking to API so once you know who the
user is you want to delegate the
identity of that user to the next hop to
your API so the API can do work on
behalf of that user and it would be
really bad if these were completely
unrelated protocols right so you would
need to learn two different things to
achieve something which obviously
belongs very closely together so that's
why I open ID connect and OAuth are
really just oh of was their first and
then they added stuff to OAuth 2 to to
fill the missing gaps to make it serve
both purposes both authentication and
and getting those access token
there so they are very very similar and
the good news is you only have to learn
it once and then you can do both okay
now this may might look a little bit
complicated but basically what we're
doing is you're focusing on this part
today okay only the client side and in
particular we want to focus on first on
the the JavaScript scenario so you're
writing a spa application how does this
get a token use the token and then it
turns out once you understand that you
know like 80% of it already so that only
20% missing - to understand also how you
would do it from a native application
okay so just to recap that really really
shortly so we are all on the same page
the general flow regardless of the
client type you're writing will always
be like this the client opens a
connection to the token service it sends
the user yeah to that service the user
authenticates of the service as the
token service and the token service will
establish some sort of authentication
session yeah so he he will remember that
user for a certain amount of time and
that is obviously also the enabler for a
feature called single sign-on right
because once you open the gate once the
server remembers you then the next mfp
rope and you don't have to authenticate
again because you're being remembered
them the outcome of that will be a
so-called identity token which is think
of it as a protected data structure that
represents the identity of the user so
your client application can know who the
user is and it's coming from a trusted
source there are some cryptography
around there to make sure these that
data structure doesn't get tempered wave
on the way back and the other thing
you're getting back is a so called
access token and the access token
represents the same user but the
recipient of the access token is not the
client application it's the API so
basically you take the access token and
then just forward it to the API and that
in essence means you forwarded or
delegated the identity of the user to
your back-end system so make sense is
that
all good all clear okay cool so that's
what we do that that's our daily our
daily lives in many many years okay but
that that's why sometimes you might miss
something which is obvious to us but not
for everyone so now how do we write
these client applications and there are
two mindsets fear when you go to a
company and there they want to write it
application obviously the low-hanging
fruit somehow is you know I'm just
writing a username password login page
right I've been doing that for years
I know how to do that yeah if they have
a username and the password and the
login button
okay so what's hard about that you know
and then I'll just send it and then the
name and the password to the to the
token service they give me back a token
and from that point on you know I'm I'm
in the other competing approach how to
do that is you don't put the login UI
into the client application itself
you're doing a redirect to the server
yeah and the server has a login page and
you log in on the server and then the
server will send you back to token now
so now that they're just an ongoing
debate which approach should I use yeah
and there are some advantages and some
disadvantages of of each of these
approaches yeah obviously the the
biggest advantage and that's why people
love at the you know option number one
is they have complete control in their
own application of how the login looks
like right so if you're if you have your
your your your UI designer in there and
he says no no no I want to control how
that login page looks like this button
is five pixels way to the right yeah I
want to control that yeah then you know
that's one really strong argument but
there are a number of disadvantages you
get when building the login UI into the
client application for example single
sign-on right so things are non is one
feature you might want to have like
let's say you have five applications and
you want to allow the user to only sign
in one's and then switch between the
applications and don't have to login
again how would that work if every
application has its own login page right
there there's no shared session between
those applications that's one thing you
know if you can argue if this is your
client application going against your
back-end and it's your users and you
already know the password of these guys
because you store it in your database
what's what's wrong about harvesting
credentials on the front end yeah and
there's not much to say about that but
what about if you're a scenarios get
more complex like you have third-party
applications for example do you want
that your users type in their password
into third-party applications or would
you broader prefer having that in your
server as opposed to someone's code
that's one thing what about if you want
to enable things like Google
authentication no one will type in his
Google password into your application
right this will never happen now
he shouldn't atleast so yeah so the
Federation scenarios are not really
achievable with this approach of I have
my own login UI so long story short you
can do option number one you have been
warned there are issues with that you
shouldn't do it okay we can really
prefer option number two where all of
your login logic is on a server now
whatever feature you built their names
passwords Google login Federation with
business partners two-factor
authentication fraud detection whatever
you only implement at once right and all
of your client applications just use
that as a service so to speak and get
that feature for free okay yeah good
yeah all right so the first scenario
that we're going to look at for these
client applications are spa style
JavaScript applications the the target
audience that we're really focusing on
here are really pure spa applications
where you have all of your rendering in
javascript in the browser you don't have
anything on the server other than maybe
a file you know serving up files
and then of course because your
application to be useful you want to
call some sort of web API that's
basically the idea so you might think
well in the past I've just used cookies
for doing authentication right why do I
need to do this token based you know
architecture and it turns out cookies
are problematic for spa style or
JavaScript style applications there are
a few reasons one of them has to do with
the fact that we'll maybe like I just
said you don't have any server-side code
running for your application you're
doing all your rendering client-side so
there's nothing really just send a
cookie back to the API that you're
invoking may actually be from a totally
different domain maybe it's a third
party API so it's not even coming from
you know your server so you can't you
know issue a cookie across that that
domain boundary if you do require
cookies to protect or authenticate your
web api's then you're fundamentally
limiting yourself to browser-based
clients of that and a pretty much has to
be your own client application so your
native application would have a hard
time calling the Web API or any other
scenario and fundamentally the real
reason that the final reason which is
the nail in the coffin here is that if
you rely upon cookies for protecting
your web api's for authenticating those
calls then you have a anti-air
cross-site request forgery of
vulnerability in your application if any
of you have ever done MVC in the past
right you know that there's this
validate an T forgery stuff that you
should be using and so that's a very
easy thing to use from you know MVC
running on your server but what about
those Ajax api's right cookies are going
to be sent to that but you still have
the concern about some other you know
tab and the browser making malicious
requests to those endpoints just doing a
form post for example so you have to
protect that okay and it turns out that
this token based architecture that we're
talking about is actually going to to
achieve that okay so that's
fundamentally why we're moving towards a
token based system so this protocol
called Open ID Connect and OAuth 2 is
going to help us you know build this
applique
to connect up to some token service that
will issue these tokens to us and then
we can use them and know who the user is
and call these API s so the first thing
you're going to have to do in these
applications is of course have a server
ok that's typically called your
authority right that's the the token
service that your application is
trusting and that your API s are
trusting so what you're going to do in
your application is then probably use a
library like one of the ones that we've
developed and configure the library to
know about that authority and so there
are a lot of things that you need to
know about that authority that that
token service to achieve all of these
protocol steps right first of all there
are things like where's the UI or the
login page to send the user to and oh we
had tokens so we're going to want to do
you know validation and things like that
so we need some information about our
token service so in the open ID connect
set of specifications there's something
called discovery and so from your client
if you register your library and tell it
the authority that you're using then
your library can go to this well-known
endpoint wait which the name of it is is
in the specification and it makes a
request to the send point to download
all that additional information so you
get back this discovery document and it
tells you everything you need to know
about how to interact with that token
service where to send the user what key
material to use to do signing to
validate signatures and a whole bunch of
other things ok so that's the first
thing that we're going to need to do so
it turns out we have some sample code
here and we happen have a token service
so this is identity server the token
service that we work on and here there
is this discovery document so this is
the discovery document that my
JavaScript application is about to
consume so over here I then have a
JavaScript application that's going to
consume that I'll switch over that to it
and second the steps for this JavaScript
application then is once it knows where
to send the user to authenticate that's
exactly what's going to do it's going to
redirect the user to the token service
or the open ID provider as they're also
called for signing in and the user will
enter their path
for it there that's their username and
password secret whatever they're going
to use and the outcome of this
authentication process is going to be
the proof of the users identity
encapsulated in something called an ID
token which Dominic talked about so the
job of the JavaScript now at this point
is to validate that ID token and then
from that we'll know who the user is
this right now is only authentication
we're not yet calling a web api so how
do we do that so let me go back to my
sample app I have a sample application
here I'm just going to run it for now
just kind of walk through the steps so
what I have here is write my JavaScript
running application running just
localhost 7017 and this is using the
JavaScript library that the Dominic
mentioned and when I trigger login here
this will trigger a request over to to
sign in okay so this ended up
redirecting me over to the token service
are running now on port 5,000 this is
identity server and like dominic said
this is where you would do all of the
hard work of logging the user in may be
supporting google logins whatever so i
just have a test user i'll hit log in
and what happens is when i come back oh
there's a content screen as well this is
where you know you can enable this or
disable this based on the nature of your
app if it needs this and when we come
back what happens is then this token is
delivered back to the spa application
okay now i my sample here is
deliberately not going any further just
because i wanted to show this this pause
and the process so this token has to be
sent back to the application because
it's a spa application really the only
good way across this domain boundary of
conveying this these parameters is to
pass it in the URL so that's actually if
you can see up here in the URL the token
is passed here in the hash fragment okay
now the hash fragments an interesting
question why why's is passed in the hash
fragment and not something like a query
string say again
yeah exactly well it's not sent to the
to the server when you're reloading this
HTML page right so this wouldn't end up
in a server log or somehow leaked
perhaps to other you know if somehow
your application had some sort of
vulnerability where so the referer
header would send things that the ID c--
intent for putting it in the in the hash
fragment so great we basically not
completed but we've gotten a very far
long way down the path of establishing
the user's identity we've made the
connection to the token service we
gotten the outcome so what we have to do
next is validate that same coming back
and so this is what we're getting back
with an ID token an ID token like
Dominic said has a structured has a data
structure that represents the ID or the
identity of the user
it is a JSON format it's basically
broken down into these parts separated
by dots the most important one here well
depends how you look at it but the one
in the middle are the payload if you
will the claims for the user and then
the bit at the end is the signature over
the the entire thing and there's some
header information which informs how to
perform the validation check so at this
point now you have this data structure
you need to validate it to really trust
you know the outcome so the nice thing
about the specification is very clear on
all the steps guide but it turns out
there are quite a few steps right
there's a digital signature involved so
that means you have to go and you know
download the certificate from the the
token service basically do some crypto
work right to validate the signature
there's time information inside the the
token which says like the token expires
after this amount of time so that you
know the user can't replay it like a
month later and get back into your
system there's also some other
properties like there's a nuns a nuns as
a security feature to prevent replay
detection into your application again if
somebody takes out and replays that
token later and then there's also this
audience thing which says this token is
intended for this application and you
don't want to trust tokens meant for
other applications right the user may be
an administrator in another app but not
your app so if you're not actually
checking that the token was meant for
your app right you might get the right
say identity or set of privileges so
that's kind of a quick overview of what
is needed to validate the identity token
and that's a lot of work to do okay so
as Dominic said fortunately we've
written some libraries right when we
first started developing with open ID
connect several years ago I was so
excited now I can go write the
JavaScript application and nothing out
there existed so that's basically what I
did is I built this thing so there's a
JavaScript library called oh I DC client
and that's exactly what my my sample
here is using so this thing's up on NPM
it's up on github feel free to you know
check out the issue tracker and you know
if you have any suggestions or issues
with it and so just to show you a little
bit more what I have here is my my page
here is pulling in this app dot jf and
there's a lot of configuration really
just from the sample code to show a lot
of the different options you can do but
fundamentally right we have to configure
some you know some some aspects about
connecting to my token service so right
there is the authority property all
right we have the client ID for
representing our client some coordinates
to return to our application and some
other frame numbers about how what we're
requesting from the token server so to
actually have triggered the sign-in I'm
sorry so then what we do is we take this
and initialize this user manager so this
is really the heart of this library to
help make you writing your JavaScript
applications easier the user manager
will do all the protocol work for you it
can figure out how to load the metadata
document it will help validate the the
response coming back and then once that
has been validated it will manage the
storage of all of the things you will
need for your user their name their
profile ultimately then when we get to
the access tokens we'll see that so to
have triggered the login just to show
you how fairly easy it is I have
basically method here sign-in redirect
right so your login button basically
calls this method and this sends you
away okay then when we come back into
our application
right I have the separate call back page
and this is the page that we're sitting
on right now where it says processing
call back pretty simple
you basically just say redirect call
back right and this will do all the
heavy lifting of processing the result
response if that's all good then we'll
just send the user back to the the index
page so hopefully if I just hit refresh
now that tokens still sitting there
although it might have timed out no ok
I'll trigger it one more time there we
go so now what happened is I went to
login Oh actually notice I went to login
a second time notice I was not prompted
for my credential so I'm getting the
benefits of single sign-on and Here I am
with the results of my authentication
and so what I end up having here are
some claims that represent my user and
right now I'm really only getting back
one thing hold the subject claim which
is the unique ID of that user okay that
was real quick but any questions about
that yeah well so the token is so there
are few things there first of all the
token all of the network traffic that
we're talking about here should all be
done over HTTPS okay sure that's the
entire point the token service that is
the thing that the token service gives
to your app to prove the identity of the
user okay so I'm missing then so now we
know who the user is now what what have
you what is your app leaked right now
this is being managed inside of web
storage ok so what happens is then we
are you know doing the validation and we
happen to store this here in the browser
and web storage okay session storage
just in the tab
sure any JavaScript application can know
the users unique ID okay but yeah from
that domain presumably you have control
over you know your domain and the
applications running under it right
that's just how the web works same thing
with your cookies to write any other app
under that you know other than cookie
pathing okay all right question so we
did drop a cookie on the login page of
identity server so yes identity server
has established a session if you look
here I'm now logged in as Bob and now in
the spa you have this data structure
that tells you who the user is we don't
necessarily need a cookie for that okay
and again if you didn't want to stick
this in session in session storage just
hold as a variable right for the
duration of the you know in memory of
the spa that doesn't work so well if you
refresh the page though because you lose
all your in memory State yeah it's the
web right okay so one of the things that
we got back was the users unique ID
that's called the subject claim if you
want more information about the user you
can pass the request along and ask for
what are called additional scopes and
these are basically just identifiers for
other sets of information that you might
want from the user so there's a profile
scope and an email scope and an address
scope and you can come up with your own
so that's what this other button is
doing here in my application it's just
passing more arguments requesting more
identity data so now that we go to the
token service notice I'm being informed
that the token service is about to
release more to the application and
again the user can consent to that and
now my application has a way to get
additional data about the user okay all
right so there is a bit of a problem
that ID token that's passed back in the
URL can get bigger and bigger and bigger
and bigger with the more claims that you
put in there so there is an optimization
in the protocol that allows you to defer
or
not put so many claims into the ID token
okay
so how are you going to then give
something back to the app but allow it
to get you know more profile data well
it turns out that there is a Web API
built into the token service called the
user info endpoint and this is basically
a web API that you can call to get more
identity data more profile data and so
the way we do this is you have to ask
for access to that API so our
application what does it will do is when
it makes the request over to the token
service instead of just asking for the
ID token which is just the user's
identity we will also ask for what's
called an access token and the
additional parameter that we pass is
just the word token what's going to
happen there is the response coming back
from the token service is still the ID
token that same signed data structure it
will only have the users unique ID their
subject claim and then you get an
additional token back called an access
token and with that you can call back to
the token service and that access token
then will be your key to getting in and
getting more profile information so if
you have a lot of data about the user
maybe like I don't know some image of
the user or something that's obviously
not going to fit in the URL so it's a
it's a time space you know trade-off
absolutely we're on the right track so
yes it we will then you be able to use
that access token to call other api's if
you know you've configured it to do so
so what I have is my application right
here is login with profile and access
token so what happens is when I get my
response back from this notice my
response now gives me that actually let
me go back and just do this one here
login with profile so notice all of the
data I have I really only have the ID
token here so when I make this type of
request it's now requesting an
additional token and here that is with
this access token okay and now if you
look at my users profile I only have the
unique ID okay that means I need to make
that extra Ajax call
with the access token to go get that
data so the way that's done or with any
kind of access token is you would have
to make this you know Ajax call you pass
the access token as the authorization
header using the bearer scheme and the
results of that are more profile data
and again as you can imagine our little
library here has a flag for that okay
all right so as long as my page is not
cached I will now go get my access token
and I have a feeling it is cached okay
and do I have more now hey there we go
okay so the library then made the
roundtrip a second round trip back to
the token service to get the additional
profile data okay and as the gentleman
in the back you know came to the
conclusion hey can't we use that access
token for calling other api's and
exactly so what we're going to do is if
we want that access token to be able to
be used at other Web API s you have to
request more scopes and the scope
represents the access to these api's so
you could come up with your own scope
representing your API 1 or your calendar
API or whatever and when you get that
access token back it can then be used to
call those Web API s the network call
looks exactly the same so what I have
here in my application n is actually an
API but I wasn't running it so let me
run that real quick now back here in my
spa I can now access a request token
with additional scopes for that Web API
my consent screen is letting me know
I've requested those I will consent and
now I should be able to call that Web
API and the Web API is basically just
echoing back what it saw in the access
token so now my Web API will know the
users unique ID and any other additional
data that you've put in there
okay there's also logout support I'll
just Emma that real quick I know we're
kind of tight on time here but logout
there we go so those are the basic
moving parts for getting a spa style
application a user logged into a token
service getting tokens back getting
their identity data and getting access
to a Web API I'm glad you asked right so
the question was what hell out
expiration so absolutely that access
token has a finite duration when it can
be used now that's always configurable
you can choose to make it one hour or
ten hours or ten days depends on your
scenarios okay but the consideration is
of course the access token if it's lost
then anybody else can use it and it's
going to be good for that duration so
what we usually do is tend to keep that
access token duration short but then
that does mean you have to go back to
the token service to obtain a new one
okay so so those are two things here one
is the expiration the other one is the
storage that we mentioned briefly here
you have to hold that data somewhere so
the library by default is storing this
for you in session storage but you can
configure it with other storage if you
just want to keep it in memory that's
fine too then the token expiration is
another consideration so I'll just cut
to the chase the the the common approach
for solving that problem is you want to
have short access token lifetimes but
you want to you need to periodically go
back to the token service to get new
ones you don't want to interrupt the
user though right you don't want to
redirect the main window because they
could be in the middle of filling out a
big form or something so any guesses as
to the way that on the web which is kind
of hacky by nature but we need to
somehow go back to some other website
but without the users involvement no
second
refresh tokens are not used in this type
of application in spa style JavaScript
applications if you've heard of those
before that's not not that not the
approach an iframe absolutely so that's
the last thing that the library here
supports for you the library that we're
using it will monitor the expiration
time of the access token and five
minutes which is again configurable five
minutes prior to expiration it will open
up an iframe and go back to the token
service and what makes this work is that
when you go back in the iframe the
cookie is still sent to the token
service and you already are signed in so
by the bennet with the benefit of single
sign-on with the iframe you're just you
know going back and it immediately
returns with the new token and you know
there you go you have your updated token
one of the parameters we pass though is
what if the user has signed out well in
the iframe you don't want to show a
login screen that nobody can see so
there is a parameter called prompt
equals none that you pass along that
tells the token service that you're
doing this and it will immediately come
back with an error and then you'll tell
the user and then they'll have to
redirect in the main window okay okay
Dominic are you ready to come up we're
going to switch now to two native
applications doing something which you
should never ever do in a presentation
unblocked DAV you never know what's
going to happen on the other side but
while Dominic's plugging in any
questions about the the JavaScript
scenario yes
right that was the bit at the end that
we were talking about you could redirect
the main browser window but it wouldn't
be user-friendly so that's the iframe
approach yeah you can do it before you
want to do it before the token expires
you have to redirect the user well let
me get the back sorry so when the user
if the token expires that's you that
just means you can't use it at the API
but you can take the user back to the
token service in and the iframe and as
long as they still have their cookie
their sign-in session at the token
service that will come back with a new
token that they can use at the API yeah
usually you set up maybe a 10 hour
cookie the duration of a workday in
terms of the expiration on that but
again that's all configurable as well
okay native apps so I get to sit down
okay you can sit down yeah okay cool so
second part is native apps and it turns
out they are very very similar to
JavaScript apps even if you wouldn't
expect it to be the case yeah so first
of all I think it's important to make
sure that I you know what I mean with
native apps because there are so many
ways how you can now do stays you know
build build client-side application so
what I mean with native apps is
typically applications that have access
to native operating system facilities
you know you can call native api's and
the most the most interesting one type
of API you might want to call for these
types of applications is to protect the
data storage you know the the crypto API
so to speak on on on the oval rating
system so for example on Windows you
have this thing called DP API the data
protection API in in iOS you have thing
called a keychain for example which is
seems to be like really a secure place
to store data right you know the FBI
paid a lot of money to get access to it
their Android has a similar thing and so
on vanya so you're having access to that
feature can enable some extra scenarios
that in the browser a little bit you
know questionable right at least yet I
mean there are other there were
development of the bit crypto that you
know in the future you might have these
as well also so in other words yeah if
you're writing a c-sharp application
native now if you're writing an
objective-c application that's native if
you're writing a Cordova application
using Java Script that would be native
as well at least according to my
definition right because you can call
down to into native operating system API
yeah in a browser you can't do that so
desktop Mobile's of metal Ilham so this
is a very common scenario and there's
actually a spec for that it's the OO
open early connect for native
applications it's a really good spec you
should read it
lots of thinking is going into how to
secure applications on mobile devices on
the desktop and so on that that use this
token based approach so again it's the
same as I said earlier you could have
your native login UI and we already
figured out that this is not the right
way to go right we want to use our
server based UI in other words well how
do I show a web page if I'm not in the
browser I have to open a browser yeah
and a couple of options here from less
recommended to recommend it now is you
know some some frameworks are pretty
much every framework has this thing
called that few like an embedded that
browser you just have you know a control
inside of your application which you
give it a URL and it renders of that
page right and that is something you
could use
now the webview has a couple of problems
first of all there there's no indication
for the end user if it is really a
browser is looking at right I mean it's
something that looks like Google's login
page but it might be you know something
you've you've drawn yourself and just
have the smell the keystrokes yeah
there's no way to
check am I really on Google because they
have no URL bar at the bottom you can D
X inspect the SSL certificate for
example and for from a former pure
usability point of view also is you
don't have support for add-ins like your
password manager for example yeah so
what do you have to do and there are
some really nasty offenders on the
Windows platform like Visual Studio for
example yeah you all know that right
window pops up from time to time a
dialog which which have a login page
right and now you I don't know my
password so I have to go to my password
manager find my MSDN password copy to
the clipboard go back paste it into the
lid into my password box and not so nice
yeah so yeah these are the few mam not
not recommended and if you're reading
the spec actually kind of like forbidden
okay so they did they did say you you
shouldn't use them anymore actually that
goes up to a point where starting this
year Google will sniff the user agent
and if they find out it's a it's a few
control from you know winforms WPF and
so on they will block their login page
so you can't use Google anymore from
within the webview obviously unless you
change the user agent string I guess
then but still did you know the
intention is they are insecure they
don't give the end user a lot of control
you shouldn't use them here you should
give the end user as much information as
possible about the thing he's typing is
tested in mam
the second category is some some people
came up with thing called authentication
brokers and think of them as special
browsers in the system they they share a
couple of things they are like locked
down they don't allow you know reading
the keystrokes for example and some
might have some special features they
sometimes even share the cookies between
the client applications that's another
thing that data def you can't do right
by by definition you're hosting a
private copy of a browser so you can't
share cookies between your applications
which means you don't get a shared logon
session between the applications some of
you education program
allowed to do that has anyone ever used
the web authentication broker in Windows
8 or Windows 10 to build in a special
browser
well you haven't missed much the really
recommended way of doing that is using
the system browser okay so the system
browser is probably already the most
trusted piece of software on your
computer right using it every day using
it probably most likely you know
counting the hours you sit on the
computer for the for the most time
you're probably going to use the browser
you type in all your passwords there you
type in all your credit card information
there you use your search engine which
you never lie to you know and so on okay
so why not use this piece of code to to
to log in to something okay
also your cookies are always already in
there so if you are logged into Google
yesterday then today you will get
signals along with Google if this
application is using the system browser
now you know more modern operating
systems like iOS and Android they have
API to invoke the system browser
programmatically and they called it an
in-app browser tab so basically what you
do is you actually open a tab of your
browser inside your application yeah
it's the real system browser with all
the bells and whistles with the add in
support and all these things they add
some extra special protection to it
again like the keystroke logging and so
on you get the shared cookie container
and you get all the benefits basically
you would get from a system browser okay
so these are the three fundamental
options so quickly show you that so I
have a customer you know he did open
early connects back to the DAA you and
all your hippie talk yeah we do WinForms
yeah can can can we do fancy open ID
connect with wind forms but yeah I think
I can do that yeah and the way this
works is you know this is a an example
of a web view right so this is a browser
it renders our identity server login
page somewhere yeah it's you know the
user can't see that is the browser
ah well I probably could right-click I'm
what's happening here yeah it looks like
a browser right you can't see the URL
you can't see the certificate you can't
you can you know let's let's you know
let's hope it's really a browser so we
can sign in we get our typical you know
server-side logic and we get back our
identity token our access token in our
claims back into the client application
I'll show in a second how that works
so just want to show the the user
experience first here's an example for
this authentication broker so because no
one has ever seen it before I show it to
you once and then you can forget about
it again yeah let's see okay the best
login button it invokes this
authentication broker that's built into
the Windows operating system you get
this window that is not resizable for
whatever reason that is beyond me it's a
fixed size it doesn't have an address
bar it doesn't show you a certificate
information it doesn't have add in
support but it's you know it's supposed
to be secure the only thing it has it's
kind of a questionable password manager
support built in so Microsoft takes the
freedom to basically look at what you're
typing into oh that looked like a
password I should start it for you and
actually you know what not only on your
machine but also in the cloud yeah
because you know you never know when you
need it again so let's press yes and
because I am you know I thought that's a
good idea so the thing is that they
don't even use that stored password to
give you a single sign-on experience now
because when you log in again
they just prefilled the password fee
well
okay anyways if you ever wondered and if
I buy it by mistake press that that
button the yes button you can get rid of
it very obvious by called searching for
something called a credential manager
and then here you see two above he
signed into something here his password
you can remove it again okay so really
the the preferred way of doing it if is
a set of system browser and this works
arguably the best right now on on mobile
platforms so let's have a summary in
application here let's start that I
don't know why my iPhone 7 is always
that big when I'm only when I want to
projector otherwise it's pretty tiny
when I'm not on the projector okay
there's a way to scroll here right yeah
so so what happens when I press login is
now I'm using the native Safari api's
from iOS then you see basically this is
a bit different now
yeah same same login page but now you
get all the information you get the
certificate you can sign in here and
we're back and here's my hero my claims
and his Mac's talking and I can call my
API okay just run it again just to show
another feature or maybe even two
features
because of single sign-on I have to
restart the emulator right I'm signed in
now I didn't have a look I didn't write
a local logout button yet but who cares
about logout okay
login so let's say you know you logged
into Google already yet the Google
button and now we can use your existing
Google login to assign to the
application now and the very last thing
I want to show you this one it again is
a feature that is I think you know it's
quite nice at least someone fought about
that at Apple is you could be extra
paranoid saying okay yeah it looks like
you're starting Safari but is it really
Safari or just the tricky clever
animation you did here in which within
your application right so they have a
button here in in their browser control
this guy which basically it switches to
the real Safari on your desktop so to
speak as if I click that now you are
actually in real Safari and if I log in
with this guy it is okay are you ok with
going back yes I am and now I'm locked
in here okay and it looks very similar
on on Android as well so how does it
work
so rocks broke shout you what in the oak
MediConnect specification is called the
implicit flow and it's think of it as a
simplified version of open airy connect
for browser-based applications because
we have less features in the browser for
oh yeah and and one of the one of the
behaviors of implicit flow is that
everything you're doing which makes
total sense happens inside the browser
this thing is called a hybrid flow
because what what they do here is one
part happens in the browser and one part
happens in a back-channel communication
so the the not so sensitive identity
token is Ischia is transferred over the
front channel but the sensitive access
token is transferred over a back channel
okay so you have less exposure of the
sensitive data so you know it looks very
similar one thing to point out here is
the redirect URI so Brock said earlier
you prove ownership of the domain where
you go back to ok and the idea here is
very similar yeah you don't you
obviously don't use a web address here
because you don't have the Internet in
your pocket right it's something locally
on your on your phone so there are these
custom uri schemes that you can register
with your application yeah so basically
together the typical pattern is you take
like my company comm you reverse that
you make it combat my company dot and
then the name of the application and
then the idea is whenever the browser
navigates to this address here it knows
that it belongs to this native
application and it calls you back ok so
the whole workflow is we run through our
web-based flow whatever that is it might
be you know registration login to fact
or whatever the very last thing the
browser will do is is to redirect to
this URL ok and then this URL the
browser knows ok this belongs to this
application here and it will call back
the application and hand in the query
string ok so now my application takes
over again it passes the identity token
validates it same steps as we've seen
before
it takes the
it is code that got sent back not the
actual token but a code and then thus a
direct connection using event API call
to the token service sends in that code
we got earlier back from from the token
service and this in turn gives you back
the actual access token okay so one more
step one more step to basically reduce
the exposure of the access token to the
browser so one one little sites note
here because someone asked there there
are some additional things which we I
don't want to go into details for the
interest of time but that data
specification called tick feed approve
key for code exchange which kind of
introduces a per request secret between
the client and the server so it makes it
harder for attackers to intercept the
token coming back or the code erratum
and that is basically this thing called
decode challenge which which is a hash
you send in the hash on on leg number
one so to speak on on leg number two
here you send the unhatched version of
the same value the server does some
crypto on that and make sure that you
know the entity on leg 1 is the same as
the entity on leg two okay we don't need
to go go into very much detail
one thing that's also different here is
as opposed to the implicit scenario you
get a refresh token
so a refresh token is basically a token
that allows you to get a new access
token without having the user to be
interactive right so scenario is the
same you know the user wants to use this
native application on the phone I have
it installed for years you don't want to
maybe maybe you don't want to ask the
user again and again and again for its
authentication you for fourth
credentials here so but you want to call
api's so what you do is then typically
you take this refresh token store it
locally in your protected data storage
here most the most secure place you know
on your operating system and then I use
that to whenever you need get a new
access token so you send the Refresh
token in get a new access token and can
continue using the API
like then yeah well my clients on my
Mountain
yep my client libraries chop is done
once you have all the data from the
server and then you would store in your
local storage
you know the refresh token the
expiration time and so on I thought
about that but then that meant I needed
different implementations for Windows
for iOS or Android and a for Thea no I'm
not going to do that yeah so yeah one
last thing
how are we in time perfect
this is a digital of work yeah again
like block yeah in in proxy Nereo it
took us quite a while to implement all
that you're all they're going back and
forth the crypto the change checking
here hashing there and you know doing
all the magic so you typically don't
want to implement it from scratch okay
so there are a couple of options for
native libraries I'm working as I said
on one written in c-sharp that there
were two versions of that right now one
one is a c-sharp portable class library
now that was the only thing that was
available by the time I started with the
project to create a cross-platform
library for all of you who have ever
done in their life a portable exactly
they know that you don't envy me writing
that code it's horrible with the advent
of the state dot net standard now it
becomes much much easier to write these
kind of things right the dotnet standard
library is a shared feature set of
dotnet across desktop Windows and uwp
and Semoran so that's the one I'm
currently working on it's it's working
progress but I think it's pretty much
done and that's the new one and then
there are also native libraries so if
you're doing native mobile development
the people who wrote the the o of spec
as always and then 80
expec they have reference
implementations for objective-c and for
Java so you know if you care about that
and the last thing I really want to show
you is the library I'm working on right
now as I said it's it's a dotnet core
library which means it runs on Windows
on Linux and Mac OS on Android on iOS
and whatever other operating systems are
supported by document core and this is a
console application right so what what
do you do in console applications same
thing you start a system browser right
and then you just have a have to find a
way how to communicate with these things
so here's my system browser that's the
one I trust the most
it's it from Google but still so when I
do dotnet console browser DLL C get some
little ASCII art going on here
now I'm launching the browser I'm
sending the browser to Maya or to the
login server right
I could log in with Google here and now
it's communicating back to the
controller application and here's my
claims here's my identity token
here's my access token and now I can
call an API ok and you know that the
nice thing about that is now imagine
that another application console native
web whatever yeah
and now we have no and now we have a
shared a shared authentication session
between that that those applications you
know the next time you want to use the
same authentication provider you get
single sign-on one
cool so that's it
that all we have on the slides you can
download from here from speaker
backslash lease privilege and thanks for
your time and enjoy the rest of the
conference
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>