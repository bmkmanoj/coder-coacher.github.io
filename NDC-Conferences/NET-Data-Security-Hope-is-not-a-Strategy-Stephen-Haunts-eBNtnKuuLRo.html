<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>.NET Data Security : Hope is not a Strategy - Stephen Haunts | Coder Coacher - Coaching Coders</title><meta content=".NET Data Security : Hope is not a Strategy - Stephen Haunts - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>.NET Data Security : Hope is not a Strategy - Stephen Haunts</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eBNtnKuuLRo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">someone named Steven haunts and this is
my talk net data security hope is not a
strategy so first of all thank you for
having me over here in Sydney it's an
amazing city my flown over from the UK
so taught me about 30 hours to get here
so I'm still awake
just okay so a little bit about me so
I'm the co-founder and CTO of a payments
company in the UK called ladder pay so
we aim to make business and consumer
payments easier for our customers and as
well as that I also for the last three
years I've been offering courses for all
sites over in the States so a few
supplemental materials just before we
start so we're going to cover quite a
lot of ground very quickly in this talk
so if you don't grasp all of the
concepts straightaway in the talk that's
absolutely fine treat is the art of the
possible but I've got some other
resources out there to help you so first
of all there's my course practical
cryptography and dotnet that's available
on site is everyone a Provost our
subscriber here quick char hands it's
quite a few for those of you aren't so
I've got some cards at the front there
which give you 30 days free access to
the library so if you want to try it out
and watching other courses then help
yourself to a card there so this course
will basically walk through what we're
doing in this talk but in a lot more
detail when it kind of holds your hand
and goes through the code demonstrations
it's a much better pace I've got a
second course called play-by-play
enterprise data encryption we've as you
revealed which is all about taking
everything we talked about in this
course but then using the azure key volt
to protect all of your encryption keys
so it makes quite a good supplemental
course what we're talking about if you
go to the github page listed there I've
got all of the source code from my
course available for free so everything
we're talking about here is is in that
github repository so you don't have to
code anything if you don't want to you
can just steal what's there and use it
and bend it to your own will and also
the slides here up on github as well so
if you want a copy of the slides
afterwards just go to that address there
ok so why are we here then so I believe
that as developers you is basically your
responsibility or you have a big
responsibility to your employers and to
your customers to protect their data so
we're in a society now where data
breaches are becoming even more common
every day
and the people that can really help
prevent that is you guys working in your
teams back at the office so for many
years you know companies tend to think
you know we'll just cross our fingers
you know it's not going to happen to us
we're too small to get hacked or you
know you've got all these brilliant
firewalls and this impenetrable
intrusion detection systems we've got no
one's ever gonna hack us well guess what
it happens every day so nobody's immune
to it so it's up to us as developers to
try and put better security into our
systems and as the course is named hope
it's not a strategy such as hoping that
you're not going to get hacked and
having real data stolen from your
databases isn't a good strategy going
forward unfortunately the reality of the
world is we've increasing project
budgets security always gets pushed
right to the bottom of the pile so it's
kind of up to us to try and make sure
that doesn't happen okay so what's this
talk not about so this isn't a deep
mathematical talk about how encryption
algorithms work you'll be glad to know
so we're not going to do lots of complex
maths because I'm rubbish at it and
we're not going to talk about
cryptanalysis either so cryptanalysis is
kind of the art and the science of
breaking encryption algorithms so that's
not what this talks about what this talk
is about is about people like you and me
who work on teams of developers for
organizations building enterprise
systems so this talk is really aimed at
you know looking at what's in the dotnet
framework and using those tools for our
benefit so most of these sort of code
snippets are going to look at us or from
the more traditional saying quality in
quotes dotnet framework so typical you
know surface I at API is WCF web
services all that sort of thing or
client codes and if you do winforms WPF
or anything like that then this stuff's
all very relevant so in the.net core
world if you're using dotnet core 1.1
and don't know standard 1.6 you kind of
outta luck so most of the api's we're
talking about are not included but
luckily two days ago dotnet core 2 was
released and no standard 2 and you'll be
glad to know that we have feature parity
of all the api's so if you're in the
dotnet core world and you're upgrading
to dotnet core - then you're in luck
and what a good time to release dotnet
core 2 while we're here at NDC Sydney so
I spent the last two days upgrading my
codebase
so what what we're talking about it's
got a very Microsoft focus today
actually the concepts of what we're
talking about it's kind of transferable
across different systems so if you work
in you know Java PHP god forbid - no js'
or anything else like that and all the
concepts that we're talking about
transfer a Porsche stop see the api's
are different so is everyone here at net
developer I can't pretty much buy to
anyone good room it's being a PHP
developer now I said that sorry I
apologize okay so we're gonna cover
quite a bit of ground so what we're
gonna do is gonna break it down into a
series of abstractions I guess because
we love abstractions so first of all
we're gonna talk about random numbers
and why they're important because they
kind of underpin everything that we do
in cryptography we're then gonna look at
hashing and hash max or that's a hash
message authentication codes then we're
going to talk a bit about secure
password storage and so what's a good
technique and what's not good techniques
to use then we gonna look at symmetric
encryption so we'll look at IES and what
that is and how you use it then we can
look at asymmetric encryption which is
RSA and then we're gonna look at digital
signatures but once you've done that
we're not going to stop there so we're
going to explore all of the different
primitives are available to us and the
dotnet framework but where the real
value is when we start combining them
together to do what's called hybrid
encryption so we're taking the best of
both worlds from the all these different
primitives and using them together okay
so what is cryptography then so
generally you know cryptography is about
protecting information you know you have
a piece of plain text you encrypt it
with some secret encryption keys and you
get ciphertext out at the back so that's
what we all commonly think of as
cryptography
Bashi there's kind of four pillars to
cryptography that we want to explore
during this talk so the first one is
confidentiality so that's what we
typically think of when we're talking
about encryption you know you have a
piece of data you don't want someone
else to see it's even encrypted but also
we've got integrity which is about
detecting over anyone's tampered with
our data or whether it's been corrupted
in any way then we got authentication
which is about proving you know am I
allowed to see this data so you have you
got access to see some data and then
we've got non-repudiation x' this is
being able to prove that it was actually
you that sense a piece of data in the
first place
so examples of cryptography mean you
can't wake up in the morning and
function for about the day without being
exposed to cryptography in one way shape
or form so every time you use the
Internet
maybe anything over HTTP it's going to
be using cryptography and the
backgrounds protect your traffic you
know using a cash machine or on ATM and
you put your PIN number in there's a
handshake that goes on between that
machine in the bank at all friends okay
yes that's all using cryptographic
protocols mobile phones these days
especially iPhones you know with the
secure Enclave chips on there they're
very secure devices these days as you've
seen in the US where the FBI tried to
get Apple to unlock the San Bernardino
killers I find which I refused to do and
then paid some company over a million
dollars for some tools to help them but
then we've got other areas like in
crypto currency so Bitcoin litecoin and
all the different currencies that are
coming out in that area and the
underpinning blockchain protocols as
well all quick top a few based I wish I
had more time to talk about block chains
it's one of my favorite subjects but I
only have an hour but also a picture
down here electronic voting systems are
all based on cryptography as well as you
know once you've registered your vote
can someone go and change your vote and
tamper with it or can you vote twice
so those all use cryptography behind the
scenes to help implement them okay so
let's start looking at the top of the
list then that we looked at that's
random numbers so random numbers are
very important to cryptography it's one
of the most important concepts we need
to get right and because used in to
generate encryption keys so we can do
that you know see that multiple times
throughout the talk and there's
different ways of doing it in dotnet but
but the one you don't want to use is
that system got random because it's it's
not a random number it's always very
deterministic so if you don't change the
seed that you pass into it you get same
numbers out so it's only really good for
simulating dice throws and maybe the odd
lottery number so what's better to use
is a class called rnj crypto service
provider now you're gonna find that a
lot of these objects in net if you're
not familiar with them have got some
really ridiculous names which is where a
lot of people tend to overlook the
mininet framework because they're not
very obvious so this one is our ng
crypto service provider and that lives
in the system got security cryptography
now
space along with everything else that
we're talking about today and you know
this is very easy to use and it'll be a
common theme all of the things we're
looking at actually very easy to use
they're just not very obvious in a
documentation from Microsoft so to
generate a random number so we've got a
small method here so be passing what
length we want so typically you know we
might want 32 by its random number which
is 256 bits which is very common key
letters to use these days we create an
instance of RNG crypto service provider
we create an array we call get bias yeah
we pass in the array that we want filled
which is fatal to bias for example and
then it gets filled with random data so
typically what we're going to use to
generate encryption keys for the rest of
this talk so moving on then so the next
thing is hashing so as everyone used
hashing before I'm familiar with hashing
yeah I mean the concepts are quite
simple with hashing but they're very
powerful what they can do so a good way
to think of it is if you've got a piece
of data and then you create a hash code
off of it it's a bit like a unique
fingerprint for that piece of data so
you can take in an arbitrary block of
data because you know generally in a
byte array you run a hashing algorithm
over it and you get a fixed length
string effectively out the back of it
which is the hash code for that piece of
data there's kind of a few properties of
hashing that are important so the first
one is it should be easy to compute so
generating a hash of a piece of data
should be easy but it should be
infeasible to generate a certificate you
shouldn't be able to say you know for
this praveen piece of will flips given
hash code what's the data I need to
generate the hash you shouldn't be able
to do that and it should be infeasible
to modify a message without changing the
hash so if you've got say a PDF document
and you generate a hash of that document
if you go and change just one bit in
that document then the entire hash code
should be completely different so I'm
not slightly different but it'll be
completely different and it should be
infeasible to find two identical hashes
for the same piece of data or different
pieces of data that produce identical
hashes that's called a hash collision so
that's something you don't want to
happen with hashing
so good way of thinking about hashing
then you know when we look at encryption
it's generally a two-way operation so
you have a piece of data you encrypt it
with a key and then you decrypt it with
the same case it's two-way but with a
hash it's kind of like one-way
encryption effectively so you have a
piece of data hash it even you can't
recover that original data from the hash
that's good way of thinking about it so
there's lots of different ham
hashing algorithms that are out there so
one that's very common and quite old is
md5 this produces a 16 byte hash value
and it was designed by a chap called Ron
Rivest in 1991 but in 1996 a hash
collision resistant for mobility was
discovered so it's actually not a very
secure hashing algorithm to use these
days the reason we still talk about it
is because if you're in the enterprise
application development space you
probably might have to work with systems
that are much older than you we still
use md5 hashes you still need the
ability to bounce calculate them so they
still use very commonly with legacy
systems following off from that then we
have the shower or secure hash family of
hashes and these come in different
flavors and so sha-1 and char two are
both in the.net framework so sha-1
produces 160 bit hash and char 2
produces a 256 bit or 512 bit hash
depending on which one you use and both
of those were designed by the National
Security Agency in the United States so
naturally that means a few people
slightly nervous so there was a
competition to come up with a new one
called char free because they're very
imaginative with the names and the aim
of this competition was it was going to
be an on NSA designed hashing algorithm
so in the ends algorithm called kick
hack I think is how you pronounce it I
know I hate pronounce it was deemed to
be the winner in 2012
now unfortunately that's not in the
dotnet framework yet but I'd expect it
to be in there at some point in the
not-too-distant future so how do we
create a hash again it's very easy a lot
these things are very easy to use so in
the method on the screen we pass in a
byte array which is our data we want
hash so that could be someone's password
it could be a PDF document it could be
anything songs it's in a byte array then
we call a static medical create on the
sha-256 class
or objects and then we call compute hash
and we pass in the data we want hashed
and then we receive a byte array back
which is our hash the piece of data so
moving on from that then so the next
step of hashing is called authenticated
hashing and these are or they're correct
term is hash message authentication
codes or h max so these work exactly the
same way is how you generate a normal
hash so you pass some data in you hash
it you get a hash code back out the back
of it but what you also have the ability
to do is pass in an encryption key so
using one of these random numbers that
were generated 32 bytes in length you
can pass that key in and generate the
hash code now the good thing about this
is the only way you can regenerate that
same hash code is if you have that
encryption key so if someone hasn't got
the same key and they try and regenerate
the hash hash will be different so it's
good for authentication because someone
has to be in the possession of that key
so we'll talk about that quite a bit
later on so said they used for verify
integrity and authentication which is
what makes them powerful and you can
have h max based on any of the hashing
algorithms so md5 or the char family of
hashes we can use sha-256 in the
remainder of this talk and the strength
is based on the length of the key so you
want a good strong key which is why
typically these days we use 32 bias
which is 256 bits
you can't go higher but generally at the
minute people tend to use 32 by it
keys and the most common type of attack
against this is called a brute-force
attack and we'll talk a little bit about
that in a moment but again they're very
easy to use so have a method here we
pass in a byte array of our data we want
hashed we pass in a byte array which
represents our key so if a to two bytes
of random data and we create an instance
of the H max sha-256 objects we pass the
key into the constructor then we simply
call compute hash on that objects
passing in our data that we want hashed
let me receive a byte array out the back
which is our hash code
so that leads us on to talking about
passwords whether the thorny issue of
passwords so passwords are kind of
essential to every system we use that's
the common way B's to authenticate our
users and typically the way people do
this or have done it previously is to
hash the password to store those hashes
in the database so has anyone done that
in the systems they work on or seen that
a few hands Publix people know where I'm
going next so this is all well and good
and it's served its purpose for quite a
while but it's actually not that secure
so you can do what's called a
brute-force attack against that password
which is where you just try billions of
part of our combinations per second and
in eventually you're going to be able to
generate the same hash code for the
password another type of attack is
called a dictionary or rainbow table
attack and these are huge databases of
passwords including all the clever ones
we turn the vowels into numbers and put
exclamation marks at the end you know
that really doesn't work so these
rainbow tables exist and literally you
know passing your hash password and it's
more than likely gonna have that
password in the dictionary and the
reason why these are these attacks are
easy to do is because generally used
tools that hash cat and which works
using the GPUs on your computer so GPUs
are probably increasing in speed at a
faster rate than what normal CPUs are so
people leverage the power of GPUs to try
and crack passwords so you can literally
do billions of combinations per second
so a good way to illustrate this so
there's lots of sites like this on the
Internet this one's called crack station
net so you park you paste in your hashed
password at the top there that's a
sha-256 hash password they put in a
little capture hit crack hashes and then
it recovers to password for you pretty
much instantly and it's pretty accurate
you can download from dubious places on
the Internet massive databases of
passwords so it's not it's not a very
good technique so we want to do
something slightly better so the next
best way but not the best way is to do
what's called salted password which is
where assault is effectively another
random number and you know so you
phototube bytes in length you append
that to the password and then you hash
the pass
and that gives you what's called
increased entropy so it increases the
password space that you've got to search
to try and break that password and again
that's much better than just doing
hashes or even plaintext passwords but
as GPUs are getting faster this can also
start becoming susceptible to attacks as
well because you can still test billions
of combinations per second so you know a
password that's hashed as opposed to by
salts may be secured now but you know
who knows what could happen into for
your you know five years as these GPUs
get faster so what we want to get onto
now then is the better way of doing it
so it's using something called a
password-based key derivation function
very obvious what that is isn't it or as
it's commonly known a pbkdf2 so if you
want to sound really cool down the pub
you can just talk about pbkdf2
but actually the concept is very simple
in what it's doing so we have the
password that we want to hash go into
the box at the bottom we have a salt so
we're still going to use a salt you know
first to buy a piece of entropy but then
we pass in a number of iterations and
what that number of iterations is is the
number of times that pass was gonna be
repeatedly hashed and the reason we do
this is we're trying to algorithmically
slow down the hashing process so if you
think about a GPU can crack say 2
billion passwords a second if you our
Griffin to slow it down then maybe they
can only check 10 passwords a second so
it makes it much harder for them to do
it and less efficient
so a password based key derivation
function is actually an official spec so
I've had to write it down so can ever
remember it it's called the RSA
cryptographic standards pkcs number five
version two if you if you're wondering
and it's also publishes an RFC document
so it's also called RFC two eight nine
AIDS okay and this is why a lot of
people don't tend to know about these
things because they've given very
non-obvious names but the idea is he
supposed it slows the password cracking
process down so it basically makes it
much more secure but you'll be glad to
know it's very easy to use
provided you know what classes to use so
we have to use RFC up there RFC two
eight nine eighty derive bytes of course
it's obvious
so when I method up here now we're
passing in a byte array of our data to
be hashed or password in this case we're
passing a salt a photo two bytes of
random entropy and we pass in a number
of iterations create an instance that a
class pass all those three things in
call get bytes and passing 20 and then
we get the resulting byte array which is
our hash
so the reason we passing 20 to get 20
bytes is the RFC to eight nine eight
derive by its objects you see char one
below the scenes or blow the covers
which is gives you a twenty by a hash so
you don't need to actually extract any
more than 20 bytes so what's a good
number of iterations to use and when I
originally wrote this talk probably a
couple of years ago now how did a little
test on my laptop I did some timing
tests so four hundred iterations it took
two milliseconds so hashed a password
for a thousand iterations it took 16
milliseconds 10,000 iterations it took
196 milliseconds all the way up to half
a million iterations and it took seven
seconds just over seven seconds to
calculate so one of the things you need
to think about as a developer is what is
an acceptable amount of time or delay to
incur on your users on your systems so
you know seven seconds is very secure
but if you've got a pup you've got
someone logging onto a website do you
really want them to wait seven seconds
they're probably going to go somewhere
else so you have to work out what's an
acceptable level so I mean I've if
sometimes if you go into a website and
type a password then it feels like you
wait in a couple of seconds it's
probably because they're using this
style of password hashing behind the
covers so you know typically I'd say you
know one hundred thousand or between 100
and 200 thousand iterations you probably
don't get the good bets but you have to
think about the context in which you're
using these algorithms does anyone
remember this from a few years ago
I'm not gonna ask if anyone was a member
cuz I'd be on the phone but actually
Madison they had to know what their
source code and dates and lots of other
stuff stolen and one of the interesting
things about it was how they took their
approach to passwords so they were
actually being quite good they were
using something called bcrypt
behind-the-scene now bcrypt is kind of
another flavor of password-based key
derivation function it uses different
algorithms internally but it's a similar
concept you have a hash password and a
number of iterations and that's how they
were still in their passwords that's
great but the attackers also stole the
source code to the system which was a
bit of a problem because when they were
going through it they realized that some
enterprising engineer at the company to
try and improve the performance of the
system was actually storing local md5
hashes of the passwords so when you read
log on to her sites
it was storing an md5 hash which is a
lot easier to brute-force and because of
this and they managed to recover about
11 million passwords from the system
just because some Engineer probably
fought his do something good to improve
the system not actually really knowing
what he was doing she caused a major
problem so there's a really good article
here on that link there which talks
about the story in a lot more detail
what we can do today it's all talked
about how they put the processes are you
went through two to do that okay so
we've talked about random numbers you'll
talks about hashing authenticated
hashing and password so let's move on to
encryption so the first one we'll look
at is symmetric encryption and the
reason this way this works is you have
an encryption key
you use that to encrypt some data then
to decrypt that data you use the same
encryption key so that's why it's called
symmetric now there's a one problem with
symmetric encryption is to actually
share in the keys is very difficult to
do so if you've got an encryption key
and I encrypt some data how am I going
to get that key to someone else now am I
gonna email it to you probably not a
good idea should I put it on a USB stick
and hand it to you probably better but
you know someone bashes you over the
head with a pipe and steals the USB
stick you're in trouble so this is one
of the problems of symmetric encryption
it's one of the things we can talk about
later
took about hybrid encryption it became
just show this slide again encryptions a
two-way operation as you said it's
symmetric use the same key to encrypt
and decrypt whereas hashing which we
talked about before is a one-way
operation so it works n is we encrypt
several bytes at a time and that data is
basically split into blocks it does some
internal encryption operations doesn't
loss whopping of all the blocks but it's
a it's a very algorithmic process it's
very fast and the blocks are typically
padded as well as if you get to the end
of the day to your encrypted and it's
not at the correct size of the block
then it will pad those blocks out so in
dotnet there's free encryption
algorithms we can make use of says AES
which is one we're gonna talk about most
later and there's another one called des
and in Triple DES so they're kind of
older encryption algorithms they've been
broken the reason they're still in the
dotnet framework is again you might be
dealing with legacy systems that have
got des or Triple DES encrypted data
it's why used to work for a large bank
in the UK and our core banking platform
was actually on an IAS 400 I'd be a
mainframe so some of the data that it
were passed back to us it was encrypted
with Triple DES so we had to use some of
these classes to access that data but
you don't want to go into writing a new
system using DES or Triple DES you all
know whose AES so a AES is international
standard
so was the u.s. national standards and
institutes and Technology standard and
it was made a standard in 2001 and it
was invented by two Belgian
mathematicians so Joan Damon and Vinson
rhymin and the original algorithm they
came up with is called Ryan down but
then round out was what originally won
the competition and became the standard
and he's known as AES as we know it
today so to use it there's several
things we have to do to pass into a yes
to make it work so we have our plain
text at the bottom so that's a data that
we want to encrypt
do we want to make a secret we have our
key which we pass in as well so that
could be 128 bits 192 or 256
it's in length so we can use 256 bits
their military sprinkled an
initialization vector which is 16 bytes
of random data that you have to pass him
and the reason we do that is because the
data split into blocks and he does
operations between those blocks you kind
of need a bit of seed data to get it
started it's kind of like a kickstart to
the algorithm so we pass in 16 bytes to
do that those 16 bytes aren't secret
they're not a key so you can store them
along with your data it's a need to be
aware of so in doc nets we have two
flavors of AES which are most commonly
used this AES managed and AES crypto
service provider and they both do
exactly the same thing so AES managed is
a native dotnet implementation of AES
and there's everyone with it it works
it's fine it does his job but it's not
been certified with something called
FIPS 197 - - which is basically a
certification scheme that the algorithms
go through and what that gives you is
then if you're certified you know that
if you receive any encrypted data from
another system say written in Java or an
IBM mainframe you're going to be able to
decrypt that data and vice versa so AES
managed hasn't gone through that
certification scheme it'll probably work
but it's not certified to work so the
alternative then is AES crypto service
provider and that usually the underlying
windows crypto platform and not quite
sure how they've done it in botnet core
basically used something else I don't
know what so to use it again is fairly
straightforward and all the code which I
said about on github at the beginning
all of this is in there so you can just
steal it or steal it borrow it use it
it's open source so we have our in quit
method and we pass in a byte array of
our data to encrypt that could be you
know that small bit attack so it could
be a large document that's been split
out into a byte array we pass in our key
which is 32 bytes in length and then we
pass in our sixteen byte initialization
vector then we simply create an instance
of the AES crypto so to provide a class
we
in the key in the IV and then we creates
a memory stream and a crypto streams
it's all stream based how it works so
you can pass in quite large pieces of
data and then we you know cool right and
then flush on that crypto stream and
then we can pull that data back out
which gives us our encrypted byte array
so it's quite straightforward to use and
to decrypt it and they'll be passing the
same information our data to the
equipped our key and our initialization
vector we create the AES crypto service
provider class create the streams cool
right on the streams and then that data
gets decrypted so it's nice and
straightforward to use
okay so following on from symmetric
encryption we have a symmetric
encryption so I'm sure everyone's heard
of RSA okay yeah so it's a same premise
but it works in a different way so in
asymmetric encryption we have two sets
of encryption keys you have a public key
and a private key I'll talk about those
a little bit more in a minute so RSA was
invented by RSA data security
incorporated in the States by free guys
Rivest Shamir and Adleman
and the way this works compared to say
AES in AES is very old with making how
it works you know it splits about data
into blocks it does encryption
operations it swaps blocks around so
it's very you know what we typically
think of as a computer algorithm
whereas RSA is more mathematical in how
it works it's all based on modulus
arithmetic so at the moment the current
minimum recommended key lamp for RS 8
2048 bits but you can use 4096 bit keys
as well one of the downsides of RSA is
because it's mathematical and it's all
based on modulus arithmetic is you can
only encrypt up to the size of the key
so you're limited on how much data you
can encrypt in one go which seems like a
bit of a limitation but as you'll see
later it doesn't really matter because
when we start combining a lot these
systems together we get a lot of
benefits so the way the key works and
it's all based on prime number
factorization so if we have this simple
sum up here so 23 times 17 you know even
in our heads on a calculator and quickly
work out the answer
it's 391 if we go the other way so far
so I ask you what two prime numbers make
up five thousand nine hundred and
sixty-three anyone know the answer no
one's got it yet that's fine
so it's 67 and eighty-nine multiplied
together and that's kind of the
underlying premise of how the security
of the keys works but the prime numbers
are huge massive prime numbers so in
this sort of case our public key is the
five thousand nine hundred and
sixty-three and the private key is the
67 and eighty nine numbers so the
private key you don't want anyone else
to know that's your own private key but
the public key you can put it on the
internet you can post it to people email
it it's it's okay for anyone to use how
does this work in practice then so first
of all in dotnet we want to generate a
new key or a new set of keys so you
create the RSA crypto service provider
class you pass in the key length that
you want so in this case 2048 bit keys
and then you call export parameters
passing you false gives you your public
key and then you could pass seen true
and it gives you your private key so in
this example we're just storing it in
memory so one thing has to be aware of
is how you're going to secure and
protect those keys it's one ways you can
generate certificates to store them in
certificates or you can use things like
as your key volts or all hardware
security modules to do that so is
everyone here
work on Azure what is sure and then we
come from know few people okay so azure
kevo is effectively a hardware security
module or an abstraction over a hardware
security module when it's a piece of
hardware which is designed to secure or
to store encryption keys very securely
so if anyone tries to tamper with the
hardware security module then it wipes
itself so Microsoft has data centers
full of these things they're based on
the thallus and shield hardware so
highly recommends playing around with
that it's actually very cheap to use on
a dribbler costs cents per key it's
really cheap
and that's what from code okay I mean
there's a full set of API so you can use
it and use it from what you want okay so
to encrypt some data then so we pass in
a byte array of our data to encrypt we
create the RSA crypto service provider
objects we import our public key because
when we encrypt data we use our public
key to encrypt it and then we call RSA
dot encrypt and then we get our
encrypted data back out so to decrypt
the data we pass in our data to decrypt
typos on slide there create the RSA
service provider objects we import our
private key this time because the
decrypt the data we need to use our
private key then we just called equipped
on the RSA object and we get the
original data back so we think about how
this is being used in fact here so if I
want to send say you some data I would
use your public key to encrypt the data
and then you decrypt it if your private
key but you're the only person that
knows that key okay so moving on from
asymmetric encryption we've got digital
signatures so early one when we talked
about the four pillars around
cryptography one of them is
non-repudiation so being able to prove
it was actually you that sends a piece
of data so this is where digital
signatures help us out with that
and these are used all the time so has
anyone used DocuSign the website yeah
shoot a few hands up there so DocuSign
is a good example so it's a way of
signing contracts between two parties so
we use it a pro site when we sign a and
all for agreement for a course we do a
two-way signature thing with DocuSign
and that's using digital signatures
behind the scene so that if say even me
or cause I disputed anything in the
contracts where you can't because we
both both digitally signs that contract
says do digital signatures we kind of
need three different things to any key
generation which is exactly the same as
what we did for RSA and we need a sign
in our Griffin and a signature verifier
algorithm so the way this works saying
is you have a large piece of data
in the green box at the end there and
then you create a hash or hash Mac with
that data so you end up with the data to
buy a hash that piece of data it's
actually that hash which you then create
a digital signature off
so because additional signatures in.net
are based around RSA you've still got
that limits of how much dates you can
encrypt in one go so you tend to
generate your signatures off of hashes
of other pieces of data so if we look at
this as an example so we've got Bob
wants to send a digital signature so
what he does is he creates a digital
signature using his private yeah his
private key so you remember before when
we used i RSA you're being cryptic with
a public key and decrypted with a
private key this is the other way around
so we create the signature using your
own private key you send the message
over the Internet to someone or the
intergalactic spider's web
my diagram I'm not very good at art and
design on a Friday so you send that
image that that digital signature to
Alice at the bottom there and then she
uses Bob's public key to verify that
signature so if anyone else other than
Bob created their signature then the the
signature won't verify at the end so
Alice will know that that message didn't
come from Bob so we're going to use it
it's quite straightforward so we
generate a set of keys exactly the same
code as what we saw a little while ago
and then we want to use a class called
an RSA pkcs1 signature formatter
wonderful bit of class naming by
Microsoft there so what we do so we
create the RSA crypto service provider
then we load our private key into it so
our keys were ready to use and then we
create the RSA pkcs1 signature formatter
try saying that after a few beers and we
party in the RSA objects we tell it what
hashing algorithm we want to use so char
t56 in our case here and then we call
create signature of the hash that we've
passed in and that will give us back
it's quiet array with that digital
signature in so now if we want to verify
that a signature is valid so I recipient
is now going to check the signature we
pass in
the hash of the data that's been signed
and we pass in the signature create the
RSA crypto service provider object
loading the public key that's what we're
going to use to verify the signature and
then we call RSA pkcs1 signature D for
matter set the hashing algorithm to
sha-256 and we call verify signature and
we pass in the hash of the data that was
originally signed and the signature and
they leave a return true or false true
it's about a signature folks it's not
discarded okay so if we do a quick recap
of the four pillars and then we'll look
at how we've satisfied those four
pillars so confidentiality we talked
about AES and RSA so that's new typical
encryption that we all know enough
integrity we talked about hashing and
we've used sha-256 there's a hashing
algorithm there authentication we use
hey shush max or hash message
authentication codes using sha-256 and
then we talked about non-repudiation
using digital signatures you've been
able to prove that you're the actual
original sender of a message so it's all
great and very useful in their own life
but really want to do is start using
these things together to do think more
powerful which is where we get onto
hybrid encryption okay
so we've already said the RSA has a
limit on the amount of dates you can
encrypt in one go it's a very slow
mathematical process so you can't
encrypt or decrypt anything bigger than
the size of the key is on the other hand
is very fast and very efficient
encrypting data but sharing the keys is
hard you can't it's very difficult to
get a key from one person to the other
so what we're gonna start off by doing
is combining RSA and IES into a hybrid
scheme so we're gonna build this up bit
by bit so what we're gonna do first in
is we're gonna use AES for encrypting
our data and then we can use RSA for
encrypting our encryption key so if we
walk through this is a few examples so
first of all we're going to generate a
session key so it's just a 32 byte
random number
generates then we're gonna use that
session key to encrypt our data using
AES it's that's our data encrypted they
need to be sent and then we can use our
recipients public key to encrypt that
session key then we send the whole lots
over to the recipient and then for them
to recover the message they have to use
their private key to decrypt the session
key and then once you've recovered that
key they can then go and decrypt the
original data and given that neck is in
the original data back so in terms of
the data that we're sending across to a
recipient so we've got the RSA encrypted
session key we have an initialization
vectors removed we need 16 bytes to
jumpstart AES and then we have the AES
encrypted data they've on front of that
so far let's walk for a couple of
examples so Alice once has had and Bob a
message so she starts off by generating
her session key and then she generates
her initialization vector she encrypts
her data with AES that so dates are now
protected she don't encrypts her session
key of RSA and posts the whole thing
over to Bob so Bob now wants to read
that message so he decrypt the session
key using his private key cuz only he
knows that private key he then uses that
the cryptic key and initialization
vector to recover the original message
and then he can read the message so meet
me at noon blow the clock tower where a
red rose in your button V spy thriller
so now Bob wants to send a reply back to
Alice so he creates a new session key
cue never reused the same keys you
generate new ones he creates a new
initialization vector and he then
encrypts his reply using that session
key he then using Alice's public key
encrypts the session key and then sends
a whole lot across to Alice so she now
uses her private key against only she
knows her private key to decrypt the
session key she then uses that than the
IV to decrypt a message and they can
then she can read it so I will meet you
I'll be wearing a blue hat and red boots
so she's a very fashion-conscious
that's great so we've satisfied a couple
of problems so we've satisfied the the
fact that RSA can only encrypt small
amounts of data efficiently and we've
also fixed the problem we're getting an
asymmetric key from one person to the
other which was hard we've now had a
better way of doing them so now what we
want to do is we want to make sure that
whoever receives that message is
confident that someone hasn't tampered
with the data always being corrupted as
it's been sent so once no is that data
actually intact and not being fiddled
with so we did exactly the same process
as what we did before but before we send
the message to the recipient
we also generates a hash mark of the
ciphertext in the IV concatenate it
together the reason we use a hash Mac is
because we can then use that a session
key to generate the hash so in any way
you can verify the hash is if you've
recovered the key on the other end so
then on the other ends the recipient
uses their private key they decrypt the
session key they can decrypt the text
and then they can use that decrypted
session key to verify the hash if the
hashes are identical then great the date
has not been corrupted if the hash is a
difference then you discard the message
because someone's either tampered with
it in transit always been corrupted over
the wire so our data that we send across
the wire then looks like this now so we
have an encrypted session key we have a
mission as a tional vector we have only
s encrypted data and then we have a H
Mac of the encrypted data that's great
so now what we want to do is you want to
make sure it was actually Bob that sent
the message in the first place and not
Jeff Eve evil Jeff so game everything
we've done before we're still going to
do but before we send the data we're
going to use our private key to create a
signed hash
but the hash that we created previously
let's using our private key so as the
sender only I only I have that private
key so if anyone verifies the signature
on the other end you can only have come
from me unless someone's stolen my key
so again if we look at what that looks
like so when we send that data we have
the RSA encrypted session key the
initialization vector that is encrypted
data we have our hash of the encrypted
data or a hash mark of the encrypted
data and we have a digital signature of
that hash so the person on the other end
has to verify that signature they then
have to use their private key to decrypt
the session key which I then used to
decrypt the data and then read the
message
so actually what we've done so we've
used all of these very simple primitives
in dotnet to give us something quite
powerful so we can send we can securely
send data from A to B using public and
private keys because that makes the key
sharing problem a lot easier but we've
used the efficiency in the speed and
power of AES to encrypt our data and
we've made sure that the data hasn't
been tampered with over the over the
wire or been intercepted and we've also
made sure that you know we're sure that
it was actually Bob that's in that data
in the first place it sounds quite a
powerful concept I've just talked over
that start without showing the slide but
that's the fact we recap in what we've
just done it's anyone's brain melted yet
okay so that's effectively what I wanted
to cover there's quite a lot to it as I
say if you don't quite understand all of
it right now that's absolutely fine
treat this talk as kind of the art of
the possible so you kind of had a flavor
of what you can do with these sorts of
things if you do want to watch my course
it's about three hours long before hours
long it covers the same topic but he
goes into a bit more detail and a bit
more depth and it walks you through all
the code samples so it's it's a slow way
of going free which is good where we
talked before about the difficulties of
storing RSA keys so this course here
shows you exactly how to do that and
again all the source code phase of
on the course so you can just take it
and that shows you how to store keys in
your key votes if you're using Azure
I'm sure AWS and Google cloud have very
similar things in them as well I've just
not used it myself that's a good way of
securely protecting your RSA keys so you
feel free to use the code steal it do
what you want with it and use it as a
basis for your own security in your own
systems I encourage people to do that
and take a look at it
and again the slides all on github as
well so if you want to refer back to the
slides you know you can just go and
download them from there I don't want
the slides for my for talks so a bit of
further reading so I mean when I first
started looking at this sort of stuff
years ago it's it's absolutely
fascinating subjects cryptography so
I've got three book recommendations here
should you want to go in more detail on
it so the first book is called the code
book by the back with Simon Singh it's a
very small book it's kind of a novel
sizes I read it on holiday once my
wife's horror but it kind of covers the
history of encryption and cryptography
from sort of ancient they helped us or
modern modern day so it's kind of a
historical document more than anything
is good fun to read everyday
cryptography covers a lot of the things
that we talked about today in hybrid
encryption but it also has lots of
examples about where encryption in
cryptography is used in real world
scenarios so how does a TLS handshake
work when you use your browser how to
cash machines authenticate you it goes
into more detail on that the last book
is called applied cryptography now this
is the book that was released in the
early 90s this is the book that the NSA
tried to ban at the time this is at a
time when encryption was considered
ammunition a weapon but it's a fantastic
book but it's very mathematically heavy
so you have to be into that kind of
thing it doesn't cover AES because it
came up for AES was written but if you
want to have a good insight into how
these algorithms have evolved over time
and how they work and it's a great book
to read so thank you very much I hope
you've enjoyed it
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>