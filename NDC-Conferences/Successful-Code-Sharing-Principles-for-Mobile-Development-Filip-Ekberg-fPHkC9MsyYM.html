<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Successful Code Sharing Principles for Mobile Development - Filip Ekberg | Coder Coacher - Coaching Coders</title><meta content="Successful Code Sharing Principles for Mobile Development - Filip Ekberg - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Successful Code Sharing Principles for Mobile Development - Filip Ekberg</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fPHkC9MsyYM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we're gonna be talking about
successful code sharing principles for
mobile development is everyone in here
doing salmon or different mobile
technologies when you react native or
native script it's a bunch of different
ways for us to build mobile apps and I'm
here to talk about how we can do this in
a more proper manner using salmon so
I've been in a bunch of different
Salmons projects all over the world and
I see a few common mistakes and I've
learned a lot during the times on those
projects so I will be sharing a little
bit about how we can improve how we
build these apps by plowing a few good
principles before that though I am
Philip Ekberg I'm a Microsoft and salmon
MVP that pretty much means that I go
around to conferences and talk about
these technologies don't really mean
that I know how to actually build the
apps so I do my best to learn about all
these technologies and a lot of talking
about them and what I want to do is that
if you snap a photo and ping me on
Twitter you have my Twitter handle there
I'll give you a free copy of my book
c-sharp smorgasbord all right so so
sixel successful code sharing principles
what I want to talk about is some really
fundamental and easy ways for us to
build better mobile apps will apply some
you know the principles that we learned
back in school or when we started
programming will try and reapply that in
our cerumen applications because it's
really hard for us sometimes to get this
done correctly in a mobile environment
because fundamentally these platforms
are totally different and if you come
from a Java background or a swift
background you've seen how you do it on
those native platforms but when you
start introducing more platforms
everything becomes a little bit more
interesting so I like to talk about this
from the perspective of you know
unsuccessful code rank principles
because I've been in plenty of projects
where we've kind of failed doing code
sharing properly and I don't know if I'm
the common denominator but I've been in
all these project that potentially had
you can take good a better code and I've
learned from that and I'd like to share
a few things that I think is interesting
and this is in salmon it's everyone here
familiar with salmon this is not an
introduction to stammering I will show
some fundamental parts in
building apps using salmon and how we
can improve those apps and I will talk
about kind of the future of how you
would build an app maybe in six months
or a year from now and kind of what my
goal is when I apply these principles in
these apps so the idea of salmon is that
we can achieve really good code across
different platforms that are totally
different so if I've got a Tison Samsung
TV that's a smart TV at home if I've got
a whole lens if I got this surface hub
or if I've got a surface book or you
know a iPad or an Android tablet or a
SmartWatch I can share the same code
across all those different platforms but
the interesting thing here is that
they're totally different it's different
ways of interacting with the platform
but things like how do I store data
across these platforms that's probably
the same if they're hooked up to
internet like I can use the EH to be
client and things like that I wouldn't
talk about how we can make it easier for
us to introduce code that's shared
across all these different platforms
even if there are totally different so
now when we talked about code sharing
the the total ID here is that we have
this really enormous shared c-sharp
application layer and you've probably
all seen this graphic before where we
talk about the the perfect world we have
three different pillars we might have
iOS Android and if you have a boss that
uses Windows Phone you probably have to
build a Windows Phone app otherwise no
one really focuses on building windows
phone apps anymore but what happens here
is that the IDs that we have C sharp
code across all the platforms so we
divide these into boxes we have a small
layer that's an iOS project an android
project and then we have a lot of code
that's being shared what I normally see
though is that it's really hard to share
a hundred percent of code across
platforms that are totally different so
what happens is that we pretty much end
up with something like this here we have
a very small share code layer and then
if we have a totally awesome iOS
developer what happens is that the Iowas
layer kind of tends to grow a lot
because they like to do everything
natively but in c-sharp using samory so
what happens is that we try to build the
apps like you would build them when you
build a native app but you do it in
insane
which kind of defeats the purpose so the
ideas that we try to minimize the amount
of code that we have in this shared in
the platform specific layers and add
that to the shared application layer
instead so I'd like to have a look at
kind of a current state what you would
get when you start Visual Studio for Mac
and you create a new project you get a
really nice project template and that's
kind of their idea of having like a a
perfect goal or the holy grail of what
the abstraction would look like but if
they did it perfectly I would probably
not bring it up as an example so what we
have here is an application that's
available for Android and iOS and when I
create the solution here I get three
different things I get a shared shared
project a shared project is a way for me
to create c-sharp classes interfaces and
services and repositories and all that
and have that in one place but the
difference between a shared project and
any normal project like a class library
in c-sharp is that all the files that I
have in here are going to be brought
into the project that I compile and be
compiled as a part of that that means
that if we're going to this file here
called app CS for instance which is in
this demo one shared project you can see
here that there's there's no references
or anything in this project and if I
would try to compile this nothing would
happen because what happens is that when
I see sharp compiler sis this project
it'll bring in this app class into the
project that I compile which would be
the iOS or Android app and it compiles
that as a part of that project so what
it does that we can do things like we
can say well if it's iOS I want you to
compile this line of code here otherwise
I want you to compile this part of code
here so I'll cover more about why you
would would not want to do that
in just a moment but what we can see
here with this project is that well we
are trying to follow some really best
practices so they're trying to set this
up with the same principles that if you
see in salmon forms so they have this
idea if there's one app file that
controls the states in our app or
setting everything up like dependency
injection and inversion of control and
then we have something
called view models now the view models
and the idea of a view model is that we
have logic that concerns a certain view
in that particular file so for instance
if I have an iOS app or an Android app
and both of them have a login screen you
know both of them probably require the
username and password probably have the
same requirements for the password and
something's gonna happen when you click
login like the idea of this that same
logic happening in all the different
platforms will be the same right it
doesn't matter if it's an iOS or Android
device so the idea is that we bring all
that UI logic into one place like a view
model and we add that to our project so
now what happens is that we have a
reference to that here in our android
project and I'll just start this here
and I'll show you what this app looks
like so you know the idea here is that
we have this kind of big project for
Android and it looks like an Android app
because salmon is native and all the
times that I've talked about salmon in
the past one of the things that our
reiterate is that everything is native
all the controls are as fast as you
would get issue if you built this in in
Java now what we can see in here is that
we have this this main screen here and
you can see here that it says sign in as
Phillip here now what it's doing is that
it's it's in the background it's using
some service and it's using some
patterns to allow me to share instances
across different screens so what we
didn't see here was that in the splash
it sets up some value which I can then
use somewhere else in the app so that's
the idea of separating concerns in my
app so what I'm going to be able to do
is that I want to be able to use the
same kind of data across the different
screens in my app and if we just go into
this here before we look at the code
we'll see here that we can click around
this in this salmon application and it
looks like an Android app so what
they've done here is that all the things
for like the data store and all the
information that's stored inside this
shared project and how we build up all
those different pieces is stored in this
shared code but the problem here is that
we have a lot of files in our android
project we have things like activities
which is a way for us to set up the view
on Android and if we have a look at this
splash screen we'll see here that just
turn this off so it makes it easier to
to look at we can see here that well
it's requesting a few services using a
few patterns that I'll talk about later
on but we can also see here that well
it's doing a bit of logic in here and
you know we want to build applications
using better practices and one of the
reasons that we want to do that is
because we want to build apps that are
more maintainable and probably more
testable right so even if this small
part here shows us that well it's just
checking if we're logged in and if we're
not logged in we'll do this if we're
logged in we'll go somewhere else
now this is a very simple example but I
want to see happen quite often is that
well it's just this part of the code
here so how about I'll just add a few
more lines let's add something to the
database right and then do something
with Google Analytics right so what
happens here is that if we start adding
more things into the platform specific
layers will start having more and more
code inside the wrong places
so we'll start to look at a few
practices that we can go by to make this
a lot better so if we use this as a
current state so this is like a really
good example because it's it's already
very good but they've still done a few
things that I think that could do better
such as I wouldn't do things like the
view logic inside one of the activities
because the same logic applies to both
iOS and Android so just play with the
thought that those six lines we could
bring them into a view model or
somewhere else that's shared across both
of the platforms and then we could just
add a lot of logic to that if we need to
right but then you ask yourself well how
do I transition to a new intent from one
of the view controllers
oh excuse me mm-hmm
so let's head back to the slides all
right hmm
so if we have this as a current state we
can see that it's really a good example
right because they've tried to do all
the right things but then they failed in
some places like still having new logic
inside our activities so why it's
co-chairing so hard well as I mentioned
earlier you know they're fundamentally
different right so iOS is totally
different to Android and Windows is
totally different to the other ones Wow
well that's never happened sorry so I
said in my talk earlier this week that
I'm starting to come down with something
so if I fall off this stage and you know
something happens just slowly walk out
of the room and put a green thing in the
box just forget you were ever here right
joking so co-chairing so hard because
their platforms are totally different
right iowa's is different to Android we
have different paradigms about the
different platforms and reduce these
activities iOS users view controllers
and so forth and it's not only that they
have different that they're
fundamentally different the different
form factors everything from the surface
hub as anyone see the surface hub the
gut one over at they ratify office it's
really nice it's this big 80 inch screen
it's like a smart whiteboard and with
the hololens and so forth so the idea is
that we can target all these different
platforms with the same code and if we
apply better practices it'll be easier
for us to target new platforms most of
the times you know when we look at
things like the Android we want to build
a UI that works on all the different
Android devices
you know platform platform fragmentation
and OS fragmentation on Android is
really silly like I don't know if we
have any native Android developers here
that have been around for a long time
like there's so many different form
factors and the API levels and the
different things that you can or cannot
do on those different platforms so we
want to choose like a minimum version
that we want to target even though just
stick with that and sometimes it is ok
to you're gonna break out of the box if
I'm working with shared code and I want
to do something very platform specific
you know that's that's alright we can
totally do that and we'll look at some
example on how we can do that properly
sometimes you know when we're building
applications and this is this applies to
like every different software product
that we have out there it feels like
we're you know we we know where to start
we know where we want to end we we hit a
few roadblocks along the way and it
feels like this makes what we need to go
through
this applies to pretty much every
different software project right if
we're working agile there's a few
changes along the way that makes it
harder for us to reach the goal
sometimes but I feel like if we add you
know the parameter of having all these
different platforms kind of end up ends
up being this instead right so we want
to target we'd build this thing on
Android you know we're gonna build that
thing and I was and one of the things I
find happening is that you know I'm
starting off a new project and we start
up building the Android app and then you
know you build all the UI with all the
logic and then in the end of the project
someone says well let's just compile
that for iOS doesn't really work like
that we need to get all the parameters
in the start and it is amazing that and
a lot of the times when I build salmon
apps I do feel like this I want to
scream at my code I want to you know go
back to the start of the maze and just
review everything and hope for a better
world right I want to hope for
everything to be better the second time
I do it then I restarted to do the same
mistakes again or different mistakes so
how do we solve this how like how do we
make our code better how do we approach
this so we've talked about we've looked
at code that looks pretty good and a lot
of us probably work in code bases
are a lot worse in a lot worse state and
what we saw from that out-of-the-box
example well you know one of the ways
that we solve this is by introducing
abstractions now an easy way for me to
score a lot of green votes would be to
jump around here like Steve Ballmer and
scream extractions abstractions
abstractions but since I'm coming down
with a cold or something I'm not going
to do that but you're welcome to put a
green vote in the box anyways all joking
aside so how do we solve this well you
know we can introduce interfaces we can
introduce abstract classes and to make
sure that we use that interface across
the the portable class library or we use
that inside our shared code so then what
happens when we try that so I've done
that as well and what happens is that we
look at that shared code and all of a
sudden someone tries to do plot from a
specific code in our shared libraries it
kind of defeats the purpose so what do
we mean by use doing share like platform
specific code in those shared layers
well the code that we just saw inside
this projects here let me just show that
again so we saw it that we can say well
in this app when we start off this
entire app this class is initialized
from both Android and iOS and we're
saying here that well if this runs on
iOS I want you to do this part of code
here what's interesting here is that
they're simply saying that well I want
an iMessage dialogue to be an iOS
message dialog for Android I want that
to be a droid message dialog actually
they're saying that if it's iOS I want
that to be a particular iOS message
dialog and for Windows Phone and
hololens and all the other platforms as
well I want this to be the droid message
dialog right so this is kind of where
we're leaking platform-specific code
inside our share code and that's not
good so that's one of the things that I
don't like about their out-of-the-box
examples like it's fine to want to have
platform-specific code but don't add
that into the plot like into the share
logic so how would we properly structure
that well we can introduce layers in our
apps we've all looked at all the layered
structures
over the years and I like layers so what
we can do if you start from the bottom
we introduce a portable class library I
like to think about that as where to put
the code that I would share across Saron
apps desktop apps you know a spinet apps
and so forth so what normally happens is
that in my projects but we do is that
all our PC else services interfaces
sometimes may be repositories depends on
how abstract they are we put that into
nougat packages and then we share that
in internally on an internal nougat
server with all the different teams
working on dotnet so that means that if
I need to talk to our back-end and I
don't want to introduce all the
different things that they've had to do
to make that work I can just bring in
that nougat package right and then one
step above that we were pretty much
inside the code that I write in my in my
solution that I have here so we start
looking at the shared logic which could
be common implementations for interfaces
so we look at an example of that as well
it could be that I have my for instance
an IEEE account service or an i were i
something repository or my service
living inside a PCL it defines a command
contract that this is how you work with
this thing and then for ios and android
the implementation is a little bit
different but if the implementation
would be similar on my serene apps but
different on the asp.net I can have a
shared project in my serene app that
implements that for both iOS and Android
in the city in the same manner and then
one step above that we have the shared
UI now don't be scared of doing shared
UI I'm not just talking about doing the
same buttons and inputs it could be the
view models right v-mon dislike view
logic so we could say if you click the
button this happens that could be the
same across iOS and Android then of
course we have the native
implementations so I like to think about
this as as you know growing the further
down you go so we want to have a lot of
PC ELLs a lot of codes shared from
coming in from you get a lot of code in
shared logic and then of course we need
view models and then small native layers
but I'm not saying that more layers is
necessarily better like we don't want to
end up having like a micro service
solution with 400 projects just to build
a simple iOS and Android app that's not
what anyone wants and there are so many
patterns out there that sometimes it's
really hard to know which one to choose
and I can you know I can say that we're
gonna use dependency injection and
inversion of control and we're gonna use
all these different awesome frameworks
to solve all our problems
but you know we can throw a pattern not
a problem and still have another problem
so we want to approach this with the
correct patterns to make sure that we
apply them correctly in our apps because
we see here with the out-of-the-box
example they're using something called a
service locator which allows us to solve
a particular problem especially if
you're coming from an Android background
that kind of makes sense because the
service locator is what you use an
Android so let's not just throw patterns
at the problem but let's introduce them
where it makes sense so ultimately why
do you want to do this well we want to
make sure that our code is more testable
and maintainable and hopefully it's
cheaper to build as well there they'll
go love salmon is to build cheaper
applications that perform as good or
better than native apps more code shared
and you know ultimately we want to be
able to target new platforms with as
little code as possible so as I
mentioned earlier like how do we test
this so we have there you don't like if
you're an Android developer you probably
cringe a bit even if you are a salmon
developer like why would you unit test
an activity well you wouldn't but then
again you shouldn't put via logic inside
your view I feel like this is like if
you've done wind forums or WPF this is
like going into the code behind and
adding a lot of few code like you just
don't do it so what I'm talking about is
this part here so if settings dot is
logged in do this otherwise do something
else so that part we're gonna break that
out and we do that by decoupling the app
by bringing in things like view models
and making sure that we have interfaces
and services that supports that and then
we want to use frameworks to help us
achieve those
different goals so one way to do this is
throw more lines of code at the problem
which is always a good good way to solve
anything so in this case here we have a
splash view model and this one here
takes an eye setting as a parameter to
the constructor so this here makes at
least a view model a little bit more
testable if you want to test the view
model then of course we're still doing
something in here but imagine that we
were to inject a navigation as well we
could say that well we inject an eye
setting as well as an eye navigator and
then we can check if it's doing the
proper thing depending on the parameters
that we said on our projects or in our
properties makes it a little bit easier
to test now of course this is a lot more
code and most of the salmon projects
that I've seen is that we start off with
one platform and then we add the other
one and if you do that you don't really
think about these things until you go
over to the next platform because you
want to be able to get your product to
market as fast as possible so what about
platform specific code like how do we do
things like NFC it's a funny story with
NFC I don't know if anyone saw the Apple
Keynote while back they've announced
that you can now use the NFC chip on iOS
and you know you've been able to do that
on Android since forever pretty much on
Android you can use both read and write
NFC chips so you can pretty much to say
that your phone is your opal card which
is pretty great so when Apple announced
that as well I'm like yeah that's
awesome because now I can simulate a
bank card and you said for bank
transactions where I can simulate the
opal card but what they've done is that
they've done read-only which means that
you can only detect if there's an NFC
tag so they've kind of done done one
thing but we're waiting for them to do
it properly
so that means that our shared code that
might be allowing us to do NFC needs to
be you know changed for iowa's but it's
a little bit different for android so
this is a good good scenario where we
want to be totally different on iOS and
Android we might not even want to
display certain things on Android or iOS
depending on if the features available
or not so how do we do this well I
showed you earlier that
we can be specific in a shared manner
it's in this case here we have a way for
us to retrieve a message from an HTTP
response message and the content here is
going to be gzipped
and if it's gzipped you have to manually
decompress that on android but that's
just automatic on iOS so the way that we
can do that is by instead of introducing
a lot of abstractions and interfaces and
services it's just as one line to say
well if it's on Android just run this
different thing you have to be careful
though if you do this a lot you'll end
up in scenarios where just grows and
grows and grows and grows and grows and
then you certainly end up having your
platform code inside your shared logic
and it's hard to test it's hard to know
what's happening and we all probably
know that if you have these compiler
directives sometimes the IDE doesn't
notice that you've changed which project
you're working on it just becomes hard
to work with so another way that we can
help with this is to introduce things
like tiny IOC so tiny I you see is an
ioc container which allows us to
register interfaces and implementations
and tinnitus it's just a small file that
you bring into your project it's
available in github and it allows you to
do things like I can register my account
service as an account service I can
introduce my my preference service is a
preference service in a cache as a
singleton cache now what's interesting
here is that we can say that well give
me the instance of an account service
which might have a dependency on a
preference service which might have a
dependency on cache so they're all just
automatically created and injected
properly into the constructor of those
different types so it really helps us
build better applications that are more
decoupled and what we can do here is go
even further to say that well the
account service is a little bit
different on Android so what I'll do is
that I'll just register a different
account service when we were in the
Android project and another one when on
the iOS project and then in the shared
code it'll just pick the correct one
and then we can introduce something like
the service locator to help us resolve
these from the containers so I can say
here that well when I ask for the
account service go to the container that
I've set up and ask for an i account
service now what happens here is that
it's going to find the correct
implementation for that particular
platform so let's just look at that and
see what it looks like inside our code
so we saw that pretty quickly just
recently that I did that here in this
project so I'm doing service locator
instance because this is a singleton I'm
saying well I want you to register the I
account service as my counselors now
what's interesting with the account
service is that it's in fact living
inside my shared project so I've got the
same implementation for both iOS and
Android
now we could play with the thought that
you know this I account service lived in
a PCL that I bring in over and you get
and then that's being used across a lot
of different places inside the shared
code that I bring into the project but
what I could do here is of course do
different implementations per different
platforms and this here allows me to for
instance as we saw in the splash if we
go down to Android I can ask for the
account service in here and then I can
tell this here to set something up I
want you to save some preferences for a
certain account so I have a demo account
here with a dictionary of preferences
sorry and then what happens is that I
can ask for the same one somewhere else
in the app so if we start the
application you'll see that it says sign
in as fill appear so if we go and have a
look at that particular activity which
is the login activity we can see here
that the login activity is also asking
for the account service and then it's
setting the button to that account name
so that's a way for us to share you know
instances across different decoupled
activities
all right so we could do the same for
iOS and Android and we can do these
things to make it easier for us to just
get our implementations somewhere else
so this is just a way for us and I'm not
saying that the service locator is the
best pattern out there like because it's
a single ton and because we were saying
that in here we were probably kind of
breaking a lot of other principles so
when I use the service locator I feel
like this a lot of his times what
happens is that well you add the service
locator and you you have this big method
and you're you're just asking for
dependencies from other places anything
while I'm using interfaces so that's
great I'm decoupling my app but what
happens is that if you want to test that
method like the person calling it how we
didn't know which interface is to add to
the service locator it would be pretty
hard now the way that we solve that is
by of course injecting the interfaces to
the method instead making it obvious for
whoever calls it which one to use Wow
and I tend to tell myself this I don't
want to repeat myself especially I call
myself an idiot all the time because I
keep repeating myself and one way to do
that to stop repeating myself is to stop
repeating the UI so how do we do that
well we could use salmon forms is anyone
using salmon forms no one hopefully will
be using a little bit of salmon forms
once we've done with this talk if I can
get through it without coughing all the
time send one recognize his background
it's from Windows XP now I'm not saying
Windows XP was the best project but was
certainly a product that lived a long
time and I just love the background so
greenfield projects are interesting
because that means that we can choose
whichever technologies that we we want
to do right we can choose the patterns
and practices that are appropriate for
our use case now I've done a lot of
mistakes in my career and I'm like even
if I'm gonna
you feel project that do do certain
decisions that make sense at the time
but then you regret that later on in the
project because the requirements change
and that's not a difference here right
but what we can do is to make it easier
we can we can think about how to avoid
spaghetti code like I wrote code last
weekend that I think is bad now so we
learn from our mistakes all the time and
one way that we can you know approach
this is by trying to just think about
how do I make this more testable like if
I'm gonna go back in two weeks or two
years how do we make sure that this code
is still solid you know one of the dream
scenarios is to be cold up bought by
your old workmates to say like you know
your code is still in production there's
no problems it's been running solid for
five years right that's great
probably a lot of security bugs in there
though so and they should probably
restart the service anyway so we want to
avoid spaghetti code in the way that we
do that is by you know trying to
abstract our solutions have an interface
do the implementation in one place don't
add a lot of platform-specific code in
your shared projects and what we can do
is that we can try and introduce a
little bit of salmon forms so we're
adding one more things to our
you know bowl of spaghetti so that would
probably end up looking something like
this here so we have one way of doing
this is by by smacking in a little bit
of salmon forms a little bit of shared
UI you know one of the views inside the
app that we've looked at it has two
buttons one says don't login and the
other one says login you know the only
difference between iOS Android in that
case would be that the buttons looks a
bit different you know on Android
they're a little bit more square II and
on iOS they're a little bit more nicer
so how about you salmon forms for that
but then you know you still have the
platform specific implementations that
you might want to do per platform but we
can still do that and you know in an
ideal scenario if we can introduce a
marine forms which we can now do using
something called semi forms embedding
we'll end up having something that looks
like this here
so you know ideally what happens is that
only a small part in the apps are so
platform specific that we need to do the
implementation in that layer using nib
files or storyboards for iOS doing
Android XML for Android but you know
only a very small portion of the code
would be that important to be
implemented in you know the native
programming principles most of the times
we are good enough using salmon forums
and now they've introduced something
called salmon forms embedding which lets
us do things like we can use sam'l to
set up our salmon forums page and then
we can just inject that into a native
layer in Android or iOS so that sounds
pretty promising and that also gives us
the capabilities of using everything
that we have available in salmon forums
such as the messaging Center the
dependency services and things like you
know event aggregation and dependent
inversion of control and all that so how
does it work
well it's simple so I have a page here
called main page
I say well start an instance of this
main page and then give me a fragment or
give me a view controller this is pretty
simple and this allows us to do
something like this here we have an
android activity for the login screen so
when I click login it brings us to this
view here and then on this view here we
have a an Android fragment which is in
fact our salmon forms page that's pretty
cool and the same goes for iOS as well
so the UI is different the U is native
but we built the UI using the same code
so again we're sharing more code and you
know I want to I want to show you some
code instead of just talking so what
I'll do is that we'll look at how this
works
so what I've had here is that it's
pretty much the same structure we've
gone from having that baseline that we
had before say map I just want to
introduce something with salmon forums
so I introduced this layer here called
demo to UI which is a portable class
library so it has no reference to
Android no reference to iOS has no idea
about how to build a native app so I
don't have any you know native parts or
anything in that project it's all shared
code that's I think that's the best part
about sermon forums is that it embraces
the idea of sharing more code it allows
me to to use the principles you know
like a dependency injection and
interfaces and all that and apply that
in here to make sure that I don't write
too much platform-specific code so I
have this my page here and it's a simple
page this could have been sam'l but now
I've done the code hearing in my page
here and it's it's gonna show us a
simple button I click it it just
increments an integer and then if we
look at the Android or iOS project we
see here that we have a tab bar on iOS
now what I'm doing here it's a little
bit more code on iOS than Android and a
few different reasons it's because how
this demo is set up so I want to work
out of these same examples that you
would get when you start this project in
Visual Studio for Mac just to make it
easier to follow along so what I'm doing
here is that I'm creating a new
navigation page that has my page on it
and then I'm simply retrieving the view
controller converting that salmon forms
page to a view controller and then I'm
just adding that to the collection or a
few controllers in my tab bar so if we
run this on iOS
let's see what it looks like
it takes a while to start the simulator
so the idea here is that it's going to
show us that we can combine stammering
forums and semi native and I've done
this in a few projects and I think it's
working out pretty well so now we look
like not now here so that was pretty
quick to getting to the app I'll click
about here at the bottom which is in
fact going to show us this summary forms
page so I can click that a lot and it's
just increments that integer so it still
feels like a native application I'm not
a UI designer so it doesn't look very
beautiful but imagine if you have a UX
team working with you and and they can
work with a saml maybe they have some
blend experience and done a lot of WPF
in the in the past they'll just have a
blast building a beautiful app so if we
run the same one on Android you'll
notice a little bit difference in the
speed so I've done some reforms
embedding even since before they
announced it was a thing because it's
been working out pretty well on both iOS
and Android despite one thing so now I
click not now when you see here that
there's a little bit of delay so some
initialising salmon forms on Android
takes a lot longer than it does in
iowa's look about here and this looks
like an Android app right so the idea
here is that we have the UI it's shared
it's somewhere else that's really good
and it's really easy for us to add this
to our project so if we just look at
what this looks like on it on Android
and the code we'll see that we have this
main activity the activity itself allows
us to you know get that fragment when
you swap between those different tabs
super simple
pretty much the same code across iOS and
Android right so this here also allows
us now to do things like using the
messaging Center doing things like
dependency services and using all those
tools like prism I don't know if
anyone's using prism in the past it's a
really great tool to allow us to do
things like mvvm which is pretty much
the final things we're gonna talk about
so we can do things like using the
dependency service so that's a little
bit different way for us to register
things for the ioc container so we have
this thing called the dependency service
it comes with sermon forms and what we
can do is that we can say we can use
this assembly directive at the top here
to say well this here contains to
implementation for my councillors and
then anywhere inside sermon forums we
can say well give me the implementation
of the IARC answers and that is go out
and find that inside our project and
even if we're working with a little bit
of Native and we're working with you
know salmon forums it'll all just work
together so we can use all these
technologies and and use them together
which is really good so now you're
probably thinking well you know if I
have this login screen here I click the
login button and we talked earlier about
well you have this setting dot it's
logged in and you want to transition to
summer how do you notice notify the OS
or the app that you want to go somewhere
else well several forms comes with
something called the messaging Center
which allows us to communicate between
both sermon forms pages and view models
and so forth as well as talking back to
our native layers so this is where it
becomes really powerful and this is
where I see the US is succeeding more
when we share code so we can apply the
the common principles of just just do
abstractions and interfaces and P sales
and break everything up into smaller
pieces but when it comes to actually
implementing this in the native layers
and adding salmon forums this is for I
think it becomes to make more sense so
an example of doing the messaging Center
is to say well I want to subscribe to
this here in my native layer so we can
say well when the logging completes I
want to go to this intent here so
imagine we have the setting that it's
logged in that could have erased this
event then we can subscribe to that
summer in the Android app and then then
from within samory forms we can say well
distribute this using event aggregation
just send it out to everyone that's
listening that you're now logged in
it's really awesome so let's look at
some more code code speaks more than
slides so so this allows us to if we go
in and have a look at this here you'll
see here that I've introduced something
called a login view the login view is
supposed to just show us like a username
and then click login and then you can
come into the app and I'm using a little
bit of mvvm here I'm doing data binding
so I'm saying well this is gonna be
bound to a property that I have in my
view model this here's gonna be bound to
command so this is now we're starting to
separate we have a view view over here
than a view model now we have the
activity it's all getting more decoupled
excuse me so if we look at the view
model we can see here that of course
it's a little bit of more code in here
but it's not too bad one thing that
you've noticed is that we were asking
for our account service what's really
interesting here is that the account
service the interface lives in let's say
it lives in a PC a lord lives inside our
sermon forms project now our Sam reforms
project has no idea about Android or iOS
so what's pretty cool here is that I've
registered the account service inside
the actual native projects so I've said
that well I have this account service so
whenever it's it sees that well you're
asking for an I account service this
thing here just lets it know that this
is where you find an account service
it's pretty simple and it's pretty good
because now I can use this inside salmon
forums which has no idea about my Navy
projects I can work in a much more
decoupled manner and of course you could
write this even better to make it even
more testable and then what happens is
that I'm using the messaging Center to
send out this login completely to
command and you'll see here that I'm
actually using a local version because
there's been a bug lately in the the one
that they've distributed on you get so I
just pulled in an o1 something you get
so it doesn't get hub so that's all fine
now to initialize this on Android you
will see that it requires a little bit
more not more code but it requires us to
do a few things so I've got a fragment
activity that allows me to display a
fragment which is how it works on
Android I'm starting off by initializing
salmon forums and then I'm saying well I
want you to subscribe for a certain
event the event happens on a log in view
model when the login completes when the
login completes we get the v-model and
then we're gonna do this okay and then I
set up the login view I give it a
binding context which lets me set up all
the VMP mvvm goodness and then i
transition to that fragment so let's
just look at what this looks like when
we run the code you'll see that so small
changes to the code and introducing just
these common practices that we've seen
in Silverlight or WPF it just makes it a
little bit more fun to work with salmon
apps and it makes it easier for us to
write more testable and maintainable
code so one of the problems that I've
struggled with is that I tend to have
projects where we have nib files and
storyboards and Android XML and then you
have view controllers and someone's
build you white code inside the view
controllers and inside the activities
it's sometimes just a big mess so being
able to just break out of that and just
ignore it go to a new fresh salmon
forums PCL and just build a little bit
of the UI there instead and introducing
small pieces like the messaging center
and the dependency service it just you
know makes it a little bit easier to
work with even legacy code bases even if
I would love to use this in a Greenfield
project most of the times we don't work
in new projects all the time so I click
sign-in here it takes a little bit of
time to start up salmon forums it's
quicker on iOS I'll simply write Phillip
here and what I'll do is that I'll set a
breakpoint in here just to show you that
it works so this is inside my my Android
fragment this here is inside salmon
forms I'll click login here we'll see
that I got into this play
here and if I hover this here you'll see
that it in fact says that I'll just show
you like this you'll see that it says
Phillip here so it passed in the
username that I entered into that text
field so I've used mvvm I've done
bindings it raises a command it
distributes that using the messaging
Center and it's storing that as well
inside the I account service which it
knew about using dependency services so
I'm introducing all these different
tools to help me build these better apps
but there's still a few things that we
could make better right I want to avoid
doing this thing here at the bottom so
we can introduce tools to help us solve
that as well
and just to show you that this looks the
same on Iowa's iOS the code for iOS is
the it should be identical so we'll have
a look at the login view controller it's
doing pretty much the same thing it's
listening for that event and then it's
navigating to that correct view so let's
run this and have a look
click login all right Philip login and
it just brings me into the app which
means that it works and if I could about
there at the bottom it's using the same
account service inside this view here
which is also using salmon forms so
what's interesting here is that this
about page is using you know we talked
about earlier that it used in my page
that I added the first in the first demo
if we just look at that code now inside
this salmon forms project where there's
my page we can see here that this is
also using the account service and it's
bringing out that name as well so we've
got that passed through the native
layers and we use tools to help us make
the code a bit more decoupled now if you
start using the messaging Center in just
racing events everywhere like your
coworkers are gonna hate you because
it's really hard to debug sometimes it's
like doing the old events in in wind
forums right so we don't want to do too
much of that so pretty much the final
thing that I just want to talk a little
bit more about is you know mvvm mvvm
allows us to break up the app in a
little bit more structured manner so
we've got a view that represents what
something looks like now we can use mvvm
even if we do native programming like on
Android and iOS the view would be you
know the Android XML or the storyboard
and then we have the view model which is
the shared view logic which often uses
data from a model which comes from a
data store now there's no one framework
to rule them all I like to use prism but
there are other ones as well we've got
mvvm light you got fresh mvvm mvvm cross
and there's a bunch of them out there to
help us build these apps in a better
manner right so the goal of one of these
frameworks is to allow us to do things
like navigation like what happens if I
click this button I want to navigate
Summer navigation is different on the
different platforms but I don't really
want to implement that myself so we can
use an MDM framework to solve that for
us we can use an event aggregator which
is the same thing as a messaging Center
to distribute messages between certain
view models and between you know
activities and view controls and so
forth and then of course dependency
injection
so let's look at how we can do this with
prism so I'm really liking doing
dependency injection and being able to
write more testable code and I rather
want to inject a lot of interfaces
rather than having a service locator
inside the method asking for that
particular interface so the final demo
we have here is it's interesting because
it's using prism and you'll see here
that the view model is a little bit
different so it's actually now
inheriting from something called a
bindable base and I'm injecting
something called the I account service
into this here right so you'd imagine
that well you probably just create an
instance of this in the android project
but if we look at the code of how we set
up this in the Android or iris project
we'll see that that's actually not
what's happening so we'll check the same
thing as we did before so I'm calling
load application I'm setting up a new
salmon forms application I've replaced
salmon forms that init with this thing
in here instead and then what I'm doing
is that I'm simply creating a new view
here and create the fragments I don't
set the binding context or anything so
where does that come from well you know
it's magic if we have a look at the app
dot - sam'l dot C s this is the prism
application it's like a salmon forms
application but a little bit of goodies
added to it
so what it's actually doing here it's
it's using artifact internally and the
first thing that I'm doing is that I'm
registering an instance of my account
service which I'm getting out of the
dependency service so I'm combining
these two services really just to grab
that out from the native layers and then
I'm registering a navigation page in a
log in view and when I register the log
in view here it'll just do a lot of
magic to know where to find the view
controller what things to inject it
knows that it's gonna inject this
account service automatically so that's
really powerful so what's happening now
is that it knows that it's going to
create this account service and pass
that into this login view model alright
and then I'm using the messaging Center
to send
back again but how does it know that
it's using this particular review model
well if we take a look at the view that
I've created one of the things that I'm
doing in here is to sell it - I want you
to automatically wire this up with the
view model so I've got a log in view
when it finds his view here it's gonna
say well I'm gonna find a log in view
model to bind to this here and it'll
automatically set up the username and
login command so even more I've reduced
the amount of code that I have to write
in general I don't have to set up the
view model myself anymore so if we just
run this we can see what it looks like
and I want to show you that it actually
works so we can go into two places I
want to show you the the view model that
we get this passed here and then inside
the Android project
we'll put a breakpoint inside this
messaging Center subscribe here I'll run
that
soon our some of the successful coach
sharing principals is just going back to
the basics doing things like inversion
of control and dependency injection and
using the correct tools to help us solve
those problems so what I'll do here is
I'll click sign-in I'll write to Phillip
to login here we see that we're now
inside the login view model just get rid
of this here we considered that we have
an account service there's actually an
instance of that we can hover over the
user name and see that it's bound that
as well so there's no magic it's just
really there is a bit of magic but we
don't see it so I'm not doing anything
manually to set that up and now I'm
gonna release this breakpoint and going
to the native layer so now we're inside
the Android project then I can hover
over the object here and we can see that
we have our login view money so it's
passing in Phillip here inside the user
name and we can use that inside Android
as well so what we're doing now is that
we're taking our native Android project
and introducing a little bit of salmon
forums using salmon forums and Betty
right
so you no longer really have to choose
do I want to do salmon forums or do you
have to do semi native well you can
combine the both in in the best way
possible so I've tried to do this in a
few projects and it's been really
successful a lot of people that use the
apps don't see any difference except on
Android there's a little bit of delay
sometimes so I'm avoided doing it in
really mission-critical parts of the
apps but once they fix those
performances issues like you won't even
notice a difference and I think it's
really powerful because you know now we
can write more testable code and we can
make sure that we adhere to those
principles that we've all learnt about
all right so you know the end goal is to
write more testable maintainable and you
know more fun to work with apps I don't
know about you but I personally like to
write applications that I think are more
fun I want to focus on building features
rather than working more with spaghetti
code and solving the the past weeks
coding issues right so we want to make
sure that we feel a little bit more
happy about our solutions it's funny
because when I choose this picture
didn't even notice that there's a Mac
but you
required to still use a Mac from you
doing iOS development with salmon so we
want a few more like this we want to be
more happy when we're building salmon
and I think that when I build salmon
apps and when I'm trying to adhere to
these principles I'm introducing things
like a little bit of salmon forums where
it makes sense doing a little bit of
good code sharing practices just makes
it a bit more fun and like I don't want
to be afraid of doing platform-specific
code so imagine if I do the NFC parts
for Android but not for iOS like it
still makes sense to do most of the
shared things in a shared layer like
abstract it out to interfaces like you
might have something like read this
thing from NFC in the contract what you
read from the NFC tag might still be
shared across iOS an Android so don't
just build that into your android
project but take the extra time and
bring that into a PCL or share layer
just to make sure that when it is
available on iOS it will be easier for
you to transition and add that into your
iOS project as well so hopefully we'll
end up with a structure that looks a
little bit more like this here it's okay
to have a little bit larger Irish
project if that's what we want and maybe
a little bit larger Windows project and
people sometimes forget to do a little
bit nicer things on Android and then
it's nice to have a shared UI layer as
well even if it's just a few models like
you don't have to share the views but at
least try and share a little bit of view
logic like what happens when we click
the login button that should be shared
across the platforms so just to wrap
this up I hope you've learned something
about what you can do with salmon forms
embedding and what you can do with
better code principles and use person
and that you can combine these different
principles to write applications that
are a little bit more testable a little
bit more fun to work with and ultimately
like we want to go back to the basics
and introduce things like dependency
injection and inversion of control to
make it easier and more fun to work with
our apps I want to thank you all for
coming and listening to me I'm really
sorry about my voice and I was trying my
best to keep it up if you want a copy of
my book please do ping me on Twitter or
send me an email and I'll be sticking
around here for a while for questions
thank you so much and have a great
Friday night
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>