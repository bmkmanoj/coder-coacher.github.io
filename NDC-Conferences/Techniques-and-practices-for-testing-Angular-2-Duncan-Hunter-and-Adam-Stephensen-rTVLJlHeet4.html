<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Techniques and practices for testing Angular 2 - Duncan Hunter and Adam Stephensen | Coder Coacher - Coaching Coders</title><meta content="Techniques and practices for testing Angular 2 - Duncan Hunter and Adam Stephensen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Techniques and practices for testing Angular 2 - Duncan Hunter and Adam Stephensen</b></h2><h5 class="post__date">2017-04-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rTVLJlHeet4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi and welcome to techniques and
practices
testing angular2 i'm adam stephenson i'm
a solution architect and the general
manager of SSW in queensland out in
australia i'm my primary responsibility
is i'm in charge of making sure that we
shipped large enterprise web
applications and I'm also a mentor at
five boot camp which is where we do a
whole lot of angular2 training through
SSW my name is Duncan I work with Adam
in Brisbane Australia I'm a Software
Architect at SSW and I've been really
lucky just to do pretty much only
angular for the last couple of years
angular 1 &amp;amp; 2 all in typescript been
involved in about a dozen projects and
we get we've been lucky enough to train
and do lots of code reviews over the
last probably year and a half while
angular's being kind of moving through
alpha and beta into being released in
angular 2 and now we're finding a lot of
people because it's angular 2 is
released or actually at the point where
they're writing their applications and
they're cut and the first thing they do
when they actually kind of start is
going to test this so we've found a lot
of people have been very interested in
talking about testing with angular 2 now
that everyone's actually kind of getting
into production with it so hopefully we
can share some of the tips and tricks
along the way we've learned in a lot of
that teaching awesome
so also you'll hear us saying Euler to a
whole bunch but we probably shouldn't
because angular has decided to drop the
version numbering from their name
they're not going to be angularjs
they're not going to be angular 2
they're just going to be angular and
they're gonna pick up semantic
versioning so they're gonna be truck
they're going to be iterating much more
quickly so there'll be a lot less
relevant hopefully we'll get a lot less
breaking changes and it'll be a bit more
evergreen so we'll say angular 2 a whole
bunch just because we're transitioning
that moving forward in the whole world
hopefully it's is going to be angular so
so who has tested angular 1 who's
written angular 1 tests only a couple of
people so who's written angular 2 tests
so far awesome where you guys are in the
right room just for the record that was
at any hands went up just then there was
two on angular 1 but any Frank Euler -
okay cool great we're in the right spot
definitely so just before we start a bit
of history so it was 1979 when
testing the first time the testing was
actually differentiated as a different
practice from debugging so we've been
doing this a while now
in 1996 Kent Beck released XP or wrote
about extreme programming which had a
real focus on testing and in 19 1988 he
released s unit which was the first of
the xunit frameworks which a lot of the
current frameworks are still based upon
in 2001 pivotal labs did a javascript
port of s unit for jeaious unit and keep
an eye out on pivotal labs in 2003 TDD
test-driven development started gaining
a lot of popularity in 2006 den North
wrote about a new way of writing tests
so it was an evolution of TDD with more
human readable tests for behavior driven
development and Dan's actually at the
conference if you see him make sure you
buy him and be up and then in 2006 we
got selenium for running our end-to-end
tests in 2010 we got Jasmine which was
by pivotal labs again and that was the
updated version of Java jeaious unit in
2010 angular 1 came out and this was
really cool I was really excited about
this for the first time file new project
was test-driven so angular 1 from the
very first version had a real focus on
testing between 2011 karma came out from
the Google team and I actually much
preferred its original name which was
testacular which is pretty cool
in 2013 we got protractor 4 which is how
we now run our end-to-end tests and it's
using selenium under the covers and 2016
we got angular 2 now what's really
interesting about this history is that
you know we're still doing TDD we're
still Jasmin actually uses BDD we're
still using so protractor weezing
protractor and it uses selenium under
the covers we're gonna be writing
jasmine so a lot of the practices we're
following in the tools were using in
2016 they're not new they've actually
been around for a really long time so
why are people writing tests
well tests aren't necessarily easy to
write it's not always easy to write code
and one of the things we're really going
to
come around and one of the focuses that
we want to focus on today is showing
you're the cool new utilities that the
angular team have put into angular 2
that are going to make testing easier
and hopefully that will enable more
people to write tests so our agenda for
today we're gonna have a look at the
tools that you use to write unit tests
we're gonna have a look at Jasmin we're
gonna talk about then the three biggest
challenging areas around testing which
is faking dependencies and about the
testbed API which is a new API that the
team's included an angular 2 which is
really going to help you with your tests
and the real challenges around you know
programming and how do you test
asynchronous code and then we're gonna
have a look at some into n tests
cool so we're gonna jump in and have a
look at some of the tools that are most
popular for angular 2 and I think it's
good to reiterate what Adam said that
you know testings not an afterthought
for angular 2 it's kind of it was one of
the most notable things about angular 1
is when it first came out it was all
about being testable and if you go look
at the docs for angular 2 at angular dot
IO for testing you try and print them
out it's about 99 pages long it's just
one long document on the web so there's
a lot to it and it's it's there's a lot
of great new things so we'll show you
some of those today so when we're
talking about what we're going to test
today we're going to be doing some unit
tests and we're gonna do some end-to-end
tests of course the enter the unit tests
are just testing specific functionality
or specific functions and the end-to-end
tests is actually you know running up a
browser and you know running tests
against that browser and looking at way
an actual user would work with that
browser or the application running in
the browser so these are kind of the
default tools that everyone's using for
angular to ever know you've got options
so for your unit tests you'd be using
karma as your test Runner you'd get
jasmine as your testing framework and
for your syntax and then I've got
angular here because angular is actually
part of the deal there's a whole bunch
of testing utilities that you use when
you're testing angular to when you're
running your end-to-end tests
protractors the default for kind of an
angular wrapper over the selenium
webdriver and you'll also use Jasmine in
that case so you can use mocker and
sign-on if you're used to using those
but most people are using this
combination of things and it's what a
lot of the default tooling that comes
out of the box is using so what's
Jasmine looked like well Jasmine gives
us this BDD style kind of syntax this is
an individual test it's an it block you
could also call it a spec and it takes a
string it's got this video d english
kind of written sentence in it so should
add one plus one and then it takes an
anonymous function and then you do your
testing inside that block there and then
here we're using one of the Jasmine
matches which is dot two equal but
there's lots of match matches in Jasmine
so we could have an individual test like
this you would always wrap them in a
describe block so you'll have multiple
tests inside of this described block and
there's a lot of flexibility in the way
of using Jasmine you could have nested
describe blocks in each of those nested
describe blocks have more eight blocks
in them so you got more individual tests
and it can go on and on as much as
dynamically as you want to do it so you
could have this nested structure of
describes in its statements but this is
kind of the general flow that you'll see
commas the test runner runs in whatever
browser you want to choose out of the
main browsers and you can run it on your
build server and when you run it you get
an output in the terminal similar to
this this all these tests are passing in
this scenario but just to point out the
fact that commas your test Runner
protractor looks really similar in the
terminal when it gives you the output
but of course it's fundamentally
completely different because it's
actually running your whole application
in the browns they're not just part of
your application like you would in a
unit test so we can see here again
you'll get this output of tests and
we're going to be doing a few small code
demos over the day so you'll see both
protractor and karma working now there's
another tool that I really love family
we've only got now up Duncans a massive
fit Duncan's actually a massive fan of
wallaby he's actually got the first
wallaby stick in the world yep
Luke he actually sent this to me so he
actually gave me a whole bunch I'll go
to my bag so if you want to comp it in
you can get a wall of your sneaker or a
magnet so what is wallaby who's heard of
wallaby jeaious okay a couple of people
so well a bj is just another test runner
but it's designed to be running tests in
your IDE so what you get is real-time
feedback so imagine you had those
similar tests that I had up before
on the left here you can see that the
first test is passing and the second
test is failing and you get this red dot
on it and you also get this great what
you would normally get in the terminal
saying what your error is in karma in
line there so there's a there's a lot
more benefits to this you can do code
coverage and other stuff but it's great
because it gives you you know this fast
feedback so where you'll see us use both
of these today it does cost about a
hundred bucks us so you got to take that
into account but if you're writing lots
of tests then it can be very useful I
actually ran had to run a little while
for a couple of days without it and I
actually noticed how much of a how much
of a Productivity drop I had having to
constantly jump back out of the terminal
yeah so angular CLI
is not a testing tool but the angular
CLI is something that from the community
and the Google team that allow you to be
able to spin up a new application really
quick and when you new up an application
an angular 2 application it comes with
all the testing out-of-the-box so I
mention it here just because we're using
it today and it's an awesome way to
learn testing and start even a proper
application with the angular CLI it
comes with all your end-to-end test and
unit tests ready to go so you just go
farm your project and then start writing
tests so if you want to learn to write
tests it's a great way to do it
so in summary out of the tools you want
to use the angular CLI if you want to
get up and running really quickly karma
protractor and Jasmine or the default
but there are options but almost
everybody at this stage in the early
stages of testing angular 2 in the
community and all the information that's
out there everyone's using these ones
and you should check out wallaby jeaious
it's a pretty handy tool so we're going
to jump on to talking about Jasmine
because what we're going to write today
and all that the it's kind of the
testing framework of choice and I call
it a framework even though we talk about
syntax because there's a lot more to it
than just the syntax so we're going to
be testing some Chuck Norris jokes today
and the reason we've got this very
simple little application that basically
allows you to click the button and get
another Chuck Norris joke is because it
kind of represents the common things you
need to do you'll have a service you
serve angular service will course in a
few people chuckling we'll call the call
HTTP requests to get the next joke and
then you've got to communicate between
your angular service and your component
you can pone
has to bind that data and then you've
got some Dom events that you want to
listen to and detect changes in your
tests so kind of it's a nice simple
easily understand application to think
about all those common pieces that
you'll want to test so let's jump into
Visual Studio code and we're going to
have a look at writing some very simple
tests so if we come over and have a look
in the directory over here we've got an
angular CLI application and it's just
very default version of it and we've
gone and written a joke feature that you
saw on the page there and we have this
joke component spec file so obviously
all of the unit tests if you're going to
go down the road of using the inbuilt
tools anything with a dot spec inside of
this app folder is going to get run as a
test by karma the test Runner so I'm
just going to come in here and I can do
a describe block in Jasmine and I'm
going to be describing a certain
component here and that component is
going to be our joke component and then
inside of here I can do a Jasmine
Jasmine it and here I can say something
very simple like should add one plus one
so in this case I just need to do an
expectation with jasmine and say one
plus one is going to equal 3 and of
course this is going to fail because we
know that's not correct but you start to
get a look at what the syntax is like
I'm going to open up a terminal here and
I'm just going to clear it out and I've
already got the application running in
another terminal but I'm just going to
run ng test here so ng is the way you
get a hold of the angular CLI and then
you can ask it to run your test so I'm
going to ask it to run the tests it's
going to kick off Karma all of this
comes out of the box in a you know once
you've installed that it's very quick to
do so it's going to run that and it's
going to say that it fails because we we
know one plus one equals two not three
so I could just obviously change that
back comas watching that file that was
saved and then I'll rerun the test and
now we can see that the test is passing
down here and we have a successful test
but I'm going to turn this off and I'm
just going to run wallaby instead
which will do a similar thing but it's
going to give us the output of our tests
in line here so why love you'll kick off
it will show us you can see it's just
starting up down here in the bottom
right and as it starts up all then show
us the green dots so it's just another
way of doing the test runner so I could
say it's three and then it's going to
fail and it's going to show us the
output so it's quite a nice testing
experience to do it like that
so enough talking about jasmine in that
sense let's move on and talk about how
would we actually do a really simple
test to test angular so in that case I
could make another eight block or
another test and I'm going to say it
should have a title of title here on our
application which is Chuck Norris jokes
so I'm going to jump back over and say
that it should have a title of this so
I'm just going to new up a component
here so I'm just going to say Const
component equals a new joke component
now this is the start of our challenges
with if you're jumping into testing
angular 2 is a joke component if I look
at it here it's giving me is telling me
if I want to new it up I'm going to need
a joke service I'm going to have I've
got a dependency on this joke service
and we're going to come back and talk
about faking dependencies but for now
I'm just going to pass in null here
because I'm not actually going to test
anything with the joke service and I now
have the component that I can test so I
can do an expectation and say that my
component title and this is kind of cool
if you're used to testing with
JavaScript your pup might not
necessarily be used to testing with
typescript so because we're testing with
typescript together all the same
intellisense and code completion and so
forth so I can just go yep I want to
look at the components title it's
already telling me in line there that
had expected the the string that we have
and then now the test is passing so this
is just a very like quick look at how
you can do a test and we're going to
jump deeper into how you would do some
other tests in a second so we had a
quick look at adding one plus one and
then we had second test and we looked at
doing it up so in summary with jasmine
it is the default kind of testing
framework tool for the angular community
or the
there's other ones you could use and
it's a lot more than syntax we're just
using the syntax there but there's a lot
of testing helpers and you'll see Adam
show you a couple of those now cool
thanks Duncan so what I'm going to talk
about is faking dependencies and faking
and the set up of dependencies is still
one of the hardest parts of testing
doesn't matter what language you've been
using when you're trying to test a
particular piece of code and that code
has a whole lot of dependent is
dependent on other modules it's very
hard to isolate to just test that coat
that dumb that this particular structure
under test so this is what Duncan showed
so we've got this situation where we've
got our component that component has a
dependency on a service so at the moment
we're just passing null what we want to
be able to do is our joke component
depends on HTTP service that's actually
going out to the web to you know a
really useful API that returns Chuck
Norris jokes when we write our unit
tests we don't want those tests to be
going and calling that service so what
we can do is we can go and create a fake
so we can create a fake object here we
can assign some behavior and say return
a particular string and then we can pass
that fake into a joke component that's
one way of managing dependencies now
Jasmine gives us some helpers so an
alternative method is that we can
actually create Jasmine spies so you can
see here I'm using the Jasmine create
spy object method I pass in the name of
the object that I want to make and I
pass in an array that has the functions
on that object and it's actually then
going to return me a fake what I can
then do is go and say on the joke
servers get joke method I can then
specify the behavior that I expect and
then I can pass that into the class that
I want to test so there are two
different ways of of managing the
dependencies in our application so one
of the bits so the benefits of spies is
that spies let you intercept any
function call and they also let you
override the behavior of the function
one of the other benefits of spies is
that they let us check what's actually
happening on those dependencies so I'm
able to verify that the get joke method
has actually been called I'm also able
to verify how many times it was called
and I can also verify what parameters
were passed to that particular method
let's go and have a look at what that
might look like in code
so what I'm going to do is I'm going to
come down here and I'm going to create a
new test okay and what am I going to do
for my test what I'm going to say is I'm
gonna say that my test should set the
joke
property on the component now let's have
a little bit of a look at what I mean by
that I'm gonna jump into my component
and have a look and now in here you can
see when the components initialized it
calls the get joke method they get joke
method goes off to my API and then when
it returns a value it assigns it to the
joke property on this class okay
so what I'm gonna do is I could new up
the component here and then go and call
the ng on init method and then go and
check that the property is correct but
before I do that rather than declaring a
new component inside every test I'm
gonna jump up to the top of my my my
describe LOC and I'm gonna use the
before each Jasmine function and I'm
gonna say before each test what I want
to do is I want to execute the following
what I want to do is I want to come in
here and I want to say I'm going to come
up and I'm going to declare my component
up the top and I'm going to say that
that is a joke component and then in my
before each now I can set the component
component equal to a new joke component
know okay so I've just done a little bit
of refactoring so that I don't have to
creating your component in every test
cool so now for my test what I want to
do is I want to come down here and I
want to say on my component I want to
call that mg on init method that's the
one that goes out calls the service and
then assigns it to the property once
I've done that
what I'm going to do is do an
expectation and I'm gonna expect that
the components joke property is equal to
something that I know okay
now this isn't going to work because we
don't have a service ng on inner is
going to call the service that was
passed into the component when it was
instantiated but we're not passing in a
component yet so let's see what it looks
like if I come along and what I'm going
to do is I'm going to come up and I'm
going to create a fake joke service and
what I'm going to do is I'm going to say
in my the for each I'm in a crap I'm
gonna set my fake joke service to be
equal to an object and on that object
I'm gonna add my get joke method and I'm
gonna say that it returns an observable
of fake joke now for that to work I'm
gonna have to come up here and import
the rxjs kitchen sink so I can get the
extraneous X that just lets me get the
of the of function okay so you can see
what I've done there is now in mind
before each I'm creating this fake
object I'm putting a get joke method on
it that get joke method is going to
return an observable of fake joke I can
now pass that fake joke service into my
joke component when we scroll down here
we can see that what I'm calling my own
in it on the component and it now knows
hey that joke property should it already
is telling me that it should be equal to
fake joke and that's exactly what I
would expect cool and now as soon as I
finish that my test is gonna pass so
that's doing it using and using a fake
what I can do is I can I'm also going to
show you how to do it using a Jasmine
spy so using a Jasmine spy I'd come up
here and I'd go
fake joke service equals and I'm going
to go Jasmine doc creates create spy
object then I'm gonna supply the name
I'm a fake joke service and then when
you create a spy object you pass in an
array that contains the methods on that
object get joke okay so now I've gone
and I've created the fake joke object
and now what I need to do is just go and
assign some behavior to that get joke
method so I'm gonna go a fake joke
service get joke and I'm gonna say and
what value is an observable fake joke
and if I haven't missed anything I don't
think I have my test should still be
passing okay
so that's very quickly showing you the
two different ways of doing that of
creating a fake away so what we just had
a look at is we've had a look at how to
create a fake joke service and pass that
in and to be able to override a
dependency and then how to create a fake
using a Jasmine spy and the Jasmine spy
then lets us override the the the
functionality of the method and we could
also go and check to see when you know
the behavior of those methods so the
benefit of faking is that it's isolated
you're actually creating a whole
separate object for your service or for
your dependency and you're passing that
into the component under test okay the
downside is you often end up with lots
of duplicated code and you can end up in
the situation where when you go and
change the real implementation of the
service and you don't update the fake
implementation you might have tests that
are passing when they really shouldn't
be the benefits of spying is that spon
spying has additional functionality so
you can go in assert you know didn't
find out information
about how that dependency is behaving
and you end up with cleaner code so in
summary you need to know how to use both
fakes and spice and faking in the setup
of dependencies is still probably the
hardest part of testing but we've we've
got the testbed to help you out yep so
we're going to move on to talking about
the testbed which is the biggest newest
and shiniest part of the angular 2
testing and Before we jump in talking
about that we want to talk about why
would we want to use the testbed and
that's because we want to do a certain
type of test now in the angular
community people are talking about three
different types of tests at the moment
the first type is talking about isolated
tests so an isolated test is when you
just consider you're just looking at
testing the components class so in our
case that's all we've been doing so far
as newing up the component we have no
HTML template yet that we're interacting
with and that's where a shallow test
comes in when you do a shallow test
you're actually going to be looking at
the component HTML template querying it
running detect changes on it to see as
you run your tests did things change and
update and actually query the Dom and
select some of the elements on it and
normally when you do a shallow test
you're only really talking about looking
at one component the last one is an
integrated test where you would actually
not just test the little pieces that you
need to test for a unit test but
actually passing the entire app into
kind of setup for your tests and then
testing against that we're going to look
mostly at shallow tests and isolated
tests today so let's jump into talking
about this testbed and how we can use it
to do a shallow test so the test beds
got this configure testing module method
on it and what it allows you to do is to
make an angular module so in angular 2
right at the end of their journey when
they went to our TM they came out with
their own idea of modules and they've
got angular modules and basically just
specifies a section of code or a section
for this section of code these here
dependencies so this is great for a test
because you can say ok I'm going to run
this test I only have these dependencies
for this little section of code so it's
going to become a default way of writing
tests so you go test bed configure
testing module and you'll have a set of
things that you set up so imports
all of your other libraries that you
import like the HTTP module our test has
a dependency on that for the service to
be able to make HTTP requests
declarations are your components or or
your directive so we've got a joke
component and that's all we're testing
so when this test beds made it's just
going to give us these things not all
the other components in the app and your
providers your services so we only have
one it's just the joke service this is a
pretty simple example but this is what
our testbed wound up looking like so
this testbed does lots of things for us
but what we want to get from it is the
ability to grab the Dom so once we have
this testbed we can use it or once we've
set it up and the big thing we want to
do is get a fixture and this is that the
specific terminology so you want to get
a fixture and the fixture gives you the
ability to get an instance of this
component so you'd go testbed create
component and pass it the joke component
and then you've got a fixture on it
then we can start to access the HTML so
we can also get the component and all of
its methods and properties on it but
then we can get this debugger element
and this debug elements while we're
going to all this extent here because
then we can use that to be able to do
some queries against the Dom but also
there's a whole lot on this test bed
it's a really big API so we can detect
changes we can actually get it to do
some dependency injection but for now
we're just focused on getting this
fixture so we can get a hold of the Dom
so this is what it would look like if
you wanted to do that so we could say we
want to make a joke text property and we
want to set it to the result of what we
get from this P tag so it's a debug
element query would query by CSS and
we'll get a hold of the P tag which if
we remembered that's there's only one on
our page it's a joke so whatever the
joke comes back as but we can also go
dot native element on the back and
that's really important if we were to
add that on the back because now we can
query this joke text as if we would a
normal Dom API so all of the doc click
and so forth that you used to doing with
the Dom API you can do so test that's
really good it allows us to create this
testing module and then we can query the
HTML templates or under tech changes and
a lot more so let's jump into having a
look at a code demo of what this looks
like if we were to refactor the code
that we have here
so I'm going to come in and I'm gonna
delete all of Adams hard work he does
that a lot and that's going to break a
few different things here and I'm going
to just make us a testbed so it'll be
testbed dot create component no that's
not what we wanted we want to configure
a testing module so it's very similar to
testing angular or creating an angular
module itself which is kind of what
exactly what this is so we're going to
have some imports and the imports are
going to be the HTTP module and then
we're going to have some declarations
which is the components themselves and
we just want the joke component here and
the it's interesting here to point out
we're actually passing in the real
service now so I'm gonna list that in
the providers array where I'd list all
the services that this testing module
would need and I'm going to pass in the
joke service so I'm actually going to
pass in the real joke service and we're
gonna spy on that so this is kind of a
different approach or reduce the amount
of code you're writing normally it takes
a little longer to do what mock out the
HTTP part of it so that we don't
accidentally slip through and call the
real service but in this case we're
going to keep it simple so now that I
have this testbed module I'm going to
need to set up a few different things up
at the top here some properties to
initialize so we're gonna have a joke
service and most importantly we're going
to get a hold of a fixture and this
fixture is going to be of type component
fixture and it will be of type joke
component so once we have this fixture
we can also get ahold of the debug
elements I'm going to do one more for
that which will be debug element and
it's going to be of type debug element
so we need to go and initialize these
now but we can do that with the testbed
so I'm going to come down into our
before each and with with that setup
done then we could say okay so this
fixture is going to be testbed dot
create component and then we pass it the
joke component
so it might look like a lot of kind of a
lot of code here to be writing just to
get to this point but I guess this is
kind of still the state of affairs for
testing front-end application you know
the challenge is all the setup at the
start of your test and once you've done
this once it gets very easy to do it
again and again I actually find it a bit
easier to configure than the previous
way we would have done it using the
testbed so once we have the fixture then
we can also get a hold of the creator
component so then we would get that from
the fixture and we would say component
instance and then we can get this debug
element so the debug element is going to
be fixture debug element and that's the
big thing that we want to get but the
one last thing I can do is we can see
another aspect of the testbed is being
able to get some help to manage our
dependencies like this service so I can
actually use it to do some dependency
injection so I'm going to take this joke
service I'm going to say that it equals
the testbed and I can just say get this
is a very short way of doing this I like
kind of the simplicity of it so I can
just say testbed can you go get me a
joke service and it will go and manage
the dependency injection and set it to
this joke service here so with this all
done we've now got our test bed and a
fixture but I've kind of broken some of
those steve-o's work down here because
we're no longer we're no longer spying
on anything so we're not saying what
we're returning back so I'm just going
to very quickly come into the tests that
Adam wrote here and at the top I'm going
to show you another way of creating a
spy because we already actually have the
joke service and that would be to say
spy on and I'm going to spy on joke
service that we've set up and in
particular I'm going to spy on the get
joke method and then do the return value
thing that we saw before so that would
be and return value and the return value
will be this observable dot of and fake
joke so with that set up all our tests
should go green again unless I've missed
something and then you start to go okay
so testing is kind of one of those
quirky things and you
to practice it and I know that right now
all I need to actually do is just
restart wallaby you can see I just hit
the keyboard shortcut and it's spinning
away at the bottom here and I just need
it to restart again and pick up the
changes that I've done because we've
kind of changed quite a lot so that's
working for us and we're kind of back to
where we were before except now we have
the ability to get this debug element I
can query the Dom and actually check
that it's setting the joke properly so I
can come underneath here and make
another test and say that it should have
bound a joke to DOM and then in here
what I can do is I can kind of copy this
Spion up from above because I'm going to
spy on that again so I'm going to spy on
the joke service and expect it to return
of fake joke for me but what I'm
actually going to do is run fixture dot
detects changes now so I can actually
trigger change detection by using this
fixture that we have so now that's going
to trigger change detection which we'll
call orange ng on a net which we'll call
our service it'll hit our spy which will
bring us back the fake joke so things
are kind of set up for us here so once I
have that what I went through all this
rigmarole to do is to be able to get
ahold of to set an element here to the
text of the joke so I'm actually going
to call it joke so I'm going to get a
constant okay and that's going to be
accessible through this debug element
we've set up so I can say debug dot
query and then I'm going to query by and
this is a specific symbol from the
angular project CSS so I'm going to need
to bring it in so I'll just use the auto
importer to bring it in there and that
would have added that to the top of the
page for me so once I've got this I can
say okay I want a query by CSS and I
really just want a query for the P tag
and I want to interact with this how I'm
used to interacting with the Dom API so
I'm going to say native element to get
access it in that sense so once I've got
it I can do an expectation against it
so I'm going to say that I expect
my joke text content is going to be
equal to fake joke and this has already
jumped ahead and told me that you know
it doesn't equal an empty string it
equals fake joke so I can come in and
just pop that in there for us so this is
it seems like a lot of boilerplate but
you get very used to it there's a lot of
cutting and pasting that goes on but
there's a lot of very handy things the
testbed allows you to do which we're
going to cover in a second as well so
now we're at this point we're actually
literally querying our HTML template and
using a testbed to only have this
isolated amount of code that's running
versus running the whole angular module
so we had a look then about how we set
up the testbed it looks exactly like an
angular module would and it gave us the
ability to get this querying
functionality so it's a bigger API it
takes time to learn it's kind of the
cornerstone of angular 2 testing now and
it basically makes us an energy module
and runs everything in a zone so if
you're anything like me the first time
you thought about this you're like
what's a zone but zone is basically
something Adams going to talk more about
now so I'm going to pass you over to him
awesome thanks so we're gonna talk about
two functions for helping you test
asynchronous code and because asynchrony
adds complexity to writing JavaScript
unit tests you know you click a button
that calls a HTTP request and you've
gotta wait for that to return before you
can really check on you know what what
is the result so asynchronous code is
often hard to test so what we've done
previously and you're still able to do
was use jasmine done callbacks so with
this you use a promise and then when you
are done you actually call the done
method the downside of jasmine done
callbacks is they require chaining
promises handling errors and then
specifically calling done they're not
recommended with angular 2 but you still
need them for some edge cases what we
prefer to do is use the new async and
fake async helpers and the key to those
are zones now what is a zone who does
anyone want to tell me what
- no it's taped so I'm going to try and
give you the easiest explanation zones
defined an execution context face
synchronous operations so they're very
cool essentially in angular 2 anytime
you do an asynchronous operation it's
happening inside a zone and what happens
is it says there's an asynchronous
operation happening I'm gonna put a
micro task on a queue and when that's
finished I'll remove it from the queue
so angular 2 is always aware of what
asynchronous operations are outstanding
okay which is very very powerful because
now we have these two new keywords and
when you go and you wrap your test
methods in either a sync or fake async
what it does is it says I'm not going to
use the normal zone I'm going to use a
special test zone so now anytime I do
something like call a button click
inside my test because it's in a test
zone I've called an async operation and
it's putting a micro task on the queue
so it knows I can come down and I can do
something like call fixtured when stable
and what that does is it resolves when
that queue gets back down to zero so now
we're able to say tell me when all of
the asynchronous tasks and the tests are
done because then I can go and do things
like the tech changes and then check my
expected result is as I would want it to
be faced it makes managing asynchrony
much easier in your tests fake async
work similarly the benefit of fake async
instead of needing when stable and
returning a promise it gives you a very
linear test so with fake async what
we're doing is we're calling button
click it's going and putting a micro
task on the queue in our testers own and
then you can call the tick method and
the tick method controls time so you can
go ah pretend that all the mock those
are done and then you can call detect
changes trigger change detection and
then go and do your assertions so tick
simulates the passage of time until all
of the pending async requests are done
but it also lets you do like in the
example pass in 3 3,000 milliseconds
simulate 3
thousand milliseconds passing before you
go and detect changes and do your
expectation let's have a look at what
that might look like in a code demo so
what I'm going to do is I'm going to
come in here and Duncan took pleasure in
deleting my code I'm actually more of a
steal his code kind of a guy so for this
test I'm gonna start off and I'm going
to say that what this tests what I'm
gonna do is it should I'm gonna say
should get next quote on button click so
the test I'm gonna write is I'm going to
do exactly what Duncan was doing I'm
gonna say when the page first loads
we're going to call ng on in it and it's
going to set a joke my tests are better
than here so I can test when you click a
button it's actually gonna go and call
the get joke method get another joke and
then set the this and I'm gonna test the
second jokes property yeah but because
I'm handling this button click I want to
be able to manage the asynchrony so what
I'm going to do is wrap this test in the
fake async keyword I'm gonna wrap this
in the fake async method it's gonna jump
down there so I'm gonna wrap that and I
just need to import fake async so I have
access to it say now I'm doing I'm gonna
do all the same code that Duncan was
doing I'm setting up the spy but you
know what instead of returning one value
I Maritain multiple values so the first
time that I call get joke I'm going to
return an observable of fake joke the
second time I'm going to return an
observable of fake joke too and just to
make it a bit more fun I'm gonna wait
for two seconds before I return fake
joke too so the first one will return
immediately the second one is going to
return a different value and is going to
mess with me by waiting two seconds
before I do it so how do I make that
happen well
I'm gonna once again I'm gonna take his
code and copy it what I'm gonna do so
he's doing his first desertion then I'm
gonna go and get a reference to the
button okay so once I've got the button
I can call button click to call the
click event and then what I should be
able to do then is go and check after I
call the click event you know i'm
expecting fake joe to to come back but
my test is failing
why is my test failing because it's
rolling through before the two seconds
is passed and i've gotten my new my new
fake joke so what i can come in here is
I can go tick tell it to wait three
seconds well and I should import it
because that helps
what have I done wrong I got my changes
I didn't call the tech changes so after
I called tick I need to run a cycle of
change detection and now my test passes
pretty cool now a fake ASIC lets me
manage time it does have some
limitations like you can't do s xhr
requests using it so what I'm going to
do is I'm just going to show you what
this exact same test would look like if
I just used async so if I use async if I
use async
I can't specify the time out because it
can't control time to the same extent
but remember went down here instead of
doing tick what I did was is I said
fixtured dot when stable okay and now
once I've got fixed your dot when stable
then it returns a promise I'm gonna say
then and I'm going to then fashion okay
so what I'm going to do is I'm going to
say when the fixtures stable then do my
detect changes in my expectation okay so
I've moved my expectation might detect
changes and my expectation into my when
stable because I can't use tick in an
async method and now that's how you do
it the exact same test but using async
instead of fake async so there's angular
2 it makes testing asynchronous code so
much easier Thanks don't perfect um so
we saw how click and when stable is used
when writing async tests but we're going
click tick and then doing our sessions
when we're using fake async so the
benefit of async is that it simplifies
coding our asynchronous tests
the benefit of fake async over a sink is
that the tests are all in a straight
line they appear to be synchronous there
are downsides though like you can't call
xhr requests
so in summary async code is edgy to get
right but the new tools are really going
to help you write your tests a lot
easier cool thanks Adam so let's move on
talk about end-to-end tests for a second
anyone catch scott allen's javascript
patterns talk this week a couple of
people so it was really interesting you
made this just this offline comment at
the end of it where he said our less
unit tests more integration tests and i
thought that was really interesting and
he also said that he actually tests his
real services rather than mocking as
much but the real interesting thing
there was that he's kind of saying you
know more integrations there's more into
n tests versus unit tests for his front
end and we're definitely seeing a trend
towards that in people where people are
going are just you know all this mocking
all this work on the front end i prefer
to just do a like an automated smoke
test for my end-to-end test so i thought
that's really interesting and it's kind
of a trend that we're definitely seeing
as well that end-to-end tests are
getting more popularity and people are
kind of wanting to have more of these
even though they can be quite brittle so
end-to-end tests ensure that your
integrated components function as
expected and when I say components on
talking about angular components I guess
I'm just talking about all the bits of
your application cuz you actually run
the entire application has to be running
and then you interact with it in the Dom
so we're going to write some of these
tests now and we're going to see some of
the new language features with async
await around typescript and so I'm just
going to jump in and do these ones that
our last demo of the day and we're gonna
do some inter end tests so I'm actually
just going to come back and bring up
localhost again which show it has our
application running so we want to come
in here and we want to run a test
against this and we want to be able to
grab the title so I can come back over
into code and I'm just going to close
everything down here and open back up
the directory and what we've got is e to
e folder so this is what angular CLI
sets up by default for you they don't
really give you too much in there all
they basically do is do all the plumbing
to get protractor working and give you
some default
so I'm just going to hijack that default
test I've already deleted all the
content that's in there and I'm going to
write a simple end-to-end test now
there's this idea of page objects which
is like a style of doing things which
I'm not going to do today just because
would have lots of pages open and I just
want to show you how the protractor
stuff works so what I need to do first
of all is get some helpers from
protractor so I'm going to import from
protractor a couple of helpers here and
they're going to be the browser which
will allow us to navigate to the right
page and elements and by for being able
to do some Dom selection so once I have
that this is going to look really
familiar to the Jasmine you saw before
I'm going to have a describe block but
now I'm not describing a component I'm
describing like a web page so it's a
different kind of context so I'm going
to actually call this a page and then
I'm gonna say it's the joke page and
usually you're kind of thinking about
testing a user story so it might be
multiple pages that might be like login
go to the email start an email send an
email and make sure everything works so
it's more kind of cross-cutting but in
our case we've only got this one page
and we just want to check the title so
to start off I'm going to say browser
get and just navigate to the root of our
application which is the only page that
we have is this sum this single page is
straight on the root and what we want to
do is check that this title is correct
so once I've done that it's going to
boot up the real application in the
browser navigate to this page and then I
want to actually set a property of title
here and the way I'm going to get that
is to go element by CSS and this time
I'm going to be querying the h1 element
which is the title and it's a different
a different API occurs using protractor
here and it's get text to get the text
content so once I have that then I can
do an expectation again and say that I
expect the title is going to equal this
string of Chuck Norris jokes now I
haven't got any amazing tooling here
that's going to just show me green
lights because obviously I've got a fire
up the browser that's
all the sort of thing you do at the end
of kind of completing a piece of work to
do this integration piece and that
obviously it's not meant to be there so
once this is working I can I need to
make sure I'm just going to clear out
our terminal here I need to make sure
the applications running which we know
it is and then I can go ng to get a hold
of the angular CLI again but rather than
going tests like we did before for karma
you go E to e and this will just trigger
off all the end-to-end tests with the
protractor now that's pretty fast so I'm
actually going to push this over to the
side of the page here and I'm just going
to hide this when I run this it's going
to flash up on to the other side of the
page and very quickly load up navigate
to that page select the h1 element read
its text and then run the test so you
have to watch pretty closely here on the
spare space over on to the side here
boots it up tests it and says that it
fails so let's see why that it's failing
here and it's gonna say it expects error
expects was used so what I've done which
my wingman didn't pick up I know exactly
what I've done I'm just making funny so
if we clear this all out I've actually
just gone and written everything
straight into the describe block which
is obviously incorrect I need to nest
that into a spec so in here I should say
should have the title of Chuck Chuck
Norris jokes like so and then in here is
where we do the work that we said before
so in here I just paste back in what we
had so it's in here that I'd do the
browser navigation and everything else
so what we're going to do now is run
that same test so I'll move this to the
side open this up just clear this out so
we've got a bit of space and then I've
run the same ng e to e and this time it
should do the same thing booted up
select it and then run the test so if we
pop back over here and have a look you
can see that it ran should have the
title of Chuck Norris and it's screen
and it's successful so that's kind of
the like a really simple test but let's
jump in and write one more test here and
actually have a look
some of the new async/await language
features in javascript or in typescript
so I'm gonna do another test but this
time what I want to do is actually want
to click the button and check that the
second joke is different than the first
joke so I'm going to come in and say
should have a different second joke and
I need to navigate again at the start of
every tests a browser get and we're just
going to go straight to the home page
and then in here I want to do a Const of
joke one and then that's going to be
equal to the element by CSS again and
this time we're looking at the P tag
which has the joke and we're going to
call get text on it we're gonna want two
of these one for the first joke and one
for the second joke after we've clicked
the button so here I'm going to go
element again and it'll be by dot CSS
but this time I'm going to select the
button so I'll just passing button here
and rather than calling dot text I can
just call click on it and I'm going to
execute a click so this will go to the
page get the first joke set it to the
variable click the button and then we've
got the second joke there hopefully but
then it we kind of introduce some issues
here and doing this because potentially
the second joke might not be there when
I run this expectation to say that I
expect the first joke is not equal is
not going to be equal to joke two so if
we have a look at this this get text
function here returns a promise so what
I'm actually going to do I could just do
dot then and deal with the promise in
there and put my expectation in there
but what I'm actually going to do is
just block on this line and use some of
the new async/await stuff with
typescript so I can say that this is an
async function totally different than
the async that you saw Adam used to do
with the angular testing utility and I'm
gonna get an error here saying you can't
use this when you're transpiling
typescript down to JavaScript 2015 only
2016 but we're in luck because I don't
actually need to run this in the browser
I'm running this a node that can handle
JavaScript 2016 because these this
execution environment is in there so I
can come back over to the config file
for the type scripts for this throwing
into end tests say don't target es5
target air six for me and now I can use
some of the new language features so
then if I come back to our test we've
got this async I actually need to just
reload the page so that the typescript
compiler can see that I've changed that
settings so now it's not complaining
about this async keyword and I can come
down here and just say a wait in front
of this element I really like this I
find using async await with normal Java
scripts because you've got to always
catch your errors not as sweet as when I
use it with here because if this fails
it's just going to timeout which is fine
so it's really nice just say a wait and
block on this line for me and wait for
it to be able to get that text and then
run this joke but in the in the meantime
I've killed our server so I'm just gonna
say ng serve again to start up the
application cuz remember it has to
actually run the browser so in another
terminal I can come in and run ng e to e
again so I'm gonna push this over to the
side like we did last time and run this
it should fire up the browser navigate
to the page run the first test again
next page check that the first joke
click the button check the second joke
if you've got eyes like Superman you can
follow this but it'll be pretty quick so
it boots it up second one and then runs
it again so I could put some stuff in
here to slow it down but I think you
guys get the point of what's happening
here and how this is running and now
it's running these two tests for us so
that's just a quick look into running
end-to-end tests it's a lot of fun using
the angular CLI to be able to jump in
and do this stuff really quick rather
than spending half a day configuring all
your testing harness and so what we just
had a look at was we went and looked at
just selecting the title and then we did
another one where we actually were
clicking around on some buttons so in
summary for end-to-end tests they're not
a unit test they run in the browser and
usually testing using user stories
versus like a function so this example
is not perfect normally
you'd be like I'll log in check the joke
or do some work and then check what a
normal user would do through that user
story but it helps save manual testers
and I'll love it if we had less manual
testers because I think we could have a
nicer world in that time and save some
people's days so so there's just a
really important point that I think we
need to call out and is that testing is
something that you just can't do
sporadically it's something that the
whole team needs to practice and they
need to practice regularly it really
isn't something that you can just go and
start doing straightaway it's something
that does require practice but it's
definitely worth it so this what you're
looking at here is my attempt to finish
this Wiles on the road this is our new
documentation for our angular because we
do a lot of courses and two-day
workshops this is our testing Docs it's
basically a much longer version of what
we did today with everything so there's
like seven or eight lessons in here and
each lesson has all these different
tasks that you can complete so we just
rewrote it an angular and polymer but
unfortunately it's not complete except
for this section I have to do the
authentication still but if anyone wants
to directly message me I'm happy to give
it to them for free so on Twitter I've
got an open DM if you hit me up on
Twitter you can i'll give you access to
it so it's basically just the module we
did today but you can go and follow it
and step through everything we've done
next one also just calling out we're
doing a 2-day angular 2 workshop in
Copenhagen in February so I'd love to
see some of you there but in summary
what we've had a look at today's we've
had a look at some tools for testing
angular 2 we had a look through how to
use Jasmine around the complexity and
some solutions for managing dependencies
in your tests we look at how the testbed
API can save you a lot of work and we
looked at how async and fake async are
making a lot easier to test asynchronous
code in the in your angular 2 and then
we ran some end-to-end tests look
everyone thank you very much for coming
along follow us on Twitter and we hope
to see you around the conference Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>