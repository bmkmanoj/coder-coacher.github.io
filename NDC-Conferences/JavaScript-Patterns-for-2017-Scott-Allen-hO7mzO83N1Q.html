<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JavaScript Patterns for 2017  - Scott Allen | Coder Coacher - Coaching Coders</title><meta content="JavaScript Patterns for 2017  - Scott Allen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JavaScript Patterns for 2017  - Scott Allen</b></h2><h5 class="post__date">2017-02-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hO7mzO83N1Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name's scott allen and i went to
20:17 it is the end of the day the small
room we're kind of friends here I'll be
honest with you this talk did not turn
out the way I expected it when I started
putting it together if you if you came
expecting like design patterns from the
Gang of Four that's not really what
we're going to talk about well what I
wanted to talk about was patterns that I
see in the JavaScript language
particularly patterns that have
disappeared from the old way of doing
things and new patterns that have
emerged and it's not just design
classical design patterns it's more like
patterns in the tooling patterns and in
the build process we have some patterns
in the code also things to be wary of
when you write JavaScript code things
that people try to commonly do and fail
at because uh they didn't quite
understand how a particular feature work
I hope to get you so all of that and I
did just want to take a quick poll of
the audience as I can see everyone
through the headlights here how many
people are using typescript
today quite a few so at least version 2
I'm guessing tight skirts and how many
people are using I cluster of 2015
features like import-export class
definitions okay well I hope everyone
gets something out of this talk I
basically broke things down into a few
different areas number one modules when
the ECMO Strip 2015 specification came
out yes there was a lot of excitement
about arrow functions class definitions
but it was really modules and the ACMA
script 2015 module definition that has
that has the most significant impact on
our code and our architecture and how we
build large applications so I want to
spend a little bit of time talking about
modules I also want to talk a little bit
about language features and show you
some things to be aware of talk a little
bit about the current cooling system and
JavaScript ecosystem and everyone needs
a build process for JavaScript these
days so I'll give you some of the tips
that I've learned over the past few
years trying to build typescript and XS
crip 2015 code first of all let's talk
about es modules when I solve a
specification for es modules that I
remember completely under appreciating
the impact that modules would have on
in JavaScript so the first thing that
happens first thing that happens is a
lot of old patterns fall away there's
actually two patterns here in this
little code snippet one is the
immediately invoked function expression
and we've been a lot of us have been
trained over the years to wrap all of
our JavaScript code inside of an iffy so
that nothing escapes accidentally into
the window object of the global scope
right and the second thing we were
taught was to start using the string
literal use strict to switch the
JavaScript runtime into the strict mode
which can reduce the number of strange
errors that you get the amount of
strange behavior that JavaScript has and
sometimes even lead to performance boost
those things are all gone because when
you write a equi script 2015 module
you're using import and export keywords
you're using something like the
typescript compiler and web pack to
build everything together when you're in
a any JavaScript file you don't think of
it as a file anymore every time you
create a dot J s or TS file that is a
module in JavaScript and you don't need
any sort of iffy nothing's going to go
into the global scope unless you
explicitly try to put it there by going
to the window object and you don't need
this use strict declaration anymore
because modules by default they will be
interpreted and executed as in strict
mode so forget all the old things you
know about modules and concentrate on
what modules give you and I'll just give
a brief overview for those of you that
haven't worked with echo script 2015
modules which you can write from plate
scripts also take script used to have
this name spacing thing but these
modules are even better so inside of
this file as a dot JSP file it is now a
module this function work unless I
explicitly write an export statement
saying that I want to export that other
people then that is hidden it's an
implementation detail of this file no
one will be able to access that symbol
and invoke that function but down here
at the bottom of the file I said I want
to export two symbols work in person so
you can export functions you can export
classes you can export variables and you
can also have a default export which
just means when someone imports it they
don't need to use the curly
races to bind against that export they
just say export or sorry import to from
bar and they will get whatever the
default export is we'll talk a little
more about that in some more detail in
just a bit so I can import person an
animal from lib and you'll notice I'm
specifying a relative path so if you do
dot slash and what the module bundler
should do whatever tool you're using
which in the future might be the need of
browser the nodejs but no one actually
supports loading modules just yet we
have to use tools to do it
that should while searching for a Lib KS
or Lib dot t-- s file I don't specify
the file extension this is grabbing a
default export for this particular file
this module /lib slash human should have
an export default of some symbol and
then this syntax is basically a way of
saying give me everything there's this
library exports and attach it to this
object Lib and it's not well yes I don't
want to call it a variable we'll talk
about exactly what that is in just a bit
but now to access things inside a
library I have to say live that person
with that animal
they'll all be available some of those
functions like an angel ease so a couple
things to note about this when you're
using modules also that people run into
trouble with one is that the import
statement creates what we call an
immutable binding so it's not really a
variable back here if I can say import
person from Lib this is a binding so
even though you can use person like a
variable throughout the rest of this
module you might run into unexpected
behavior so here's an example I'm going
to have a module that exports a counter
just exports basically the value 0 and
I'll export a function that someone can
invoke from this module called
incremental increment the counter so in
some other module I will import counter
and I'll try to modify it that should
produce a runtime syntax err telling you
that you are not allowed to do that
counter is an immutable binding I cannot
change the value that is in that binding
I can however
import the increment function and call
something in that module to change the
counter value and that will work so the
counter will value will start at start
time to zero alcohol increment will free
look at counter again it will have a
value of 1 and this is important to
understand that from a design pattern
point of view if you want to create a
singleton everyone who imports this
counter is going to see the same value
and that value is live for everyone so I
could import counter into three
different other modules they're also
going to see the value 0 until I
increment and that value changes inside
of there so it's almost like a layer of
indirection in these bindings ok and
after these bindings are live so let's
export using an object literal syntax an
object that has the name Oscar let's
export a function that will just say
basically what names you see inside the
module and then export a function reset
which will change the entire object
reference that we're exporting into a
creature so if we start off things and I
import so pretend there's an import
statement here in another module if I
try to assign to the name property of
creature a new value that works so that
part of the binding is not if I try to
change creatures that's a syntax error
if I try to change a property on
creature that's okay so I'll just change
the name and everyone's going to see
that name I'll see the name in this
module if I ask the module itself to
inspect that value that will also show
winning and if I do a reset everyone
will see a new creature object there
with a different name so I'm making some
sense and here's what I think
interesting with modules so the kind of
talking about patterns the kind of
pattern I like to see let's say you're
building a library and you're going to
have a welding module and a logging
module and an HTTP module sound familiar
and you're going to have an application
depend on that library and that
application can also use modules routes
the shell components that you have and
of course both of these pieces are going
to depend on additional implementation
details so for example the library on
the Left will depend on the HTTP module
might depend on something that
specifically knows how to instantiate an
XML HTTP request to make the request
versus another module that might use the
fetch so what's interesting is since
let's say the the fetch implementation
of HTTP is in this module someone will
have to export symbols from this module
to make them available to HTM using HTTP
just like in my components I'm going to
need to export things to be able to get
to the functionalities r1 and it's fine
it's my components my application
references HTTP module unfortunately
it's also possible to get a reference
into some of these implementation
details I can XML HTTP other class
because it is just exported and anyone
can walk up and as long as they know
where that is on the file system they'll
be able to get to the XML each of your
class which is I don't think such a good
thing typically what I like to do though
is to make sure that there's some
well-defined boundary where my
application will export things and where
I will only allow say my application to
drill into one level of the library
that's actually the libraries
implemented and one way to do that is to
have files that use this export star
syntax or have an index jes file that
will export things from that directory
only the public things that are needed
so if you're not familiar with the index
dot JSP this has to be supported by some
sort of tooling but essentially let me
back up to an import statement real
clear
if I write this credit import calendar
from glib slash features my tool can
look for a creature CAS file or
creatures TS file or I can also
configure things to look for an index
dot JSP s file that is in that folder
/lib slash creatures and this goes back
no developers have been doing this
forever
the idea is that this folder creatures
has a whole bunch of JavaScript files in
it and it's that index dot JSP s file
that really contains the things that are
exported from that particular folder so
there can be other implementation
details inside of there that are
exporting all sorts of things but
publicly what I want you to use are just
the exports from the index.jsp file that
is in that folder
mmm and if I'm just exporting everything
you can use export star syntax to say
let's just grab a bunch of stuff from
all the GS files that are in this folder
and push it all out as public API one
way to do things and then we're in this
kind of strange situation with
JavaScript so the module syntax that
import and export stuff has been defined
by the extra script 2015 standard so the
syntax is solid that's what we're using
moving forward but there's not a single
environment out there that natively does
module loading so there's no browsers
that natively support some sort of
import statement what we asked to do
right now they're working on that
standard but what we have to do right
now is use a tool like one of the ones
listed here that will go to our
JavaScript source code analyze the
dependencies to import statements and
just follow them out so find all with J
s and T s files that we need for our
application and then bundle them up into
a single file or multiple files but it
basically needs to resolve all those
imports so that things will work at
runtime without requiring something like
an import so use an API that actually
works maybe something like require
personally I've evaluated webpack and
roll-up and I use browserify long ago
and right now I'm really still prefer
web pack I think it's a tool that has
the most
some so if you're you know selecting a
tool to bundle up the JavaScript code
and we definitely look at web pack I
would also take a look at roll up roll
up was implemented because people wanted
something that was a little more
efficient than web pad and turns out
when web pack bundles up all this
javascript code it puts a rather large
prefix and postfix around each bundle
around the each module so it can be
dynamically loaded and that has some
that adds to the code size of all the
JavaScript code just shipping to the
browser will UPS a little bit better
with that but web pack just released
version 2.2 within the last couple days
and they promised that the next thing
they're going to work on is actually
optimizing the bundle sizes so when it
puts modules together particularly
modules that are commonly used together
it won't have as much overhead and the
other thing that web pack implement
implemented in version 2.2 that roll-up
had before was tree-shaking which is a
way to shake this tree of dependencies
and actually figure out what you're
using and what you're not using so
things that you're not using can be
thrown away you'll see some interesting
studies out there where people say this
tool this tool plus this tool produces a
JavaScript files it can be gzip to this
size and when it's sent to the browser
it takes this long to start executing
and we also have to factor in when
you're choosing a tool that you want to
use how hard does that tool have to work
to produce your bundle you can see the
closure compiler up here produces code
that is very small but it's also one of
the slowest tools to use whereas the
typescript plus web pack combination is
pretty good and small code executes
about the same as everyone else and it's
a lot faster than closure and that's
another reason why I prefer web pack it
has a the ability to allow me to do the
hot module loading into the browser so
when I change the TS file and say that
just that little snippet of code gets
transpile and put into the browser and I
don't lose any state in the browser just
used games the new behavior
how many people use webpack few webpack
gets easier and easier to use and once
you learn like everything once you learn
a few of the basics it becomes easier
you basically have to provide it a
configuration that gives us a few key
key pieces of information so one key
piece of information is what files am I
going to look at so this is telling them
to look for TF TSX for react and Jas
files I will talk about this modules
directory in just a bit you have to give
it its entries so entries would be like
the module name that you want to use
that where webpack should start to
analyze your dependencies so if you have
something like a main TS file that is
the entry point for your application you
would put name TS here webpack would go
to that file look at the imports go out
and find those other files that were
imported bring them in look at their
imports and it just follows that tree
down so you need entry you need output
basically what file in my building where
should I put it to put it in some paths
that I've assigned to assets you'll have
plugins web pack calls loaders because
web pack by itself is only concerned
about analyzing dependencies and
bundling code together when it
encounters something like a tight script
file that tight script file has to get
transpiled into es sexiest files
whatever and what and web pack doesn't
do that natively instead there's very
common plugins for web pack this TS
loader is a loader that web pack will
call on when it sees a file with the PS
or a TS x in this case GFX extension is
loaded it'll call on this TS loader
which calls the typescript compiler and
that produces the code that web pack we
use and then there's a bunch of other
plugins I'll talk about this DLL
reference plug-in and just a bit but
this modules directory by the way I love
this thing so a lot of times when you're
writing your application code I hate the
pattern where
had import statements to do dot dot dot
dot dot slash dot dot slash dot that
slash and they're always moving up the
directory and then coming back down
somewhere to find a module one of the
thing things you can do with modules
directory is basically tell web pack
what is the entry point where I should
go start searching for things so if I
have a statement like import su from bar
what web pack will do is first go to the
/ client slash script folder and look
for a bar directory with an index file
or a bar GS file it will try to find it
there they'll try to find it in node
modules and this just if you define
module directories for the top-level
modules that you want people to use it
becomes a very easy pattern to spot in
people source code if you see them using
dot dot this and dot dot bat or trying
to drill too deep into the directory
layer that you've defined then you know
they're doing something wrong they're
not they're not following conventions
and the pattern that you want to use an
application this by the way also
supported by typescript we'll talk about
that in a second something else I
believe in is having a web pack
configuration file per purpose so the
pattern that I've seen in the last
couple applications I've built this will
be a web pack config jas that will build
my application code I'll have a web pack
config dot bender jas which will build
third-party code so vendor code things
like angular react whatever I'm using
and I'll have a web pack dot test or web
pack config test jf so the web pack
bundles up might ask which brings me to
another point while I'm at it a lot of
people will use a test JavaScript test
when they're like karma karma has a lot
of plugins you can tell karma that you
want it to run unit tests and point it
to typescript files but then you also
have to load a plug-in to karma to say
when you see a dot tes file please
transpile that before you try to run the
code inside and so you have karma
transpiling your test on the fly I would
prefer actually to just have web pack do
that
it simplifies the configuration for
karma we don't have to worry about it
trans piling things and as typically
found that just to be a little more
robust and to work better and maybe even
be a little bit quicker karma all it has
to do now is sit in the background and
wait for a file to change a Jas file
that's already been bundled up with all
my tests produced by webpack which is
really good at calling and getting
things changed piled and then karma just
has to execute this test in a browser
and the one thing to remember about web
pack is I'll see this pattern to where I
actually write a little bit of
JavaScript code to go out and find the
things that I want web pack to do
because web pack this configuration file
it is executing inside of nodejs you
have access to all the npm modules and
programming constructs that you can use
a node so I can go out and I can require
something like a glob and I can say
basically I'm going to go out and find
all my so this is building tests I want
to find out all the files that have a
dot spec TS extension those are my tests
- all the holders that are in my project
and just bundle them all up and I'll
have some specs over here in this other
area where I keep common modules and
this crazy thing is just trying to
rewrite the file name so that if I have
a file in say slash features / - board
slash foo and bar dot specs top PS I
want that rewritten in a way so that it
is just so I'm trying to remember what I
do that with that crazy global
expression I just want to call it a
whatever its name is flash script /t
effects and the end of the day I'm a
little bit loopy right now
select modules let's talk about arrow
syntax for a second arrow syntax that
was introduced in Ekta script 2015 is
this beautiful notation for writing a
function that looks just like lambda
expressions and T sharp so I can write
an expression where X goes to x times X
and I can invoke square now like a
function if there's two parameters I
need parentheses around the parameters
so here x and y go to X plus y and
here's a log yeah well that one's not
different I was going to say if you have
zero parameters you have to use the
parentheses too but I can invoke log
caching at the result of squaring adding
3 and 5 very good I mean seems simple
rate and allows you to do a lot of
programming with higher-order functions
with XS which echo script and JavaScript
encouraged because now I can call like
the map function on an array and just
pass in an arrow function and double
everything in the array don't have to
use the function keyword anymore which
is nice but here's some patterns where
I've seen people run into problem
problems and I see it a lot actually in
the react community just because of
their particular style of programming
but one problem I've seen people run
into is trying to return an object
literal when they're writing an error
function because what the JavaScript
runtime see here is that you're passing
in a function that takes a parameter N
and it returns this expression which is
an object literal or sorry doesn't
return this expression and get that
backwards when the JavaScript runtime
sees that opening curly brace it assumes
you're not just immediately retraining
an expression anymore it assumes you're
running executing a block of code so as
soon as you put that opening curly brace
there you've defined a function that
unless it has a specific return and
explicit return keyword it doesn't
return anything
so number stop map n goes to what I
thought would be an object literal where
I'm creating objects with a value
property that would actually produce
undefined undefined undefined so in
array with those three values
easy solution to that is to wrap that
object literal with parentheses and then
you come out with value 1 by u2 baggage
3 this three objects fascinating isn't
it
glad you stuck around for this I hope
and here's where people run into
problems with air functions so it's
supposed to be a feature of arrow
functions but it creates problems so the
idea was one of the special
characteristics of an arrow function is
that it can lexically bind the dis
reference so I don't have to save the
discrepancy often to a local variable
and capture it in a closure so for
example this adder object has an ADD
method and I can tell us to add up some
numbers pass in an array and it's going
to try to use a for each statement and
access this right you've run into the
slippery this problem before I'm sure
the value of this has changed from what
it was at this point in time right
inside of where we started executing and
this piece of code that is inside the
function that we passed into for each so
we'll get cannot read properly some it's
not pointing to an adder object anymore
arrow functions solve that problem
because this arrow function that's
defined that I'm passing into for each
the rules of JavaScript say that this
has to lexically bind which just means
in the looking at the source code
electrically the value of this here has
to be the same as the value of this just
outside the arrow function so like just
when we started executing add so that
code will work fine but this is where
people run into problems arrow functions
you have to be careful about using too
many arrows so this is working code
right here I have a method definition on
the object literal and a for each
statement inside but what if I wrote it
like this what if I wrote ad as an arrow
function
that means that this arrow function will
capture the value of this lexically in
the scope where was defined which is
outside of adder so it's typically
whatever is the value of this is inside
of a module and inside of a module the
default value of this is undefined so
this code doesn't work so you know
basically look for the enclosing scope
of the arrow function if you're inside
of another function you're fine if
you're inside of an object literal
you're not in such a good shape and then
the other thing that trips people up
again particularly react primer
programmers who want to define arrow
functions and bind them to event
handlers is that once the value of the
disk reference is set for an arrow
function you can't change it it's baked
in so if I define this object adder and
I define this function called add and
then I try to bind adder to the add
object literal here to that adder object
that fails I cannot change the value of
this doesn't work the value of this will
be electrically whatever wherever this
was defined so just be out here be
undefined and that's something that you
have to be careful with with legacy
library so I look I write a lot of
Jasmine unit tests and there's this
ability in a Jasmine unit test where
inside of a test here instead of a and
it you can use the value of disk to pass
around some context between different
tasks we're between the you know like
before each and then each individual
task and what Jasmine tries to do when
it invokes this function as it tries to
set up the value of just a point to the
test context that it's managing but it
doesn't work because Jasmine is unable
to change the value of s is actually
actually how I ran into this I had
Jasmine test failing just because I
changed those from function function
keyword to an error function and that
can happen with things too like jQuery
jQuery I'm trying to go out to a button
hook up a click event handler defining
it with an arrow function and saying dis
name because if I worked out as a
regular function that would work
when jQuery invokes this callback it
sets up this pointer to point to the Dom
element but there's an arrow function
that doesn't work and the value will be
whatever function I'm inside of or at
module scope that would be undefined
there's new keywords to declare
variables and X equal script 2015 and
one of the patterns actually out there
that I kind of like and I've been using
is that use the Const keyword instead of
the let keyword wherever you can
constant means no one else can assign to
that variable
they cannot overwrite the value so if I
try x equals 3 on a Const X that should
be a type error at runtime that doesn't
mean that I cannot modify again the
object that I'm pointing to so I can
modify this array and push new values
into it it just means that no one can
walk up and say numbers equals and some
other array if that's something I wanted
to do there's an object out freeze API
to freeze numbers and there's libraries
like immutable Jaso will give you
immutable data structures I would look
at that something else
so another pattern I'll another set of
patterns that is completely following
away when you start writing echo script
2015 or typescript so you don't never
write another constructor function and
prototype exes crypt 2015 enter these
classes and we say that classes are just
syntactic sugar for what happens behind
the scenes which is here's a constructor
function but someone uses the new
keyword on this is not of setting up a
prototype for objects that will be
instantiated from employees to make sure
they have do work methods and that's a
useful mental model to have about
classes that they map from this syntax
to the syntax but there's a couple
patterns that you might have used with
constructor functions that don't work
with classes for example hoisting
you might want to write a utility class
of some sort in a module and push it
down at the end of the file because it's
not important it's not the thing you're
exporting you just want to use it from
the top of the file and even think that
would work I mean it works with
functions I can take consti equals new
employee and define the employee
constructor function later at the bottom
of the file that just works because
JavaScript essentially a holy Stephan
ition up to the top of the file and
things were it does not work with
classes if I try that same code with a
class definition at the bottom that will
be a runtime reference care which is
interesting and you say well why is that
and you'll get even more confused when
you go into the extra script 2015
specification and you realize that they
say classes and functions are both
wasted and the function hosting allows
us to work but for some reason the class
hoisting doesn't work and that's because
of this other thing that you'll find in
the echo script specification called the
temporal dead zone anyone here the
temporal dead zone the TDD sounds like a
bad movie the temporal dead zone is what
the echo script 2015 specification
declares as the area where a symbol is
available because it's been hoisted so
like a class definition at the bottom of
the file it's there it's been hoisted
but until it's been formally declared
it's in the temporal dead zone and any
attempt to actually try to access it
will produce a reference err the same
thing actually happens with let so let X
equal to this X technically it's hoisted
to the top of the function that's
available up here but if I touch it or
try to do anything with it I'll get a
reference here and that's just
particular it does that wouldn't happen
with bar bars are hoisted and there's no
TDD but anything declare was lat or
Const or class definition you would run
into that problem another problem I see
people run into a pattern again
trying to push the pattern aspects of
this tone is people do a lot of
reflection in JavaScript
I want to walk out to an object and see
what's inside of it and it works a
little bit differently if you define a
constructor function and a prototype if
I do a four in loop over a new instance
of human I will get back to do work
function that was defined in the
prototype so I could see oh yes this
object has that capability but if I
tried to do that same thing with a class
definition it wouldn't work
just when class when a class is
instantiated it takes some extra steps
when it's adding those methods into the
prototype so that they are not seen in a
foreign loop so you might be wondering
well I really want to do see what is in
this class what do i do what do i do you
could do this you could say I want to
get the prototype of this object that I
have and then once I have that I can use
object not get own property names on
that prototype object to find out
exactly what is inside of a horse and
that will actually not only tell me
about do work it will tell me about a
constructor that is available for a
horse because it's a class
another pattern that you might have seen
in regular JavaScript is when people
implement a constructor function they'll
use instance of checks inside of the
constructor function to make sure that
someone invokes that function using the
new keyword and if they didn't because
it's not an instance of that function
they'll turn around and use new and call
the function again you don't have to do
that with classes if I have a horse
class defined and someone just tries to
invoke that constructor function that's
it's there behind the scenes for a class
that'll be a runtime type error so you
don't need to do any crazy checks on
that but interestingly enough if you're
in a situation where you might want to
mock something out or fake something out
and you want to walk up to an existing
class definition and rewrite the
constructor you can actually return
anything from a constructor it's not
like c-sharp
where I say new horse and I always get
back a horse I could say new horse here
and just get back an object with a name
property giphy JavaScript so here's
something the thing about using new
features of the XS trip language so
extra script didn't change for the
ten-year period because of political
infighting where the parties fell apart
and they dipped version for the standard
and it took forever to get back on track
and we finally got extra script 2015 and
now there's a new echo script
specification every year did you know
that there was a 2015 there was a 2016
which didn't include really anything new
but there's a 2017 specification coming
now and so you might want to say to
yourself how aggressively should I adopt
features and it depends on the
application and the team but I see a lot
of people aggressively adopting features
in some circles like in the react
circles they're aggressively adopting
these features of echo script features
that haven't even reached the standard
gap and one of the popular transpilers
out there battle there's plugins
available for that allows you to
configure just what babel knows how to
compile how you know should have
transpile stuff from just XS crip 2015
or also 2016 and 2017 so I can go into
my babel configure
and npm install babel + es2015 + es2016
if i just want all the current standards
I can just say npm install the latest
plugin for babel there's a plugin for
react and then there's these stages over
here which are interesting so the theme
the echo script specification the way
the way they work the recommendations
all go through this stage process where
stage 0 is basically like okay someone
on the committee had an idea at the bar
and they're going to propose this new
feature by the time it reaches stage 1
it's a little more serious people have
prototype this out they've hopefully
worked out some of the bugs and the
implications for the runtime by stage 2
there's probably some people that have
implemented this in a runtime somewhere
and by stage 3 you might even have
browser vendors already adopting this
new feature of echo script before it's
officially in the stack and then there's
a stage 4 which is essentially it's
ready to go it's just waiting for the
next specification to be released and
you can go into babel and you can say
okay I want stage 3 features because I
want stuff that's almost there it looks
so good I just want to use it this to me
is always interesting um typescript is a
lot less aggressive on implementing some
of these features some things that go
for like a single wait before it's
actually ready from the specification
but babel you can get really far ahead
of yourself and some of these new
features are quite good some of them are
worried about and sometimes I worry that
something will change in a late stage
and break existing code but I did just
want to cover one crazy operator that's
being that is currently in stage 3 and
quite useful it's the object spread
operator but sometimes it leads to
crazy-looking code so II this is not new
this is the bang bang you're a boolean
so I want to take value and basically
coerce it into a true boolean value and
get back a true or false so a value of
one this should be a result of true true
boolean a true boolean value through
and we're going to combine that with
something called the spread operator so
the spread operator in Equus Tripp 2015
allows you to do things like take an
array and spread it into a new array so
result would be an array with one two
three four five six and people looked at
that and said you know that that's nice
to have with arrays but what I would
really like is to be able to spread an
object into another object in other
words if I have this object data with X
1 Y 2 I'm going to create this new
object result that will have gain x + y
in other words take that data object and
spread its properties into a result and
this is another one of those things
that's quite useful and react when
you're using something like Redux and
you're always treating up new instances
of objects to represent your new state
that you need to copy some things over
from old objects and in fact in the
reducti berry there's this construct dot
dot dot bangbang ternary expression and
you look at that and you have to figure
out what it does and what it's doing I
mean one of the first things you have to
figure out is operator precedence
obviously I mean what what order is this
expression going to be evaluated in so
once you find out that the negation
operator will be evaluated first you'll
realize ok what we're going to do is
we're going to turn data into a boolean
true or false and then the next thing
that is evaluated is the ternary
expression so if data is true we're
going to take the data object and spread
it into this thing
if bang-bang data returns false we're
going to take this object literal over
here default true and spread that one
into result so I want to spread one of
those two things into result but if you
haven't given me data I'll spread a
default in there JavaScript
anything away wonderful feature I just
started using it a few weeks ago and I
much I'm much I like this feature but
almost immediately the team ran into a
couple problems so a single weight is
behind the scenes is all promise based
when I have a function declaration get
matched set
that is an async function that means
that that function has to return a
promise and when a transpiler like babel
or take script comes across this it will
make sure that get map set returns a
promise because it will create one
immediately and then resolve it if i
return result bought data and reject it
if an as an exception comes out of here
so it works very similar to C sharp but
C sharp of course is a task the key here
behind the scenes the mechanism to
control this is a promise javascript
promise and here I can await something
that returns a promise any promise it
doesn't have to be a library that was
implemented with async await it just has
to be a library like jQuery angular also
two libraries out there use promises for
different things so this is a HTTP
communication library called Axios and
actually can say actually is get and
every turn to promise because of that I
can await it and I'll get the result of
a successful resolution here inside my
result variable the trick here is
there's nothing in JavaScript that
forces you be or will be aware that you
might have forgot the await keyword and
that when you return result that data
you're really returning the you're
trying to get the data property of the
promise that was returned from a kiosk
it so that's one of the issues that
comes up with us but this is how I could
use it I could have a load method that's
also async and say I want to go out and
await my ATI getting golfer's await my
API getting something else and then do
some work with that data that has come
back and that's just waiting for
promises to resolve how many people
think that would be in serial like one
at a time well we'll get the active
golfers and wait for that response to
come back before we go to get matched
set anyone think that yeah how many
people think it would be impaired
Oh nobody okay
well this would happen one at a time
we're awaiting that promise to resolve
and we're not going to go any further in
dysfunction until that promise returns
and we have some golfers and then we'll
go out and get the match set so how
would you make this work in parallel
there's a couple ways to do it but
basically you cannot use in a wait until
after you call these two methods get
active golfers get matched at and one
way to do it is just to use the built-in
promised methods that are available like
promised at all promise that all you
pass it an array of promises it will
wait for them all to resolve
successfully and then give you the
result back in an array which will just
be structure here into two variables
golfers and match that and again it's a
good demonstration if I can await any
promise even a promise that I create
it's no problem takes about e I'll be
honest I uh avoided tight script to the
longest time I thought it had some
wonderful features but I just didn't
work the way that I wanted it to it
seemed like it was always just not quite
up to par with what I wanted to do but I
think angular has been very good for
take script I think the typescript team
actually recognizes the problems that
JavaScript programmers want to solve and
how the tools work and how the ecosystem
works and I just wanted to point out a
few things about this PS config dot JSON
file that type script uses to figure out
you know how it's going to behave
so first is no implicit any that's been
around forever but that's basically the
trigger that says are you all in with
site script are you not and if I set
that to false I can have any types just
floating around anywhere and I don't
have to worry about typing as much as
many interface definitions and things
like that for take scribe B I liked that
they started embracing things like
working with the angular team and also
working with react it's a real pleasure
to write CSS files and write JSX
components with typescript behind the
scenes here's a big one that arrived
module resolution node it's really nice
that I can just say npm install some
library
and maybe that library already has
typescript definition vowels like
angular 2 would and then I can just
start writing dot TF files in my own
project and say import this and import
that and play script automatically
because of this module resolution
setting will say yes I'll go into the
node modules directory and look for
those things where cause requires no
additional setup which is nice I like
the tasks setting so you might remember
earlier when we talked about web pack
and this was new and version 2 I think 2
or 2.1 and I don't remember earlier in
web pack I gave web pack some paths to
look for modules here I'm doing the same
thing with typescript if someone says
that they need to import through from
bar go out and look in the client /
script slash bar Jas look for that file
or the bar directory that's really nice
so it understands my layout and it even
understands my environment so one of the
things I would struggle with with plate
scrap and sometimes you pull down a
library and take script word complain
that I don't know what a promises or I
don't know what this Dom structure is
that you're using now with this lib
setting you can explicitly tell
typescript the type of environment that
you're operating in so I'm probably
programming in the browser I'm going to
tell typescript that the Dom UTIs will
be available don't worry about it don't
try to throw an air from trying to set
inner text on such and such a thing I'm
using es5 EP eyes I'm also using ES 2015
promises they will be available which is
good
a place to call home this would show
what my usual directory structure would
look like for certain applications where
I have a services folder in that
services folder I might have an API
wrapper for my Web API something that
handles errors something that handles
parameters that come down from the web
server util that might be private users
I only want to use that inside of
services so that's where inside of index
PS that that's where I would carefully
go through and just export the things so
they want to export from services so
that somewhere else in my application I
can just say import API import API from
services I don't have to say import API
from services / API just from services I
went there just that top level and I
usually for asp.net core project anyway
I keep my uncompelled sources completely
separate from the compiled sources like
an asp.net core I treat the dub-dub-dub
root folder as like the bin directory so
the only thing you'll find in there are
the process JavaScript files that have
gone through the translation it's gone
through a web pack how many people use
on the types repository now the type
scripts so this is also the best thing
ever so originally with typescript we
needed declaration files things like
jQuery and all these other libraries but
weren't offering typescript so they
created a definitely definitely types
repository which gave you a place to go
out and download declaration files for
things like jQuery and then eventually
there came the tool the TFT PSD tool
typescript definition tool where you
could say TSG install jQuery and it
would go out and fetch the thing from
the repository and then came the
Taipings tool and the typing stat jacent
file or you could say typings install
jQuery and it would remember that and
put it in me or the typing stat JSON
file all of that is gone
just get rid of it get rid of all those
tools and extra configuration files
because now although all of the types
declaration files for libraries and
frameworks that do not provide them
natively like angular 2 would
live in the NPM package app types this
meta package they bacala and now if I
want to for example install declaration
files for react and Jasmine unit tasks
I don't need to install any other tools
I can just say npm install act types
slash Jasmine and poof all of a sudden I
have intellisense for Jasmine when I'm
offering typescript files no additional
configuration no additional tools needed
and it's part of my NPM package Jason so
when I do an NPM install I not only get
the libraries that I need I also get all
the types like declaration to they need
so it's quite nice the one thing that
does concern me about typescript still a
little bit they have to be very careful
about how aggressive they are
implementing new features I ran into
this thing when I was programming with
react where I wanted to write a function
that would do structure incoming
parameters for the the props of a react
component and it turns out that that
parameter destructuring of course
conflicts with typescript which caesar
as something different trying to provide
type annotations and there is a way to
do it as just a little bit cumbersome
that's unfortunate and it when people
you know try to propose syntax to work
around us you know the types creat type
scripts teen says look we have to be
careful there might be conflict in ef7
we kind of have to see how the
specification committee works us out and
sure there's people from Microsoft that
can influence the specification
committee but still one of my concerns
about typescript is just how quickly can
it evolve and adapt if the XX or script
specification or for some reason to put
in a feature that conflicted with an
existing typescript syntax right yes
there's one more thing I want to say
about Shakespeare but I don't I lost it
I don't I bring already the build so I'm
a big believer my patterns for builds
are to have tools do the simplest
possible thing that they can do so web
pack is for bundling only karma is for
running tests I don't try to transpile
things when karma runs
I still use gulp because you can do 99
different things with web packs with web
pack there's plugins to copy CSS files
around on the hard drive and all that
stuff but I would still prefer a web
pack to just do my bundling take these
files and spit out an output somewhere
and I'll still use gulp to do everything
else and then even when it comes to gulp
I'm a bit of a minimalist so there's a
plug in gulp - web pack that allows you
to use web pack inside of gold but the
truth is web pack is just an executable
so why not just require exact and just
execute that command you know by
shelling out so I want to execute web
pack when someone wants to run the gulp
task Jas - app to try to keep things
simple not rely on additional plugins
just to make things maybe with a
different syntax or a little more
convenient and just a minimalist about
it and speaking of which no more global
tools there's a few tools that you have
to install with NPM there's there's only
a few tools that you truly have to NPM
install globally with a dash G switch an
example of such a tool would be yeoman
yeoman is used to scaffold out a new
project since no project currently
exists I can't have human any project so
therefore I install it globally but then
when you look at a lot of the samples
that are out there for web pack for
example a lot of people will say ok to
get started with web pack the first
thing you do is npm install web pack -
JEE felt like globally and I love when
they throw the pseudo in there because
you have to be an admin to install web
pack which isn't true but I digress I
will only install those tools locally so
npm install' web pack npm install'
typescript and then if i need to invoke
those tools if i want to make it easy
and not have to drill into node modules
/bin to get to that tool
because that's where they will live well
if you define scripts in your NPM
package JSON file when it executes the
command associated with a script it will
include the node modules bin path when
it's trying to find whatever you're
trying to execute so if I just have
shortcuts to run web pack and a shortcut
to run karma I don't have to worry about
a global installation of web pack it's
local so the trade our trade off there
of course if you have a thousand
projects from your file system you'll
have a thousand copies of web pack which
isn't that nice but I can tell you what
in about two weeks there's going to be a
whole lot of people that probably don't
want a global web pack install because
now when you start NPM installing web
pack from scratch you're going to get
version two which has some configuration
changes and breaking changes from
version one which everyone's been using
up to this point so no more Global's
keep them local this is my typical karma
configuration file I just want to set
the base path the frameworks the files
the reporters the browsers I don't want
to load any plugins to these crazy
things like transpilation
all that's taken care of by the other
tools this is just my test runner - all
I wanted to do so load up my vendor file
load up all my specs and my spec files
when what Pak processed them they
bundled in my application code because
of course my unit tests were they were
importing things from my application and
I like to keep keep my spec files in the
same folder as the component or the
service or the objects that they're
associated with so if I'm building
something to wrap an API
I'll have API TS and API spec TS and
specs will allow me to identify that
that is the unit test file to execute
and slightly controversial if you know
really pay attention to code here I like
using jasmine and I don't like mocking
frameworks at all I try to write
actually more integration tests these
days
I have found that they provide the best
bang for the buck so for example if I
have a component that uses of service
and that service calls into an HTTP
service and that HTTP service calls and
visual logging service whatever I
actually want to write unit tests
against that component that use that
entire dependency chain right up until
an HTTP call is made I do want to fake
out the HTTP call so I'll cut things off
but like the data access layer in my
JavaScript but to me a lot of the
components that we write there they are
orchestrators their entire purpose in
life is to call the right service at the
right time and pass the right parameters
there's no real design issues that I
need to drive out with TDD there's no
real state inside of them that I need to
assert on because they're just they're
not doing any calculations or algorithms
not all of them are like that but quite
a few of them and something I discovered
a couple years ago with angular is we
were writing all these unit tests trying
to isolate things like a controller
which means we had to fake out services
that were used at that level and it
turns out then those tests weren't very
robust things would still break in
production the underlying service
implementations the real implementations
could still change and people forget to
update the unit tasks and we switch
things around and said you know what
we're going to test the controller
calling this service and that service
telling that service we don't care we'll
just stub things out at the HTTP layer
it was something like 70% left code that
way
and we suddenly had a much higher
success rate of catching problems before
they went into production because now
when someone changed like the API
service that wrapped HTTP the unit tests
would actually fail because we weren't
trying to fake out or mock anything at
that point so slight rant their own
tests and that's pretty much all I have
for you I hope you got something out of
this presentation if you have any
questions feel free to email me that's
my email address I always answer
questions and have a good evening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>