<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A taste of EcmaScript 6: the language and the tools - Rob Richardson | Coder Coacher - Coaching Coders</title><meta content="A taste of EcmaScript 6: the language and the tools - Rob Richardson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A taste of EcmaScript 6: the language and the tools - Rob Richardson</b></h2><h5 class="post__date">2016-08-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Io0RYJLB674" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody it's great to be in Sydney
I'm Rob
ittsan some people know me as rub rich
Rob underscore rich on Twitter it's it's
great to be in Sydney here's the part
where I say I'm definitely gonna post
the slides of my blog tonight you're
gonna email me in a week or two I'm
gonna reply in a month or two no really
I'm gonna post you can go to my blog
right now
Rob rich org slash presentations and you
can pop open the slide deck right now
we're gonna learn es6 the language and
the tools Rob rich targets my blog so
that was fun well maybe I won't be using
this so I do a few things in JavaScript
and a few things in net
you're not going to trust what I have to
say unless you know that I know what I'm
talking about
so that's me you can hire me to do this
so I'm from Arizona in the United States
there's me Arizona is a great place this
isn't my picture but I wish it was I've
seen skylines like that though and it is
so beautiful but you know every paradise
has a downside here's the weather in
Phoenix a little warm so we're going to
talk about es6 now starting off
terminology es6 well is it javascript is
it javascript harmony is it what's the
difference between es6 and this ACMA
script 2015 thing well in actuality all
of them are exactly the same thing as we
got going along yes three es5 because
programmers can't count es6 and and we
got to the tail end of es6 and they said
well we want to go on a faster cadence
we want to go on a yearly cadence so
instead of calling it es6 we're gonna
call it ES 20 2015 and the the industry
kind of went yeah so going forward will
have es 2015 yes
2016 and we're gonna call them es6 and
es7 because you know naming conventions
naming is hard so es6 that's what i'll
call it today but you can call it
whatever you'd like
the es6 story on the server is really
interesting as well but we're gonna
focus on the es6 story inside the
browser you've probably been doing es3
for a while es 5 is getting pretty cool
and you open up es6 and it's like the
term that comes to mind is visual fred
remember when we tried to go from vb to
vb.net and we had this big trauma it's
really not that hard and so hopefully we
can get over that move and get towards
es6 so i'm going to kind of break it
into new two major groups of things
associated with es6 there's the new
features of the language which is really
elegant and then there's also new syntax
that makes existing jobs easier now
ultimately we're gonna want to latch on
to this really hard and this is going to
be a theme that we go that we keep
coming back to we're gonna want to watch
on to this and and keep running with
this and and es6 all the things and
that's not it ideally you want to create
create these experiences to increase
legibility of your code so sprinkle in
these features as it makes sense but
don't go overboard and try an es6 all
the things grab a few features as they
start to make sense and implement that
in your code and you'll have a much more
successful experience so new features
and new syntax new ways of doing
existing things under the hood it falls
back to the way where we've always done
it we'll see that with classes in
particular so in the magic question can
I use it today yes but so I'm gonna
click through here to the Ekman script 6
compatibility table and it's really fun
to kind of see well if I have this
browser how much of es6
does it support and we're getting pretty
good except for this one and and and
this one and then we get into mobile
browsers and we start falling off again
so at this point you're going to turn me
off and say yeah that no especially as
we get into 2016 or into other features
we start seeing this support go down a
whole lot so how can I use it today
well let's create a mechanism where
let's imagine a reality where I write in
es6 and I compile to the s5 well we call
it transpiling well you know how is
transpiling different than compiling
some would argue compiling is the
umbrella like unit testing is the
umbrella and then there's little pieces
under it some people argue that unit
testing is one of those little pieces
and compiling is one of those pieces and
transpiling is a different piece for our
purposes transpiling is just taking one
language and moving it to another
language that has a similar level of
abstraction when we come payal we go
from C++ to see or we go from C to
assembly we're going from es6 to es5
we're taking a sideways track is that
compiling ask the typescript guys yeah
we're gonna call it transpiling will
take code from es6 and will turn it into
es5 code and then now because we have
evergreen browsers es5 code does just
fine in time we can take maybe some of
those shims out and just start running
our es6 code more in the browser but by
then will we have moved on the es7 let's
create a mechanism where we can start
leveraging the features that we want to
today and transpiling them into the
browsers that run today so we can
leverage the newest stuff and our users
can still use our sites
thus transpiling so the interesting
about this transpiling is it takes this
toolchain and so you know as we approach
reactor as we approach angular we start
looking at the tooling associated with
using it and that's really unfortunate
because we really like that hello world
where you just open Notepad and you
start typing and you open the browser
yeah that's not es6 world today but as
we dig into the tools you'll see that we
can kind of break that into a really
elegant experience once we've got those
tools under our belt so we'll look at
kind of three groups of tools we have
the polyfills we have transpilers and we
have bundlers transpilers we kind of dug
into a little bit let's dig into it
quite a bit more but let's start with
polyfills cuz that's really fun so
polyfills
let's harken back to the moderniser days
when we were looking at you know jquery
and and those types of realms and let's
use the analogy can I put a polyfill in
here well what was really cool as
moderniser would shim in all those extra
div tags article and nav and it just
kind of made all those tags work which
was great
that was an effective polyfill but could
i polyfill canvas yeah technically I
could have rebuilt the app in flash and
I could have also built it in
Silverlight and now I could you know
kind of shim between them but I would
argue that's not a polyfill that's a
port yeah let's get a few beers and we
can argue that for a while so can i
polyfill i would say if the level of
effort is smallish yeah if we're able to
achieve similar functionality without a
whole lot of effort and in the cases
where that makes sense polyfills are
really easy and at that point let's
polyfill those things into place as
those standards become possible in the
browser as the browser's implement those
features those polyfills can fall away
and now maybe we don't need that
- ml5 MJS the next level is those
transpilers and there's two major
transpilers that are in use today
there's others but for the purpose of
avoiding decision fatigue Babel is kind
of the king pin here and typescript is
really interesting as well
typescript gives us some more benefits
when we're coming from you know c-sharp
or Java and we have that kind of
classical language we're going to focus
on Babel today because it kind of takes
the stance that es that JavaScript we're
just going to take JavaScript at its
core and just enable those additional
features so what's really cool about
Babel if you start off with Babel j/s
just pop open the Babel j/s website it
has a really neat repple a read eval
print loop where you can just start
typing the es6 code and it will produce
that similar code in es5 and so I've got
this experiment I want to do I want to
you know kind of dig into well I can
just sit it here in the repple and I can
play with it and get that experience so
for an unwrap I don't really want to
open up the browser and type all of my
code in there and then copy the the
thing into the other place so we'll come
into Babel's site and we'll click on
setup here inside setup I can pick my
tool of choice and I can pull up the
code that makes that happen so I think
this is particularly wonderful am I
using browserify here's the code to make
it run and browserify all of the
instructions start with npm install
because babel is a node tool so yeah
you'd need node on your box but I can
dig into you know am I using it with
jasmine or karma or dotnet
Jade all of those things then have these
shims to be able to leverage Babel in
really interesting ways Babel will take
our seat our es6 code and turn it into
compatible es5 code so we dug into the
repple that was pretty fun
any questions on Babel before we go too
far so the really cool part about Babel
is that it shims in all of these es6
features by replacing them with es5
features there are some things that we
can't do that with one of the most
notable ones is imports and exports the
module system the module system depends
on loading other files and es5 can't
just say well go load the other file so
we're gonna miss use bundlers for that
purpose we're gonna miss use a bundler
to say go crawl my dependency tree find
all the dependencies package them into
one piece and now i have one file and so
the dependencies are already resolved in
effect we can think of this as turning
es6 code into AMD turning commonjs into
AMD so browserify was the first one that
accomplished this and browserify gained
market share really quickly browserify
is kind of fallen out of favor and
webpack is the one that's taking over
webpack is immensely powerful and option
offers us a whole lot more options
towards transpiling our es6 code and
bundling things and so what i'm finding
is that angular is moving to web pack
react to suggest web pack aralia
is moving to web pack and so I would
argue that web pack won this war so web
pack is really interesting just from the
command line if I just say npm install
dash G web pack to get web pack
installed globally and
you say webpack my source file my
destination file it will do that
translation so in this case we said
let's transpile mange s into bundle GS
it'll go look through main it'll crawl
through all of its dependencies and it
will produce this final bundle well
that's interesting but that's not
transpiling our es6 code well let's dig
in a little further just running web
pack with a big long command line isn't
as much fun so let's create a web pack
dot config GS and web pack dot configs
get immensely large we're not going to
get too big there but here's kind of a
hello world web pack config we have this
entry this starting place that first
file in the command line and we have an
output file name that second one we had
on the command line this is kind of that
hello world web pack where we say I want
to start here and I want to end there so
with web pack we've got that mechanism
to get our bundles into one file any
questions on web pack before we dig into
far
so we want to take webpack and we want
to take babel and we want to mush them
together we want to say hey web pack as
you're wandering through your
dependencies run each file through Babel
and get the es6 to es5 transpiling
goodness so I added another section to
my web pack dot config this module
section and it says hey every time you
hit that that's a regular expression
that ends in dot GS every time you hit a
dot GS file go run it through babel
there's a few more things that i have in
place here I have a babel RC file so
let's zoom into that babel RC file and I
have this presets well babel is really
interesting it said it's this very
pluggable architecture where i can say
well what rules would I like to
transpile in this case I said well
everything in the 2015 spec there's
various plugins into babel let's come
back to that one then i run a whole
bunch of npm installs and now i run web
pack and I've got that translation
process for each javascript file it's
going to go wander through the
dependencies each dependency will get
transpiled from es6 and es5 i'll end up
with a single file when i'm done and i
reference that single bundle JS file
from my HTML code
so we talked about presets let's dig
into that a little bit farther each of
these presets enables a rule set you
know basically a group of rules and
Babel has quite a few of them yes 2015
is kind of the one that we like to focus
on to get from es 58 es6 we can enable
other features es seven features with
the 2016 preset we can pull in react
presets if we'd like and then there's
this group of stage presets that are
kind of fun we can say well for the
various levels of development of these
new draft JavaScript features I want to
pull in that so if I pull in stage 4
that is pretty much everything is done
with that browsers may start supporting
that I want to pull in that rule in my
translation as well stage 3 is more of a
incomplete spec or a complete spec but
browsers haven't done it stage 2 is kind
of a draft all the way down to stage 0
which is like hey I have an idea let's
try this so I can turn on whatever
levels of things that I'd like just by
including these additional presets back
in this babel RC file here in this array
I can just grab those presets so I may
include es2015 yes 2016 maybe i'm
including some react things to get my
JSX to compile or I'll go full hog and
I'll say stage 0 I want to transpile
everything I want a sink and a weight in
JavaScript I want to pull in all the
things so I've got these stages here in
my babel RC I've got this web pack that
describes running babel for each of my
JavaScript files and then web pack to do
that module loading and now I've got
that complete system now I can walk
through a thousand different other
things associated with web pack I'll
leave that to you web pack files do you
get this
so ultimately answering our question
from the beginning can I use it today
yes let's use webpack let's use Babel to
be able to write es6 and run es5 in the
browser today so now that we've answered
that question of saying can I do it well
what can I do what is this es6 you speak
of any questions on tools before we dig
in yep
that's a good question why would I would
use Babel over typescript why wouldn't I
just go full hog and go to typescript
ultimately that's a choice Babel keeps
more towards the JavaScript standards
towards ACMA script where typescript
kind of adds extra things and so if you
want those extra things typescript is
definitely where you want to go if you
don't want those extra things
babbles where you want to go if you want
to look at more of those stage 0 stage 1
things typescript doesn't have those and
doesn't have a way to plug them in so
babble is kind of a better fit there
because I can dig in to more of those
advanced features
if those event features aren't important
and typing is more important typescript
is definitely a better choice great
question yep the tools generate a source
map web pack has a plugin for that and
you just say hey I wanted I specify my
dev tool and my dev tool is the type of
source map that I want to produce and
yes the source map spits out the really
elegant thing about the source map then
is I reference my bundle yes it has that
source map decoration at the bottom of
the file I open up the f12 developer
tools and I am debugging my es6 code but
my browser is running the es5 code and
that is such a magical thing yes source
maps are wonderful any other questions
so we've got this build process we're
now able to take advantage of these
things and we're gonna skim along the
top of these features this is hardly an
exhaustive list but let's let's look at
some of our favorite features here's my
warning again use these things sparingly
because it would be just as easy to
sprinkle es6 over everything and now my
code is completely illegible let's avoid
that use it where it makes sense use it
where your code is more terse more
descriptive the moment you get clever is
the moment you get scary if you I love
this quote my friend Jeremy Clarke code
like the person maintaining your code is
a homicidal maniac that knows where you
live typically the guy coming behind you
that has no idea what you wrote because
you wrote it two weeks ago it's probably
you so code for legibility so variable
scoping one of the things that we love
and hate about javascript is that curly
braces don't define scope curly braces
define curly braces in es5 we have
mechanisms where we can get into this
really interesting place where this
variable exists both above and below
where it was defined is JavaScript
broken some might argue this is perfect
but in es6 we have new mechanisms for
accomplishing this we have let and const
let and const will both pay attention to
the scope of the variables the curly
brace scope and will behave as you
expect so for example we define let
message here in the middle and if i try
to use that message variable above or
below that i'll get an exception as i
expect there's mechanisms of dead zone
where we can get into some
interesting places and you know
ultimately been Scott Ellen's here as we
get into these dragony places but then
the next question is so do I use let or
Const we're transpiling so ultimately in
spite of the fact that we may define it
as immutable it's not immutable haqq
harkening back to our c and c++ days
it's a constant pointer if i point to an
object that object is not immutable and
so I could still start manipulating
adding properties removing changing data
in that object but that pointer is
immutable to that object so ultimately
const is more a communication to our
fellow developers that we don't expect
this to change rather than a hint to our
compiler to unbreak this so I say use
Const when you don't expect it to change
use let when it's data that will change
and that communication mechanism may be
more important than what the variable
what the name difference actually does
ultimately discuss that with your team
find a convention that you like and run
with that let in Kant's though give us
that ability to work through curly brace
cope and find interesting places they're
so fat arrows this is our quintessential
thing that we're so glad that we don't
have to type phungster own fat arrows
federer's are wonderful because it
reduces that function word down to a
smaller piece but it has some side
effects it binds this at the point where
you define it which means you can't
later bind this using like the apply
keyword or the bind keyword it's already
bound it's always an anonymous function
and it has an implicit last line return
if it's a single function single line
that can be wonderful or we learned this
in the CoffeeScript days it can lead to
really unexpected results
so function is not deprecated by any
means for that heavy-lifting where you
really want control over this or you
want kind of a longer experience
function is definitely the right keyword
ultimately decide together with your
team which one you like and pick the
style that works best for you so on the
Left here's our es5 function we had to
type so many characters we had this
three line just to say hey I want to
double this number on the right we have
this arrow function where we just say
hey you know go grab that input variable
and turn it into a doubled result well
that's a little bit magic so let's break
that down a little bit I start off with
my regular function I'm gonna turn it
into a fat arrow function I noticed that
I only have a single parameter that
means that the parentheses are optional
if I had zero or two or more parameters
I couldn't do this so let's pull the
parentheses off the front I also noticed
that it's a single line and that I like
that it's a implicit return single
leiden returns so I'll shorten that and
I got to that result so now setting that
into place I could say array dot map
that really short that really short
function a such that a dot times two and
that makes my code more legible the
intent flows through more so than the
big word that has lots of letters in it
what's really interesting about this
each of these four are valid they're
valid JavaScript lines in es6 so one is
not more better than the other and there
are places when each of these is the
most descriptive thing to use so
ultimately get with your team find the
style that you like the best and
leverage that federal functions can be
really powerful in making your code more
concise but if you just go find and
replace the function keyword with arrows
you'll probably find unexpected results
classes classes are one of these
wonderful but horrid things that
JavaScript has done to us because it
makes it feel more like our classical
languages Java and c-sharp but it still
is a prototypal inheritance under the
covers so use them sparingly but of
course nobody listened to me so angular
and react and aralia all uses classes as
their base construct and they have these
dependency trees and hierarchies I would
argue that if you're inheriting from
something in JavaScript classes you're
on the border of doing it wrong if you
have a deep hierarchy yeah you're
definitely doing it wrong so under the
hood it's still this prototypal
inheritance so here on the Left here's
that prototype where I created the
constructor function how am i implying
that it's a constructor Douglas
Crockford said so yep it's a capital
letter and then I have this dot
prototype where I'm defining things that
is that a class yeah but here on the
right it's much clearer it's much more
concise I've defined a class and I have
a constructor called constructor I have
methods that don't have the function
keyword they just have the name and
they're able to do what they expect
ultimately this and this work exactly
the same which is better I think this
one's easier to read knowing that it
works exactly the same as that one but
because they work exactly the same
they're also interoperable which is
really fun so we see promise is a
polyfill if babel doesn't enable
promises promises can be really really
powerful we're in this callback realm
and we want to move to this promise
realm or we're starting to play with
promises and we want to move to ace
promises give us the ability to kind of
hold on to a result and sequence events
in a much easier way than we had before
so here's a callback pattern and it's
not broken it's just a little weird why
is the first result always blank because
it hasn't aired so should I just ignore
it no here in the promise mechanism I
create a new promise the promise takes
in a function that has two parameters
the success and the fail and then
whether I succeed or fail I call it that
result and then later on in my code I
can say dot then dot then I chain these
dot then functions and I can just walk
through my series of events with dot
then the cool part about this this dot
catch dot catch will catch all of the
things even if it erred in my dot then
callback I didn't get that with
callbacks and callbacks as soon as I
handled the error right here that was
the end of my error handling if this
code failed I was done here this code
could succeed or fail and I would still
fall into my catch here I called it the
success and fail typically we called
them I lost it
resolve and reject and so you'll
probably see that that methodology so
this is one of those things that you
need to polyfill paly feeling a promise
isn't that hard because you can kind of
create a mechanism to call of n you know
ultimately there's like promise a Phi
that could take a callback and turn it
into a pro promises are in browsers for
the most part now so maybe it's not
necessary to polyfill promises anymore
this is one of the only ones that you
kind of have to look at in another way
so all along I'm not sure if you cut it
we have up at the top the thing that
makes it happen thus far it's been
babbled that has empowered all of these
things promises had a polyfill that
enabled it and now modules
babbles purpose is to transpile es6 in
es5
modules is about consuming other things
and so this is where we jump into that
bundler to try and do that navigation
between files so here's that web pack
logo we'll grab our web pack config and
we're really glad that we can do this in
effect we're taking common je s style
code and turning it into AMD code in
command J s we presumed that modules
resolved synchronously and in ACMA
script six
we also Razoo assume modules resolved
synchronously so kind of turning it into
AMD where it could be asynchronous as a
misnomer really it's that kind of AMD
style syntax that's pretty cool we
didn't have this in es5 at all so now we
have this kind of es6 export and import
syntax but we did have it in node so
let's compare nodes mechanisms to es6 as
mechanisms in node if we have this
square function
we'll have then this module exports
object and this module dot exports
object then has various keys
representing the things that we want to
export as I want to pull it in I say
require that library and then I can call
the functions that I've exported in es6
it's not all that different I just put
the export keyword right as I'm defining
each thing yeah technically I could
create an exports like result object but
that gets a little weird
so here I've said export the square
function and then I I'm going to import
that in I'm going to say import star as
a star pulling all of the things
as live I'm gonna rename it to live in
the same way that I called my local
variable and node Lib and I'm just gonna
call Lib dot square to be able to
leverage that library so the interesting
thing is I can import it using a couple
of different ways and I can export it in
a couple of different ways I'm going to
call out default because it's one of
those ones that's a little weird
export default function now ideally when
I want to import it I just want to say
import the thing and so export default
makes it trivial to import things here
when I'm importing it I'm just saying
import Lib from that library so I called
it Lib but they called it square
basically what I said is go grab that
thing marked as default so export
default in node land that would be
roughly akin to saying module dot
exports default is this thing and then
as I require it I say require dot
default in effect it creates a key in
that module exports object named default
so how do I export a function instead of
this object with keys and values you
don't you create the default export that
kind of mimics that instead so how do I
know whether I'm supposed to import the
default thing or a set of keys and
values you open up the file and you go
look or you leverage typescript in
typescript I'll tell you so how you
import it in how you export it becomes a
matter of that contract between those
two files I like to use default exports
when I'm going to only export one thing
or the main thing and I like to use
regular exports when I'm going to export
a whole lot of named things I want to
export a square function and a buy two
function and you know maybe an add or
subtract function if I have a service
that exposes lots of business logic
associated with my class I'll I'll
export all of those things but if my
class only does one thing I'll probably
do an export default to get that thing
pulled in modules are kind of weird any
questions there
so we kicked around a lot of cool things
we're back in Babel land and let's look
at string templates this is really fun
so we've really wanted to do large
strings multi-line strings for a while
and we've built up these things
handlebars is great in defining the two
curly braces the mustaches to build up
these templates of things but it always
comes out turning really ugly so here on
the Left we've got this string and then
we plus equals and my favorite part of
this part putting the carriage return at
the end of the string which I always
forget so now I end up with like lines
and words match together this is painful
it's painful to do that templating and
to walk in and out of am I doing the
template or am i doing code here in es6
I do a back tic and I just start going
and that is my string literal here
inside my string literal there's no back
tic at the end of this line there's no
back tick at the beginning of this line
here's the end of my string right here
and then when I want to get into code
mode I do a dollar sign curly brace and
now it's looking into scope the scoped
Feria Buhl's to try and infer the data
that I want to pull in so for example I
have an A and a B variable here and I
would just want to add them together
dollar sign open curly brace a plus B
close curly brace I really wish it was
two curly braces instead of dollar curly
brace but that looks gorgeous
we have multi-line strings we have
templates and I'm not doing any heavy
lifting of you know trying to get the
carriage returns to fit any more string
literals
next up building objects so ultimately
this building objects is syntactic sugar
for making object construction easier
I've got a whole bunch of properties and
I want to build one object with all
those things well I end up module dot
exports is a great example of this
module dot experts curly brace some name
: that name some name : that names that
that redundancy right there is really
painful well now we can just say the
names and JavaScript will notice that I
have variables in scope that match these
names and pull them in automatically
I've got this really elegant mechanism
for object construction I can also kind
of filter that in with other variables
as I'd like so in this case I wanted an
extra Z variable and I just called it
out so x and y or the ones that are
implicitly pulled out of scope and z is
specifically crafted to be that value
I'm constructing objects in this way I
could also dereference objects
destructuring objects as well so as I'm
D structuring objects I have an object
that has all the pieces and I want to
pull variables out of it as I'm
destructuring so instead of var x equals
CX and VAR y equals c dot y I'll say hey
let open curly brace a whole bunch of
variables in this case x and y equals c
and it will go dig into that c object
pulling out the properties into my
variables so now I have an X variable
that is as I expect and a Y variable
well that's really weird syntax when
would I ever de structure like that why
would I want to do that import so I've
exported a whole lot of things in this
library and I don't really care about
all of those other things I don't I just
want these little things I want
the square function and the double
function and ignore all of the rest so
I'm going to import this library and out
of those things I'm going to pick out
square and double and now I have
variables in my scope called square and
double and I don't care what your
library called them and I don't care
that it came from your library I'm just
gonna do that so a lot of the things
that we see in angular and react and
aralia kind of leveraged this type of
import syntax import open curly brace to
find a bunch of variables and now those
variables came out of that exported
library and I'm using the variable and I
don't need to know which library they
came out of anymore destructuring
objects yep
good call if I'm pulling it in I need to
know what the name of it was out there
so I can't change the name in this way I
could say in this case square as circle
if I wanted to call the square function
circle and that would produce that
renaming artifact great question any
other questions
yep I'm just
it's just a named variable if I were to
flip square and double they would still
represent the same things and so it's
not like the order it was exported is
actually the order I need to import them
it's just pick these things out of that
object that was a great question
yeah they're not ordered so now we get
to order about should they be
alphabetical yeah take that one up with
your team yep
if I don't have the variable do I get an
exception or a null that's a good
question I don't know for sure I believe
that you get a null if you don't find
the variable up in your scope but the
cool thing is it will start to crawl up
into other closures cops so it may not
be in your immediate scope it may be you
know up a few levels so you know
ultimately defining interesting
variables may lead to really interesting
results if you didn't define all the
variables you're expecting that's a
great question I want to go explore that
now
any more questions yep
good question as I'm building my imports
and exports do I need to define them as
AMD income and Jas is that your question
ah good call so I'm building a library
and I want different people to be able
to import it some may become ingest some
may be es6 some may be AMD how do I pull
that off is that right yeah we're still
trying to figure that out and that's the
unfortunate part is that we defined
really well the import and export syntax
but we haven't made a good shim of how
that relates to other things
so in the short brew in the short term
probably what that means is I'll need to
define a different version of my library
for each version of the places where
they want to pull it in and that's
really unfortunate ultimately we'll hope
that this syntax will win yeah but we're
not sure yet and so yeah maybe I have
one UMD version and one es6 version and
that gets me close enough or maybe I
produce three yeah that's painful
so we've got dereferencing objects the
rest parameters I want to have a
variable number of arguments to my
function and I'm left with this
arguments array and this arguments is
not really an array so I do these really
interesting things like array dot
prototype dot sliced called dot I
forgotten what happens after here dot I
copied it out of the last thing and if I
type out it yes I want the rest of the
parameters so I have the three dots and
I have this variable I happen to call it
the rest but you can call it anything
and it becomes now an array of all the
rest of the parameters called to my
function the interesting thing is this
is a real array so I don't need to do
this but shim it into an array also
because I wanted the first two
parameters to be real parameters I don't
have to like pop them off the stack in
my arguments array I can just grab the
rest and I can start to leverage that as
a real array rest parameters we also
have this spread operator so if I have
an array and I want to pass it in as a
bunch of parameters I can take my array
and move it the other way so previously
where I would do apply or call or
something like that to try and get my
array apart into pieces I now just call
the spread operator with these leading
three dots and I'm able to get to where
I need to be now the interesting thing
is you can tell the spread operator is
kind of that more powerful array literal
so for example here in es5 when I'm
trying to take that user input the the
parts and kind of put things before and
after
do I need to unshifted I need to push
first with it shift or was it unput pop
you know ultimately I end up with this
awkward syntax that doesn't really
convey what I'm trying to do here on the
right I've got that parts thing and I
build my lyrics array and I say hey I
want to put some stuff before it oh
three dots and and take your array apart
and put it in place and then I'm gonna
put some stuff after it and I've got
that exact same thing but now I'm
conveying that intent much more easily
so we've got rest and we've got spread
and you can tell them apart because the
rest parameter has those leading three
dots and the spread operator has those
leading three dots oops
can you move one of the dots to the end
maybe that kind of do no they are
exactly the same syntax so how do I tell
the rest operator from the spread
operator well the rest operator is
always a parameter into a function and
the spread operator is always the other
parts so if I have a function
declaration even like an array literal
fat arrow function and I see the dots in
there then that's the rest parameter
it's breaking it apart and otherwise I
have that or the rest parameter is
putting them together otherwise I have
that spread operator that's breaking
them apart yeah I really wish they'd
used a different god oh no plus dots at
the end but rest and spread can be
interesting so ultimately we took this
really quick tour through this es6
syntax I'm gonna say it again
use these things sparingly use this
where it makes your code more legible
don't es6 all the things but es6 this is
now approachable you can use this today
we work our way through babel and also
web pack to get from es6 into places
where our browsers can use them today
and so ultimately yes you can use es6
today you can use it with you
existing stuff and that's what I've got
any questions thanks for coming yep
mm-hm
right
good question is there a mechanism in
es6 to deep copy there really isn't
I lean on two different tools one is
serialize it to json head back now or I
lean on lodash to be able to pull that
off great question thanks for coming by
Twitter is Rob underscore rich and give
me green things we like those</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>