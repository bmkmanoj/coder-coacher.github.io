<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Linux Security and How Web Browser Sandboxes Really Work - Patricia Aas | Coder Coacher - Coaching Coders</title><meta content="Linux Security and How Web Browser Sandboxes Really Work - Patricia Aas - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Linux Security and How Web Browser Sandboxes Really Work - Patricia Aas</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jc7FpkyrOz0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody and thank you for coming
today
I am going to give a very technical talk
but I'm going to have a very untechnical
metaphor going through the entire
presentation so I'm not going to talk so
much about the metaphor so you just kind
of have to learn to it yourself but I'll
just start to off a little bit and the
reason why I have a metaphor is because
sandbox is it really it doesn't really
work as a metaphor for what assemble is
so basically the idea is when you launch
an application on a platform it's more
like if you're planting a flower in your
garden so throughout the presentation
there will be a garden metaphor where
the program is a flower or a plant that
might be poisonous might poison the
ground or other plants might kill
something in your garden and the garden
will be your operating system machine so
what we're going to be talking about is
Linux security and how web browsers the
sandbox is really work and first of all
who might my name is Patricia Wolff and
my programmer I started off my first job
was at Opera Software in 2005 so I
worked on the original opera browser and
later on I tried myself at being a Java
consultant for two years then I went off
and went back to C++ again and I worked
in Cisco for five years being an
embedded programmer or working with
telepresence systems there and now I
started just recently at the Val D so my
twitter is there I will put up links to
the slide on Twitter right after I'm
done here so you can and my Twitter will
be like occasionally on slide so so this
is the plan for today as we'll have a
very short overview on the browser how
it the different processes are and
things like that then we'll have
an overview over the security API is in
Linux and then we are going to look at
how these are used as we launch the
browser and at the end just a couple of
problems that we end up having so first
of all I have to kind of explain which
browser family we're talking about and
most people don't realize that there are
browser families but originally nobody
has written a browser from scratch since
the 90s so all browsers today belong to
some kind of browser family there are
generally four browser families one of
them has been discontinued which was the
one that was in the original opera
browser opera went over to the chromium
blink family for the rendering engine
and so that rendering engines exist
today running Opera Mini so you will see
it if you have an upper mini claim it's
very much used in Africa and Asia but
generally we only have three left and
this is a part of it so I'll just
explain the history of it and the
original browser engine came from KDE
used to power the conquer browser the
layout engine was called 8k HTML and you
had KJ yes for that for the JavaScript
engine and this was adopted by Apple to
make Safari and they branded it as or
they forced it really saying they
wouldn't and called it WebKit later on
when Google decided to make the chromium
browser or the Chrome browser they took
WebKit as it was being published by
Apple so at once every night they would
have a source code drop with no code
revision which was a very difficult way
to work because it was a very big
project and and Google had to deal with
this and so one of the things that they
did in the architecture of chrome which
is very important and this recently
bring it up is that they isolated WebKit
into its own process so for each tab
webkit was loaded in a separate process
and we'll come back to it but that's
called the rendering process and the
reason for that is that they act they
didn't feel they had control of
instability of WebKit
so if WebKit crashed then it would just
take down the vendor process you would
get this dead bird in your tab and you
could reload it it would start a new one
and your entire browser wouldn't crash
and this project was called chromium and
had still WebKit inside after a while
Google decided found out they were
contributing more than anybody to web to
WebKit in to chromium and decided it was
more hassle than it was worth and they
did a fork and they created what is
called chromium blink and there's a lot
of browsers that use chromium blink and
they're in that family and we value the
browser that work for today is one of
them and and the new opera browser is
also one of them so yeah so what we have
now is that we have more than one
process for the browser because before
this generally you had only one process
for the browser in Opera we also had on
Linux a process for the plugins but
generally there was a single process so
now we have multiple processes and then
we can start building the opera
operating system API I had to do all
sorts of things and can be resource
management but in this case they used
this feature of their architecture ad to
implement security mechanisms and the
sandboxing and that they decided to
implement and there's different versions
of the sandbox thing and we'll go
through that later but basically there
are two types of threats that is trying
to protect you from and the one that is
most famous is the external threat
so consider a Java Script that manages
to escape the browser for some reason
for some of the security vulnerability
and in the browser and it escapes the
render process and then can execute on
on the host machine and the idea is that
even if you escape the browser there is
still protection mechanisms in place so
that you won't be able to to do any harm
and you also have an internal system
thread where you might have malware on
your system and your browser contains a
lot of personal information a lot of
sensitive information so a a sibling
program on your host machine being a
minute like a malware or some kind of a
spyware or something trying to mind your
mind your computer they might try to pee
trace your browser processors and might
try to make them crash sure they can
analyze the static memory dump things
like that okay so that's overview on why
so let's start off I'm going to use
without there's an example but basically
the layout is the same for all a
chromium link based browser so you can
look at your own browser so if you look
at the executable files that you will
find in your install directory you will
find a three so in this case we volume
we've already bin and then we've all
these sandbox and by the way it's I have
quite a lot of text on my sites that you
don't have to worry about reading them
as mostly if you want to go through
later on or if you want to read of
course um yeah so the one that sounds
most alluring is the bottom one which is
called the Baldy sandbox right but
actually it's pretty much not in use
anymore and it's used on older kernels
so we won't actually go that much into
it today
so the what is when you start your
browser you started with the bash script
generally it will set up some
environments and then it will launch the
binary so we've already been in this
case but when you start it up
you will see that it spawns a whole lot
of us processes but you'll also notice
that it's the same binary in each case
but with different admin line parameters
and we'll go through this in a little
bit but I'll just want this is basically
one tab open
ok so app we're going to go look at the
startup process because the sandboxing
is created as you start the browser app
so first of all like I said there's only
one binary so all of your processes are
the same binary and it's kind of
important to remember because it makes
the code a little bit convoluted
because you only have one name but they
all have different functions and so this
is part of what we're going to go
through okay so the first process that
started is the so called browser process
when it is when you look at your your
task manager or top or something or a PS
you will not see any - - browser on that
process there is no - - type on that
process is also the the parent or
grandparent or whatever of all of your
processes so it is the the first one an
able general it will fork initially into
two other processes and these will
actually be executed by a command line
so that Li you will pass through main
again for each of those two and then
later add those will fork again to
several more so you have a browser
process it is it is the trusted process
in this family of processes and it does
all of the sensitive things so it will
run your UI it will do your IP C - all
of your other processes it will do your
networking so any kind of network
traffic will go through the browser
process then go through IP C to the the
vendor that's going to render the
webpage and all sorts of things so this
is the the trusted process that has full
access to your machine then you have in
the beginning there's going to be
spawned a process called the cipher
process anyway if you look in PS you
will see that there are two cycle
processes a parent and a child and these
two are going to be in charge of the
parent is mostly only going to be
functioning as a Reaper process but the
child is the one that's going to be
forking into all the via renders so
that's where all your tabs are going to
come from little bit get into it so
don't worry about it so then you have
the render the vendor is basically a tab
or so if so for every time you open a
tab you will generally have a new vendor
these are spawned from the cycle process
in the previous slide
and these have full sandboxing now that
the cycad already has a lot of
sandboxing already in place but this is
the most sandbox process now it isn't
fully sandbox right away it is it almost
fully sandbox right away but it will do
a little bit in the beginning as it
starts up to complete its non boxing
this is before it executes any
JavaScript so you're still in what is
considered trusted code and then you
have that GPU processes now this is for
all intents and purposes one process
it's split for four sandboxing purposes
and we'll look at that but it basically
has one function it is to compose the
final window is the biggest function of
the GPU process because all of these
processes are now creating frames for
all of their different parts of the
window but you have to compose the final
window which is the browser that you see
and the browser you see is an output of
many different processes and the GPU
process is the one that composes all of
these different layers and it will also
generally do anything else that has any
contact with the GPU driver so that will
be things like hardware decoding for
example yeah it has it has some sound
boxing and there's a little bit of a
difference between the some boxing or
the GPU on the GPU broker
but we'll get back to that this is kind
of weird because you will see that you
can that you will have things like WebGL
where you have actual GL commands is
like coming out in the in the web
process but these are actually
serialized and piped or passed over IPC
over to the GPU process which is kind of
an interesting architecture ok so
basically this is what's going to happen
this diagram we're going to get back to
and I'm going to put more and more text
here so we'll just start with the easy
one there is only one binary remember so
all of these blue circles are the same
binary but they have different names and
you can see the names when you do PS so
the in the beginning the browser will
and I will use the term fork though that
doesn't necessarily mean I'm using the
forth system call so you will see that
it says one one-sided force and the
other side uses crone now cologne is an
underlying API that is oftentimes used
to implement fork and in the reason why
we're going to use it because it takes
more parameters it has a lot of
flexibility and we can introduce some
sandboxing as we do the call and we'll
look at that then we have so the first
two processes that we create is a GPU
process and the signup process and then
later on these will again spawn other
processes but basically you can see that
there are basically two families here of
course that's a simplification most of
time that's what you see the moment you
start off with only one tab you'll only
see these processes but there might be
other processes like for for plugins or
other things but these are the main
group of processes that you will see
okay so then we come to the linux api so
these are the tools that we're going to
be using to try to construct the
sandboxing and so if you go to in your
browser and you go to in this case with
Valda colon slash slash sandbox or you
can do the same for Chrome or any other
browser you will get this box here
that's at sandbox sandbox status and it
has lots of cryptic things in it and it
might seem a little bit alarming that
the first one says no but as we'll get
back to the first one will generally say
no on your machine it's because it is a
legacy solution for sandboxing and and
we'll go through what all of these
things mean if you were in Sasha's talk
earlier you talked about bps and we'll
talk a little bit about PPS in this talk
as well but anyway so we'll get back to
the slide also later when we've talked
about these things okay so these are the
elements that we're going to be using so
I'm going to go through them first
because it's going to be really
confusing if I go through them as we
construct the sandbox okay so these are
the ones that I'm going to go through
and there are a few at the end
I will just mention that are also in the
chromium code base but they're not used
on desktop Linux and that's the one that
I'm going to be focusing on this talk so
you have a concept of capabilities
namespaces routing second process
resource limits Yama LS M so first of
all capabilities and most people are
used to on a Linux machine that you are
a regular user or your route
capabilities was the idea of trying to
split the concept of route more into
more fine-grained privileges and so that
you can have as a process to have
certain capabilities but not other
capabilities and that way isolate what
this process is able to do and that at
the bottom I will generally have what
kind of API are used that have this this
concept in mind so in this case it says
cap set and then you could go on your
Linux machine and demand cap set so
basically that's it okay so namespaces
and this is this is very important
because this is the reason why we don't
need the Vivaldi sandbox process and
it's because of concepts or things that
happen around the concept of namespaces
and namespaces and Linux is a way of of
isolating what a process can see so in
this case what the process sees is it
doesn't reflect reality so you can
define in this way how the process
perceives its environment in many
different ways and we'll look at this a
little bit further on and sure routing
is the most famous I think that we go
into those who today um sure routing is
a generally famous from Mac because they
generally form the basis of what is also
called the jail and so you have
jailbreak and then it becomes famous
because it has a good name however
basically sure routing is a way of
isolating the part of the filesystem
that a process can see so it will you
will say that the part this is the
of your file system if you go to slash
you will just go to that folder and
we'll look at that and I use it in a
very cool way and so we'll look at that
at the end it's very interesting um then
we come to second second is a very
powerful API and it it has been
mentioned in a couple of talks I think
here the underlying language for it it's
basically a virtual machine that exists
inside of the kernel and you can pass it
a program and we'll look at how that
works but basically as you can limit
what kind of system calls that the
application is allowed to do and also if
you want them to be allowed to do the
system call if you want them to fail or
how you want them to fail so we'll look
a little bit at that then you have
resource limits it's a little touch on
it a little bit and so it's a way of
basically setting up how much resources
in certain categories that the process
is allowed to have and then you have the
Yama LS m which is very it it there
there's some code around it inside of
chromium but it's basically only checked
so the it will check the status and the
status can be checked in this file that
I've I have the path tool at the bottom
there and basically it says the one is
adequate I think so I won't go that but
I'll say a little bit this it no sir
wrong way that way and this is is
remember I talked about internal
external threats this is an internal
threat sandboxing so this one is trying
to limit that the rights of the
processes have to P trace this process
and P tracing is a very powerful API and
that is used generally by debugger so
gdb so you have massive access to the
running process if your P tracing it's
very low level but it you can do very
powerful things and these are the kinds
of things we don't want any malevolent
program to be able to do so you can you
there's the LS m is for
Linux security module so this is a
specific one and it is mostly around pee
chasing but there's some things around
the hard dancin and soft links as well I
won't talk about that much because it's
not used much it's just checked okay so
other IPS that are also in use and
chromium alright set UID and GID these
are also famous in certain circles
generally security circles because they
have very interesting properties now
these they're not used today but they
are used in the the Valda sandbox of the
process where keep talking about or not
going to talk about but basically it
does something very interesting if
you're running an executable as a normal
user but this executable is owned by
root and it has this set UID or set GID
set on the file then inside of the file
the program can assume that the rights
of root and do root operations and the
reason why this is has been used before
is that namespaces that we just barely
touched on previously you couldn't
create a user name space without
CAPTCHAs admins which is is a root kind
almost a root kind of capability and so
you had to assume the role of root to be
able to do that but in modern Linux is
that's not necessary anymore and so we
will create a user name space without
needing set UID then you have C groups C
curves is very famous in certain circles
again this time in the container
business and because a lot of these
api's that we're going to be talking
about today are also very extensively
used in in containers just like things
like docker
so you will see these things come up
because it's basically the same API so
and Siegrist is very much used in dr2
and it's basically to allocate what kind
of resources that you don't want the
process to have access to and how much
basically so
in desktop Linux is not in use but it is
used in Chrome OS and it's used to
implement some very interesting things
like in docker you know that you can you
can freeze a container and then you can
you can migrate it to another machine
and then they could follow it there and
it just starts up right where it was
okay this is C group
this is secret functionality and it's
using Chrome OS to freeze renderer
processes because they generally
Chromebook start have bad hardware so
this is a way of resource management on
bad hardware but it's not used on
desktop unfortunately so you you will
generally see your browser taking a lot
of resources on your machine so then you
have process groups is used for the
chrome driver which might be famous if
you're a web developer and then you are
using it to run new tests but it's not
very interesting for anything else it's
a way to group processes so you can
treat them as a group so if you put
processes into a group and you kill a
process group then it kills all of the
processes in the group and other things
like that okay so that those are the
tools I'll mention them again as we go
through and so what we are trying to do
is we're trying to execute an untrusted
binary inside of sandbox now this is the
truth truth with modifications as I say
and because the diviner is our own
binary right so we trust that but the
thing is we are going to be executing a
virtual machine in there executing
JavaScript coming from the internet and
God knows who wrote that maybe you guys
anyway the thing is is we are
considering it to be untrusted right so
we are going to be looking for a witness
of opportunity where we can in some way
limit what this process can do or it's a
child process as we go through the
startup sequence so first we're going to
create the initial sandboxing so like I
said in the beginning you have the
browser process is going to do a fork in
a clone
right as it starts up and these are
going to do afterwards you see after the
pink
boxes you will see an ex AK so they will
do an X X which will actually cause the
binary to be to be executed again and
come through main and you have like
you're starting to the beginning and the
way they are distinguishes because you
pass as a command-line argument what
kind of role it's going to take as it
starts up so you're passing two types I
got then it will check that it will say
oh I'm aside that okay I'm going to go
and run so I got main so which is a
function inside of chromium or are the
same for GPU so you'll have a GPU main
um and then there's a lot of words Oh
Moses Moses right now we're just going
to look at what is in black I'm just
going to save right now the reason why
the Texas in black and that's the cap
set you see in that set comp is because
most of the time as you are creating
your sound boxing you are limiting what
your your future children can do but in
this case these are kind of sneaky
because they make sure that they spawn
their child before they do this thing so
so the fact that does the cap set but it
only does that after it's already forked
so the cap set that it does only applies
to itself so the parents like that will
have a capsid done on itself but it
won't apply to the child so the child
will also do a cap set later on but it
will hold on to sysadmin caps assignment
but we'll get back to that in a little
bit but it's basically an explanation of
the diagram and I'll come back to the
diagram so first of all on Linux you
have the concept of a fork x AK it's
sort of like a thing people say and the
idea is a fork will create a new process
and an X I will execute an executable
inside of a process so if you do an X
like you are already in a process and
now I'm using the word fork all the time
because it's a normal word to use and is
also used a lot in the chromium code
base but oftentimes the fork in chromium
will be a clone and a clone is
quite interesting and we'll look at that
in a little bit okay so we're looking
for windows of opportunity where we can
actually limit this new process that
we're creating so if we do the initial
sandboxing we have the browser process
it will do a clone or an Fork and then
it will do an X X so you have many
different stages at which you have the
possibility of limiting these child
processes and but after that the other
other processes will only be using fork
and then you have not so many stages
where you can introduce something so if
we go back again so you have if you have
a fork extech you have before fork at
clone if you using clone before xx so
now you've created a new process but you
have an X idea xx yet and then you have
app startup you're coming through main
again so you've passed maybe
command-line arguments and now you have
the possibility of doing something as
you starting up again but with fork is
basically before and after there's no
laughs no other windows of opportunity
there okay so the initial sandbox
construction and you'll see I'm going to
be writing in the top-left corner which
process is that this applies to it's
just trying to keep it in mind but it
don't worry if you get confused because
I'll bring out the the diagram again and
then you can always look at the slides
so the initial sandbox construction the
most important thing we're going to be
doing here is creating the namespaces
for the side up process because remember
the side that parent has a second child
which has all of the vendors as children
and these are the ones that we are most
afraid of so we're so this is the part
that where we are building most
extensively sandboxing yes
so before you fork or clone you have
basically how fork and clone works in
general is that you have a process you
are going to make a new process
and the four call is basically copying
the entire memory of the process you're
in into the new process and everything
so that states stack everything and
they're on the instruction pointers at
the same place in both processes and
then it returns from fork in both of
them so how you can distinguish if
you're the parent or the child is a
return value of fork so if you are the
child you will get zero back from fork
if you're the parent you will get the
the process ID the pit of the child and
and then from there on you have to kind
of split again because remember this is
kind of if you're only doing a fork this
is fiddly because you have to return you
have a fact right you like you called
stuff so you're up here somewhere and
somehow you have to unwind this stack in
a way that makes sense for both parent
and child um yes then the interesting
thing with clone is that it allows you
to pass a bunch of flags to it which can
define exactly how this this copying is
going to be done where you have the
property of passing Flags where you're
saying that we want to share stuff now
on Linux actually at the clone system
call is used to make threads as well
which makes you see exactly how powerful
this in this system call is because you
can pass things like I want us to share
virtual memory I want us to share file
descriptors I want us so and there's
like a whole set of flags are basically
only used for threads but in this case
we're going to use them to make
namespaces because in general you will
have the child would get get what the
parent had so you if you want it to be
different this is the time so what we
are going to do here is create a
namespaces now this is the first
namespace that we're going to be making
which is slightly described on the next
slide it's called a user name space and
it's really really really important for
everything else and the reason why is
because remember we're starting in the
browser as a regular user
all of the other namespaces require you
to have capsules admin which you don't
have as a regular user you would have if
you were root but you're not root so we
need to become root or become root and
that is what the user namespace will do
it will create a new namespace in which
you will have the role as root but it is
only you thinking you are root in this
case and so in the using new user name
space you will get new P new pits all of
the so you will get pit one and you will
think your pin one and all of your
function calls will think your pig one
kid one but if your outside of this
username space so your parent process
will see your real pit but inside of
this namespace you are root and now you
can do root stuff and that's what we're
going to do to make more namespaces and
one interesting thing in the code
actually around colon inside of a
chromium is that it emulates the fork
because the chrome is clone is a little
bit different by using some long jump
stuff so if you're interested in that
you can ask me later because I think
it's nice and yeah so these are the new
spaces that are created so you have user
Pig and net user will then we need to
become root in the space and then we use
that to make pit and net so you can you
make a pit namespace inside of that pit
namespace you will get pit one so at
this child when it emerges as a process
will be pit one to itself and but not to
but not to the parent so the parents
will have the real world view but the
child will live in this and if you use
containers you've kind of seen this
thing that it's kind of weird like you
feel like you're in the normal Linux
machine but you don't really know how it
works it works by these kinds of
mechanisms and and then you have the new
nest which basically isolates this
process from accessing network and this
is the way so I told you in the
beginning that the browser process is
the one that handles all network traffic
this one else is this one
make sure that this process has no way
of accessing network okay so then we
have before X X and this is last time to
do some cleanup so there is a bunch of
launch options that can be used here to
fix all sorts of things now around
forking and cloning there's a lot of
them file descriptor staff a lot of
signal handling stuff and I'm not going
to get into it because it's like a whole
talk so yeah read the man pages okay so
now we've created the initial sound box
and so we've created the namespaces and
then we've isolated from the network and
you know we've gotten a little bit
further but this is the first psyduck
we've created now but we want to make it
smaller again so then we come to the
second stage and we're going to try to
shrink it even further and so what we've
created I'm not going to talk so much
about the GPU process because it doesn't
use a lot of sound boxing so we'll focus
mostly on the sides out here everybody
will do the distributing trick which
I'll get into in a little bit and it
will create a new user name space again
here and yeah so first you will see if
you trace the process you will see it
calls a lot of of PR CTL with PR SEC no
new prints which Mike you might wonder
what it does but basically it did this
flag is if you said it is preserved
forever you can't unset it and it does
turn off a lot of functionality inside
of the kernel and with regards to what
this process can do especially around
stuff like set UID and such a ID stuff
that we skipped earlier so I'm just
saying it but you have to do this and if
you're going to do set comp which I'm
going to talk about in a second
otherwise you have to have caps of seven
so it's either/or and so this is the
either so we're going to so this is
going to be set before you do second
okay so second what is that basically
you write a program it's a very assembly
like program its installed in so you
create a struct in and has like all
sorts of instructions it's
a interesting program in it it doesn't
have any loops it has a very sick size
the instructions are all six size it
only has an implied instruction pointer
it's a very interesting thing but
basically this program runs in a very
small virtual machine and internal and
it wasn't created for this purpose it
was created for TCP dump and the reason
for that is that you could you for in
you get so many network packets that if
you want to actually filter them you
can't have a context switch between the
colonel and the user space application
for every packet so in this case you can
you could use the BP F which is called
the berkeley packet filter syntax to
write a program to filter the packet you
can say I'm interested in this in this
in this packet and then only those will
be passed to you and so this has to be
very fast because it's going to be
running for every packet right in this
case it's going to be running for every
system call so you're making a program
that the kernel will run when they in
this application or any a child event
child or whatever a process will do any
system call now that if you remember the
the two turtles and there was like the
little box that said the sandboxing
stuff
and it had it has looking and embed so
ii b p st sink and that is the feature
that came a little bit later which
basically said that when you install the
second program that it applies to all
threads okay so in chromium do these
policies because remember this is this
is a white or in chromium and almost in
darker as well as implemented as a
whitelist
so instead of of like listing up all of
the system calls you're going to
disallow instead you say these are the
ones i'm going to allow these are this
ones i'm going to lie depending on
something and everything else you can
crash the application and in chromium
this is implemented in a class it's the
class again is used later on to generate
this program which is then installed but
from a programming point of view or
you're going to be dealing with a class
where there's a virtual function and you
override it in the nurse's switch and
it's very comfortable and you will see
that in the numbered thing down there
it's basically the idea that these are
extending each other now since you
remember that this is a whitelist so if
you're extending a whitelist you're
generally adding more allowed stuff so
the more extended you are the more
permissive you are and yeah so that what
you will see the reason why the GPU
broker process was pulled out of the GPU
process is because it needed a more
permissive sandboxing so it is to is to
be able to have two different policies
in those two processes okay yeah so
cycle parent well I will create a new
name space but in this case it won't
create a new namespace by calling clone
like we did the first time in this case
it will use another system call so
called unshare and that will just take
the process that you're in already and
move it to a new one yeah okay in this
one I like this is my favorite and yes
they're using sure route and generally
you will you should route to make a jail
so you want to make like certain part of
the file system that this process
actually has access to and and I'm sure
most of you have have looked at web
development at some point and you know
that there are several IP is for writing
files or databases or whatnot from web
right but wait but in this case I've
also said that access is generally
coming through the browser and this is
going to make sure that you can touch
the file system at all and I said
earlier about clone that it had
interesting slides and in this case
we're going to use that and clones so
you're in the parents I got and it
clones a child and it clones a child
with the flag clone SS this flag says
that the parent and child will share
certain file system attributes most
importantly it will share the same
chroot and it will share the same
current working directory which means
that if either processor routes or
changes were current working directory
they will change together now what they
do is that immediately after this of
cloning this child with clone FS it
should root itself to a directory which
is process specific is specific to the
child and it should into that directory
changes directory into that directory
and remember these people change these
processes share so both of them are
moved and both the parent and the child
are now in this process specific
directory belonging to the child and
then the child exits the directory is
deleted and the parent is now in a
directory that doesn't exist and has
lost all access to the filesystem which
i think is kind of cool
okay so and then you have the dropping
of capability so that the parents like
that will drop all capabilities right
after forking the child side that the
child psych lab will drop all
capabilities except capsule admin so
that it can use it to create a pit
namespace later on and then you have
certain small things that are done
inside of the vendor like it's using set
our limit to limit the address space of
or the virtual memory of the of the
render process and are then a data item
to to set the maximum size of the data
segment okay so basically that idea here
so you want to make it as restrictive as
you can get away with and the reason why
I say get away with this because this is
an existing technology right it's
sandboxing was introduced in a model
that already existed so sometimes you
have to allow stuff because that's how
the web is but in this case most of the
time they're moving dangerous things
into trusted applications and they're
using IPC to talk to the things that are
untrusted and then isolating the
interests and things as much as possible
um okay I'm almost there I promise okay
so this is this is just an overview
again
we've gone through most of the stuff but
basically all of the processes in the in
the outline part has no access to the
file system
the concept is here is trustees
relatives some processes are more
chested than others but most processes
inside of the chromium space are
untrusted to a certain degree
okay so we're given back to the to the
turtles again and now hopefully you'll
understand more of what it says so you
know that the site view ID sandbox is
all because it's a legacy thing you know
name space sandbox in this case is a
username so name space sandbox and you
know we saw that but in namespaces
Network namespaces to isolate from
network second BPF sandbox to isolate
from system calls and it is all
supported for all threads and that Yama
alyssum will restrict key tracing of
these processes so hey now we understand
what it said okay but there are some
problems and just a couple it's
basically because of the P tracing right
and all sorts of other kinds of similar
thing is now it's really hard to debug
because you're basically saying that a
sibling program is not allowed to touch
this process and now you kind of want to
when you debug so oftentimes you will
turn off sandboxing to do debugging and
crash reporting the same thing we just
said we don't want crash we don't want
to leak all of our memory to some kind
of interested process and now suddenly
we actually do want to do that because
we want to send it back so that somebody
can analyze it and so those things also
become kind of like Sidley okay so this
is what I hopefully cover and remember
out put everything up on LinkedIn or in
LinkedIn and on on Twitter so that's how
web browser sound works is really work
and that if you want to look further
into this there's an excellent course by
Michael Creek which is called the next
security and isolation API so if you
want to just learn that part and that he
also has also written a book the Linux
programming interface which is basically
the Bible if you want to program against
the Linux kernel and then it says
basically a source code Linux
pages stuff like that and thank you so
any questions yes yes yes this is a very
very platform specific implementation
because of the the aps that are
available so there's a whole separate
implementation for for Windows yeah and
for Mac any more question
no okay oh yes sorry the sandbox is
still the same when you debug at inside
of chromium you're basically using the
JavaScript debugger which interfaces
with the VM inside of the render process
you're still good but if we want to make
rouser and you want to actually debug
the browser itself then suddenly it's
very difficult to touch stuff it's time
boxing is on because that was one of the
purposes of sub boxing was to protect
yourself from things like that yes yes
very unfortunate and to have to chase
off if you want to run gdb on your
browser yes
boring
yeah so there's a massive like I could
do a whole talk on the IPC mechanisms
that are you in use and in chrome it's
very interesting actually that's it but
it is it is a massive uses a lot of
virtual memory and stuff to move
information from place to place
serialization of stuff and it's it's a
whole system in itself actually there
there are not that many threads per
process but because generally each
process is taking care of itself so you
generally have that you have the i/o
thread you have the main thread in the
browser but that's more concerned with
running the UI because there are main
threads in the renders that are you
doing the JavaScript so they have their
own processes and so this is also a nice
way of doing separation in that way so
you don't have everybody walking on top
of each other yes yes
yeah anything that will run on the GPU
so that would be shaders and stuff that
you write yourself it will be serialized
through that and it's also interesting
that you can have different versions of
GL on both sides of the pipe because of
the serialization will hide that from
you but it is surprisingly performant
and you probably have already seen that
running your browser so how performant
it is so I would actually like to do a
separate talks just talking about that
specific pipe because I think that's
very interesting how that is possible to
do but it's it generally to protect like
in one cases that you don't want to be
loading the GPU driver in its it needs a
lot of access but but at the same time
also you can now afford for the GPU
process to crash which is kind of an
interesting thing like how do you do
that now you might have seen it happen
yourself well it has to it has to be
possible right and it has to see a
realizin has a deserialize so there's
something in there but I have to say I
haven't looked that much into that code
so that's why I would like to do a talk
on it to dig into it because it's very
interesting I think
available to Java
yeah and there is actually mechanisms
for blacklisting graphics cards so
there's so there's there's a whole list
of blacklisted graphics cards which will
might cause it to fall back to software
rendering yeah so they say it's it's a
it's an issue also because that the
different graphic drivers could crash
and take down your your GPU process so
the this is a this yeah it's a whole
talk again I can do this many times any
more questions
okay well thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>