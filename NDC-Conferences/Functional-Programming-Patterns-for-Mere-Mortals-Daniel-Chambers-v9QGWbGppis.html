<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional Programming Patterns for Mere Mortals - Daniel Chambers | Coder Coacher - Coaching Coders</title><meta content="Functional Programming Patterns for Mere Mortals - Daniel Chambers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Functional Programming Patterns for Mere Mortals - Daniel Chambers</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/v9QGWbGppis" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Daniel chambers I'm making
seniors
alternate ratify my roots our is a.net
developer I've worked on projects in C
sharp F sharp and JavaScript my current
day job has been interesting it has me
writing Haskell and pure script working
in these pure FP languages on a day to
day basis has forced me to confront
functional programming patterns head-on
it's allowed me to look back at C sharp
F sharp and JavaScript and see places
where those patterns occur even in those
more imperative style languages it
allowed me to see why these patterns are
valuable to have in my day-to-day
toolkit and today I hope to communicate
to you what I've learned and allow you
to identify these FP patterns out in the
wild and see how they can make your code
more expressive by reducing boilerplate
the three patterns we're going to look
at today the functor applicative and the
monad so as software developers we know
that patterns are important to our
software architectures and the
maintainability and understandability of
our code bases just like how libraries
enable code reuse patterns enable
experience reuse by basically allowing
us to rely on the lessons and learn from
the lessons of developers who have come
before us developers who understand
these patterns they basically can solve
more problems quickly by leaning on
those that experience of those who have
come before and so if you look at
typical examples from the OO programming
space program is a taught about the
strategy pattern very early on and you
know that solves particular sets of
problems and that those problems come up
again and again when looking at
unfamiliar code patterns enable
developers to quickly recognize what's
going on by identifying patterns in use
and that enables them to understand
original the original intent of the code
very quickly so for example if you see
something visit a class you probably
have a good hint there that the visitor
patterns in use and therefore you're
already 80% of the way there to
understanding what's going on patterns
are also used to hot to hide
implementation details very
encapsulation so software is complicated
and it's easier to think and communicate
big picture when we're using patterns to
abstract away in
patient details for example observers in
the observer pattern don't really have
to care about the implementation of the
subjects they just receive notifications
now functional programming is a very
wide and loose classification at its
looseness definition it means
programming with functions as
first-class entities but stricter
definitions incorporate immutability
constraints many imperative languages
are taking on functional characteristics
as the value of functional programming
is is more and more recognized
functional programming techniques can be
used in mainly object-oriented languages
like C sharp and Java and prototypical
languages like JavaScript and then there
are those FP hybrid languages like F
sharp and Scala which support many more
FP features then at the far end of the
scale we have full-blown functional
programming languages like Haskell and
pure script so many of the basic FP
patterns are useful when doing FP in all
languages some patterns are more useful
in certain languages than others and the
patterns are at their most powerful in
FP languages that support high kind of
types like Scala Haskell and pure script
because you can write code that's
abstract over these patterns and that
can enable some good code reuse however
even if your language of choice doesn't
support higher kind of types these
patterns are still extremely useful non
FP languages have been quietly
incorporating FP patterns so some of
these patterns will actually feel
familiar to you even if you don't do FP
on a day-to-day basis they don't tend to
use the same names for the patterns but
the idea is similar if not the same and
I'll be pointing out these cases as we
go through the patterns so before we
jump into the patterns let's make sure
everyone's on the same page with some
functional basics so we don't leave
anybody behind I'm going to borrow the
Haskell syntax for specifying types in
the talk because it's nice and simple
you can see the c-sharp equivalent of
the the types of the add function when
it's been curried up on the right it's
not quite as nice as the arrow style
that you can get out of something like
Haskell or F sharp so the smallest
definition of a function is one that
takes a single parameter and
a single value carried functions are
ones where the function is reduced to
its smallest definition automatically by
the compiler so in the case of the add
function it takes two parameters but
really after its being curried it takes
one parameter a single input that first
integer and it returns a single output
which is another function that takes the
second parameter adds it to the first
and returns the result so if we step
through it we can basically call the add
function with a single parameter and
that's known as partial application when
you partially apply function we get back
a function that when pass an integer
will add one to it the increment
function so if we call that with a value
of two we get back our expected value of
three another important functional
programming concept is some types or as
they're known in F sharp discriminated
unions as some type lets you define a
choice between different things so a
typical example is modeling the presence
or the absence of a value haskell does
this with the may be type which can
either be just or just if the value
exists or nothing if the value doesn't
exist f sharp has an identical type
called option and they pair sharp uses
the labels some and none so some if
you've got the value and none if you
don't have the value languages with some
types have pattern matching to allow you
to branch between
the different the different labels
depending upon what which one it is in
the case of maybe we've got a pattern
match up on the slide which test if that
maybe val is just or nothing or in the
case of f sharp is some or none another
very typical some type is the either
type which models the choice between a
value of type a and a choice and a value
of type B in F sharp that's called the
choice type so either is often used to
model error cases so where the left is
used when there's an error and what the
right is used if you have a successful
value so the next thing we should
reinforce is the concept of higher kind
of types and the syntax that we'll use
to express them because high kind of
types that syntax is very useful when
we're talking about patterns in and
abstract way so you can think about
kinds as a way of expressing types of
types types without generics
they're just types but when you
introduce generics you change the kind
of a type to be a type function I a type
that takes another type in order to
produce a type and that's why the type
may be a has a kind of type arrow type
because it's a type function that takes
a type and returns a type so if you call
them a B type with int written as maybe
int then you've invoked a type function
and you've just made a new type that's
may be specialized to int high kind of
types is we can write generics code
where the generic type parameters can be
higher kind and that means type arrow
type or type arrow type arrow type and
so on this isn't possible in dotnet
unfortunately but it is possible in
languages like Scala in high school
we'll be using high kind of types to
express our functional patterns but keep
in mind that just because your language
doesn't support high kind of types
doesn't mean you can't use the patterns
and I'll explain that a bit further once
we've covered our first pattern so the
packet that the pattern will begin with
is called the functor but first let's
start by looking at some motivating
examples of some code that we could
clean up and then we'll dive into how
functions work and circle back to how we
could clean up that code by using what
we've learned about functors so imagine
we have a maybe int and all we want to
do is just convert that into a string if
it exists right so if there maybe is
just we want to convert its value to a
string so you can see up on the slide
we're doing a pattern match between just
and nothing if it's just we take the
value out we run it through two string
wrap it back up and adjust and return it
if it's nothing we just return nothing
it's simple but it is fairly verbose we
can do a similar thing with either's so
if the either is right we can take out
the the the integer run it through two
string wrap it back up in a write return
it if it's left we return the left
unchanged
what about if we have a list of intz and
we want to get a list of strings this is
another similar function where we're
recurring through that list converting
each integer to a string in turn and
reconstructing the list now notice how
in all these examples we're transforming
the value inside the structure while
leaving the actual structure alone so
we've got just going to just nothing
going to nothing right going to right
left going to lift and that list
transformation leaves the the length of
a list done unchanged this pattern of
boilerplate code is something that
functors encapsulate s-- and simplifies
for you let's see how that works so a
type that's a functor is able to
transform a value without altering its
structure so the function that can do
that is called map and its type
signature is up on the slide let's let's
break that down so the first bit is
saying if must be a functor then we're
saying given a function that can
transform a to B's and a structure F of
a is the map function will give us back
a structure F of B's now that's all very
abstract so let's look at a concrete
example to help pin this down maybe is a
functor so let's look at how we could
implement the map function of them maybe
we can see the FS and the type signature
now have been replaced with maybe and
what we're doing here is we're just
doing a pattern match on that maybe if
it's just we take the the X out of the
just we run it through the function wrap
it back up and adjust and return it if
it's nothing we ignore the function and
just return nothing now as you can see
map is simply transforming the value
inside the maybe while retaining that
map that also maybe structure unchanged
this is an important feature of the map
function its structure preserving lists
are also functors and therefore a map
function for lists exists we can see the
implementation up on the slide instead
of maybe we're using the list syntax so
in Haskell words the square brackets
around the type so here what we're doing
is we're deconstructing the list that's
the x : x is part the x is the head
the lists the exes is the tailored list
and we recruit recursively going through
that list converting each X using our a
to be function and then recursively just
going through that list until the end
and reconstructing it again we can say
that map is simply transforming each
list element individually but it's not
changing the list structure in any way
that list length stays the same so if we
pass in a list of length two we get back
a list of length 2 either is also a
functor with one crucial difference to
maybe in list you'll remember that
either has to type parameters it it's
either ei right so this means that has a
kind of type 2 type 2 type however F in
map has a kind of type 2 type as you can
see because it doesn't take two type
parameters it's only taking one either
takes a or it takes B it doesn't take
both
but either needs to now this means the
kinds don't match so we can't just
substitute either for F in that
expression it won't work but we can work
around that what we can say is we can
take either E and either E's kind is
type 2 type so we can substitute either
e 4f in that and that's how we implement
that's how we implement map for either
so looking at the concrete example we
can see it's either e a and either e B
so that is fixed so in this particular
implementation it's again very simple if
we've got a left we leave it unchanged
we don't use that function but if we
have it right we take the X out at the
right we run it through the function and
wrap it back up in that right and return
it so again we can see structure
preserving left goes to left right goes
to right we haven't changed the IVA
structure but we have transformed the
value inside it now let's take our
original boilerplate code and use
functors instead maybe into string
that's just a map so all we're doing is
we're taking the map function we're
passing our transformation function
which in this case is our to string so
we have it needs a function a to B in
this case we've got an int to string
function we're passing that in we're
also passing the
in which is the maybe and getting back
out transformed maybe either into string
also just a map list interest ring also
a map so in reality we wouldn't even
have this with interest ring and either
into string functions we just inline the
use of map into the call sites and so we
basically eliminate all of the
boilerplate code that we have up on the
slide and that's a pretty nice thing to
do so let's have a look at another
example and this time we'll look at it
through the lens of some F sharp code so
in this case we've got a function called
get user avatar URL and what this is
going to do is it's going to take a user
ID and it's going to asynchronously
return a URL to its avatar so the
implementation is pretty simple it calls
get user async passing in that ID and
then it uses let bang to get the user
out of the async passes that user in to
grab its avatar ID passes it to make CD
and URL to create that URL and then
returns it wrapped up inside the async
so it's fairly simple code but it is
fairly verbose and we can simplify this
by relying on the fact that async is
also a functor so in the functor eyes
version we can simply use map over the
async returned by get user async passing
in a lambda that takes the user and
makes the URL so remember if async is a
functor we can use the map function on
it so they think we get back from get
user async is async of user but we want
an async of URL so we have a function
that can take a user and produce a URL
that's such utter a to be function and
that's what we've passed is the lambda
to async map so this is a pretty
standard pattern you can identify if
you're doing a let bang and then a
return you can probably replace that
with map instead
so if functors crop up all over the
place if you have a look at c-sharp
innumerable select is basically map with
a different name this means i near
abalzer functors same for observables
tasks and nullable types are also
functors if you care to write the the
map function for them
in F sharp option choice list and async
are all functors the standard F sharp
libraries often have map functions
otherwise you can get them from the F
sharp X project which is an open source
project that adds a whole bunch of
really F P stuff in JavaScript arrays a
functors and you can get a nice
functional style map function from the
low - FP library now everyone in this
room has probably used at least one of
these map functions before so I'm sure
it's feeling familiar the takeaway here
is that more things than just lists and
I enumerables are functors and you can
have a similar style map function for
them as well so I mentioned before that
high kind of types can make these
patterns even more useful on languages
that support them here's an example of a
place in net where you wouldn't get code
reuse because of the lack of high kind
of types but notice it doesn't mean we
can't use it we can't use those patterns
it's just we don't get a bit of reuse
that we might get elsewhere so in this
case we've got a method here that takes
an onion rule of mints and adds one to
each item and convert it to an English
word and returns a results at owner of
also we're using the functor pattern
we're using select which is map if we
wanted to do the same thing for a
observables we would have to
re-implement the the method
unfortunately in high school because you
support because it supports height kind
of types we can write the function once
and it works for all functors so it can
be used for lists for maybes for either
x' for i/o for parsers basically any
type that's a functor we can use that
same function for and that's pretty nice
if you've got it alright so the next
pattern we'll look at is called the
applicator applicatives
are similar to functors however instead
of transforming values inside a
structure while leaving that structure
alone applicative transform both the
value and the structure together so
Before we jump into them let's take a
look at a motivating example of where
applicatives could help us simplify our
code so imagine we have a record type to
represent a person we captured their
first name their surname and optionally
their age we also have a couple of
validation function
so we have one called required that
takes a maybe and returns an either that
represents a validation result so either
a list of validation errors or the
contents of them maybe we've got another
one called integer which takes a maybe
string and returns a validation result
with either an error if the string can't
be paused in to an int or maybe int if
it could be now we want to write a
validation function that takes
unvalidated user input so maybe a first
name maybe a surname maybe an age but
we'll have it as a string because the
user would have typed it in and what we
want to do is return an either with that
contains either all the errors if there
were validation errors or the
constructed person if there were no
validation errors and we were able to do
that validation and make a person record
so the code to write that without
applicatives
it's a bit ugly so the first thing we
have to do is validate all of our inputs
and get back our validation results then
we want to do a pattern match and that's
the case of so what we're doing here is
a pattern match on all of the all of the
validation results and if they're all if
they all passed so if they're all right
we take the the validated result we pass
them into the person constructor we
create that person we put it wrap it up
into a write because we were successful
and return it however if one or more of
those validation results were left then
we fall down into the next pattern match
statement so in this particular part
we're saying okay we don't know exactly
which ones were left versus right so
what we're going to do is we're going to
use the from left function and what that
does is that you give it an either and
it gives you back the contents of the
left
if the either was left but if it was
right then obviously it can't give you
back the contents to the left so it
returns the first parameter so from this
will either get an empty list if there
are no errors or the list of errors if
there were some we could take those
errors and then we use plus plus to
match them all together into one big
list that's just doing this depends we
wrap that up in the left because we
failed and return it so that's how we
can get our either list of errors or a
constructed person
unfortunately it was fairly complex and
annoying for something that's
conceptually quite simple and that code
smells very boilerplate II let's dig
into how applicatives work and once
we've got that we'll circle back to how
we could use a bucket of stew clean up
this code now applicatives are similar
to functors however instead of
transforming values inside a structure
with while we leave that structure alone
applicatives transform both the
structure and the value so for type two
be an applicative it needs to have two
functions it needs to have pure and
apply so let's look at pure first pure
is a very very simple function let's
have a look at its type signature so
basically where F is an applicative if
we're given an a we can basically wrap
that up inside the structure F and
return it now the implementation for
maybe is very very simple all we do is
we take in that X wrap it up and adjust
and return it that's it now let's look
at the other function for applicatives
and this is where the real meat of
applicatives lies the apply function
let's break it down so the first bit is
saying that f must be an applicative
then given a function that can convert a
x' into B's and that function is wrapped
inside the structure F and given a
structure F of A's apply will give us
back a structure F of B's now a very
abstract again so let's look at the
implementation for maybe so we've
substituted maybe for F here
so if we have if we look at the the
pattern matches there we're saying that
if the function we've got is inside a
just and the value of God is also inside
it just we can take the function invoke
it with the value and then wrap it back
up and adjust and return it but here's
the crucial part if either the function
or the value is nothing we return
nothing and this means what we're doing
is we're combining the structure of the
first parameter of the function with the
structure of the second parameter which
is the value right so this is unlike
functor where if we gotta just in we
always return to just if we've got a
nothing in we always return to nothing
and
case if we get a nothing and adjust we
return nothing we transform it into a
nothing and vice versa if we get if we
get a we get adjust for the function and
the the value comes in is a nothing we
just return nothing with and we throw
that just away whatever it was now you
may have noticed that apply they apply
functions type signature looks pretty
similar to what we saw from map from
functor so if we put them side by side
the similarities are even more apparent
right so map takes a function from A to
B but apply has that function wrapped
inside the structure so it turns out
that applicant any applicative is also a
functor so the similarity between those
signatures is less surprising than you'd
think so you're saying well that's nice
but it's all very abstract how can I use
that well let's walk through a very
simple practical example imagine we may
or may not have two strings so we've got
string a and string B both of which are
maybe strings so that we may have a
string or we may not have a string for
either one and what we want to do is we
want to take both of those strings and
if we have them both we want to separate
them with a space so we've got a space
separate function but it takes strings
it doesn't take maybe strings but we
have maybe strings so how can we make
this work and this is where applicative
can help us so we have a combined string
function that uses pure and apply to
effectively invoke space separate even
though we have maybes and we get back a
maybe from that but that's not a very
nice function to read there's too many
parentheses in there something for my
taste and that's because usually apply
is invoked in in fixed position
so in Haskell if you put back ticks
around the function name you can invoke
it like an operator like an in fixed
position as opposed to the usual place
where we invoke a function which is
prefix position when we do that suddenly
that expression becomes way easier to
read so let's break that down and see
how those types click together so pure
space separate is giving me this back
and maybe string to string to string
just so space separate is that function
and remember what pure does it takes
foot whatever you pass it and wraps it
in the structure so we're base
we've taken that function and wrapped it
inside of maybe then what we're going to
do is we're going to use apply string a
and what that's going to do is basically
remember what the implementation does it
unwraps the function that we pass into
first and then invokes it with the value
that's in what we pass in and that's
what's happening here we invoke it and
because it's a it's effectively a
partial application we get back and
maybe string to string we do it again
with this time with string B and we get
back our final maybe string now we can
actually simplify this expression even
further by relying on the fact that all
the placate eaves are also functors
which means we have the map function
available to us so we can replace that
pure then apply with a single call to
map and let's look at the types to see
how that works because that's a bit of a
leap space separate map string a is
maybe string to string now that's a bit
unintuitive so let's see how that kind
of works so space separate is the
function with pasture map so up on the
slide we've got the concrete type of map
and the abstract type of it underneath
so we can see that when we use space
separate a is string and B is string to
string so our F of a which is string a
is maybe string and we get back an F of
B which is our maybe string to string so
that's how we've ended up when we've
used spaced separate map string a that's
how we've ended up with maybe string to
string so the next thing we can do is
call apply string B and we get back our
final maybe string now that sort of
thing is very common when we write
Haskell so Haskell has operators for map
and apply which makes that expression
even more terse than it already was this
takes a bit of getting used to with the
crazy symbols so I'll try to avoid using
them where I can and where I can't I'll
put a comment next to it because it's
much easier to understand when you're
learning when you've actually got an
English word to latch on to
all right so either is also in
applicative and it's it's similar it's
similar it's in the way that it's also a
functor right so we can say the
implementation of apply and pure up on
the slide so when we're for the
implementation of apply if both the
function and the value come in is rights
then we can take that function run it
run it with the value we've got and wrap
it back up and a write and return it
however if we get a left for either the
for either the function or the value we
transform it into a let and return it
but notice how we preference the left
from the function so if both of them
come in is left we hit the first pad
match the left sorry that's the second
statement in the past the second
expression in the pattern matched so the
first left there and we return that left
we don't return the error we throw away
that error from the from the value and
this is this is an important thing to
just hold that in the back of your head
for a second pure is very simple all we
do is we take our X wrap it up in a
right and return it okay so now let's
circle back to our original validate
person function that we saw before that
was kind of gross and ugly Haskell has a
library that provides us the
acceleration type and which is a very
similar to either in that it's a some
type that either gives you a successful
value or a failure failure value that
with some errors similar validation
functions are available if you're
writing if you're writing f-sharp the
f-sharp X library gives you a way to use
choice in a similar way as we're going
to use a crevalle addition here so the
key here is that act validation is also
a functor and an applicative so we've
got the same person record type before
but this time our validation functions
instead of returning either will return
act validation instead and the reason
that we're using AK validation here
instead of either even though we saw
just before that either is an
applicative is that the ACT validations
applicative implementation retains all
of the errors where as we saw before
with either it throws away one of the
errors if both the function and the
value come in as as left's we toss one
of the values
and one of the areas and we don't want
that we want to keep all of our areas
and that's something that acts
validation will do that either doesn't
so what we're going to do now is we're
going to use the the functor and
applicative patterns to compose together
all of these pieces in a very clean and
readable way in order to validate that
user input and construct a person record
or get our back our list of of errors so
what we're doing is we're taking those
three maybe strings and then we're
validating them using that same map
apply apply pattern that we saw before
so we've got our person constructor it
takes a string and another string and a
maybe int and we're basically going map
required first name apply required
second surname
apply into J age and the ACT validation
functor and applicative we'll make sure
that we get back an AK validation of
errors or a successful person and this
code is so much more simple and much
more readable than the original and it
scales a lot better if you have a person
that has more than three properties
isn't as most person people what most
people do have more than three
properties so if we had ten there you
can imagine with the original code how
many how much wider that that that like
Pat match would be how many more lines
we'd need in there with this we just add
more more applies at the end and so it
scales much more nicely it's and it
still stays very readable so applicative
is a bit rarer in the wild mainly
because it's a very functional pattern
and it relies heavily on curried
functions so you'll usually not see this
show up in an imperative language
however it does show up in functional
languages like f-sharp though in F sharp
you need to pull in the F sharp X
library and that adds a bunch of
implementations for pure and apply to
many types so f sharp X we'll call pure
return in and apply app so I put some
examples up on the slide of it in action
so we've got one for option and we've
got for choice and for validation choice
so f sharp x will let you do that
validation thing that we just saw using
the choice type and it is also for async
so let's have a look at an F shop
example for applicatives so let's
imagine a simple function which needs to
load a bunch of data to populate a view
model in this case it loads some user
data a bunch of categories and the
particular item for whatever page this
is and it's using F sharks I think so
we're using let bang to load each of
those things asynchronously in turn then
we're passing all of them in to make
your model and returning it this is a
perfect place where we can use
applicatives to make this code even less
well I can make it slightly less noisy
so the F sharp X library gives us some
operators we can use it in fixed
position so that we can keep that
readability because remember when it was
with parentheses it was kind of ugly and
we can use those operators to use that
same applicative map apply apply style
to effectively invoke that make make
view model function by just you know
using that map apply style and we don't
need to have the computation expression
or we don't need that return and what
this makes evident to us immediately
when we can see that expression is that
there is no relationship between any of
those three async calls they're
completely independent so there's
potential that we could actually run
those a syncs in parallel so if this was
done in Haskell there's actually a
concurrently type that you can put in
there that's also an applicative that
magically makes all of that run in
parallel for us and we don't really have
to change the shape of our code at all
we just use concurrently as your
applicative instead of the original IO
which is Haskell's ish version of of
async now I'm not aware of a similar
thing in f-sharp but I think it'll be
pretty easy to write something similar
so you can just stick an additional type
in there and have things run in parallel
all right so now got a little example of
how we could do command-line argument
pausing and use the same applicative
pattern to compose together different
pauses so I'm going to switch out of the
slides and hop into Adam so this example
is in high school because in this
particular library octopi as applicative
is a haskell library I don't expect
everyone to entirely grok what's going
on in this file because I'm not gonna
explain how the the optimizer
applicative library works in detail but
you should be able to get a general
sense of how
it kind of pieces together and then
hopefully you'll be able to see at the
end where we use that same map apply
apply applicative style to compose the
other bits so what we've got here is
basically an application that defines a
configuration record so it's going to
take some configuration from the command
line we've got an API URI is one of the
things that we're going to want from the
command line we've got a dry run flag so
a ball whether we want to run and try
run mode or not
and we've also got a verbose flag so
maybe you want to do some of our voice
logging we want to be able to turn it on
and off so here we're basically defined
apposite
API URI from the command line so a
positive purgative has this option
function and that what that means is
that we're gonna be configuring a parser
for an option where you you basically
can submit a value so that'll be our URL
that we type in right because it's a URI
and the command line just has strings on
it we need a way of parsing that URI
into into like from a string into a URI
and validating it so there's a paas you
are a function that will do that so
we're using that here we want on the
command line for it to be - - API URI in
the long form so if that's how we're
telling the the library to use that the
meta VAR URI is like a little bit of
documentation so you know when it prints
out the help text it'll say - - API URI
and then you need to pass a URI here and
there's some help text we've got a
parser for the dry run flag so we're
saying this we want we want to parse for
a flag the flag can either be false or
true so if false if you don't pass it
the flag and true if you do the short
form of a flag is just dash D and the
long form is - - dry run and a bit of
help text and we've got a similar
structure for the verbose flags we've
got another paz'
this one will be - v + - - verbose now
we've got this record here that takes a
URI a ball and a ball and and we've got
parses for URI ball and ball but what we
actually want is a positive for
configuration because at the end of the
day we want to take a command line off
the from you know and take our string
from our command line pause it into a
configuration record so we can come we
can basically compose together this
these three parses into a positive that
creates
configuration for us so if I scroll down
here we've got our configuration parser
which is just a composition of the three
previous pauses that we saw using the
same map apply apply so we're taking our
function for configuration so if I hover
over this you can see if configuration
is simply a constructor function that
takes a URI a ball in a ball and
produces a configuration and we're doing
map API URI apply dry run flag apply for
both flag and we get back a positive
configuration so it's the same
applicative pattern that used in many
different situations in this case for
pauses and down at the bottom there's a
bit of magic invocation to positive
asically take that string off the
command line and then we're going to
print out that configuration so I'll
just demonstrate that so you can see how
that works in reality so I've already
compiled this guy so we can go args
example XE and if we pass - - help that
library will print out some help text
for us based on all those parameters we
pass so you can see it we've got an
executable it takes API URI
there's our meta bar and then you can
optionally pass - d or - - dry run or -
vo verbose and I hope text is here so if
I go - - it's a - - API URI and then
pass say local Eddy and then let's say
we want to run in for burst mode we can
see we've got a there's the printout of
our configuration so we've got our API
URI and have a boost flag set of course
we could use - - dry run and we'd have
our dry run flag set and of course we
could pass them some crap in here as
well and it would break so if we just
pass in junk for the URI we're gonna get
a parse failure so that's pretty cool we
can use that same a pattern to do
parsing we can use the same pattern to
you know combine together maybe as we
can use the same pattern to combine
together either's and you know basically
any type that's an applicative we can
use that same pattern alright
so now we probably get to the most
famous of functional programming
patterns the one that for some reason is
told by developer parents to scare their
children into using JavaScript or
something however you shouldn't be
worried we'll see that the big bad monad
is basically just an extension of what
we've seen before in functions functors
and applicatives now you often hear
people describe monads with metaphors
like a monad is a burrito or monads let
you do side effects or monad is is how
you do imperative programming in a
functional language now all of these are
true except for maybe the burrito one I
don't when I get that one but I don't
think you should try to rationalize
monads like that monads are a very
abstract concept that's used for
applying structure applying functions
over structure similar to an applicative
but because it's so powerful it can be
used to do things like side effects and
to do things like imperative style
programming but it itself isn't those
things they're just something that the
monads pattern can enable you to do so
don't try and box it into just one of
those things so first let's look at some
crappy code this is a kind of a
contrived example for simplicity sake
but imagine we have a user ID and we
want to get a user's rolls display name
we've got a map or a dictionary of users
by their ID we've got a map of users to
roles and we've got a map of roles to
string where the string is thatis by
name and what we want to do is basically
navigate these maps in order and if we
can't find a key at any point we just
want to return nothing and if we can if
we make it off make it the whole way
through we want to return the the users
roles display name now you can see the
code that we have to write to do that
we're using our lookup function which
takes a map you can take a key and
return a maybe value so it's the keys
not in the map you get nothing if it is
you get a just in the value and that
lookup codes kind of ugly right because
what we're doing is we're basically
doing a map we're doing a lookup of our
user ID in the first map then we get
maybe back so we have to do a pattern
match we get back the user if we've got
it
we do the next lookup we do a pattern
match we do the next lookup it's kind of
you get that crappy indenting style and
you know if we're getting nothing at any
point we have to do a short-circuit and
just return nothing so
scale well if we need to do more lookups
the indenting gets even worse this is a
sort of code that we can clean up this
is one Wales one other sorts of code we
can clean up very beautifully with the
use of monads so let's dig into them and
we'll come back to this and see how we
can clean it up so the best way to
understand monads is to look at its
function type signature and compare it
to functor and applicative then see how
it's implemented for different types
because it is different for different
types you can see the map and apply
functions from functor and applicative
up on the slide all monads are functors
and duplicative so all monads have the
functions we've looked at previously so
map apply impure however monads go one
step further in that they also have the
bind function so if we line the bind
functions type up next to map and apply
you can see some structural similarities
already so let's break down bind
so we're saying F is a monad and given a
function that can take an A and produce
a structure F with B's inside it and
give it a structure F of S bind will
give us back a structure F of B's now
notice the difference between this and
map and apply map basically takes a
function that can convert from a convert
AIDS to B's applicative so apply will
basically take that function ace to B's
but it will have it wrapped inside a
structure bind takes a function that can
take an A and produce a new structure FB
and this is why it's so much more
powerful than both both map and apply
the function that you pass can return
those new structures that bind will
combine back into that main structure
neither map or apply can do that they
can't combine structures like like like
they can't bind combine these nested
structures like like like bind can so
let's start looking at some concrete
examples here to make that make that
more real there may be type is a monad
so you can see from the implementation
that it's extremely simple in fact this
is probably the simplest implementation
short of pure that we've seen so far all
we're doing is we're saying OK we get a
maybe in if it's just
got a function we run the we run the the
contents of the just through the
function which produces them maybe that
we need to return job done however if we
were if we get a nothing we just return
nothing and we don't use that function
so you can see in the Pat match is just
under school we don't care about that
function we just throw it away
don't use it so given that
implementation let's have a look at how
we can clean up our previously ugly
lookup code with monads and see how the
monad can give us a bit more power than
applicative now what we want to do is
given that user ID we want to do a
lookup and we want to use that user ID
in that first lookup to get the user if
it exists if it doesn't exist we're
gonna get back a nothing so you can see
the code up on the slide we've just
tried to take that maybe and jam it into
the lookup and obviously we get a type
error because we need a user but we've
got a maybe user now in the previous
example we use the pattern match to get
that user out but he would just put it
in and doesn't work map and apply can't
help us here because you can see from
there type signatures neither of them
allow us to pass a function that returns
a maybe and we have a maybe so we can
fix this error by passing lookup to bind
after partially applying the map to it
so see that after partially applying
lookup what we're doing is we're passing
we're passing well the function we're
passing a bind is a function that
matches what binds needs so remember
bind needs an a and it produces an FB so
in this case the partially apply the
lookup user role map is the key so key
is our a and maybe is our F and value is
our B so that matches what we need so in
high school and in and in F sharp to
some extent we usually use the bind
function with its to its two parameters
flipped around the other way so FA comes
first and then amend the function and we
generally use it as an operator and
that's that famous symbol that we've
probably seen before that kind of makes
up the Haskell logo as well so you can
see that once we do that and we have
bind as an operator like this we can get
that nice terse fluent style and you can
see that at the bottom right of the
slide and we've used bind here to join
together those lookups and so you can
keep adding additional binds there nice
fluent way and you get that desired
behavior of either getting your final
result as adjust or getting a nothing if
any of the lookups failed so you can see
that we've trivially added that final
look up for the rolled name the roll
display name map we've added that to the
end and you know that code is still neat
and readable and we could keep adding
lookups here and we wouldn't be I don't
have that indenting problem where it
just gets out of control this scales
very nicely and it's still readable so
bind works for us here because the bind
for back bind for maybe is basically
implementing fail-fast for us remember
the implementation from before if the
maybe comes in is nothing then we don't
use that function we just throw it away
so in this case if the lookup returns
nothing we return nothing and we don't
do any of the subsequent lookup so it
just happens for us that plumbing is is
handled for us by bind and this is this
means we have much cleaner code than our
original indented pattern matching code
now either E is also a monad and its
implementation is very similar to maybe
so likes a functor and applicatives we
need to fix that first type parameter so
for either to be a monad we're actually
saying either is the monad not either
for writes in the implementation all
we're doing is if we have that right we
take the X out of the right we run it
through the function and return it
because remember that function is going
to create the either that we need to
return the left's similar to maybe we
just ignore the function and return the
left and this makes the ELA monad very
useful for modeling error handling in a
type safe way so remember how I said
before right at the beginning of the
presentation we can often use the either
type to model errors so left would be
our errors and right would be our
successful results so in the cases where
we have left's we don't run the next
step we just return the error so let's
see a small example of that and for a
change let's do it in F sharp so in this
example we've got a transfer money
function it takes an amount a from
account and a to account and for what
the very first step we're going to do is
we're going to withdraw some money but
this might fail because maybe you don't
have enough money in your account or
something so it returns a choice which
is F sharps either it's a choice between
either
successful withdrawal receipt or an
error if there was a problem what we do
next is we use bind and we used bind
with a lambda to receive the withdrawal
receipt if it was successful right
remember that bind won't call our lambda
if our choice comes back with an error
so automatically we don't try to do a
deposit if withdrawal failed
so we then deposit some money but of
course depositing money might fail so it
returns a choice as well and we do
another bind to receive the the deposit
receipt and if we get a deposit receipt
then we send a notification involving
all that information of course that
might fail because everything can fail
and that returns a choice so bind for
choice here is basically ensuring that
for each subsequent lambda it doesn't
run if the previous part failed and out
of the end we either get a successful
result or we get the first error that
occurred so you can see that syntax
again is pretty yucky there's too many
parentheses so f-sharp actually has a
syntax sugar called computation
expression that we've seen before but
it's usually used with icing that's the
most common example of it but in this
case f-sharp X can give us the choose
computation expression that basically
gives you that nice let bang syntax but
for the for the choose the either monad
so what's happening here is those LED
bangs exec are actually doing binds
behind the scenes Haskell also has its
own syntax sugar like this called do
called do notation and this has made our
functional code actually quite says it's
made of functional code look quite
imperative again and I think maybe this
is where that that that myth that monads
are for imperative style coding in
functional languages and I think maybe
that's the best that that comes from
that's one thing they can enable when
we've kind of seen it here but a moaner
is a much more general abstraction and
it's behavior depends on how the type
implementing the pattern has chosen to
implemented so the monad implementation
for lists is a really good example of
this it has nothing to do with
imperative programming at all in fact
this is the one monad you've all
probably used without even knowing it
but we'll get to that in a moment let's
first see how whist
be a monad so we can see the
implementation for bind up on the slide
so we can see what binders doing here is
basically recurring through that list so
again xx's is doing that list list
decomposition so we're basically taking
each item from the list and running it
through the function and producing a sub
list which were then appending onto the
recursive call to the rest of the list
right so what this is effectively doing
is going through the list one and for
each item we produce a sub list which
were then joining back together into one
big list at the end and this is why this
implementation bind for lists is often
called collect or flatmap when we find
it in other languages other than Haskell
so what's interesting here is if we
compare what calling map instead of bind
would do to our lists if we use that a -
list of B function so if we if you have
a look at nested lists up on the bottom
the bottom left of the slide we can see
that we've got a function that takes
AIDS and returns a list of B's and we've
passed that to map instead of passing it
to bind and what we're getting back from
that is a nested list of B's if we use
bind instead of map we would get back a
flattened list of B's this is the power
that bind gives you it basically allows
you to combine new structures together
in this case it will combine the the
list of B's that our passed in function
is producing back into a final flat list
of B's right map can't do that because
member its structure preserving so we
can't change the original list structure
that list length has to remain the same
but bind doesn't have that restriction
it can do more and in this case it will
flatten our lists for us so let's have a
look at how monads power async
computation expressions in F sharp this
time it's well we'll do a bit of an
example and D sugar it and start with
our async expressions and do sugar it
down into the binds that are actually
happening here so we've got a register a
new user async function and what this
guy is doing is basically well the first
step it does is it creates a user
asynchronously it gets back that user ID
so if we do sugar that down what we can
see is that let bang is actually a bind
where where the next step is a lambda
that receives that that user ID when it
comes and it eventually arrives they
sink and
so the next step we're doing is a is a
do bang where we're signing that
defaults fine assigning some default
permissions for that new user and of
course a do bang is also a bind but in
this case because it's a do bang the
lambda that we're passing to bind just
ignores whatever's passed to it because
du doesn't do throws away the result of
an async the next step we're going to do
is return our user ID but remember the
the form of of bind up at the top we
have a function that takes an Abe and it
has to return an FB so in this case we
need to return an async but a user ID is
just a user ID aslam an async we need to
return an async if we wanted to fit the
form so here what we're doing is we're
using pure which is called return in in
in F sharp we're using pure to take that
user ID and wrap it up in an async
because remember pure takes a and
returns FB so in this case it's going to
take a user ID and return an async user
ID it's gonna and now we've got a we've
got something which fits the form that
we need to return from that return from
that lambda function so in monads crop
up all over the place
though many implementations don't have
exactly the type same type signatures
we've looked at or and sometimes they
require a bit of squinting to see the
Monad the one that everyone has probably
used is select many from ienumerable
that's basically bind from the list
monad
if you've used link link syntax with two
from clauses that also do sugars into
into a select many and observable select
many is also effectively bind see Sharps
a weight also acts very much like bind
from monad with some syntax sugar a bit
like let bang and actually F sharp has
monads all over the place bind exists
for option for choice for list though
the list it's called collect and of
course we've got async so f-sharp
computation expressions give us that
nice way of writing in imperative style
binds and I think is probably the most
common example where you tend to use
that that style to give you a nicer
syntax and of course you can create your
own custom computation expressions we
saw before that f-sharp X would give us
that choose computation expressions so
that we could use choice do that either
monads
our stuff in JavaScript lodash will give
us a flat map function for arrays and
that's basically bind from list and Java
scripts promises a kind of moan a douche
as well if you squint a bit with then
being similar to bind so now we're
basically going to jump into a little
example of how we can use parses
applicatives and monads all together in
to basically pass someone's phone number
so if I jump out to this code we'll see
how quickly we can nip through this so
basically what we're trying to do is
pass a string from the command line into
this phone number structure so we've got
an area code a number and a number type
where a number type can be Victorian New
South Wales and mobile so we have a
function here that can determine the
type of given an area code so if we give
it an area code string we can do a
pattern match if it's oh three it's
Victoria if it's owed to its New South
Wales and it's oh four it's a mobile if
it's if it's something else then I can't
be bothered writing the code for it so
we'll just say I don't know what that is
so we then what we're doing here is
we're going to produce passes and this
is where if PASOK will give us a whole
bunch of functions we can use to build
parses so if parsec will give us this
map many are so many min/max satisfy and
what this is going to do is produce
produce a possible concern a minimum of
two characters and a maximum of two
characters that must be digits and it
will be and this thing here produces a
positive string where that string would
be two digits right that bit there is
just adding a bit of debugging help code
so it's marking up the posit so if it
fails you get back a nice message that
says this should have been a two-digit
area code now we need to determine the
phone number type and if we don't know
what the phone number type is we want
our parsing to fail so the way we do
that is we use bind so we need to get
out that string out and have a look at
it so we've got a positive string how
can we get the string well we can use
bind and bind will get give you the a
from inside the the positive in this
case it'll give us our string which is a
area code and we can do a match on that
to determine the type if we can
determine the type so we get back a sum
we can do a peer a turn which is pure
and so P return will create us a parser
a successfully parse depositor that will
contain our area code as a string and
our number type put together in a in a
in a tuple so you can see the the type
up here with Basel is a tuple of string
and phone number type now we can't
determine the type then we can just
produce a failed parser so that's what
that does so this expression here is
returning a positive so it's taking in
our a which is a string and returning a
parser of string tabled with phone
number type which may either have
successfully passed or failed now
because we're programming functionally
composition is everything so we can use
that area code pause and make a version
of it which can pause area codes when
they've got parentheses around them so P
char will make a positive that would
pass an open parenthesis here because
I've passed it there so we're saying
here pause an open parenthesis then
pause the area code then pass a closed
parenthesis and these different
operators here are basically saying this
one is saying ignore whatever's on the
left so pause it and throw it away and
then keep whatever's on the right so
that's the area code and this one is
saying keep what is whatever's on the
left so keep the area code but pause and
then toss whatever's on the right which
is the the parenthesis we've then got a
very simple positive parse the main
number so an eight digit phone number
and then we've got our main phone number
passage so you can see from the type
just above the left there it's a
positive phone number and what it's
going to do is create a couple of sub
puzzles so this one the parens area code
is going to attempt to pause with
parentheses so it'll use our it'll try
our first deposit with parentheses and
if that doesn't work it's going to fall
back to trying without parentheses just
the raw area code then we're saying how
about a parser that can parse our main
number but after the main number we
expect the end of strings so that
prevents us from having any crap after
the main number we just we expect that
the there'd be nothing after that at all
and then we've got a function called
make phone number that's going to allows
it allow us to compose together our
parses so we've got a positive which
uses that tupled area code num type so
we've got a parameter that takes that
tuple here and a parameter which will
take our main number and we construct
that record type we saw up the top
containing all of those pieces then we
can compose all that together so we've
got our make phone number function from
here composed with map and apply with
our parens area code Pazza here and our
main number Pazza from here into one
thing which is our parser or phone
number so that's where we're using our
applicative and functor patterns so once
we've got that Pazza we can basically
run it passing in a string and it will
give us back a positive positive result
and if I jump to the entry point of this
application you can see we use that Paz
for a number function here where we just
grab the first argument from the command
line and push it through that Pazza and
then just print it out so if I run this
guy if I switch this sample then here
we've got sick example XE and to this we
can pass a phone number and that will
pause as a mobile number so we can see
we've got our area code a number and our
number type we can put parentheses
around this so it's PowerShell so have
to put quotes if I use parentheses and
it still works but of course if we
mangle it we get rid of one of those
parentheses it's going to fail if we put
letters in there it's also going to fail
if we make it too long that's where our
end of input is going to prevent it from
working and it's going to fail so you
can see how we've used the same patterns
that we've looked at before but this
time they also apply to pauses so we can
use bind from monads and map and apply
from functor and applicative to compose
together our pauses and a nice in a nice
readable way
all right so in summary patterns capture
proven ways of structuring software they
help us communicate our codes intention
through well-known patterns that help us
encapsulate and in kept and abstract
functionalities in in ways that make it
more digestible to for us in today's
talk we've looked at three major
functional programming patterns the
first was the functor which enables us
to transform values in a structure
without changing that structure functors
have that map function which we've all
probably used in its guise as the eye
numerable select function the second
pattern we looked at was the
applicatives which enables us to
transform both values and structures
together we saw that applicatives have
that pure function that enables us to
take a value and wrap it up in a
structure and an apply function that
conceptually invokes a function inside a
structure we saw how applicatives
allowed us to enable allow us to
basically eliminate a whole bunch of
noisy boilerplate code from our
validation example and allowed us to
express the essence of those validation
rules in a nice readable way finally we
looked at the monad and we saw how it
was simply an extension of functors and
applicatives
with a bit more power since the function
pass turbine is able to return a new
structure which bind combines with the
old structures we saw how this very
abstract pattern could fulfill many
roles from unfolding lists with select
many to doing failure handling with
maybes and eaters to doing asynchronous
execution with c-sharp tasks and F
sharps async so hopefully now you've got
at least some understanding of these
three patterns and can identify where
you might have used them before out in
the wild with your new understanding I
hope you go off and explore more about
these things because once you become
familiar with them you'll see that there
are many ways you can use them to
improve your functional programming code
and eliminate boilerplate replacing it
with expressive readable code that more
clearly expresses your intention if
you'd like to learn more about what
you've seen here today
I'm totally gonna hand boyyou to Scott
lation who's got his functional design
patterns talk at 1:40 p.m. so I think
that's straight after lunch
Scott is a really good speaker so I
highly recommend you go to
talk squad also has a website called
f-sharp for fun and profit which you may
have been to before and he's got an
article up there called map bind and a
play it's a series of articles and so if
you want to learn more about what you've
seen here today
and you probably you know probably need
some time to stare at those types and
let it sort of settle that's a good way
to do it if you need a more visual way
of seeing how the either monad works his
railway oriented programming talk with
as a video up on his site that's really
good
in fact while you're honest like you
mail or just read everything because
it's pretty good stuff and if you're
looking for a textbook to help learn
I recommend the Haskell programming from
first principles textbook I will warn
you it's very slow and methodical it
starts from the basics but because it's
slow and methodical it doesn't have like
a ridiculous learning curve we just get
lost
it holds you by the hand the whole way
and by the end of the journey you will
be a god among functional programmers
and monads will just be like some cereal
you eat for breakfast in this just like
second nature so thanks for listening
today I hope I haven't melted too many
brains in the room so if you have any
questions
I think we've do we have any time we're
just a little over so I'll let you run
off to lunch and if anyone wants to ask
a question come and check to me
afterwards all to stick around for a bit
thanks guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>