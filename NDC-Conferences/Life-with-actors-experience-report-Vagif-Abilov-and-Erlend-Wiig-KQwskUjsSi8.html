<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Life with actors: experience report - Vagif Abilov and Erlend Wiig | Coder Coacher - Coaching Coders</title><meta content="Life with actors: experience report - Vagif Abilov and Erlend Wiig - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Life with actors: experience report - Vagif Abilov and Erlend Wiig</b></h2><h5 class="post__date">2017-02-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KQwskUjsSi8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">testing testing can you hear me good
welcome to
if it's life food actors will be talking
about
a kebab nut mostly and a project is an
experience based report so it's a
project that's been running for I think
just over here which will shows you some
experiences during this project but
first let's introduce yourself who are
you good morning my name is Val Eve I'm
originally from Russia as you can see
from these Cyrillic letters they have a
league in living and working in Norway
for quite many years and last few years
working with some interesting projects
at NRK it's a Norwegian Broadcasting
Corporation
I'm consultants working for a company
miles and in this last project I've been
working together with Arlen yes and this
is me I'm also mainly background in
c-sharp
but recently 12 last few years I've been
doing F sharp a lot and this is as you
can see all the text here you can't
really see but it's a ma award which I
haven't won but I I could take the
picture at least it likes before a
children's show that we produced at NRK
and this is an RK as I said it's sort of
the BBC equivalent in Norway so Republic
podcasts are owned by the state or the
government and we are funded by the
people and this is a picture from our
first live TV broadcast in the middle
the guy and the shot I think it's it's
the first is the king is king olav the
guy on the far right is the Prime
Minister is called Kate Hudson and the
reguar next to the Prime Minister is the
third guy and it was before fake news so
the whole thing is real yeah we can't
really you haven't found out who the
third guy was he's he's like the third
guy on the Apollo 11 mission along with
Buzz Aldrin and so a short timeline like
we said the first ball cost TV broadcast
was 1960 but we've been around doing
radio since 1925 eight years as a
private company and then it was
in 1933 and today we have over million
programs in our database which is cool
but due to rights
mostly around 120 hundred and thirty
thousand are available at any given time
and that's combined TV and radio and our
product looks like this at least on an
iPad of course we have multiple
platforms Apple TVs and so on as you can
see it's a modern web player and we are
our main competitors our Netflix in the
Norwegian market and YouTube and so on
all the Giants from America and this is
our system this is our system as you can
see we've been very creative during this
trying to create this talk we've been
drawing a lot in OneNote and our project
is the square box in the middle here the
e stands for distribution engine and
that is our project we take some
programs from internal storage and we
distribute them to the cloud that's been
Akamai and on the far back and you can
see that a program is typically made up
of five files which are encoded in
different qualities ranging from 720p I
think it's the highest one to a very low
quality hundred and eighty P so that is
the project a lot of files shred state
parallel processing parallel uploads
yeah we try to distribute things as fast
as possible and that's where parallelism
comes into play and that brings us to
the point why we needed to do something
with it because as Alan said we actually
started doing it from 2012 so actually
we have working stable system so but as
you saw with a lot of files processing
parallel then it's a lot of thread
manual thread management it's a lot of
state locking state management so the
large the old system was really hard to
maintain because it was not many domain
related things
mostly thread and state management so
then we started looking and different
programming models which would simplify
our work so it could get rid of all this
and then we found that actor model and
particular actor dotnet since we are in
dotnet was a good fit and in the rest of
this talk we are going to talk about
primarily about main lessons especially
my lessons for us as developers is
object-oriented background who considers
himself or herself developer with
object-oriented background yeah I guess
majority so so what are we lost majority
yeah
which leads us to again a simple drawing
our existing system bog if mentioned it
is a system written in written in
c-sharp fairly well written four years
ago five years ago but we've mentioned
we had quite a few issues around
threading and it was spinning up of
multiple I need to do multiple uploads
there was a big pasta torii of tasks so
I had to lock the repository and make
sure you check in some tasks and check
them out and there was also the green
one is the database a lot of the state
was actually kept in the database with
various amounts of flags so this is a
typical software development story if
you want a new feature you add a add a
flag in a database which leads you into
trouble so you wanted to get rid away
from these horrified monkeys design
goals to get rid of where did you find
this picture yeah so we wanted to get
rid of the man actual manual handling
state of threads I consider it a bit
like memory management you want to get
away from it as much as much as possible
at least in general programming models
and and in for some more of a strict
mutability and what did you use f-sharp
basically and more a functional approach
since this is a very back-end driven
data transformation type of project the
C sharp implementation was was trying to
do it functionally but but
a functional language is better at doing
it functionally so we ended up with
these two choices
acha dotnet and an f-sharp and I think F
sharp which was the obvious choice for
us as we've recently become quite big
fans both of us and in different
projects so it's become more or less the
default language in our team that was
easy I thought that was maybe not that
of an obvious choice but we read some
stuff about the actor model and I
thought it could help us isolate some
state around these uploads around these
programs we maybe can model each upload
as a as an actor and by the way who had
no experience with F sharp please don't
leave the room yet because our main
lessons there about programming model F
sharp just an imitation language and
there will be music at the end so you so
you have to stick around for this it
will be worth it so how to introduce
actor model in just in a few minutes the
best probably you should find the proper
picture and of course when we started
googling welcome our model this is the
first picture not diagram we found and
actually in some presentations actor
model is illustrated with their picture
of fabula which was completely
unacceptable for me because I have in in
our family fibre this is my father so we
couldn't use that picture father instead
we'll focus on the actual description in
a few slides how actors and actor model
work yeah this is a diagram showing the
actor or one actor this is an actor
several actors actually an actor is
simply a message loop and for your left
you can see you interface with an actor
by sending it a message that message
gets put on on a cube which we usually
refer to as a mailbox and it's important
to note that one actor has its own
mailbox so they're not these queues are
not shared among actors every actor has
its own mailbox and when a message gets
puts on the queue direct actor starts
reading
the message one at a time it's also very
important to remember so you so it has
to finish the message before you can
start anything else and as you can see
that one message at a time and also just
messages can an actor have a state which
is visible for others no it controls its
own state so it's not like an object you
can't access the property and so you
have to send it a message if you want to
ask it something then you ask it by
sending a message similarly when we talk
about actors we also refer to an actor's
system or an actor hierarchy this is
very simple iteration system is a
namespace we think of research for
logging and some operational things and
space you use mostly is our user space
where we create our after you create a
hierarchy parent and child and the
provision and someone will will come
into that later because the hierarchy is
quite quite important on this slide we
try to illustrate that just because it's
a hierarchy doesn't mean that you only
can pass message to your children or
your parents you can actually pass them
along any way you want actually you can
obtain a reference from the lowest level
to the top level actually whether that
makes sense is up to you still have to
be intelligent when writing these
message flows but but there's no
inherent thing stopping you from passing
messages all through the hierarchy but
actors are quite different from from
objects in what way
what if yeah for us it was a big change
of perception how actors work among the
objects objects they don't have a really
embedded notion of threads when they do
those things so objects are bags of
properties you can give them human
readable names you can call them Pete
and Mary but they can be easily bullied
so anyone who has a thread can access
public methods of public properties and
start changing objects so and then we
say the object is not thread safe if you
can't
do changes to it through multiple
threads and that's of course a big
problem actors they don't own threads
either continuously all the time but
what's different is that an actor when I
like to get the message it borrows a
thread and whatever he does to it state
if needed it's just its own sole
responsibility so if actor changes the
state it's only that actor that changes
the state that makes it much easier to
debug actors in case you have some
problems with that
so no shred state no threading that
makes it very very different and very
applicable to this enterprise system
with a lot of parallel processing yeah
this is a simple this is actually C
sharp example which we wanted to show as
we mentioned it will mostly be showing
examples in F sharp but let's look at a
very simple implementation in ships C
sharp it's a class it inherits from
receive actor it's as a constructor and
it has a receive method that's quite
important so receive is like well in
JavaScript like an on receive message so
when you receive the message of type
user message then you do something
there's a lambda expression here just
doing very simple logging in this
example and similarly an example is in F
sharp is a bit more alien to you perhaps
there's some stuff going on here there's
bangs and stuff and there's loops and
yeah but in essence it's the same thing
we're getting a message on me the main
lesson is the same thing it's a
continuous loop asynchronous receiving a
message from the mailbox receive message
it's prints printer found prints the
message and returns the loop and tries
to receive another message let's look at
a bit more interesting example that's
something more interesting from
operational point of view because this
is an actor which implements a simple
state machine FSM
so it it has two states disconnected and
connected and each state is managed by
so called
function because then F sharp everything
because this function you tried to use
only functions with that so this is a
function which takes messages and then
it reacts on message Connect and then it
creates connection and then it goes to
another state which is also implemented
using another function connected in
connected state we only respond to
disconnect messages otherwise otherwise
we yes we do respond but we Jung don't
do anything we stay connected so you see
it's very declarative we have States
presented as function and also it's
quite declarative like what messages
respond in every state and of course we
need to specify what is initial state of
this actor is disconnected state so
these constructions we use quite a lot
in our project and it's really easy to
read it's really easy to maintain yeah
is remind you of the agenda we'll finish
with our introduction now and we'll move
on to the main lessons and by starting
with tell don't ask yeah that's the
first main lesson probably far the most
important lesson that we learned because
when we started with active model we saw
that akka has two methods both looks
very convenient tell and ask you used
tell we just send message to another
actor and you ask when you send message
to another actor and you don't do
anything else until you get a response
let me so that's the best of two worlds
let's use them both of course we try to
use most detail but in case we need
answer now we just wait first of all
that breaks reactive software principle
because when an actor is waiting for
response it's actually consuming CPU
it's in it's consuming a thread but then
what if response never comes and this is
not fine and this is frightening picture
it shows actual number of hours which we
spend debugging such actors waiting for
respond that would never come and I
probably should have specifically bad
conscience because I'm external
consultants using these hours
but there is more than that the
performance of aspiration is just
horrible
and let's have a brief look why so will
this machine the small machine with into
i-5 to run some tests and just for the
reference the fastest thing you can do
of course is direct method invocation
and then you can call a method about 300
million times a second on this machine
and all other operations which we tried
so much slower we decided to remove this
from other slides otherwise we wouldn't
really see the real thing so when we run
two actors talk to each other just
sending a message to another actor is
also pretty damn fast
it's three million about actually about
four million on this machine messages
you can send from actor a track to B
which is approximately approximately 10
times faster as using a sing a wave if
you use tip a library but if you use ask
before most drops dramatically we're
only about hundred fifty thousand
messages so it's really horrible
performance if you want a long answer to
that you should read the blog post
written by one of a cadet contributor
Bart Asha Petrovski
but in brief the ask implementation
internally is actually quite complex
because everything is message in actor
model so let's say an actor a sends a
message to actor B and then it needs to
get a message back immediately before
processing anything else so there is a
message coming its way
if message is received in the regular
mail box what if there are other pending
messages that needs to be processed but
it can't it needs to respond to get
message the response first so we either
need to rewrite implementation of
mailbox which is starting not sequential
or we need to do something smart and
both creators
acha acha Scala and akka dotnet they did
alternative resolution to that so
actually they create a third actor with
the sole responsibility for waiting for
this response and delivering it using
kind of
priority delivery to the actor a so you
see three actors are involved just to
get response back which of course makes
it complex and makes it slow so what if
you really need a response from actor
and you can't do anything else until you
get a response what works very well
actually is implement so called
integration pattern where you add simple
finite state machine to your actor which
actually brings it into a waiting State
so you can wait for a response
staying reactive let's see how it can be
implemented first the region employment
a shin you have an actor that receives a
message and if you see the message
process item it needs to fetch some more
details and here it's old implemented
it's waiting for response this is an F
sharp ask method get item details we are
waiting so we are in hands of this other
actor and we still consuming CPU how can
we rewrite it
let's introduce now simple FSM we can be
an idle state and if we get the message
process item we just send a message
straight get item details and we enter a
new state awaiting details and we
actually go to sleep until we receive
the response in this new state if we
can't process incoming message then we
stash it that's a function of akka so
you can stash messages in some
intermediate queue until you can do
something with them stay in your active
once you get this new message you get
these details and send them to
interested party and un stash messages
that have been waiting so this gives you
actor very scalable and reactive and no
longer you have this synchronous loop
waiting for responses and if you look at
performance of this it's actually not
that bad of course it's slower than tell
direct single message between two actors
but it's actually several times faster
than using TTL
yeah this I think does yeah TPL so this
is our preferred way of implementing
bi-directional communication now in our
system of course we still use us in some
cases but this is mostly some system
calls some calls to active system like
asking for reference for an actor
wearing persistent actor we'll be
talking about later so mostly our system
now implementing using the
unidirectional messages and that brings
us to the next important lesson probably
the second of its importance Octus
provision yeah let's look at actor
supervision or I wrote handling as it's
as it is actor or other handling in a
car is quite a bit different and in
c-sharp or look at that it's we try to
get away from handling actors in a very
small local scope and we try to do
supervision on top of that and say fail
fast and easily down here but take care
of care of it up here so we actually
have another example in c-sharp it's
true remember that but this is a example
trying to connect database of thing and
what do you do in c-sharp well you slap
the try-catch around and they come on
you want to execute of course okay
probably a lot of you've done multiple
times in this case we are not doing very
much we are just wrapping it in some
sort of custom exception which is very
nice and nice an enterprise I think it's
not good enough there is not good enough
we can do it even more Enterprise e we
can catch multiple exceptions there's
probably I can't remember how many
exceptions that connection is able to
throw but I guess is approaching double
digits and how many different argument
exceptions and all these kinds of
different exceptions but what's
important here you can read in the code
or in the comments is what what do you
actually do inside these
catchers do you just log the idle and we
throw it and hope that some other being
on top catches it what do you do if the
connection is shared among a hundred
different methods how do they recover
when the connection is suddenly dropped
how about the threads how are they able
to to stay on top of this it becomes
very difficult and we'll just have to
reference this other article paper which
is very good and explains it isn't quite
quite a good detailed they're very
sticky situations you can get into with
the control flow when you try to handle
these others locally particularly in
more modern parallel paradigms so let's
start trying to explain how I did it in
in aqua dotnet and this is a very simple
example of our interface which deals
with reading messages from a queue not
the internal actor queue but external
queue like rabbitmq we use RabbitMQ lots
so this is command as you can see it to
connect to the queue you have to connect
of course and once you've connected then
you have to subscribe to the actual
queue name and or give give an actor
that's supposed to receive the message
after you've you've read it off the
queue and the implementation looks a bit
like this as before that's usually
mutually recursive function and an FSM
that's deals with transitions between
all these states but off but I'd also
care always not just in a c-sharp code
it will probably the database can go
down mean there's no magic in functional
programming that you won't lose the
database so and you have to handle that
error and then okay that is dealt
through a supervisor strategy so a
supervisor is the parent of the child so
as you remember
earlier we had a actor hierarchy and the
parent house is when the heir apparent
creates the child it's also a sort of
responsible for that child just as in
real life and what happens when an
exception occurs in the child then
depends on the on the strategy and the
strategy can be applied just to the
failing child so if the child falls down
it breaks its leg you take the child to
the hospital or maybe retort to yourself
and you fix the leg I'm not sure I
usually take my into the hospital you
could do the same action for all your
children so if one falls down you take
them all to the hospital
I guess might make sense be the only
child in my family I find this not fair
strategy it's nice to go to a hospital
but so you can choose just hand the one
message or maybe it's just a that child
is part of say a hundred workers doing
the same job and it all need to restart
them for instance because what you can
do there are four types of things you
can do you can just restart the actor
just say oh exceptions that's bad
try again and that's default that's you
don't find out this is what will happen
yeah or you can resume so we have the
mailbox and one message fails but that
doesn't doesn't really matter maybe it's
a video stream so if you lose one frame
that doesn't really matter so you can
just keep on processing you could
actually just stop the actor give up or
you could really go give up and just
escalate the whole other to grandparent
yeah
so grandparents or who always know
better government or supreme being of
some kind and this is a simple example
again the strategy as you can see it's
one for one so this is just the one
actor and here we can also be quite
enterprising and catch all these
different exceptions and do different
jobs depending on the exception but what
is important that this strategy
definition it replaces all those
around try caches everywhere so you
define within one place typically on
parent level in case parent encounters
these types of problems what needs to be
done to after stop it can see a resume
it and so on so no no more this logic
inside the catch that is true and let's
be really explicit and just show you
what actually happens the exception
occurs the exception gets thrown so it's
and it's it suspends the run time like
actually suspended the supervisor get
note gets notified supervisors then gets
rid of the actor but what's important
here is that the supervisor gets the
mailbox so say there was a thousand
messages pending on this actor and one
of them's fail the apparent gets the
other 99 or the whole mailbox actually
and can we instantiate the actor and
give it's all its messages so you can
just try again and what we realized with
our implementation was it was quite I
think it was a very strong
implementation basically it's very much
modeled after the c-sharp API what what
happened here is that when we you
restart the actor it gets the mailbox
yes but it doesn't get the message just
replayed that made it go into a certain
state so in our case when we first
started up an actor you have to actually
send it a message to connect and then a
message to subscribe when it gets
restarted it gets into a blank state it
receives the messages or the mailbox but
it's not actually in a state to be able
to process the messages so we had to
inject those doing similarly to
dependency injection after actually have
to send in functions or messages that
makes the actor able to start working
right away so we could get rid of a lot
of the API making it is a bit less
explicit
and we ended up with this now it's just
a one function and on the top you can
see that we send in in the constructor
or in it's called pops in properties we
send in the actual details of the queue
so the address of the queue the name of
the key you should subscribe to and also
the subscriber the one that is going to
do the next step in the in the pipeline
and if you remember the first
implementation it can had three states
disconnected connected subscribe but it
doesn't make sense to create an actor
disconnected it should be as operational
as possible so just not just one state
and we try to send anything that we can
to make actor up and running in cases
we've restarted which takes us to the
next lesson which actually was not
essential reason for us to choose actor
model we read about so called persistent
actors but we thought it will be nice
addition to regular database because in
every back-end project you need to have
regular database and after a year of
development we can be proud to say that
that was a year without creating tables
without writing out the table everything
all our persistent needs solved by so
called persistent actors which are
implemented using so-called event
sourcing principle so an actor receives
commands or messages and they all can be
treated as events and if you need to
play them back if you take care of them
you can do that so the persistent actor
is the one who actually stores all these
events in so called event journal so
this are all events that happened to
this actor for performance reasons for
optimism you can also have snapshot
store it's a typically another table in
your back-end where you can store some
stage periodically so if you want to
play it back you will play back quite
fast so this example of persistent state
that we take care of we deal with file
distribution so in our
system we need to take care of locator
when in the cloud file is located
storage provider its CDN path and so on
this production code is not yeah it's
actually it is from production code and
these are four commands that we send to
our persistent actor we can assign
locator we can remove locators that's
the only case we'll use ask actually
query locators I said earlier that we
still use ask for querying persistent
actors and we take snapshots for
efficiency reason and there is a wide
choice of backends for I could net we
using Microsoft sequel server just for
reason of maintainability and operation
because at NRK
there's a lot of competency and
good operations around microscope server
you can choose anything that you would
like to of course MongoDB or even events
store it's not listed here because it's
not officially released but you can also
use that and just for curiosity that
this is how event journal table SQL
server looks what's important that you
must have global unique persistence ID
which is up to you to assign it has
sequence number so it will be played
back using the sequence number and of
course the event content is here its
payload but again this is something we
just copied from github and apply to the
database we didn't do it ourselves and
being back-end developer for quite a lot
of years I must say that that was not my
most creative time I've been doing in my
life creating and altering tables and
just focusing on the main tasks and
outsourcing to preset actors was quite
quite a relief and then next question
about how less than about yeah it's
about scalability so which leads us back
to this actor hierarchy and one of the
main advantages I think of implication
is that it's very easy to create a lot
of parallel tasks or sort of worker
thread
there are not threads there are actors
but they are if you have a task that's
supposed to break down something maybe
something you can easily split them up
to ten jobs or maybe hundred jobs or
thousand jobs it's very easy to create
that parallelism in our cabinets it's
that done through routing which is
similar to supervision is defined on the
parent level do you define how the
messages should be distributed among
your children and you can do that in
several ways there's round-robin you all
know this
it's just evenly distributing them you
could do the smallest mailbox and say
the one that doesn't have much to do you
should get the message it doesn't take
into account stashed messages so you
might run into some trouble there but
the one that we have been using a lot is
consistent hashing where you give the
actual router a function saying based on
this hash you should drive the message
to this and we use this for the separate
programs as I mentioned we have a
million programs or a hundred and twenty
thousand active programs and each of
those programs are separate actor based
on the hash which is based on I think
it's the unique ID and some other
characteristics here so this example
shows you the very basic creation of an
actor so this is just creating one actor
exactly you might upload actor is the
actual function and it has some drops
properties yeah and this one shows a bit
more code but this is actually all you
need to write to create its limit here
somewhere I can't remember or you can
put everything in configuration it works
out yeah well it's limited by some free
configuration but I think we have a lot
at least 100,000 different actors will
create it on the hash function which is
the Akamai uploader get hash base so
that returns something which uniquely
identifies your actor and then every
other message that could post into this
parent actor and gets routed to the
correct child that prevents same files
be processed by parallel actors
simultaneously and what and what
probably what's important if you go back
one slide that this act doesn't know
about it is configured so now it's
running in hundreds of instances the
code is still the same yeah it's
actually actual actor implementation you
don't have to rewrite that and say you
up to 100 or something you define it on
the top and the actual function is still
still be exactly the same more or less
yeah which takes us to the much promised
musical break yeah there's been quite a
lot some of content and so we thought
that it would be time before we go to
the final part representation to let you
easier memorize the things by presenting
a song about it and this song might of
course must be written by English
musician in this case Elton John and we
will be covering several topics in this
song of course you already know that
doctor you say we but this is more of
your yeah it will be helping with this
line your domain yeah this is where I
become a sort of embarrassed and I
refuse but you can sing along so octopus
is one message at a time we all know and
actor instance created using little
props and the reference track is called
actor F and if we're out to create
multiple instances of actor they get
names dollar a dollar beam dollar see
and our hero will get name dollar
beautiful names yeah and then of course
you have supervision strategy and the
most crucial one or cruel one is all for
one we're all octo sorry started and of
course you should try to use tell and
not ask so with that we will see if we
can see this keyboard yes
yeah looks like so now you're helping
with text yes and everybody can sing
along
though I never you you
they chose us to restart you
and you kid stones got your name
but when you were alive
you played your own
props and every single message do that
for you she's only one
only using a few cycles from the message
game
and I
but supervisors five new Pistons
I gotta read little lost
loneliness was done
you had to sleep alone
most of the time
you go away come they let you tell but
when you die
it was another sibling spam
but supervillain strategy
and it seems to be
it's your life
for me
and I will
why
I
thank you thank you I ready for with
more technical stuff
no that was also technical testing
testing how we tested actors how can we
go back to testing now there is a
courtesy desk it yeah I think one of the
main lessons we learned that of course
well and recently there's been a big
debate on testing in Uncle Bob and so on
but I think we started a bit late on
doing our testing and you shouldn't
really underestimate testing even in a
functional language and even in an actor
model and whatever fancy framework
you're doing you should probably do some
testing and verify that's the stuff for
accessory expect an architect's kit
helps you do that it's it fits well with
the functional paradigm so it's an input
and an output and then an extra systems
case that is a message in and the
message out so you can actually send it
a message and then verify that it sends
a message you expects that's basically
the answers of testing actors you have
incoming messages and then you expect
certain output messages and then if
they're OK in relationship with incoming
messages and your actor is good but we
are also using so-called FS check who
knows quick check o fo check yeah quite
a few you yeah so a first trick is very
heavily influenced by quick checks sort
of a port from from quick check and what
this helps us do is randomize the input
of our messages so in this instance you
can see that we the very top line on the
far right you can see that we get a
message that is of type a blowjob then
on the bottom area that you see that we
expect some certain messages or
sequential messages being handled
these are message types or message names
and this is order so if it will be wrong
message wrong order then we will add an
error but look that we didn't specify
the
initial data there will be automatically
sampled by our check and this case is
just it tries to create ten different so
it's ten different variations of the
upload jutsu
so it looks as at the type looks whether
it's a string and so on and and tries to
infer the data types of course an
analyst tries to manipulate those data
types and basically tries to break break
your system and that helps us a lot I
think with actually steps that weak
typing Korea who follows this recent
Twitter war started by Uncle Bob who
claimed that static languages sometimes
their to read it too strong about things
and then it shouldn't really replace
your test with with it you should sort
of rely more on your test who who has
been following this yeah and well Uncle
Bob of course he has a lot of valid
think things to say but we must say on
outside that actually we'll be using
quite extensively the static type system
because when we started with this
applauded job we used types like strings
ins and then our sample generator just
generated some rubbish strings for us
because you have file I which consists
of commas or new strings and then this
is a noise which is not worth testing
then we slowly started turning into
strong type so now we have typed the URL
file name alphanumeric and so on once it
was done and we have proper generators
for everything then we get actually data
that has a lot of sense and so we can
get here in this test ten samples but
usually by default like hundred samples
you get for free basically from test
generators and it's all dependent on
good strong types behind behind I think
we also had some file paths so
see : something path and then the FS
check would just create a string with
just numbers which doesn't of course
it's a valid test if you want to make
your system really handle everything in
the known universe and be unbreakable
that's not really realistic because when
you control the input and the output you
won't really send like nine nine nine
nine nine when you're creating a path so
it helped a lot by creating strong type
F sharp is especially strong with that
it's very easy to create new types and
make them very having some some some
semantic meaning in the types not just a
string in value a if you are f sharp guy
or sorry C sharp guy you can use FS
check inventory search our library with
your C sharp code to generate samples
for your C sharp yeah success to the
final point and this is the conclusion
we will start off by this obligatory F
sharp slide bragging this is just
propaganda propaganda slide you can see
the total lines are about half empty
lines or lot less files are actually a
lot less because you can fit more into
file or makes it easier to fit anything
into a whole file but the story is not
that big of a difference when you see at
the actual code lines when you remove
all the stuff now you see that C sharp
code is actually is still something like
25% larger than F sharp but so many you
sort of get just the meat as they're
comparable but the traditional with C
sharp is Java you get a lot of
ceremonial get a lot of verbosity which
affects actually the ability of the code
because you you can't really see the
whole thing on one page with this F
sharp you it's very efficient code like
88% is real code exactly executable code
so our impression that it's improved in
practical aspect our work with source
code and also the fact that we have now
one third or maybe almost 1/4 of
original number of files also also
I don't think we mentioned it but this
is a comparison of the old project from
10 2012 and a new project and they are
not strictly like there's no one to one
feature set with that we've tried to
extract the ones that are overlapping
and compare them but they're not
you can't yeah there are approximate she
do not do not yeah they're not written
in stone these numbers but actors are
not silver bullets so what bad can we
say about well you remember the
benchmark that the absolutely fastest
way to execute piece of code just to
have direct method invocation and when
we started working with actor model we
run some examples including them boot
camp and there were some examples of
creating actors to conclusion eight two
strings of course this is kind of
caliber thing but it may give you a
wrong impression that you should be
creating our actor for some such strong
such simple things no you shouldn't you
have to have some reasons for creating
actors yeah because actors do add some
complexity and I think mostly to do with
debugging because an actor is
asynchronous and it's very small piece
of code and you create this large
hierarchy so it can be a bit difficult
to fit it all in your head but of course
you can say that about a long stack also
but on the debugging sort of operational
side it can be quite difficult sometimes
because this stack in every actor is so
small that you can't really trace your
whole the whole flow if you're not being
proactive by doing a lot of logging by
doing well Cabala is your friend at
least for us by doing some transexual
IDs maybe so you start with like a unit
of work ID or some kind if you create
that of the on the boundary or system
that or addy flows through your whole
system makes it easier to to look at
logs in in in the whole operation of one
operation and they are not easily
composable a sort of hardcore
the next step in the flow is sort of
hard-coded in the first actor you can't
easily publish library that contains an
and actor to the rest of the world of
course if active just confuse messages
and does certain things you can but
let's say actor is communicating with
other actors you have to some smart
things typical dependency injection to
make it more open but extremes
initiative actually tries to address
this point that's for another talk yeah
I mean it really tested so when should
you should you use the vector before or
define one yeah well as we started in
the beginning we showed this evil
picture with three creators like thread
lock and state and like this year while
we have been working with actor model we
really focused on all the main tasks we
we didn't we didn't actually write a
single instance of word thread oh look
during this year and that's probably
good personal achievement and also
actors say they're very good in single
way ordered message processing and so if
this is something that your system can
accommodate that that actors have a
friend and also the parallel computation
it's it's easy to at least when you're
in the prototyping phase you can
experiment by splitting jobs into
several smaller jobs if you need some
sort of high performance type of
operation you can split them is very
easy to scale up maybe maybe does it
make sense with the ten concurrent or
maybe a thousand just that's just one
line of code to experiment with this and
it's very very pleasurable to work with
that sort of scalability and state of
course you don't get have getters and
setters no status it is very nice to not
lock down huge collections of tasks
that's been very nice so all in all are
are we happy with our choice yes right
now we're happy we have a cyst
them in pre-production it's actually
part of it already is in production
which showing very good scalability and
performance figures the rest of the
system is under testing but our
impression so far that we have in the
system which is will be much better
maintainable so in the future probably
you will need less consultants like me
to work with this stuff so how are we
doing this time I think we still have
more than five minutes so we will be
around during the rest of the conference
and you can contact us on Twitter on
email party have some questions now can
people try to answer them we have a my
kick and you could get the mic I can
actors have more than one subscriber so
you for instance like you pass you pass
the message on to the next the next step
which does your processing we might also
have an active that sends off a
notification or something so like a
branching yes actors you can you can
subscribe to certain missions or certain
actors even though actor is sending
accident message to to some after you
you can subscribe from different places
also you have broadcasting possibility
with actors another question how do you
handle your dependency injection with
using actors there's no explicit sort of
framework or anything I don't think we
we have sort of a which became quite
large after hila a sort of a startup
function which basically wires up so in
a lot of cases you start on the very
main or main method function level and
you create an actor and then you create
the second actor and you just toss it
into the
next one dr. F so it's kind of sometimes
it's referred as poor man dependency
injection exemptions that we are not
using any dependency injection framework
and we considered that we actually
didn't need that we have bootstrapper
gold that just spins actors and passing
them are the actor references of
functions that retrieve code or data
that is necessary to start this this
actor this is how handle we have a few
bootstrappers that we execute in the
beginning of it and also it's quite
testable we use a test kit let me just
pass different actives test actors when
adjust the system so all our tests are
the pure unit tests in memory test no
questions left or right for you is there
a single server application or do you
rent on the cluster observers is the
distributed app or a single server app
it's just a single serve up in our case
there is something called a car cluster
so you can or a CO remote actually so
there's a commodity of Osaka cluster
yeah true can't deploy it to multiple
service or say that this this group or
actor should be deployed to this servant
but not this but in our case I think the
just the amount of computation hasn't
been great enough to yeah performance
wise will we have fun adjusting instance
but we already started the testing of
our cluster because of failover across
their needs because it's not good enough
just to have one instance of operation
reasons and there is a class of issues
released about half a year ago and which
supports different scenarios so what
we're probably going to use this are
called cluster sharding which uses
persistent actor so you have single back
end and you persist certain actors there
and so then nodes can enter and leave
the cluster we will also be using so
called aqua class a single tone where
you actually have just single instance
of your server but in a classic
environment so if it goes down then
another one will be fired up thought
that probably transition paths for us
because it will require less code
changes you started testing is lost yeah
yeah we are actually
we run some tests last week and Iroquois
organization where you have to called
innovation days where people can try
different things like couple a month and
for us was very good opportunity to
actually start using our cluster yeah no
questions so style with the one server F
Shop has actors as well do you mix the
two do you replace everything with akka
is it is it is it just what's your why
did you look at the EF shop kind of a
Bach process we looked at the mailbox
processor because as you say f-sharp has
a built in actor system and I've
actually built one smaller project using
that and that it's fine it's basically
the same thing it's an asynchronous
message slips it keeps its own state and
everything but it's very limited it is
just the raw actor there's no routing
there's no supervision there's there's
no yeah it's very limiting so he decided
to go for a bit more of a framework
because we need some of the routing and
so on yeah so like we presented four
main lessons and three of them included
things that you found you won't find in
f-sharp mailbox processor with
persistent actors routing supervision
and in addition occurring mode on our
clustering
it's not covered by but it works fine so
use it for if you have a smallish
project and just ease it it's it's fine
I've have it in production in a much
smaller project and it's I have no
issues with it so more questions
I guess the time is small this up yeah
thank you very much enjoy your meal and
the rest of the conference yes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>