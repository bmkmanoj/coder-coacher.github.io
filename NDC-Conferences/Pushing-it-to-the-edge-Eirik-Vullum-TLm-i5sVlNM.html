<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Pushing it to the edge - Eirik Vullum | Coder Coacher - Coaching Coders</title><meta content="Pushing it to the edge - Eirik Vullum - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Pushing it to the edge - Eirik Vullum</b></h2><h5 class="post__date">2017-05-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TLm-i5sVlNM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for coming from the title it
might seem like this is a talk about
performance but I can assure you that
there is nothing about performance in
this talk this is me my name is Isaac
and I'm a JavaScript consultant and
instructor and I spend most of my time
programming JavaScript both on the
server and on in the front-end some
people love to hate JavaScript I just
absolutely love it some things are
rubbish
but the best parts are golden and one
thing that I like in particular is react
not because react is react but the idea
behind react and what it enables so
there's other libraries with the same
qualities as react and even better ones
more objectively and that are more pure
but the exact implementation isn't the
important thing here but rather what it
enables and to explain what I mean by
that
the
yeah so to explain what I mean by that
we can look at how you create a
component in react and in react that's a
matter of describing some UI based on
some input so the input here is some
prop some data and then the output is
some UI and it might become even more
clear if you look at these functional
stateless components which are just
functions pure functions that take props
and then return UI if you want to see it
without the JSX notation you can see
that it's just function calls nested
function calls so we can use this
component now to create a description
because the components here they don't
actually return UI they've just returned
descriptions of UI so you could use this
as a function that takes some input and
it will give you a description of some
UI and that description might look
something like this for example it's a
plain object just describing some UI so
this is just a value so the component
doesn't actually render anything it just
describes the output to do the actual
rendering you would have to use the
react runtime and it's the runtime that
actually does the Dom manipulations and
actually get something to be rendered on
the screen so there's a runtime for
rendering something to the browser
there's a runtime for rendering
something to a string and there's a lot
of other targets as well like native
devices now so the important thing here
is that the runtime just takes a
description of what to render which is
just a value and then the runtime
performs the actual operations to get
something to be rendered on the screen
so what happens in react is that you
might have some component tree which
consists of these pure functions that
just returns descriptions of what your
app should look like and then you have
this rendering engine wrapped around
your application and then you might have
the Dom on the outside so that's
completely on the outside it's a bit of
a misfortune that it's a bit far out on
the outside but that's not a part of our
application so what might happen here is
that the react rendering runtime tells
the component tree could you please
render yourself and then pass me
whatever description that yields and
then the actual runtime would patch the
Dom to render this to the screen and
then maybe someone changes the state of
your application then the runtime have
to ask again what is your output if the
state is this and then it passes back
another description and then it patches
the Dom again so what if you wanted to
write a test case for our component now
for our application we could just write
a simple test case where we force some
description we could produce some
description here and then we could just
expect that to equal some description
that we wanted it to yield so this is
just comparing values we're not actually
doing anything against the browser or
any rendering here we're just comparing
descriptions and since we have this new
way of calling functions with jsx
this new syntax introduced with react we
can make it look even simpler because if
we use JSX we could just expect that to
give some kind of output producing this
description which would again just turn
into an object just a value so what
reacted is that it made it
easy to describe UI and to test your UI
and that makes me really happy because
that used to be really hard if you think
about like really imperative solutions
like jQuery or other solutions where you
don't have this divide between
describing and the actual rendering
another library I like really much is
Redux not because Redux is Redux or the
hype or anything but I rather like the
idea behind it and especially Redux
because it is the simplest
implementation of this idea you could
pretty much create the core of Redux in
seventeen lines of code maybe less so if
we take a look at redux then by the way
the logo here was really hard to draw
for some reason so if you look at Redux
now in redux you have this way of
describing actions that might change the
state of your application and these
descriptions are just values so here
it's represented by just a plain object
and then you have this so-called reducer
function which is just a mechanism that
takes your previous States and a
description of what to happen and then
it returns a new state based on that so
you are the one who decides how state is
updated and how state is represented and
this again is used as input to create
this Redux runtime because the store is
what actually handles all of your states
and then we can pass descriptions to
this runtime by dispatching so-called
actions so the action here is just a
description just data just a value and
then the runtime does the actual state
updating so if you wanted to write a
test case for our states updating logic
now we could just define some kind of
initial States that we wanted to start
in
just define a set of actions that we
wanted to process in our system through
selection the increment action here has
happened three times and then we could
just expect that the result of reducing
all of those actions with the initial
States and our reducer function that it
returns the states that we expect so
that we go from having to state 10 to
having the state 13 so now again Redux
made this whole deal of describing state
update logic a lot easier and also
testing your state update logic that
again makes me really happy because that
used to be really hard like a global
global mess so on what both react and
redux here have in common is that
they've taken the fact that you're both
describing and doing things and it
separated it into separate parts so one
part is describing what to do and the
other part is actually doing things and
this is really great because this means
less complexity in the true sense of the
word because things are less braided
together you cannot have the separate
boxes now to put the different things in
so that's really good so now we have UI
and state covered here but the hardest
thing might not be the UI in the state
but at least we have a third thing maybe
a fourth which is how do I orchestrate
all the asynchronous flow here in my
application because how do I decide when
things should happen how to decide when
to dispatch which actions when I'm doing
things asynchronously and if I'm having
a lot of side effects in my application
but side effects what-what has side
effects really
so when I'm saying side effects here
it's everything for that might interact
with something on the outside like the
network or printing something to the
screen writing something to a disk may
be rendering something to some platform
basically anything that interacts with
the atom with the real world is a side
effect and we need side effects because
without side effects our applications
wouldn't actually do anything they would
just be pure programs that did
calculations and that doesn't really
have any real value in the real world
and when we think about these side
effects here in our let's say react in
Redux applications it usually comes down
to the part where you're doing something
asynchronously like let's say you're
getting some data from the server and
then you're going to populate that back
maybe you're doing something else
asynchronously at the same time so if
you look at this pattern here which is
called a thunk you can see that we are
dispatching actions at different times
here and the actual operation of
dispatching something here or going to
the network to get something is a side
effect so that means that if you wanted
to test things here we would have to
write mocks which is pretty unfortunate
but just to avoid coupling this to read
us and react I want to make this example
a bit more generic so you can just say
that we have a function which we're
calling a procedure here which just does
a lot of stuff it gets a random number
it logs out that number if that number
is higher or lower than 0.5 it logs out
something different then it does a
request and then it writes the result of
that request to a file so we have a lot
of side effects here so to visualize
what happens here we have this procedure
and then this procedure calls out to do
a lot of side effects so when we get a
random number you actually have to go to
the computer and get some kind of
entropy to get around the number maybe
someone throws the dice or it's in some
case we need to interact with the real
world and when you log something you
have to print something to standard out
if you make a request you have to go to
the network if you write to the file you
have to access a disk and so on but if
you look at this now what you can notice
is that there is no boundary here
there's no boundary between the thing
that describes what to do and the thing
that actually performs all of those
things so we so when we don't have those
boundaries we have to resort to things
like mocks so if we look at this
procedure again now you can see that we
if we wanted to write a test case for
this procedure we would have to mock out
a lot of things here we'd have to mock
out math.random console.log the request
thing we're using here right to file and
so on and so on and and that makes me
really sad because who wants to write
mocks who here enjoys the right mocks
no one of course and the worst thing is
mocks that have a lot of behavior
because mocking behavior is the hardest
thing because to be able to test things
you have to mirror the behavior and
behavior of the real thing which can be
really hard and expensive and it has to
be maintained alongside your actual
application code so again what we want
to do here is we want to take this and
be able to separate whatever describes
what to do from the part that actually
does it so it's time for a little story
a story about Frank procedure Johnny run
time and his evil twin brother this is
Frank
Frank pretty much just lives in the
world where there's flowers there's
trees there's the ground and the Sun and
all that thinks you're used to and Frank
can interact with the world he can for
example observe things he can observe
what time of day it is what kind of
temperature it is and he can observe
different events that happen in the
world and he can also interact with the
world or mutate the world he can do
things like chop down a tree he can dig
a hole he can pick some flowers you name
it he can do a lot of things to
manipulate the real world but Frank also
has some special characteristics which
is that Frank is incapable of lying and
he also have this very specific job and
he does exactly what he is instructed to
and nothing else so that's Frank
it's a Frank's job it's pretty much -
every day his instructions are to wait
for the sunrise when the Sun rises you
should measure the temperature if the
temperature is below 15 degrees you
should chop down a tree and make a fire
because it's cold if not he should just
like pick some flowers to make a bouquet
have a nice day and then whenever that
is done he should wait for next sunrise
and do the same thing so Frank is pretty
happy because he knows what to do every
day and he does what he's supposed to
you might think but can we really be
sure that Frank is doing what is what
he's supposed to for any condition of
the world it's been it's been 20 degrees
over the last 10 years so we don't
really know what Frank is gonna like
chop down a tree and make a fire if it
turns cold but we want to make sure that
he actually does that so how can we make
sure that fry
does exactly what it's supposed to for
any state of the world and Frank pretty
much cannot answer what-if questions
because he only does exactly what is
told so we either have to wait for all
of these different conditions to happen
naturally in the world which seems
really inconvenient or we can fake all
of the conditions in the world and that
would include like making a lot of
plastic flowers and plastic trees and
making something that could fake a Sun
Rise and that just seems really
expensive and hard because the Sun Rise
only happens once a day so it would be
really inconvenient just to be able to
test things once a day so faking all
these things in the real world is hard
because that means that you have to
mirror how the real world works so what
do we do then
first we'll have to introduce Johnny
Johnny runtime and Johnny runtime
performs tasks if you tell him to do
something he'll do it like if you ask
him could you please tell me when the
Sun has risen he'll tell you that could
you tell me what the temperature is and
he'll tell you that could you chop down
a tree for me yeah he'll do that but
Johnny doesn't have any understanding of
like the order of things he just like
gets he does single requests and then
gives you a result back let's try
another scenario here where we have both
Frank and Johnny in our world so it's
the same world flowers but you can see
now that at least some of you might see
that it's supposed to be night like
that's a nice guy but we'll have to make
some restrictions for Frank here because
we don't really want Frank to interact
with the real world anymore
so we couldn't have to build like this
wooden cabin around Frank with no
windows you have the door but like the
only way he can communicate with the
outside world it's like passing notes
under the door that's you can't hear
anything can't see anything
it's nice and warm and cozy but other
than that it's like completely isolated
let's see how this interaction now might
go down so we'll start out by Frank
knows that he's supposed to wait for the
sunrise so what Frank does is that he
passes a note a post-it note under the
door saying that could you please
whoever is outside notify me when the
Sun rises and so the Sun rises and
Johnny passes the note under the door to
Frank to tell him that the Sun has risen
then Frank passes another note back and
ask for key I want to know what the
temperature is now like you nee writes
that on the note could you please tell
me what the temperature is and Johnny
okay sure I'll measure the temperature
and then he passes the note back telling
him that it's 20 degrees and then Frank
passes another note to him telling him
to go pick some flowers and have a nice
day
so Frank doesn't get to get to have any
fun anymore but Johnny does so he picked
some flowers and then it passes another
note under the door telling me telling
Frank that yeah I picked the flowers I'm
done and then Frank passes another note
telling him could you please tell me
that when the Sun rises and then you
have this loop going so that seemed okay
not for Frank though but like keep
disregard humanity in this example but
how does this make it easier to test
that Frank does what he's supposed to
for all conditions that's where we have
to introduce Johnny's evil twin brother
Bill bogus Mack testy
bill bogus max ft he will lie about
anything and but the good thing is that
he will take instructions about which
lies to serve and bill actually never
interacts with the world he doesn't care
about the world he's really
self-centered this is only job he lies
about things and takes instructions
about what to lie about so what if we
replace Johnny now with Bill so we start
up the same it's the night it's a middle
of the night and Frank passes a note
under the door telling whoever is
outside to please let me know when the
Sun rises and Johnny gets a bill gets
the note and he just passes the note
back telling him yeah the Sun is risen
like it definitely hasn't but it's just
yeah why not
this reason sure and then Frank passes
another note back telling him could you
please tell me the temperature and Bill
just I don't want to measure the
temperature I'll just tell you that it's
a zero degrees so he passes a note back
describing that it's a zero degrees so
Frank doing his job passes another note
back out to Bill because now the Frank
is supposed to tell whoever is outside
to chop down a tree and make a fire and
Bill gets the note he does nothing and
then he passes the note back in telling
him that yeah I chopped down a tree and
made a fire and then that starts again
right now Frank asks for like the next
sunrise so the important thing to notice
here now is that we we can now test that
Frank does the right thing for any state
of the world but we didn't really have
to mock we didn't have to fake any
behavior here so we didn't make any
marks we didn't make any plastic trees
or any props
but rather we only mocked values because
the only thing that we had to mock here
was what was written on the note passed
under the door and that doesn't have any
behavior that is just values that it's
just data so this seems like maybe this
maybe maybe this is a good idea to be
able to test our asynchronous procedures
but how would you translate this into
code like how would you do something
like this in JavaScript because
obviously you cannot pass things in and
out of functions in several places a
function has takes input in the start
and then it returns something at the end
so clearly using a function here just
wouldn't suck the surface so let me I'll
have to take a look at this really nice
feature that came in es6 called
generators some other languages have had
generators for a long time how many of
you have heard of generators some of you
how many like have used actually used
generators okay not not a lot of you so
then it's pretty fitting with a
introduction then so a generator looks
very much like a function except it has
this star and you have this new keyword
called yield so it looks pretty much
like a function but it doesn't act like
a regular function because calling a if
we create if you call a generator
function it'll return something to you
called an iterator and if we use this
new for of loop syntax that came in es6
as well in this case it'll just by turn
logout one two three because that was a
Val
use that would eat was yielded out of
this generator and seemingly it doesn't
really care about this return statement
this is only logout 1 2 &amp;amp; 3 but we can
also manually step through generators or
these iterators rather so we can create
a certain iterator from this generator
function and then we can start stepping
through this function so an iterator has
this interface where it has a method
next that it uses to skip to the next
point that is yielded inside the
generator so what happens here is that
the first time we call next here it's it
skips down to the first yield and then
it returns an object with the value that
was yielded and it also tells you if
this generator function is done running
and it obviously isn't done running yet
because we've just hit the first yield
if I call next again it'll give me the
value 2 it'll tell me that I'm still not
done I'll call next again it'll skip 2
the value 3 and then I'm still not done
and when I call next again it'll give me
finished so obviously now it does care
about the return statement so now I got
finished out and it also tells me that
I'm done done is true if I call next
again it just gives me undefined that's
the value and tell me that I'm still
done like I don't have any more values
for you so let's take a bit more
extended example here where we have this
generator function which will count to 3
like we have 3 yields inside here but
we'll also log out something here we
login the result of yielding this value
so we'll start out by creating this
iterator instance and then we'll call
next so what happens when I call next
year is that the generator jumped down
to the first yield and then it gives me
back the value one and done false
and the next time here I'm going to call
next with the value 5 and when I do that
it actually logs out first number 5 so
it seems like we've been able to pass a
value in into the function here and then
it jumps to the next next yield and it
gives me out the value 2 and says I'm
still not done and then we pass in the
value 10 on the next it logs out second
number 10 jumps to the next yield and
then it gives me back the value 3 and
done false and then I pass in the value
15 and then it logs out the third number
15 and then jumps to the return
statement and then it gives me the
return statement value and it says that
it's done it's done running so what's
happened here is that we've actually
been able to replace those yield values
there by putting these values into the
generator function so it seems like
we're both able to get things out of
generators and put things into them
which is pretty much what we want
because we want to be able to pass
things between this boundary and this
might be exactly what we're looking for
because now we see that we can get
values out we can take values into the
generator and then we get this really
good idea that why can't we just use
this to pass descriptions of
side-effects out of the generator
because now we have this semantics here
to be able to pass just values in and
out of these generators so what if we
create ourselves a function here a
function called call which takes a
function and then a set of arguments and
then it returns an object which is a
description
of calling some function with some
arguments so to explain what I mean here
is that if you use this call function we
could create a description of calling
console.log with hello and world as its
arguments that would give back a object
here with that description so this
doesn't actually call console.log with
hello world it just returns a
description of calling it so this
actually doesn't do anything to be able
to do something with this we would need
some kind of mechanism that could take
these descriptions and then perform
these actual effects so we'll create
another function here called perform
effect which takes this description as
input and then this perform effect here
now obviously only supports the call
effect and if it gets a call effect
it'll take the function call it with the
arguments and then return a promise of
the result so in use this would look
like this so if we made this description
here of calling console.log with hello
world we could perform that effect by
just passing that effect to perform
effect and it'll log out hello world or
we could just do this directly by
passing an object describing this
directly to to perform effect that we
just log out hello world so again what
we've done here now is we've been able
to separate the actual doing of
something and then the describing but
there's still one thing missing here
because we don't really have who is
going going to make sure that this
generator gets step through like we
don't you don't want to do that manually
so we'll need some kind of runtime that
would be
responsible for actually running all of
our procedures so an example of a
runtime like this would be a function
that would take a generator function
which would then make an instance of
that generator function and iterator and
then we would recursively step through
this and whenever their generator yields
some description of an effect out we're
supposed to resolve that effect perform
it and then return the result back into
the yield in the generator so we're kind
of just like the generator is passing a
description of doing something else and
gets the actual value back so this
procedure now where we're doing things
directly we're like doing side-effects
directly here translating this over to a
generator we would replace all of the
direct calls here with yields which
pretty much this creates a description
of calling math.random without any
arguments and that's what we push out of
the generator and then it's up to the
runtime how to actually handle that you
can see that all of the side-effects
here have been replaced with
descriptions of side-effects that we
just push out of the generator so if you
look at this procedure now it doesn't
actually do anything anymore
it does nothing other than compute
because all of this is just descriptions
it doesn't actually log something it
doesn't write to the disk it does
nothing it depends on the run time to
actually get anything done so to run our
procedure now instead of just calling
the procedure and letting it run we're
passing this procedure to our run time
and this looks something like this where
we now have our procedure like before
which is now a generator function which
yields
descriptions of doing things out of it
so now we have a runtime like
encapsulating our procedure so the
runtime starts stepping through the
procedure the procedure yields out some
description of doing something and then
the runtime actually goes out and gets a
random number and passes it back to the
procedure and then passes the data back
into the to the procedure here it steps
to the next it logs out something to
standard out and that doesn't really
return anything so we're not expecting
it to either then we're doing a request
the runtime goes out to the network gets
the results and then passing it back in
to the procedure and the same when we're
writing something to the disk here so
the runtime is doing a lot of things
here and the procedure is just
describing what to do so what about
testing this now because now we have a
procedure that doesn't actually do
anything it just describes things and
then the runtime performs any of it and
between the boundary here between the
procedure and the runtime the only thing
that passes that boundary is values only
data nothing that has any behavior so
this is just plain values plain data so
if you were to write a test case for
this now we could take our procedure
make an iterator out out of it and then
you can start step start to step through
it manually so we can go to steps like
the first step here and then we could
expect that the first step here is that
the generator yields out a call to
math.random so we can expect that that's
what it's doing then we can actually say
that ok I'm going to fake this because
I'm not actually going to make a random
number I'm going to tell the generator
that your random number is zero point
two and then I can check that ok that
means that the next step should be that
he yield
Souths a call to console.log with the
value 0.2 because it was supposed to log
out the random number it got and then
this goes on right we can just observe
what the generator yields out and we can
just pass fake data back to it then we
can make sure that without ever doing a
request here or logging or doing
anything we can make sure that the
procedure does exactly what it's
supposed to do for all different
conditions for all different values so
this in the same way as react and redux
makes describing a synchronous flow with
a lot of side effects a lot easier and
also testing asynchronous flow because
we have found a way to separate the
describing of what to do and actually
doing it and that of course makes me
really happy so this has just been an
attempt to repurpose the underlying
ideas behind react and redux and all
these kind of functional principles here
where what we're basically doing is that
we're pushing all of the side effects
all the way to the edge of our
application so that the core of our
program doesn't actually do anything
anymore
it just describes things and then all
the side effects are like way out on the
edge of our application and the most
complete implementation of this idea is
something called Redux saga which so you
might have heard about which uses
exactly this way of being able to
declaratively describe side-effects and
use the exact same semantics that we
looked at and this isn't just something
that you can use in the front-end but
rather it's something that you could use
for anything that has a lot of side
effects and a lot of the complex
asynchronous flow
yeah I'm not actually sure if I'm going
to show the demo but let's say that we
had this program here it's a program
that is called slow print and what it
does is that it sets up an infinite loop
and says that the first thing that you
should do is wait for there to come some
data in on process standard in like if
someone writes something into standard
in give me whatever they wrote so now we
have this new kind of effector
previously we only have call but now we
also have an effect called take stream
which produces and a description of
waiting for a value on this stream and
when we've gotten some data there we'll
just make that into a string and then
split that into an array because what
we're going to do here is that we're
going to like incrementally print out
these characters with some delay between
them so we're saying here that while
there's characters left in the array put
those into standard out like print that
back wait for 50 milliseconds and then
go to the next one so this is of course
just in a contrived example but this is
something that would be really hard to
test without marking out an
implementation of streams but now you
could actually test this without using
any streams at all because you could
just test that it does what it's
supposed to do for different kinds of
effects let's see if I can get this up
here
why it doesn't let me move the window
okay
I'd be a bit more juicy maybe so so we
have this program now that that when I
write something here if I write hello
it'll print it back to me with a 50
millisecond delay if I write a lot of
stuff here now it'll just print it back
to me to the stream here so the only
thing I've used here is just a slight
extension of the runtime and the code
that we've been writing here now so
again something that might be both hard
to describe and hard to test might be
made a lot easier by using this approach
and also there's no callbacks here or
then there's no promises it's just
sequential code which is also this
really big advantage to using this
approach because it kind of abstracts
away the whole deal of a synchronicity
so now we have these new effects here
like take stream put put something to
the stream and we have an effect for
making the process wait for 50
milliseconds so you could pretty much
make all of your own effects here but
Redux agha has all of the useful ones
already implemented there's also a very
similar construct called async await
available now in JavaScript which does
pretty much the same thing for promises
where you can write code that looks
synchronous but is in fact asynchronous
so I cannot just use async await here
instead of generators so the the
drawback with async await is that
there's already a runtime for you there
you are not able to override that and
step through your asynchronous functions
so you wouldn't be able to test it the
same way you would still have to write
complex mocks but for asynchronous codes
just we're going from like promises and
callbacks
async/await is very nice so just an
important note is that I'm not telling
everyone to and go ahead and do this
thing but if you're writing a lot of
complex logic and you're finding
yourself having trouble like getting to
test this you're having to write a lot
of mocks it's hard to see the actual
sequential flow of your code this is
something that you should look at and
then specially then redock saga that's
my time so that's what I have if you
have any questions please feel free to
ask now or afterwards</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>