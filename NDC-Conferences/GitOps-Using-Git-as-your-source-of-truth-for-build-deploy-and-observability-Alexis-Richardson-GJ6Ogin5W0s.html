<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GitOps - Using Git as your source of truth for build, deploy and observability - Alexis Richardson | Coder Coacher - Coaching Coders</title><meta content="GitOps - Using Git as your source of truth for build, deploy and observability - Alexis Richardson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GitOps - Using Git as your source of truth for build, deploy and observability - Alexis Richardson</b></h2><h5 class="post__date">2018-02-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GJ6Ogin5W0s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Alexis
and
among other things the CEO and founder
of weave works a software company based
in Shoreditch and San Francisco we make
trad native tools for containers
kubernetes prometheus if you want to
talk about that please talk to me
I'm also the chairperson of something
called the Technical Committee for the
CNC F does anyone know what the CNC F is
one person knows what the CNC F is CN CF
is part of the Linux Foundation it's
with the home of kubernetes
who knows what kubernetes is great
because I'm gonna be talking about CI CD
for Cuba Nettie's today basically we
call it get ops for reasons that I will
explain it's just a variation of DevOps
modernization if you will and it's all
about going from you know a few
deployments a month or a week to many
many many deployments a day can I have a
show of hands who's if you're doing
deployment if your team has an app that
you're responsible for how many people
do more than once a day and deploy more
than once a day yeah it's probably about
15% I think in a few years time that
numbers going to change what's allowing
that is the flexibility and power of
these new technologies that are arriving
on the scene today kubernetes is the
most important and most best known along
with docker they provide you with a lot
of automation and flexibility which lets
you introduce a whole new layer of
tooling to make these changes more
frequent so I'm going to start with an
example okay this is a company called
called over there based in San Francisco
and they do a really cool product which
is a website for what Americans call big
marketing brands who do something called
localization so if you make say clothes
and you your advertising depends on
people wearing those clothes in order to
encourage people to realize how nice
they look what one thing you might want
to do is have very
Shinzon how you present that to people
in different countries localization and
called overdo localization for these big
shopping brands but powered by machine
learning so it's kind of combination of
traditional online marketing from that
Ally 1990s 2000s with the latest and
greatest in analytics and when we
started working with them they were
already starting to use kubernetes and
they had attached kubernetes to jenkins
on google cloud and they started using
weave and today by the way I'm not going
to try and force you or sell you on an
on a commercial product there is an
open-source past for everything that I'm
going to show you there's actually
several pausing and talk about patterns
as much as about products but in this
particular thing they are using our
implementation of this stuff and this is
a picture they sent me of their rate of
fixing bugs and responding to consumer
requests and before they started using
weave they were of this trajectory and
then they started using our software and
they went up to here in terms of their
rate and it ends up looking like this
and this is the kind of other key
numbers so they basically doubled their
team's productivity and when I asked
them what was going on there they said
the real benefit to us is we used to do
employments each one took about 30
minutes to do and sometimes they would
break so we would do one or two a week
and when we were doing a deployment
everybody would just have to kind of
hold their breath and then if something
broke we'd all have to kind of go in to
fill alert try and fix it because there
is no there wasn't any rollback as such
they would have to either figure out
what gone wrong another kind of keep
going or kind of go back and start again
maybe rebuild the whole thing in other
words a bit of a nightmare and now
they've got something which is automated
and instantaneous and can roll back and
it's programmatic and repeatable not
based on scripts there's very rarely
very hard to make it go wrong which
means that all of that sort of developer
freeze time that they had a loop let's
wait for the deployment finish could be
freed up and think by thinking about the
application once more so they stopped
worrying about infrastructure and
focused on the application
and they started to gain confidence
doing more and more and more deployments
and now I think more than thirty a day
and this is quite good for a team you
know a team which consists of about
twenty developers split up into about
five teams okay
so that allows them to do things like
experiment what if this would work in
China let's try that oh no doesn't work
let's roll back and they can do this
really fast they're very excited about
this and I've you know this is part of
the get ups is just an example of the
larger DevOps picture if you read about
continuous deployment in the space and
people at J's humble and others you know
there's lots of people who've written
down over years and years and years how
there's a kind of phase shift that
occurs as you as you go from a few rare
deployments to lots per day in the
confidence of that that gives you that
all of these other numbers start to
shoot up so what I'm saying here is it's
really this that's enable them to get
good results in terms of productivity so
what if gita' building on the idea of
DevOps
but perhaps that slight shift in focus
in DevOps we were talking about
infrastructure as code so operations
folks who were responsible for
infrastructure start to think about how
the system works in relation to code and
become coders developers hence DevOps
with what we're seeing today with cloud
native tooling like kubernetes is if
anything kind of the other way around
where developers are being encouraged to
take ownership of some operational
functions which is leading to the
ultimately the same result and there are
teams like one of our teams that we work
with is lyft the uber competitor I asked
them so what's your structure do you
have operations people and developers
what how does it work everybody is
DevOps now I don't believe that every
single person in that team is very large
team has exactly the same function but
they think of themselves as being just
kind of overlapping one big team which
is really cool and the key idea here is
and this is also not a new idea using
git as a single source of truth for the
whole system
and we this idea first appears about
2005-2006 of course on one of the Martin
Fowler blog posts he's very good at kind
of writing things down before before
other people do talk about using source
control as a way of expressing what you
want to do in your system
and you can see this is sort of starting
to happen with with Web Apps this is
something that didn't happen with old
client-server applications and now we
have these systems where we actually are
you stood an uptime we want to maintain
a common experience possibly across the
globe it becomes very important to know
what the system actually is supposed to
do so he starts a story in source
control and this idea revolves in
evolves as continuous integration starts
appear on the landscape testing becomes
a very important automated Testament
becomes very important suddenly at scale
having any kind of system in our
automated testing and bill becomes
unfeasible and now today 70% plus people
use CI and so then that it becomes
natural to tie back to get and so this
is prevalence in the devops world you
change things in git you'll see eye
picks up and you roll out artifacts
where you get artifacts that you can
roll out so you've taken that basically
pattern and just kind of expanded it we
ourselves as a company or a start-up
we've got about 45 staff of whom half
are basically all sres doing development
and operations and open source and all
the cool things and we've learned
through enormous pain in the last few
years of running kubernetes and anger on
amazon at scale that you know the
pipeline has to be automated complete
end-to-end it has to have everything
there's no point in having CI and then
having a manual deployment phase you've
got to vacate monitoring and security
right at the beginning otherwise you
have no idea what happens when things go
wrong and really critical everything has
to be version controlled and stored in
one place which is one source of truth
not two if you have two sources of truth
and something goes wrong you are in
trouble and I'll tell you some more
examples of that in a minute
and this is a picture I found to just
illustrate the idea that DevOps is an
evolution some ideas some practices some
technologies all these things at once
Kuroko evolving that's the expression
that Simon Woodley would use here
practices and tools are Co evolving and
we start off with some people at some
meetups and all of a sudden you've got
people at velocity and then you've got
chef and puppet adhering and so on and
so on that's the Phoenix project great
book if you haven't read it and now we
have cloud native this image by the way
this woman called Helen Biel at range of
thought develops consultancy so what
does kubernetes bringing to the party
declarative infrastructure if you read
about infrastructure as code which is
basically the idea that you know instead
of having each machine hard-coded with
you know weird config files all over the
place you can have a more programmatic
approach to building your machine or
your machine image in the cloud it
splits off into two different schools of
thought the declarative and the
imperative and the imperative looks more
like how machines used to be built in
the declarative which is exemplified by
a belief puppet for example and
basically says what the end state should
look like and that's the system figure
out how to get there
on a per machine basis kubernetes does
the same thing but at the level of the
whole application and at the level of
containers rather than underlying
machines so this is a picture actually
of a web app with an RSS reader
component and an engine X component and
this format you probably recognizes
jamol's the famous horrific config
format that's used in most cloud native
things today the key point is however
horrific and maybe it is declarative
which means that it can describe an end
state and the kubernetes Orchestrator
can understand that and then enforce the
system of bays with the constraints of
that end state and I hope this isn't
particularly a great example but I
probably could have something with it
might say there are four replicas for
Redis and then kubernetes will notice if
a Redis blows up then and there's only
three it will spot that
start another Redis for you or if
somehow he end up with too many it was
shot one now is this making sense so let
me tell you a story you mentioned about
bitter lessons of having automated
pipelines and observability joined
together we about a year and a half ago
we've been started running our system in
anger for about 6 12 months and sitting
in the office one bright spring day and
one of the developers suddenly says I
think I might be about to wipe out the
whole system if I press this key then
I'm gonna wipe out everything I think
I'm worried that's probably what's going
to happen at which point I stood up and
said please don't do that anyway the
next thing I heard was followed by oops
and then our systems gone anyway then
the whole SRE team had to come together
and do you know incident management and
we've got the whole system back up again
in 45 minutes now this is bringing up
all of the application state the data is
on disk multiple Amazon zones multiple
stages including production actually
users a lot of a very complicated system
involving kubernetes and Prometheus and
fluent E and SQS and Nats and governance
what else tons of things and we were
very pleased with this it just worked
and the reason was we could we could we
had not only the code and the configure
of the machines but also the entire
application state and the monitoring
state and the health checks all starting
gear so one key idea about get ops is
the more about your desired safety of
your system that you can haven't yet the
more you can get back consistently the
other thing is obviously get is a social
tool so when you have lots of people
working together you can see why
decisions were made I mean hopefully
preaching to the choir here what we have
today is major minor changes don't go
through cube cuttle on cue Bonelli's so
who people who don't know Kevin Eddy's
cube couple as Kelsey Hart sir itis s is
like SSH for kubernetes you kind of open
up a back door and use Scripture Burnett
is using command tool from the command
line cube cupola lets you change how
communities
working so we don't want people to do
that we want people to go through get
even for production changes now that's
this is a guideline okay
it's like above all don't do anything
really stupid if you need to break the
rules break them but we try and stick to
the rules
so probably 95% of the time we stick to
this even in crises the other thing you
can do is this is where observability
comes in you can compare your observed
state with your desired state now cube
energies is capable of doing that for
some things and that is in fact what
orchestration is the yamen I showed you
is compared with the running state so
for instance I can tell whether I have
three radius replicas or four and do the
right thing we just have expanded what
you can do with that with diff tools and
sync tools and things like this so gift
Ops is just following the DevOps rubric
which is your configures code code is
version control configures version
control to what can be described
therefore can be automated provided you
have tools that understand how to
reconcile desired and observed state and
what we're trying to do is maximize the
scope of what you can describe and
observe so that you can reconcile
everything
now when I say automation another key
point
I'm not saying please stop doing your
jobs and let some mysterious piece of
software take over and automate
everything you know in practice a lot of
things are semi automated or there's a
manual step or there's an approval step
or the staging piece but the more
automation you have there easier is to
decide where that should be okay we do
this even with things like monitoring
tools as well so it's not just config
and code but also policies about
deployment dashboards as well once
you've got the ability to describe your
whole system this way you can start
dipping it again this is not a
completely new idea well now we're
getting into the realm of fairly recent
I believe puppet
of all have tools a bit like this you
periodically compare your desired state
with your observed state in relation to
things that Cuba Nettie's itself can't
see and you fired if alert in this case
this is popping up on our slack SRA
channels saying something is wrong and
obviously we've actually quite an old
image we've got slightly richer reports
now and there's a link to the the
dashboard in the playbook and so on so
you can sort of see how this can create
a joined up life cycle so so that's the
core idea a good presentation of the
core ideas and this is where I said not
pitching a product there's a pattern
here he's presented by Kelsey Hightower
who's probably the most well-known
advocate for kubernetes he did a really
good keynote at cube con in Austin just
a couple of months ago which is on
YouTube you can go find it very easily
in fact you can go to our blog and
you'll see a link to it the world isn't
a longer envisaged it's a machine
installation it's now seen as a repo
because that's what moving that if you
say my systems observe state must be
corrected it must be what's the desired
state as well then I can say that the
world is what's in my repo for the
things that are important everything
else is incidental and he provides a
demo which gives some guidelines to how
to do this yourself in his case he's
doing it with gke and github but you can
do it with other cloud tools and other
repos bitbucket so on the key points
that Kelsey makes in his talk which I'll
repeat for you here is that once you've
got your kubernetes you really want to
have CD continuous deployment when CI is
not the same thing as CD there's a
limited number of CD tools out there I
will describe one later we Fluxus
spinnaker as an online service called
code fresh there's a few other things
kicking around
he describes the goal which is very
similar to how we see it as a developer
I want to make a pull request and really
just want to get given a URL to see what
the results of my change were and their
bonus points for the operational
back-end tool and give me metrics give
me visibility and I don't have to use
that open up the back
2news cubicle anymore and so this is
really useful because it means that a
new developer can join the team who
knows github and be productive on day
one which is really cool you don't need
to learn kubernetes or learn cloud
native or learn from easiest to do this
alone graph on ax plus and again
emphasizing something that really exists
all your changes are audited and git
which also has these really nice
features like roles based access control
and security and who does what you know
people who are our customers are using
this technology this approach for things
like compliance pci hipper and Sox
because they can go and see who made
changes to the system at certain times
in here and when you show the auditor
this then they go oh well that's amazing
I don't that you could do that and bear
in mind that this world of HIPAA
compliance is one which is actually full
of crappy commercial products but don't
do half the things I supposed to and the
things that they actually do they do
wrong it's just a general world of
psychopathic so actually using
a nice clean tool like git is really
helpful okay
so let's unpack the gear tops concepts a
little bit more I'm going to talk about
this what I call the three pillars of
get ups which are shown here in these
brightly colored rectangles pipelines
observability and control and sometimes
when I do this talk about talk about
observability being a concept that arose
from yeah from the 60s with something
called well various kind of things like
decision theory and control theory that
arose at a time but observe ability and
controllability are dual concepts a
system that is observable is also should
be controllable that's an interesting
thing to go and research a few have some
time so let's talk about each of these
joined up pipelines this has three parts
as I mentioned git has to be the head of
this or you know an equivalent system
see ICD and release automation
it's the same thing okay CI is what you
do for testing building there's a
pattern which I think of as an
anti-pattern which I call CI ops which
is when you let the CI system drive your
push to production because you write
more scripts that take your built assets
and roll them out that way if that
crashes you do not know what state
you're in continuous deployment is using
specialized programmatic technologies to
orchestrate the relationship between
what is in your built artifacts which
would be containers in the case of
kubernetes but it could be VMs or it
could even be other things and what's
running in your real system which in
communities faces their cluster I'll be
describing more about that in a minute
and release automation is a interesting
concept I mention it in two for two
reasons one because if you're interested
in you know how enterprises do this and
ultimately that's quite important
release automation is a is an actual
product category you know there are
things that you can buy that help you do
releases and manage who did what when
going back 15 or 20 years and there are
things that are happening now the
communities that resemble what those
products do but the other reason is as
you do more sophisticated types of CI CD
you find that you actually want to
differentiate between a deployment in a
release a deployment being moving an
artifact so that it's incarnated and
running in the cluster somewhere and
then a release being actually having it
exposed in production to users because
you might have five or six different
concurrent deployments of which only one
or two are exposed to users in the case
of two classic examples of this for a be
testing when you have two versions of
the system you're checking them
concurrently and you're splitting half
and half of your users let's say and
giving them variations of the system so
you can try out ideas another one is
blue/green deployment where you start
off with it you roll out a new version
you've got it in parallel with your old
version in the production system and
then you flip all the traffic over and
you keep the old one there in case you
need to roll back quickly and the other
one of course is canary
as a Reynaldo canary is so canary canary
concept canary in the coalmine
you send a small thing into your
production system and you let that live
or die and then based on that you does
you decide whether to to roll out the
whole thing so what that means in
practices I roll out my change I tell my
route or my traffic manager or my load
balancer hey there's a new thing here
why don't you send one percent of the
traffic to that let's watch what happens
when that happens is the performance
improving is the user having a better
time are we do we think this is the
right thing to do yes okay let's roll
more traffic over oh no hang on a second
we observe in our 1% canary that oh look
the queues are getting blocked up
something's backing out something's gone
wrong oh dear
we've introduced the burgh let's not
actually roll out that anymore of that
let's shut the canary down so that's
content of release management so to do
this you've got to have your pipeline
this is a amateurish picture of a
pipeline little acronym to help you
remember is ABCDE you app tools like
your IDE or your git and then your build
tool there are lots of really great
build tools out there so you can choose
your own adventure here we use circle
see is we've works it's a nice little
tool another very similar one is Travis
Travis CI there is of course Jenkins
which is very widespread and the
commercial company doing very well
cloudBees which is the Jenkins company
there are other tools like shippable
gitlab most of the big clouds and they
have their own tool there's a Google
container builder for example and
because we're in the container world of
cloud native you generate containers
from your build and config artifacts and
then you've got to get these into your
running cluster so that's the deployment
and release automation step so that's
your pipeline
okay this is quite interesting bit
because now I'm going to say a few
slightly more detailed things about Cuba
Nettie's itself right so Cuba Nellie's
has this concept which was introduced
about a year and a half ago called an
operator and an operator is essentially
an agent that lives inside cuban areas
and shares its lifecycle and takes
responsibility for starting and stopping
things that cuba nellie's itself does
not natively know how to do so it's
really a customization tool for adding
things to cuba Nessie's in a way that's
consistent with how it operates and
there are examples of operators out
there like for example the @cd operator
or the prometheus operator we've written
a service for doing multi tenant
monitoring with Prometheus which is
essentially as a Prometheus operator
starting up as many Prometheus instances
as you like in Cuba Nettie's and
managing that and scaling it up and
scaling it down and making a
multi-tenant it so that's kind of thing
and operated us you can do deployment
using an operator because what you're
doing is instead of letting your CI tool
push artifacts willy-nilly into your
running system you actually let that
some inchoate live in here take on the
role of being responsible for deployment
and be responsible for looking both at
the get code and config and at the
service and what community thinks has
been deployed and making sure that they
are the same do you see the difference
for this is an active process is running
all the time it's checking this
periodically it's checking this
periodically and if they're DIF
reconciling them so you have desired
state observed state and it's making
sure they are the same so this is
extending the idea record of
orchestration so it's really a
deployment orchestration operator this
is very different from pushing things
and hoping that it will rub okay does
this make sense I hope so
so just to recap we want to do get ups
we want to have everything being get so
configures code and everything is config
with in the declarative world so that's
relatively straightforward and therefore
everything has to be version controls
and again something else that the
operator has to do is record changes
that it makes as it's doing the
deployment so that the desired state and
the observed state are the same so that
when you've actually completed the
deployment you can go and look at get
and the deployment operator will have
updated everything saying this is now
moved from a staging into production now
these are the images that were running
and they're associated with these
services and now all in a correct State
after that things may well go wrong but
you're in correct State at that point if
you want to do this yourself and you
don't have any config to hand you can
extract it you know there's a tool for
this which is called excitingly cube
cuttle export and if if you widdle
around with this you can get your
kubernetes to give you things that you
may not have in terms of your confit
okay and you should look at what it
gives you because it may not have the
things that you expect okay this is
quite a nice example
what about secrets so kubernetes is
intended to run large-scale multi-tenant
multi-user multi everything systems
which means that we need to care about
security and we also need to care about
who gets to mess with the system at time
different times so we have secrets which
let different people do certain things
the system at different points and those
systems mind those secrets might need to
be rotated for instance so let's say
that somebody leaves the company to go
and get an exciting job at another
company and so they then have
credentials into the system you might
rotate our secrets out so they can no
longer get in through the backdoor and
you know in get offs we want to keep
everything about our running state and
our desired state and get how do we do
secrets because it's bad practice to put
secrets in because people can go and
find them there and they're not secret
anymore
so--but Namie another company that we
work with came up is really cool
solution called sealed secrets in which
you encrypt the secret before you put it
into gear and then you have a mechanism
so that cuban Eddie's can decrypt it
pretty cool huh
so effectively you're sending secrets
inside sealed envelopes when you do a
deployment and you can do everything
once you've got that you can do
everything exactly the way I've
described as if it was unencrypted so
that when you have a disaster recovery
situation your whole system blows up all
you need is the initial private key to
unlock all the secrets in the cluster
which means that you can recover your
full state from gear and the way that
works is how hides another operator it's
the same technology that we use to run
monitoring cassandra my sequel Redis and
flux deployment in communities clusters
we can also use to do encryption and
decryption so it sums up so how do you
organize your code and repos if you want
to do get-ups we typically recommend
that you split your config off into a
separate repo because what you don't
want to do is when you update your room
config trigger a build otherwise also
split things up by service and
application as much as you can and
different branches per environment so we
typically will see staging and prod all
or three or four stages different kinds
of staging it's very important to be
able to split staging from production so
that you can make sure that everything
is correct in your staging system before
it runs in production I hope that's not
too much of a teaching unisex type of
statement but it's very easy to make
mistakes even and these are more
advanced systems that you need to check
in staging and then push all your
changes including health checks to
branches first why would we push health
checks into a staging branch because if
you if you made a mistake and you'll sit
in your health check if that was wrong
and he accidentally told you a whole
system was unhealthy and he were in
production it would shut the whole thing
down whoops so you want to actually
check both the monitoring and the
running system
which is why we go we're saying kid ops
is more than just infrastructure as code
it's also health checks is code
monitoring is code applications as code
everything is conflict lastly how do you
do production changes you do emerge you
go from staging to prod and get and off
you go the same thing happens in
production it's not driven by CI it's
driven by git and the deployment
operator because the deployment or
theater goes aha
something has changed now I need to do
update the running system and here's a
picture of that so this here is your
fairly typical CI CD pipeline as
currently conceived in most of the
developed industry and here's what you
get by adding the concerts I've been
describing of having a deployment
operator be responsible for reconciling
changes that you intend to write in
production with your actual observed
State so you're adding this to this when
you do get up Spacek me okay so the key
thing here is the really important bit
when you do a roll out into production
and you emerge the configs will get
changed and the images that you want to
roll out will be changed in the config
and this will notice that and I'll go
are the desired state and the observed
state are different I need to do an
update they'll keep working on that
until it's correct okay so that's the
pipelines piece the most detailed the
second piece is observability which I
hope will be very intuitive so
observability it's an ility it's an it's
a property of your system it's a lot of
thing that you do I don't you know do
observability well you do it if you're a
vendor I guess as a an owner of a system
you don't do observability it is
desirable that your system is observable
in the same way as it's desirable that
it's secure it's desirable that it's
available but when it comes down to it
it's really bringing together a few core
tools monitoring logging tracing events
visualization error report
etc to create the most comprehensive
view possible into your system the key
difference between observability and
monitoring is whoops hang on I'll go
back to that in a minute
just jump a couple slides ahead the key
difference between observability and
monitoring is expressed by charity she's
here this afternoon by the way so please
go to her talk our charities amazing
talking about observability monitoring
is a tool that you use to tell you
things that you already know are
important you're trying to make sure
that all the critical things you may
want to get alerted on are in your
monitoring system and just though so you
don't get overwhelmed observability is
everything else that you might ask after
you start to try and understand what's
going on in the system especially if you
are a developer how does that play out
here here's a nice rule of thumb from
John Observer observability driven
development don't merge that pull
request unless you know you can check
that it's correct or incorrect after
you've merged it so you want to be able
to use your view into the system to
verify that we did is correct this is
particularly important with the tool
like kubernetes because it's automated
its virtualized it's running everywhere
it's doing a lot of things for you so
you don't have that old way of just
checking the system that the app is up
except going to the website but if you
want to check other things about it like
has the right number of replicas or
something you know you need to look at
it and this is a rather jokey comment
but I think it's not it's also serious I
mean it's like TDD for production it's
the whole concept of production is the
new testing which is obviously an
interesting idea observability is
intended to encompass a lot of things
and user happiness when I make a change
does it make my users experience better
always how's that user experience
correlated with what I'm seeing in the
logs traces etc and this is really
important really really really really
important
the old way of doing operations when you
had Devon ops team separated was you
keep you fill up a rule but a playbook a
Rundberg and they tell you when things
are wrong and they try and remedy them
and if they can't fix them they bring in
the dev team with the concept of
developers being partly responsible for
operations as the example are left the
idea is that the team who's responsible
can actually should be looking for
problems before they happen ideally
because often systems start behaving
oddly before they stop before they
actually go wrong so if you are in the
habit of observing your system and
asking questions of the running system
you may be able to validate whether it's
healthy or becoming unhealthy before
things go bad it's a very similar
concept to get a preventative medicine
being ultimately lot cheaper and taking
people to a hospital and as charity says
it's about understanding your system if
you're the owner of it so that concept
of understanding leads us in get ops to
have different kind of dashboard which
doesn't only have so this is rather a
bad picture this is a lift thing doesn't
only have metrics but also has logging
events and we can correlate activity
with results and here's a picture from
brief product plug our own product
screen where you do a deployment and you
see the results immediately in your
matrix and that allows you to do more of
the same deployment in the release or
roll things back if things are not going
well so that's the concept of a get ops
dashboard that is emerging what you're
combining different aspects of a system
to be able to make better decisions
faster and so the last pillar is control
which is the opposite of observability
it's really about how you change things
and it comes down to this concept which
I've wrapped on about a few times is the
desired state same as their observed
state and if I make a change if I want
to change this how do I change that to
change this so it was very space that
can happen
orchestration when that's not working
you can use different sync tools and if
that's if all else fails is use cue
cuttle what we'd like to do is be in a
world where we can do something like
cube cut apparently to the system here
and introduce a get commit stage so I
get the experience of messing with my
running system but I'm actually obeying
the rules of get up so that I don't get
out of synch with everything with my
desired state that's an interesting
problem to solve here are some examples
of the kind of changes we're talking
about systems not responsive roll back
to the desired state you know are my
metrics telling me that the system I
release is too slow or too fast
my differ lurtz firing is something
coming up in chat ups and so on I'm not
only dwell on this a long time so this
leads you to a service life cycle which
I wanna talk about for a few minutes I
talked about desired state and observe
state and checking in the difference
between them this actually drives a
cycle so you go from get into kubernetes
you monitor and log it and you then
operate based on that and this is shown
here so this is really a picture to try
and show you conceptually what I think
you are doing when you do operations if
you are an SRE doing get ops this is
what everybody should be doing you've
got these phases that you're going
through and you have an endless cycle
and the objective is to go around this
as fast as possible the more you can go
around this quickly
the more you can iterate quickly with
your in and make your business happy
because that's the idea and therefore
the more you can make your customers
happy so I start from git I update
something I do release I'm now in given
nephews I observe it these are the tools
I'm using they do all kinds of different
things so I need to already take myself
and make decisions about what to do
that's the operational role that might
be automated or it might be a human or
it might be dashboards and humans
then I act by updating something and
then I'm back in get because that's the
place where all my actions must land and
then we go around again operations is a
simple cycle that goes round and round
around like this for everything so if
everybody can master that then they can
do cloud native operations if you're a
developer making it very fast you can go
from a couple of deployments a week to
30 or 40 a day in a small team so if a
few end observations to kind of wrap up
the talk one is a kind of you know what
is the sort of core idea here that is
that if you can describe and observe
things and you can control and automate
them which is what Cuba now this is
doing for you with orchestration
reconciling desired Meserve state it's
what we're doing with the weave flux
open-source deployment Orchestrator
desired an observed state it's what the
sealed secrets are doing from bitNami
it's what you should be doing for the
whole stack indeed only what you can
discern described and observed can be
automated if you can't describe an
observe it you can't automate it so what
are the core principles what you must
you do there's really these three things
you absolutely must be declarative is
very very difficult to do this with
idempotent imperative scripts you must
do all the get review melodrama in order
to actually get changes into the system
the upside of this is you can ditch a
whole lot of change management and
compliance gubbins that you might have
had to use before don't use cue proper
directly if you can avoid it and finally
you've got to drive the difference
between the desired in the observe state
to consistency to conversions which is
provided by things like the operator now
if you want to go and do this there are
three ways you can do it today one is
you can go and use our product which has
a free tier which combines deployment
and observability to do some of the
things I've talked about or
you're one of those people who
absolutely master the open-source thing
first we have an open source deployment
operatically flux or you can go watch
Kelsey's demo which myth us out this bit
but actually has kind of 75% of the core
ideas there as well and these are all
consistent with each other they're not
competing approaches okay this is more
decomposed you can sort of see the
machinery and learn more about how it
works which is how Kelsey loves to do
things when you realize it it doesn't
kind of make sense to be programmatic
you might want to use an operator and if
you want to have a product world go
ahead and so what are we doing here
we're brick we're taking operational
concepts and practices and tools and
putting them in the hands of developers
because if you can merge a pull request
you know in my view then you are an out
developer and if you can if you use
cloud native tools you can describe them
and get so you can operate them in get
to that's what get ups gets you and by
the way github is very popular it's got
about 25 million users now and I think
they'll be about 100 million in kind of
in no time so does anyone have any
questions thank you for listening to me
about this appreciate it
hello okay yes
because what we do that's all we do at
the moment yeah we do the whole thing
just push it straight through yeah yeah
so right ours is a bit faster than that
but but there was always going to be
some interval and my that interval might
be too long so what do you do if the
interval is too long to do the updating
get so that's where I was going with
this thing about the unsolved problem
you know you know how do you know that
if it's been pessimistic and optimistic
concurrency so with pessimistic
concurrency a pessimistic approach to
this would be to say you can currently
change a the running system and you
change gear and then you make sure that
get the get changes push through so it's
the same as the running system so the
whole things like the two-phase commit
across get and the running system which
will be which will be slower you could
imagine doing it optimistically where
you make the change the running system
and then afterwards it tries to update
it for you and then if something goes
wrong it tells you that didn't work out
now that obviously has some downsides
but I think that would be the way to
make it faster but it's an unsolved
problem anyone else got a question hello
I think the best way to do it is through
the examples of people doubling their
productivity by introducing faster
release cycles and also talking talking
through so if you go to my blog the
latest blog on get ups which I published
just this week which is ennui works blog
in fact hang on the same so this is a
make a note of this address you'll find
that there are some blog posts about get
ups on on it that I recommend reading in
the latest one there is a link to a
another blog post by Adrienne Collier
who is on the board of our company
Adrienne writes an excellent blog post
but a local that they're dead sorry the
daily paper which in which he goes
through technical papers and explains
them to people and he wrote one last
year on continuous experimentation which
I recommend reading and that basically
talks about how once you reach a certain
velocity in terms of your ability to
deploy end times per day or per hour you
can start to experiment very quickly and
what kind of experiments might you do
well for the business they might be
things like a be testing let's try out
two different things for our customers
or you can have you know let's try this
out on our premium customers first and
see if they if they like it there's also
be just a very basic which is shown in
my my example I'm customer response time
reduced by about 50 percent so if a
customer calls up and says you know
you've got a spelling mistake on my form
and I'm offended you can fix it twice as
fast and then also fixing issues twice
as fast the other one that I mentioned
is compliance you know doing all of this
in such a way that you're lowering your
cost of compliance is actually very
compelling from the business for that
perspective so velocity in compliance
anyone else
would anyone like to say anything at all
thank you very much okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>