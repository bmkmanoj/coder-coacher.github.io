<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Secure Programming Practices in C++ - NDC Security 2018 | Coder Coacher - Coaching Coders</title><meta content="Secure Programming Practices in C++ - NDC Security 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Secure Programming Practices in C++ - NDC Security 2018</b></h2><h5 class="post__date">2018-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Jh0G_A7iRac" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi and thank you for coming here and not
the Scots talk okay so first of all
this is going to be the talk with the
most code that I've ever done and I've
never done it before so this is gonna be
the first time so how many of you would
be comfortable looking at C good because
you will and at any point if you feel
there's too much C you can just like
sneak out the back line
okay this is on the grown-up title and
then I realized when I came here that
having a grown-up title was not the norm
but my grown-up title when I pitched was
secure programming practices in C++ but
then I realized that that was wrong so I
asked somebody on Twitter to suggest and
I got a new title so how to avoid
blowing your leg off with C++ C that's
more like in tune with the thing okay so
Who am I I am Patricia oz I work as a
programmer I programmed my and C++ I've
done so for about 12 years and I've
worked on two browsers I've worked on
the original opera browser and I am
currently working on the Vivaldi browser
and all my slides are on my Twitter than
my pin tweet so you can get them from
there and all my photos are from pixabay
okay so we're gonna start with the two
quotes from Vienna that were in the
intro scene makes it easy to shoot
yourself in the foot C++ makes it harder
but when you do it blows your whole leg
off see that's what I the title came
from yeah so this is this is this is
like the the feeling most people have
when when seeing C or C++ and I'd like
you to not get there so then we'll go
and go with me on a second quote with in
C++ there's a much smaller and cleaner
language struggling to get out and and
that is the goal of this talk but first
we're going to go through all the
pitfalls well not all of them but a
bunch okay so the first question when I
was preparing this talk is what kind of
specs exists in this base because we're
talking about how to do secure
programming and
there are certain resources and I ended
up landing on three that I wanted to
mention so the first one is not that
famous even for C++ developers and
there's only a few years old and it's
called a C++ core guidelines basically
it's an outlining of how the top people
in C++ feel that good C++ should be and
it is worth browsing but it is quite big
and the thing is that's what you will
see from all these specs they're huge
this is actually the smallest one so it
doesn't really lend itself to reading
but this is a very important one
and it has to do with that with coding
standards so secure coding standards
almost many languages you'll find a
section for that language like Java has
one this is the one for C++ it's 435
pages but in addition to this one of
course you get to see one as well so
it's a it's big and then you have this
one this is the common weakness
enumeration I'm going to use it a lot
throughout the presentation but it's
huge so but it's also worth browsing
maybe III tweeted a link to the C slice
of it and and quite a few of the ones
that are there I'm going to talk about
today so the the whole idea is that
going programming C C++ it's basically
there are a lot of dragonss
so this is the slide with the most text
and I'm going to read it but it's very
important so I'm going to read it
it's about undefined behavior which is a
very important term in C++ examples of
undefined behavior are memory accesses
outside of array bounds signed integer
overflow null pointer dereference
modification of the same scalar more
than once in an expression without
sequence points access to an object
through a pointer of a different type
etc
compilers are not required to diagnose
undefined behavior although many simple
situations are diagnosed
the compiled program is not required to
do anything meaningful okay and this is
the most important thing coming from a
managed language and moving into the c
c++ space this is a thing this is this
is in this is in the specification there
are parts that are just considered to be
dragons and it's your your skill that is
supposed to avoid these dragons so the
most important things there are three
things that you should internalize with
undefined behavior first of all don't
try to reason about it it's very it's
it's the thing the programmers often do
when they try to be cool they try to
think like yeah this is undefined
behavior but and then they try to reason
about it don't because it's getting
progressively difficult to do that and
we'll get into why a little bit you can
just assume it crashes or it's never
executed because that is allowed you can
just skip it changing your compiler or
changing your compiler version or you're
off to my station line level can break
your application if you depend on
undefined behavior and this is very
common and often how people discover
that they are depending on all an
undefined behavior is that they changed
out after my station level and suddenly
parts of their application don't work or
it crashes and we're going to talk about
one of those cases now this is not
undefined behavior what I'm going to
talk about here it's basically in line
with specification and it's very famous
in C++ see and it's caught it's the case
of the disappearing memset that's a very
pretty picture oh sorry I'll go back you
can take oh no wrong way there you go
take a picture it's pretty is one of my
favorite slides yes this is this is the
perfect reading up sign okay so this is
the code from from this and they are
enumerated these common vulnerabilities
things so you have C
w/e 14 and it has actually this code
example in the text
it's compiler removal of code to clear
buffers and the reason why this became
very famous is that suddenly this is
something that hit a lot of applications
and the idea is you can see from the
code is that basically you are getting
you're storing a password on the stack
but it could be anywhere and you're
getting add the password from the user
storing it in this PWD and then you're
doing a thing and when you're done doing
the thing and using the password you are
returning blah blah blah
and at the bottom you want to to zero
out this part of memory that has the
password the reason for that is if you
in any way somebody can get access to
your memory in different kinds of ways
you don't want this to be lying around
in your memory in plain text so
basically you want to keep it as short
of a time as possible in memory but what
happened was that with a modern
optimizers this was considered to be a
dead store dead store meaning it is
trying to write to memory that is never
read again a dead store is allowed to be
optimized away and so what happened was
that programmers in good faith said okay
I'm going to zero out this memory but
the optimizer decided we don't have to
do this memset because nobody's going to
read this and a lot of things were left
in memory that was never intended to be
left in memory so the solution the the
solution that I hope will be the
standard and is currently the standard
in most platforms is the first one here
so it's basically exactly the same as
mem said except as this underscore s and
it's guaranteed not to be optimized out
so that was the solution that Windows
had I had another solution from
previously
secure zero memory and it's basically
the same thing if you are in this
scenario if you have code like this in
your application go read these pages ok
before don't don't take my word for it
it has different it depends on which
version of C you're in and all sorts of
things with
platform you're on make sure you study
this okay but this is the fun part so
we're gonna go through ten normal or
common famous vulnerabilities and and
show you how they can appear in the code
okay so the first ones are around
integers Oh was I too fast again
see but it's my slides are up okay so
we're gonna do this go through unsigned
integer wraparound sign integer overflow
and numeric truncation error
so first unsigned integer wraparound and
again you can see that I have the number
for it for so you can go look it up
again but basically this code it looks
like a lot but we're gonna see it
several times so just pay attention the
first time and let you get it next time
basically what it's trying to do is
concatenate two strings it's not very
easy to see because the code is very big
for this is C so there you go so
basically here what you should pay
attention to is the first leg and the
second leg the first leg is set to you
int max which is the biggest number that
there's room for in an unsigned int the
other one is 256 because it's a nice
number so and then you have the buffer
that we're going to copy these two
because basically we're gonna try to put
first and second inside a buff after
each other so we're concatenate two
strings we have a new string but the
buff is only 256 so we want to make sure
that these two strings that we're gonna
put together this is a this is a
contrived example but if it's on the
slide right so we're gonna make sure and
like if that you know if you add the
first length to the second length and it
has to be less than or equal to 256 that
is our garden to make sure that we don't
write outside above the problem is that
unsigned integer in c and c++ wraps this
is not undefined behavior this is
defined behavior it wraps so if you have
a first length then you add to the
second line then it actually turns out
to be 255 which is less and
you go straight in and you copy woohoo
way past so then we go to the next one
silent it overflow look the code very
simple similar here and now we have an
integers and now we're using integers
integer overflow in C and C++ is
undefined behavior
remember undefined behavior is you have
no idea what's going to happen and
basically this will be different on
different compilers different platforms
you will see different results the
actual number you get will be different
when you overflow and also can n it also
depends on after my station level so
this is like definitely undefined
behavior territory but you have the same
idea we're trying to make sure that
we're not writing over so we're checking
that first length and second length is
less than 256 but unfortunately when the
sign enters your overflows it often
overflows into negative numbers so this
will be a negative number which is less
than 256 and we still go in and poof we
write over lots of memory then we have
numeric truncation error in this case
you're trying to put a number that is
too big into a into an integer that is
too small
basically 1 is so in this case an
unsigned integer you're trying to put an
unsigned integer into an integer and you
can see that in that line which says int
newland so in this case we're just
putting the the expression into a
temporary variable because it makes it
more readable right and the problem here
is that first line plus second line
still fits in an unsigned int it will be
you in max but unfortunately you're
putting it into an INT where it doesn't
fit and this is not undefined behavior
this is implementation dependent
behavior which basically is the same
problem it just means that this time the
actual compiler will have to tell you
what happens but it can depend between
implementations or compiler so for you
it does really matter
in an clang on Linux I get minus 1 and
minus 1 is less than 256 uh poof I'm
we're back okay so then we're gonna do
stack place buffer overflow and heat
base buffer overflow and buffer
underwrite slash overflow underflow okay
this one's much shorter this is much
easier yes so this is our main we have
our stack allocated buffer and then we
just do a guess which reads from the
terminal and then you can just write
something that's bigger and it will
overwrite your stack okay today you
mostly get a warning if you use gets but
you can use other things to achieve the
exact same thing I just wanted to put
gets on one slide so there you go that's
a good slide okay and then we're gonna
do a heap base buffer overflow so if
your allocated memory on the heap and
here since mine see we're doing it with
malloc and so allocating our tiny little
buffer and then we're copying in one of
our command-line arguments again
untrusted input when we're just writing
it to a random place in memory and we're
writing outside again and this isn't the
most important thing I think to know
from both C and C++ is that you can do
this it is possible to write outside of
your your specified region and you don't
have to get any kind of exception or or
a segmentation fault you could get a
segmentation fault especially in this
case you probably will get a
segmentation fault
but if there is valid memory right next
to this and that's what they do when
they make an exploit using this
technique they make sure that there is
valid memory right next to it and then
they write into that okay
but for under-ripe underflow and here we
have our fabulous low world now this
code and I'll do a another version of
this code later it's not very
interesting but basically the idea is to
remove all trailing exes this case we
don't have any trailing exes which is
very unfortunate because if you look at
the while loop it says we go in here
as long as the current character isn't
an ex and when you find an ex I want you
to put a zero there instead the problem
is there are no X's in hello world and
so this one will instead of writing past
the end this will go past the beginning
okay so let me go to use after free or
double free these are pretty easy to to
write but it's not very easy to
understand how you would end up that way
so and I use after free you freed it and
then later you use it and generally this
the the code that you will see will look
something like this because there's not
something that will happen all the time
it will generally happen in some kind of
weird branch in your code but generally
in this case you're having some kind of
error and so in the error handling code
you're freeing the buffer and blah blah
blah but you will often see is that
people don't have proper testing for
their error branches and so you will see
serious mistakes being only executed if
you end up in an error situation so here
the buffer is used after free and double
free is the same thing because generally
it's like somebody had looked at this
code and then they ran it through some
kind of memory analyzer thing and they
say oh no it says the buffer is leaked
so somebody just puts up this free
buffer at the bottom but unfortunately
somebody before way up in the code had
already freed the buffer in an error
again it's very common that this is the
these are the kinds of cases where you
have this okay and the last two is
incorrect type conversion /cast and use
of external format string so this is
very recognizable to people where it's
and C and C++ was very weird for people
coming from other kinds of languages in
C and C++ you can hard cast something to
something it's not it's a feature
so and we call this in C++ we call it a
seat cast or a hard cast and you can see
here on the bottom line that a is being
cast to a B when a is clearly not a B in
any sense and this can this can be used
for many different things because you
know that the pointer to a is a valid
pointer pointing to valid memory and so
so you have it is allocated and and now
you can you can manipulate it in
different ways by pointing a B at it
instead it's very useful okay and then
the last one of these common
vulnerabilities is the use of an
external format string and this was a
very popular exploit and it is a little
bit similar to a sequel injection the
idea is that you are taking in some kind
of string from the user and then you are
actually treating it like safe data in
this case here I I'm running this
application here it takes the format
string is the first argument and some
kind of other string as the second
argument and then it's supposed to print
that string with that format sounds very
useful so basically I just pass in % as
yes great I want to say hello world that
also want to present and do % D and then
I'm printing random memory it's great
you can do all sorts of things here
anyway so that was that was the danger
the Dragons right and this is this is my
opinionated part of the talk and it's
called the eight I'd really rather you
didn't and for people don't know sperm
test affair you know someone is really
great so you should look it up it's also
it's another word for it is the eight
condiments and yes anyway so we're gonna
go through but before I do because I
know this is going to go home video and
C++ programmers are very opinionated
fearful that so don't take me too
seriously but
seriously think about it okay so these
are my eight and I'm going to go through
for them more in detail and for them not
so much so the first four is I'd really
rather you didn't you see I'd really
rather you didn't allocate with new I'd
really rather you didn't do math a lot
I'd really rather you didn't trust your
external input the other ones were write
clever code use pointers a lot
you shared pointer a lot and use threads
a lot okay so the first one and this is
going to be the longest one I'd really
rather you didn't use C and you saw all
of the problems that I went through and
those are all of those programs are C
programs and I wrote them intentionally
as C because yes you can write C and C++
but I'd really rather you didn't if
you're going to concatenate strings this
is how it's done
do it with C++ you do it with A+ you
take first plus second it's really not
harder than this this is how you're
concatenate two strings in C++ if you're
going to read from the command line into
a string or from a string and out you do
it like this
don't be allocating all sorts of buffers
don't be reading stuff into stuff that's
too small this will size itself properly
this is how we do it in C++ you can see
that we're we're making an STD string
first by just setting it equal to our v1
that will make a string of the proper
size you don't have to make stuff up
okay and use algorithms so this is this
is the really modern C++ way of removing
the exes at the end of a string so first
here in the first line we have lambda we
can do lambdas in c++ use lambdas and
suppose plus second one is we're using
that land lambda in our find if and
we're searching from the end and we're
stopping when the character is not an X
then we're using erase on our string
from that point until the end notice one
thing that's very important here there's
no math there's no integers anywhere
here and then you have C++ casts we
heard of our C cast and C and hard cats
well this is how if you really really
really really have to and I'd really
rather you didn't have pointers I'd
really rather you didn't allocate with
new but if you have and you are then
this is how it's done so in this case we
have a spider-man and we have an Ironman
and we're allocating a spider-man and
then we want our Ironman to point to our
spider-man but that's not right because
a spider - not an Ironman and if you
compile this you will have a compile
time error saying that a static Astros
but this is with clang static cast from
spider-man to Ironman is an error which
and these are which are not related by
inheritance is not alone and then it
shows exactly where this is the thing
that I love like lying they have this
like really really pretty little arrows
it's like ah I love it
anyway okay so if you have to do a cast
and you're thinking you're doing some
kind of relatable things then use the
static cast you will get a compile time
error if it's not okay
the second one I'd really rather you
didn't allocate with
new now the ones that you see next to
here there are references to to the core
guidelines and I'm doing that mostly
because that's works really effectively
with C++ developers if we refer to the
court guidelines because it's like the
law
but anyway so you can look them up so
this is actually these next couple of
slides are from a talk that I did
earlier this fall which is online you
can watch it it's C++ for Java
developers but basically this section is
that I don't want you to to allocate
using new and the reason for that is
that if you have new you get a pointer
on a pointer is something that points to
2 somewhere in memory and this is not
like a pointer in any kind of other
language this is a raw memory address
and it is dangerous to have a raw memory
address because you don't really know
anything about the memory it points to
all you know is what kind of pointer
you're holding
but this object could have been deleted
by somebody else this pointer can
actually be pointing to totally
different type of object you don't know
anything about your pointers so I'd
really rather you didn't have pointers
and how you get pointers with with new
so what I would like you to do is use
the stack so you can allocate on the
stack here Oh H semicolon gives you a
hero it's on the stack and I'd like you
to use this back so first of all here
you have this hero and it's a stack hero
because it lives on the stack but you
might also need to allocate something on
the heap on the bottom you see a normal
normal new where you getting a pointer
back and I'd rather you didn't do that
so then you have the one above so if you
have to allocate memory on the heap then
do it with a unique pointer and hold the
unique pointer on the stack or
transitively on the stack so something
on your stack is holding something
that's holding something that's so that
when the thing on the stack goes out of
scope transitively all of these objects
are deleted this will avoid both double
deletion and will also avoid
memory leaks and it will also avoid use
after free because these things are
owned and nobody holds a pointer to
random memory so here you have and this
is some people like to say that this is
a deterministic garbage collection where
the garbage collection happens at the
curly bracket
so basically when the string goes out of
scope its destructor will be called when
it hits the curly bracket and the object
is the allocated so using this is how
you control memory lifetimes and that's
what it says here so using the stack to
manage resource lifetimes and does not
only have to be memory it could be any
kinds of different kinds of resources
like locks you want to release or file
handles so you want to release any kind
of resource can be used in the same way
and this is how it's done so in this
case you have two different types of
pointers you have the unique pointer
which is how I would like you to
allocate a heap memory but you also have
the possibility of using shared pointer
now if you're coming from managed
language that is very appealing that's
why it's it's a separate point on my
list I'd read the rather you didn't you
share pointers a lot and the reason for
that is in C++ on + C we are we are it
is a culture of managing your own memory
you have to somebody owns this memory
somebody's in charge of this memory we
are like this is like a thing if you
want to program like a C++ programmer
you have to have control of your memory
and know who has it and how long it
lives and share pointers have all the
problems of reference counting and that
it you could have circular ownership and
it will never disappear ok so those were
my two longest ones and this is probably
my most controversial one I'd really
rather you didn't
to math a lot now you saw from from all
of the vulnerability sites right that
was that was a problem all of that all
of the wrapping and overflowing and all
of these things ends up in a bad place
and most of the time and you use these
things for things like copying strings
and copying buffers and copying arrays
and then you have to have pointers and
all sorts of things I think you
shouldn't be doing and the reason for
that and this is true in even in managed
languages primitive types have no
semantics they don't tell you anything
if you have an int it isn't a thing it's
just an int it doesn't tell you what it
is and it doesn't have any kind of of
semantics to it so if you have an int
and you say that as somebody's age an
int can be negative it doesn't make
sense
somebody's age cannot be negative but
what it does have so it has no semantics
but it has limits normal people are used
to you can count to infinity you can't
counter an infinity with a primitive
type it's not possible so it's actually
quite a bad representation for the
things that were using it for so what I
would like you to do is to reduce the
value space of what is correct values to
keep and also to keep within defined
behavior to make sure if you are using
an int and you are incrementing it or if
you're using an int and you're getting
that number from somebody else
you are very quickly landing in
undefined behavior so I'd rather really
rather you didn't so we're going to look
at a couple a couple of different things
in C++ around this that I'd rather use
the first one is enum class and it's
quite recent in the newer versions of
C++ um so most of you are probably used
to eat UM's and C and it's C + bus and
those are basically implicitly converted
to int again I'd really rather you
didn't have any it's enum class has
no implicit conversion to int it's a
thing it's a thing and it can be many
you can have it have many things so in
this case normally you could just write
enum class direction but in this case
I've been creative so I'm doing enum
class direction : car and then I can
actually assign a specific character to
each of my directions so north east west
and south and if I were trying if you
skip the middle part and if I tried to
print it it wouldn't print anything I
actually have to provide a function to
show what I would like to be printed if
you try to print this enum
there is no implicit conversion of an
enum class you know to anything this is
type safe so two different ones then
that's a problem from C if you have an
enum a and an enum B and they are both
implicitly converted to one if you
compare them they will be the same
because you have an implicit conversion
to int in this case that will not happen
they will be different even if you have
explicitly said that North is more than
East is two there these are type safe
enums this one is not so famous but i
like it because it's kind of pretty
yeah so this is string literals what
you'll see here is i'm and we're using
also auto because c++ as auto auto
heroes and then you have spiderman and
you have this like lowercase s Ahriman
lowercase s and when a woman lowercase s
and this creates an object which is a
string little and we're getting it from
this using namespace thing on top and in
my for loop I'm looping through all my
hairs of course you can have this curly
bracket thing in my for loop and that's
what I did in the beginning but it
didn't look good on the slide so I got
it's on line but basically it means that
you can put as this list of strings and
loops through them and these
kinds of constructs are useful usually
in tests where you know what you're
going to be looking through in like
production code I in my experience you
don't have a lot of this but in tests
you generally have a lot so that's
string literals there are no int there
are no numbers here and then okay let's
say you have to have some numbers now
I'd like you to make those numbers a
little bit more type safe so here you
have an H which is 24 underscore hours
and then you have a D which is seven
underscore days and then I try to add h2
D and I get an error from clanging again
fabulous error saying that you can't add
hours to days remember what I said that
integers have and and and primitive
types have no semantics what I've done
here is I've added semantics and I'll
show you the code to make this right now
okay so first of all we're making two
types of structs they have both of them
are the same you have an hour's it has
takes an unsigned long long and it
basically just stores it this is a
structure all of this is public and days
the same so no magic then I make a
operator quote unquote the operator
quote unquote I put this this suffix
that I would like to have to my number
so underscore hours or underscore days
and this is a kind of a builder it calls
the constructor for the different kinds
of classes or instructs in this case and
so that the things that you get back if
we go back a bit so 24 underscore hours
will make an object of type of type
hours with a passing 24 as the
constructor argument which means that
later
when you try to invoke operator plus on
these two things these are two objects
of two different classes so unless you
have made an operator that makes it
possible to add hours to days this will
fail compile time let's see okay and
then you have size T and if there is
something in my talk that I'm most kind
of like I'm not totally sure about it's
this I would like to say that you should
use size T for all your sizes and I'm
pretty close to that in my head which
means 95% basically size T is the result
of doing a size up it's also often now
the result that you will get from all of
you lengths or sizes of any kind of
container
the one problem that I have with size T
is that it is platform-specific and it
is also 60 to 32 bit specific which
means if you're going to pass a size T
from a 32-bit application to a 64-bit
application if you have that they are
not going to be the same size so it's I
would have liked them to both be the
same size but but that's how it is but
within your own application using size T
for size T for all of your sizes is good
it is an unsigned integer type so you
will have well-defined wrap it's the
best you can do you will wrap you won't
wrap two to two negative numbers but you
will wrap again it's only if you have to
use a number right okay and this is my
last big one it's not that big and it's
quite famous so I'm not going to talk so
much about it and it is I really rather
you didn't trust your external input and
this is the concept of taint which a lot
of and which is quite famous a lot of
static analysis but is basically if this
number is coming from or this input is
coming from an untrusted source it
should take everything it touches
so to stop this you have to validate it
you have to analyze it you have to
sanitize it before you pass it in so you
just stop the taint as fast as you can
and this is true for any kind of input
in any kind of application it's not C++
specific but you saw me doing it so like
not doing this several times I was
taking command-line arguments I was
reading things from from from the user I
and but this could be many different
things it could be in media files you
will have or any kind of packet which
gives you like a length field or
anything that you use when you parse
these are very often used in
vulnerabilities especially like these
types of header things are used very
much in vulnerabilities against media
applications because it is it is
external input you're getting in if
you're parsing it and you're treating it
as true then you're vulnerable so
basically here is look at all your input
and the last these last four are there
there are more general high-level things
I'd really rather you didn't write
clever code and the reason for that and
and it's true there's a quote I don't
remember who said it but basically it
says that if you write code that is the
most advanced code you can write
something like that I don't remember the
exact quote and then you are not capable
of debugging it because debugging is
harder than coding the idea here is try
to write code which is as simple as you
can it might not look impressive but the
thing is code is more is read more than
it's written in general almost every
line of code in your application is read
many many more times than it is written
so don't try to be clever because you
might think oh but it's perfectly
understandable I understand all right
now okay for it you can start with
thinking of your colleague will your
colleague understand it right away and
then will your future self understand
so don't be clever I'd really rather you
didn't use pointers a lot and I go
through this a lot in my talk for the
C++ for Java developers because this is
a problem that they end up in often it
is because like I said before it's
dangerous territory almost all of the
vulnerabilities and the hard core bugs
that you get in C++ are because you're
using pointers this is where you get all
of your weird stuff of double freeze and
use after free and memory leaks and all
of the really horrible segmentation
faulty stuff is because you're using
pointers so try to eliminate using
pointers and the best way to do that is
start by saying I'm not gonna free I'm
not gonna new anything try you might not
be able to pull it off but you might be
able to isolate the code that does the
new in very few places in your code this
I said before I'd really rather you
didn't use shared pointer a lot and and
the thing is a lot of people feel like
this is very appealing and I've talked a
lot about it with other C++ programmers
and I would say I would like you to use
stack allocated memory either using the
memory on the stack or using some kind
of container which is has a handle on
the stack which most containers have in
the standard library so I say use that
for 95% of your memory 95% in your
memory should be standard containers
that you have in the stack or your own
memory on the stack basically your stack
don't do anything fancy
don't make your own containers 95% to
remember she'd be here and then when you
have to implement your own thing then
use unique pointer for the next X number
percent I'm not sure well you can adjust
a little bit but not much but then when
you come to shared pointers I'd really
rather you didn't use shared porter's at
all but there is a case where where
share pointers is in use often and it is
for objects that you you pass
but you don't really know when
everybody's finished with it generally
that will be stuff like buffers buffers
with input that you give to your
consumers they might have different
kinds of threads and different kinds
there might be in different applications
so there there is very unsure life time
that's the only case really I see
they're using shared pointers is good
but there might be others but basically
I saying don't you share pointers at
least not a lot I'd really rather you
didn't use threads a lot now this is
controversial in many languages and and
there are basically two reasons first of
all threading is hard
using threading and shared resources is
difficult if yes
yeah there are you know and he said that
there dotnet Oracle let's calm that says
there to people just to do threading in
the world and I would say you can do
threading if you don't have shared state
the thing is very often shared state
will slip in later that that's the thing
you you start off as like I have made
this fabulous architecture these things
will never touch but the thing is they
are in the same memory address space
then some intern let's call them that
figures out what the thing is this like
I'm not saying it's his fault and then
you know accidents happen no I don't
have any person in mind um okay so so
basically I'd really rather you didn't
use threads a lot and that first reason
this is very difficult to do well a
second reason is if you really need
concurrency today because threads were
really fashionable in the early 2000s
where we had hyper threading and it was
very cool um today if you really need
concurrency i'd say makes us do the job
for you and separate those address
spaces make processes instead there's no
shared state make processes communicate
override PC you still had to have some
sort of communication if you had to
communicate now make it explicit make it
non accidental if somebody's going to
try to share state it's going to they
are gonna have to work for it
so and and this beacon can easily be
scheduled on different kinds of CPUs
even on bad architectures this can be
scheduled really well and there are
really good IPC mechanisms out there
so I'd really rather you didn't use
threads use processes if you need
concurrency so that's the meat of my
talk is done and this is the one where
it's very short but it's very important
so let's do it
use your tools specifically anything you
can get your hands on
so basically turn up all your warnings
as far as you can make warnings errors
as much as you can use all your
instrumentation your static analysis
your automated tools your fuzzing your
continuous integration your libraries
throw everything you can at it turn your
your your compilers on max optimization
and push it through all of your
automated testing because some stuff
disappears when you do full off to my
session and suddenly undefined behavior
becomes very apparent so use your tools
and resources and set them up into your
integration pipeline so if you're gonna
go away with one thing from my talk as
I've heard that's really important then
it's this I'd really rather you didn't
you see if you go into program C++ make
use of the language make use of the
facilities in the language and in the
libraries to program more safely
don't write C learn some modern C++
instead and that's my talk thank you so
are there any questions yes
I will repeat the question see I can
think well I repeat the question
dear do you know any public repository
with you know good examples of good C++
programs or a code superfast code I
would say probably if you want to look
at what is considered in the in the
community to be the best code then
browsing the core guidelines is very
good it will show you code examples of
different kinds of things and you can go
and look at things I would never ever
ever expect anyone to look at the
standard library it is the most advanced
C++ you've ever seen and you should
never ever program like that
they're like two percent of the C++
developers in the world who feel
comfortable reading the the standard
libraries so don't do that
so look at the core guidelines I think
is a very good place to try to see what
people today consider to be good C++
I don't know of any like okay there are
probably tons the thing is I usually
work in code bases that are quite old
that have been in been shipping for a
long time like when I worked in Opera
the Code West had had been developed
since 1994 when I was now in chromium
that is also an equally old code from
the mid 90s if you think of the full
history of it and and when I worked in
an embedded sector were basically doing
a Linux distribution which again has
quite an age range right so what you
will see in older code bases that you
will see a mix of styles so an older
types parts of the code you will see a
lot of new or delete and pointers and in
newer aparts of the code you won't see
that and so it's very difficult to say
this project is great I've had like I've
had like a class I'd found here and
there where I go like oh my god but more
often it's just like one Island right
it's one developers vision in the middle
of lots of other things so yeah I I'm
not sure I'm comfortable saying this is
great but yeah sorry most actually that
the the common vulnerability is
enumeration was made for static analysis
so basically they have test Suites for
our static analysis tools and so a lot
of these things were made specifically
for that and also the core guidelines
has also been specifically made for
automating things for linting and things
like that so yeah so that's that's sort
of where these things go yes
it's a good one no I try no I I try and
I try to do better and that's that's I
think that's hopefully true for all of
us is that if you look at code you were
three years ago you go like oh my god
and that only means we're getting better
all the time right so yes this is my
goal to write code like this um doesn't
mean I'm always very good at it and it
doesn't mean my first version is like
this but hopefully before I push to
master it looks more like this um so
yeah I hope I hope yeah that's my goal
that it will look like this any more
question is no then thank you so much
for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>