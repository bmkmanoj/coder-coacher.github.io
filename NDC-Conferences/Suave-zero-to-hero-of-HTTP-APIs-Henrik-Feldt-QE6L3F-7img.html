<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Suave – zero to hero of HTTP APIs - Henrik Feldt | Coder Coacher - Coaching Coders</title><meta content="Suave – zero to hero of HTTP APIs - Henrik Feldt - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Suave – zero to hero of HTTP APIs - Henrik Feldt</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QE6L3F-7img" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to the talk this is from zero
to hero with HTTP api's I've been going
through in my mind a lot what to do in
this talk and come up with this agenda
first I want to tell you what's in it
for you
because after all we all go to some
talks and maybe they don't fix everyone
but just to start out why would it fit
you then I'll show you some of the HTTP
protocol why suave so a bit of
background Slav is the web server
I'll primarily talk about but this is
actually a talk also about community and
about building this open source software
so it's a deeply personal experience
which I'm trying to share to you today
it's built a community and in this
community we've found patterns that work
software that works so I'll show some of
those I'll give some links how to get
started and tell you something about the
future of sod first of all let's start
out by erasing of hands how many people
here have heard of sword or used it
that's nice so about 40 percent for the
rest of you let me give you first a
brief introduction what is it well it's
something about HTTP and also me I'm
here like felt I'm at half on github and
Twitter I'm hella Celt I'm pretty
prolific 20 comes to open source
software so I've written a few libraries
saw this one together Adam are expect
our testing framework library logging in
metrics as one for dotnet F sharp and C
sharp HTTP S which is a wrapper around
HTTP web request some minor libraries
for example talking to console a key
value store building with Ruby on net
albacore etc I'm also running a startup
called T to Matilda comm is trying to
automate good keeping for everyone to
make it really easy to run your own
business that's what I've been doing a
lot of three years and we actually have
them Rasmus here with us today
working with us so why would you listen
to this talk
maybe you're functionally curious you're
interested in what F sharp could bring
to the table for your organization or
even just you as a developer maybe
you're interested in website or
construction or maybe you want to free
yourself from heavy-handed web
frameworks fair works that sort of build
you into themselves and then leave you
stuck there all of those things you'll
get a get a hunch about how to fix or
free yourself from today first of all
let's look at HTTP because that's what
all of this is going to be based around
it was invented in 1989 sorted by Tim
berners-lee he was working at CERN and
invented it as an information retrieval
system he wanted to share research with
other scientists quite a bit later
everything was standardised and
formalized so the internet Engineering
Task Force IETF and w3c released RFC
2068 in 1997 that was the formal
specification for HTTP 1.1 but even
before then we had had Netscape and we
had had Internet Explorer in the browser
Wars and people had started to discover
what the Internet could be they had
started to get the feeling of what was
to come in 1999 and 2014 the protocol
was further refined and bug fixes
basically added to the RFC and now in
2015 we've got an HTTP 2.0 the latest
protocol based on a proprietary one
called speedy from Google but also
informed by Microsoft's similar protocol
this is the basics I'm sure you all have
seen it you have a user and you have a
server and it's request/response
it's layered on top of TCP which means
that it's using already existing
foundations
the stateless protocol so in and of
itself it doesn't contain any state but
you can layer it on top of HTTP so you
can add cookies and you can add session
State on the server and that's a pretty
common pattern when you build web
frameworks or libraries it's also built
to be item totems and what that means
that when you apply a function more than
once you should have the same outfit as
if you've just applied it once so if you
do a get request to an endpoint on an
HTTP server then we should have the same
result those gets there are exceptions
from this for example post requests or
delete requests the primarily post
requests they aim to change some state
and then you don't expect it to be
idempotent so what about sloths as an
HTTP server so for me it was about
developer happiness I wanted something
that I would feel happy with building
functionality and something that would
reduce my development friction and
enable me to produce software more
rapidly I also wanted to create
something that was community driven this
question lingered in my head is it
possible to compose a web server when I
came to solve it wasn't widely used but
it was already existing Audemars
Gonzalez is the other co-author of Zod
he lives in Toronto now and works in
Bitcoin startups so he had made all the
Foundation's and what I needed was a web
server that I could deploy for a micro
service architecture when I was working
with a software development team and we
were under pressure to deliver but I
also wanted to apply in my previous
history which I'll go through in a
little while but because I wanted a
micro services architecture I wanted to
have a low memory and fast enough web
server and I wanted to free myself from
the AI is trapped where you were sort of
stuck there and then everything would
have to go through the GUI I wanted
something that was close to the code
close to the metal last night
I also wanted something where I could
onboard people and teach them how to
program effectively and I wanted
something that could make sense both for
beginners and advanced programmers
cross-platform was something I wanted
because we started a micro services
architecture in a similar vein as all
the other architectures with Linux and
Windows co-hosted in the same cloud so
we needed something that could run as
API utility servers next to Linux
services the transparent development
process came afterwards
first and foremost these needs were mind
fulfill but after running this for a
couple of years the development process
has actually turned quite a neat finally
one item is to encourage dotnet devs
people like yourselves to step outside
of your comfort zones so it is quite
minimal so you can read through the code
in a sitting maybe in four hours you can
read through all of the coders love that
makes it easy to to on board and it
makes it easy for you to to start to
investigate what it would require to
build infrastructure because I as a
c-sharp developer when I started this
project never wrote infrastructural code
I always use the frameworks and I always
used the available libraries published
by authorities this is what it looks
like hello world and swab and it's
actually actual F sharp compiled this
framework is running on swab it's called
FS reveal so it's an adaptation of
reveal Jas that lets you write markdown
for slides and then it also compiled F
sharp to these nice tool tips slav works
around web parts which is the basic
building block just to understand what
Slav does doesn't require you to fully
understand what a web part is but it's
enough to understand that you can
compose them with this fish-eating
so you got webparts like yet that
filters requests and then we have
webparts like taught that also filter
and then if those don't match then it
can continue to another web part further
down the application finally you have
outlet web parts like redirections or a
successful output in this case we have
all successful okay and to take a string
converted to bytes in utf-8 and and
output it to the socket that you have
the client on so when you look at the
HTTP protocol this is what it could look
like when you do a hello world I've
spawned the server locally and I'm
making a get request it starts here on
line four with the verb gaps and the
pass hello it also contains the protocol
that the client is using the host user
accept and user agent headers are
required well technically not the user
agent but accept and host are the
minimal requests you can create in
response you you get the protocol chosen
you get the server the date and the
content type and also the content links
so down here you can see that world was
outputted you can look at the
relationships between the different
protocols like this everything is
running on Ethernet switching the basic
gift store called line on top of that
you have which provides addressing you
also have addressing an Ethernet via the
MAC addresses but you need a way of
decoupling the physical hardware from
the logical network address so they have
IP on top of IP you have UDP and TCP
like you know tea space the most
commonly used protocol for HTTP so it
gives you guarantee delivery of packages
but not messages that means you can have
terminated connections you can have
partial requests and you can have lost
messages as well so while we do get
replayability of packages and reordering
of them with TCP we don't necessarily
get all the messaging features that
you'd expect from a broker like random
key or cassia
on top of TCP then is HTTP so HTTP 1
creates a socket and then makes requests
and the client gets a response
further up you have WebSockets and
server sent events how many here have
heard of server sent events they found
and of okay so about 30% and WebSockets
almost everyone let me explain the
difference when you look at an HTTP
request it's transparent because it's
plain text you can write a curl command
and you can see the actual output of it
that's because the headers are sent as
ascii and if you just have a text HTML
body that also sent us at least utf-8
eight with WebSockets in comparison to
sse you got this you make a request
another response you get a text slash
event stream that's still plain text and
what server sent events do is that they
make the socket remain open and then you
can push data as you go you can then do
a cur command and you can see a data
being outfitted over time you could also
call this half duplex like one of those
modems that had to be silent when the
other side was communicating with it
WebSockets on the other hand their fill
duplex the first let's look at that what
it could see what you could do with just
server sent events small chat example
this also showcase a bit of the sort of
API primarily this function that starts
the web server call start the web server
it gets configured with a Slav config
that you can set up yourself in the
solve configure you have things like
binding what network network interface
do you want to bind to or ports and how
many concurrent operations you do have
what buffer should have etc then what
the small hats thing here means off to
solve config is that everything that
comes off to this hat is one value
particularly one web pot so previously I
showed you the composition of get path
okay that was one web pot
cues and it's arguments that's also one
web part so what use does is that it
iterates through the different
alternatives and the moment one says
that I'm going to reply to the request
choose also returns so it's like a
select statement for K events or our
completion port so first we see if it
matches the API and then if it doesn't
we always serve the index.html page this
is a very common pattern when you build
single page applications because you
want to serve so that the JavaScript can
do the routing in the browser using the
history API finally them if nothing
matches here which is a bit strange
because we've compiled and built the
site so we should have a new mix file
then we serve internal error because we
have some sort of programming error here
this is an example of what the chat API
can look like so we want to say that we
always serve JSON we also serve utf-8
this is a common mistake when people
start out with HTTP that they don't
actually specify utf-8 and then the
browser is interpreted as the default
for the operating system in question
that the client is running on beyond
that we have three endpoints send
messages and subscribe we also have some
global state so I remember when I was
doing a speed of nap and there was this
big big question about how do I keep
something long running on the site and
you would read this about the advice and
say that well you can use MSM q and then
you can create a Windows service and you
have to go and read about the Windows
service and everything was very very
intricate because if you created
something on asp.net like a spread
running in the background the guidance
was that this thread may be killed at
any point so you ran into the problem of
your app may not work and you'll never
know when it doesn't work unless you
capture the global error handler and
look at the thread abort exception and
that only happens every four days so
yeah good old days but like you can see
here instead we have left API equals so
everything that comes after everything
from 199 to 209
that's something which is statically
initialized like a global variable oh no
you say those are evil they are to some
extent but when you build a stripped
assistance what you want to do is you
want to push all the subscription and
metadata information to a database or
some sort of broadcast layer in the
background and there is nothing wrong in
initializing your resources for your
application statically if your
application is the only holder of those
resources so what we're doing is that
actually initializing the hub this is
very similar to signal law because we
have a hub-and-spoke architecture in
this demo we only have a singular hub we
don't actually have a persistent pub/sub
back-end so it's enough for us to
initialize it statically like this let's
look at the first pause here sending
your messages what we're doing then is
to deserialize the command that came in
the chat message and then passing that
along to this other function called
broadcast I know this looks quite
advanced but once you get into the
feeling of it it feels quite natural the
pattern is that whenever you have some
resource which is either configuration
or statically initialized you just pass
it as initial arguments and whatever you
get back that's a function and that
function can be called by the request so
that function then is what your request
acts upon and all the previous arguments
all the configuration and the husband
and everything like that the things you
use IOC for in c-sharp those are just
parameters and that you get the
configure function so in this case I'm
initializing the hub because it's a
global so it's something you'd otherwise
put in the IOC container and it just
takes one line of code we also see
another pattern here which is
deserialized
which then passes the deserialize
command into the broadcast function so
the function returns from calling
broadcast with the hub this is what it
could look like when you want to push
data from the API so as we move towards
the future our API us are becoming more
and more live it's not enough to pull
using a read model in the database
anymore but the user may want to be
directly and instantly notified when
something happens let me walk you
through this
it's using a pattern which originates
from ml which is to take the stateful
type T as the first parameter if you
remember here we're pausing the hub to
subscribe function that's the first
parameter here so we don't need to we
don't need to care about this
implementation we just have some handle
to some stateful thing and now we can
work with it
the stateful thing is then talked to
using the public API of that stateful
thing which is the thing that uses
messages in this code namely their
source type messages the rest is just a
loop that continuously consumes messages
and then send them on the event source
and this could be equivalently done
using WebSockets
so WebSockets worked like this it's
still duplex and that means that you
have a request which contains a specific
header called upgrade that part is plain
text but when you get a response back it
has been upgraded to a binary format
something which you not necessarily can
expect inspect sorry or expect if you're
a reverse proxy perhaps but it also
allows you to pause messages as you're
receiving them so you can build your API
as part of the WebSocket connection and
then you go into the quandary
should I have post endpoints or should I
have WebSocket endpoints as you can see
from the code sample I'm a big fan of
having actual HTTP endpoints for things
that we want the HTTP semantics for we
may want idempotency we may want to have
requests IDs and we want to handle them
using headers version numbers of
domestic concurrency control session
cookies etc and then you can use
WebSockets to push read models data that
you continuously create on the server
side or service unto them I wanted to go
through my story because the building of
this framework has been a lot about my
own personal experience and my my
journey towards it back in 2003 I was
devouring this patterns and practices
how to build enter apps back then I
didn't have a visual studio I was
actually coding in Dreamweaver yeah
exactly but they did have a takeaway
there something about forces the forces
were the things you wanted to consider
when building software applications they
mention things like you wanted to
minimize the changes required you wanted
reuse of components cohesive components
and performance at some points those
were the forces you had to consider
then the year afterwards came Evans Eric
Evans with his book two men driven
design tackling complexity in the heart
of software and I remember I was sitting
down at the ethic Bay and sitting in the
sunshine drinking a good latte and
reading this book end to end and it was
the most relevant or experience I have
ever had as a programmer because I came
from these parents and practices which I
really didn't understand how to generate
the data set with and then suddenly oh
it can be a repository instead Wow and
it can be only killed that was also
amazing but the big takeaway I had from
that book until my future self was
actually the leather jacket that when
you wear a leather jacket then as you
wear it and you move a belt like this
and you dance perhaps you get points of
suppleness like in the elbows or up here
on the shoulders because that's where
you move and the rest is stiff and
protects you and you want to build
software the same way you want to build
software that supple in the right places
but otherwise guides you in the right
direction
it also gave us a vocabulary for
actually speaking about software going
beyond the exact code artifact names
like interfaith and cloth and taking it
up a level of abstraction and so then I
started with open source and I start
looking into cattle transactions and and
they're contributing at a bit to it you
could in a single sentence aid was
global in realizability for aspect or in
the programming how many people use that
it's a bit opaque what it means is that
we want to guarantee correctness and the
aspect-oriented programming part was
that when you had a method you could
wrap it in a transaction similar to our
spring transactions did it if I'm not
completely mistaken
but the problem with that is that it's
opaque when you have some transaction
going on around your message you're not
really sure you're in a transaction so
you have to look a transaction scope and
then context current and see if there is
a transaction but what is it's a nested
transaction damage you're lost again and
then also MD SM has actually
parent-child transactions that can run
in parallel how many people have used us
so it was a great learning experience
and for the camera no one actually put
up their handler it learned it sort of
taught me the importance of quality in
order to understand these transactions I
had to understand the underlying
transaction paradigm and then I had to
understand the relational databases and
then I had to understand the distributed
relational databases and so on so that's
sort of how I got my shove into disturb
systems so just for future reference
tricky realisability means that you have
multiple entities like multiple rows in
the table and you have multiple
transactions as well and they all run so
that each program observes some sequence
of events readings and writings from the
database or and/or tables which
corresponds to a particular execution of
that program as it were think
single-threaded
that's what transactions is supposed to
give you but it was opaque and like with
RMS you never knew what you read and
plus you lower the transaction level to
with no lock just so the report could be
finished but in 2006 then I started with
Haskell actually because I started
University and I learned that you could
separate state from logic because
previously especially in the DDD book
which was quiet object-oriented you
always put the logic into the entities
and their aggregate roots so now you had
to intermingle the logic and the state
which turned out to be hard when when
people and myself designing applications
with it because you really didn't know
how you ended up in that
and if something went wrong you had to
sort of execute on the database manually
but with Haskell you separated them
instead so you had logic and state on
one hand side and in Haskell side you
had logic that flows data so data moves
through the logic instead and then if
you have patterns you make them type
clauses so instead of closest you make
them a type cloth and knots then the
pattern that you're reusing when it
comes to flowing the data in 2007 and
2008 this book came out just before then
it was only FS fish and strange hash
lights at the top of the FS files but at
this point with fu-uck 2.0 it started to
become readily available in Visual
Studio and I became F sharp curious I
also discovered that maybe there is a on
this slide maybe there is a way to write
code that's correct by construction and
I started looking into different sources
type series like martin love and like
dependent types and so on but of course
f-sharp isn't that but F sharp gives you
a lot more when compared to c-sharp 2.0
then I started consulting I met Simon
Paton Jones that was awesome I also read
some books and now follow some books
because at this point books started to
become a really interesting part of
course all of this aims to talk about
how this library was constructed in the
end that's why I'm saying this I just
remembered I need to say that but I read
this anti fragile book which is about
when you have complex systems like
software systems in this case you want
them to gain from disorder they want to
be anti fragile so robust system is
something like this table I can hit it
and it sort of gives back to normal that
myself if I do if I did push-ups or I do
handstands which I'm not going to show
then
my muscles grow stronger and I gain from
the disorder I create I sort of destroy
some muscle fibers but in the end I get
more of them I also worked with many
friends in 2013 I joined an enterprise
and I started looking into lean
thinking books because that was really
really what you start to think about
when you join enterprises but it became
more about analyzing humans when they
they act in software systems because
this enterprise in particular had quite
large software systems they had about
200 huge customers with thousands and
thousands of end-users and each had
customizations and reports and things
that made it very very couple to this
particular version so my nice migration
scripts in black but then how do you
sort of move forward in such an
organization and continuously deliver
value when you're always getting locked
down because as systems grow especially
if they're monolith and especially if
they don't have a culture of XP extreme
programming continuous delivery
continuous improvement etc then you hold
off on releasing and that in that spikes
the risk rather than diminishing it and
then when something goes wrong it
becomes a self-fulfilling prophecy that
oh we should have tested it more and a
nut in turn makes it even less frequent
so these books are really nice Romek was
one of the people in America that
started doing lean in his how am I on
time looking good so anyway 2015 I
started my company k2 and I've asked
myself the question what was what is so
where have I come at the moment and
where am i coming from so we've gone
through where I'm coming from now and
the question becomes what ought to be
what should the developer development
experience the business building
experience the software experience be
for you people the people who use my
fair work Slav to build software and
deliver a good book here is by hooked
one for many these are the rise of the
curating organization where they go
through that if you just organize people
around the idea of something rather than
organizing them by telling them things
you get a
a system that organizes itself and not
lazy to the pit of success because you
won't build that with people and with
software could I just get a check on how
many minutes I have left is it ten
minutes how much of an hour left
that was just okay good then I can slow
down so my point is then that sort of it
is sort of a movement at least a lot of
feels to me because I created it on my
own chamber with Adam are we iterated on
it we tested it we improved upon it and
now it's grown people are using it in
production FS nip dotnet we have the
gamma was initially written with it we
have people demoing the new vicious
studio with it people are actually
starting to pick up this software and
using it and I believe that's because
the thought that has gone into it
because there is no single person or
company that under writes what's la vez
it's a community instead the development
process is completely open it just
exists and you can choose to use it I'm
not going to push features on you you
can stay on an older version if you want
you can pull requests or older versions
so it becomes sort of this adaptive
nonlinear human system something that's
self-organizing and I think the biggest
upside with it is that it brings it sort
of guides you in the right direction
towards something which is which as low
coupling is cohesive and bring you the
properties you want from from building
software it gives you the structure and
then it goes out of the way and lets you
write your app so one thing many people
mention when it comes to functional
programming is that oh my god it has to
be immutable then I can't change things
so what about the socket in that like
all of you have said that at some point
I'm sure because it becomes so hard to
build systems when you can't change it
the world is after all changeable
the reason you have this conflict is
that functional program is actually
allowing you to change things underneath
the hood as long as your public API is
immutable then you're free to use as
much mutability and as much performance
optimizations as you want beneath the
hood a really good example of this is
the parser called utter parsec for
Haskell which actually has a very very
mutable buffer and lots of algorithms to
grow and shrink it and then outperform
see on HTTP parsing I suppose you're
getting a feeling Mouse where I want to
take slot in the future so it hides the
complexity and lets you focus on your
building your application instead this
is our production code and it showcases
the suave API for our API you can see
first that we try to find the static
file requested that's the happy path for
all the static assets and then it goes
through the different API endpoints
including the interactive endpoints that
are in public
but rather something that the app uses
or our logging framework logger uses so
what is one part of the F sharp story
the F sharp story though on the other
hand it's what ought to be that's why
I'm so happy to meet you guys today
because you're part of the F sharp story
if you want to you can choose to take
the step towards being better software
developers and furthering your knowledge
you can do that where y'all right now of
course it's not a contradiction but in
the F sharp community we've actually
gotten some steam and gotten some speed
towards the goal of building really well
architected software and it's community
driven and it feels like such a breath
of fresh air to me
let's dive a bit deeper into sod and
look at how it works this is the
connection handling you see on the left
hand side you've got the user here's
here's you the programmer you have a
nice beard we have the bound socket here
that's the thing that you bind on your
VM so a socket is the IP and the TCP
endpoint which is sorry the TCP endpoint
is the IP and port and you bind it and
you have a singular process listening to
one of those people so when the client
connects you you have the sin of this
Bay which you get syn ack back to and
then the request starts to happen the
date that I've done the headers that you
saw in one of the earlier slides but the
data sent to a child socket which has an
ephemeral port in the high port range so
when you do netstat you'll see one bound
port and then you'll see one ephemeral
port for each client the web part is
written by you so all the buffering and
all the shrinking and growing and
metrics and ensuring the HTTP is valid
as a request happens before you get
invoked then you can execute you can do
a synchronous invocations to a database
or to file systems or maybe zip the file
on the fly as you stream that back to
the client so you get the data and then
if you either have connection closed as
a header you close the connection or you
can have keepalive connections and then
you can let the client continue to send
requests to your API in code you first
bound the listening socket it's a socket
type stream on the TCP protocol and then
for every TCP connection you accept so
then you grab the client socket you
process the HP request you can see the
left bang that's F sharp or saying this
is the happy pause and then if we have
the side pass and something goes wrong
like we get a bad request
that handle outside of this code so you
can handle it in one place
that's decoupling again the logic so you
parse 'request you get the result and
then you keep it you put it into record
and feed it to your web part which can
now execute them and create a response
so we've seen the execution side the
other side is a different dimension in
sort of orthogonal in this case because
you can choose to either return bytes or
a socket ASCII in the initial hello
world example we said okay and then a
string that's good that gets directly
converted to some bytes it's a pretty
simple operation but if you're zipping a
file on the fly you want to continue to
stream that file because it can be big
so then you return instead of socket
tasks and you can be a part of the a
synchronous sending to the browser this
is a discriminated Union and it's in the
HTTP output file in this valve source
code and what the discriminated Union
means for the seizure of developers is
that it's either or it's either the
bytes always a socket task or it's in no
reply and then that's when you unit test
for example let me show you some
patterns then how do you use Slav in
real life this is for example how you
add login so one of the open source
frameworks I've released is called
lagering it's a competitor to Sarah log
but it also does metrics that means that
you can feed your application timers and
gauges and reservoirs etc into something
like influx or stat stay or yeah you get
to get the gist of it and gives you a
functional interface as well
this is another pattern it's called the
12 factor app if you haven't seen it
it's a really nice pattern for
decomposing and analyzing software that
you deploy it's primarily a deployment
pattern but as it turns out in DevOps
it's not just the operations that matter
it's the programmer as well you as a
programmer has to be there all the way
to the production to deploy and monitor
and improve your application and the 12
factor net site gives you the tools you
need to do that it also happens to sit
really well with this new technology
called kubernetes kubernetes is like a
process scheduler but for the cloud so
instead of doing terraform and then you
get a new VM and you have to manually
push every software up there started as
a service and then monitor it you can
say this is a service it expose it
exposes this port and it has these
endpoints can you please deploy that for
me with a replica factor of three and
then cover native goes and does that so
it's a hot recommendation to look into
if you haven't yet we also have this
other pattern called server pre test it
means that when you compose your
application functionally all of your
side effects and all of your
configuration is pushed up to your
composition route just like in c-sharp
where you have your ioc container but
that means that you can spawn a server
with this config with the changes needed
to run it as a unit test so we have a
library called Slovak testing which lets
you spawn server like this for each test
in this case the run with on line 8
takes the config which is your adapted
completion route and your application
and then starts it it ensures that if
the test fails it'll shut it down again
and then you perform the action you make
a request on line 9 with a get them
nobody and then you pick out the status
code from the reply then you can expect
on it this is using a testing framework
called expecto which i've also written
which is a fork as well so I'm standing
on the shoulders of giants but it lets
you in a nice fluent
say what you're expecting and it lets
you just as sloth lets you treat your
webparts as values lets you treat your
tests as values this is what it can look
like in the end we also have a really
nice community this is one community
contribution it uses something in F
sharp called type providers so that when
you create the code which you see on
line 19 to 21 you get the typed pause
and you also get a compile time
construct to interact with it typed boss
in the end you get generated swagger
documentation and all of these things
compose orthogonally so if you have your
calculation function that does the
processing of the web request you can
just shove it in here as part of the
callback here and then as it happens you
can on top of that layer the
documentation and that's really the
strength of functional programming the
layering becomes a composability so this
is all suave
have a look at swab swagger and if
you're interested in getting started
I recommend Slavitt IO the website there
is a whole book written by the male uski
called slam music stone it was written
as I said as a speech D project I think
it gives to everything from server-side
page generation to logging into session
types to cryptography to some extent
there's been a victim called them so
sorry this is the book
soft music store there's also been a
book written called F sharp applied and
it goes through how you would compose an
application with F sharp from scratch he
actually builds well in like 80 pages
and then he tells us oh so this is how
it works and now you know it because he
built it yourself then he introduces the
other tooling like packet the one here
at the top a nugget manager for dotnet
that lets you get away from one hour
nugget packet update PS prompts there is
a building tool chain called fake also
written in F sharp lets you build nice
projects quite easily iron I'd a free
editor that runs as a plug-in to vias
code and finally rx to orchestrate
concurrent operations in the backend
everything tied together with f-sharp
and swap so besides that it also gives
you it
gives you the ability to do CTRs at the
end so he tries to ticket them all but
it's nicely written and it doesn't get
overboard with it we also have this
really nice to getting started toolkit
called a web stack design for developer
happiness and github it's called fable
solve scaffold so how many here have
heard of Elm all right so that's like
80% of the room you can actually write
similar applications only on that maps
with f-sharp and compiler f-sharp into
stateless reactive you guys on the front
end so this web stack is designed for
developer happiness lets you do that on
the front end and then invoke type
routes on your server side with slot and
then you can also have swagger
documentation authentication yeah you
get the idea
and it runs on dotnet core as well and
if you're using webpack there is a web
pack loader for fable which is the
compiler for F sharp D JavaScript so
check it out I've also written this
course called the Linux intro course
coming from a dotnet background I
realized that many people don't actually
publish the applications on Linux they
normally paste it in RDP on is but this
is how you can get started so it gives
you everything from scratch this is how
you set up the terminal and this is how
you start a new project with Forge
generating the F sharp site and then
blah blah blah everything up until you
get to cover neck days this is how we
operate systems at scale this is how we
do monitoring it's on my github as well
half / Linux integrals
there are also videos the last couple of
years have had talks here at NBC about
slot and have a look at them now follows
a few more sorry about this there is
really cool attempting library that runs
a state machine as a web server but lets
you expose your iot computer as a web
api and then you can also map the
different API endpoints to the states
that your hardware has
this presentation was built with SS
reveal this is how you can do
authentication with f-sharp this is
probably the most horrid monadic code
I've ever written but it does exactly
one thing and it's just a library so
you'd never have to read this code
because it follows the specification as
tested you can run web shop run solve if
you wanted to because love is also an a
wind server and of course that means you
can run identity server of course Laurie
the logging framework I mentioned you
can do metrics and logging from your
client side and push them into solve and
then push them into your logging
back-end there is also this previous
talk about building a chat with hope a
con job which goes into how to use an
old invention 40 years ago
no actually 20 years ago called
concurrent and now which we now have a
porters to f-sharp called her pack
so lots more what about the future I
want to increase uptake that's why I'm
standing here I'm going to look at GC
performances issues and also how we can
make a nicer passer because what you
want from a system like this is
isomorphic code you want something that
those sends and receives with similar
logic so then you might as well join
infuse your HTTP client with your server
and had something which tests end-to-end
in your unit test with this pattern
server as a test
going to look into distributed
persistent channels similar to what
elixir does so that you can have a load
balanced chat server that keeps track of
each clan connection in case one goes
down and also on that client connection
what subscriptions we've had and what
position of the log it had already read
making channels our first primitive in
building web applications so it's really
trying to take it to the next level of
distributed systems so with all of these
we're looking for yeah documentation
we're looking into protocols this is the
client and server we could do some
really nice testing if we did this in
the end it comes down to speeding up the
development with higher quality code
that's what I want to have as a takeaway
from here and if one of you is
interested in sponsoring salt perhaps as
a company patron that would be very
appreciated we could combine it with
courses and you'd expect to see
development speed ups and that's from
experience and not from other companies
as well so come talk to me you can reach
me here
Hayate q2 or on twitter so thank you
very much so now do you have any
questions before everyone leaves all
right well thank you for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>