<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The C++ Type System is your Friend - Hubert Matthews | Coder Coacher - Coaching Coders</title><meta content="The C++ Type System is your Friend - Hubert Matthews - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The C++ Type System is your Friend - Hubert Matthews</b></h2><h5 class="post__date">2017-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pY-_93cfvso" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">ah versus good morning gentlemen I hope
that we'll be joined by few more I
thought there might be little there
quieter this morning so welcome to NEC
London day two and they talk on Super
Plus on the type system so why why this
talk I usually like to start by thinking
well why would I talk about this subject
why would anybody listen to this why did
I come up with this one well I've seen a
lot of people using C++ and some C for
some time and they use primitive types
or a lot of things there is a lot of
help in the language that you can use
and you can write essentially your own
language inside C++ rather than using
what you're given so here are three
things that I think are important and I
would like them in this order I want our
code to help me to avoid avoidable
mistakes stopped me doing things that I
don't want to do things that I shouldn't
do and I want that at compile time if I
can get it I don't want to have runtime
crashes I want to get the compiler to
say no you can't do that
so how do we do that one that's one of
the things we're going to look at the
other important thing or amongst the
important things is runtime cost okay so
if I have this and I use lots and lots
of features in language to help me build
up my stuff to prevent this I don't want
to do this basically at zero cost
because if I do this an extra cost oh
you can do this in the safety stuff but
it's slower or bigger or generally gets
in the way then people are not gonna do
it they're going to go back to the old
way the garbs can use an int here or
whatever so people go back to unsafe
coding styles because it's slower so I
want to show that actually we can have
our cake and eat it here so we can say
we can have our safety and it has zero
cost at runtime in terms of memory and
speed it would also be nice if I could
put this into a library and say ah let's
reuse this so I don't have to do this
again and again how do I make it
reusable generic no flexible those two
those words that developers love so we
don't have to re-implement every time so
that's basically what we're going to
look at today so a little bit of history
about programming and types when
machines first came out you program the
machine code or assembler and it's
essentially its typeless there really
isn't much in the way of types going on
in there you have some basic kind of
things inside the machine if you're
lucky integer and machine word is the
basic thing of this one and you can use
it as some dress so you can take an
integer turn into a pointer a pointer to
an integer assembler just says yeah it's
a register I don't care you may have
some things there were the slight
differences you may have some double of
some floating-point things or more
recent machines in hardware than in old
stuff you get machine efficiency that's
great but it's at the cost of programmer
effort you've got to do lot of work to
do this one you basically have to go
okay here's what I want to do and then
you have to translate this into the
world of assembler and pointers and
addresses and you make sure you get
right there is domain knowledge in there
somehow but and it's it's but it's
inside the program you can't see it
obviously and if you've ever done an
assembly you'll see here's the assembler
and here is the per line comment that
actually tells you what's going on it's
not easiest easy to decipher or work out
what's going on it's easy to make
mistakes as a high maintenance cost of
programming and assemblage is why most
people don't do it these days okay so
what comes after that
well after that there were typeless
languages like be in BCPL which were a
step up from assembler it did all of the
allocation
for you registers and other bits and
pieces like this but basically there was
almost no type safety so an example from
BCPL three times brackets four plus five
words give you the value twenty seven if
you miss out the multiplication by
mistake actually what you end up calling
is a function at address three with the
value nine this is obviously a path to
madness and trying to debug this or work
out what's going wrong is kind of fun
okay the C preprocessor for instance by
the way simply like this great line from
Kevin Lee honey yesterday this is it's
instead of strong type safety is string
type safety so everything is basically
string string Lee typed languages so
that was kind of where we started and
then the next thing is we started adding
more types into this one this is where
you get C and people using C++ based
around the primitive types
it stops you making those mistakes in
terms of integers and pointers it says
all you've got to do cast for that okay
it's fine so it stops those mistakes you
get the hi machine efficiency which is
where C comes from and secret for us
inherited that one better programmer
efficiency so you have integer pointer
and float point or own child pointer and
other things like this so you get some
idea what's going on in there you
haven't got any extra staff you having
built in the extra layers you're still
using what's underneath
integers and floats and type pointers to
this they added structures and
aggregates so you've got structs and
arrays and other bits and pieces so this
is this Maps fairly well on to your
assembler so you get that efficiency not
much abstraction no so C gives you
abstraction through files you can do
modules primarily but you have to
translate sill there's a translation
there because you go well this is how
I'm thinking I can't do this sort of one
to one lie might do well with objects
and there is little opportunity for
tightly compiled time checking so you
might end up with all a static analysis
tools to try and work out what's going
on particularly in safety critical
things
you
this is where I'd like us to have a look
at today which is this higher level c++
how can we use the type system and using
a lot of types to create lightweight
abstractions that are going to increase
the amount of domain knowledge we can
put into our program without sacrificing
that efficiency so how do we get more
stuff in there but still retain the
machine efficiency you have from
previous ones and the interesting thing
about a type system is that it's a proof
system it says 100% you can either do
this or you can't you can add these two
together or you can't and it's done at
compile time and there's no ifs or buts
about this one it's legal or it's not
and I'm trying to see how we can make it
so we can use that to avoid problems how
do we use the type system to basically
say you can do this you can't do that
and stop problems happening at runtime
by turn converting into compile time
errors if you do this well you get code
safety you get more reuse be honest true
strop likes this and he's trying to
avoid people using primitives and
interfaces okay
compilation is remarkable it's a
wonderful thing so we have a picture on
the left hand side we have run time and
you'll notice a run time assembler or C
C++ they all basically using machine
types underneath it all compiles down to
the same thing but you'll notice at
compile time in assembler we basically
have nothing because once you've
assembled it that's it in C you have
some of the language types so you
basically get the intern floats and
pointers etc that information is thrown
away so everything in the orange is just
thrown away for the C++ well I'm talking
about we going to add our own
application types so we're adding lots
and lots of stuff into this type system
and we're then going to throw it away
and at runtime we're left with exactly
the same thing and so we're focusing on
that top right there about application
types okay some little small white lies
here C does have things apart from the
language types has some small
application types
such as structs and secret of us has
some runtime type of information which
is obviously at runtime not a compile
time but the big picture of this one is
we can use lots of types and then throw
it away and we don't have this at
runtime
okay let's have an example let's get
down to some code and a big picture for
the moment date intake three integers
what are the parameters how did you know
well you got to go and look at the
documentation or you have to go date
into your date month in today and
there's nothing to stop you getting this
wrong there's nothing to stop you
putting them in the wrong order when
will this show up it'll show up at
runtime not a compile time it will be
much nicer to say date take year month
day and it's very clear what those
parameters are which order you should
put them in if you try to put them in in
the wrong order it won't compile if
they're separate types okay we're in a
much better place already it's
unambiguous its expressive we know what
this this is about if we try to do this
just by having an alias or type def so
I'm using the CEPA plus eleven alias
features here if I just said using your
equals int that doesn't actually do
anything because it's a type alias and
therefore if I said you using your
equals in using month equals in they are
actually the same type because it
doesn't introduce a new type it's just
an alias so we can't use that we have
actually to help create our own classes
like last dates last month etc and this
would catch them at compile time let's
have a look at another example what
happens if you're trying to do things
with physical units so meters and
seconds and some measures of length and
time and there's all the 7s are units to
deal with meters plus seconds does not
make physical sense the kapala goes you
can do that if you want if you did them
as floats you could do that
if you do them as just meters and
seconds I want the compiler to tell me I
shouldn't be adding length and time
together because it just doesn't make
sense
notice on the second part there I've got
feet and meters they're both lengths but
I can't just add feet to meters without
some conversion it doesn't work
gives me a nonsense result if you're
lucky it gives you a result that's
obviously wrong if you're unlucky gives
you result that's believable so the top
right of this you'll see these wonderful
little pictures which are from the Mars
climate orbiter and the mass climate
orbiter this is hundreds of millions of
dollars worth of of kit Lockheed Martin
and NASA managed to screw this one up
unfortunately and the problem there was
that the that the interface had pounds
seconds so Imperial English units and
when the other parts was using SI units
with Newton seconds which are out by
factor four point four five so instead
of that lovely little curve coming the
top and going round Mars it came in four
point four five times to low bang
straight into Mars if those guys who
who's spending hundreds of millions of
dollars on this can get this one wrong
what chance do we have how likely are we
to make these errors I'm going to show
you techniques that will stop this
errors one hundred percent if you use
them so it still you can write nonsense
and it will still compile so one of the
basic things here is a thing called
whole value pattern this was invented or
named by Kent Beck extreme pro game guy
first in small talk and it this is right
ok we're gonna create class yeah like
this which is just holds this year
that's all it's doing it's nothing
there's nothing special about this one
but it's a different type so the second
part on this one the operator double
quotes double quotes c plus eleven
so-called user-defined literal this now
allows me to write cut typed constants
so instead of just saying yo y equals
206 2016 i can now say 216 underscore
year and that will return something of
the right type the other thing to notice
is the explicit constructor you you
can't automatically convert from an int
into a year type you actually have to
say i want the year your parentheses
whatever so this means you can't
accidentally pass these things
you can't create one by mistake again
safety you coming out of this one though
so that's explicit going in stops that
conversion because that's an unsafe
conversion we want to control that one
operator int is a user defined
conversion an implicit conversion out of
the class so you can say right ok how do
I get that value back out if we do this
we can actually just convert everything
back into integers do the arithmetic and
we're we're okay to go with that we can
actually still do stuff this is giving
us a start it's not the end yet so it's
an widening conversion out and that's
safe not foolproof and it gets boring
when you have multiple types because you
can imagine that month is going to look
the same day is going to look the same
week we're going to use this a lot this
pattern of course when you see repeated
code structure templates are your friend
templates are code generators built into
the language and they help you with
repeated structure so in this case what
I've done is taken class year we now
call it class unit that's the name that
beyond a through strip has been using so
I've been using that one and now going
to template it you get a template it all
essentially just a number to make them
different types there's nothing special
about the unit type there it's just a
list of numbers and it means they're
different same thing but now I can say
here is a unit of yo type and month of
month type and now there are three
different types so I can take this I got
in my library class and I can make them
different now I've got a type safe API I
don't need to repeat myself all the time
this is as efficient as using integers
all the functions in line there is no
runtime overhead here
yeah
absolutely you can so if you wanted you
could put that in a header file for
instance if this was a date thing you
could put using in your header file and
see this one so if you had a date H or
whatever then you would put in you have
this unit you'd have year month day and
then your date one all of that lot in
one header file that other people can
see absolutely
start we've wrapped up an integer but we
know that it's a constrained set of
values we don't want to be able to
create things out of a certain range so
here is a technique we can use with
constructors so const expert is
something comes in c plus 11 and was
made much more useful and c purpose 14
so this means this can be done at
compile time so it's a on a constructor
or a function it says it can be run at
compile time
if you whether it is or not depends on
how it's used and so there's a context
in which it's used so you can see at the
bottom a lot bottom two lines the first
one is a run time check and second one
is actually a compile time check so this
one here you can say right ok my unit 1
like this notice on the unit type i've
got two extra parameters which is the
low and high value so I can now say AHA
look check at compile time or when you
try to create this one that it is valid
if you're doing at run time it'll to a
throw okay that's you can't create one
of these that's fine if you do the throw
it the compile time you can stack Spur
you'll get a compiler error now it may
not give you a particularly nice
compiler error but it will actually give
you a compiler error so you can now at
the bottom that will bottom line will
not compile so I can say that's out of
range so now I can say look it's of type
it's like this and it has this range and
get that checked so we can do runtime
and compile time checking the compile
time check has no runtime overhead the
run time check obviously does so up to
now we have just been looking at
labeling our types we haven't done
anything particularly special with them
and we have not done anything with
operations we've said ok we can wrap
this one up when we want to do something
we'll take it out of this class use dine
conversion implicitly do our arithmetic
and then we have to decide whether to
put it back in or whatever we can do
what we choose to do with I'll print it
out
this is error-prone we've got rid of
some of our errors we got rid of passing
the wrong thing to date but we haven't
got anything about what we can do with
years some operations are valid and make
sense physical sense and some arms so we
now need to start looking at the other
side of this one which is operations and
moving on from just labeled types so
we're going to make the conversion out
of our thing explicit so this is the
same as before but you'll see now in
this explicit operator int so conversion
it and I go drop all the context purse
after this one because otherwise the
slide just gets you big ok now you can
you say I can't create a year unless I
explicitly type year I can't actually
convert it out into an integer unless I
say I want an integer so now conversion
control in and out my operation operator
plus I just said look it makes sense to
say year plus an integer or integer plus
a year so I can say 2016 plus one so
year 2016 plus one gives 2017 but it
doesn't make sense to say year 2017 plus
year three
what does add two years together doesn't
make a difference it doesn't make sense
so we can decide what operations make
sense in our domain and which ones don't
so we can choose we can now be explicit
about what is allowed and what's not
allowed
so
plus int you go yes okay that makes
sense so for dates we have we can add in
extra things we can say what we decide
what date plus int would mean maybe
that's going to add a number of days no
date plus one will be tomorrow into plus
Tate Tate - dates that make sense
because of how many days in between
would it be dates less than date
yes that's obviously some ordering
between those and we can do equality so
some things will give us date some will
give us in some of is bull dates times
int what does it mean to say two times
today makes no sense so we have to
decide which operations make sense which
ones don't
but for instance with money you can say
well money times a floating point yes
that's fine that's an interest
calculation that's that's a very common
thing to do but money plus a float
doesn't make sense
certain operations do certain operations
don't and there's a little of whole pile
of sort of kind of mathematics around
this one with groups and rings and all
those other things like that if you want
to get into this how do we get the point
where we can have the desirable ones how
can we say what we want and what we
don't want here but without having to
spell it out every time how could we
make that more reusable more generic how
do we avoid all the boilerplate and
repetitive code okay let's have a look
so first approach is that we can let the
client do it and there happens to be
something in the standard library that
will do this so if you have operator
equals equals which is a fairly
straightforward thing to do and operator
less than you can now include rail ops
this is something that was in 98
standard and it defines the other
operations like less than or equals in
terms of less than and equals equals and
what it has inside is some templates
basic templates like operate a greater
than is just operator less than but
where the arguments turn round so this
is you can say well I publish these ones
and I'll let the client decide what he
wants that the reason it's done this way
and in a separate namespace is because
they're very big powerful templates
operate at greater than matching two T's
there's would just match everything
so that would give you operator less
than on things that just don't make
sense at all which is why it's
constraint you can't use this to define
your own class though and it's a bit of
a quick cheap way around it but it's
it's there so what's one option we're
not going to take that one we're going
to see a little bit more and that's only
defined for the relational operators so
here's a technique thing called CRT P
the curiously recursive template pattern
or curiously recurring template pattern
this was used over 20 years ago there's
a book called scientific and engineering
C++ by Barton Nachman who do a lot of
this and this is essentially doing the
same as a virtual function but it's
doing it at compile time and it's a
rather rather fun trick when you first
see you go really what's going on here
so classier inherits I'm ordered of
Europe you appear to be inheriting from
yourself or a template parameterised on
yourself well the reason for this one is
that why we do this way this is as I
said a compile time version of virtual
functions if you just do without virtual
functions you could with virtual
functions at runtime class year inherits
from ordered and then ordered which is
the base class up here would have
virtual functions that would say right I
want to use the operator less than
that's in the derived class
and so it's a virtual operator greater
than called the derived classes less
than so you use virtual to do the
downcast but that's done at runtime
what you need to do is to get that same
downcast done at compile time which is
why you need to have this technique here
with a downcast a static cast to derived
in order to know how where to do the
downcast you have to pass in the derived
class which is why it's your public
audit of your so that you can pass in to
the base class the thing is trying to
downcast - that's way it's done it's a
very powerful technique when you get
your head round it you go oh I can do
lots of things here so if you're used to
thinking in terms of object oriented
stuff and
chores done at runtime you can do the
same things now at compile time and so
here at the bottom I can see that I've
got a operator greater than defined in
terms of operator less than so that
derived downcast is done at compile time
there is no overhead to that one because
the class has no size so there isn't any
point to adjustment or anything at all
it's just a cast
all compile-time stuff and this is
sometimes referred to as compile-time
polymorphism so as I said it's like
virtuals but done at compile time why do
it this way rather than with a virtual
okay so imagine I we've had this as an
unsigned char if I added virtual to that
any virtual methods then it would add in
a virtual table pointer it's a V table
pointer so on a 64-bit machine my one
byte unsigned char is now gone an 8 byte
pointer followed by one byte so it's now
gone from 1 by 2 16 bytes 16 times
larger if it was an int it would be 4
times larger I'd have to do a virtual
call so I'd have to do this call
resolution at runtime so that's slower
so it's 10 takes instead of being
resolved an inlined which basically has
zero overhead it's now going to take 15
maybe 20 cycles to do that to do a
virtual call at runtime indirection
through a pointer you can't do context
but you can't do compile time stuff
anymore because it's a runtime thing if
you use virtual rather than using these
techniques so you've pushed things to
runtime you may think slower you can
it's unlikely you can inline it or
depends how it's done but if it's pure
virtual you wouldn't be sorry if it
wasn't just virtual functions you
probably wouldn't be able to inline it
inlining is a huge performance benefit
and also the branch prediction in your
CPU is going to go have no idea to
virtual function don't know it's going
to have to measure it at runtime whereas
if you do this one it's all inlined
you've got no overhead here and there's
no branch prediction because it's all in
like it's a very common technique used
in libraries like boost you'll find some
libraries use it all the time very
useful technique to get your head round
so let's now look at physical quantities
so this is back down to the Mars climate
or which problem so I've got quantity at
the top there so it looks fairly similar
but notice I've added some extra things
into this one here so instead of just
I've added type name V so that says I
can parameterize the type am i storing a
float or double or an int or whatever
I've got a second one unit sis and this
is then for saying okay
this is a templated parameter that tells
me what type of system I'm going to be
using so specifically here am I going to
be using SI units or am I going to be
using the English or imperial units and
then I've put three additional template
parameters there I could go all the way
up to seven so these are the indices the
exponents for the dimensions so M L&amp;amp;T
for mass length and time
- fine operators operator plus an
operator divided on all the other ones
so operator plus just says you can only
add quantities of the same type I can
only add things which are the same or
the same units and they happen to be the
same physical unit representing so I
can't add mass to length so the ml and t
in this case are indices for this one so
as an example see the bottom here meters
I'm defining say that's a float and
you're using SI units zero one zero so
mass is zero length one time one so
that's at time zero that says I'm
dealing with a length quantity so I'm
doing dimensional analysis seconds math
zero links there are a time one now if I
do meters plus seconds like on the
bottom it's going to say you can't do
that you can't add meters to seconds it
doesn't make physical sense there is no
operator plus for these because you can
only add things which are the same types
operator divide however is a little bit
more fun because notice that says well
okay I can only do things that are the
same type in the same unit system so
immediately I'm in a good place there
but mass one length one time one massive
length through time - and then I say
okay I'm now going to do some arithmetic
so I'm going to say the output has the
same type same units but mass one minus
mass two so I can now start and do
arithmetic on the exponents so when I do
meters divided by seconds instead of
what the answer will be will be float
that's our units are zero one minus one
Lorde's meters divided by seconds gives
me a velocity so it says here are the
the calculations you can do and by the
way I'm going to keep track of all those
types
again zero runtime overhead here why
because this is all on the type system
we throw it all away we've got a proof
system at compile time that says you've
not done anything silly or here are the
class of silly things that I've stopped
you doing and you can always write silly
stuff of course but it's thrown away so
we're getting these conversions in our
case here the conversions we're doing
are the exponents it stops physically
impossible calculations and stop some
mixing of units the SI units in per unit
we can do related flavors here so
multiple currencies you could do
similarly like this you could say okay
can I have a currency in in this value
comes the labels of this value I would
then have to find what conversion would
meant between them so if I wanted to
convert pounds to doral of dollars or
Euros I couldn't stop myself adding
pounds and euros together
because all of this is through all of
our information that we have that rich
type information is thrown away at
runtime we can't do in C++ what you can
do in other languages which is do
runtime reflection and find out what
types things are or do calculations and
compare runtime you can do calculations
at compile time however so in C++ one of
the techniques is often used a little
bit a template metaprogramming is
publishing your template parameters out
to the outside world
so you republish what comes in so and
I've got vum L&amp;amp;T and I'm republishing
them so you'll see value types so for
instance if you have a vector vector of
T you'll find inside there is a type def
that says value type that tells you that
the vector of T has a type of T that
allows you to be able to take a
container and find out what's inside it
same thing here I'm republishing the
exponents and unit systems etc so that's
all just static information that's in
the type system but there's no overhead
to it at runtime at all so why would you
want that well okay in the middle here
length and time so I can say I got a
float of SI units
I then won't have a time unit that's
compatible I say well it has a quantity
of length type yes I want that to be
type I want this to have the same type
as that guy so if I change it from float
to double that would also ripple through
I want to have it the same unit system
so I can do some simple calculations
through this compile time reflection I
may say I can use the template in a list
like this is a mass is always going to
be 1 0 0 for these ones here but I can
then also decide whether I want to have
floats and doubles or some other types
in there I can do things like this if
the unit system equals SI units then
print out this one here because that if
is done at compile time then we'll be
dead code if it wasn't there the
compiler would eliminate it in C Pro r17
you can even do if Const expert
so that is how do we tailor these
operations so the next aspect of this
one here is we want to be able to use
some way of saying well I want plus for
this guy but I want not for this so for
instance when we looked at date and
money date we said we want to be able to
add date and integer we didn't want to
be able to add money an integer we
wanted to do date money plus money yes
but not date plus date so I've got a
short little thing here operator traits
that's basically a table that says here
are the operations that I want and
here's the ones I don't want so I can
put I don't want these ones here so my
my base one here of AD scalar add value
and now I can do these operator plus
there's two versions here so the first
one is adding it an integer to something
and I've put in an enable if enable if
is a way of limiting the read the
overload set for template and basically
says if operator traits add scalar is
true then this is enabled if it's not
this template does not exist so it uses
this technique called spin a
substitution failure is not an error and
it says if that's not true it's not
there but don't complain
don't throw an error if this template
it's not there if you try to use it it
will but it doesn't say enable if won't
throw that kind of won't complain it
just takes that template away so I can
say I can add duty plus integer or I can
do t plus t if add value is true so that
will be the library code and then how do
I use that well the client code says ok
here operator traits for you I'm just
going to say add scalar I wanna add
scalar I don't want the other ones so I
can say here are the operations I want I
can enumerate those ones that will use
the enable if turn on the template for
the relevant operations and now I can
say yeah plus 2 it goes fine year plus
year is a compiler error so that's kind
of fun that allows us
notice here the use of these things once
you've done all the rest on his foot is
as simple so I'm trying to get it so
that there is zero runtime overhead but
also zero sort of compiled developer
overhead to using these types
once you define them the code looks just
as you would have done if it was
integers
so where are we we've done a load of
stuff here thrown pile of things in
let's have a look so on the left here I
have my main so I've decided to have got
distance here which is this so I've got
all this business with context pers and
user-defined literals and a five point
two meters I have all the physical
dimensions all that ml and T type of
extra stuff I've got this unit types
about what we can do I'm using CR TP for
the operator inheritance I've got so
this happens to be a constant expression
example but the same thing applies if it
was runtime values so I've take a couple
of things like this add two distances
together do some comparisons with an
operator greater than even though I've
done operator less than and I then said
Riker that's distance and divided by
time that's going to give me a velocity
that's fine and then converted it back
out again the interesting thing is in
GCC gives you the answer as saying it
just compiles down to the answer is five
so the generated code is basically just
return the value five if you do this
with without constants you will get an
equivalent as you are saying that you
would get if you just did with doubles
so there is no compile no runtime
overhead to this one it's all done at
compile time okay let's switch to a
little bit of something else there are
other things that we may want to to
check and so here's a little
fixed length string class fixed length
string class we're trying to avoid some
of the problems that you get with C
style arrays with pointers to memory and
don't know how long it is the the
classic buffer overflow problem so this
was something that you might use an
embedded system were you going well
actually I want the kind of efficiency I
get with contrast our stuff but I don't
want to have the buffer overflow
problems so this string here fix string
notice in the middle struttin copy here
so we're copying into this into the
buffer we've got notice it's not
dynamically allocated it's just inside
the string you store and copy make sure
it's not
nated there's actually a policy decision
based in there and embedded this is says
I'm going to truncate my string if you
give me a string that's too big to put
in there you have a great long you put
war and peace into something it's only
ten characters long it's going to
truncate it truncation may or may not be
appropriate it's a policy decision
but is that policy what you want so for
instance what might what might be some
other valid policies you might mull say
well actually look I want to stick this
in diagnostic log because something's
not right there but I'll just truncate
it and but I'll note the fact that
truncation occurred you may be
displaying something on the screen and
it may just be a message where it's
truncated that's okay if it's a message
as printing out a value and it truncates
it that might not be okay because it now
gives you three digits of an integer are
the four digits of an integer oops so in
a case like that you might decide to
throw an exception you go look this is
horribly wrong
and there's something bad here we all
need to recover from this somehow if
it's an embedded system you may go look
actually I'm in a horrible place I have
no idea what's going on I'm going to
reboot so there's something something
bad has happened here you may be in a
test environment and say look actually I
want to stop at this point getting the
debug give me a back trace go down here
and go where are we because I need to be
able to do this one these are all policy
decisions that you want this string to
be able to implement so we can use a
policy to this one here so my fixed
string here instead of hardwiring in
that strand copying truncate I'm going
to do all the copying and if it's not
zero at the end so I've got a thumb from
the truncation and then get a call the
overflow policy at that point to decide
what to do and this one here by default
it's saying okay complain just print
something out to standard output you can
decide what you want to do you can
decide you may create a one hear a noise
e string that says it's resetting on
that it's going to be make its presence
felt very nicely when you do that so
these are policies that you can do
let's just compare the policy in a CRT P
approach CRT P essentially does a
compiler downcast and it's mixing in
functionality it allows you to say what
you want with this one and it's really a
library injection technique and it's a
way of refactoring things out policies
don't do downcast they essentially doing
up cast or depending with you inherit
from that or want you to quiet to it and
this is useful for rules validation
logic such as constructors because that
was if you notice that one is was a
constructor and it's a validation policy
inside a constructor just as we had
validation for the limits of our of
types so let's see how we can mix this
all together here so it's unholy mess
here of quantity that says right I have
a public I'm ordered of quantity and I'm
also inheriting from the constructor
check so I will do the initialization of
that one of the ordered one that gives
me my all my relational operators and
then the constructor check will call the
constructor of in this case it's non
negative checker if it's less than zero
we're going to throw so this is context
per which means that this can then be
enforced at compile time so if you try
to create one of these things at compile
time it will do that check at compile
time you won't even compile so if you
try to put a negative integer a negative
floating point sorry it won't compile if
you try to do this at runtime it will
obviously do the runtime check
so that can
to check their it you can initialize the
string directly but it's a little bit
more entertaining to do if the
constructor check doesn't complete
correctly because of that exception is
thrown that turns it into compiler error
if it doesn't throw on the other hand
that top part isn't throat essentially
gets removed so you've done a compile
check that then goes away at runtime
this just there's no there's nothing
left of it so there are some useful
things you can do with that so let's see
what that's done here when we put this
extra check in here Const export
negative number compiler error if we do
it with a negative number here you'll
see you get a runtime throw and if we do
it without that we get exactly the same
as we had before so there's a zero
overhead to that
just as stand back from a little bit
what we've done actually is created this
domain-specific embedded language de sel
so it's like a domain-specific language
but it's embedded in C++ we basically
said here C++ will use these tools to
produce our own language if you use int
and float you're using an implicit
interface you're using what the language
has given you what we've done here is
said now we're going to go explicit
we're gonna say I'm gonna I'm gonna take
all control of these ones instead of
saying I get all the operations that I
get with on int and floats which causing
me no work to create this zero work to
create it easy to misuse though I can do
plus plus on something when I didn't
mean to do that
what does that mean for for your type
little checking if you use the implicit
interface and it's what I'd ever
necessary it doesn't allow you to
constrain things but on the other side
if you then go to the explicit interface
you say I haven't only these things
you've got to do some work to do this
one once you have those libraries there
are a number of those libraries around
boost has something similar but it means
it's harder to misuse and you get a lot
more checking and it's only as wide as
you need okay so implicit versus
explicit there are some things however
you want to happen in perfectly and
typically the destructors and the
cleanup is something you want as an
implicit interface you don't want people
having to do explicit cleanup so I would
say from a safety point of view you want
explicit for all the operations apart
from the cleanup operations so your
resource management and destructors and
cleanup and rollback you want that to
happen you don't want to have to call
clean up things in other languages you
have to go and call cleanup in C for
Plus destructors a huge huge part of
good C++ code in terms of resource
management there's that so that that
means you want implicit safety
operations but for anything else you
want those to be visible and explicit
okay so have libraries we've got
complete let's compare the run time and
the compiler time stuff so on the top
there the oo view of the world is you
say well I have a client and server
class and I have an interface in between
a Java style interface or C sharp or
whatever you want and this has the
advantage of allowing you independent
compilation if the client class here
says I'm going to call something that
expects a string and I try to pass on
integers - it says you can't do that you
get that independent checking if the
server says I'm trying to call dot
lengths on an integer it says no such
method so you can compile the client and
the server independently but you can
only put those things together which you
have thought about so this is a white
list this is pre-planned you have to
know that these things can be put
together with templates on the other
hand and we'll come back to this
concepts thing in a moment you get a
template of T and an X and you go or
just put them together do they have the
right signatures and it goes yeah I can
do that that's if they if all the
operations are correct that's fine if
not you get a horrible error long model
like this is like war and peace and this
is one of the reasons you can't get
separate compilation of templates why
you have had a files etc and you need to
see the so the inclusion model for
templates what happens if we tried to
get that kind of this similar separate
compilation or at least this checking of
compare of types with templates and this
is what concepts are about two concepts
are essentially trying to do like kind
of like that interface thing and
applying some of some additional type
information to template parameters it's
there it's not in super or seventeen but
you'll find GC has concepts in it so
let's try them out let's see actually
what we could do how can you apply
concepts to what we're doing
so here's oh here's my first attempt to
this one so you've got a concept ruling
has operator less then and it says well
it's a red boolean and it returns true
if t1 less than t2 is a valid expression
if you can do that okay so I can now
take my ordered and say house operator
less than so instead of template type
name its template has operator less then
and that then should allow you only to
put in to this one things that have an
operator less then
so let's actually try it class year
public ordered year damn this doesn't
compile and the reason it doesn't
compile is because ordered EUR ordered
is looking for something says well I
don't know what's in year so I don't
know whether it can satisfy this so I've
got although I can use CRT P with
inheritance and things I can't use it
with concepts which is annoying and then
I add a scratch on my head and said well
how else could we do this one so this
does actually work so I've tried this on
GCC same concept but notice instead of
having a constrained template argument
like that I've had before type name I've
now put a requires Clause afterwards if
you've seen c-sharp c-sharp has a
request Clause similar to that so my
operator greater than you can only pass
in something that says House operator
less than derived now that works so one
of the reasons for doing this is we
think actually yes this we can we have
some fun with this let's try it let's
see what the error messages might look
like so here are the error messages
without concepts so I have my struct X
ordered like that and then I try to call
operator greater than when X obviously
clearly does not have an operator less
than so this particular thing says well
required from here no match for operator
less than in this and it's one of those
confusing messages you look and said I
was calling went to greater than why is
it saying operator less than so that's
one of the problems you get if you try
to do this with concept on the other
hand it says ah look operator greater
than can't do that one because does not
have operator less than blah blah blah
here and this expression at the bottom T
1 less than T 2 would be ill-formed it's
a longer message but it's least pointing
in the direction says where those things
are I mix
affecting that the compilers will get
better at these messages I'm hoping
because that's not particularly nice
let's see what the fixed string thing
might look like if I try to call out to
something that doesn't have overflow on
it so the top one there is without the
concepts and I try to call this one
fixed straying for 4x and it says no
overflow like this this with a concept
it says oh that X can't do that one
because it hasn't got overflow because
overflow blah blah blah would be
ill-formed so at least it points in the
right direction
so a summary of this one essentially
we're providing lightweight abstractions
that allow us to control what we do that
allow us to write safer code that allow
us to have the compiler do more checking
for us and allow us to put more domain
knowledge into our code and have it
checked and if you're doing anything
that requires safety anything requires
correct answers this has advantages it
has zero or small runtime overhead
usually zero in terms of CPU or memory
the use of these ones so there's zero or
little overhead to the developer for
this once you have those libraries in
place and allows you to create those
ones and I don't promise that everything
will turn into just a single instruction
okay
any questions about that</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>