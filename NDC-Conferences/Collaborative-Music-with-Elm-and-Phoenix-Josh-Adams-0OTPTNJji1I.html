<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Collaborative Music with Elm and Phoenix - Josh Adams | Coder Coacher - Coaching Coders</title><meta content="Collaborative Music with Elm and Phoenix - Josh Adams - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Collaborative Music with Elm and Phoenix - Josh Adams</b></h2><h5 class="post__date">2017-04-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0OTPTNJji1I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">if you here but the thing
with elm and Phoenix and collaboration
music than this is in fact that room
so before we again make a confession I
gave this talk at a liquor comp earlier
this year and I have a sort of a problem
I have a lengthy history of talking
about languages other than the one that
a given conference is focused on so for
instance at ancient city Ruby I've
talked about elixir in 2014 and at
lexicon that year I talked about Java
sort of and at lexicon Palast year I
talked about angular and building your
own language so lexicon this year I
talked about home and so we'll also
cover lecture and ex2 but will spend
more time on philosophy then we will
focus on like difficult code on the
elixir side but you'll see stuff so
let's talk about collaboration like what
it is the easiest way to describe it is
you have multiple parties that are
working on something together they're
viewing some shared state together in
this case we're doing collaborative
music but the fundamentals are the
important things so here that shared
States called a thing that Alice and Bob
are interacting with but of course could
be a document or game simulation or
database tables but realistically
probably unless you're building a
database after they shouldn't be
thinking about them as database tables
or yeah in this case it's music so
that's the motivation and I'm going to
walk through sort of how we'll cover it
so we're gonna have like a speed reading
of the history and the fundamentals of
collaboration on the web I already
talked about how it's fundamentally just
multiple parties working on some shared
state you'll note that that sentence
does not mention the word like
WebSockets or real-time or the web or
anything like that
so Phoenix is a framework for lecture if
you're not familiar and it gives us this
abstraction called channels and people
generally say channels how you mean
WebSockets and that's not really right
so I want to kind of talk about that
very briefly so the point is a lot of
people said ah now it's easy to do
collaborative stuff but and it used to
be hard because now we can do WebSockets
with channels and the point is you don't
need WebSockets for collaboration and
phoenix channels aren't just WebSockets
there's lots of transports and you don't
need to be on the web to write
collaborative software and collaborative
software doesn't need to be real-time
and it doesn't need to do ajaxy things
at all
but for Ajax existed I had a I basically
had this like zero with hidden iframe
that I used for something Ajax II like
it was blocking but it was blocking
somewhere else so nobody cares I had
like a queue of them and I just spun out
messages to them and let them do things
this is what
for xmlhttprequest but it worked and it
worked roughly the same way but only
because browsers were terribly insecure
anyway so the point is that work just
fine back then this was in I don't know
is like a year before the sort of Ajax
blog post came out and also normal crud
dress interfaces are also collaboration
they involve a lot of header overhead
for repetitive face to be requests
you're collaborating on a shared like
database probably in any credit app
right so crud is collaboration you're
all changing some shared state that you
can see but you didn't traditionally
have a great way to basically send
updates to the client so push out
connected clients some updates about
what's happened so part of the
importance of sending clients
notifications is sending clients
notifications that's kind of part of
part of what makes things feel like in a
real time collaborative and what's nice
is that phoenix channels make it easy to
do collaboration but they do it by
providing this nice abstraction that
could have existed before WebSockets or
any of sort of newer technologies my
whole point in going through all that is
I wanted to just point out it's the
abstraction that matters back in 1990 in
1998 we had TLS we could have done HTTP
streaming with TLS and at least for one
half of the communication that's exactly
has exactly the same performance
characteristics as WebSockets so like
you could have built the stuff that
people are building in Phoenix now you
in theory could have built right in 1998
and mostly been okay but there were that
made people building this sort of
awesome stuff that's easy to build in
phoenix pectin and that's because there
weren't great abstractions we had like
comet but not in 98 anyway so the point
is the abstraction makes it possible to
do lots of fun stuff and the thing I'm
doing today is one of those things and
phoenix channels are a great abstraction
over this real-time communication so if
you happen to be telling people why
phoenix is awesome please don't talk
about the WebSockets part talk about the
channels bit i guess so
i'm going to tell you a really dumb
story that gives a good insight into
what it means to think properly about
building collaborative software just so
you can also see how not to do it so we
had a custom I worked ran a consultancy
for like a decade and we had a potential
customer get in touch with us because a
guy we'd worked with before knew he saw
them like
driving off a cliff and he couldn't
convince them himself but he said okay
well like just spend a few minutes
talking to Josh and telling him what
you're doing and so he got the guy on
the phone to me and he said I don't know
why I tried to told me to call you but
you know let me tell you were doing and
it turned out that they were basically
building like collaborative software but
with no abstraction around what
collaboration meant and they were gonna
run into a huge problem because it turns
out you have conflicts and they weren't
going to deal with them so yeah so he
said to me on the phone well we have
this one small bug maybe this is what
he's talking about
so has this ever been actually an
accurate statement like in ever anytime
it's not there's not a small bug so
didn't rate they didn't know that their
problem was hairy at all they thought we
have this one tiny bug when we're done
we can ship this thing we worked on for
six months and I told them no you
actually have to throw it all the way so
once they explained what they were doing
I realized like no you've completely
modeled this wrong and like you they
basically hired a very cheap contractors
to do it and they just got something
done so there's always being dramatic
when I told them that it was never going
to work the way they'd built it because
this is not a distributed system you're
being a little when you're being
dramatic we just have a couple of people
on the internet doing stuff together but
that's kind of the point so anyway it
was a couple people that were
interacting with like the shared bit of
state related to like just quoting a
solar panel installation like plan right
so it was essentially a sales pipeline
for solar panel installers it worked
perfectly except for any time there were
conflicts and then like who knew who won
right and they would get out of sync and
there was no real good way for them to
sort of solve it
but ultimately I was able to help them
get a solid product but the point is you
have to think about these things and
just like we're going to use WebSockets
and collaboration is not a good way to
think about them so you have to build
systems that are designed their own
collaboration from the get-go if you're
going to have a happy time and I wrote a
lot about like academic things that I'm
honestly not qualified to tell people
about like Leslie Lamport and total
ordering and happened before and time
stamps and vector clocks and all that
stuff but I would I would probably
butcher it but I'm still glad to talk
about it just not on this stage anyway I
do read about this stuff a lot anyway so
the point is these are like the sorts of
things that you need to be thinking
about when you're going to build
collaborative software
you're not you're going to have you're
going to run into problem so like a
really solid example is in a chat log so
the stereotypical example for Phoenix
Webb Phoenix channels is let's real chat
and the way we do it is we have a forum
we have some JavaScript and you type the
thing you press ENTER and it puts it on
your DOM and then it sends out a message
to the channel and then anybody that
receives the channel message also puts
the same message on their Dom but like
you can look at this and say okay well
like there's no guarantee about the
ordering being the same like on these
two browsers based on the way that's
done so that's problematic so the whole
point is it's about your you should
think of a chat log as like this
collaborative thing like we have this
log and we're all collaborating on this
thing and so if we are then it should be
the same and so if it's not the same
then in chat you can probably get away
with it for the most part but it's still
wrong anyway so we can move on from
there and talk about an application that
I built in elm in Phoenix and I'll show
it off in a little bit it exists as a
kind of introduction to doing real-time
collaboration with these two amazing
tools I think both Elliman and elixir
and Phoenix are really really nice
I call this think a looter and you can
find it on github at Nooter that's my
nickname because I was 14 once I thought
it was hilarious and then a collude er
as in collusion
alright so it's an app that has two
parts there's the elm piece which is the
front end and this is actually where I
built the app initially I did all the
data modeling do all the planning and
then there's a Phoenix piece which is an
umbrella app which if you don't know
Phoenix just means that it's multiple
applications that kind of sit under one
mega repo and work together and the
Phoenix part is just a really thin shim
for the Phoenix channels which are kind
of like that that collaborative
abstraction to send in messages to
what's known as let me just ask like who
here knows in much or much about elixir
Erlang who knows nothing about elixir
Lane okay so in lecture knurling there
are these things called gem servers and
they basically are like these sort of
processes that run on their own that
have you can send the messages and they
have like some state that they can
manage and so you can represent things
that live collaboratively with gin
servers and so have this gin server
protocol that represents like a song
because you're all working
collaboratively
on the same song so there's one actor
living and you're all sending in
messages and he's talking to all of you
and then the actual web piece because
that's all non web right that's just
software and then there's the web piece
that just like makes it easy to send
messages in and out of it from which is
I think a thing that we don't do enough
separation of like the business layer
from like the web layer and I always
want to encourage people to do that
because your web interface should just
like literally just to be a web
interface into an application that's
running anyway so that's sort of how
this ends up being modeled I'll talk
more about that later so I'm on a bit of
crusade to bring these two worlds
together I think they're both really
amazing apart and they're doubly amazing
together
and so when I was actually getting
in-depth into this project I tweeted out
something that just was you know sort of
passionate about at the time that
expressed how I felt pretty well and so
said yeah elm and MDL which is a
material design library for Elm and
Phoenix is like the closest I've ever
felt to come to having actual
superpowers and that's just because I
built something that going into I
thought might be moderately complicated
to like get exactly right all the UX
concerns and then it just wasn't at all
complicated and it worked first try and
that happens plenty but in this
particular case I was concerned about it
so it was like how I always dreamt
programming could be if only it weren't
awful a lot of the time anyway so I am a
full-on fanboy for elixir Phoenix and
elm that's because they make my life as
a programmer fantastic so if you take
nothing else away from the talk fiddle
with one or both of these and if you
really want to go hog wold make them
work together because it's not hard and
I'll show you
so I'll demo that app pretty soon now
but first I want to talk about them what
it does is who here knows anything at
all about Elm okay so about half the
people of C know or know about elm and
haven't so I'm gonna give you a
high-level overview of how your elm
applications work so this is like an elm
application in general and so that a
little bit in the middle you can think
of it the run time and you as the
programmer provide basically these these
green boxes you provide you also provide
the types of what your model is like
your applications model and put your
messages your messages would be like all
the things that can happen in my
application so you have your knit where
you say like this is the initial state
of the world you have your update which
will be
handed by the runtime both any messages
that come in and the current state of
the model and then you'll like return a
new model and you might have that second
command message is side effects so like
things that you want to happen in the
world maybe you want an HTTP request to
happen or something to go off a
WebSocket and then that'll like come
back into runtime and now your model has
been replaced with the new model that
you spit out and then you have the view
which takes the model as its argument
and produces something that that HTML
message is hTML is the type that's
provided and message like is the message
type that you describe so it's
parameterised over that basically means
it can emit the messages that you've
defined that's that's all that means
it's just a type so anyway the model
goes through the view function and
produces some HTML that can produce
messages and so that's for like when the
user Sally here in the bottom right does
stuff but then also stuff can happen
that is not user initiated right so like
the ticking of time or something comes
in on a WebSocket basically things that
the user didn't do but still happened
and those are subscriptions so you set
up subscriptions and they also produce
messages so you Matt you have
subscriptions that say like hey when
stuff comes down on the WebSocket take
the raw data like decode it this way and
then create a message that uses that
decoded thing and send that into my
update function anyway so that's sort of
the whole of Elm and it may seem
complicated but in fact it is not very
complicated at all when you get into it
all right so you totally understand Dell
now here is the Elm side of kelud err
it's not like the most amazing saying
here but this is the Elm application
that I built uses Web Audio in
background and this is not doing
anything calamity this is just like
differently is producing JavaScript when
we make script intersecting you can take
notes and all that jazz so the reason
that I felt like I had superpowers is
because I've wanted to build something
like that for a long time but I want to
put any time into it like it's not like
it was important to my life it was just
a thing that I wanted to do because I
have a lot of I have like some games
that I want to build that need that is a
sort of fundamental building block but
like I knew the JavaScript part was
going to be terrible and that I would be
miserable and the collaboration story
was awful before I dealt with phoenix
channels and i didn't really want to do
it and so what i could have built i
could have built that at any time since
98 but i was unwilling to go through the
trouble and since these things are
awesome i was not only willing to go
through the trouble i was excited about
doing it I did it about I could have
realistically done in a few hours
I did over a couple of days because I
was kind of taking notes as I went
because I produce a training for people
anyway so let's look at how the elm app
itself is built all Elm apps tend to
look the same at the top level roughly
not even russet like almost all of them
look like this or some minor minor
variant so here we've got a program we
say hey I'm going to produce a program
that's all that thing at the top means
that's like telling the the runtime how
to wire stuff up I give it my initial
stuff and so the init on the left that
sort of thing in parentheses is a
2-tuple
so the thing on the left is my initial
model I don't think I should have
necessarily called it in it in this case
but and then the second part is what are
my initial like outbound messages or
outbound commands rather that I want the
wrong time to do tit for me then we have
my update which is just here's the
function once you have a message here's
the function to route it through along
with my model then I tell it how to
render the view and then I give it a
list of subscriptions and these actually
are dependent on the model you can do
some neat stuff because of that it's not
too important right now though let's
talk about the model we have some types
we should talk about first song is a
dictionary with integer keys and tracks
for values realistically this might
should be an array but I didn't want to
have to worry about like what happens if
something like went out from under me
because I there's not a really good
reason actually to have had that
concerned by the point is that I did
model it as a dictionary with a new
yorkese it's not broken so I didn't
wanna go fix it so this is the data
structure that represents like all of
the stuff that you saw in the UI or the
song part of what you saw in the UI
track is just a record it contains a
note so like what note do I play on this
line of that interface and it also
contains some slots and those are all
the things that can either be on or off
and so when the sort of playhead goes
through them if they're on it produces
the note specified and then slots again
is a dictionary with integer keys of
boolean so like is the slot on or not
that's all that means
so then there's the model there's a
whole lot of fields at the top here up
through song that are completely
irrelevant to anything except for
setting up the initial kind of music
part on the JavaScript side so we'll
completely ignore them and actually some
of those should like not be there anyway
they still need to be there but then we
have like our song we know what the
current note is and that's just like the
pass through the that's where the
playhead is essentially we have the
total notes this is a silly field that
ultimately shouldn't need but again I
haven't needed to remove it yet so not
that important whether or not reposed
what beats per minute we're playing at
that mvl bit is just stuff that is used
by the material design library that I
use sort of to manage internal state and
then we have these last two bits and I'm
going to get to them a little bit in
more detail later but like when you saw
the modal come up where we were changing
the note on the track this says like
track being edited you may be editing a
track if you are it'll be in just some
integer which represents the key in the
in the dict for that track that you're
editing orally nothing if you're not
currently editing one and then a chosen
note you know it's like a multi-step
flow so I represented sort of that
wizard as these two pieces of data kind
of mixed together which is the part
that's not great so the chosen note was
like when you pick the first part of the
wizard so it may be a string or maybe
nothing anyway so that's the type of the
model and this is an instance of the
model so it's just a record of that type
that has reasonable starting values it's
all that first bit up till song gets
filled in by the JavaScript on the other
side and a few things I have an initial
song it's super basic it's empty with
two tracks starting point for the
playhead is zero total notes is some
number it's not important
we are playing we have 128 beats per
minute we have an initial material model
and then we're not editing a track and
there's no chosen note in the wizard
so I pre populate the song as just two
tracks each with a fifth octave a note
and 20 false slots right so this is if
you haven't seen elm code this is fairly
straight forward elm code right several
notes as an integer it happens to be
twenty initial song we start out with an
empty dict we insert with key zero a
track and we insert with key one a track
and then a track is MIDI note 69 which
is the fifth octave a there's last two
bits aren't terribly important because I
don't let you edit them and then the
track slots okay so I have like zero
through total notes minus one so I have
20 of these things and that lifts up
fold L right it's just folding across
that initial list and accumulating into
an empty dict a new dict with that slot
ID and false so that one a little bit I
probably could have made a little bit
clearer but it's not confusing to me
anyway it's kind of important to be able
to do stuff to your model and this is
where updates come in so elm is an
immutable language because otherwise I
wouldn't use it so how do you change
something in an immutable language so
we're not confused right it's the same
thing as I mentioned our language in
service or elixir gin servers they have
they're the same situation elixir
darling or immutable languages so like
the whole trick is you have an initial
state and when a message comes in you
produce a new thing that represents the
new state and then your function
basically like wraps that and passes it
on to the next piece which is generally
a loop so you don't change anything you
just call yourself with different
arguments and then you have tail call
optimization and things are okay and
things don't blow up anyway so just a
little primer on how that works in both
genders and now I'm glad to talk about
it more detail later so you can dig your
application is constantly folding or
like reducing over incoming events
through this update function using the
initial model as the initial State
that's all that this whole trick is or
going to give message as if you know it
looks are like a gen server cast and
update is like the handle cast function
so what kind of things happen in our
apps this is the whole list it's awful
and big and flat and seems overwhelming
if you just look at it it's kind of a
grab bag of different stuff I'll break
it out into some smaller pieces and
we'll talk about those so this is the
Web Audio that this is just some piece
that I created from an exist
open-source project that did the initial
sort of web audio setup because I didn't
want to figure it out from the get-go
and it was already done and it seemed
great so that's why I said this part
wasn't terribly important because
they're just in JavaScript on the other
side that interacts with these updates
and these messages and like sets the
stage so that you can play music nicely
like loads in a sound font as one
example and starts a web audio object so
not hugely important but what happens
ultimately is we find out if we can use
OGG we go load the sound file we ask to
load the sound fonts we're told whether
or not that worked we ask it to play
notes etc these go reports into the
JavaScript runtime which you can ports
are like how you do Interop and that's
sort of how this works in a lecture
there's also ports it's the same thing I
guess how you doing off with other
things one really cool part of ports is
that since this is a strongly typed
language they do something that they
call border control in elm which makes
sure that the data you can't send
anything across report that the port
doesn't know how to deal with so if you
have a board that says I turn a string
into messages and you say ah hi yes I'm
going to send a one across that port it
stops on the JavaScript side so that's
the board of control right there's you
never on the Elm side have to deal with
anything being like maybe not the right
shape like if you're running JavaScript
adversely guarantee you have 8 million
lines in your codebase they're like well
I told people to give me an integer here
but what if they gave me an array of
three Nils or something stupid right so
anyway so all this stuff basically lets
us make noise in the browser so we want
to talk to Phoenix so we have a message
that tells us hey I'd like you to
connect the socket and then we say hey I
got a message back and this is managed
by a library that I use and then receive
state says like here's your new state
your new model that the server gave us
and it's just a json encoded value when
we get it from JavaScript and then we do
decoding into our actual types on our
side anyway I did write there's in in
Phoenix channels there's also distinct
called presence so you can know who's on
the same channel as you
I wrote support for it but I don't use
it here here yet I would expect
ultimately to like be able to say these
are the three people that are playing
with a song with you okay so the actual
app that you have that's doing stuff not
the other bits we talked about playing
music or talking to fee
but the part that you know we saw
standalone is this right so we have the
ticking of time represented to like that
just tells us hey the app ticked like do
whatever the next step is we have check
note which just lets you pass for a
given track ID and slot ID whether you
want it to be on or off we have set note
which lets you choose for it is badly
named let you basically say this track
should be a third octave a or a d7 or
something and MIDI note is its own type
we have add track which says like I'd
like another line in the sort of song we
have set BPM which is how you change the
beats per minute
toggle Paul's turns it off are on set
editing track choose a note and choose
off divert all three kind of combined
part of that wizard that we saw and
that's a bad model I'll talk about that
further i delivering this to the update
function the drives all this so can i
better read this again so this is not
unusual like in elm it's encouraged to
have these big flat update functions
just because in practice it's not
problematic there's a lot of code here
it's not complicated to work with this
code like I've never ever ever gone into
this code base and gone like now what
does this part like it's really really
straightforward so we'll walk through it
in much smaller chunks because
legibility okay so like initialize audio
context just says like we send the thing
out a port that says like please make an
object for me in JavaScript and then
response all your context is then
telling me oh cool you have one here
this request dog enabled that just lets
me know whether or not I should use the
auxiliary soundfont request load fonts
you tell them like here's where the
fonts are please go get them and then it
tells us whether it worked or not and
then request play note says hey right
now like play this note that's it and
then there's very thin JavaScript on the
other side that knows how to deal with
all this it's maybe 40 lines of code and
could probably be less and then I get
find out whether I played the note or
not on so they don't give a crap like it
works so bad I could care and then
toggle Paul's right all this does it
takes our model and it says like take
the pause field and set it to the
opposite of what it is right and then
that bang empty list thing so the return
value of this let me go back to here so
I the
talking about syntax because I'm sorry
other people here have not seen ohm
there's an update function that takes
two arguments message and model and
returns a third saying and the types the
type of message is this upper case
message type of model is a separate case
model and those are just things that I
defined and then it returns this to
topple write the model and then some
commands that are that will be mapped
back into messages so that's that's what
the return value is so here you see I'm
returning two tuples and that's seems
reasonable right because that's the sort
of thing I'm supposed to return when you
come over here I've got this other thing
I'm doing with it's like bang at the
list and all that is is some shorthand
people get confused when they see it
because they should it's not like
well-documented often it just says like
here's my model and also I don't want to
do anything or here's my model and
here's my list of commands but that way
you don't have to write a two tupple
because it would be like three lines
long if you want to follow coding
standards anyway so it's it's silly
shorthand all right so then we have like
tick sub which is a list of
subscriptions so it takes our model it
says if we're paused then I'm not going
to like do anything when times passing
but if we're not paused then every
minute times the interval for the model
which is one over the beats per minute
we're going to send a tick so basically
that just sends ticks at the appropriate
timing based on the BPM setting and then
when we tick I don't care about the time
like that's what that underscore means
so there tick also gives me like here's
the time but I don't care about the time
at all I just care that we ticked so I
take our model and I pass it through
that's a pipe you'll see these in both
the licks R and L m and all it does is
it passes in this case the last argument
to that function is passed as the thing
that you're piping through it in lick
sirs case it's the first argument but
those there's various reasons for them
to be different so I have this update
notes function I'm just passing through
to the model and all it does it says hey
take the current note incremented by 1
and in modulo total it's right because
we want to wrap back around and then we
have our command that takes our model
and request some notes to be played and
so what we do is we go through the get
notes function that says like here's
where the playhead is what note should
be played right now based on the state
of the system and then go ahead and map
that through a list of commands that ask
JavaScript to play that note check note
just takes the model and updates the
song
I updating the track with the checked
slot but whatever you checked and then
it actually call this check note
function which actually is sending stuff
out over the over the WebSocket piece
over the Phoenix Channel so that's maybe
moderately confusing but basically I get
my new model and then I'm like well I
check the note and here's like the new
stuff and here's what to tell people I
checked
similarly with set note which sets the
the note for the track I do the same
thing I update my model and then I have
the set note function that's just like
produces the outbound message for the
Phoenix channels ad track fairly
straightforward you take the dictionary
you insert a new track with the new
track ID which will be the size of the
of the model or the size of the song
which will be you know n plus 1 the
length and then we we have ad track
again which does the thing it tells the
Phoenix channel like I've added a track
and then set editing track and choose
note just update those two bits for the
wizard for changing stuff so that was
maybe lengthy but like it's a relatively
complicated application and we went
through all of the things that it can do
in not only five seven minutes so I like
that it's pretty great I don't end up
with a smooth of an architecture when I
just like craps and JavaScript into an
editor I guess I haven't covered
everything because there's also the
choose octave piece this is the awful
piece this is actually up till now
things were moderately okay like you see
stuff and things seem cool but then like
when you're finished with the wizard
this is the code to UM actually change
the note for a given thing and there
ways I could have like made it made it
smaller with like if maybe that with the
default in the case of a nothing but
that wouldn't be the right solution the
right solution is to model the thing
differently and I'll talk about that
later again but ultimately like we
assuming that our state was reasonable
for to route because we could receive
this choose octave message technically
without having attractive to be edited
just based on our model there's no way
in the UI presently to produce those
messages but there could be and so
that's sort of why this is modeled
terribly but anyway we do end up
updating it and we tell people that we
updated it and then when we connect to
the socket we use this phoenix channel
library to go ahead
neck to the socket which returns us this
so we start off with this channel so in
theory I don't have it wired up this way
but in theory you could I got my server
supports arbitrarily many songs so like
if you just looked at the URL and like
took a good and like made it a shareable
URL then it'll support multiple songs
being edited at the same time so that's
what the channel name is is just
whatever whatever would be after the
slash but it's hard code in this case
and then we have like an initial phoenix
socket so the phoenix socket in this
case that phoenix socket in it is just
like data right it's not doing anything
it's just data and then what we do is we
pass both those things through this
phoenix about socket joint so we say
take this phoenix socket init which is
data representing a socket and tell it
to join this collusion channel but it's
not doing anything it's just returning
well here's what the sockets data would
look like afterwards and here's like a
command that you should send back out to
the runtime if you want that to happen
so i collect both of those and then i
also add this on collusion state so like
when i get a new state from the server
pass it through my receive state message
like our map it through this it's
actually a function receive state that
takes a single argument that is like the
model or a song rather and so it says
like when that happens given this
collision channel name mapping into
receive state and it just gets a JSON
value and we deal with it later anyway
and then we update our socket the data
piece because otherwise it would get out
of sync with what it should be and we
use command map to send out the messages
to the runtime and command map says like
there's this Phoenix piece that knows
how to deal with all these messages that
I don't know how to deal with they're
like sort of opaque to me and so all I
do is I mapped them into a my message
type which is Phoenix message and I just
hand them over to that update function
when I get them and it'll take care of
like making stuff good now I have to
think about it there's a lot of stuff
that worked this way anyway when I do
receive a state ID decode it with a song
decoder and if there was an error
decoding the song then I just like don't
do anything but I happen to have put
something out of the console but if
there wasn't there the decoding the song
I replace our song entirely with it so
like my entire collaboration strategy at
this point is throw away all of our
local song and replace it with this new
one any time we get a new one and for a
small number of people this is fine but
the point is I thought about it
anyway and so when we get the Phoenix
message thing we just pass it through
this Phoenix dot socket dot update and
whatever it gives us back we replace as
our socket data and then we send out any
commands that it told us that we should
send and again we map them back so that
when the command comes back it's sort of
wrapped by our Phoenix message type so
that we know to send it back to this
component this is perhaps like maybe
confusing if it's the first time you've
seen but it's not it's not confusing in
practice anyway so that's all the update
stuff and we covered all kinds of stuff
there between using an external UI
library that kept internal state to
using like this Phoenix thing that keeps
internal state to deal with Phoenix to
doing all of our stuff to doing setup
for music so there was a whole buncha
stuff that's happening but ended up
being like five pages of code and all of
the things were like two three lines
right so with the exception of that one
terrible and anyway so let's look at the
view all the view does again to take
your model and produce HTML that can
produce messages and so here we have
your body which is the core of it and it
takes our model I'm using this LM CSS
thing to produce some Styles that's not
hugely important it's just a few minor
things so I'd send those in just into
the dom there with a style node just so
they'll apply you can sort of see here
how you see divs and then you have a
list of things that's a list of
attributes and then you have another
list of things that's a list of children
that's how all of the HTML stuff works
in elm and then we have five pieces that
I've broken off into functions of their
own view metadata view top controls view
song editor view dialogue and view
connection and so that's the sound a map
to the actual UI that you saw a second
ago so that top fits the metadata then
we have the top control the song editor
the the dialogue you don't see unless
it's being shown and then the view
connection button and so I just wanted
to walk through those so this is all
that is right I have the current note
and I show the models current note as a
string I have paused whether or not it's
paused and I just turn that into a
string so that's straightforward enough
the top controls this BPM and I've
actually modified this a little bit in
the demo that I'll be showing you but in
general we have like this pause button
and then we have this thing to edit the
BPM and it's a little bit convoluted
honestly the button that render mdl bit
this is because of the way that this
material design library I use works it's
not hard to use but it's definitely not
the best thing to show someone who
hasn't cmlc known before and be like
look how easy this is because
it's a little bit more complicated than
it should be anyway but it's also like
is really nice so again on that text
view so a button that on click emits a
pataga paused message right and then if
they're like a laser one would assume
whatever there we go and then on input
we set BPM we parse this string as an
integer and then like if it was an
invalid string like you entered the word
I don't know
tofu that's not a number right so then
it turns it into 128 so it doesn't parse
an integer it turns into 128 then it
passes that 3 to set BPM and that's the
message that gets emitted anytime you
change the input and then the song
editor itself we have track rows so what
I do here is I take the song which again
is a dictionary of tracks and I fold
them through this function with I start
off with like this empty list because
these are going to be the children of
this table so start off here I fold the
dictionary of tracks through and I take
the accumulator which starts off as this
and then I add on the list that has that
the result of the view track function
with the model the track ID and the
track and then the fold is going to get
the track ID the track and the
accumulator because I'm folding through
dictionary right so this is the key as
the value of this accumulator anyway so
that's how that works and then I
basically have this table and I just
show the track rows as its children so
that's like all of these are just that
one tiny like value and then I have the
add track button that emits an Ontrack
function our message and then viewing a
single track which is the function that
we mapped over here right we would kind
of pretend that this existed well here
it is so it gets the model it gets the
track ID and it gets the track Binga and
produces HTML and so we have like we
take the track slots we turn them into a
list we map that list
overview track cell which is this
function we'll see in a second we tell
it what the current note is because it
needs to be able to draw this black line
if it is the current note and we tell
them what track idea is dealing with and
so then we like add all of those track
cells we add after this one initial TD
which is the view track metadata which
is where you change the net thing and
the reason I'm going through all this is
just to show you like it's real
a complicated application but it's
pretty understandable in all of its
small parts and that's kind of a thing
that always happens with them it's very
easy to understand in the small viewing
attracts cell that's what one of these
little squares is basically we have some
more styles right the current note if
it's the current note so this class list
will apply whatever this classes if this
is true and it won't if it's false so
it'll be checked if it's on and it'll be
current note of its current note so if
its current note it'll have that black
bar on the right if it's checked
it'll be red and then it's just a
checkbox that I've styled a particular
way and then I say whether or not is
checked and then when you click it it
will get checked obviously and when you
check it it's going to emit this check
note that knows the track ID in the slot
ID that you just checked so that gets
routed back up to our update function
then we deal with it viewing the track
metadata we have this like MIDI table
and we like basically figure out what
model what note you're showing and we
share that as text and then when you
click it it's going to start it's going
to set editing track which will tell
trigger the dialogue to show this is the
dialogue that so if the track is if
there's no track being edited then like
the dialogue would show this about
function but you actually don't ever
open the dialogue without that anyway so
you know whatever sees that but if there
is a track ID then when you show the
dialogue it'll view the note the track
notes user and then this is the track
notes user right it says like pick the
note and so if you've chosen a note then
you'll pick an octave next but if you
haven't chosen a note then you'll pick a
note and so that's how these two things
happen and then finally when you pick
the note we will just like emit that
message wherever it is but you shoot
close on click that's a close pick the
note of the note buttons themselves have
that sorry they're right over here now I
don't show them anyway the note buttons
know what message is to emit and octave
dialogue looks the same this is terrible
anyway and then we have this view
connection right so if you're connected
then it doesn't show anything it shows
an empty div but if you're not connected
it says hey click this I'll connect the
socket and that will talk to the Phoenix
piece so that's the whole of the Elle
map location it was a long discussion
but you've seen a giant o map giant
you've seen a relatively complex LF
ocation now then we have the Phoenix
side of things and so I wanted to start
off with like a preface I'm kind of dumb
I used to think I was smart but then it
turns out now so I'm going to show you
why that is I'm always telling people
like in the rails community or elsewhere
like rails is not your app
Phoenix is not your app right I've
mentioned it earlier right it's just
this wrapper around your app so the some
people do things like they take a
database before they have written any
line of code that seems dumb to me I
don't think you need persistence yet you
don't have anything anyway so imagine my
dismay because I found myself doing this
and these are Phoenix generators but
basically I just generated a model which
already says like we're going to store
this thing in the database we're going
to have some tracks I don't need a
relational model for this there's a song
like I don't need to do any joins I
don't need to do any analysis of this
it's a freaking song and so I started
off here and this was dumb and I
ultimately realized it was dumb because
I tell other people that is dumb and so
this commit existed but I very quickly
got rid of it my point though is the
song is just this giant blob it's not
relational data so why was I using a
relational database I killed this with
fire and I replaced it with this so this
is an umbrella F it has two pieces it
has collusions which is the part that
deals with these collaborative songs
existing conceptually and then we have
the web piece which is like oh wouldn't
be nice if I could interact with them
from the web so these are both OTP
applications if you know what a lick if
you know what those are but basically
there are these separate applications
you can start and they happen to
interact with each other anyway so we
have no TP app that runs some gen
servers to manage state I'm going to go
through this part fairly quickly but
this is the exact same state as before
just I poured it very mechanically from
Elm to elixir I'm going to build a thing
that can do this automatically but
there's not yet extant software that
gives you the abstract syntax tree for
home code so I did this by hand this all
looks like if you squint it looks the
same so we have a song it has this like
dictionary of tracks we have two initial
tracks right you've seen this before
there's that initial slot note 69 and
then we create 20 of them right again
there's our sort of update function no
we can zoom in and it's a normal gen
server and if you look basically we say
okay like so where's the song that
you're trying to talk about so I say
start link and I give you a name and if
it doesn't exist then we start one if it
does exist then we just return whatever
it was and pretend like we started it
here's our server and so this is just
like the the gen server so you can ask
it what track
there are you can ask how many there are
you can ask for the total slots and you
can get the value of a given slot it's
fairly straightforward stuff and these
are all these are doing is just calling
out so this is the public API and the
way this works is you have your process
that's running somewhere else and then
this is like the functions that you call
and they use gen server call to talk to
your process and get data back so the
actual implementations of those on the
server side or still in there sorry
these are this is more of the public API
so you can like set a slot set a no data
track get the state get the state is we
use that a lot and so this is the
implementation of all that it's not that
exciting you basically are just doing
the same thing we saw on the Elm side
just with these elixir data structures
they're almost you know all of the
things you can do to modify the song
exist in both places and so then let's
see here yeah so this is just a little
bit more that didn't fit on that I guess
so it's somewhat lengthy but it really
is everything we do for the whole song
so like it's like maybe three pages of
code at most if you have a big font so
it's not crazy for like a collaborative
song tool and so then this is we have
the gem server we'd like to be able to
modify it when you make changes in your
own application so we want changes that
you make in the UI to like change this
thing that's running somewhere but of
course it's not running in a web server
yet so what we want to do is we want to
wrap it with channels and so this is the
general idea these provide an interface
to send messages in from the web piece
so this is a quick channel that lets us
send messages I have this kind of
refresh rate where I send the state
regardless like I send it every second
regardless I don't have to do that part
I just happen to it's dumb and you
shouldn't do it if you're doing this
anyway so when someone joins a channel
it basically says you know they join
collusion : some name foo bar is the
default one and what it'll do is it'll
start a collusion or start one of these
songs with the ID foo bar and if it's re
running and just get the running one
back so some ones are connected to it it
gets their you know they're both working
on the same state now but if they're not
they'll start a new one and then they'll
send this push state message to itself
so that's just so that it can finish
this function and like come back to
handling the next message which is the
piece to push the state and then we
return it state and that state is we
take it's the socket we had
not only the state but anyway we
assigned the ID and the process ID into
the socket just so we can look them up
easier later there's just kind of some
local stuff you could places you can
store stuff when someone sends us a
track ad we send inclusion server ad
track and then we tell everybody about
it broadcast state and then we reply
cool and we update our socket we didn't
change anything but we returned our
socket is it's a new socket when
somebody checks a note again we just
defer to this function that knows how to
check the note we tell everybody about
it and then we say okay similarly they
set a note same deal I mean we're just
calling a function do a thing telling
everybody else how it happened and then
we're done and you could do more
interesting stuff than just broadcast
the state you could like specifically
send this note was checked but it's
really easy like with a few number of
people that make sense in one of these
things they just tell everybody like
here's the whole new state right now but
you can be somewhat the point is that's
where you would be smarter if you wanted
to make a smarter server and then push
state basically every refresh records
great seconds every second we push the
state to everybody regardless of whether
somebody's doing anything just in case
something went wrong and as well as
being overly defensive I didn't need to
do it it definitely does not cause a
problem and then broadcast state just
tells everything ssin that tells
everybody what the state is so that's
like the whole everything so this on the
one hand it was kind of deep on the
other hand it's really kind of cool app
and I don't know we looked at maybe
eight pages of code so not that much so
here this should work you have a laptop
out anybody has a laptop out visit that
you can pull it up on the phone I have
not taken any efforts to make it nice
and it's a table so it should work but I
doubt you're going to have the best of
times and so then let me get out of here
like this no how do you have that okay
so I'm going to refresh and we should
all be on the same thing part like that
you can see it anything
that bitly /m - Kluber it's running so
slow I'm going to take that off just so
I can increase the beast a minute
also it runs it uh because it didn't
have a focus the browser was not like
preferring it so as a it was running
slower than it should anyway and move
this over there
so you should be able to go there and
change the song I'm not going to touch
the thing because we were able to go to
yes or let me change that URL for like
the nicer world hi goodbye last gesture
dangerous
now you will be running at a different
beats per minute that's not thinking I'd
continue the song itself insisted on did
you give up
it doesn't show the reason for that
oh but regeneration exactly never put
the button to come back the next event
but someone's doing something I need
do
and after this part down here was
contributed by a
anyway doesn't say a crazy amount of
code and it's nice and it's not
the magical at all and I can make the
whole in writing really two parts always
just by writing a sign for this one
still different generalizable
you would want to use a subversive
nature
in the
I feel like this is like the part where
you have a crazy single day
in
that's the same
anyway so that is that is the the whole
of the thing that I built but I wanted
to go through just sort of how nicely it
was - how nice it was to do that sort of
thing in in Elmen elixir and again like
I could have done this in a couple of
hours not like Tooting my own horn here
it's just like it's not actually
complicated it's complicated if it's the
first time you're seeing both elemental
looks at the same time for sure anyway
but I mentioned a few things about how
this was done
and I think I have like ten minutes left
first of all does anybody have any
questions because otherwise I'll end up
burning too much time with this next
piece all right so I'll talk through how
this is done
so there's this thing like making
invalid things unrepresentable or make
impossible States impossible this
concept and this is where I failed at
that so I have in my model I had this
track being edited it's a maybe integer
and I have the chosen it which is maybe
string what these are representing is
conceptually like a three step flow
through a sort of a wizard so I could
have modeled these as a union type where
like the first one was not editing and
the second one was editing track integer
and the third one was editing tract
integer with no note and the fourth one
would have been like non-existent right
because that's actually another message
that I met but the point is then I
would've had a union type I would had
only a single value to cover this and I
wouldn't be dealing with like this
essentially this matrix of like all the
possible maybe states because these are
really these are the same thing they're
like parts of the same idea but I'm
tracking them separately because like
because I'm using them as maybe is I
have this awful like waterfall of
badness where I have to check to see
like is it a nothing is that a just
thing and so like this is how I could
have modelled it right no chooser where
wizard would be pending you'd have track
being edited int and you would have
chosen note where you have the track
that's already being in an edited you
know about that and the string which is
the note you chose and then I could have
tracted as a single thing in my model
and then I would have just started out
in the pending state so the point is
anywhere anywhere you have and this you
know whether in your L you're an Elmer
Haskell or any anything where you have
multiple bits of data that are like
maybes but are used in conjunction with
each other
you really have something like this
almost certainly you have like you can
model it instead like this and then you
can I would never have this code right
this code is the only reason this code
is awful is because I didn't encode it
properly now the code would be like are
we pending then we do this our editing a
tract and we do this we're choosing a
note we do this and here we like have to
kind of derive that based on the state
of these maybes so the point is the code
would be like two lines of code instead
of 18 here 7 of 12 so it would look like
this right set editing track would set
its track being edited choose a note
would say look if we are in the track
being edited States and we do something
otherwise we don't do anything anyway so
the this code is obviously I think
everyone will agree that this code is
simpler than this code they're not
simpler quicker to read minimum anyway
so that's just the point I wanted to
make about making impossible States
impossible right you can if you take the
time to encode things into your types
then you can build better code faster
that's like easier to read and says more
about what it is right it wasn't maybe
chosen note it wasn't like those two
things if the idea was like we have a
wizard it has this state as this trains
like very ordered steps and so instead
of making people like figure that out in
their head by reading the code and being
like oh this is how we use these 2
maybes together well you just say
there's a wizard here the state to have
anyway so that's all I have thanks for
listening and if you don't get anything
else out of this I'd love to convince
you to play with either Phoenix or elm
and ideally them together anyway thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>