<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Talk: Deliberate Architecture - NDC Techtown 2017 | Coder Coacher - Coaching Coders</title><meta content="Talk: Deliberate Architecture - NDC Techtown 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Talk: Deliberate Architecture - NDC Techtown 2017</b></h2><h5 class="post__date">2017-12-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9e3lflYhNd8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Robert small Shia I am going
to talk about deliberate architecture
but actually I think the subtitle here
is probably the real title of the talk
it's about responding to requirements
rather than following fashion so I'm
going to talk a little bit about fashion
this morning so industry is very
different from other injury industries I
think like aerospace engineering for
example or reservoir engineering well
something I have some experience with
insofar as we have an exponential growth
almost in terms of the number of people
engaged in building software in the
world I mean it really is growing at
almost unmanageable rate and so our
industry is almost unique in and that
insofar as that has also been true over
a fairly long period of time now and I
expect it to continue as software works
its way into more and more areas of our
lives and our business the second
interesting aspect of the demographics
in our industry is that many of us are
effectively self-taught amateurs when it
comes to software engineering even those
of you in this room who have a degree in
computing science have a degree in
computing science not a degree in
software engineering and these are quite
different things
I remember that computing science has
almost nothing to say about computers
but at the end of the day software
rights that never gets executed on a
computer isn't very interesting in the
business sense
the third demographic aspect that leads
to the states that our industry is in is
the fact that we have very high turnover
in our project so you can think about
turnover within a project or turnover
within a business and if you look at the
numbers you'll find that the half-life
of a software developer with respect to
a particular project or particular code
base is about three and a half years so
what that means is that every three and
a half years you can expect half of your
colleagues to be replaced by new
colleagues as people move on to other
project
it's okay so essentially we are a
collection of rapidly growing
inexperienced amateurs and I mean you're
laughing because you know it's true I
mean how many people here actually have
a degree in computing science okay so
maybe a quarter of the people in the
room how many people have a degree in
software engineering like three people
all of you might know so the one of the
effects that arises from this is that
rather than us being driven by good
engineering principles and good
engineering practices like the people
who build our aeroplanes we are very
much driven by fashion essentially and
here we have clothing fashion I think
it's an interesting example because the
functional requirements for clothing
haven't really changed for a very long
time right I mean they they have a need
to fulfill a few basic needs right they
need to protect us on the elements this
is more important in somewhere like
Norway than other more Clement places
and they need to preserve our modesty to
the extent that we are interested in
doing that but in spite of that there's
a lot of churn in fashion and you know
I'm wearing some clothes that are
fashionable now and they may not be
fashionable in a few years and vice
versa
stop looking at my trainers like that
these are like two years old so things
change but not necessarily very good
reasons but people feel strong emotional
urge maybe not some of the guys in this
room to keep up right I've hidden my
drink in the undergrowth here so
actually I do have one piece of good
software architecture advice and it's
the only piece of real solid advice I'm
going to give you it's on this slide
already and this autumn or fall as
Americans would call it layered
architectures are in what's interesting
there is I mean that's a very visual way
of looking at the Hera fashion is
presented but you know we as an industry
are very much guilty of doing exactly
the same thing and we we know we talk
about some things with metaphors which
are very pejorative we talk about
spaghetti code or ravioli code and we
have these nice visuals which look
nothing at all like any software I've
ever seen right which shows something
which is I imagine this is supposed to
be presented as a good thing these
little bubbles floating around and these
they almost look like cells don't they
these micro-services here or cakes or
tarts or machines and software doesn't
look like this but we feel the urge to
present it in ways that make it
appealing to us particularly textures
need to be appealing okay cupcakes are
much more appealing than many other
types of food to most of us so you know
I haven't drawn these right these are
taken from consultants industry reports
right on I'm not gonna name them on how
to promote for example microservice
architectures and we promote them as
cupcakes with cherries on top lovely and
if you don't like cupcakes you can have
donuts so also from a industry report
now there's an irony here because one of
the consultants is out there which has
produced some of these pictures is also
quite well known for another product
they produce I think every year which is
the Gartner hype cycle so who here is
familiar with the Gartner hype cycle
it's essentially a model of why things
are our fashionable
so you can see here we have some new
technology is introduced innovated a
technology trigger and then shortly
afterwards we pass through this peak of
inflated expectations where all of our
hopes of being saved from the mess we've
got ourselves into are pinned on this
new technology and we have vastly over
inflated expectations of how much
benefit that can bring to us we only
look at the good aspects of the
technology at this point we don't have
the experience to understand the
negative sides of the technology so
we're only seeing the upside risk we're
not seeing the downside risk but over
time as we build experience and learn
about the trade-offs involved in using a
particular technology the enthusiasm
begins to fade and we discover that some
of our choices perhaps we're not so
smart and we enter the trough of
disillusionment I don't think the
horizontal scale on this diagram is
linear by the way because after some
extended period of time when we begin to
understand the trade-offs when we begin
to understand the context particularly
the context in which technology is
inappropriate in which it is not a good
fit then we ascend the slope of
enlightenment and ultimately we reach
the plateau of productivity and actually
finally begin delivering value to
customers rather than just faffing
around with new technology
so it's interesting to think about how
some of the technologies we might be
familiar with have travelled along this
curve and indeed are traveling along
this curve now so I've just put some
sample software architecture styles on
my picture here where you can see them
travel along so it's a very old
architectures like pipes and filters and
layered architectures plug-in
architectures Model View controller
architectures and many of these things
are over in the plateau of productivity
now they're fairly well understood we
know when to use them we know when not
to use them unfortunately some of them
are very unfashionable even if they are
an extremely could fit to the problem
particularly things like pipes and
filters architectures and many
architectures have traveled this cycle
more than once in disguise you know so
we've had small talk MVC and then web
objects MVC and then spring MVC and then
Ruby on Rails and all the rest of it and
so these things have so you know they
live another life in with another name
some things seem destined to stay
perhaps for an extended period possibly
even forever in the trough of
disillusionment things like
service-oriented architectures others
have perhaps recently passed the peak
event sourcing very exciting new way of
thinking about building systems storing
a log of everything that's happened
people are now really beginning to
appreciate the problems associated with
that particularly in light of new
European Union privacy regulations
coming in and the fact that storing
everything about everybody forever might
actually be a problem and then we have
Micro Services which is probably at or
near its peak cupcakes if you I'm sure
they are and I think there's no small
irony that service-oriented
architectures are in the trough here and
micro service-oriented architectures are
it there
really the same thing apart from
questions of scale and then we have
things which are very really very much
in the ascendancy now I made this slide
about a year ago so it should serve
Ellis should probably be rather higher
towards the peak at the moment it's
probably getting a little nearer to the
peak of inflated expectations but people
are very excited about it I'm excited
about it we're building a system that's
using serverless technologies right now
because we're excited about it so even
people who understand their own floors
like me are susceptible to the the
problem I'm talking about we can also
put practices on this diagram I mean I
think I really think agile has passed
the peak of inflated expectations
lots of people these days are conscious
with some of the failings of an agile
method methodology especially agile as
commonly practiced rather than agile as
was originally intended which are quite
different things and software
architecture practices like actually
bothering to design your software which
is not really doesn't really fit into
agile I like to think that some of those
things are coming back now and we're
much wiser in how we apply them we're
smart enough not to spend months and
months doing big design at front ok but
we are
I hope smart enough to think about many
of the other good things that software
architects are talking about 10 or 15
years ago I guess UML is always
can it be here there some things you
just have to abandon there they become
historical artifacts they were
interesting at the time even people like
Grady Booch who was the driver behind
UML I think now largely regrets it but
we learned something there we learned
that building systems of code from
diagrams doesn't really work very well
except in very narrow domains so the
reason everything is very fashion driven
is that we are deeply compromised biased
individuals and it's extremely difficult
for us to be objective and I am NOT
going to go through all of these biases
now they're probably all in play
concurrently at any given moment but
let's look at a few of them availability
gas cade at the top was an availability
cascade bias that means that if you go
to a conference and every third talk is
about microservices you begin to think
that micro-services are a good idea
subjectively even if that is not
necessarily true in your context alright
so just repeated exposure to ideas
because they are popular makes you think
they must be intrinsically good so you
have to correct for that remember that
as you go through the rest of this
conference or in fact any other
conference the recency effect you've
probably seen these things in like in
magazines and things like music
magazines have you know best records
best music made ever right and they're
always heavily bias towards music in the
last 18 months right because people can
remember it and also because people are
young right people who read these
magazines are young they haven't had the
they haven't lived through the 70s and
80s 90s alright so there's a strong
recency effect hyperbolic discounting
this basically means that our future
selves regret the decisions that we make
today right as that happened to anybody
here we discount the the true in
act of the decisions we make now we
don't understand the full cost of them
in future and that's compounded by the
fact that we tend to leave projects
because of the high turnover so rarely
are we exposed to the consequences of
our own decisions yeah and I think the
last one was pro innovation bias just
because something is new and fancy it
must be good so where does this leave
the Software Architect we tend to think
of software architects as people
concerned with the structure of systems
how the large components or modules fit
together what their responsibilities are
how they relate to each other and that's
maybe quite a traditional view of
software architecture I there was
something else that when a lot of the
classic software architecture was done I
guess back in the late 90s around the
turn of the millennium there was a lot
of talk about software qualities and for
me this is a really central aspect of
what software system design should be
all about so the structure is important
but the structure is there in order to
facilitate the building of features and
to produce systems with particular
qualities and this is really tricky and
it's really tricky because it involves
trade-offs and making trade-offs is
really hard because you have to
understand that if you chase after one
particular quality of the system you're
going to compromise some other
particular quality of the system so not
all of these are drawn in opposition to
each other but I'll just highlight a
couple that I guess the classic
trade-off is performance against
maintainability and doing another talk
later today where you'll see an example
of this I'll show how to make some code
much faster but a significant
significant cost in maintainability when
you optimize things you're making them
easier for the computer to do and harder
for us to work with usually security and
usability tend to trade off it's kind of
annoying doing all those sign-in things
isn't it all the time it gets in the way
of you actually doing what you want to
do many things can be traded off against
of course making reliable systems tends
to be more expensive than making
unreliable systems so understanding the
trade-offs involved is really for me
what and the trade-offs in qualities in
particular is really for me what good
software engineering and system design
is all about so you might think that the
chocolate cake and the Apple are you
know obviously they have very different
qualities but one of them is definitely
a lot more tempting so I really want to
talk about deliberate design for
software qualities how can we begin to
think about building systems or just
getting the right frame of mind to build
systems that have the right qualities so
I mentioned Grady Booch a few minutes
ago and we're gonna go back to some of
his thoughts on this he may have
produced UML which was a failure but
he's also a very deep thinker so let's
come up with some very good stuff so
let's start by trying to understand the
incident forces on a system and there
were lots of forces acting on a system
we have a system here the blue square
it's a solution to some particular
problem we have and there are various
forces acting on it those forces come
from customers they come from the users
the definition of enterprise software is
that these are distinct people business
owners marketing and sales people who
are trying to promote this thing the
developers you have to build it the
people have to test it people who are
managing the building of the thing and
many many other people are involved in
any business that involves software
which is most businesses these days and
of course forces are all constraints are
also imposed by other systems you know
you have to integrate with some other
system you not in a position to change
in any way you just have to deal with
that force that comes from that system
I swear all these forces on the system
and what Grady Booch said which I I
don't think it's entirely obvious until
you've heard it is that all of these
forces have to resolve to zero and the
reason they all have to resolve to zero
is that if they don't either your system
just buckles under the forces and
collapses and implodes on itself and is
no longer useful or it accelerates off
to infinity so there needs to be some
kind of balance here so we can factor
these forces into four groups you might
be able to think of other groups but I
think these four encompass most of the
forces that we think about when we talk
about software systems
there's the functions the functionality
of the system there's the qualities of
the system which I just spoke about
there's constraints and there are
principles for my money the the
qualities and the constraints are most
important so the functions are what is
it for what use cases does it support
what does it allow people to do that
people couldn't do previously without
the system what functions does it have
the qualities are how well should it do
those things sometimes these are called
non-functional requirements not a quite
an ugly phrase but so performance
scalability security maintainability
usability fault tolerance you can go to
Wikipedia and find a list of about 200
of these things because there are 200 it
makes the trade-off problem really
difficult I'll come back to that later
there are constraints things that limit
our approach how much money we have what
the law says or regulations say how much
time we have how many people we have our
experience those people are I can tell
you how experienced they are not very as
I explained at the beginning and then
there are things we choose principles
how would we like to build it given all
these constraints and forces we still
have some space to maneuver there's a
still a solution space we haven't
collapsed
solution space down to a down to a point
so we can choose our contextual styles
we can make technology choices
ultimately it probably doesn't matter
whether you write it in Java or C sharp
right those things are largely
equivalent standards we choose to adopt
so basically how would we like to build
it and for my money the qualities and
the constraints are really the main
things that should drive the software
architecture the features and the
functions will drive the software
architecture in aggregate but generally
speaking adding or removing an
individual feature does not require that
you come up with a new software
architecture to support that feature
yeah so I mentioned non-functional
requirements non-functional requirements
tends to get quite confused with
software qualities and people almost use
them as synonyms I prefer to think of
non function requirements as well
requirements they are things going into
the process of building software and
software qualities as qualities or
characteristics that are exhibited by a
software system as built so the
relationship between non-functional
requirements and qualities is the same
as the relationship between functional
requirements and features which support
those use cases
so it's been claimed in the past that
features and qualities are kind of
orthogonal as I've drawn them here and
what's very interesting to me and this
has become apparent to me over a decade
or more is that we treat these things
very differently the way we handle them
in our projects is very different
features tend to be all the requirements
that lead to them tend to be explicitly
captured you know they are a ticket in
our scrum backlog or our Kanban board
they're intentional we tend not to
accidentally implement features they're
quite deliberate thing they tend to be
tracked we know whether a feature has
been implemented or not all right it's
still on the to do you backlog or it's
being built currently or you know you
can go to a developer and generally
speaking you can ask them what feature
are you building and they probably give
you a reasonable answer to that question
they're designed and implemented there's
a specific act of implementing a feature
they're tested and verified by some
means and if the software we're working
on for example comes with the user
manual
remember those they are specifically
documented there might be some
instruction on how to exercise and use
that feature to achieve some to achieve
the use case and they're essentially
digital I mean these are the features
there or it isn't I mean it might be
buggy but it's essentially there or not
right
contrast that with qualities they tend
to be informally captured as that bit at
the back of the requirements document
template that nobody really is sure how
to fill in ask you to think about these
kind of things and people try to write
something because they feel they have to
do because it's template but people
don't think very deeply about it they
are emergent they tend to emerge from
the software and I'm going to come back
later in the talk to this word emergent
because it bothers me they're
untraceable it's very difficult for me
to go to you you know we're looking at
your code and I say well where is before
which file of
Cody's performance implemented in which
file of source code is security
implemented in can you show me the
scalability class right I mean they're
just nonsense questions right because
they are cross-cutting the concerns they
are throughout the whole system they
tend to be retro actively redressed
because we're never really sure whether
we've delivered a system with the right
level or not until we've got it out in
the field and being used so then we have
to come back and correct shortfalls and
we tend to monitor them in production so
how what is the throughput of a system
for example we can monitor that while
it's running and they tend to be largely
undocumented and they're essentially
analog features you know you can have
more or less performance okay you can
have more or less usability maybe
security is an exception to that because
half security is really no security so
it's been claimed as I mentioned earlier
that these things are orthogonal
it's just claimed in software
architecture and practice a long time
ago now 15 years ago functionality and
quality attributes are orthogonal I'm
not sure this is quite true because I
can remove all the features from your
software and make it very secure so I
think this is an ideal but it's probably
unachievable
but you should think about how you
handle qualities in your own
organizations you probably have a very
explicit process for handling features
and requirements think about how you
handle qualities so I wanna zoom in on
this word emergent where does that come
from well it comes from this guy George
Henry Lewes a philosopher Victorian
philosopher and this is the sentence
where he essentially Queens the word
emergence this is the first use of the
word emergent you don't have to read
this huge screen full of Victorian
English it's quite hard going even for
me George Andrew Lewis was essentially a
failure the philosopher no one's really
ever heard of him he's mostly famous for
being the lover of George Eliot the
novelist so let's extract some snippets
from here and try to turn them into
something like modern English so he says
with emergence there is a cooperation of
things of unlike kinds he's not talking
about type systems but he's talking
about emergence the emergent is unlike
its components insofar as it cannot be
reduced to their CIRM or their
difference right so we if you have one
feature and then you implement another
feature
how many features do you have you have
two features right performance and
usability that work that way if I have
one feature and add another feature as
my usability doubled probably not it's
probably gone down by some complex
function right that we don't fully
understand
so emergent is really a code word for
what we would call nonlinear systems I'm
not sure that phrase was in use when
George Henry Lewis was around maybe it
was so what do we know about nonlinear
dynamical systems such as building
software systems we know that they're
really hard to model we know that
they're really hard to predict the
future behavior of and we know that
they're incredibly hard to control
if we're in the situation of building
control systems so emergent is really a
code word for all these things so even
though emergent is used in a quite nice
way in lots of presentations be wary of
it so normally when I show this slide
when I'm doing this talk I say probably
later in this conference
somebody will show us slide with this
picture on it thankfully van Katz has
already done it in the keynote this
morning and shortly after somebody says
somebody shows you this picture on a
slide they will say the word emergent
but normally this sapling is cradled in
the nurturing hand of a Software
Architect what I'd like you to do is
every time you hear the word emergent
which really means hard to model harder
to predict and hardest to control
I'd like you to mentally replace that
with accidental because that's what they
mean
so back to my thoughts about how
software systems are constructed we have
some system we have some set of
requirements we have an agile process of
course which delivers features into the
system you've all seen those diagrams of
scrum haven't you with that kind of
circular thing spinning round which is
each sprint and another circular thing
spinning round which is something else
and it's like a diagram of the internals
of a pump right and that's because agile
methodology is commonly practiced are
basically a feature pump right pump pump
pump pump features into the software
system you can watch it ballooning up
and inflating as the features are pumped
into it but over time here's that word
emergent again the qualities of the
system emerge right and they don't
necessarily emerge in a way that you
particularly like or your users
particularly like the only thing you can
be sure about them is that they will
emerge right your system will have a
usability it will have a security it
will have a maintainability whether you
thought about those things ever right
they will emerge they kind of come from
nowhere it's amazing but somebody's
gonna notice if you don't notice your
users are gonna notice what's
interesting is that course the agile
process works over days and weeks
whereas these things emerge over months
and years right and this Delta in
wellness if you like is the kind of
aggregate of all the properties gets
encoded into thousands of defects and
then get fits defect reports which in
gyro forever and then fed back into our
system now anyone who's ever worked on
control systems will know that this time
delay here is like having an incredibly
brutal low-pass filter on the feedback
loop in this system I guess which makes
it incredibly hard to control in short
time so your defect tracker is just a
low-pass filter
and these it's hard to address because
they are cross-cutting concerns so what
we would prefer to have instead is
deliberate design for these things and
be very conscious of them in advance and
deliberately choose systems which
exhibit which are likely to exhibit the
right kinds of qualities at the right
levels given trade-offs that we are
comfortable with since we're software
architectures all about really it has to
provide a system that facilitates the
development of appropriate features but
it must also think about deliberately
choosing software architectures that
deliver within the constraints we have
time money people but also at the right
quality levels
Winston Churchill said it much better
than I ever could he said however
beautiful the strategy you should
occasionally look at the results so what
makes software architecture really
difficult is that there's this Fitness
landscape of different qualities and
these complicated trade-offs there's
really nothing simple about it and I
really see the job of the the software
designer well the software architects as
navigating this complex landscape that
we can't see and is difficult to model
to try to get the software system into a
good place in that landscape now it
would be easy if it was like this if it
was a I say easy I've worked on two
dimensional optimization problems which
are horribly difficult but you know it
would be easy if there are only two
variables where you had to optimize for
there of course the reality is is a kind
of 96 dimensional space of all these
different software qualities which
relate in really difficult ways and
finding your way around this is really
hard and the way we do find our way
around it and the way we manage is by
choosing to build systems using
architectural styles which have known
qualities right so don't choose them
because they are fashionable choose them
because they have the right set of
qualities and make certain trade-offs so
I like to think of architecture as a
counterbalance to what I call agile
feature ISM
so to a great extent functionality is
independent of the software structure I
can implement the same features in many
different ways using different
technologies so here's my web Twitter
client here's my iOS Twitter client I
don't know maybe this is written in
Swift maybe this is rip this is probably
written in JavaScript okay
they both essentially have the same kind
of usability and they interoperate with
things the native apps probably a lot
faster than the JavaScript app I'm
pretty sure the maintainability of the
JavaScript app is appalling the Swift
app is probably pretty good on the other
hand the web app is incredibly easy to
deploy somebody just needs to hit
refresh and they get they potentially
get a new version whereas deploying the
thing new app through the App Store or
if it's a built in app might require an
operating system update you know that
this more work involved in that the web
app is potentially very portable too lot
across lots of different operating
systems I could even use the web app on
my phone
whereas of course the Swift base iOS app
is locked into iOS right so here's an
example of a simple example you probably
all have on your phones now of
essentially identical systems with the
same feature set supporting the same use
cases but very different trade-offs very
different software qualities have been
selected
yeah as I said you know we could
potentially run the web app on our
phones anyway but this might integrate
less nicely with the operating system
than the native app so back to the
cupcakes and other confection when we
are choosing a software architecture we
shouldn't choose it because it is
literally flavor of the month
right we should choose it because of the
qualities that its exhibits and over
time we have a pretty good idea what
quality is these different systems
exhibit micro services are arguably
quite modifiable the services should be
small enough that I can quickly rewrite
one I don't really have to necessarily
worry about maintaining it I could just
replace it okay to choose software
architectural styles based upon the
qualities they are likely to give your
software system so I'd like to say I
don't often spend my evenings reading
other people's PhD theses that's not
really true
I do sometimes this is the PhD thesis by
Roy fielding this is the thesis from
2000 where he described the restful
software architecture so rest api is
comes from this thesis and it's very
interesting and should go and read it
because most people have completely
misinterpreted what he said but on page
15 there's a really nice quote if you
get as far as page 15 some architectural
styles are often portrayed as Silver
Bullet solutions for all forms of
software however a good designer should
select a style that matches the needs of
the particular problem being solved so
he's counseling us here to not follow
fashion but to choose things based upon
their known behaviors and qualities in
the world of building architecture
people have said similar things in this
book
about constructing buildings personal
stylistic concerns have no place in the
work of a professional architect you
know we are supposed to be doing
engineering it should be objective as
far as possible we should try to correct
for our biases so how do we deal with
qualities when we're building software
well you know we have our Kanban board
features progressive across this board
from left to right the stuff to do the
stuff we've done it's hard to build
qualities into this we can't have a
ticket it just says performance or
security because they're untraceable and
trackable right so what the agile folks
have said is well you need to build your
qualities into your definition of done
right so it's not allowed to be done
until it meets you know it's been
returned it's been checked it's been
reviewed comes all the right tests it
implements what we have asked for and we
add to that it meets the qualities order
it enhances the qualities in a good
direction it doesn't degrade the
qualities in a bad direction and this
seems like really sensible advice
however it doesn't work because what it
leads to is this when nothing is ever
done
and people will very creatively add new
columns to this thing yeah so we tend to
these days deploy things early and then
monitor I guess one of the problems is
they are some of them can be monitored
so you could monitor performance in the
field when should deployed your system
into AWS you can some extent monitor
usability you could figure out how many
people successfully managed to buy a
book on your shop right on Amazon it's
hard to monitor things like portability
I mean how do you deal with portability
well as an example Mac OS which started
life on PowerPC and has since moved in
tell obviously portability was a concern
somebody our Apple very wisely had in
mind and later to arm as well along with
in the guise of iOS and the way that was
done is from the very earliest days of
Mac OS they had people compiling it for
Intel even though Apple was not at that
time building any computers with Intel
processors right so where you can't
monitor you need to put practices in
place that maintain a quality like
portability say even though there's no
immediate value from that
okay and of course we can deal with this
to review and one of the things we do is
software architecture reviews and when
we are reviewing people systems there's
a very strong focus on qualities of the
system where the shortfalls are and
things that can be specifically done to
address those shortfalls
and bring them up in the level of
consciousness in the organization so and
of course there are many many people
involved who you need to talk to you
about those qualities it's not just
about code all kinds of people are
involved in building not just software
systems but software intensive systems
whereas some broader system it involves
Hardware people and software so I'd like
to advocate for people who are software
architects to really focus on software
qualities and be the champion of
software qualities in their organization
and I'm gonna finish now with some
advice that I was given in my previous
job which i think is excellent advice
and I'm it's not my quote I can't find
out where it originally comes from if
anybody knows please do tell me so I can
add some attribution to the next slide
which is this and this is advice to the
software architect you look after the
quality attributes and the features will
look after themselves which sounds kind
of cryptic but also profound and I think
there's a lot to be said for this
because what is being said here is that
there will be no shortage of people in
your organization thinking about
features right the sales people are
selling features developers interested
in building features the features are
very explicit in your project management
tool they're probably explicit in your
defect tracker you have scrum people who
just mostly care about features there
are project managers nobody is gonna
forget to implement the features right
so to a first approximation as a
software architects you can kind of
forget about the features as long as
your system supports the addition of the
features people want to add that's fine
okay see obviously there is some impact
on the architecture but mostly as a
software architect you should focus on
software qualities so you look after the
quality attributes and the features will
look after themselves thank you very
much
I would normally take questions but I
have another talk to prepare for which
is in the next slot so thank you you can
come and find me I'll be around the
conference do</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>