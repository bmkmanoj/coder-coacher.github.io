<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C# 7 - Jon Skeet | Coder Coacher - Coaching Coders</title><meta content="C# 7 - Jon Skeet - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C# 7 - Jon Skeet</b></h2><h5 class="post__date">2018-02-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/q13g_Zef8nk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay I think folks are still streaming
in I suspect a lot of talks have run
slightly late so that's fine we will
actually make a proper start in a couple
of minutes those of you who are in
Kevin's talk just now he mentioned
legacy a few times I now have a fairly
new appreciation of the word legacy
since becoming a Hamilton fan part of
Hamilton is him saying legacy legacy
what is a legacy it's planting seeds in
the garden you never get to see from
which we understand that Hamilton was a
consultant so he was writing all this
code and then riding off into the sunset
and letting other people manage the mess
that he'd left okay on your agendas you
will have seen that this talk is
notionally by me and in an hour and 20
minutes there's another talk by Bill we
noticed this and thought this is silly
a c-sharp 7.0 talk followed by a 7.1 and
7.2 and maybe more talk we thought it
would be much better if we presented
together so the format that we've sort
of discussed this morning is I will
present most of the code for this talk
and occasionally bill will ask me
questions as if he were you do not let
this stop you from asking questions as
well okay you were me yeah and one thing
that bill can do is while I am looking
at the keyboard so I will be sat for
most of the time while I'm looking at
the keyboard bill can see any hands but
if bill hasn't seen a hand within a few
seconds just shout okay we're all
friends it's all fine no one will can so
that consider that rude so please do
shout if you have any questions because
chances are someone else is thinking the
same thing but hopefully bill will ask
you questions and I will ask bill
questions of sort of motivational things
that you know what's a typical use case
how does this affect bat compat etc etc
hopefully most of you have all of you
used c-sharp six or let's make it easier
has anyone and I don't mean to cause any
embarrassment
not reasonably familiar with c-sharp 6
because you may get confused if we use
some of the examples use string
interpolation and things I've been
writing about c-sharp 6 and 7 together
for sufficiently long that sometimes I
get confused as to what's which features
are in in which version however we have
an agenda here this is a slightly more
detailed version that I normally have
because it was going into each feature
with the order to do things I was
putting this together in a separate text
file and then thought there's nothing
desperately secret here you know it's
not Bills social security number or
anything so I just keep it here because
it's simpler okay I think that's all and
we're good to go
so tuples are the first secret first
feature of C sharp 7 and normally when I
would introduce a new version of C sharp
7 sorry new version of C sharp like with
3 &amp;amp; 4 &amp;amp; 5 it would be really easy to say
C sharp version X is all about this big
idea and really can't do that about C
sharp 6 or 7 and it sounds like probably
not with 8 although there are at least
be a few big ideas C sharp both 6 and 7
have a bunch of smaller ideas they're
mostly to do with making code easier to
write easier to read and a few bits and
pieces in between so we'll start with
tuples and I'll show you some code to
start with this uses tuples in a variety
of ways so we have at the top of our top
of one equals and then what's called a
tuple literal and you can see we're
pulling things out as item 1 and item 2
then we can see on the second section
that we can also construct it with value
tuples and pull out item 1 and item 2 we
can use the same syntax as the first
part and then pull them out as a and B
we don't have to use var we can specify
the type and the element names in
in the type declaration sorry the
variable declaration and then the topple
literal doesn't have to have them a note
that this is assigning to a tuple with a
long first element and an int and we can
infer them as we did in the in topple
three okay so that's showing you some of
the syntax but what is it supple think
of a tuple as an unincorporated form of
composition so out of interest how many
of you were in my talk this morning
loads of good talks is not a problem if
you weren't so I talked about
composition and how it adds value and
that there are lots of different levels
of composition there's just I want to
shove these two values together then
there's I'm going to shove these two
values together and give them names that
imply some kind of greater meaning and
then there's I'm going to shove these
two values together and indicate other
operations that you could do and that's
called writing a class or a struct okay
and tuples have nothing to do with that
but these first two around I want to
just shove a couple of things together
in a completely uninhabited way I'm not
saying anything about the values really
if I give them names they're more
suggestions than fully validated
requirements and tuples allow you to do
that really easily you may have seen
couple of T t1 t2 t3 etc in.net for
dotnet 4.7 introduced value tupple and
it's available as a separate nougat
package 4.7 for alright okay well
actually can I can i interject something
it's close there's a there's a dotnet
core versus that net framework thing
okay so dotnet framework it's delivered
as a Windows Update so you may have
heard we do things like the spring
update and the fall update
that's when they've gotten it framework
I'm windows gets updated dotnet core
it's delivered whenever dotnet core
wants to sew system that value tuple
went in the fall creators update for
Windows which is four seven one that was
the next Windows release it could be it
on the.net core side its in.net core 2.0
so if you're building down in core apps
you don't need the extra nougat package
once you're on - on Windows if you're on
a machine that has four seven one then
you don't need the extra nougat package
for any language feature that relies on
a type will always have a new good
package with that type so we're not
going to get you that way okay okay cool
thank you I'm so system topple in dot f4
is a reference type and I think it's
immutable
I hardly ever used it I think so I think
it is system dot value topple or value
tuple is a struct and it's mutable and
it has public fields are you feeling
scared yet okay these are things that
are generally designed to make you run
away screaming when you're writing an
encapsulated type you don't have mutable
structs and you don't have public fields
and in fact if either of those have been
true without the other it would have
been a problem but the way to think of
values at value tupple is that it is
unincorporated all its being is a
container a bag so when you have a tuple
variable like tuple one here well let's
let's go for tuple 3 because it's got
nicer names that's just a bag of fields
it's got an e field and it's got to be
filled so it's fine for us to do that if
you have if you're passing a value you
should think of it as a bag of values so
if you have a parameter everything will
have been copied by value so it's fine
for you to modify that and that won't
change the caller if you have a
read-only field that is a value tuple
that's effectively a bag of read-only
fields a bag of values and it took me a
while to be comfortable with this but I
am now
so the reason that tuples were horrible
back in net for with couple of T were a
few big reasons firstly no language
support you do not want to be writing
this all over the place when you can
write this okay it makes a big
difference
secondly being able to assign names no
one wants to write item 1 and item 2 in
particular if you ever use tuples with
two types that are the same or very
similar if they are in turn int who's
gonna know which is which yeah my
favorite example for doing named
arguments in c-sharp fall was messagebox
show which has title and content or
something like that title and text and I
could never remember I didn't want to
have to remember which way around they
went so use named arguments and you're
good to go
likewise use name couple elements and
you suddenly provide a lot more context
to anyone reading the code the computer
doesn't care at all doesn't care about
the names more so than ever before as
we'll see in a minute
being value types it means that they're
cheaper to pass around if you want to
return to values from a method say you
want you've got you want to introduce a
new link operator of min/max it returns
you both the minimum and maximum of a
sequence at the same time that's fine
just return a tuple no heap allocation
it's all good being value types and the
mutability sounds awful but it works
really well for you to take existing
code that has a bunch of fields and just
say gee oh I seem to have address 1
address to address 3 and you know name
one name too
that's clearly two different sets of
fields I don't want to bother writing an
address
that properly encapsulate things but it
would be helpful to have just two fields
name and address that are then composed
so it's lightweight composition for
times when you don't want to bother with
encapsulation it's not saying that
encapsulation is bad but you don't
always need it and this is why I'm not
sure whether I've got an agenda item for
times that you shouldn't use tuples I
would generally not recommend returning
tuples from public api's or accepting
tuples in most cases it's going to be
simpler to encapsulate this is what my
composed value means if it's something
that is widely applicable so you want it
to be public this is something we talked
about this morning is deciding when to
use a topple and when to use to create a
class or a struct and one of the
guidelines that I often give is think of
someone coming to your code base and
reading it for the first time they're
gonna look at the names of types you've
defined the classes and structs and
think those are important things and
concepts I should understand where I'm
passing around a tuple I don't think
that's an important concept
it's just values that happen to travel
together so as you're trying to figure
out which one do I choose I'll often
look at that is this a concept I want a
reader to understand later when they
read this code or is this just values
that happen to travel along together and
for something like min max it would be
reasonable to write a public extension
that did return tuples a topple of the
min and the max because you're not
trying to encapsulate anything but if
you find yourself returning a date time
and a string then a use noter time
instead of date/time and B you think
about well what's the relationship
between this date and time and the
string and doesn't that deserve a more
first-class approach than just as bill
says things that happen to go too long
go along together
okay I'm gonna whistle on because it's
really easy to spend and I know from nd
seals though to spend half an hour
discussing tuples one important thing
though is what they look like in CLR so
how many of you are familiar with
anonymous types okay we introduced them
in c-sharp 3 the fundamental to link
because they let you do lightweight
projections with named elements tuples
are really different to anonymous types
every time you use an anonymous type in
c-sharp the compiler will generate a new
class for you internally modulo same
properties in the same order regardless
of types because it uses generics but
with tuples that doesn't happen there
are the value tuple types structs and
those are the only ones that will ever
be used so if I do var topple 3 B equals
foo 5 bar 20 then tuple 3 and tuple 3b
will have the same execution time type
okay the compiler is using those names
for our benefit not for execution time
benefit it's a little bit like if you've
used Java the type erasure in Java with
generics where there's only one real
type and it's just useful at compile
time to be able to restrict things
that's very similar with types here in
c-sharp the language they are regarded
as different types but with identity
conversions between tuple types that
have the same element types in the same
order regardless of the names one
downside of this compared with anonymous
types is that if you call to string on
it it can't show you the the names so
let me do an on equals nu equals 1
equals 2 and then if we right
that's explicitly called a string okay
so I will run this code and then we'll
can't remember their white background
sorry so double numbers so our three
console dot write line statements print
1 comma 2 which is this T 1 so that's
the X Y true for t1 equals t2 even
though they've got different names and
an on to string the anonymous type
preserves the names which it can do
because precisely because the compiler
has generated a new type each time ok so
there are there is that downside to
tuples versus anonymous types but in
general they work how you want them to
you can pass them as parameters you can
have them as fields you can have them as
return values so here's an example if we
had lots of counters within within a
type just have one tupple that keeps all
of them and then we can increment one of
them or the other and obviously when
you've only got one field yeah maybe it
would be worth having two fields instead
but by the time this is a sort of mini
encapsulation within an implementation
that these things happen to travel
around together then it's really useful
right I want to move on what do I miss
bill that's I think we covered most of
it ok I think we're up to deconstruction
oh there may be to add in the element
names element names yes with element
names they are burned in in metadata
with attributes so they are available
publicly and they are available if you
wanted to use reflection to get at them
yep although getting at them with
reflection is interesting so one of the
one of the tricks that the compiler does
is you can have as many tupple elements
as you like here hundreds if you want or
at least I haven't run against a limit
don't but you can and you could easily
have 12 value topple only goes up to 8 I
think the compiler magically uses
another value tupple
when it gets to item 8
and so if you have 12 elements that will
be a value tupple of t1 t2 t3 t4 t5 t6
t7 value T'Pol t1 t2 t3 t4 t5 and the
compiler just manages all of that and it
manages how the element names are worked
out within that and it's relatively
tricky so I think if you're dealing with
reflection and tupple names expect it to
be a slightly rough ride unless there
are helper functions available no the
more the more important part about that
is if you've got if you do have tuples
as a public part of your interface you
deliver that dll visual studio and other
tools will read it right yes yes so you
can expose element names in one assembly
and consume them in another that works
ok let's segue into sorry any questions
on tuples it is a huge topic and it's
kind of tricky to cover adequately I'm
aware of all the things that I haven't
covered but think of them as bags don't
be scared about them being mutable value
types but be aware that they are and
those are kind of the big they don't
generally expose them in public api's
are the key things and be aware that you
do have values there sorry compiler
support for tupple literals you almost
never want to be explicitly constructing
things like that ok let's look at
deconstruction so tuples help you
quickly compose things there are two
language features in c-sharp 7.0 that
help you decompose things and one is
just deconstruction and the other is
pattern matching so i'm pattern matching
maybe more decomposed e in the future
anyone following along in the Rosslyn
repo may have seen a load of language
designs because it's great that the C
chart team mostly works in public now so
we can see a lot of what pattern
matching might look like way down the
track when we've also got record types
and who knows what but will will stick
to what we've got for at least this talk
so if I've got a tupple suppose I've got
a method that
creates the minimum and maximum so I'm
going to pass in a sequence and I will
get back a tupple that's all very well
but maybe I want separate variables
because I'm gonna use the min and Max
quite often
wouldn't it be useful if I could just
decompose deconstruct it to two separate
variables rather than one variable that
is a composition of fields well for some
reason visual studio thinks I want to
keep seeing system console
maybe our hovervan oh don't go away come
back yeah right so composition sorry
deconstruction allows you to declare
several variables with something that
sort of looks like declaring a tuple
variable but this isn't this is
declaring three different fields sorry
three different local variables in one
go so I'm calling this create couple
that does whatever it needs to do and
then we have a B and C so if if we did
write our enumerable int source okay I'm
not going to implement it now but if we
had mean of zero max of 100 it keeps
removing Mike : bill would like you to
fix that I'm not even touching their
keyboard no no fix Visual Studio you're
as the Microsoft employee on stage
you're there for a it's will for every
bug in Visual Studio
so using our min max example that I
mentioned but didn't have coded up
sometimes you want to have things
separately and all you've got to do is
just say var min Max and if you want to
explicitly type things you can even mix
and match and say I I'll make some of it
var in inside that up all sorry inside
the local variable declarations but I'm
still declaring two local variables so
that's a really handy thing to be able
to do take a composite value that's
returned from a method or obtained in
any other way maybe it's a parameter
mate who knows and extract separate
variables from it so if that's a useful
thing to do but we've said well if you
if you want to start encapsulating
things properly then hey maybe you
should be creating a struct or a class
well we don't want doing the right thing
there to take away functionality later
if deconstruction is a useful thing in
general why would we restrict it to
toughen well yeah so what if I only
wanted them in ooh
and and don't just make me call min I
want to just like throw away displaying
a wonderful amount of faith in my memory
of c-sharp I haven't mentioned discards
let's let's make this min Max boggled
where boggle is some bizarre thing that
no one really wants at all and okay we
call min max boggle and all we wanted
was the min so this underscore is what's
called a discard and interesting things
happen if you already have a variable
called underscore which is valid but at
this point it's trying to deconstruct to
two things so this is trying to assign
to the existing variable
twice and declare a new one and I should
have mentioned that it would have been
fine if we'd had in May an equals 10 in
max equals 20 and these don't have to be
called this yeah they could be 2 1 2 2 2
3 30 it's fine to do deconstruction this
is an assignment instead of a
declaration ok hour 10 20 30 I've gone
away now
we've assigned to three things at the
same time and obviously min no longer
works however before we get to that
before we got to that I was showing int
min and then underscore underscore where
underscore just means I don't care and
this was already a convention that I
certainly had if I had a lambda
expression and I didn't care about the
parameters so say it was going to return
a random number whatever then I would
use underscore as the parameter name to
mean clear don't care so this codifies
that into a discard and you can see I've
got two different discards both called
the same thing I can't do int ignore int
ignore because that would be declaring
two local variables with the same name
these discards really are discarded and
I can't even get at them and that's why
there's no type specified this has not
created declared a local variable that
was what you're getting at I see yes
good so what do you do if you don't want
to be using a couple for this so
obviously I'm going to use date and time
as the example so what if you've got a
date and we've mentioned at some talk
this morning Gary it wasn't my son line
talk you know how would you represent a
date and someone said with a year month
and day so naturally if you want to
deconstruct a date you would deconstruct
it into the Year month and day and maybe
calendar system well you can do that
with did I do have an extension method
somewhere sorry extinction method
deconstruction so this is a version of
node of time before I put this into Noda
time itself so I have this local date
and so long as I have an extension
method or an instance method called
deconstruct so deconstruct becomes a
magic name as far as the c-sharp
compiler is concerned that takes a date
and has three l parameters then I can do
get the current date from our system
clock which does implement I clock Kevin
and then I can just assign to ymd
declaring variables called ymd and
obviously I'd normally write
year-month-day but I want to observe
that you don't have to call them that
and that just deconstruct and it's not
just extension methods if you have a
regular instance method that can be
internal it could be private if you're
only using it through the same within
the same type you can just do that
assignment and it will deconstruct for
you I want to point out one nifty thing
here so this is the this is an
assignment to X and message that our
parameters from exome message so that
this is something that is incredibly
cool and probably our most loved use of
this feature is let's say you have yeah
but you're in the less talk we wanted to
do immutability here right yeah there we
go
so you got all this and and now I can
assign that to the local fields in one
statement because it's a deconstruction
assignment of three different variables
and I think that will work even
should work even if they're immutable
yes yeah so now that that makes writing
constructors especially clear take all
the things that came in as arguments
assign into all these fields but just
just do it in one statement please I
really don't want to write brackets and
extra stuff for this at the moment I
believe it will construct a value tupple
of t1 t2 t3 and then deconstruct it
tuples don't use a deconstruct method
for complex reasons that I do go into in
this fourth edition of c-sharp in depth
but I don't intend to do here mostly
because I can't remember them right now
well for one thing because there can be
tuples as I mentioned tuples of more
elements than value tuples supports so
it can't possibly support you can
support it just through deconstruct so
if you're not going to need deconstruct
why bother so at the moment that may be
slightly less efficient than assigning
it through three statements but I bet if
we all start using that and then
complain about the performance
they'll just fix it I will point out
that the team's using that the seizure
of compiler teams using that all the
time right
so yeah if it's if it's not already a
pattern spotted by the JIT compiler I
would really expect it to be in the
future because it's really sweet and the
fact that it's one statement makes it
very obvious that that's all that the
constructor is doing is copying from
there to there there's no other work in
the constructor and sometimes
constructors could do with doing some
actual work and in that case let's make
that obvious so that's deconstruction
and you may be wondering why deconstruct
uses out parameters instead of returning
a tuple of things that it can then
deconstruct or whatever it's the way
that overload resolution works so
imagine that imagine and public whatever
int
Intex string message deconstruct and
parameters okay so this would have been
a different design that's saying we can
deconstruct this to a tuple with int and
whatever but in this case I've got two
different deconstruct methods one that
will deconstruct the int and the message
and another that deconstructs to the int
the message and the exception okay well
let's see what that would look like
let's just copy it and exception
exception can you see the problem we
have two parameter less methods that
differ only in return type c-sharp does
not like that using out parameters it's
fine we we have all those out parameters
which means that in no design to point
you can deconstruct a local date to
either year month day or year month day
in calendar and it just depends on how
you're trying to use the deconstruction
that determines which overload is used
deconstruct cannot be generic for
reasons of type inference gets really
really confused even if even if it feels
like you should be able to do it you
just can't and it is it does make sense
when you look at exactly how it's
represented in the language spec for
well it's equivalent to calling exactly
this and that wouldn't have type
inference applied I'm sorry about that
it's just kind of annoying in a very
very few cases but it doesn't hurt the
normal use case you know you said we
could go on for tuples for a half an
hour yep we did yeah oh well we've done
all of the construction that's good yeah
okay pattern matching so there are two
aspects to pattern matching that are
worth separating out mentally because
each may expand in the future in c-sharp
and it's worth knowing oh this is just a
new pattern or this is just a new place
can use patterns I think there are less
likely to be very many new ways of using
patterns but there may well be new
patterns coming up there are three
patterns in c-sharp seven across all
versions I think there is a constant
pattern there is a type pattern and
there is the VAR pattern and patterns
look like this a value on the left and
is and then the bit on the right that is
the pattern and you can tell the
difference between this and the regular
is operator because it's got more than
just a type so this is a tight pattern
that matches if X is an integer and it
declares a pattern variable this I you
can also recognize that because you
can't use the regular is statement with
value types that's true in this
particular case you can you can tell the
difference because it's int and you
couldn't use X is int yeah I know it's
ears you can't use yeah yeah okay you
can check that for boxed ones yeah for
non nullable value types you can't use
as okay so the the interesting point and
that's interesting from a language nerd
kind of perspective in that I believe
this is what caused the most discussion
well
Bill's trying to get right a few years
ago at a conference bill and I presented
together and I started editing the code
just before he presented it and this is
clearly his time for getting revenge on
me and but the interesting bit about I
is what the scope is in particular can I
use I outside the if statement so we can
see here you know red squigglies i can
use i and this is where you would
normally before pattern matching you'd
have to do if x is int then int I equals
and then a cast from X to int okay this
gets rid of that you are very unlikely
to have to need
kind of casting ever again it's
wonderful so we can clearly use I inside
the F block however predict as I type
but before rosin catch it up to present
squiggles or not whether I'll get an
error for this and if so what the error
is
okay there is an error hands up who
thinks that the error is that it's out
of scope hands up those who think it's
another error and would be willing to
say what that error is anyone yeah it's
not definitely assigned yeah use of
unassigned local variable I so we can't
use it there but it is in scope if I try
to do int I equals 10 then that creates
an error a local variable or function
named I is already defined in this scope
so I mentioned three types of patterns
the type check pattern that says is this
value X a value of the type named here
and if so please assign it to this newly
declared variable and it becomes
definitely assigned if we can only get
into the because we can only get into
this if block by that being true that's
fine
so I can do and X is long and other okay
this is now valid but useless code
because something can't be both a long
and a linked but is definitely assigned
if I try to do or here then I can't use
I because that's not definitely assigned
because maybe I is assigned and maybe
other is assigned Kevin why what
it's because it's an if is the problem
is that I could write something up at
the top that goes if not X's int I and I
need i to be in scope in the off clause
else clause oh I think so it's different
than yes
yeah so the awkwardness that Kevin is
describing right so ugly because you
need that variable in the else class in
scope for object J is null if J is int
kefflin no nothing in there then we
can't declare oh no do you know yeah
that's interesting because yeah we're
allowed to declare Kevin higher whereas
earlier on it was complaining about the
later declaration so you can't do it um
but but but for well for the different
reason that the the compilers decided
that the earlier declaration is the
invalid one well okay so there's a
reason for that and this gets to the the
whole the idea of seizure of helping you
write correct code so first scope is a
compile time construct right and
initialization is a runtime concept so I
need you to move the cursor just a bit
so the scope of Kevin here is the entire
method right because it's declared in
the method anyplace above this
declaration it is uninitialized right
because we haven't gotten there yet but
it's declared its scope is the whole
method because of where it isn't braces
that sounds great but but the scope of
ie is the whole method and it's one
that's complaining yes the scope of the
other eye is the whole method as well ah
right okay yeah
yes I know right
c-sharp is getting it useful yeah that's
a different um I I would love to give an
example I I have used a counter example
but I can't remember it right now and
that makes me very very sad
I would I would like to move on I think
this is a deep rattle but it does it's
right so that's what it is
yeah if I were to have an else clause
here I really want things declared in
that if to be available in the else no
it's not it's a different if it's a
different sculpt because that one is
only true and that's why you have to
move it out of the if statement and
actually I've got the example now throw
new exception you can only pass int and
then okay that's where it's useful yep I
want to be able to test for something
and use the result of that test later
and it could be that the if is a
different one and I want to be used able
to use it for from the negative case
yeah it would be annoying to not be able
to do that but don't feel bad about you
the C sharp team spent months trying to
work out whether this should work or not
yes we are yeah we already have yeah
okay but let's look at one example I
brought up Oh yep just a bit which which
won't this line 16 and 17 right what
should happen there so um I'm gonna
guess so when when we get to object X
this doesn't know that it was originally
via a nullable int because nullable int
is just boxed as an int so yes it will
print hey you passed me 12 what's
interesting is what what if we do that
that's still valid yeah
and that can detect that's basically
saying did you pass null or not and
that's a really bad way of saying did
you pass no way to do it Yeah right
equals null speaking of really bad ways
of passing things and checking things
let's look at the next kind of pattern
this is the constant pattern so we still
have is but it's saying if X is 5
okay no one should ever write that code
unless they're demonstrating the
constant pattern in this case because
you know we know that X is an int so
this is exactly equivalent to that
that's yeah that's the better way of
doing that there is a reason for using
this this kind of pattern which I'll
show you when we talk about switching
case here's a slightly less pointless
version where we're passing in an object
or reference and now we're saying is it
5 and now the question is under what
situations and what circumstances is
that true so here are some examples
we're going to call it with 10 don't
expect that to print that you passed in
5 5 would expect that to say you've
passed in 5 5 l the long 5 or and
passing in a string no that's not equal
to 5 and let's let's just give us one
more just to if we're gonna do a string
let's try the string 5 oh good man
you're writing JavaScript yeah exactly
so this is I don't know what the VB
version of pattern matching does it who
knows so the the interesting one here is
5 l and without wishing to this is for
my interest how many of you think that
this should say yep that's 5 okay and
how many of you think it shouldn't be 5
okay and about 1/4 of you didn't put up
your hands fine that's fine
so we've got 5 things here oh there bill
there is all that's because I've done
all kinds of
let's just remove all our undo
everything from there I love change
control okay we are now building so if
we do pattern matching one oh okay we
screwed up our pattern matching things
for Kevin's sake of course
good thank you it's always good to have
a helpful audience right pattern
matching one okay so we previously did a
few checks before fire ten isn't five
five as an int really as five but five
long isn't five so it really is checking
both the type and the value and if we
made it X is five L then it it would be
those two would be reversed and no a
string value five really isn't an
integer 5 which I think we can all be
grateful for okay so the third kind of I
haven't got a nick we need to comment
okay yeah so var will will help more so
we've seen that you can use patterns
remember kinds of pattern you can use
places you can use patterns you've seen
the places you can use patterns as if
statements and I think you can just do
boolean x' as well just the boolean it
is expression yeah you can also use them
for switch case and we've currently seen
type and constant patterns switch cases
where constant patterns become more
useful and where the third kind of
pattern of var comes along so previously
switch statements have always had to
have cases that are constants and those
constants have had to be distinct so
there has never been any opportunity for
more than one case to match okay unless
you consider default as always match and
it will sometimes match other things as
well
now
switch statements the order matters so
we're taking some object in and we're
saying if we were given five which we've
already seen will be only when it's five
as an integer will return fives never
blend if we're given these are the same
condition twice for the sake of the
comment basically so two case labels for
the same case block that's as normal but
there's an interesting thing here which
is I can't use Y or Z if we only have
one passim variable or other one case
statement so there's only one case label
that can have matched so Y is definitely
assigned then Y is introduced really
interestingly we can have another case
table for Y or rather that introduces a
pattern match for Y just for any int and
the scope of that the scope of any
pattern variable introduced by a case
label is that case block this is not the
same as if we declare a variable so we
have no let's not call it X let's call
it local if in some completely different
case label we try to write the value of
local it will say it's not definitely
assigned it is in scope this is bizarre
and basically I think a failure in the
the c-sharp specification but it's far
too late to fix okay there's no good way
to fix it now basically case case labels
should have required braces all the time
at which point it would have just been
solved by all the regular rules early
versions in fact I think currently the
MS spec claims that you can reorder case
labels so however you like you couldn't
before because of this and you
definitely definitely can't from c-sharp
7 because of patterns so these take
precedence in an order so literally the
generated code will sorry
you can put curly braces if you want
absolutely yeah so first it will check
whether it's 5 then it will check
whether it's divisible by 5 then it will
check whether it's an odd number then it
will check whether it's an integer so if
you pass in 5 then every single one of
these case statements these case labels
will match but it's the first one that
takes priority there's one exception to
that if you give a default that default
is always effectively at the bottom now
it's not compiling because of the the
VAR case which I will explain in a
minute but the fact that this is at the
top is irrelevant and therefore I would
strongly recommend that you always put
it at the bottom so you don't need to
remember this okay if your convention is
it's always at the bottom then it's
obvious that it will only happen if
nothing else matches the final kind of
pattern and the one that's more useful
in switch case that in if statements and
things is this VAR which is kind of like
a tight pattern except it matches
everything so it ends up with a static
type which is the same as the thing that
you are switching on so if you are
switching on an iPhone the type of oh
would be I foo because it will
definitely be at least that good in this
case it's object but we could we could
make it I comparable in this case and
it's still fine for those various intz
and then Oh
we'll be I can you won't be able to see
this but that really does say local
variable I comparable oh so this is like
a default case except you get to use the
variable afterwards which isn't terribly
useful if you're just switching on X but
if you are switching on some large
expression then you don't want to have
to evaluate that expression earlier
sorry twice or have a declared local
variable above it just lets you say
match something and capture it okay yeah
you further I think you can put a one
clause there yes so I didn't even
introduce the when clauses these are
what are called guard clauses when date
time dot now dot our minute less than 14
because we really need to move on before
it gets to 514 so yes you can
a var close without any guard will
always match even if it's null unlike
anything else that does type matches but
you can put these guard pauses and that
can be an arbitrary expression that can
also have more pattern matching in which
will declare more which can declare more
pattern variables so you can capture
more than one pattern variable in one
case label you did actually gloss over
something really really important if you
look at this case string name when named
out links is greater than 5 we don't
need to check against null there okay
even if the type up at the top that we
passed in was a string this pattern only
matches if it is not null there must
actually be storage there which is just
like the is statement as you'd expect
you know if o is string checks that I'll
is that o is not null as well okay we're
rapidly running out of time this is fine
it is well that's the trouble it's
always fun local functions basically you
can now use declare functions inside or
declare methods inside other math
so here we have a way of doing the
Fibonacci sequence I should have done a
Fibonacci version that uses tupple
deconstruction and assignment because
that's a really nice way of doing it but
this is just calling fib from within
main outside main fib does not exist and
you can sort of mock that up a little
bit with delegates but it's really
annoying
it gets more than annoying when it comes
to capture variables though so a local
very local method is allowed to capture
variables just like a lambda expression
can but the difference is that generated
code if you capture variables and you
don't do anything with the local method
that would potentially prolong the
lifetime of those capture variables like
converting it into a delegate or
something like that then the compiler
can do cool stuff to make it really
efficient instead of generating a class
with all the capture variables it
generates a struct that it keeps on the
stack and then passes that by reference
to the method instead of anything else I
have used local functions successfully
within code to break what would probably
be far too long a method to be one
method and would be annoying if I'd had
to create private methods because they
would only be called by another method
by this one other method I've moved
those private methods into the method as
local methods so you end up with
something that yeah looks like it is
overall quite a long method but it's
it's really nicely broken down within
that um I'll give two or two examples of
the same kind of usage which is another
really useful thing which is for
anything with an iterator block so
anytime you're using yield return or
probably more likely these days if
you're writing an async method
do I have an async example no and
both its race blocks and async methods
have a problem with validation if you
call foo async no and the first line of
the way sink is if the parameter is null
throw new argument null exception what
will happen it will return a failed task
it will not throw an exception and that
may be okay but I like validation
exceptions the you've done something
stupid when you were calling me
exception to happen as early as possible
there's no no reason to wait for that to
complete to wait for someone to wait for
that to complete before finding the
error because by that point you may have
lost some of the context of where things
went wrong
likewise exactly the same kind of
validation with yield return if no one
evaluates the sequence then we never
even execute any of the code this is an
example of what it's like when it's
broken previously the way to fix this
would be to write something that doesn't
have any yield return or a non async
method that still returns tasks of T do
all your validation and then return the
result of calling and implementation
method and the point of using local
functions is you still do that but it's
your local function that is the iterator
block or the async method so you get to
hide it you're not polluting your scope
even with private methods that nothing
else is ever going to need to call okay
given the time Bill anything else on
local methods that's about it okay
yes question there though sorry do you
have to declare local methods no don't
write so you can declare local methods
you can declare local methods within a
for each block you know void print item
console dot write line item this is just
using a method
the expression body method for
simplicity so you can do this don't
please don't
you've got to declare it within here
otherwise you don't have access to item
but it looks really weird and painful so
I would try not to do that one
restriction that I hope to persuade the
team to fix at some point is local
methods have to be unique by name so
there is no overloading before now I
have wanted to write two different
overloads of the same method name as
local methods that's not allowed they
contribute to the same declaration space
as local variables and each other so
everything has to be unique and that's
kind of annoying occasionally okay so I
think we're about halfway through the
agenda now actually I will leave ref
local and referee tone entirely I will
okay because I can cover the last three
in about two minutes which is good
because I have one minute so custom
async return types in c-sharp 7 you can
write your own task types that can do
all kinds of funky things you will never
need to do this should I have a question
does anybody think they do good ok so
this is a instead of returning tasks of
tea from an eating thing you could
return bill tasks of tea so long as you
have a bill task factory that does all
kinds of cunning stuff that's really
complicated to get rice and thread-safe
or you can use the 99.999% case of value
task of tea which is a struct which is
stack allocated unless it's actually not
completed it was basically built for
asp.net core it will be useful outside
asp.net core as well the crucial thing
is if you're fetching a value from a
cache and most of the time you will hit
but just occasionally you need to make
an async call you've got to return
something that is away table because
it's fun
intially asynchronous but you don't want
to take the hit of allocating a task on
the heap on every one of those calls if
it's just returning hey I've got the
value oh you've put me into a state
machine okay now I need to do a state
machine dance and it all gets very
complicated so value task of T is purely
an optimization aspect and it is
basically the only implementation of
Tarr space types that we'll ever need I
may try to come up with some weird and
dangerous ways of doing things but I
don't expect anyone to do it in prod
code through our expressions throw is
now an expression in some cases but not
all there are two reasons you may wish
to do this one is this exact code so
basically I have preconditions doc check
not null all over the place in various
libraries you could do if value not
equal to null return value and then
throw new argument null exception but
hey we've got the null condition sorry
the null coalescing operator so let's
just use it likewise a lot of people
don't like this code so if you don't
you're in good company but I find this
sort of nested conditional operator
ternary operator it's a conditional
operator and I find this really readable
so condition if the condition is met
return this value if that conditions met
return that value it's sort of a poor
man switch case and yes you could use
pattern matching but sometimes you
really don't need to and being able to
throw at the end that relies on throw
being an expression what I would really
like instead of doing this is to have a
simple way of expressing pattern
matching as the return type the return
value from this method is the result of
matching this pattern because then I can
pretend I'm writing f-sharp and finally
you merit literals you can now write
binary you can now use underscores those
underscores
go anywhere you can even have multiple
ones together and when I say anywhere I
mean of course anywhere apart from the
useful place so wouldn't it be nice to
be able to separate the Oh X part which
has nothing to do with the value it's
just the the base from the number itself
like they got a sample for you yeah wait
a few minutes okay
I won't spoil the surprise then so
numeric literals you can write literals
that are slightly more readable
that was the incredibly rushed version
of what's in c-sharp 7.0 hang around for
20 minutes or grab a coffee and then
hang around for 20 minutes for what's in
7.1 and 7.2 and rather than taking
questions now and ever on feeling guilty
for sort of getting up come and see us
on the stage thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>