<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Choosing a JavaScript Framework - Rob Eisenberg | Coder Coacher - Coaching Coders</title><meta content="Choosing a JavaScript Framework - Rob Eisenberg - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Choosing a JavaScript Framework - Rob Eisenberg</b></h2><h5 class="post__date">2016-06-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6I_GwgoGm1w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon how's everyone doing
today enjoying the conference great well
thank you for coming
this talk is obviously titled choosing a
JavaScript framework a look at six
popular options my name is Rob Eisenberg
I have a pretty extensive history in
front-end frameworks across a variety of
platforms including windows unity 3
flash flex silverlight and the web a bit
more about my history I actually worked
on angular 2 is a core team member and
also on angular material design project
as developers on both and also designer
on angular 2 long story short I left
that project to due to various
differences and began working on a new
alternative to angular 2 oh called
Orillia of which I am the lead architect
now what are we going to be talking
about in this talk well we're going to
look at six frameworks very simple
examples of each frameworks because we
don't have a lot of time we can't do go
very in-depth technically with each
framework so we're going to look at a
very simple hello world type app where
we're going to look at six versions of
it one with each of our major frameworks
so you'll get a feel for kind of the
development methodology and the
philosophy behind each of those
different approaches then we're going to
do a comparison a technical comparison a
comparison on project and team and
community and collaboration and business
and a whole bunch of different aspects
of these projects many of which you may
not have looked at before and then we'll
conclude the talk very briefly with my
own recommendation to you in terms of
how to approach these frameworks on
which to use and I'll break that down
into three categories the yes the may be
in the know now having said all that I
want to make two quick points before we
really get deep into this here the first
one is I want you to keep in mind
my obvious bias clearly I worked on the
angular 2o team and left a high paying
very visible job to create an
alternative framework to angular 2
so obviously I'm biased against angular
and for my own product Aurelia you know
that I'm exposing that bias to you ahead
of time so you just keep that in mind as
we proceed through this talk especially
if I happen to get on my soapbox and go
off number 2 is another call to action
for you not only now during this talk
but going forward in your careers and
that's really a call for us all to be
professionals as software developers
it's we're just as susceptible as anyone
else in the world to get wrapped up in
hype to be swayed by marketing and
branding and logos and all these sorts
of things that work on our emotions and
our insecurities and all these sorts of
things as professional developers and
architects and team leads and CTOs
our job is to really understand the
business first we need to understand
what are the business needs what is the
real problem we're trying to solve
understand our team our company culture
and then with all these things as a
context then we want our technological
solutions to fall out of that naturally
in fact when we do understand these
things
it makes it much easier to make
technology decisions so often we start a
new project and before thinking about
all that we say well I'm going to use MS
sequel server net and angular but we
haven't even identified the problem yet
we haven't even thought about what the
app is that we're going to build so I
think this is just a general call you
know as a consultant I work with a lot
of companies and this is kind of a
systemic problem I think in our industry
we need to think about our businesses
that we're working for think about our
teams think about our corporate culture
think about the real problems that we're
trying to solve and then in light of
that we choose the technologies that fit
best for that particular context so keep
that all in mind and let's move forward
so what what do we want to talk about
framework's well we're going to be
comparing six frameworks angularjs one
dot X this is a framework obviously that
a lot of people very familiar with so
this is going to provide a foundation I
think a lot of common understanding for
people and a frame of reference we're
going to talk about angular two we're
going to talk about
aurélia ember polymer and react I've
done my best to I'm trying to be non
biased if I can help it
so the frameworks will be appearing in
alphabetical order wherever you see them
unless I'm explicitly ranking on a
particular feature alright with that in
mind please don't get angry at me if I
call your baby ugly all right there's no
perfect framework
except for Aurelia and so you know
obviously there's criticisms to be made
of everything so please don't take it
personally
hopefully this will all be edifying for
you you want to take this information
and it's now resources that you have to
help you make choices in the future
whether you'd agree agree with my own
opinions or not I hope that there's a
lot of information in this talk now the
next thing I want to say about these six
frameworks is that they're not really
all of the same sort in fact they're not
all frameworks the first thing I want to
point out is that angularjs is what you
would call an all-in-one framework it
just it doesn't just do say templating
and binding but it also has routing and
HTTP and animation and a bunch of things
when you use angularjs you get kind of a
whole package deal so that's a
particular category of framework the
other thing that's important to know
about angularjs is it's pretty much
deprecated there's literally a fixed
number of months left on the lifetime of
that framework I'm pretty much including
it in this talk not so much because I'm
going to recommend it to you in fact I'm
showing my hand a little bit I'm
obviously not going to recommend
angularjs one because of this one fact
that it's deprecated and so that's not
to say that during big trouble if you
have an existing angularjs codebase but
it's probably to say that you shouldn't
start a new project in angularjs right
now and you should be thinking about how
you might migrate any existing code
bases so this isn't a little bit
different category because it has a
fixed number of months left on it of
life and then it's kind of gone but this
is going to be a good frame of rec
for us as well the next set angular 2
really ember and polymer are all also
all-in-one frameworks that provide you
know pretty much all the pieces you
would need to build an application and
their more modern these are ones that
are using modern JavaScript they're
using the modern Dom and more modern
techniques as opposed to angular which
is more of a angularjs which is more of
a previous generation framework so these
are ones that are all-in-one and then
modern at the same time and then finally
react is a little bit different because
it's not a framework per se it's more of
a view rendering engine or a component
model so it does that one concern
specifically and typically when you use
react you're going to use it in
combination with a host of other
third-party libraries and you're going
to sort of build your own framework with
react being a central component of that
so keep that in mind not all these
things are really the same shape if you
will as we proceed and I'll try and call
that out as we progress all right so
from here I'm going to do I want to just
get straight into some demos I'm going
to show you the same exact app six
versions of it I'm going to run it once
because they all look the same so we
don't need to keep running it to prove
that it works but we'll look at the
source code of all six versions and then
you'll kind of hopefully get a feel for
the different approaches that these
libraries and frameworks take okay so
with that I'm going to jump into the
demo which I've got running in Firefox
this is the angularjs version actually
and this is a really super simple demo I
mean this is just about as simple as we
could get because we only have a limited
amount of time but the demo basically
just says two free labels first name
last name and full name and two textbox
one for the first thing one for the last
name and then a computed full name that
is the result of bringing together the
first name in the last name and as I
type in one you know the full name of
course updates below all right so it's
pretty simple and straightforward and
that's how it works that's the whole
demo I know it's not terribly impressive
but the point is that we're going to
look at the different approaches because
even in the simple
like this across the frameworks you can
see some extremely different approaches
to how to build something like this
alright so hopefully you have that in
mind a couple of labels a couple of text
box some auto-updating stuff based off
of changes in those text box so let's
see how this is put together across our
different frameworks so I'm going to
bring out Visual Studio code here an
excellent new cross-platform editor
interestingly enough written with web
technology itself so if you're not if
you haven't checked out this editor I
definitely recommend it we're going to
start with the angularjs 1x
demo now with angular we're going to in
with each demo we're going to start kind
of in the index.html file it's a nice
good starting point for us
so with angular you would reference
typically the script file for angular
and then just the script files for your
app however you built those and then you
would declare templates and those
templates would be controlled by a
controller so you can see that angular 1
uses something called directives and
here's the or directives and controllers
and in this case we're declaring a
controller called ng controller that's
pointing to a person controller which
I'll show you just a minute in the
JavaScript file and it's being named
basically as person controller this uses
the controller as syntax from angular
now I realize with angular 1 there are a
bunch of different ways to do the same
thing so if you're a big angular user
and you don't see the approach that you
like here just be cool all right so this
is using the controller as syntax and
let's look at that controller let's
actually jump into AB Jas now you can
see from the get-go this is a little bit
of a throwback to what I would call the
previous generation of frameworks so
we're using a specific API that's
angular specific for declaring modules
rather than es2015 modules because this
dates to before the standard so you see
what that we're declaring this app
module and then we're calling an API to
declare a controller we're giving a name
of person controller and then we supply
a function to that which effectively
becomes like a constructor function for
that person controller and so we set up
the first name the last name and a
function called get full name that
calculates the the full name from those
two other properties so
pretty simple pretty straightforward but
you if you looked at modern frameworks
you can see how this is a little bit
dated now not using es2015 modules it's
using something that's kind of like a
constructor but it's not using classes
there's a lot of strings happening here
so you can kind of see those those sort
of previous generation techniques but
what happens in the index is we bring in
that person controller that's identified
there and it's named and then we can
reference the properties on it first
name last name and there's that get full
name method and an angular one there's
an NG model attribute which handles
two-way data-binding and so what we can
say is let's connect the inputs value
basically through this model directive
to the first name of the person
controller and the same thing for the
last name and then let's just output
inline using this double curly syntax
the result of get full name so this is
called an interpolation and you'll see
this throughout a lot of the frameworks
these double curlies and that's going to
output the result of that function right
there and you can you saw in the demo
how this just works is I type in the
first name it updates the full name
below as I type in the last name it
updates the full name below and that ng
model is pushing the data and two
directions it's pulling it from our
initial values in the model or in the
controller in this case and then it's
also pushing it back there as the input
changes it all right so this is
angularjs one again it's a simple app
but you can kind of see the approaches
you can see how it's maybe looking a
little bit old but yeah it's actually
still quite simple and it works all
right so that's angular one let's
contrast that with angular 2 I think
that's a reasonable follow up to angular
1 and it's mostly alphabetical right so
in angular 2 things are a little bit
different we've shifted over to using
modern JavaScript in a particular thing
or the two it really focuses on
typescript it's not that you can't use
javascript with angular 2 but it is much
more difficult to use plain JavaScript
so most people are going to be kind of
pushed down the typescript road
necessarily with angular 2 we're going
to start by looking in the index and
first of all this is based off of some
of their tutorial materials for getting
set up so they have a lot of scripts
that you need to include in a real
production app that will probably look a
little bit different than that you'd be
doing some bundling and some concatenate
and all that kind of stuff you also need
to configure the module loader because
we're working in a
Dulli modular system now with es2015
modules you need a module loader to load
those modules and so this is just code
you see right down here that is just
configuring the module loader this stuff
right here even though it looks a little
bit more complicated this is very common
across the modern frameworks so don't
take that as an idiosyncrasy necessary
of angular 2 you'll see it in a bunch of
other places as well and then in the
body we simply have a my app custom
element and now let's look and see a bit
you know how that kind of brings the app
to life and you can see it's importing
this app main to the module system down
here so let's go ahead and let's look at
app MAME now app main we're going to be
looking at typescript is the way that in
this case that you bootstrap angular 2
so here we're just bringing in the
angular 2's bootstrapper and we're
bringing in this app component which
I'll show you in a minute and then we're
just telling the framework or angular 2
please bootstrap the page with this app
component alright so let's look at app
component again you can see the
typescript here in the import syntax so
we're bringing in the component
decorator from angular 2 decorators are
something that are part of a future
respect for JavaScript and they're also
implemented today in typescript and the
decorator decorates the app component
class so you can see the app component
class is declared down there with two
properties first name and last name and
you can see the full name computed
property and this right here looks a lot
nicer than the angular version in terms
of kind of standards compliance because
now we're looking at a pretty normal
class the difference you can see here is
that there's this angular 2 still
requires the same kind of configuration
that angular 1 did that didn't go away
just kind of change form so an angular 1
you would call API is to declare a
controller and declare a module and do
all this kind of stuff and angular 2 you
still use their API is to declare this
stuff only it looks a little bit
different so it looks like a decorator
so here we're just declaring that this
class is in fact a component the CSS
selector that's going to control which
component what what element this
component applies to is the my - app
selector alright and then we're
providing the template for the
component and in this case it's done in
line through a template string it can
also be done through a URL but this is
again an example that they show a lot in
the docs now you can see looking in the
template how the syntax has changed
let's look at the similarities first
with angular 1 the double curlies is
still the primary way to do the string
interpolation but you can see that now
we're using getters instead of functions
which is kind of nice that's just the
benefit of using the new class syntax
for getters and you can see how ng model
has changed now instead of it being ng -
model we see a lowercase ng capital
model and then we see brackets and
parentheses in here in the brackets and
parentheses designate two-way
data-binding the brackets indicate one
directional from the model and the
parentheses indicate one directional
from the view so combine them together
and you get two directional data binding
yeah I think this something that's worth
noting here the symbols are a little bit
odd that is technically HTML spec
compliant though it is a bit odd but the
thing that is not expected is the
capital casing of the model if you know
anything about HTML spec you know that
hTML is case insensitive so this is
really an important note of
differentiation here with angular 2
where they're deviated just a little bit
by using mixed casing and some of their
attribute names and so this actually of
the angular 2 runtime of course does
support this but it needs to implement
its own HTML parser which preserves
casing in order to do that so some of
the use cases actually that were
supported by angular 1 are not supported
by angular 2 because some of the design
choices that were made around HTML how
hTML is handled so you might not have
noticed that if I didn't point it out
but these are some details I just want
you to see because they are kind of
important all right so that's angular 2
let's move on to looking at the best
framework no aurélia and it starts out
in a similar way it brings in a module
loader and then it imports something as
well in this case it imports there
really a bootstrapper which is
responsible for starting up a really
and it really is very convention based
so you'll see that in fact the component
is just a plain class with no
configuration whatsoever and this is a
bit unique in this sense because there's
no framework there so you just write a
plain class and you can see it's got the
same properties in the same getter and
that's all there is to it and then in
the view you have app dot HTML and this
is the first example we're seeing of a
framework that's beginning to use web
component technology so here you see
template HTML template element being
used to declare views and that is from
the HTML web component specification
actually backported in html5 and so you
can see that it really uses web
components to do templates and you can
see that it's data binding language is a
bit different it simply allows you to
take any HTML attribute and append bind
to data bind that attribute so here
we're two-way binding the values of each
of those and then we're using a slightly
different syntax for string
interpolation in the full name this
syntax if you know es2015 is actually
borrowed from modern JavaScript it also
uses the dollar sign curly syntax for
string templates or string interpolation
in JavaScript so that's been borrowed in
Orillia and that's the whole of the
really a sample just a plain class and a
template with dot bind on a couple
attributes from there let's move into
ember and you're going to see the first
framework that really takes there's a
big difference I think between angular 1
and angular 2 there's some similarities
between angular 2 and Aurilia we're
going to look at ember you're going to
see some similar similarities between
ember and Aurilia but you're also going
to see how ember takes a bit of a
different approach with ember it's also
uses a lot of conventions like Orillia
those are the two frameworks that try
and maximize productivity through
conventions but ember is a very strict
MVC model so when we look at their code
you're going to see the model the view
and the controller all very explicitly
and in fact I don't think you can sort
of get away away from that but a lot of
people do like that so first again
looking in the index we brought in some
script tags you can see that here where
we've got a script tag in the body for
declaring our template with a special
type notice the data template name
equals index that's going to be
important in just a minute when
I show you the JavaScript code you can
see the templating syntax also a little
bit different still it's completely a
spec compliant HTML but handlebars has
some nice helper methods for generating
tags so you can see that that input
helper is generating an input tag there
and it's setting the binding up on first
name and last name for you and then you
can see the double curly syntax below
just binding the models full name now
let's look an app J s and here's where
you're going to see the model view in
the controller first at the top we're
creating an ember application with ember
application create then we essentially
define our model from the MVC pattern so
you see app dot person equals M Bert
object.extend and you see it's declaring
some properties first name last name and
full name as well now here I'm not
showing the es2015 version of ember
there are some equivalents as that so if
you're using ember I would love to talk
to you and have you help me update my
code I had a bit of problem with the CLI
when I was preparing so this may be
there's probably a slightly different
approach you can take today but
essentially the important thing is that
you're declaring a model and then here
we're in instancing that model so
creating an instance of the person so
that's our model instance and then down
here we're setting up the router now I
haven't showed you routers on other
frameworks because the other frameworks
don't really require a router for the
basic app but with ember it like I said
it's a very strict MVC paradigm so you
have to have a router involved so here
we just setup the routers map and we
create this generic index route again
this is based off convention you can see
that naming convention of index route
that's going to be the index route that
it goes to when it doesn't match any
other patterns and you can see how by
declaring that route we're creating it
and then we're specifying what model is
associated with that route so you can
see the very explicit NBC design here
and notice the name is index route and
the view of course was called index so
you can see those conventions of kind of
hooking things up based off of naming
and that's how ember looks now let's
move on to polymer which is a very
different approach polymer is based
exclusively on web components and
actually attempts to do almost
everything in the Dom so if we look at
index.html again we're going to see the
script component to bring
in the basic web components polyfills
and then we're going to see an HTML
import link which brings in the app
itself as an HTML manifest basically and
in here you can see the my app element
being declared so where does the
behavior from that my app element come
from well again let's look into my app
HTML and again you can see that it's
that that links in the actual polymer
framework so we're layering polymers
layering on it first starts with the
polyfills that bootstraps the process so
that it can then load the whole
framework in so that's where polymer
framework comes in now notice the very
different approach here everything is
done in HTML in fact there's a Dom
module and so components are used to
create other components very different
from the other frameworks completely
different methodology notice the Dom
module has an ID of my app and also this
polymer script says is my app and over
here in index we have my app so you can
see how things are linked together in
polymer you have the template that's
again using a web components template
just like Orillia did it's got its own
binding language it uses the double
curlies for the interpolation and you'll
notice that for two-way data-binding has
a bit of a different syntax so you'd
have to declare the property first name
that you want to bind to and then use
this double colon syntax to indicate the
name of the event that is going to
trigger the reverse binding update so
you can see in first name we need to say
that it's the input event and last name
the input event that's triggering the
bi-directional update of the binding and
then you can see that rather than having
a computed full name down here it simply
does it in line using spans so that's a
little bit different as well and then
finally you have the script tag that
uses the polymer API to declare the link
between the pieces with the is property
and then a ready function which is part
of the polymer component lifecycle that
sets up the initial values of the
component so you can see this is very
very different in nature and philosophy
than ember and very different from
really and very different from the both
the angular's completely different
approach I think a strange thing to note
about this is it's it's very very web
component
and everything is done and Dom like this
so this is a little bit actually
concerning for me because it doesn't
entirely make sense to do everything in
HTML but there it is that's my opinion I
have seen some things like this done in
the past does anyone remember Microsoft
Acropolis project nobody remembers this
it was like 2008 this was in the early
days of Microsoft sam'l when they
attempted to do everything in zamel and
that project died that's why you've
never heard of it so I kind of worry
about this approach a little bit because
it hasn't been tried in the past and
it's a little bit odd for example
polymer has Ajax elements HTML elements
for Ajax HTML elements for local storage
and that maybe works for simpler apps
but it seems a little bit not quite
right perhaps for more complex
applications so this is a very very
different approach very web component
oriented finally let's look at react
again reactors going to take an
extremely different approach from
everything else an index I'm just
setting up a bunch of scripts don't
really worry about that the important
part is this div with the container ID
an app I'm going to jump down to the
bottom first so you can see how the
framework actually gets things started
off we use the react API to render the
app into that container that I just
showed you so where does that app come
from well first I'm basically writing
JSX here which is a custom sort of
language that combines javascript and
HTML together in the same file and react
we can create components by creating a
class that inherits from component we
declare our state so you can see this is
kind of like the model we have our first
name in our last name that's our state
and then that state gets rendered into
the Dom so we can see the render
function how it has HTML and it's
rendering out an input and that value of
that input it's getting its value from
the first name now this brings up an
important point every framework we
looked at so far as a two-way
data-binding
it could flow data automatically back
and forth react doesn't really do that
instead it has this one directional data
floo for everything and so what this it
looks like a binding but what it's
actually doing is its only getting the
first name out of that state and
rendering it into the inputs value if
you want to go the other direction you
need to manually wire up the events so
you can see here I've got this on change
event and whenever they on change fires
then I'm going to call this first name
change method which is up here it's
going to get the event from that event
I'm going to pull out the value of the
textbox and update my state so that my
first name is now updated I'm then going
to tell to recompute the full name once
that whole process finishes the
component is then going to re-render
itself with all the new values same
thing goes for last name which you can
see here and here and of course the full
name is just rendering out that state so
you can see that at least in the case of
data input there's a much more manual
process that one has to go through in
order to handle that now there are other
things on top of react that will make
this easier but out of the box this is
the kind of flow that you deal with when
doing kind of input based stuff all
right so I think with that we're done
looking at this this is obviously really
fast I just threw a ton of information
at you six frameworks and we spend about
four or five minutes per framework so
now you have a bit of a foundation for
understanding what these frameworks look
like how they're used what their
philosophy is kind of the different ways
that they do the same thing from that
I'm going to jump back into my slides
and let's get into the nasty part don't
hate me
we're going to start comparing things
now we're going to start with the
technical comparison the first
comparison I want to make is size of the
framework the clear winner in this case
is react I didn't talk about Redux but a
popular combination of reactors
combining it with Redux and so you can
see that Redux + react comes in as the
smallest framework these are all
minified sizes not gzip but minified and
so you can see that react is the
smallest framework if you add some of
the optional plugins that's where you
get 167 K from the question marks there
at the end for that size represent what
I stated at the very beginning which is
that react isn't really a framework it's
more of a view run
so you have to remember that if you're
going to use react you're going to have
to add things to it so that's the
question marks representing the size of
your custom-built framework if you will
using react is very dependent on the
project so that's really kind of an
unknown if you move up the line into
what I call this middle tier this middle
zone here with angular one polymer and
Orillia you see things get a little bit
larger but angular one was still small
the one 58 is the minimal version the
240 K is basically a more typical
configuration which includes the router
the HTTP capabilities and the animation
system when you move up the polymer it's
getting a little bit larger to 22 is
sort of their minimal version based off
of their light polyfills 302 K is using
a more extensive aspect compliant
polyfill and the question marks in this
case indicate the fact that this doesn't
include a router and HTTP client or an
animation system so you can see how we
went up in size from angular 1 to
polymer but we went down in feature set
ok so these are things that are
important to realize with the frameworks
we move up to Orillia we're a slightly
larger 255 k is the minimal size and
then 323 K is the framework plus the
normal standard plugin so that includes
a router that includes animation and
that includes an HTTP client moving out
of that mid-tone we start to get into
things that are definitely a bit larger
ember has done a lot of work to bring
their size down but there's still a good
chunk larger than the next kind of size
down so there at 435 K that includes the
router as you know because ember
requires the use of a router right so
that's going to include the router and I
believe that's also HTTP but I don't
think there's an animation system in
there with angular 2 you see a bunch of
sizes that are again quite large that
698 K is the minimum framework 919 K is
the framework plus rxjs which is highly
recommended extension because angular 2
is very based on rxjs in a lot of ways
so they kind of recommend you drop that
in there 1023 k includes the router
and the httpclient but does not include
animation so you can see at this point
we're actually more than twice the size
of ember for the same features and
actually ember can do some more things
that angular 2 can't do so angular twos
clearly on the left out and left field
somewhere here now important note about
angular 2 is they have been working a
lot to get their size down and one of
the things they're doing is called tree
shaking which allows them to remove
parts of the framework that you're not
actually using the problem with that is
the only way to get your app small is to
not use much of the framework and in
real world apps you typically use a lot
of the framework especially if you bring
in a third party component library like
a telluric suite any kind of data
visualization these libraries make
extensive use of the core framework
capabilities oftentimes doing like
dynamic compilation which means you
can't tree shake those capabilities out
so you're going to be left with a large
framework there so just bear that in
mind
even though angular 2 is the largest
it's still as less features than some of
the frameworks in the middle zone which
are a third smaller how about
performance how fast can these
frameworks draw on the screen using an
independent benchmark called DB monster
which basically regenerates lists as
fast as the frameworks can do it I ran
these benchmarks on this machine with
the same browser so this is a MacBook
from like three years ago and I ran them
in Chrome on and these are the numbers
that I got I don't have a number for
ember because I couldn't find an updated
implementation of this benchmark for
ember like there's one out there but
it's very very slow but it's also very
old and I know the ember has done
extensive work in performance which I
believe makes it probably definitely as
fast as polymer but maybe up there with
angular 2 and Aurilia as well but you
can see that Aurelia and angular 2 are
pretty much head-to-head in terms of
performance here they're really really
close on my machine really it was a
little bit faster but it's kind of
negligible in that first number they're
both very very fast they'll be honest
all these frameworks are very very fast
that
50 you know even on the react which is
on the on the low-end in this benchmark
50 paints per second is faster than you
know you can see right so that this is a
pretty fast still that's how fast it can
paint repaint the entire list per second
right you'll notice that I really an
angular to have secondary numbers which
are higher that's because both of these
frameworks have plugins which allow you
to opt into other features that improve
rendering performance in certain
scenarios with Orillia we have a
virtualization plugin which only draws
elements of the list which are actually
visible so if you have 10,000 items in a
list but only 20 are on-screen it will
only draw 20 so that makes a lot of
sense by dropping that into this
benchmark we get 130 to 150 paints per
second which is far above everything
else and angular 2 they also have a web
worker based multi-threaded renderer
which can be turned on as well and that
also improves their performance one
caveat with that is that it only works
in Chrome and Firefox because that
technology isn't implemented everywhere
just yet but it's coming but Barrowman
you won't be able to get that upgrade on
older browsers at all as opposed to the
other upgrade alright so how about
standards compliance how close are these
frameworks staying to web standards well
at the top of the list you've got really
a polymer and ember which are all using
standards compliant HTML all focusing on
Xmas crip 2015 and then also a really
and polymer are also using parts of the
web component spec I ranked a really
higher in this case because it really
also implements the shadow Dom v1 slots
which polymer has not updated to yet if
you don't know what that is don't worry
about it too much it's just one of the
web components specs but I imagine
polymer will be updating to that very
very soon but clearly a really and
polymer do the best job at standards
with ember being a very very close
behind when we get down to the second
half of the list things get a little bit
odd as I mentioned when we looked at the
angular 2 code we have something that
looks like HTML and angular 2 but it
begins to use casing that makes it
impossible to use with the built-in
parser of the browser so they deviated
just enough from the spec to require
their own parser which preserves
kasing so that's a little bit odd also
they write part of their code basin and
dart which you know maybe it's an issue
maybe it's not but a lot of people don't
know that angular one actually in some
ways more spec compliant than angular 2
a very good job of having standards
compliant HTML I used yes 5 but that was
the cutting-edge course at the time the
place where it wasn't as compliant was
in modules and the way it handled
dependency injection because that it's
just an older framework it was just
before these things got standardized so
in some ways angular 2 improved on that
by using a better pattern for modules in
DI in some ways angular 2 kind of
regressed in terms of how they're
handling HTML and some things react is
very very different it's using Equus
crypt 2015 but it's also using this JSX
thing now your opinion that you can kind
of think of this in multiple ways you
know if you think of this as a view
rendering language then it's not such a
big deal really but it is a bit odd that
it looks kind of like HTML and it's
mixed with JavaScript but the HTML
that's in there isn't actually HTML
right there's mixed casing and there's
event names that aren't the real event
names and different things happening in
there so it's maybe not a huge deal for
you but the important thing that you
should note is that if you're have a new
developer coming in that's learning so
they react first and then they go and
try and just write HTML they may have
learned things wrong because JSX
the HTML and the JSX isn't precisely
HTML right so it's a bit of a non
compliance issue there may be a big deal
maybe not depends on what you're doing
all right
separate a presentation things like MVC
mvvm MVP how well does the framework or
platform allow you to have a clean
design by separating the model the view
and the controller or the view model how
good does it do separate a presentation
well you saw that a really an ember did
a pretty good job of those demos very
clean template in one file class and
another ember had a very strict MVC
pattern so those pieces are very clearly
differentiated angular one actually does
a pretty good job as well
the syntax isn't is clean like I said
it's a bit dated but it keeps those
pieces pretty well separated anger
actually gets worse and you can't see
this in the demo that I showed you
because it didn't use a lot of external
directives but when you build a
component in angular 2 the whatever
directives you use in the HTML if you
use a repeater or an if or a switch
those have to be declared in the
JavaScript so your controller or your
component code is strongly linked or
strongly coupled to your view which
means that those two things can't very
independently have one another very
easily without a maintenance problem it
also means that it's hard for two people
to work on the same component if you've
got a designer that wants to work on the
HTML and CSS they can't do that without
messing with the JavaScript and if
you've got a JavaScript developer that's
maybe working on the advanced behavior
there they're going to be stepping on
one another remember that things like
separate a presentation these patterns
and in fact most design patterns are not
primarily about technical issues but
about human issues of how we collaborate
and how we work together and how we
achieve productivity if everything is in
the same file or if concerns from this
thing mix into concerns from this thing
then we can't have two people work on
the on it at once
we now get less parallelization of our
work now only one person can work on it
and this is the same problem that
polymer has also if you saw everything
was done in Dom but now every single
piece is in that same file and it's not
really a good way to split that out and
so that causes a problem if you want to
parallelize work with multiple people
working on the same part of the same
component or sub component of the system
now separate a presentation doesn't
apply to react right because remember
react in fact in some ways it Eber
applies right because react does the
view and that's all it does right you
are responsible as a developer to figure
out how you're going to do separated
presentation yourself and every react
app that you built so you need to take
responsibility for doing a good job with
that but react focuses on the view and
so you know it doesn't this criticism if
you will or this way of comparison
doesn't necessarily apply to react
because it doesn't care about view
models or controllers or models or any
of that
how about obtrusiveness how much does
the framework get in your way the
framework API is how intermixed with
your Co
they get a really is probably the best
of this in fact no framework is quite
like this if you remember I showed it
really it's just a plain class there was
no framework in the JavaScript ember and
polymer actually do a pretty good job of
this you can see that ember lets you for
the most part create simple models in
fact it's much better and es2015 if you
look at the way you do it in es2015
polymer does a pretty good job but
angular 1 angular 2 r we're actually
both very obtrusive one of the ways you
can see this with angular 1 is you go
look at all the plug-ins for angular 1
there's thousands and thousands of them
is that just because angular 1 is
popular or is it because you have to
wrap every third party library in order
to make it work with angular 1 and the
reason is because the design of angular
1 the way it's dirty-checking mechanism
worked is anytime you wanted to use a
third-party library that might touch the
Dom you had to wrap it and call some
special angular api's in order to make
it work so that's very obtrusive there's
a high friction that's involved in that
process also angular 2 is fairly
obtrusive as well although it improves
on that issue from angular 1 it now
still has those component directives
everywhere in your code you have to
declare the the directives from your
HTML in your JavaScript and in general
if you look at more advanced to angular
2 apps you'll see that you have to
configure the change detection mechanism
a lot more and deal with a lot more than
nitty-gritty details of how angular
works ultimately making you write more
and more angular code in the real world
and react is fairly obtrusive as well
because there's no escaping the react ap
is when you write a react app you're
using the rack react API is the render
you're typically using JSX so react is
just kind of infused in most of your
view code at least and again it's up to
you as a developer to take
responsibility to isolate those things
appropriately as you know how to do how
about interoperability well
interoperability is typically a function
of standards compliance and
obtrusiveness
so the things that stay closer to the
standards are going to interoperate
better with other things the things that
stay out of your code and out of the way
of other codes are going to interoperate
better with the other things so Orillia
and
and polymer are much more interoperable
than say angular 1 and react which are
on the other end as I mentioned before
with angular 1 you typically had to wrap
every third party library that you used
with react most of the react developers
I've talked to tell me that they that
they don't use anything like jQuery for
example typically instead that they
would just rewrite the thing so there's
a lot of writing stuff from scratch
because it's more difficult not
impossible it's more difficult to
smoothly interoperate with somebody's
third-party plugin because those things
work with the Dom and react works with
the virtual Dom so there's a bit of an
interoperability issue that needs to be
solved there angular 2 improves in this
category because of the way it's changed
it's dirty checking mechanism but
there's still a certain amount of pain
that's involved in op interoperating
with things because of the extra syntax
that's involved let's move on from
technical comparison and let's talk
about the project and the team again a
lot of people think only about the
technical stuff but I've got like three
or four other categories that we need to
go over right because there's a lot of
things you need to think about when you
pick a platform so let's look at the
project itself the project here you can
see they all have websites which is
great they are their own websites
they're all open source and they have
their source code available on github
they all have pretty decent open source
licenses MIT for the first three first
four and then BSD for the second two
with a note on react I'll come to that
in a minute
status is worth mentioning because the
way that these frameworks can handle
releases is quite different angular one
is on the 1x release but it had breaking
changes in its minor releases so it
didn't really follow a semantic version
it's more like it's on version 5 to be
honest if they were semantically
versioning or the one it would be like
angular 5 so keep that in mind
angular 2 isn't a release candidate now
though the release candidate excuse me
wasn't really announced on the blog or
on the website and they just recently
added a note on to the github so sort of
like a soft release candidate it's still
undergoing breaking changes in fact just
today they announced a brand new
implementation of a router that's in an
alpha state so even though it's called
release candidate it's not really a
scan it we have to be honest about that
if you look at what's actually happening
there with Aurelia we're in beta but
we've been in beta for six months with a
stable API for six months so it's not
we're not are teaming yet but it's more
stable than some rtems with ember mega
props to the Ember team really
impressive the way that they've handled
their move from 1.0 to 2.0 they had a
very strategic way in which they version
the framework in which they migrated
developers and slowly deprecated
features so they're on an official - o
semantically versioned and have done a
really fantastic job with how they've
transitioned the community over time a
polymer just recently hit 1.0 and it's a
real 1.0 so good job for them and also
props to the react team the react team
was on like 0.14 0.15 and then they
realized you know what we're really on
version 14 and we're really on version
15 so let's just say that because
everybody's using it that way anyway and
now that's properly semantically version
our library so they switched over to the
15 X version and that's an accurate
representation I think so props to them
for recognizing that and switching that
all these projects have a lot of stars
if you look at github anything with more
than three or four thousand stars is a
pretty successful project to be honest
clearly the ones backed by Facebook and
Google have more stars because it's
Facebook and Google you can also see the
open issues on this is again as of a
couple days ago so these numbers
obviously change all these numbers here
but the smallest number of issues goes
to ember now this isn't bugs this is
bugs features all kinds of different
things I looked across the tags of all
these projects in the way bugs are
categorized are quite a bit different so
it's difficult difficult to get a an
existing number of reported bugs across
there but what seemed from my looking at
it intuitively is that the number of
bugs was correspondent with the total
number of issues at least so keep that
in mind but props to ember on this they
have the smallest number of open issues
second by Orillia and the most open
issues is angular 2
and a really important note here and if
you don't know this I'm sorry to be the
bearer of bad news but the react license
has a patent clause in it okay if you're
using reactor considering using react
you should not unless you talk to a
lawyer because of the patent clause it
means that you cannot do anything that
in any remote way could be construed as
competing with Facebook you're actually
not licensed to use react in those cases
you also your license is revoked if you
have any kind of IP dispute with any
other company that happens to be using
react and there are a bunch of caveats
to this if you don't know anything about
patent law it's crazy I'm just telling
you it's crazy the ways that these
problems can arise so I'm getting on my
soapbox here but I'm saying I would
never touch a framework with a patent
clause in its license I don't think that
open source and patent Clause is mixed I
don't want to make that decision for you
you need to have a lawyer and talk to
your lawyer and think about your
business and what it is you're doing
before you use react because there is a
patent clause in there and that does
have serious ramifications that's why
Google employees are forbidden from
using react
that's why Microsoft employees don't
aren't allowed to use react all these
kinds of things a lot of not a lot of
people know this because they don't
scroll down to the bottom of the readme
then look there and read the license and
see all this stuff but it's in there
it's right there so please keep that in
mind that doesn't mean you can't use
react but it means that you need to
consider this carefully from a legal and
a business perspective how does the
court team work out for all these
frameworks well each framework here has
a sizeable core team I couldn't
determine the exact size of angular one
because they're kind of shuffled in with
the angular 2 on the website but all
these frameworks have a team and this is
really important for a framework like
this you don't want a one-man show
that's not really going to be good as a
platform if it's a smaller JavaScript
library that does one little focused
thing it's not a big deal if it's only
one person but if you're picking a
platform to build your app on you
probably want there to be a team now the
teams are located mostly in Silicon
Valley because really four out of this
frameworks here are made by Google or
Facebook right so they're like next-door
neighbors so angular 1 and angular 2 and
polymer are all the teams are located
basically on Google's campuses and react
they're basically right at Facebook now
here we get into something really
interesting here take a look at this one
of the most important things you need to
consider when picking an open-source
framework is do the people who design
the framework use it and this is
actually quite surprising especially to
a lot of people who use angular which is
the answer is no with respect to angular
1 and angular 2 the people who actually
design and implement angular don't use
it on a daily day day to day basis from
what I could tell some of them may have
never put an app in production with it
or at least not in maybe multiple years
with respect to angular 1 this is really
important for open source if you adopt
open source you want to make sure that
the people that are writing this library
actually using it themselves they should
feel the pain you feel they should
understand what works from their own
experience this is just an aspect of I
think us as humans that when we're using
our own tools we understand how to make
them better and so you can see actually
that angular 1 and angular 2 didn't
really do such a good job of this
polymer they partially use it especially
a big events they built this what I do
to do some stuff with it react at least
they initially did I'm not sure if the
same team is using it now because now
they've got this framework team I would
love to hear information whether the
actual react developers are actually
building Facebook products with it or
not it definitely came out of a facebook
product which is a really good starting
point so that's important or out of a
not a Facebook product but uh what was
that company that other company anyways
the other thing is training do the core
team members actually train and this is
actually really important because often
that not just the best source of
information but the best way to
understand the mentality of a framework
is from the creators of it so can you
actually get access to the people who
build the framework to go to a workshop
with them or to have them come to your
company and train you and that's also an
area
where none of the Facebook or Google
oriented things come succeed so I really
an ember really do very very well in
both these categories how about
community and communication well on the
community side of things there's a lot
of contributors for most projects this
is the number of developers from the
community that have committed code to
the project so you can see angular 1 is
the biggest there it's also been around
the longest followed by react and then
you can see then it's ember Orillia an
angular 2 and then polymer and polymer
has the smallest number of community
contributors how well does this a team
collaborate with the community invite
them and take their feedback and anger
the one did a great job with this
angular 2 not so much they kept a lot of
thing in private documents and sort of
behind closed doors even though it was
open source it was kind of not really
talked about publicly at least for the
first year or so so they didn't do a
good job with that I really an ember do
a really great job with this involving
in fact ember has an official process by
which it does this polymer was very
close in the beginning and they weren't
making any progress with web standards
that they wanted to see adopted so they
finally loosened up on that and started
collaborating with other groups and so
that's good and of course react does a
really good job of collaborating with
the community how often do they
communicate with their community if you
want to find out the news of what's
happening with this platform how often
are they talking to you now angular 1
and angular 2 combined only have one to
two posts in a three month period so
they're not very good at communicating
openly ember and Aurilia both have at
least one post per week for the through
the official channel so you can stay up
to date polymer and react both do a
pretty good job of having a regular at
least once a month update on the project
and this is this kind of communication
is really important when you build your
business or product on top of that you
want to know what's going on what's
coming what the plans are all these
sorts of things public appearances is do
do the core team members actually appear
at public events do they actually come
out to events like this and talk do they
go to
code camps do they go to meetups do they
go to events that aren't their event
sponsored in other words to the angular
core team do they actually speak at
events that are angular conf
does the react team actually speak at
events that isn't react conf in the
example the the truth of the matter is
is you don't really find them out there
doing much in the community like that
very different from the Orillia and
ember teams that are speaking all over
the place all over the world from the
smallest meetups to big conferences like
this I think that's really important how
about learning materials you want to
learn a framework you need good
materials well the great thing is is
that this is mostly a bunch of yeses for
every one of these frameworks there's
API Docs articles guides videos
Pluralsight courses book starter kits
command-line tools samples everything
there's just one little detail if you
want official training directly from the
people that build the framework you can
only get it for a really a number so
that's not something you're going to be
able to get from Google or Facebook this
really brings us into the business side
of things does the company that produced
the framework buy in well this comes as
a shock to a lot of people but angular 1
and angular 2 and polymer are not Google
products they're open-source side
projects of teams inside of Google
they're not productized in fact one of
the surprises I had when working on the
angular 2 o team is that nobody ever
used the term customer and nobody ever
talked about product in fact I found
myself being one of two or three
consultants that were the only people
advocating for the angular community
during the design of angular 2 and that
really troubled me and the reason is
because there's not an official product
going on there's not an official
customer relationship as we go down
you'll see a few other things here
polymer also I asked them point blank is
polymer a Google product am i a customer
if I'm a developer that uses this
product and they said no and no same
thing with react it's not a product of
Facebook Facebook is not committed to
react as a product can you get
commercial support well again it's only
for really a member can you get
consulting directly from the people that
built this directly from the companies
that
these things well only for a really an
ember are their official customer
relationships again for anger the both
versions and angular and react there's
no product there there's no official
customer relationship though that
infrastructure does not exist again it
does for it really an ember and that
comes down to and same thing goes with
official partners for the most part
angular2 has a couple but for motivation
this really comes down to motivation why
does angular exist because of green tea
who knows what green tea is you don't
know what green tea is that's the app
that drives everything that happens with
angular it's an internal app it's this
is not private knowledge you can go
google this and you'll find it it's just
not talked about a lot publicly but if
you look through the design documents if
you look through the github issues
you'll see GT GT GT you'll see this all
over the place
or maybe spelled out green tea and you
can google this occasionally at a
conference you'll hear that phrase
mentioned and that's because it is the
product that Brad green and the his team
works on and it's the sole reason for
angular 2 and it Trump's every other
design decision when I worked on angular
2 I got really frustrated because the
feedback I was providing didn't seem to
matter because it was always trumped by
this Green Team project that was
internal so you need to understand what
the business motivators behind these
things are the only companies that are
actually building a platform for
developers are the companies behind
Orillia and ember polymer mostly built
kind of as experimentation with web
components react was originally built
with apps but you'll also hear the react
team use the language of experimentation
we wanted to experiment with this we
wanted to experiment with that only a
really a number have from a business
perspective decided to build a platform
as a stable platform for developers
brand recognition
well obviously Google and Facebook they
have the best brand recognition all
right now just pointing that out thank
you
so what are my recommendations at the
end of this highly biased talk you can
probably figure out what they're going
to be but I hope you see why I'm not
trying to pull one over on you okay
these come in three categories the yes
they may be and the no so clearly I
think the yes is a really
mber obviously like I said I'm biased I
include ember in this because you see a
lot of the same values on the Ember team
as we have on the Orillia team standards
compliance stability the business side
of things all these different things
that I talked about which are secondary
or tertiary concerns of the other
frameworks really really important maybe
is polymer and react this really depends
on what you're doing
react is much better for read-only apps
it's more difficult for input intensive
apps but remember the patents clause
okay you cannot ignore that if that's a
problem then react is probably a no for
you but if you really like the react
programming model you should look at
riot it's an alternative very similar to
react but without the patent problem in
fact it's smaller as well so again maybe
react but probably if you're leaning in
the react direction you might want to
look at riot instead and polymer you
know maybe maybe as well polymer is less
app focused and more component focused
so if you want to build a set of
reusable components across multiple apps
polymer might be a good choice but again
nobody wants to include another
framework just four components so what I
recommend is instead of using polymer
you consider using web components j/s
which is just the polyfills for the
standards upon which polymer is built
and then you can just build a spec
compliant web components to share across
apps and then pick one of these other
frameworks as the app framework that
helps you bring those pieces together so
those are in the maybe and clearly I
mean you knew this from the beginning
right you knew it sorry
angular 1 and angular 2 well I told you
angular 1 up front mainly because it's
deprecated it's basically going away if
flash and Silverlight are dead angular 1
is more dead because it's you know now
that it's not actually a product at
Google and there's no reason to actually
support it if green tea isn't built on
it anymore all right so it's going to
die faster than anything you know from
Google's perspective and angular 2 you
just saw that it has the same
motivational and business problems as
angular 1 it's also very large and very
complicated it requires a lot of
ceremony
to work within the code standards
compliance is kind of gone backwards
with respect to that and a number of
other things now obviously these are my
opinions but hopefully at least the
slide deck has given you a bunch of
information and encourage you to think
about a lot of different aspects of what
it is that is guiding your decisions
remember that all this data influx the
team the collaboration and communication
the technical aspects the business
motivators those all need to be
considered within the larger context of
your company your product your team your
corporate culture so I just want to
encourage you to think very clearly
about these things when you're making
decisions don't just pull something off
the shelf because you know the logo
there may be more things under the hood
there than you expected which aren't
quite perhaps what you assumed so do
your research consider all these facets
take everything into account and try and
make the best decision that you can for
your business going forward thank you
for being with me really thank you for
humoring me and understanding my bias
and bearing with me through this
presentation I am the worst person to
give this presentation clearly but I
wanted to give it because a lot of this
information just wasn't out there and
aggregated so I think even if you can
see through my bias then you can see
that there's some very valuable
information here so I hope that helps
you thank you again for coming and
please don't forget to press the green
button on your way out
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>