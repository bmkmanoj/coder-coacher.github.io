<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Talk: Fastware - NDC Techtown 2017 | Coder Coacher - Coaching Coders</title><meta content="Talk: Fastware - NDC Techtown 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Talk: Fastware - NDC Techtown 2017</b></h2><h5 class="post__date">2017-11-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mYzaFzAHuZ4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so who here is interested in making
things go fast
all right that's terrific
so in this talk we're going to talk
about a few things I learned while
during my six years of stint at Facebook
I worked as a research scientist which
really means you're like glorified as
Venkat said okay you know software
archaeologists working on things and
I've made a few small discoveries in in
terms of optimization that I find very
interesting and I wanted to share with
you one of which is what I call The
Forgotten parallelism so there is a lot
of talk about like parallel software and
all these great assistance and fork/join
and what-have-you work-stealing all of
these great great things there is a form
of parallelism that doesn't require you
to kind of start threads or you know
these few processes into these are these
awesome things it actually writes you
requires you to write code you know odd
specific way who has a guess on what
that could be
The Forgotten parallelism everybody
forgot about it apparently right so let
me show you is it visible yeah quite so
let me show you this is the internal
halo market tech chure and I don't like
a point or anything and I want to favor
any side over the other okay there's
like two more people on that side so I'm
gonna be there you guys so this is like
the traditional representation of CPU
and it's actually not the CP it's one
core Heena CPUs they're like eight of
those right so the data flow sorry the
instruction flow the instructions flow
top-down and there's essentially like
the whole pink part the color of like
vomit after a night of vodka that would
be the decoder decoding of instruction
so it transfers the complex
input instructions into nice risk
instructions that are simple but very
large so you know there's like 128 byte
with here and then we have something
interesting because we get into like
where the action goes and here's what
the action goes that's called V come on
you guys you know you can't be that high
level you got you got a level with me
here
hey thank you Hubert mm-hmm I love
Hubert's voice he has like so much but I
should I should you should voice over my
talk so this is the ALU arithmetic logic
unit and what's interesting about this
ALU is there's a lot of stuff that's not
vertical it's horizontal and remember I
said instructions flow downwards so at
this point there is a fork in the road
and as the thing goes you should take it
right so at this point we have several
things potentially happening literally
simultaneously there's a store dialog
there's a dress calculation there is a
integer add move whatever floating point
has a movement you know I can count on
things like you can have an integral
operation and a couple of floating-point
operations happening literally
simultaneously and the interesting thing
is you don't do anything about it anyhow
so at the end of this there's this is
actually a programmer helper because
it's an octuple associative data cache
whatever I'm sorry this is the program
helper memory order buffer memory order
buffer which makes things that are
happening weirdly in parallel look
relatively tame to you as a programmer
so you don't have you you know you have
the right sequence of of operations
almost almost almost almost real okay so
um the action is parallel and the
question is how to expose that
parallelism how do you make these good
use of this little parallelism and the
interesting thing is people like once
you lose that you never gain it back
right so to kind of ever gain it back
you gotta buy more computers so you
underused
as well you see my points that there's
this whole you know there's this all
talking about the dark silicon you know
dark silicon like it's here we have so
much processing power so this alien has
so much stuff on it so many transistors
that can do interesting stuff
interesting to some right not everybody
cares but you know interesting stuff but
we can't bring data fast enough into
those transistors to make them do the
interesting stuff so then how do we you
use those and it's very interesting that
this instruction level parallelism
happens even before we think about it
because there's a whole cabal there's a
whole conspiracy friends that is at work
making our code our serial code that is
parallel there's all of this laundry
list of things and many many others they
only conspired together to expose
publish material code and if you sit
down and write serial code it's going to
have any hearing parallelism and there's
a magical number which is like a cross a
large variety of coding styles and
applications it's going to be actually
this is the amount of errors in serial
code who knows what the number is how
parallel do you think you're writing
code today on average like you know 1.5
like you write code that serial but it's
actually 1.5 parallels good hook is more
to ease your code to a parallel without
yes give who gives more this is a kind
of a yes come on I should have that fast
voice or like folks who do that kind of
stuff so actually it's 4.2 so the
average serial code has four point three
here in parallelism which is
discoverable and automatically paralyzed
about this is the Forgotten parallelism
and now what I want to do is discuss
ways to expose and exploit more of that
parallelism make it I don't four point
five because it can happen
without actually a sitting out you know
dude you got a fork girl Chris threads
and gonna dull all these awesome things
no it's just rewriting code in a
slightly different manner and it's
actually not really just slightly but
it's rethinking your code in such a way
that's gonna make it parallel so the key
to the kingdom is you gotta have fewer
data dependencies now what is the data
dependencies probably it's good to know
right yes all right all right so that
was a complicated explanation why don't
you do what Venkat said make it simple
what would be a simple explanation say
that sorry that that looks simple but it
requires quite a bit more background the
whole hazard thing what is data
dependency an operation depends on the
result of a previous operation friends
that's it right so that was an example
given all of the simple of the simple
notion so whenever you have something
depends on something else you have
serialism and you have a data
dependencies because you know whatever
you do must wait for the previous
operation to end and that's all the
cookie crumbles so well we want to make
those you know as few as possible want
to minimize data dependencies and we're
going to show you an example who know
c++ c c+ i don't care c plus was right
okay who understands what this function
does by for example i look at the name
it converts ascii to integer so it takes
a pointer to the beginning of a string
of characters and a pointer to the end
of the string characters in HDL style if
you wish to iterate as if you wish right
and it's going to compute the the
conversion of that string of characters
to
and unsigned integer so we don't care
about sign kind of simplify our life a
bit and it does so by successively
multiplying the current result you know
the running result by 10 and adding the
least significant digit right the
current digit now this function is uh is
called actually Horner's scheme if you
crack up on any book on algorithms from
way back when in college or whatever or
you know for me it's way back when for
you it may be much more recent but if
you crack up on a book on algorithms
gonna see this is how you do it and it's
been like this for literally the past 50
years it's considered an algorithm that
is classic and at its optimum and I'm
here to tell you this is not this
classic but it's not at the optimum it
can be improved radically the problem
with this algorithm being it has too
many damn data dependencies and who can
tell us what are some of the
dependencies involved yes the result
depends on its previous version by me
and also now on the current character
like star beam by means of a complex
pattern right well the result is result
intense terminal thanks whatever plus
whatever so that's a problem and I sat
down you know I would the funny story I
was working on a database a higher high
performance high scale we're talking
petabytes and it's called hive a Merinos
hive the hive database as a used for
offline data at Facebook and it's a it's
a awesome data is great and just because
so awesome so powerful so fast they
decided to make communication between
the database and the client computers in
a most brand possible text the second is
too powerful actually let's make it
let's make the communication stupidest
format there is keep it kind of in a
textual format so then every client
whenever they need to do something they
are going to do what read numbers on the
database convert them to grata integers
and floating point numbers in one have
you dates times what right and then do
some computation and then you
convert back to text and send it to the
database I am not kidding this is not a
joke so you know we had like these hive
applications and kind of slow you know
what's happening here let's let's you
know let's measure this thing let's see
where the time goes guess what all the
time was goes here right because
whatever I do you're gonna have to
convert every damn column and every damn
number into from text right so that was
a bummer so well who's the idiot who's
gonna help us improve this thing oh
there's Andre right so here I was
working on this I spent on this like
probably a couple of weeks sleepless
nights what have it was you know if this
was a movie that would be one of those
ellipses in the movies where I kind of
sit here and kind of think real hard and
kind of scratch paper and can throw it
away and kind of you know beat my wife I
don't know that kind of stuff right so
it was one of those nice sequences in
movies like you know Rocky Balboa and
whatever so great and I came with the
following great idea I said you know
what am i drinking I'm gonna kind of
give justice here and kind of stand on
this side as well so I said you know let
me write this with pen and paper
what is the actual computation that is
performed and I said okay so this is
what the algorithm really does in
inlined math form I feel like the first
thing I'm doing is like an idiot are
multiplying by zero that's not a good
sign I mean the fact that the sheer fact
that you're doing some useless operation
to start with it's not a good omen right
agreed so that you know cancels your x
time okay thank you very much idiot
right plus five everything times ten
because every depends on the previous
result the algorithm so then plus two
everything times ten plus three
everything times ten plus and I can't
yell any any louder because I'm going to
destroy my voice but essentially I'm
doing something really really
complicated I love Venkata
not only because he along with this the
clicker but he made great points about
simply this is not simple it doesn't
look simple it looks ugly it has too
many parentheses and I liked Lisp also
has parentheses but in this process
serve a different purpose
they represent them you know be
dimensional data structure you turn in a
dimensional string right so it's a
different their grammar separators if
you wish they are punctuation in here
they're not punctuation they are an
obstacle to efficiency because what does
the process is doing math it forces the
order of operation to be not the natural
order as whatever deity intended right
it says you know what you shouldn't do
things as they are
it shouldn't do things like the path of
least resistance now you should like do
this first and then that right so
parentheses is all already a data
dependency you look at the you look at
the math you see has so many processes
there's too many data dependences so now
you know how to improve this thing the
question would be thoughts ideas yes
so we multiply by some constants and
there's another yes sorry so use parts
of 10 use sort of the positional well I
gotta admit I'm not as smart as you guys
I went through a went through a you know
stage where I was thinking there's gotta
be some divide and conquer solution to
this I thought maybe I divide the string
in two or more pieces and then I kind of
figure out this ending you know I don't
know me actually this is interesting
because it Rizza
it leads us here it gets us here to this
nice point in our lives
whereby you know this is actually
beautiful and it has no parentheses and
actually you know it aligns nicely so
you see the number here is also on the
vertical and we have a triangle here so
you know I think the Vinci would like
that right that kind of stuff right so
if you like I can see this goes it's
really a simple and nice and shapely if
you wish formula and you know lot tech
loves this because you can align with
lot I call this all this process and
stuff has special codes for that so okay
oh well this is pretty awesome so let's
try this thing and you know the code
looks looks a bit just a bit more
involved but there's nothing complicated
about it because I'm really one thing I
really take pride in is I can write
powers of 10 realize it's you know
there's gonna be a triangle here right I
didn't write everything right so there's
gonna be this nice triangle with one
followed by 1907 one followed by 18
zeros and so on and all of them are
gonna you know nicely converge there and
then we have enforced by there it's kind
of like an assert that always that's
always in action so then forces like it
throws an exception whatever so then I
say okay so I'm starting with the result
and here I'm going to
well this guy come from 20 you should
not you should never have literals in
your code right you should have only
like minus 1 0 &amp;amp; 1 and everything else
should be a symbolic thing this comes
from there and it means it's the end of
the array and it positions me starting
from the end of array it goes back to
whatever the most significant digit is
so it's going to position me in this
table in our in our example he is going
to position me on 100,000 right so it's
going to position me there so by the
time I kind of doing a instead of kind
of computing powers of 10 on the fly and
just gonna put them in a table just just
so I save a bit of a bit of work but
that's not instrumental so case I'm
starting with this I at sort of the
right position of the most significant
digit power of 10 now I'm gonna say okay
so let me kind of go from there and
result is result plus power of 10 of I
plus plus times the current digit and
that actually implements that very
simple algorithm so it's just a
different thing but it has fewer data
dependencies because now result still
depends on its previous value but only
by me so Bob and guess what plus has an
interesting property which is called
it's cumulative and it's interesting but
probably not for this case associativity
the interesting thing about plus is it's
associative which means the plusses can
be done in any order including in
parallel and guess what the CPU
architects know that whenever I see an
repeated addition they're going to be
like yes your own buddy is awesome I
know what to do here whereas in a
previous algorithm it's a much more
complicated patterns are gonna multiply
that with 10 and kind of do this and
have a coffee in that kind of stuff so
it was very different and this approach
is going to be perhaps faster so what do
you do to make sure to
validate the fact that it's fast or not
measure I've seen so many people too
smart to measure and you know it
includes me as a flight you know while
ago like a week ago
right so you know did when you measure
you actually get a leg up on experts who
are too smart to measure so it's really
good right so let's measure this well I
did and my question to you is like how
much do you speculate we're gonna win
here gonna win 10 percent 20 percent 50
percent 80 percent thank you
who gives more 200 percent so the three
times faster all right
thoughts depends on the length yes so we
got a measure for all digital number
lengths yes five times five percent all
right and yeah it could be slower by the
way so it does happen it did happen to
me to me with disquieting frequency that
I thought sound it's going to be faster
it was a net pessimism right to spend
time actually making things slower which
was pretty you know just not
counterproductive so it's actually that
John was right it's three times faster
and it trails down to two times faster
and what I like about this this growth
so this is the relative improvement on
the baseline by the ways I make this so
I just had this Plus which due to which
my voice is so course right now and they
also my my accent I didn't have an
accent when I came here he should know I
was like has a perfect British accent
was awesome and just because I'm so
tired it's just so um the nice thing
about this first of like let me let me
go take a parenthesis and tell you about
baseline so what's a baseline a baseline
yes in a measurement what you're
measuring against I've seen too many
people who don't use baselines
and it's funny because it sort of makes
a bit of a difference between an a
newbie engineer if you wish and a
scientist the scientists always these
baselines and also marketing people is
baselines in marketing you always choose
like the worst baseline you can find
right say look good
so like I'm gonna choose this shitty
algorithm this crap implementation is
awful product and then it we're like was
so much better than this the leading
competitor and that kind of stuff right
so I'm marketing people do that all the
time but as a scientist you know you
want to choose the best baseline you can
find because that means progress if
you're better than the best then you're
you know you that it means global
progress in humankind if you wish so
that that's why you should always use
baseline see if I showed you here
nanoseconds and microseconds you should
actually you should punch me right now
right because I you know it's it just
takes like 15 nanoseconds to do this
operation like you know what I have no
idea what you mean with nano see maybe
at the baseline we faster made all the
way would be faster by few nanoseconds
or whatever microseconds so I should
show you by how much the current
proposed solution improves over the
basement which means one is just the
same and below one is not good and above
one is interesting that's good
right so our process is closed use
basslines people like whenever it do
performance like dual use baselines and
measure right
I hope I'm preaching to the choir here
so we are at three point four trailing
trailing down to two and that's a very
nice result and actually there's one
more thing that I like about this
algorithm is is that it is better for
small numbers it's I mean the perform
the improvement is even so much better
for little numbers and yeah there's a
you know the loss of big numbers the law
of big numbers in math right they say
you know those like with growth but
actually in program there's a lot of
small numbers like most numbers are
small like if you look at
numbers in all applications in this
world right now what I like about like
seven and you know no greater than forty
to add that kind of stuff right
most rings are empty and those that are
not tend to have like one character that
kind of stuff like most most most things
are gonna be small of course it's gonna
be a lot of large numbers as well but
how often did you have an array that had
the size of like nineteen bits there
right maybe not too often you know that
kind of stuff so I like that the
improvement is so much better for small
numbers because it turns out that for
small numbers you know small numbers are
much more frequent however there would
be exceptions like who can give us an
example of a number that is actually
shouldn't never be small an integer 64
bit oh sure the hash ID like user ID or
random generator number you know
anything that is supposed to have high
entropy would need to occupy all the
bits in a 64-bit integer so it's if it's
small that's a problem right so by the
way Facebook started with that's funny
how things start right so I start like
Zack has ID like four no joke like his
ID on Facebook is four and first we are
not occupied right like zero to three
are not just not taken I tried but don't
you they wouldn't give it right so Zack
is four and then you know I kind of grew
like by one after that and it was kind
of weird and then they started
generating like when they got a live
like two ten thousand people like whoa
we're doing it wrong dude let's let's
subscribe
let's subscribe these random IDs great
so associative means paralyzed able
there is a there's a deep truth here
whenever you have an operation that's
associative in good shape because you
can paralyze it in the CPU can paralyze
it for you so now let's apply an
optimization known as strength reduction
anyone who wrote the kind of knows this
kind of a compiler term compiler
architecture term Hubert talk to me
right so strength is a bit of a misnomer
it's kind of expense reduction which
makes a lot of sense economy friends
right stress reduction means you take a
multiplication replace it with an
addition that kind of stuff right or you
take a power and you replace with a
multiplication or take an addition we
replace the addition with absolutely
nothing because there's nothing cheaper
than addition any additions like one
cycle right so let's focus on this thing
which is m4 switch like assert like
verify that the input is correct so you
gotta have it make sure that the current
digit is valid between zero and nine SK
right so actually if after inlining and
whatever you know it doesn't really
matter it reduces to if the digit is
less than zero or greater than line then
I'm going to throw something is
incorrect input and then we have the
core loop in the computation and the
question is you know let's improve on
this a bit so let's take this operation
here and make it just a bit faster
because let me let me point this out to
you you know this is like short circuit
right short circuit evaluation a great
invention in the early days but now
right now it's actually bad because it
introduces a dependency right because in
order to evenly valuate this expression
this comparison this must be finished so
what do you do as a good engineer to
make sure that this is not a dependency
remove the dependency for me please
sorry use and and it's the same deal
it's just yeah it's or an and both are
short circuit logical or logical and
sorry
okay other thoughts yes sorry
the second if split up into trips but
still have that same dependence eat
cereal if this guy and then I test that
guy I want I want let me clarify what I
want remember that nice ALU with things
that it can do in parallel this and this
can be done in parallel
I want them done in parallel yes use up
be twice or you know lose one lose one
pipe here lose one pipe thank you lose
one pipe and the bitwise door is going
to give me the same result as the the
cereal or what is going to allow
parallel execution which do you think is
faster so this guy or that guy which the
do you think it's measurable first of
all do you think I can measure
difference and if so which is going to
be faster in your intuition the second
is going to be faster so I thought so I
thought in my recklessness yes
now I'm testing on every possible string
length random numbers so random numbers
of length one sorry yes but you know
this is the thing I don't want this to
be fast because by the time you throw
you can tie pretty much like the
performance is down the drain I'm
testing on valid input I want the cost
on the normal path to be as low as
possible that's a that's a good point
thank you and I'm measuring the speed of
exceptions that you know of errors I I
care about the speed in the normal case
so um here's the interesting part so I
measured this my baseline I measured
this and they did just just as fast so I
was like oh so there's no difference
here but I looked at the generated code
and GCC generate the same goes for both
GCC was way ahead of me he said oh that
guy thinks he's smart so I'll show him
right
so the code generator is literally the
same the compiler detected that what I'm
doing and figured out how to paralyze
things way ahead of me thinking about it
but you know I'm not going to give up
without a fight
so I said how about the table lookup how
about the tail you know each digit looks
up a table of 256 bytes and curve it
goes in a table and table has bits set
and that kind of stuff
so it's a table lookup is digit which
the thing is faster this guy or that guy
thoughts is digit versus an operation so
tables versus computation thoughts ideas
yes hypothesis you think table is slower
who else thinks different or the same
table is slower table or tables Lord
actually it's just the same GCC tries
the same cool for this guy too
I was shocked that GCC was smart enough
to figure out maybe it has memory maybe
to figure out all my experiments is let
me show this guy what an idiot he is and
is that you know in your face so
am i share my compiling different code
yes so J is the same code even though
ostensibly it's a table lookup and a
kind of a function calling to a library
and stuff and GCC apparently knew about
the semantics of his digit and said oh I
know what the city is trying to do so
let me do it the fast way frame but of
course I won't give up and I tried
something more more principled which was
let me use unsigned arithmetic and mud
and modulo subtraction so you know I
want was the following let me convert
the digit to some to an assigned number
32 bit and then subtract the 0 and the
nice thing about unsigned numbers is
they can't be negative so whenever I
have this the subtraction it can be
between 0 &amp;amp; 9 or something larger than 9
and everything is larger than mine
should be wrong right everything in
between is good whatever it would be
negative in signed arithmetic would go
somewhere weird somewhere in the wrong
range right so that was my my reasoning
and I had to prove myself that this is
correct because the fear would be what
if what if by some you know by some
arithmetic property or whatever this
subtraction of that would be negative
and whatever it goes by mistake into the
right range in between 0 &amp;amp; 9 so who can
actually sketch a proof of what is
happening here being correct it's not
quite obvious right so I'm sure like
experienced engineers they kind of look
at it I squint I'd be like oh yeah
that's plausible that make sense that
could work let me test everything
letting me test and see yeah test it it
works so it's not that's not like you
know I'm saying principled approach I'm
not saying like test everything approach
so the principal process is well if I
had a number that you know the negative
number converting to the sort of the
false
positive number the false right number
then I don't have to function to values
in the kind of domain of the minus
operator in our sign numbers mapped to
the same number right that would have
two DS this - you know the good value
and a wrong value both map to the good
value so actually that can't happen
because - is what they call a modular
subtraction and when you do modular
subtraction it has a property which is a
more arithmetic property called
it's by ejected but but you know there's
one of these I'm interested in this
project it means injective and
surjective subjective means it covers
the whole space of the codomain an
injective which is where we're going to
means an injective function an injective
function also known as an injection or a
vaccine colloquially right that was a
joke I didn't really work out right so
yes right exactly an injective function
has exactly the property looking for
which it always Maps these things two
distinct he never met two distinct
inputs to the same output so then we use
the sub mathematical fact to say
actually I don't even care what happens
because I know if I convert the right
inputs you know the right digits in
ascii to the right digits in the range 0
9 whatever wrong digit I have they're
gonna go elsewhere so with one test I'm
done and even better I reuse this
subtraction here I just you know save it
in a in a verb alone I'm using it here
so I I actually saved one subtraction to
write so is this gonna be faster or not
is GCC going to still ruin our day is it
even okay let's say it is different so
Jesus didn't do this or naturally so I
had you know the culture it is different
the question is is it measurably faster
is he going to make an impact on our
business it turns out faster
significantly so the this plot shows ILP
is our ILP version it's not the initial
baseline so baseline is at 1 so this
would be the baseline and we have the
ILP in this nice violet color and we
have IP plot ensign in green so we see
that the advantage of IP plus ensign is
going to get better with the number of
digits why do you think so so why does
the you know what does that why does
this this gap increase with the size of
the number let's look at the code again
just for a second this is the core loop
well folks so the reasoning is I'm
saving a little for each pass through
the loop so the more the loop goes the
more I'm saving so that that would be
the the obvious explanation so we have a
nice trend here Helen sorry
what is the bump yeah what is the bump
around 10 right is that what's the bump
around 10 I'll tell you I have
absolutely no freaking idea I'm not
kidding so actually it's visible here
too in the in in this plot as well where
I kind of replaced with a drawing and
it's just a fact of of computing when
you optimize there's some sometimes
there's artifacts there's absolutely no
explanation can find except if a good
attendee gives them to you
uh-huh so yeah so actually um
thank you so actually we can see it's a
tad slower for very small numbers up to
two digits three two or three four up
like two digits breaks even for one
digit numbers you're right and actually
it's a good point I suppose that that
the loss in efficiency for a small
number it's not gonna be it's not gonna
be huge so I'm gonna keep this the green
version so just for kicks let me add a
couple of more baselines so this here at
one would be a two i sorry a to you well
in the c standard library this is sort
of the absolute baseline you take the
library function and just look at it and
then have our in yellow we have our
handwritten version which we showed in
the beginning and oh we have an awesome
baseline here this is really good to
beat this boost lexical cast
what does why is it so slow
I know Hubert knows what does boost like
see it does the same thing but it does
pretty much what Venkat said it converts
everything to XML and then it and then
back
so treatment quite almost literate is
that what it does because what what does
this brain that function does is it
writes the string to string stream and
then it reads it back as an integer that
code got written and can you believe it
this is amazingly so I want to convert a
number Chinese so let me do the most
general thing I could be anywhere in the
world and Kaali right now right let me
do the most general thing possible which
means I'm going to write this to a
completely general extreme and I'm gonna
read it from that complete general
extreme so I got word that you know
though I give this talk a couple of
times so I think the booze folks did get
the memo and I can they improve that
function is that true so you know I
recall somebody mentioned I didn't
verify it but
somebody mentioned I actually they kind
of they got the memo and they they
improve that function anyhow if you're
not bad if you're marketing you should
use that baseline right and you're gonna
be awesome great so let's do one more
optimization and when I say think
outside the loop an obvious optimization
that's a classic comes to mind which
would be think outside the loop yes
thank you unrolling so let's unroll this
beast and it gets quite quite a bit
bulkier but it's going to be a bit
faster so we're gonna unroll the loop
four ways why four ways and not three
five or eight why do you think four is a
magical it's a good number because we
are computer scientists and we like
small parts of two but that's a simpler
reason I measured everything and
actually the four is the sweet spot this
is like this should be the ultimate
answer to you know what I measure with
three five and eight and whatever and
four would be simply double you know the
better performance there's nothing
really interesting about this function
at this point it got from sort of the
ivory tower of math it got down to the
you know the greasy hands of a working
programmer right so it turns out that is
better but you know you see the point
stands that it still does a bit worse
for a small for small integer
integers why do you think it's not as
fast for small integers with the
unrolling we don't want necessary work
it's all necessary oh yeah you're right
by the way this is not the whole code
you know if you look at I'm really sorry
for though I mean I I hate this room it
should be like the I don't know it's I'm
feeling bad about those people and when
I'm feel bad about these people the
grass is always greener right so this
look goes in step in four steps but it's
incomplete because if you have a number
that's less than three digits you're
gonna have to kind of fall back through
the loop and have some fixed up code
they call that's going to do the last
iterations so actually it's kind of a
bit awkward for really small numbers
because you fall back to the previous
algorithm with
much without much improvement so that's
the reason why why small numbers are not
as good what you can do actually is
combine the algorithms and say if it has
less than three digits do that otherwise
do that at any rate this is kind of
interesting
so checkpoint depends on who you ask
depending on who you ask love for money
makes the world go round
I leave that to your philosophy
professor in algorithms it's math that
make make make them go round so many
people believe optimization is this kind
of weird thing whereby oh he's doing
assembler the machine code he's a badass
no actually it's math you know it's high
school and college level math that's not
even super complicated most of time but
that motivates the transformations that
you can do to reduce data dependencies
and to reduce the strength of operations
used right and that's how it works
exploit instruction level parallelism by
keeping those dailies busy spread work
around to minimize data dependencies the
code I just showed is part of a nice
face book library which is on github
too which I contributed a fair amount
and it has high performance routines for
this kind of stuff so that is not
however strong enough result to be
publishable
which is going to segue into a future
talk of mine which does feature
publishable result with this with this
I'm gonna thank you very much for being
here you've been great awesome thank you
thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>