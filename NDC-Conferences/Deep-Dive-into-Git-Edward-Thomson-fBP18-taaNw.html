<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Deep Dive into Git - Edward Thomson | Coder Coacher - Coaching Coders</title><meta content="Deep Dive into Git - Edward Thomson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Deep Dive into Git - Edward Thomson</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fBP18-taaNw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Doug Thompson today I'm going
to talk a little bit about get the
version control system take a little
deep dive into it if you show hands how
many people are using debt right now
maybe it yeah that's absolutely
everybody ok keep your hand up if you've
been confused by get at some point in
time yeah again absolutely everybody so
let's try to take a little bit of the
edge off if we can again about myself my
name is Edward Thompson I'm a program
manager at Microsoft which means I don't
actually write code anymore I just kind
of stay in Excel Word PowerPoint and of
course outlook at least at my day job I
do also act as the maintainer of the
liggett 2 project you're not familiar
with Liggett 2 it's kind of a
reimplementation
of get as a library so that you can host
it in your own application and it's used
by people like github gitlab and of
course microsoft visual studio team
services to actually twiddle the bits
and the repositories that you host there
and do the low-level kind of stuff so
that's why I have to understand kind of
how git works at a deep down level but
why should you understand my friend Emma
talks a lot about teaching it and
learning it really the very getting
started basics and she tells people that
the worst way to educate people about
git is to start out by talking about how
it's just a directed acyclic graph right
because who on earth knows what that
means not me I actually failed graph
theory in college whoops but you can
still be successful using it even not
having graphic but it is kind of the
next level up to start talking about how
it works on the inside and its internals
because what you really find is that
knowing it helps you use git if you if
you rewind a bit and look at how git
came about if you look at its Genesis it
was invented by a guy named Linus
Torvalds that name sounds familiar to
you I hope it does he invented a thing
called the Linux kernel first and he
invented get to help him manage the
development of the Linux kernel
he was frustrated with the version
control tools he was using and he set
out to do something a little bit
different and we could created get he
set out four goals first of all it has
to be fast second of all it has to
support a distributed workflow there are
people working on Linux kernel from all
over the world third it has to provide
safeguards against accidental data
corruption and if there's ever a doubt
as to the direction that the project
should take you should look at CVS the
concurrent version system the the
corrosion control system the cube was
using as an example of what not to do
there are four things on this list and
one thing is missing noticeably absent
is easy to use and it's not it's so in
fact challenging to use that xkcd has
gone and made fun of it and this is
totally honest like this is an accurate
portrayal of the state of get today
because git is really hard to use it has
some weird commands the check out
command does four different things you
know the first first time it's listed
there checks out a branch the second
time that creates a new branch the third
time it checks out a file in your
current branch and the fourth time it
checks out a different file in a
different branch so really challenging
and if you use it wrong it pokes back at
you right there are some really strange
error messages like you're in a detached
head state who on earth knows what that
means by the end of this session you
will and if you try to figure out how to
use it if you want to go read the man
pages those are hard to understand too
because it contains sentences like
forward port local commits to the
updated upstream head I I sort of got to
read that like three or four times
before I realized they were talking
about rebase the most fun get command of
all so I want to pause real quick I
think honesty between you and I is
really important in the short sixty
minutes we have together and I'm telling
you a lie on this slide one of these
things is actually not in the get man
pages the get man pages are so dense and
hard to understand that somebody has
created a fake get man page generator
which is tons of fun they fed all the
existing man pages into a Markov chain
generator and out pops random things
that sound like get man pages I created
the slide a while ago so I'm actually
not sure which ones which I think it's
the third one reveal all downstream
commits below the sent upstream paths I
think that's the fake one but how on
earth is that any different than the
first I don't I don't remember so you
know go check that out have some fun
it won't confuse you any more than the
actual documentation so it turns out you
know we talked about how good is really
powerful and important and this this
notion that it's really hard to use
doesn't exactly jive with that and it
turns out that the git commands are just
really the cinah stab stracke ssin over
the data model so if you understand the
data model you understand a lot better
about how it actually works so let's
let's actually rewind start at the very
beginning what is the distributed
version control system well distributed
version control systems came about in
particular in the open source world you
know Linus invented it to work on the
Linux kernel and in the open source
world people are spread out all across
the globe working on the projects I mean
that's not always true but often it is
true and the thing about working in a
very distributed team is that you don't
want to have one central server because
where where would you put it you know I
I work with I live in the UK right now
and I work with people in Germany in the
US and Australia you know I mean if we
kind of average that out we'd probably
put our central server somewhere
floating on an island out there in the
Pacific and that's not going to work for
anybody so having a the idea of having
to use a central server is really
problematic in open source and so the
idea of a distributed system kind of
flips that on its head in a classic
centralized server of course you have to
talk to the server to do almost anything
some really like take it to the next
level
and make it so that if you want to just
edit a file that you've already got
locally you've got to run check out and
talk to the server and ask it if you can
edit the file and there are good reasons
for that but not if you are working on
an open source project and with people
all around the globe okay so the idea of
a distributed system brings the entire
repository locally so you have
everything local including all of the
history so that means everything you do
is local even when you come in and it's
not until you actually go and share that
commit the changes that you've made with
your co-workers that you actually hit
the network and this notion this idea
really underlines and defines how it
actually operates and it informs the
entire data model right so the
repository is actually architected in
order to support this type of a workflow
and it's very very different than a
centralized version control system okay
so we often talk about the repository
and now it's it's time to talk about
what it actually looks like this is
where where we go a little bit more
advanced and we do start talking about
the fact that it's a directed acyclic
graph so we can we can actually just
take a look at what history looks like
let's say I'm working on a project with
my coworker Alice and we both clone the
repository we've gotten it from the
server and we've both gotten the three
commits there it's a real simple
repository you know it's something like
hello world I don't know why you need
three commits to do hello world but
let's say I don't know maybe we
internationalized here so we both clone
this repository and we get the three
commits and so that means in this
distributed system if I make a change
and check it in and Alice makes a change
in check again we both are only checking
into our local repositories we don't
actually see each other's changes until
such time as I figure out a way to get
Alice's change from her maybe she opens
a pull request pushes it up to be STS or
github
maybe she sends it to me in a patch-over
email because that's a thing gets
supports because it's
if you're a Linux kernel developer and
it's 1995 but anyway somehow I get her
commit and bring it into my my
repository and then I merge her commit
and mine and I get the result very
straightforward
this is tend to be how we visualize get
working as this sort of graph that kind
of diverges and comes back together and
it turns out that that's exactly how git
history is sort so here we are in our
little repository very straightforward
and if I run git log I can see that in
fact I have brought Alice's change into
mine but when you run git log it's it's
not exactly showing you exactly how git
is storing this information now you're
just seeing like this flat list of
changes without any sort of structure to
them right just commit after commit
after commit so the nice thing about get
is you can run git log - - graph and it
will show you the actual structure that
the repository is taking and so you can
see commit one two three and then it
kind of branches off into a licentious
change and then branches off in a
different direction in the mine and then
it actually comes back together so this
is actually the way history is stored as
this graph structure right so there are
actually a lot of tools that will show
you this besides just get graph actually
you know we got like think about get
cramping running somewhere there's a
really good example of a visual tool
that'll also show you this I I like to
see the graph I like to actually look at
the graph and see how it's changing over
time in most of my projects it's not
actually it's not actually perfect in
every project because depending on like
this sort of branching and merging
structure you use you can get into a bit
of a headache if you look at git itself
they really like their branches so you
can see each of these little lines over
on the left is an actual branch that
eventually gets merged and they go a
little bit crazy so so I like to look at
the graph I like to use git log - -
graph to see the grata to see the way
the structure has changed over time but
it gets a little problematic on a really
really giant repository okay
so again this is the graph or the dag
what does that actually mean what does
it mean to be a quote unquote directed
acyclic graph well there is some
direction to the graph that means it's
it's moving in a certain direction I
like to model it as moving forward in
time again I don't want to lie to you
too much these arrows don't actually
flow this way in the good object model
we'll talk about that in a minute
I sort of got one of the hardest things
when you decided to start writing a
distributed version control system is
figure out how to draw the arrows on the
whiteboard when you're talking about
things I've spent countless hours of my
life in these discussions well so we'll
get there in a second
but there is a direction to the graph
and we often model it as moving forward
in time and it's a cyclic meaning you
can't have a cycle in the graph
meaning that one commits can't point
back to a previous commit so it's moving
forward in time you know commit three
can't have been the parents of commit
one that doesn't make a lot of sense as
far as we know time moves forward so you
can't kind of go back and and change the
directionality of time okay that's all
we'll talk about the fact that it's
directed or a cyclic now we'll just call
it the graph okay I think this is the
last lie there's something wrong with
this slide it's not so easy to go one
two three four or five in a centralized
version control system that's the way
your commit ideas work but that's not
actually the
this works and get the reason being it
can't if I'm working on on my repository
and I've cloned down the repo and I have
three commits and it said commit ID
three and I go and make a change and
check it in and Alice goes and change
goes and makes a change and checks it
into her repository how do we know who
gets commit ID four and who gets commit
ID socks right we'd have to have some
way to talk to the server and get that
commit ID so that's not actually how it
works I think most of you probably seen
this get stores it's commit IDs as a
forty character long hexadecimal string
what that is is actually the sha-1 hash
of the commit it's it's set up that way
you know it could have been like a
random number or a gooood but using a
sha-1 hash actually makes a lot of sense
this is an idea inspired by the monotone
version control system who really set
the groundwork for the way it works in a
lot of ways so we take the commit and
rehash it we run it through sha-1 and
the resulting hash ID becomes the commit
ID and so you get things like and
thankfully we only have to talk about
like the first seven or so characters so
you get commit IDs like one c6 b201 so
it's a little bit of a bummer but you
know you usually only have to talk about
like the first seven characters and on a
big like I don't know TF BCE like
centralized version control system
you'll get changed set IDs into the
seven digits so it's not too much of a
stretch but it is a little bit of an
annoyance right so what does it mean
when I say a we take a hash of the
commit what is what do I mean when I say
of the commit so a commit represents the
entire repository so it's a snapshot of
the entire repository at any state in
time that's not always so obvious
because if you run git log or if you run
get show for instance what it'll show
you on a commit is just the changes it
will show you the dip of how how that
commit change from its apparent
so it's really easy to start thinking
that that's what get is actually storing
just the disk how something has changed
in a new commit it's not it's going a
snap it's storing a snapshot of the
entire repository so when it's computing
that disk it's actually doing the diff
every single time you run get show so to
make that structure to make that
snapshot a commit is made up of trees
and blobs trees are Directory objects
they represent you know file system
entries and blobs represent an actual
file so you have a bunch of blobs one
for each file in your git repository and
they are organized into trees and then a
commit points to the root tree the root
of your git repository it looks
something like this so if I have one
file just file one dot txt it'll be
stored as a blob and it's hash also so
we take the sha-1 hash of the file that
you're checking in and we put that into
a tree this is the root tree and we take
the sha-1 hash of that tree and then a
commit points to that tree okay a lot of
people seem to think that git is
inefficient because it stores a snapshot
of the entire repository at every state
in time but it's not actually this is
where the sha-1 hash as your ID starts
to make a lot of sense so if I have one
file in my repository file one dot txt
we take the hash of that let's say I add
another file and I want to check that in
I want to create a new snapshot it's got
file one dot txt and something else I
don't put another copy of final one dot
text into the repository because when I
hash it the hash is the same hasn't
changed I'm only adding file to text so
I get a lot of space saving benefits I'm
just compressing the repository without
even trying because I don't need to add
another copy of file one dot text when
it hasn't changed so to add a new file
we just put a second entry into our tree
file to text the tree entry it does
change right it's a different tree now
so it's sha when I do changes and then
we create a commit on top of that
so we don't have to duplicate that at
all
I think so I've said you know this is
what a commit is it's a copy of the
content let's actually take a look at
what it's storing on disk again let's
get back to my actual repository so this
is my working directory I've got a bunch
of files in it I've also got this folder
up top get that's where it actually
stores all the metadata that's where my
git repository lives I don't know if
you've taken a bother to go look inside
it's got a bunch of files and folders in
it this is actually the metadata of your
repository and the commits the trees the
blobs the things that make up our
repository we call those objects so
they're in the get objects directory
we'll talk about a couple more of these
files in a little bit and if I look in
not get objects I see a bunch of hex
characters these are where my objects
are stored when I first start creating
objects they're stored in here as loose
objects they're called and it's
basically just one object per file on
disk later git will come along and pack
these up into an archive which allows it
to be a little bit more efficient in the
way it accesses objects but when you
first start creating them they're stored
as loose pack files I'm sorry loose
objects on disk and if I actually just
go and read one of these I'll see my
file oh no I won't actually I'm really
disappointed
turns out they get compresses it but it
does give us a bunch of handy utilities
to actually look and inspect the objects
that live there this I know happens to
be commit so I can run git cap file
commit give it the ID that I'm
interested in and it'll show me so this
this is what I mean when I say we take a
sha-1 of the contents of a commit this
is that commit so a commit contains some
metadata about when I made the change it
was me on this date it gives me the
commit message
and then up top I see the tree so this
is actually pointing to the root tree
the snapshot of my git repository when I
ran this commit and it's also pointing
to a parent so that is how git build its
tree structure how it builds the graph
in memory it starts at one commit and
then it can walk backwards through the
parents okay so that's what I meant when
I said that we get into arguments over
which way the arrow should go get
actually points backwards it points to
the previous commits in time okay and we
can look at these other objects we can
look at the tree if you're on gift at
file tree is what you would expect to
happen like get cat file commit if you
do that you're really bummed out because
it's also in binary turns out that git
stores trees in a binary format in order
to save a little bit of a fit and make
it a little bit more efficient instead I
can run git LS tree and give it the ID
and then I'll actually see what my tree
looks like again I've got file 1 dot txt
and file to dot txt at this revision at
those at those IDs and I can run git cat
file on a blob blob being a file of
course and see the actual contents of
the file at this point in time okay so
all cat file really does is kind of just
uncompress --is the the object or finds
it in the pack file if get has stored it
in the archive and just dumps it to
screen so it's really handy for
inspecting your git repository so that's
how objects are stored that's kind of
the minimum thing you need to be a
version control system is to be able to
take copies of files and store them at a
particular version but it's not so
helpful if that's all your version
control system does you also really need
the ability to make branches because if
I'm working on some like long-running
teacher let's say I'm hacking something
in and it's not quite ready to ship and
my coworker Alice needs to fix a bug we
need to be able to separate our
workflows I need to be able to keep
working on that development
isn't ready to ship so that Alice can
you know get her code into production
fix that critical bug so that's the you
know kind of function that branches
perform branches work a little bit
differently in get than they do in most
centralized version control systems like
subversion or TF PC in those sort of
version control systems you have a
folder and you branch a folder so in TF
b c you'll often see it called main i
think it's been a long time since I've
used it apparently in SEN you tend to
talk about trunk as your main folder
where everything is integrated and next
to trunk if you look in your repository
you'll see other branches you'll see
feature branches you'll see release
branches that's not the way it stores
branches it actually stores branches at
the repository level so you branch the
entire git repository when you create a
new branch and that's actually really
really economical and yet so we've
talked a little bit about the graph
why does get store branches this way
well it turns out that instead of
actually branching folders inside the
repository get tensed or a branch really
really economically just as a pointer
into this graph so if I have my branch
in this repository that we've been
working on what gets actually doing is
just storing a pointer to the commit
that my branch is currently referring to
and the same with Palaces branch so that
it's a pointer into the graph and the
nice thing about this is that since it's
lightweight since it's easy to you know
just make a pointer right you just kind
of write a file on disk we'll see what
that looks like in a second but because
this is so lightweight it encourages you
to branch more in so working at
Microsoft I've worked on TF musi and we
worked in a really big repository the
the TF PC code base is pretty large it's
not huge it's not Windows not office but
it's pretty big and so to create a
branch on our centralized version
control system would take
I don't know an hour so it's like copy
bits around and line everything up and
so you had to do it you know only when
you needed it and you had to get an
administrator to do it because there was
so much overhead yada-yada-yada terrible
system for for the idea of topic
branching right if I just want to fix a
bug I can create a branch to do that you
would never do that in TF PC on a big
repository we just take too long
and get it's super easy because a branch
is really just a pointer what do I mean
when I say that so let's go back into
our git repository into the dot git
folder where all the metadata is stored
and right below the object folder is a
folder called ref and in kit terminology
a ref is a branch or a tag and again and
get terminology it's actually not called
a branch it's called a head so I
apologize for that but if you look
inside you were get refs
heads folder you'll actually see the
branches and so they're actually named
on disk the files on disk are named the
the name of the branch so it's really
super easy to inspect these and I can
look at what's inside the fact that it's
41 characters might give some of you a
hint as to what's in there it's the it's
the sha-1 it's the commit ID that this
branch is currently pointing to and I
can look at mine and I'll see that it's
pointing to a different sha-1 and if we
look in our log and we pass the decorate
flag this time we can see that in fact
at my branch the one on top is 9 9 6 9
whatever which corresponds to the
contents of the file Alice's branch is
one C six six so it stores these
branches just on disk in these files so
it's really easy to manipulate these
it's really easy to create a new branch
all get has to do is write 41 characters
to disk and boom you have new
branch way different than needing an
administrator taking hours to set
something up so it really encourages you
to create more branches even just to fix
a bug I create a branch so it's great
that we have branches but usually you
have the notion of being on a branch I'm
working on some branch when I check in
changes they go into my branch when
Alice checks and changes they go into
hers git uses another type of branch for
this it's called a symbolic reference
and the important one is head in all
uppercase you've ever been in that
dreaded detached head state this is what
it's talking about this is we're
starting to get into that so head stores
the current branch that you're on again
it's also just a pointer but instead of
being a pointer to a commit now it's a
pointer to a branch and I can look at my
head file in all caps in my git
repository and it says refs heads mine
so this is telling me that I'm on the
mind branch right now and if I run git
branch indeed I am right get so get to
tell you what branch you're on just
looks at the head file says refs heads
line it can then figure out which commit
that is by looking at that file the mind
file if I switch branches if I switch
branches say to Alice's all it's going
to do is update that head file okay so
super straightforward to change branches
obviously it'll also check out the
differences between Alice's branch and
my branch that's the time-consuming part
but switching branches is really
straightforward let's go back to mine
so branching is great we need to be able
to branch so that Alice can fix her bug
while I'm working on my feature but
branches are pretty pointless unless you
can actually converge at some point in
time and of course and get that is
merging so in our repository
we if we think look back to before I
actually brought Alice's change into
mine what happens is to to figure out
how to get these changes in first we
have to find the common ancestor and in
a centralized version control system
when you create a branch that
information gets stored in some database
somewhere and when you do emerge that
information gets recorded too and that
and then the centralized system can
figure out how these branches diverged
over time and where your common ancestor
is it's not always easy especially if
you have some advanced emerging
capabilities to figure that out and get
it's super simple you can look at the
graph and see it right I also change
there my change is there let's just walk
backwards until we find the first common
commit the first commit that we both
have in our repository and boom that's
our common ancestor easy once get finds
that then it can figure out how to do
the merge so it looks at the common
ancestor it looks at the files that are
inside of them and then it looks at each
of the branches and it just just goes
straight down a list enumerate them what
file is in my common ancestor had to
change in my branch okay
what about their branch okay so for
files that have changed on one side but
not the other it's super easy to just
take them you just take the changes if
it's file one changed on my branch and
didn't change on their branch will just
take file one into the new repository
into the new merge result same with file
two over here file four changed on their
branch but not online we'll take that
file three haven't changed anywhere it
just stays the same so merge is actually
very straight forward until you merge
this until both both branches change the
same file that's when it gets a little
trickier but at at its root it works the
same way you look at the file and the
common ancestor look at the file on each
side and you just go line by line did
this line change in one branch if so
let's take that line did this file
change in the other branch if so let's
take that line
this works most of the time right this
is really pretty naive because if one
branch changes the way of variables is
declared changes its name but doesn't
touch any of the other you know maybe it
doesn't change the bottom of the file so
it changes the name of a variable in it
it updates that variable every time it's
used but then somebody in another branch
appends a new function at the very
bottom of the file that references the
old variable name obviously Auto merge
can't sort that out for you it'll take
the changes from one branch and it'll
take the new use in the other so you
still need to check your auto merge when
it's done you need to you know run your
unit test and obviously this is just a
best practice in DevOps these days I
probably don't need to tell you this but
for the most part Auto merge despite
being really naive works really well of
course if both people change the same
region of a file you'll get a conflict
I'm sure we've all seen this there are
good merge tools of course I like source
gear diff merge you know find a merge
tool that you like unless you really
like using bi and cleaning up arrows all
the time
and if you do please do yourself a favor
and turn on merge conflict style dip 3
because at least you get to see the
common ancestor then it'll provide you a
little bit more context when you're
suffering in VI trying to figure out how
this this file changed and where these
conflicts came from ok this is this is
actually what I use most of the time is
bi yeah let's old habits die hard I
guess so once that gets computed once
all the files are Auto murder and the
new tree is computed once you've
resolved any conflicts when you run git
commit what git will do is actually
create a commit a new commit with two
parents we saw earlier how how get
encodes the parent in the commit when
you do a merge get records to parents
let's take a look so let's go back in
time to before we had merged Alice's
change into our repository and I can run
get logged
- grass - - one line - - decorates and
we can see that right now I don't have
any of Alice's changes I'm getting
really tired of typing git log - - graph
- - one line it's super useful I've got
it alias get lol log one line it also
comes in handy when you're working in a
source tree that doesn't make any sense
you get to run git lol and give yourself
a little smile every time - like what
happened in this history but if I I can
also add the branches flag to get log -
- one line and I'll see all the branches
that exist and how they relate to
history so I can see right now that
Alice's change is built on commit three
and so is mine but we haven't merged it
yet so let's actually do that merge okay
like I said I really do send a lot of
time in bi so once I've done that I can
run git lol and boom we've got our our
branches diverging and then coming back
together and if I get can't file commits
the new commits will just run youth head
I can see I've got two parents so this
is actually how git builds is this graph
structure right it starts at head and it
starts walking you know finds the tree
finds the commit information rather that
that have refers to and then it opens up
the parents and it just keeps walking
down that list to build the graph so
when I run git log that's actually what
it's doing it opens the head file and
then keeps going down that list that's
the typical merge case you may have seen
something called a fast-forward merge
this happens especially if you if you
only create topic branches off of master
your master stays in sync with your your
server the master on your server when
you run get pulled in that situation
from master you'll see this was a
fast-forward so what does that actually
mean
if we look at gets graphing we can see
that really quickly let's say I'm let's
say Alice's made a change here and I
haven't made a change right I cloned the
git repository I haven't
anything and there's a new commit maybe
on the server when I run get merged in
this scenario by default it'll be a
fast-forward all get does is update the
pointers so again let's go back and so
what we can see now is that if we look
at Alice's branch it's on top my branch
is right below it so we have a linear
history to Alice right we're not on
Alice's branch yet we don't have any
that change she's a kind of ahead of us
if we just look at our history we'll see
that but what we don't see this time
despite using the dash dash graph is any
sort of graphical divergence because
there isn't it's a straight line and so
if I run git merge Alice it tells me
that it takes fast-forward so literally
all get has done here is update my
branch to point to the new commit that
alice is on and head of course hasn't
changed I'm Phil on my branch and if I
run git log I can see that all it's done
is update these pointers so fast forward
merges are super efficient and get all
it has to do is calculated it can do it
and to set the new pointer you can if
you don't want a fast-forward you can
pass no fast-forward option to merge
that's that's the way if you've ever
seen like maybe github or vs yes when
you click commit pull requests it will
turn on that option it will not do a
fast-forward intentionally so that you
can see the information of when the pull
request was committed okay so you can
turn this off but I don't know why you
would it's a great feature
so that's merging that's the probably
the most common way people take two
branches and and join them up there's
also another feature which is the
subject of much much sort of religious
debate if you will and that's rebasing
and a lot of people are frightened about
rebasing it's not at its heart it's not
all that challenging the idea is and
this is where the name comes from you
have some commits my commit and I want
to integrate it into Alice's but instead
of instead of merging it so that I have
a new you know a join in the in deGrasse
where I have two parents I want to just
pluck this this commit off and I want to
base it off of Alice's commit I want to
change how it exists in history
hence the name rebase and at its heart
all we do is we again find a common
ancestor we find the set of changes that
were uniquely introduced in this commit
and we just replay them right on top of
Alice's branch it sounds pretty
straightforward it is pretty
straightforward
the problem comes when you've got a lot
of commits when you've diverged a lot
and you end up with conflicts since
you're replaying every commit back on
top of Alice's branch you end up trying
to solve the same conflicts over and
over again quite often so it's not
perfect but in in theory in the graph
it's really quite straightforward so
let's take a look at what that looks
like if we had rebased Alice's change
instead of merging it
okay so yeah we've got Alice's change
diverging from our change and let's
let's do something a little bit
different here let's actually create a
conflict so we can see exactly what's
going on we can see by running at disk
that Alice's added a new file called
Alice text let's also create a file
called Alice text we don't have one
right now if we look okay so now we've
got a final Alice text indeed we will
have a conflict let's add it through our
repository and rebase so when you when
you actually stop and look at the the
messages that rebase is giving you it
gives some insight into the process
first it says applying my change okay so
what is actually done is in this case
created a patch file of Alice's sorry of
my change and if I if we look in our
rebase folder we can actually see these
patches that get constructed you know I
don't I don't think you should never
ever need to do this but it does
illustrate the way rebase works it
creates a new patch file and then it's
going to apply this patch and commit the
changes so that is the first commit in
the graph in the in the rebase the
second one we introduced our conflicting
Alice text file and that's where it
stopped if we scroll back up it tells us
that we had an ad add conflict so Alice
added the file
Alice text I also added the file Alice
text and so it's just left us in this
indeterminate state if I look I do have
an alt text and I have both of both
sides with the fun arrows and the
conflict markers
at this point I need to edit a love text
I'll take both changes and then I can
get add and get three days continue if
we let's scroll up again we skipped over
the very first line in rebase is output
it says first rewinding head to replay
your work on top of it so what it what
it means there is it's taken our head
file and it's pointed to the the common
ancestor sorry it hasn't it's pointed to
Alice's change and then we're going to
apply each one on top of that and the
way it does that instead of checking out
Alice's branch is by checking out the
actual commit what do I mean by that if
I look at my head file I'm not pointing
to a branch anymore I'm not pointing to
Alice's branch I'm pointing straight to
a commit ID as if head were just a
regular old branch this is what a
detached head is its when you somehow
have gotten into a state where your head
file isn't on a branch anymore
you are detached from a branch you are
in a detached head state so if I were to
just do something crazy like try to get
out of this rebase right I've decided
that these conflicts are terrible I
don't want to deal with them anymore
I should have merged instead I want to
get out of this the right way to do that
is to run git rebase - - abort that'll
just stop everything and it'll it'll get
you back on the branch that you were on
to begin with it'll just undo all of
this this crazy State if I don't do this
if I don't abort my rebase and try to
kind of keep going and try to figure out
a way to live life as if I had never
gotten into this mess I will still be in
a detached head state you can stay in a
detached head state so let's I don't
know let's do something crazy in our git
repository and we're not releasing
anymore we're just blowing away metadata
now right so oh my god if I run git
status it says head detached and I can
I can pretend to keep going and get log
teams to work but ultimately I'm not on
a branch so don't don't go down this
road you can also do this if you check
out a commit by its ID and I know this
is probably the most common way to do it
because check out is a confusing command
there's like four different ways to
invoke it if I just check out sorry let
me type that right then you can also get
into an attach that same it's getting
better about warning you about what's
going on and what this means but
ultimately it's it's still rather easy
to get into this case so don't do this
stay on a branch always check out
branches cool
so that's where we ended up right so
we've talked a lot about the actual dot
get folder and what's inside what your
repository kind of looks like under the
under the hood what we haven't talked
about is the way that you tend to
actually interact with your git
repository on a day to day basis you
don't spend most of your time in a
folder called git you spend most of your
time with your source code in your
working directory and the working
directory itself doesn't have much
interesting going on about it
I mean your source code of course is
interesting but from gits perspective
they're just files there and it manages
them what's interesting to get is a file
called the index that maybe you've heard
of it's also it's got three names like
everything and get has it's confusingly
named it's called the index or the stage
or the cache what do these things
actually mean so from gits perspective
the stage is what's going to be your
next commit if you were to run git
commit at that very moment everything in
the index would become that next commit
and again it doesn't store differences
it doesn't store how your files changed
from commit to commit it stories a
snapshot of the commit and you can run
get disk to figure out how things
changed but it's a snapshot and just
like a commit is a snapshot the staging
area is a snapshot so when you run git
add it puts files into the index when
you run get RN it removes files from the
index and otherwise everything in the
index is what's going to be committed so
I can so remember ls3 that's what told
us what is in our here I'll put this on
top so it's easier to see we use get ls3
to tell us what was in the tree at a
specific time I can pass head to it and
it'll tell me what's in my what's in
head right now what's in my repository
that was checked in at the last commit
and if I run git status you'll see that
I haven't changed anything in my working
directory I can also run git LS files -
- stage and it'll tell me what's in the
staging area what's in my index and
they're identical at this point because
I haven't made any changes my status is
clean so you'll see that all those files
exist in both places and they're at the
same IDs okay so what gets actually
doing is just dissing these two things
to show me status and if I make a change
to a file
I wasn't suitably excited when I wrote
this file let's change that to an
exclamation point and if I run git add
we can look at the staging area and file
free text now has a new ID so when I ran
get ad it's actually computing the ID of
the new file and putting that new ID
into the index and if I run git status
it will actually compare what's in head
to what's in my index and that's how it
determines what I've modified and now
once I run git commit I can run git
sorry LS tree head and it's updated head
now with that new commit so if I want to
see what's changed between my current
version and my previous commit I can run
get this what that's going to do is
inspect the trees find the final three
has a different ID and one and just show
me that difference so git actually does
store in the index a whole snapshot of
the files that will be permitted and
when you run git status it's actually
comparing everything so it compares
what's in the working directory so
what's in the index and those are your
unstaged changes those are the changes
that you've made that you haven't yet
run get add on and if you ran git commit
those
just stay behind right because the index
is what will be the next commit if I
compare my index to my head
those are my stage changes those are the
things that I've run get add and get our
M on those will be the next commit so
get just basically is a big diff engine
it just gives everything against
everything to show you what's going on
and especially when it comes to the
working directory
that sounds really inefficient right
I've got to crawl the entire working
directory comparing it to what's in the
index to tell me what's unstaged that is
where the index gets its other name the
cache so what actually is stored in the
index is metadata about what's in the
working directory and that allows get to
not have to open every single file and
compare it to the index because remember
the index just has the sha-1 of the blob
and so to do a comparison against that
you would have two sha-1 your entire
working directory that sounds terrible
and in fact it is and that's not at all
what it does that's what allows it to
stay fast
we used LS files - - stage before to
show us what's in the index we can show
use LS files - debug and that will
actually show us all of the bits that
are stored inside the index for every
file and you'll see things like C time
and end time you'll see the inode number
you'll see the size of the file
so what get can do is just open your
your working directory and it can
compare the time stamp that it's got in
the index against the time stamp that it
has on disk and if that time stamp
hasn't changed if the size hasn't
changed the inode number hasn't changed
nothing has changed it can just skip it
it will know that you don't have any
unstaged to change there so it can just
keep going doesn't have to actually open
the file or calculate it if I change the
time stamp
and I don't actually change the file so
now file1.txt has a new time to gain
from what it had before now git will
actually have to open up the file hash
it see if it's changed and and actually
do the comparison against the index but
until I do that until I make some change
it can just skip right over it
it's really handy one thing that you
tend to do so when you run git add you
add a file to the index so right now I'm
at 5 t11 and I haven't actually made a
change so if I make a change and add it
one thing that you can do is if I run
git add so it's going to hash this and
gets not going to go bother hashing the
file to get the ID and not also save a
copy right so when you run git commit
it's already prepared all the objects
that it'll store it just writes a new
commit and if I run LS files - stage I
can see that new ID it's o e to f7 for
for the thing is what happens if I run
get add again that file is gone now
right it's not in my working directory
for sure if I run LS files - stage
file1.txt is at a new ID what happened
to zero e to F so it turns out that this
is now garbage in the get lexicon and
eventually get will garbage collect it
but until it does it's still in my it's
still in my object database if only I
had a way to get to it there is I
actually just whip this up the last time
I gave this talk somebody asked well
what happens to those files and I said
well I guess you could figure out a way
to get them
and so finally I came up with a little
script called get recover if you run get
recover it will show you the garbage
that you've recently added to your
repository but it isn't there anymore so
it will find the unreferenced blobs
unreferenced objects and show them to
you and allow you to recover them it's
like if you're old like me you might
remember Norton on a race it's like that
for Dass only for your git repository so
I can run git
recover and it'll show me all the
recently change files that are no longer
in my debt repository and it's written
in date order so I'm guessing that the
one on top is that file that I just
added
I type it's ID write zero e to F 744 oh
right sorry get cat file blob right so
that's the change that I didn't in fact
lose it's still hanging out in my
objects database and I can get recover
it and it will just put it on disk for
me so I can get these files back after I
thought I'd lost them I can also use a
quick interactive mode and it'll just
show me all of the changes that I've
made that I run get add on and that I
don't have currently pointing to by a
commit so you can get your lost blobs
back really easily no I don't want that
one and let's take that one and it'll
it'll just write it to disk so super
straightforward nice way to to be able
to recover things that you've lost so
just run remember to run get add-on
things you know the the mantra is get is
commit often but even more so add often
if you're ever at a point where you have
a snapshot of a change that you want to
save run get add on it it'll go it in
the object database you can come back
and get it later
if you if you need it cool
so remember the git commands are really
just a simple abstraction over the data
storage mechanism so once you understand
how that data storage mechanism works
you can be much more effective using it
all of a sudden when you have to type
head in all caps now you know why it'll
give you a lot of insight into the way
it works I think I've still got five
minutes are there any questions
hand went up quick oh so the question
was how to get add compared to gets -
that is a great question
so what stash actually does so I'm not a
stash user so I'm a screw this all up
we'll see so what gets - actually does
is it takes a copy of the index and
create a commit from it but it doesn't
put it in the graph right it doesn't
create a new branch it actually stowed
it away in a file called stashes so
let's see file one dot txt make a change
get at it I don't have to add everything
to my stashes because I can stash
unstaged changes as well which is kind
of a clever feature so call it a new
file get status okay so now I've got oh
and in fact I had that recovered garbage
from before so I've got a couple of
files that are unstaged I've got one
file at a stage yeah I'm sorry I've got
to read the man page on this one there I
know there's a way to create a stage
with AHA include untracked so I can get
stash save - - include untracked and
what's happened is that git has now
cleaned up my changes so I can use the
stash command if I am ready to if I'm if
I'm working on something I get
interrupted and I need to make some
pickle bug-fix but I don't want to lose
what I was working on one thing you can
do is just run git commit on your branch
that is almost always what I do instead
but you can also run get stash it's just
which one you prefer what it actually
has done here if we go into the gate
directory now we have a git refs stash
not get refs heads that was our our
branches we've got to get refs stash and
so it's made a special commit for us
that has multiple parents even though
it's not emerged it uses the parents to
figure out what was unstaged what was
staged and what the true parent of our
commit would have been so we see things
like that that's our true parent and
then it's made this sort of we call it a
synthetic commit and it's it stay keeps
the actual contents of the index as it
was when Iran gets - and I can even look
at that and I'll see this should be my
stage changes
yep so file1.txt is actually different
it has a different live ID took me a
while to actually find that and so if i
unstack what will happen is it will take
this tree and turn it into my index and
put anything that was in the untracked
files list which is the other tree
that's up there it'll put that back on
disk good stash pop I think yep wow I'm
surprised I got that right to tell you
the truth so yeah so stash is a little
bit different it is kind of a you know
like I said it's not something I
actually use I think the best practice
is just to create commits on branches
and then you can switch back and forth
between those branches but you can't
commit untracked files that's the
advantage
the big advantage I see to stash so I
don't want to keep you all I'm actually
out of time if you do have other
questions
I am super happy to answer them I get a
sick pleasure out of talking about get
it turns out you can find me on Twitter
I'm that's the best way to reach me I'm
at a Thompson I'll also be at the
Microsoft booth right after this you can
you can grab a shiny get sticker or I
get for Windows sticker
even more shiny so yeah grab a sticker
or ask me questions I'll be at the
Microsoft booth so thanks so much I
appreciate you coming out</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>