<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GraphQL - A query language to empower your API consumers - Rob Crowley | Coder Coacher - Coaching Coders</title><meta content="GraphQL - A query language to empower your API consumers - Rob Crowley - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GraphQL - A query language to empower your API consumers - Rob Crowley</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/S677jraR7Hs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi there good afternoon and welcome to
the session on graphed well so my name
is Rob Crowley and I am the technical
product owner or technical lead for
api's and authentication at Bank West
and I work as part of the delivery
enablement team and one thing I really
like about this team is that we build
software for other developers within the
bank so our entire role is how can we
let other developers other delivery
teams build more compelling user
experiences for their particular cases
that's awesome and that's really one of
the lenses which we'll be looking at
today so building graph QL ap is such
that your front-end teams can deliver
better more exciting and richer user
experiences and we've got quite a lot
we've got a cover today so I don't want
you to leave today with just I've seen a
little bit of graph QL in action I
really want you to understand the
category of problems that it will help
you with because then you'll be able to
decide whether this is a tool that will
help me our four particular problems
that you know you might want to look at
it moving forward after we set that
context we're gonna take a look at graph
QL in action and for this year you'll
see a couple of features I think
everyone's kind of like got a click and
say yes I guess it right I think this
makes sense from there we're gonna look
at how you can actually use graph QL
effectively as part of your delivery
pipeline so in other words if you're
actually building it as pairs of a team
what are some of the tips and techniques
that you can get the most out of it but
most of all today like realistically we
have an hour together I will not be able
to make every single one of you in the
room an expert in graph QL in one hour
but if I can inspire you just enough to
leave the conference and learn more
about graph QL that would be absolutely
a fantastic outcome for me so a little
bit of context so the recent shift to
micro services rich web apps that's
really had quite a significant impact on
our ability to build really rich and
compelling API experiences so rather
than just show you a little to-do app or
something that's quite naughty let's
actually look at what
your world you know site could look like
today so I think this is going to be
pretty you know familiar to everyone
this is Amazon and there is obviously a
huge amount of data represented on this
site so if we were to build this how
could we actually decompose this size
into you know a number of modules and we
could slice this from a number of angles
so first of all from a data perspective
if we were to provide that daily into
for insisted a micro-services
architecture it could look a little bit
like this so for instance we could have
some core product details from a product
service we could have some price from
the pricing engine inventory promotions
images could be served from here a
highly distributed image service and so
on and so forth we could have certain
details therefore cross-selling each of
these could have their own data store
could actually then be managed with you
know its own pipeline its own speed of
change but what about from a UI
perspective it looks quite different
again we could have you know product
header information product details but
then even tree that's got data from a
number of different services in it like
the key takeaway here is that there's
not a nice one-to-one mapping between
the UI component and the underlying data
services so the question is how could we
efficiently deliver this data to the
client and what we're going to take for
the next five to ten minutes is a
whistle-stop tour about how we as an
industry has looked to kind of solve
this problem over time so starting off
we could say each one of the components
could do its own orchestration so it
could call down to the various services
that it needs pull down that data
aggregated and put it on the screen on
the face of it that looks pretty
sensible but when you actually consider
over the network what that means you're
gonna have an incredibly chatty series
of calls from each one of these
components potentially over a very slow
Network link particularly if you're
looking at emerging markets like that
could lead to a terribly poor customer
experience so what can we do to improve
that so this particular point in time
you might say cool what we could do
we could put it on API gateway and this
thing could then perform at a general
back-end and we can do certain
aggregation here and deliver you know
more normalized data to the client I
could absolutely be effective too but if
you look at this as part of a delivery
spectrum this then can quite often
become the constraint on delivery it's
generally managed by a particular
back-end team if your front-end teams
want to iterate quickly the two have to
be tied in sync but that's really not
the biggest issue with this is it's we
don't just build web sites anymore
Mobile is everywhere your company might
have an upcoming line of wearable
products each one of these experiences
needs a different set of data if you
just got one back-end
they're just serving this you know flat
resource structure your own ergo send
too much data to the client or too
little data to the client there is
always a trade-off so what can we do to
improve that at this point we then
looked at backends for front ends so
here we have each channel experience
will have its own back-end API and
that's quite cool because this API is
generally deemed to be an extension of
the front end product so you're not
really dealing with normal at well the
or Bulow's resource would you actually
say how could I populate the data
exactly for that particular view model
and again that's that's pretty good
we've improved things we've removed a
fair amount of the constraints that we
had with a single general-purpose
back-end but there's always
complications
what about versioning so again with
websites we've been spoiled to update to
a new version they just redownload the
page that's easy
what about mobile what about you know
wearables where you actually have to
Virginie API what about different
requirements over time so much a version
would of my app just needs a smaller
motor data we add features as we go and
overtime we're sending fare more data
down to the client but if someone's
still running version what why are we
sending all that extra data to them that
they don't need again it's waste
particularly if you're in an emerging
back is where days is expensive you
don't want to be doing that I
and we're having to trade off so what we
really want to do with this scenario if
you had a perfect case we would send
exactly the data that the client needs
irrespective of diversion and
irrespective of the channel and this is
one of the cases that we're going to
explore for graph QL today gradual lets
us said exactly the data and only the
data that each channel experience needs
in one round-trip to the server that's
amazing because if you think in terms of
a restful api you might go i will call
the root level resource it will return a
set of children and then i will actually
go through each one of those child
resources pull down the information it
he'll have a lot of chattiness we will
see irrespective of the data structure
would query to the backend and just to
highlight this as well is we're not
really tied to just fronting you know
HTTP services graph QL does not care
about the backend
it could be directly really for a
relational database could be soap over
web service it's to provide that age
layer at a consistent interface outwards
so when you leave today and if you're
sufficiently interested in graph QL I've
written a quick demo app based on
Facebook's reference implementation of
graph QL server which is written in
JavaScript and the goal of this is to
answer the vast majority of the
questions that you will have a you will
face will you start a gradual how do you
get a server up how the bits tied
together you know so you can explore
that and it actually covers like a
number of reads rights and then some of
the more advanced features which will
see as we continue through this
presentation so the example domain that
we cover in that app is actually quite
simple but it's complex enough to
actually show you know a number of is of
interesting business rules so for this
one that we're probably quite familiar
with me about ists and assets can
release albums albums in turn released
on labels and then we also have this
concept of a user so in this particular
system you will be able to have a user
and they will be
reviews or create reviews on albums and
as we've got soothes through the the
type system later you'll see that each
one of these rules that we can introduce
and then it kind of changes the way that
these interact so let's take a quick
look at graph QL in action I think at
this point you'll kind of see the idea
of okay I see how this thing works it's
sending the data back and forth for the
server so what I've just loaded up here
is called graphical so graphical is you
can think of as the IDE for graph QL so
if you download one of the graphical
server implementations you will
generally get this as part of it and
this lets us compose queries in a pretty
elegant way and also they'd explore some
of the API as we go so let's just start
off there and you know just that like a
first initial our first initial query so
we'll just go grab an artist and you
know get that a not very interesting is
yes because we could do that with
restaurant though it would just look
like slash out of slash ID so let's do
something a little bit more interesting
so okay so we looked at before we said
that you know Asus cared release albums
you know that's cool so that we go
okay would call we say as it's now get
all the albums that they have again
reasonably interesting let's continue we
did say then that you know albums are
released odd labels so now we can pull
down all the information for the label
this is where things get a little bit
interesting because that again what I
could say at this point is actually grab
me all the other albums that were
released on that label as well and that
you can see that these things you could
just grow them as you go forward and you
saw that each was at each time I went to
one of these lists I'm actually getting
a drop-down list of fields it's somehow
that graphical seems to know what our
valid field or property is for this
particular query if I type in something
that's you know not allows for this is
like foo I get an error it says foo
isn't a valid member on this type
so that's pretty cool so this where I'm
actually coding up my queries I will
actually know well what's valid and
what's not valid that's pretty powerful
there's also den on the right hand side
we can see certain documentation for the
API so we can see I can do this set of
queries at the root element so I could
grab labels artists albums user IDs and
also tells you that what the valid
inputs and your outputs for them as well
so it's robably some people at the room
they're just thinking oh okay so you're
over and there's probably some sort of
scheme or a type system involved and
you'll be absolutely right and actually
we'll look at how that's composed next
there's probably some other people in
the room though and you know it's what
are you trying to pull here well he
could actually do this with rest before
and you probably could like we could
build an API and we could then have you
know number of query parameters we might
say okay well just return these
particular fields then we could also do
dynamic includes
and in fact if you look at JSON API it
actually covers a lot of this
functionality already but the key point
with graph QL is it makes it absolutely
trivial to do it if that's what it's
designed about absolutely if you had a
team and you know just to support you
know one particular channel system cool
you could probably make that work this
makes the functionality available for a
vast number of use cases it is
incredibly quick to put a graph QL front
at the top of your legacy API our legacy
back ed suite and then be able to move
quickly forward it's not talking about
weeks and months of development to craft
a REST API and even as my role as
technical product owner for api's of the
bank even trying to get consistency in a
REST API is that build from what
delivery team to another it's actually a
bit of a nightmare there's a huge
governance process the second you look
to scale graph QL enforces a consistent
interface so at this point was got a
sidestep a little bit and I want you to
really understand what was happening
behind the scenes in that quick demo so
graticule itself is comprised of three
main pets so we've already seen the
query language on the right hand side so
this is where I was typing into
graphical you could see that it defines
rules such that that each query has to
open with a curly bracket and close with
a curly bracket it defines what the
valid syntactic structure of a query is
the type system on the left is a user
defined schema or set of types so in our
particular debate it is albums reviews
artists on the right this is part of the
standard on the left in the type system
this will be bespoke to your particular
domain when you combine those two
together then that's what allows us to
process that query and that's done by
the execution engine so generally this
will be the graph QL server and it has
two main jobs
first of all validation so as I said
before you always know whether it's a
valid query or not based on the language
and the domain you can mathematically
prove whether that query will be
successfully executed if validation
passes then we will be into the
execution phase and this is one thing
that I incredibly like about graph QL
particularly when you're trying to scale
it in an organization and this is a
quote from Bertrand Meyer you might
known from design by contract and this
is even in an O language we can
generally have inconsistencies at module
boundaries so interfaces and that's
between two parties imagine how much
worse that is what rest when we don't
have a strong interface is just implicit
typing what's a valid query upfront
what's not you can eliminate a whole
category of issues right upfront and
again there are ways that you can
mitigate this with risk so a big quest
we use consumer different contracts a
loss whereby each consumer of an API
could then express their own set of
requirements for that provider scope and
save all these Ted fields I'm only
interested in these few that works
really well when you're a POS are used
internally when you have a node number
of consumers that does not work well at
all with public apos
it just does not work at all and that's
where the technique falls down so what
does a type look like in graph QL and we
could define them quite succinctly so in
this case I say it's an artist and the
artist has an ID property so in this
case ID is just an opaque identifier
it's got a string that's a name and the
exclamation mark of the right-hand side
basically means non novel a value is
required it's got a number of aliases
denoted this is a list by the square
brackets at the front and at the back
and graph ul supports a number of other
scalar types so it supports boolean x'
floats but you can also define your own
custom scalar type so for instance if
you had a particular type of your system
so for instance you might want to create
one for a daytime if you say I want to
have ISO 8601 forward for my dates you
could absolutely create a date scanner
type or for instance you might have what
to say is this a valid URL so then the
demo app shows you how you can actually
create those scalar types that actually
extend that type system yourself
probably most interesting though we can
actually define a relation to another
type that we defined in this particular
case album so we can say this artist
will have a collection of albums
associated with it and this relation is
actually what lets us traverse down when
we were executing the queries so now
that we have a hierarchy of types how
did we actually get that query executed
on the server so each type and each
field on that type has a function
associated with it so for instance at
the root level we associate this
particular function and in this case
this can be whatever you want it to be
purely you will take in this case what
input parameter which I had as the SSID
and I just execute some arbitrary code
to return that model and then each field
of that you can assign another function
to it so in this case the artists name
will just be retrieved by passing in the
artists which was returned by the route
resolver at the type level and then just
pick out the name
property of it but that again you can
rise it to be as complex or as simple as
you need it to be so let's look through
a query and actually then see how that
would actually be you know conceptually
executed on the server so again this
query is pretty straightforward you just
say four artists with ID of five I'm
gonna get their name I want to get the
list of albums and then off the album's
I want to pull out the title and the
name of the label so the first thing
that would happen is after the queries
been validated it would hit the resolver
at the type level for artists and it
would then in turn retrieve the
heiress's model at that point in time
and then pass that data to the named
resolver and the album's resolver first
off we would just retrieve the primitive
Dame and in this case it might do
another back-end service call to
retrieve the collection of albums at
that point in time the result of each
one of those albums is going to be
passed to the album resolver function
and again it's going to go through the
exact same process it's gonna call the
title field resolver and they go to the
label and in turn traverse down to the
label resolver itself
so what you could really see is that the
structure of the query that we pass Eid
is literally they just passed and each
word of those notes execute a piece of
code at the back end and we just keep
iterating down until we reach the leaf
node of the query that data they get
bundled up and returned and that's why
are the server-side and actually we
could have you know multi ax here as
well this doesn't actually have to be a
straight I could absolutely go from
label back up to artists across to use
it this is all defied by yourself but
the query itself will just be past the
dead for each node and for each edge
which is the relationship between two
nodes you will just execute that
particular function on the back end and
that's what you can actually grow
arbitrarily deep queries on the
left-hand side like in the query to be
executed on the server and this is
really a fundamental difference to what
we have with rest with rest we model
resources and state transitions between
those resources so we define on the
server side how the client is going to
interact or retrieve that day
with gradual we won't we don't do that
with graph QL we focus on creating the
hierarchy of graph of objects on the
server side and then the clients can
express their interest in a subsection
of that graph so we don't actually
mandate here is exactly the call that
you can make we express the capabilities
and then each queries the requirements
that they need or that particular graph
so there's a number of types of
operations that you can do with graph QL
so so far we've been looking at queries
things without side effects you can also
do mutations and mutations there when
you will actually send a command to the
server side effects will happen and you
will return the data back again just
like rest these are conceptual semantics
meanings there is nothing to prevent me
from sending a query that did to a side
effect or mutation that did it just like
the rest I could do a side effect with a
guess it's not best practice but you
absolutely could if you wanted to and in
each one of these types is one request
and one response graph QL also supports
subscriptions and this is something
we'll look at later in the talk but here
it's radically different when I do a
subscription about saying I express an
interest in zero or more occurrences of
something at some time in the future so
I'm not actually expecting the data to
get come back to me straight away but I
may get some data at some point in the
future so as you can see these are
stateless operations but we will have to
introduce some level of state or
persistent connection on the server to
support them and we'll see how that
works later
so the second killer feature of graph QL
over above the type system is
introspection and what this lets us do
is actually issue queries against the
schema itself so I could ask the graph
QL schema how many types do you have
with you what are the names of those
types and in fact if you looked at
graphical that is exactly what it was
doing
to provide that drop-down list of
available fields it was issuing a query
to the server for this particular type
what are the valid fields for it and
that's also how it generates the
documentation tab that was on the rise
as well so obviously type-ahead is one
possible use for that
what about cogeneration so if I already
know what my query is and the structure
that I will get back why could I not
generate a view model directly for that
why couldn't I just you know do all the
translators for that you absolutely can
this gives you a huge amount of power to
do things not at runtime but at build
time and again you can also use that as
a valuable source of documentation maybe
just like you do with swagger today so
over above the efficiency of a single
call to the server and back this is
actually quite beneficial for a client
as well because no longer do you have to
issue multiple calls to back-end
services and then aggregate that data or
the client or if one of those calls fail
have to handle the retry logic all of
that burden is pushed to the server we
will either get the result back or you
won't
if that doesn't def fails just make one
call again so all of that is dead
handled on the server so great for
client developers actually pretty good
for us API our back-end developers as
well because we again don't have to
worry about exactly how we model the
resource though we Express the
capabilities of the graph and then each
of the clients then can query against
that just to be clear like the examples
that I've showed you today all in Java
Script graph QL does not equal Java
Script there are implementations in the
vast majority of the popular programming
languages today and in fact some of
these implementations are actually more
feature-rich than the reference
implementation from Facebook so for
instance in the scalar space they have
sangria which was actually one of the
first backends to support that push
based subscription model as well so I
strongly
encourage you to check that out this
one's a dotnet this one's a Java huge
selection as well so don't think that if
I'm gonna use graph QL I have to move my
whole team over to JavaScript on node
that's not the case
graph QL is not tied to HTTP they're
quite strong in that in the spec the
vast majority of the implementations
will transport it over HTTP but we may
see a shift in that moving forward so
long as the protocol supports exchanging
character data that will be sufficient
for graph QL graph QL is not a great
face for binary data so for instance if
you want to handle file uploads or
follow downloads
graph QL is not for you so that's why I
don't see it as a complete replacement
for REST API is that you might build it
is absolutely fantastic
when you have data to expose to a number
of different clients and those clients
have different data requirements so
don't leave today thinking I will take
all of my REST API so just back them
across they will absolutely continue to
cohabitate in your ecosystem versioning
you can't talk about a POS without
versioning and in fact when we actually
talk about versioning and Roy fielding
was asked you know the father of rests
you know when should you version a
restful api and his point was just like
don't just don't do it and there's
always a trade-off when you do that I'm
a bit more pragmatic I think at certain
points in time you do after after you
you know take that step and there's a
there's a myriad of ways we can do that
with a restful api we can stick a
version number in the URL because stick
it in the header we could do it properly
and do it as a media-type
but again there's always that concern
that when you do it will you be leaving
old clients behind and void Fielding's
sort of viewpoint and this is you should
always look to have a graceful evolution
of your API contract so again just add
fields over time then check the usage
and if they're no longer being used and
remove them and in fact graph QL
supports versioning
by not supporting versioning so again it
forces you to do the exact same thing to
gracefully evolve your API and to
provide some tooling for that so you can
mark the field as being deprecated so
what this will do is when you're doing
an introspection query to generate a
documentation for your site new
consumers will no longer see that field
because you know exactly the fields that
the client is interested in it's
actually really easy to gauge is it safe
to remove this field whereas if they're
just pulling down one restful resource
you don't really know are they using all
the fields of that resource or only a
subset of them so this actually makes
evolving your API
I wouldn't say straightforward it never
is but at least it makes it
deterministic in terms of whether a
field is being used or not and if you
know it's being used then you go and
have those conversations to say this
particular feature will be sunsetted an
exported time you know cupboard board a
key point is graph QL will not make you
a database or like an API expert you
know modeling skills across you know any
sort of like data environment it's still
table stakes so if you are having issues
you know building or like having
governance across the api's that you
build in your organization today graph
you all will not instantly make that
better it will provide you a layer of
the top wave and probably cover a
multitude of sins you've made before I'd
make you know build it the way you
wished you had the first time but if you
just rush into it you will be using the
deprecated feature an awful lot so
absolutely planet if you don't you know
you make up on stock but it would be
remiss of me if I didn't offer you some
sage advice about how do you you know
model your graph QL schema effectively
and a very useful bit of information
that you actually see like a lot of
graphic world talks is thinking graphs
that's very zen isn't it but what does
this actually mean don't create fields
that should be types so effectively from
there if you
create let's just say I wanted to you
know extend you know the artist type you
know and I want to say you know what
producers have they been linked with
don't just create a list like producer
ID with a scalar value rather create
producer as an object and then assign a
name or an ID to it because what that
lets you do is gracefully extend the
producer type as board data becomes
available so what you should always be
thinking of is how can I create separate
nodes for each one of those types I did
the relationship between the two of them
so again we're going to look know as
using graph QL as part of your delivery
pipeline and what are some of the things
that it does really well for you what
are some of the things that you should
be concerned or you know pay special
attention to and the schema is
absolutely fabulous for making
deterministic queries and on the other
side of that it actually helps with API
documentation as well but it's really
developer focused API documentation it
gives you information on what the types
are a quick description of that field
but if you were creating a public API
you need out-of-band information as well
so for instance how do you sign up to
get your API key is there rate limiting
what about security none of that will be
part of the Skiba so if you really
wanted to use this for public API
documentation we need to do something a
little bit more but there's a number of
tools in this space so this is just one
called graph doc or what this lets you
do is take the graphical schema that you
have and combine it with math down
documents to create a florid accessible
documentation so this is incredibly
powerful because you can still get all
of the benefits of the graph dwell
schema but then write your own custom
documentation with it and then combine
the two and then actually have that in
other PDF something that you can just
head to someone or as a you know a
separate website as well and so strongly
consider something like this for the
environment in which you're operating
don't roll your own graph QL client
so there's a number of clients at each
one of the languages that we use and
they will actually help you build the
query on the client side and also really
help you you're managing the various
sort of like aggregation of sub queries
that you might have in the UI as well so
if you're using graph QL you should
absolutely be using a graph QL cloud but
what are the key things that they do for
you is really help you with caching and
we'll see exactly how they do their see
the few slides in the JavaScript space
you've got three main options or at
least two main options and then you know
sort of blow some other ancillary ones
so first of all you could use relay
which is Facebook's implementation as
well then you can have the Apollo graph
QL client and Apollo are huge into space
as well and actually the Apollo client
is the one that I use for the vast
majority of work that I do it's very
simple to get stairs it and it just
allows you to deliver value really
quickly then there's also some lighter
weight words like cachet again if you
look at the reference slide at the end
you'll see where each way you can go to
see where all the available clients fare
air for you know your particular
language if you are going to support
relay and really is the client library
that Facebook uses for data driven
applications decides this really early
on relay is incredibly opinionated about
how you need to structure your graph so
for instance relay mandates that between
each node so that age you actually have
to model it as a connection itself and
that connection then defines that
relationship in more detail so you could
include things on at load you know
paging information how you should be
paged total number of Records
so you really have there is actually the
graph QL spec is about that big the
relay spec is about that big right so if
you're going to do that particularly
again if it's going to be a public
graphical ap I would encourage you to
look s relay because they that's going
to be more flexible for you know your
consumers but if it's for internal use
you know maybe you need it maybe you
don't if you think you will
third relay up front learn what it gives
you a dead you know back that decision
it's got to be nasty to add it on
afterwards though with restful APRs and
this is a large part of my role I really
care about three things I care about
what protocol the teams are gonna use I
care about what media type the teams are
gonna use and again the media type will
define how the different a POS could
actually communicate the structure
because it's operable and the last one
is naming and graph QL is no different
naming will be absolutely key for this
so there's a number of simple rules that
you can come up with so for instance any
boolean field whatever name that results
to a predicate so is can has four
collections maybe you make them plural
nodes like what you would with resources
I'm not writing these up to be
prescriptive absolutely make these make
sense in your own domain boss come up
with guidelines around naming up front
because graph QL really gives you a
second chance to get this right
don't squander it otherwise you will be
using deprecated a lot when you suddenly
figure out that you want to call it
something else and a bit of advice from
from you know sort of like my sort of
years of building a POS is really look
for terms that reflect the terms of your
business so talk to your product owners
talk to your users to see if there's
certain names that come up time and time
again so maybe not going quite to the
sort of depth of like ubiquitous
language with debate over design but
look for names that resonate with the
business there's also a number of really
good resources online for this as well
so schema.org you can go to it they'd
say okay well what are the properties
that you might find on a person so for
instance you might have you call it a
nickname you also call it like also
donors you know what you Dave those
fields if you go to schemer that all
good keeps you at industry standards
which will actually say alternate name
like it just gives you a tool to maybe
get away from some of the by shedding
conversations that you might have within
your team
so naming right it's it's tough you will
spend a lot of time on us if you do we
get rice and casings always the other
one and graph QL really mandates a
different approach to how we handle
persisting state are the client and with
restful api HTTP is absolutely amazing
it gives us such fine grain control with
case control etags for traditional gets
a conditional requests you know very if
we're going to do a base of personalized
details or not and what we could also do
is introduce intermediary caching layers
so restful api by design are very chatty
but we mitigate that chatty this through
intelligent caching so again if we for
instance with cache controller we could
put a shared back to age and put that
geographically close to the clients as
well very powerful graph QL doesn't play
nice with the web and that's you know if
your facebook that's fine you can you
know build you know custom you know
caching layers if you've got like
endless resources with backwards we
don't we really wish that they actually
used HTTP you know more effectively I
really hope that this is something that
will change in the graph QL community
moving forward but right now it treats
it as a dub pipe so if you're looking at
caching you're looking at what can
happen on the server side and in turn
what can happen on the client side any
sort of intermediary keishon layers you
know so very additional squid or any
solutions that you might be using today
they're not going to be super helpful
moving forward so what should you do on
the server side then so like I mentioned
before graph QL is often a thin layer on
top of existing services that you
already have I would absolutely
recommend that you then look at a
caching layer in graph QL as well so
this could be Redis this could be you
know anything from there and the
patterns are really quite simple so for
instance for a guess first of all try to
get it from the case if it's not there
guess it from the underlying data store
add it to the case and return the object
for the case of a mutation in this case
I'm adding an album add the album to
that
then basically retrieve that would be
just added and you don't want to use the
input model because you might actually
have additional properties that were
created like creates de so you know any
other sort of metadata so retrieve it
from the underlying store and then save
it it's a simpler pattern as that graph
QL also often comes with data loader
implementations so if you look at any of
the sort of like starter documentation
for graph QL you will hear data loaders
a lot and what that really does is
provide you per request caching and
batching to the down end processes so
for instance batching would be if I was
retrieving each one of those albums so
for instance if I RS has had three
albums instead of making three separate
calls to the back-end system it could
actually batch them up and said one
request to your delight services for
those three albums so again the vast
majority of documentation which you will
see with this covers data load or in
quite some detail also in the demo app
that I provide you I actually show you
how to actually use data loader at a
couple of different cases the biggest
change for caching happens on the client
side and this is really really the key
points for why you want to use a
graphical client and instead of storing
the hierarchical tree of data that comes
back from the server the graphical
clients themselves actually break each
row of that down and create a normalized
case for it so this is actually a pretty
amazing thing and it's probably too much
detail to put on the slides but again
it's quite covered in the relay spec as
well but what this lets the client do is
make very intelligent caching about this
is a piece of data within a tree
structure that I already have and if
you're issuing a second query you can
then say I already have this I don't
need to go back to the server for us so
even though you're expressing your data
as that query that might be exactly what
said to the server because you could
have client-side caching there as well
so into a PR communication is really the
lifeblood of rest it's actually how the
web works and
hypermedia is actually probably one of
their like the most misunderstood sort
of concepts when we're building rest
api's and if you look at what Roy
fielding here described it as he said it
was the simultaneous presentation of
information and controls such as that
the information becomes the affordance
through which the user receives options
and takes actions is ever get that it
sounds like a bit of a funny topic but
it's actually something there a lot of
us would be familiar with so for
instance HTML has a number of hypermedia
controls in it so for instance it has
the anchor tag so what that say is when
and basically whatever the client passes
that it will know if someone clicks on
that anchor tag it will dereference the
reason was identified by the href tag
cool it's got an image and basically it
will say whatever is whatever resource
is defined by the source tag it will
then pull down that images show us in
space in the screen
let's go forms and forms we'll say I
will take whatever data has been entered
by the user send it to the server
refresh the page a hypermedia
with regards to this particular rest
request in this case the client is
calling the artist a P I is the
underscore links element which is
defined by the Hal media type and what
this lets you do is any client that then
understands how will they know okay I
compare links that I know that I can
actually then dereference that
particular events URL and this will be
the format of the data that comes back
so again it's about delivering data
that's in bandwidth the request and then
the semantics of that data's understood
by both parties other than have it to go
to the documentation figure out what it
is and then come back and this allows us
to switch between a POS really easily so
I can just link between various a POS
have pulled out the data and you'll see
that that will be like incredibly
cupboard patted it's not that easy with
graph QL you can't easily fed erase
between schemas with graph QL so graph
really wants you to have one big schema
up front that covers everything
and that's actually you know might sound
like quite a limp a stop front but what
you should really look to sensei if you
need to access that data
ideally included in your graph if you
can't then unfortunately you will be
back to falling down to documentation to
try to figure it out
so for instance if I call the graph QL
API here I can get back this URL that
just points to events API and the
performers with ID of 8 what's the
structure of that is that gonna be XML
that I get back is that gonna be Jason
it could be anything
we just don't know whereas obviously if
we included that as part of our schema
that the client would be able to know
exactly what was you know on offer in it
so the other thing I think we should
talk about as well is authentication and
authorization and where does that fit in
you know the work that you'll be doing
and in this particular diagram we
actually have both of those in play so
first of all we need person gets to the
gate they will say who are you and I
will present my passport at that point
in time that's the authentication pairs
and at that point in time they'll say
well do you have a valid visa to enter
it the country that's got to be the
authorization pairs office and
authentication should really be handled
as a cross-cutting concern so again you
will not move or no likelihood you will
not move from rest through to graph you
are on everything be covered bias you
will have a bunch of legacy code maybe
some stuff you know sort of like OPC
stuff or you know some rest apos handle
it as a cross-cutting concern so again
that might be you know open I did
connect north just as a security token
service at that JWT could there be there
just propagated through graph QL
authorization on the other hand is
inherently a domain-specific concerned
it is incredibly difficult to handle
that or I would say they are impossible
to handle that as a cross-cutting
concern so where should the
authorization object go you could
obviously stick it into the graph QL
resolver layer and that's probably quite
an easy way to get started but again
what happens then if you need that in
the REST API or in your PC calls as well
keep graph QL agnostic
authorization logic graph QL should be
an incredibly thin layer over existing
services but what would that really look
like then so as a user for instance this
I want to be the only one permitted to
see my personal details so that my right
to privacy is respected seems like a
pretty legit user story so from a model
perspective I always look to get one
source of truth for how you would
retrieve one of those models so
irrespective of what entry point on the
graph there should be one way of
retrieving each type of entity so in
this particular case is I just issue
every call we'll say to get a particular
user we'll go through this method it
takes two arguments it takes an ID and
the viewer and the viewer is the context
of the person making the call and
they'll basically just check to see
whether the viewer Logan equals the
requested or the returned object login
and if the to match you return them if
not just coalesce it to null I don't
throw an unauthorized request here
so again if you're in the client and
you've got a big tree of data
don't invalidate the entire tree for
just one note and that's Jenny the
practices that are adopted with graph QL
so this approach works really well for
first party systems but what about third
party systems we've got delegated access
so it's not only what the permissions
the user has themselves but what
permissions or scopes that have been
assigned to the platform that the user
is making a call from and in this
particular case it is absolutely okay to
do course grade authorization in your
graph QL layer so the authorization
shouldn't be the sort of business type
rules like I just showed you but up from
here what I've done is I've annotated
the type definition so this is just one
looking in JavaScript with this allowed
scopes property so in this particular
case it could look at the JSON web token
which is effectively the access token
for that what the person has
authenticated with and basically check
whether it has this particular scope if
it does it will then allow that call to
be propagated to the downstream
southside apos if not it will terminate
that right up front
coarse-ground authorization absolutely
okay do not put fine-grained
authorization in de Graaff ql there you
can actually annotate you know a number
of different custom properties in your
type definitions so for instance github
use a technique whereby they add
visibility or audiences to their types
so they can actually then do this ones
for internal use of github that this was
a public use as well so always think
that as an extension point you can
actually add your own data to type
definitions so so far we've been pulling
data what if we could push data back to
the client and this is what we hinted
about before with subscriptions so again
a requirement as a user I want to be
able to be notified when my favorite
artists release albums so that I keep up
to date with the music that I love and I
found many of the applications that we
create today need this rich sort of like
interactions of data it's not I'm gonna
pull down some data then nothing happens
you know as the user experience that
we're building though because Richard
richer you really need to think about
how could actually be informed when
something happens on the back end so we
have a number of choices for real-time
api's like traditionally we probably
would have done polling and Poland's
absolutely find if you know the refresh
rate of your data so for instance if we
had product rates interest rates that
refresh once a day sure I'll just make
one call a day described because I know
when they're gonna be refreshed if the
data is more organic or evolving in
nature then polling quickly becomes
problematic do you pull all the time
this could be chatty do you do it too
infrequently you're gonna get lagged in
the user experience what we really want
is something to be pushed to the client
and there's two main options first of
all there was this idea of live queries
so this is where you could say I'm gonna
make a query and if anything with the
underlying resolver there changes I just
want to get a fresh copy of that query
push to the client really really really
hard to implement so what the industry
or what what okay you know community
have got a road is actually
subscriptions which is a vent based so
what we actually do here is extra
and interest in something happening on
the server and then we will whether
happens we will they get that pushed
back to the client and the subscriptions
RFC has already been raised and it's
actually the most recent release of
Facebook's reffered implementations
support subscriptions and the general
idea here is I want to be told when
something happens on the server and at
some point in time when that does push
that data back to me they're read-only
they're defined in the exact same way
you would any other graph QL query and
they're absolutely not a replacement for
queries you will not suddenly stop using
queries that everything's gonna be
subscriptions it's just gonna be when
something of interest happens on the
server you could then register your
interest in this so you'll be using the
two in concert so what does actually
look like so I'm the left hand side we
have what a typical request response
model would look like so obviously we
said this subscriptions are stateful so
you need sort of a two-way
bi-directional communication and this is
where this transport layer on the right
hand side comes along so each of you
graph QL types could that expose a
subscription method which will then be
looked at by the subscription ad lib and
then the clients will then have the
active subscription defined for that
when something of interest happens on
the server side it can then raise an
event the event will be added to that
same channel and then everything going
well that subscription we raised and
pushed to the client so let's walk to a
real example for what that would look
like so in this particular case the
client opens up a call in this case
using WebSockets to the subscriptions
endpoint which i've called forward slash
subscriptions doesn't have to be there's
not a standard there and it basically
then defines this particular structure
or this query so a subscription and I
want to be when an album is added and I
want to get the album title and the
artist name so what's nice about here is
it's not a it's not a fixed structure of
you know the event that gets pushed to
the client the client still defines
exactly the data structure that they
at some point of time the admin user
then adds a particular album we then see
whether that particular user is
interested in that event and whether
that event is actually you know for one
of the areas in which they're interested
in and then it pushes back the data to
the client and this is exactly the
example that I do as parrot of the demo
app as well so you'll be able to look at
the code that actually powers this so in
the last couple of minutes that we have
we'll look at a couple of other
techniques that we have for low-friction
development like how can you move
quicker with graph QL so the first piece
of advice I would give you is always
start with the schema so the schema is
what will give you shared understanding
between the client team building the
wrap and the server team building the
API
once the schema is agreed on both teams
can work in parallel so you're not
waiting for the full API to be available
and at this point in time once both of
these are complete you can then
integrate them into the product at the
end and finally rinse and repeat and
ship but always start with the schema
first and then we'll actually quickly
quickly let you iterate the design
rather than I've built it oh no wait
that's not quite right let's start again
so if the client team though is going to
be working in parallel you're gonna have
to find a way to you know mock the data
or use an API that's based on not the
actual back-end and then this really
awesome tool which I absolutely love
called graph QL Fator and what that lets
you do is actually set up a dynamic
faking or proxy that will then let you
not only completely mock a back-end but
also enrich certain functionality with
it so the first thing graphical faker
does is it takes in a schema and at this
point in time the clients can then issue
a request to the graphic UL faker proxy
containing some of the real data and
just some faked data that we've defied
in graph QL faker
the real portion of that request will be
sent to the back-end server the backend
server will then actually send back what
the real data is we will enrich that
with some fake
data and then that goes back to the
client so you can probably see here is
if you're just quickly iterating your
design you don't actually have to change
the API you could say oh well what about
you know this field does that does that
look rising you want to change some of
the details for that and in fact let's
just take a real quick look at that as
well so what we can do here is using the
extend notion we can actually then add
additional properties to types so in
this particular case I've added a side
property which I've just set as null
string with just of type URL so if we
actually go back here what I can just do
to solar illustrators we can say just
retrieve any old album and I want to
retrieve you know the you know producer
details for that and at this point in
time I'm just gonna say well you know
it's you know I don't know what a
producer is it's not a real field it
doesn't exist in the back ed schema so
what we could then do in is basically go
in and say okay well actually let's just
define what one of those would look like
and on here I can just say okay well I
will create a field that's called
producer and I will make it of type
producer now will we go back to the
client I just get that mock data and
that can be as rich or as simple as you
want it to be but what that lets you do
was really rapidly without having to
change and deploy your API iterate on
your design couple of points to finish
with telemetry is absolutely key for
graph QL you could obviously see that
the cloud could send arbitrary depth
queries to the back end absolutely put
typing details at every point in your
package because performance can be key
and you really want to see what query
came in and what queries on the south
side did you actually execute to the
back-end services as well
so think about this up front if you
don't it could be painful to add in
afterwards or worse you're in production
and something's running slowly that's
not the situation you want to be in and
again build support for a phase release
process so figure out if you're gonna
have one schemer how you can actually do
pilot launches for that so again that
might be through custom properties on
your schema so again saying this is for
internal use this is for public use
that's the technique that get abused but
again you want to find a way that you
can actually put out these features and
pilot them see that they're actually
solving the problem before you get into
that costly deprecated versioning sort
of approach for this so as you can see I
really hope that you've taken that from
an efficiency point of view graph QL can
let you take exactly the data that you
need and send it to each client
experience it can really help you with
documentation it can help you fix some
mistakes that you might have made with
your previous implementations and it's
really incredibly good at solving the
problem of multiple clients that have
very different data requirements so
thank you I really hope that you've
really enjoyed the graph too I'll talk
and I really hope that all your API
consumers become little heroes on the
back of it thank you
okay so we have three minutes for
questions if there's anything from the
floor so the question is what is the
recommendation for pagination for large
data lists so one of the things I didn't
show you which within which can run to
afterwards is that each one of those
connections can actually take a number
of inputs so for instance here we have
albums list and I could actually pass in
you know some details here so this
particular case I say that I just want
you know the first two but I absolutely
could and likewise I could do things
like you know order by these are just
things that I've defined myself this
absolutely there you could pass in a
number of arrogance which would say
first fifty you know second fifty so
with a graphical API would generally
actually recommend that you do cursor
based pagination so you will actually
just pass back a opaque cursor
identifier which will they're actually
abstract away the pagination mechanism
you know under the hood good question I
think we've time for one more sorry yeah
was there a question there okay
well so I guess the question is our
mutations you know sort of like a dirty
concept in in graph QL I guess the
primary use case for was always about a
query language is actually retrieving
data and if you look at mutations
they're effectively exactly like you
know an or PC state where take this
particular set of data and apply it on
the server you could argue it's a bit of
a bolt-on but i personally see nothing
wrong with OPC i like rest
I like graph QL I think they're all
perfectly good techniques for you know
the use case ahead
the alternative thing would be that you
try to model you know updates you know
in a different way what are the key
things though that I really like about
rest is when you have a workflow or a
lot of the business process so you can
actually reify that as a resource so for
instance you might create you know a
pricing request which might go through
multiple phases so it might start with
an open state and they go to approves
they go to closed and at each one of
those transitions you could then apply
certain business rules to say well what
could you do next that's something that
you won't get from from graph you will I
think that's all we have time for if
anybody else wants to come up have a
chat afterwards that will be good cheers
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>