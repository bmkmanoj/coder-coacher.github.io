<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>MicroMonolith - Top anti-patterns of distributed systems - Michal Franc | Coder Coacher - Coaching Coders</title><meta content="MicroMonolith - Top anti-patterns of distributed systems - Michal Franc - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>MicroMonolith - Top anti-patterns of distributed systems - Michal Franc</b></h2><h5 class="post__date">2016-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1xU-983EwfU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I don't know okay so it's 1140 so let's
start so I want to bring you on our
journey from monolithic based
applications to something distributed to
micro services based application and my
name is Michal I'm a lead developer at
company called safe giving I was born in
Poland then I moved to London two and a
half years ago and you can find my
Twitter handle it's here and you can
check my blog too if you want to so you
can you can ask this question like
micro-services again don't be bored
about this topic yes this topic will
this presentation will be about
microservices but in a bit different way
because micro services are right now on
the race and a lot more people right now
are looking in for them and you can see
this Google Trends chart that people are
really looking for it and people are
looking for it so people are looking for
them but we are the developers we kind
of mostly I think concentrate on the
positive sides of going with distributed
systems going mic reserves and things
like that and this dog would be mostly
about about antipatterns and what we
have found in what kind of mistakes we
have did in the process from going from
monolithic non distributed system to
distribute at one so this is my team and
you can see from the happy faces that my
company is probably awesome
we haven't forced them to really smile
and those are the people responsible for
our product and we are a text for good
company based in London
we are social giving platform we have
millions of users we have helped to
raise more than four billion dollars so
far and we have helped fund thousands of
causes around the world so we are
helping people to raise money for things
like you know disasters like there was
disaster someone and people would like
to help or someone is really sick and he
needs help so people are raising money
for him should be a platform like that
we are helping people to do that and the
reason I mentioned that because we have
kind of like a big numbers and there are
a lot of people using our platform so
they move from non distributed system to
the distributed one won't be that easy
which is which such a big scale and all
of this was powered by
this like monolith and one single
database and in numbers we had one
visual studio solution with 120 plus
projects there were multiple products in
there we had one big database which has
a lot of data our deploy time took us 60
minutes or more and our release time was
like two three weeks platform is so big
that we had to spend one week to
basically make the system stable and
find it and make sure that it works
still fine and then we decided to do
transformation and we decided to do
transformation because we kind of fell
that we are reaching the limit of our
monolith
after eight years of having this models
in there we kind of thought that okay
maybe it's a good time to do something
else try something new hoping that maybe
by going to distributed world with
microservices approach we will gain more
agility so this this move was a bit also
based on hype but still in the end it
was really good idea and it's paid off
for us in our environment in our product
so we didn't we did it in a way that we
took the monolith and slowly piece by
piece try to get it down to smaller
pieces and move them to micro services
so you can see like monolith is getting
smaller but micro services estate is
getting bigger and bigger in the end we
still do have some part of monolith
which are kind of like critical that we
haven't yet moved but you are slowly
getting there and we have a lot of micro
services in there and this Perl process
took us to yes and it's still going so
it's not like finished it's not yet
finished and right now it looks like
this so we have micro services all of
them consumers like web applications
mobile application api that are
consuming the micro services databases
providing the data and all the different
layers supporting this architecture and
everything there is like layers like
cloud messaging monitoring logging and
things like that in numbers we have
hundreds of micro services right now our
deploy time was called significance with
five to ten minutes but that's kind of
obvious because micro service is
supposed to be small so deployment time
of micro service should be smaller and
we kind of embraced peligro
persistence trying to use different
types of database
it kind of felt in a way but I'm gonna
talk about later and also we instead of
having two to three quick releases we
try to have right now daily releases and
so far to this day we probably have date
like 400 plus releases so far so instead
of doing two three week release right
now we can do release daily and this
also has kind of like free to other
developers make them free because right
now I'm not afraid to push stuff to
production because I can just really
stuff as soon as possible and even if
something breaks and it's affecting
users I can just push hotfix
very very quickly so maybe you heard
about the stand when you were when you
were looking for it when you're looking
into the microservices world there is a
concept called monitors first and if you
go to mark and father's blog he is
mentioning pretty nicely why probably
monitors first it's a good idea and we
have a product our company was a classic
example of monitors fast
so we have our monolith 80s of gaining
the just finding our problem space
finding our what we want to achieve and
then we took this model is the first
thing and move it to my two services so
what what we can share today what can I
share today with you of course I can
mention antipatterns and I only mention
the most important ones I could do this
talk for four to five hours but sadly I
had to fit everything into one hour so I
will only talk about my criminal is
syncing this integration problem to one
DB to rule them all and top the best one
the under estimating the costs of this
move so let's start with microphone
arrays so like I mentioned before we
have this monolith and this database and
we decided to move it on and ideally I
would love to do a monolith in that way
like a perfect hexagonal architecture
with our application domain inside all
the different adapters making short
moved all the different adapters
providing functionalities and internal
external integrations right but in
reality we know how it look like and it
mostly leads to something we call big
pile of mud now I don't like this name
because even if this is kind of nasty
and it looks bad it's still kind of
functional right because it still
provides business to volume it still
works and it still pays our paychecks
and everything so we can't make it reach
it's really not that that it has to be
functional it's also a bit beautiful
because you have to be an artist really
to work with a system like that and just
not to be too positive I'm gonna add
mass so that you won't you guys one girl
I weight one girl for this talk and tell
everyone that Michael is telling
everyone that big word of mouth is
really functional and beautiful so let's
just add mass in there and how it
happens that this big bowl of nuts is
there any filters place and I even think
that most of the products will let go in
that way it's because the IT industry is
complex projects are complicated and we
do develop an exploration in the same
time so we don't have a perfect
blueprint or perfect I mean a
specification of our system that will
fit into the market which will help the
customers and will be perfect from from
the beginning while developing product
we still are exploring our domain our
problem space and what we want to do so
this might lead to suboptimal decisions
and sub sub optimal choices and of
course there are also changes the market
can change the product can change the
specification can change people can
change you know everything can basically
change and there's also market pressure
like pressure from the market which is
something I I was not like liking when I
was younger because I like younger
developer as a junior developer I was
looking as a tech as a sacred tech is
always right and tech is always good but
then with more experience I have found
out that tech and our products are built
to provide value so business is also
important and I believe in something
like coal I can when business and tech
they are fighting together if there if
there is a perfect balance of business
and tech having the same political power
we will do something called good enough
software that will fix our tech needs
and our business needs too but suddenly
sometimes it happens that technical side
has less political power and business
side has more political power and this
leads to business basically handing
developers and tell them mm what to do
right and this leads to sometimes not
perfect solutions not perfect projects
on the other hand if technical side has
too many power and business side doesn't
have much more power the developers will
create over architecture madness
I've seen it everywhere if developers
have too many political power and too
many influence they will create over
architectured software little break so
our first iteration when we moved the
monolith into micro-services distributed
world look like this and you can see
that it kind of hasn't changed it looks
like it's very it looks very similar and
instead of having ball of big ball of
mud right now we have distributed bell
of mat so we had already uh problems and
not perfect solution in the first place
but now we also add another problem
which is which is distributed our
problems and that's that's how I call it
like micro monitor because it makes us
do two words together and micro model it
was like a natural step because as
developers when we develop this product
for eight years this our model is for
eight years we have kind of acquired
prior knowledge and habits on how to do
products so I wasn't really surprised
that we have gone that route that we
have kind of recreated the same thing we
created at the beginning and just slowly
explored the distributed world so I I
wasn't expecting like a perfect product
from from the beginning Hey just like
with Conway love when you have when
structure of a team doesn't change the
code will always stay the same so the
cold is driven by the organs action
organizational structure so if you want
to create a distributed system you not
only have to embrace the technical side
you have to look into the organizational
side of the things so distributed
systems they require distributed teams
too and changes are difficult changes in
organization and culture and how we work
in our habits and our experience this is
difficult because the way the brains
work they just create those connections
inside and if you do this if you create
this connection it's really difficult to
just reroute the brain like rewrite the
brain so the only way to do this is to
experiment and try new things and even
fail and micro monolith was like a a
step a step a learning process for us so
we have did it we have kind of failed
and we took the lesson we found out
what's wrong with in there and we just
applied a new experience new knowledge
to create maybe something better and
it's really important to fail fast but
learn because failing is pretty simply
just failed but learning out of it it's
much more difficult the other pattern
that we have found which is tied into
micro model if it's not and now a
previous experience is finger in this
integration so as a web developers we
kind of and then working on this
distributed world we kind of look at the
system from you know non distributed
wealth so we kind of have created
software that was working in one process
so we haven't really worried about non
distributed system e we didn't have any
knowledge about it so as a web
developers because we like HTTP unrest
we kind of integrated all of our micro
services in that simple way they were
just calling each other and being
dependent on each other and because
we've been using HTTP it created
synchronous integration problem and this
is kind of problematic because if one
micro service goes down all the
dependent micro services will also go
down and it's not only tied into the
micro service but also the HTTP protocol
the transport protocol connection
everything can be problematic and
because we had no experience with
distributed systems we kind of
underestimated the network layer which
is a nasty beast because it adds
problems like latency complexity
debugging problems because it's not that
easy to debug distributed system like
non distributed system when you can just
step into the debugger you know step
into the process with distributed system
you have to have token that is shared
between messages and then based on this
token you can find out what happens with
this message message passing going on
through and passing through different
micro services and there is also
security problem and of course
connectivity issue that I showed you
before so we kind of like thought that
kind of like forget about the network
and you can't beat the network you have
to embrace it
and network can be really nasty and you
have to assume that there will be
problems and you have to prepare your
system to be able to cope and fight with
those problems so one way to do this is
to introduce a synchronous integration
between your services and that way when
one service goes down the other services
can kind of functional
not been affected and then you create
something called occasionally connected
app so occasionally connected Micra
services so that they don't have to be
connected all the time they can go
offline they can lose connection to
itself but they can still work fine so
if HTTP is synchronous how can you make
HTTP a synchronous well you have to add
a middleman between the protocol between
to do calls and one of the middleman
that you can use is message bus so
instead of tying the micro-services to
each other you can just tie micro
service system message bus and then
micro service can push messages to the
2d bus and it doesn't care it doesn't
it's not worried about who is listening
there and it's very simple for push if I
change some state if I want to notify
someone I just push a message and that's
fine but what about pool like what what
about scenario when like blue service is
dependent on the green service data
what happens if green service goes down
where will the blue service get the data
from so that's where you have to go into
distributed data to which means like in
this case when you have services and red
service depending on the other two if
one of them goes down the red one can
cannot operate because it needs the data
from degree gray database so what you
can do well you have to distribute the
data you have to introduce another
database in your red service and kind of
keep at the normalized state of your
other services in this data in this
micro service so when what when the
other service goes down this database
can still function because it's kind of
like synchronizing the data with the
other two it's keeping the same state on
not the same set it doesn't have to keep
the same copy but it can kind of
normalize the data it needs and just
keep the data it wants right so that's
how you can create a connection and
still maintain connection if services
require the other service to function
the only problem is the other problem is
synchronous communication that we have
found is also related to mobile apps and
web apps so the old approach that we
have used in our apps was based on
having a monolithic app and if something
went down the app hole application went
down so going to distributed world we
kind of also embraced
distributed apps
of having one big monolithic app we kind
of played the app in two different
sections and then if section that is
dependent on for micro services goes
down like this micro service goes down
we can hide this section from the user
so user doesn't have to be even aware
that there was a problem like like an
example my product has some commenting
system inside if a commenting micro
service goes down I can just hide the
comment box I can I can just hide it
from the user using won't be even aware
that there was a problem you can also
apply it in a different way and you can
completely disable the feature like you
can still show the comment box with old
data with the data that you cached and
are keeping some stale data somewhere
but still you will disable like
interactions from the user point of view
like user can't update user can't delete
comments but at least he can see the
state the old state the old comments and
this distributed apps thing also
provides better scalability because you
can scale different parts differently
like if you have some critical part you
can add more instances in like AWS or
Asia or you will even increase your
reliability because if one part of the
sum of the micro services goes down you
can also still have microservices
supporting the other parts fine so
bringing it bringing it together I got
those synchronous problems this is a
brief history of one app that we have
made so we have started with mobile
space weather and it was based on
angular later on we moved to react and
because it was client-side JavaScript we
had to have some public API and this
public API was just a gateway to micro
services and those micro services by
keeping stake in among big database so
this is a first step of what we did with
one of the product and you can see here
there would be a problem because if the
database goes down whole product goes
down so we had to distribute the data
and move the data closer to the micro
services so right now micro services
they do own the data so if one of them
goes down at least two sub micro
services can still support some parts of
the product you can even go further away
with that and add a caching layer into
your public API so with this approach
with this approach
if the if this goes down you're still
keeping some state you're still keeping
some data in there and in my case in my
product we do display a static page
which doesn't have any interactions so
you say if go if he goes to the page he
will at least see something he won't be
able to interact with the page like add
comments or do something about it but
still he will be able to have a static
page visible we even went further and in
a critical our critical system the most
important part of the business is
donations so making sure that people can
donate money to the causes they want to
support so even if our whole
architecture goes down we removed our
donation system to separate system
completely that was maintained by
different team that in that team
supported a higher reliability higher
scalability so even if everything went
down on our product we could still
redirect the user to make interaction
and external product then we also had to
add some external dependency and just to
make things simple at the beginning we
have kind of integrated those
dependencies to existing micro services
but this created a problem like those
micro services right now are doing too
many things at once so we had to
introduce another layer of micro
services just trying to be like a
liaison or a gateway to do different
external systems and later on other
teams have joined in and kind of used
our micro services so we have kind of
half right now sheds micro services
around around the team but to make the
system even more reliable you can see
here clearly that this will be a
synchronous integration we also added
message bus in between them so now if
this part of the systems goes down the
mic our micro services supporting my
product they can still push some stuff
some messages somebody notification into
the message bus so that when the system
is back the system can just like
replying the messages or just state the
messages and do its own thing and later
on we also had other integrations to
analytics system and in here we added
even stream using even stores now even
store adoption in our company was kind
of funny because we kind of we kind of
understood the even sourcing concept we
knew that you can't treat even stream
like a normal message bath or something
like that this is basically a database
but
still developers and I also did the same
mistake we kind of use this even stream
and treated it as a message bus don't do
this
and if Greg Young is listening yeah Greg
we did it so be pragmatic so we have to
approach your application really from it
like simple start from the from the
state for the simplest possible solution
and you have to find out which part of
your system are really scalable needs
the most Cal ability and needs the most
reliable the variability the other thing
we have also noticed that is related to
the monoliths and our old ways of doing
things is approach of one DB to rule
them all
so in our old monolithic system we had
the database which was monolithic
database and malefic database has some
special characteristics like it has
business logic so after eight years of
having a monolith we have kind of builds
a business logic inside and I think it
is natural we try to forget about it we
try to avoid it but still it happens
because business needs reports business
means some logic implemented you you are
starting as a developers then you add
business and business intelligence team
or team like that and they will do stuff
on your database they recreate complex
business transactions and things like
that so our first approach to still
maintain it and still be able to cope
with those requirements existing
requirements we have kind of created
system like that from all the micro
services that were dependent on one data
and this is kind of problematic because
it was a natural step it felt right at
the beginning but then it was a single
point of failure if a database went down
we had a problem it also creates a
problem with data storage style bias
because if you are tied into one
database you will like think about your
problems from like we have a secure
relational database so all a problems
for us to look like relational and
particular best and of course your
services also tightly coupled and the
most important problem is that you have
known distributed data model which is
kind of problematic because as
developers we do sometimes or even most
of the times follow this anti-pattern
calls that data model is affecting our
code yeah this is antepartum you
shouldn't be doing the
but still it feels like most of the
teams they just go in that into that
world and if you want your fit your team
is to have distributed card you have to
distribute your data so in order to
enhance and influence your team you have
to distribute your data because
otherwise they might again following the
same problem so if one databases are
problematic and complex and it's not
perfect maybe we should do a database to
service well it looks Beautif a per but
it also creates a different set of
problems like data aggregation having
one database with different tables data
aggregation is very simple you just do a
join in a taking in database and that's
fine doing a joint across different
databases thread around and maybe even
having different systems like no secure
system of things like that it's getting
really really complicated supporting
business transactions distributed
transactions is a complicated thing and
this is one of the biggest problems of
IT and also increased maintenance this
is kind of very problematic because
keeping one database afloat and stable
is much more simple than having like
multiple tens of databases and making
sure they are fine and they do work and
they are stable and they are operational
so we also started simple instead of
going to four to full-blown database per
service distributed data we kind of
started with simple like we kind of did
baby steps so still have one database
but we instead of tying into our own
existing data model we created table per
service so this is like a first step to
distribute the data you can even go
further if you need to support more
complicated data model you can add
schema per service which is also very
useful but you have to be careful
because monolithic database after ATS it
creates certain habits that are very
painful and it's really difficult to
change people and they behaviors
especially different teams not maybe
even tired to developer teams like I I
had a problem we had a problem once that
we have my team had owned the table and
we had the service that was basically
owned in this table and we have CRM team
that is doing marketing actions and they
need the data they needed the data from
our product to send some emails to our
customers
so in the old world when they had one
database they just checked the database
in here oh yeah there's a table I will
just use it right so they kind of tied
into this table like that and now the
problem is they are couples with this
database without even telling us and
they kind of are coupled by using the
database system which is problematic
because if I want to change the data
right now or the data model of or I want
to move the table to maybe different
database or I won't want to move the
table to the database per service
approach it will break their thing and
we had this problem we have changed our
database they basically all the mechanic
actions have went out and they were kind
of not happy about it the best approach
is to they should ask you about how can
I access your data and then you can
expose this data through some API so
instead of tying ourselves into the
table and the database you are exposing
the API but it's really difficult to
change people behavior and like
influence them so they will be they will
ask your questions like don't because
they used to this old approach they were
so used to using the one database data
is that I can just use it
no they kind of didn't felt that they
need to do this they don't need to ask
the team about how to access the data so
after this after you slowly like started
with table per service or schema per
service you can slowly start introducing
things like database per service or even
a bit of compromise like having a
database per product which is like a
compromise you still have one database
that will affect your product but at
least you have more control of it and
maybe you can move some business
transactions or some data aggregation
also complex reports out of this big
monolithic database and it's also
important that you have to instead of
relying on joints inside tables you have
to start doing application joints so
what what application joins how it looks
like it's basically just one micro
service aggregating the data from other
services yes and the last pattern we
have found is under estimating the cost
so in the old monolith world we had been
renting our service and this was based
on our prior experience so we had the
eight years of a quiet experience on how
to work with rented service and we had
it under in control
so the cost of a time chart look kind of
simple
it was linear and we could really always
we always knew where we are heading and
what will be the cost what how much
we'll have to pay for it so and after
embracing the distributed no new world
that we weren't really aware of and kind
of we had no experience with I mean we
went to cloud to AWS we kind of had a
spike of our cost increasing and then
people don't worry it like what the hell
is happening how we are going to handle
it how are you gonna support it later on
it's not scalable because with more
users and with more users going into the
platform the cost will to increase and
increase and increase so this was the
time when we had to we had to introduce
spending control and spending control in
the old world was fine because we had
operations team that based on their
knowledge and they experienced they had
been doing this by themself but going
distributed and exposing the cloud to
developers we kind of showed the
developers AWS and they started doing
also two things they're like creating
instances instances out of nowhere
so we were burning money and now we had
to move the spending control out of
operational team and move it also and
and spread it out to the whole team so
we introduced things like planning
downtime which is like having three
different environments at production
staging death we we still keep
production safe and final operational
for whole day but if developers are
sleeping we don't need that in staging
and it's simple it's it won't create a
lot of savings but still it sends a
clear signal to the team and people
around the team that we are treating
this seriously right now and we are
doing things about it we want to do care
about spending and cost control right
now we also look into docker which is
nice concept but we are just starting up
and instead of having one instance
holding the micro services right like we
do right now so every micro service has
four to three instances right now we
want to go and have one instance with
container that could hold different
micro services now it won't be probably
suitable for production because still in
production we want to have ability to
scale everything fast and nicely but for
death and staging I think it will be
perfect but the biggest thing is we have
we are introducing right now and we have
introduced so far is that we had to
introduce cost monitoring and we because
AWS mi Amazon doesn't have a any tool to
really show you how much things cost we
have to build our own tool so we just
build the stone that shows us the
increased costs of the of the over the
week time or the hall increase so this
is a charge before we after we have
started monitoring the costs we don't
see this big spike at the beginning but
you can see that it's kind of like
linearly increasing slowly over time and
you can have more more reports like
check which services are the most
expensive and things like that and also
we have a report that shows us what was
the increase by week and weekly basis
and which services are increasing the
most and which services we need to look
at and this cost monitoring tool was
really important for us because we
wanted to to make the cost control part
of our development culture part of our
deployment pipeline and it's really
important because if you give developers
tools they will start using those tools
then you have to teach developers how
they should use those tools properly so
introducing cost control into
development pipeline means that you have
meetings and you have some you are
basically checking how much does it cost
you're not only checking what's your
what's the performance of your
application
you're also checking how each service
costs how much does it cost you can even
create like hackathons and have teams
competing with each other trying to cut
the curves most I know that you can gain
the system and make a micro service that
is very expensive and then it's very
easy to just tap the coast but yeah you
get the idea
so after introducing those things we
have kind of slowly get back and our
course have discrete you decreased a bit
and then they stabilized and if you
compare it to the old cost chart it's
still bigger and the increase over time
will be bigger because with scale it
will get bigger because you can see that
the the line is different but still with
increased up course we have kind of
decreased developer development time
costs we have gained more agility and we
have right now faster time-to-market
with the non distributed with the
distributed world because
we can deploy really fast and we have
daily releases so still in the end this
was very helpful for us what's the time
right fine
so in a summary the road from monolithic
application to distributed application
should be simple but it's not really
that simple it's complicated
and you will on this route you will
probably have we will be direct by
sometimes and you you will fall into the
traps like we have like - these - these
traps like Mike Romano is one database
synchronous integration and different
all changes and things like that
and when you do this you it was a
learning process and when you you also
do this probably in your companies
because crowd is not going away we will
have to embrace distributed world when
you do this you will also have to go
with with samples from maybe different
route and probably you won't fall in the
same problems like we have fold into
hopefully thanks to this presentation
but you will probably find different
routes and different ways how to do this
your route will be different completely
different and it's important to share
this knowledge so that we will be able
to find the perfect route so it's like
deal with the book of wrong angle for
the design patterns they basically
gathered the community knowledge in one
book and showed everyone how to do
partners and design partners so right
now we are slowly embracing the
distributed world and distributed world
becomes mainstream just like docker in
containers containerization have been so
distributed world was already there with
service-oriented architecture but not
many companies was doing it because it
was complicated and with micro services
I think it's getting into the mass
public and more and more developers to
do this so it's really important to
share the knowledge and gather the all
the patterns that are useful and to help
everyone to be able to move faster from
monolithic to distributed application
and the question
yeah yeah
yep
well that's a good question so the
question is if the BI team that we have
in our company is so accustomed to the
old ways of things and they want to look
into the the old way and they would like
to get access to the database how can we
make them happy so they can access this
our database this my specific database
right so I think there is no easy answer
to it and ideally they they should also
be you should you should convince them
that this is the new thing this is the
new world and you have to trust us so we
will expose the data that you really
need and you have to tie in through
ourselves because tying yourself into
the database we create more problems so
they have to understand it but so it's
not only you don't only you you can't
only change the culture across the
development team you have to change the
culture of distributed world across the
whole organization or whole team so I
don't know you just answer your question
but there is no easy way to do this yeah
yeah so so even stream and even salting
is that like a database kind of concept
when you have even changing the stage by
stage right and you can then replay the
events and you can get the snaps of the
database and this is how you should use
it is you should use it as a database
with some events that are applying stage
changes so we use it as a message bus
and we just basically stored messages
like notification message which haven't
been even changing the state and this is
not not a good idea because those kinds
of messages you would like to replay and
replying events in an even store and
even source in concept is not possible
it's okay it's it is possible but it's
like it doesn't feel feel feel it feel
good it doesn't feel right so you think
even so for message bar is a really
really good it's a really really bad
yeah so that answer your question okay
yeah yes
so there is a question about application
application joint making performance
problems yeah there will be performance
problems but with multiple
micro-services there is a chance that
you will be able to scale your
microservice as much and you can
distribute the work kind of nicely right
so if you even have to do like a complex
joint you can kind of distribute it
distributed it it's more much more
complicated it's not that easy like
doing it in a database but it's possible
but yes there will be there will be an
impact on your performance and some of
the reports that we have tried to move
we weren't able to move them and right
now that's why we have still this little
part of monolith because we can't move
everything into microservices well there
are still reports and some business
logic that needs to be maintained
because our business needs to be happy
about it so we haven't moved most of the
things because there was there was a
performance impact on it
the question is if you're exposing your
data in database access through some API
sense through the NPI not only using the
database the question is will the API
calls and different API calls expand to
like a non maintainable thing because
you know bi developers and secure
developers and people like that they do
create complex reports complex logic in
there and sometimes your API won't be
suitable to do this but then you have to
add another API call and yes it has if
there was a problem with that and
sometimes you have to create you have to
work closely with your bi team to really
find out what you really need because
sometimes they just ask questions for
some new API endpoints and it leads to a
and then they just use it one one time
and they just stop using it later on so
yeah but this will increase this will
increase the burden so some of the parts
you can't move out of out of your system
yeah yeah
because we are from the big so how to
deal with transactions in distributed
microservices words so another expert I
don't have I don't know the perfect
answer to it but I think that instead of
working with transactions and looking at
it from the old way of looking looking
at things you have to embrace even
driven architecture and maybe even even
to eventual consistent even driven
architecture and that's I think you
completely change the paradigm on how
how do you treat the data so instead of
well instead of looking at the problem
from the old perspective you have to
change completely the way how you look
into transactions so making distributive
transactions is complicated and probably
there are books and better expert on it
I won't be able to tell you how to do
this I would try to change the paradigm
and complete him try to move out of it
and embrace eventual consistent even
driven architecture or something similar
just answering a question a bit okay any
questions yeah
in that case if you can you can find
some of the so the question is if
there's a critical path in your system
that has to be always online and it's
really important would you use different
technology like airline so I don't have
any experience that I like I had that
good things about it but I had no
experience with it but yeah sure
like we have a our financial system is
not distribute that it's still being
like a monolithic system outside because
we have to be PCI compliant so this
system has to be too close to outside
and you need certificate if you want to
access this system
so yeah there are parts of the system
that we still haven't move on and we
will probably not move on because we
can't just distribute like our PCI
compliance system that was already
certified long long time ago and it's
only possible but you're looking in
different technologies you will be will
be a good idea but II yeah I think it
will you have to do this you have to
look at the different problems using
different tools you can't just the micro
services are not feel about that and
distributed systems are not suitable
that you have to look for different
tools you have different kinds of
problems I don't know if that's sounds
good questions a bit yeah okay any
questions more yeah sure whatever
what type of event store do you use so I
know the days one that you can use using
a secure database and installed even in
database but we use event store from
Greg yang which is like a application
that you just install and you just saw
it somewhere and yeah we just use event
store from from a brand young company
yeah I know the questions yeah sure
so that's an excellent question like how
will business how we business like the
move yes this will be costly move and
this is a significant investment and of
course business won't like it but we had
support from our excellent CIO and CEO
and they were aware of the micro
services and distributed wealth they
were aware of that we have to move that
slowly because the cloud is not going
away so we will have to go there one day
so with their support they were able to
communicate with the business and
explain them and always fight for us and
always explain them why this is
important so if you want to do this
thing in your company you have to get
support from someone that will support
the idea it's not you it won't be
possible just do it by yourself as one
single developer or even as a team you
need people higher up supporting the
idea so without without the CIO and see
a city our help we won't be able to do
this yeah there's no question a bit
yeah because convincing business to it
will be difficult like with everything
like you know business they want they
need value they need to increase the
value they need to make the platform
that provides the value they don't want
to get into like what's distributed
finger we don't care we want to you to
develop stuff that makes more volume so
this is when I mentioned this technical
side and business side fighting together
for resources in time because our
technical side have a support from
political people that do have a lot of
political power we could fight for this
idea in this move and in the end later
on after some time we have prepared some
reports and presentations to the
business that showed them that with
micro services and distributed approach
we have better time to market and you
will be surprised but they kind of
haven't at the beginning they haven't
got the idea that this will be huge
thing but now they really appreciated
that when they have a request and they
want to change the product we can just
deploy something in in ours instead of
waiting two to three week week two or
three weeks for a change right so at the
beginning it was difficult but after
some time when they've seen the benefits
it really got to them and they re in
business is really happy about it and
they are right now they are supporting
is feeling more questions
okay not more questions so thank you for
joining my presentation yeah don't don't
forget to vote</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>