<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Book of F# - Dave Fancher | Coder Coacher - Coaching Coders</title><meta content="The Book of F# - Dave Fancher - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Book of F# - Dave Fancher</b></h2><h5 class="post__date">2017-02-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eQzF8RrLM6s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello good afternoon oh and Dave I'm in
from Carmel Indiana back in the United
States now I've been working with F
sharp for a number of years now although
I have to confess that the past few
years since writing the book of F sharp
my career has not necessarily allowed me
to write f sharp as much as I would like
as a as many of you can imagine I'm sure
up you end up in shops or working for a
company says we're a c-sharp shop and
the throne upon trying new things so
that's been kind of my life since I
wrote the book but that doesn't mean
that my enjoyment of the F sharp
language has diminished and in fact
every time I work in C sharp there are
plenty of things that I miss daily there
are a number of things I found
workarounds for there's a number of
things that the c-sharp language team is
working on finding workarounds for but
they're usually not anywhere near as
close to what the the f-sharp
implementation is so now I do miss
working in F sharp daily and I hope to
make that be able to remedy that in the
next few weeks here with an upcoming
project but before we get started here
my publisher was kind enough to give me
a few copies of the book to hand out
here at NDC London now they're up on the
front table and they also sent enough
stickers for I think the entire
conference I don't want to take these
books back with me because they spend up
on my backpack and there's a long time
in the plane and even with those toss up
I've got to run across the airport so my
friend Brian is going to be monitoring
tweets and he will be in charge of
distributing those books so if you
already have a copy please leave it for
somebody who does not have one but
otherwise those will be handed out at
the end of the session aside from that
again I'm Dave consultant back from
Indiana and this is the book of f-sharp
60-minute human edition
so I think for me my story seems to be
pretty typical from the people I've
talked to the people coming into f-sharp
in Y F sharp I was a c-sharp guy my
entire basically my entire career coming
into this and I didn't really set out to
learn a functional language I just kind
of stumbled upon it by accident and for
me the Gateway was little technology
called link I'm sure that sounds pretty
familiar but what I found over times I
really liked the patterns that were
evolving out of link and I looked at the
query syntax initially and then I
started looking at the the method syntax
and I'm like wow why do we even have
this query syntax like this wasn't
sequel and that whole method chaining
and delegation approach just really
resonated with me it made so much sense
and soon my code started looking like
link like I was writing functional code
I just didn't know it back then but as I
learned about functional programming and
as I learned about the advantages that
it has over more traditional
methodologies as we're learning the
terminology and giving names to what I
was doing things like first-class
functions and realizing the advantages
like the default immutability and the
the improved predictability of the
software I really fell in love with the
functional paradigm and from that I
learned about F sharp so F sharp
strongly typed functional first
programming language for writing simple
code to solve complex problems great
global marketing speak yeah but it
doesn't really give the whole picture
because F sharp E is or is a functional
language and that's just for the the
academics and the financial companies
right no it's a general-purpose language
so we can write whatever write whatever
type of software we want but it's also a
hybrid language it's a multi paradigm
language
it just happens to be a functional first
language what that means is that it's
actively trying to guide us into writing
code in a functional paradigm and then
when we need to like when we're using a
library that's object-oriented we can
revert back to that we can fall back
onto those different paradigms as needed
but overall it's going to really try to
guide us toward writing in that
functional style so there really isn't a
formal definition of functional
programming you talk to ten programmers
you get ten different answers this was
kind of an aggregate definition I came
up with at one point the functional
programming pair is a paradigm which
concentrates on computing results rather
than performing actions so we're not
going to worry about managing state
we're just going to worry about inputs
and outputs and to me functional
programming is really built on three
pillars first is painting side effects
you'll hear about things like well you
can't have immutability you can't have
side effects and that's the wrong
mentality to me because there's also
that goal of software is to have some
some effect on the world right whether
you're writing to a database or calling
some service you're changing the
environment around you somehow it's not
about eliminating them it's about taming
them getting rid of global scope that
type of thing you get rid of that you
can control if you have to have some
type of viewed ability whether you're
changing the contents of an array limit
it to a function don't get rid of it all
together the second pillar is about
emphasizing expressions so c-sharp the
statement based language right F sharp
is expression based and that offers a
number of advantages in itself one
everything has an input and everything
has an output well if everything has an
output that makes it much easier to
understand what's going on inside of
some piece of code so if there's an
output you can also check what that
output is right that means it's easier
to test and it's easier to predict
what's going on
and the third pillar is functions as
data so we have our inch we have our
strings we have our custom objects
well functions should be treated no
difference in the language we're not
going to really talk is that emphasized
functions as data so much in the overall
content of this talk but we'll see it
repeated throughout so we've talked a
little bit about these advantages and I
know this has been a heated topic as the
past week or so is going on about
whether we should be relying on the type
system or whether we should be relying
on the our unit tests and our
integration tests well first off I don't
think there's an either/or I think it's
above but I've always been of the
mindset that if the computer can do
something for me why wouldn't I let it
let the type system do its job
let the type system stop me from making
stupid mistakes that that we all make
sometimes a time right
you know I liken it to a saw my dad was
a big woodworker and he had his table
saws and I see these saws in the garage
and they'd have an exposed blade you
know how many times you hear about
somebody in a woods you know in a wood
shop let's get this table saw sitting
out there and they run their fingers
through it well there are things you can
put on top of that slaw to stop you from
running your fingers through it there's
also things also things that you can
take off of the saw that will allow you
but you want to rely entirely on making
sure that you're paying attention 100
percent of the time or do you want to
have the language and the compiler stop
you from doing those types of mistakes
to begin with and then give you the
flexibility that when you say yes I know
what I'm ready to do I can take off that
safety I tend to go for the form assert
for leaving the safety on so this is the
first example in the book I acted in the
book to not go with a hello world
example because everybody does hello
world and when a language like F sharp
it's one line of code and one line of
code does
really tell you anything but this
example just a reverse polish notation
calculator and it doesn't actually it
doesn't include every aspect of f-sharp
but it involves numerous aspects and I
think you know just based on its
conciseness even those of you who have
not used f-sharp or looked at F sharp
can probably have some discern some idea
of what's going on in here right you
know we we are have a it looks like it
takes a string and okay there's this
other thing let's solve items and
current oh okay that means is that a
function it kind of looks like it's
doing something match currents and items
okay I'm doing something with those that
current value and that whatever is in
items items must be some type of
collection it's plural right and then we
can Co plus minus those look awful
familiar I'm pretty used to those as my
mathematical symbols and then we can see
Oh F split well s is coming in from
somewhere but split I know split that's
a method off of the string so I must be
taking a string and breaking it apart on
the spaces and then I'm executing some
method to solve this for every other
variable so if you know that reverse
polish notation is taking a string of of
expression or string of numbers and
operations you can have a pretty good
idea but maybe it looked like something
like this the input to 3 plus so it's
going to push 2 &amp;amp; 3 onto a stack and
then plus it's going to evaluate oh well
that's right here plus we're going to
pop the Y value because that's the one
that was put on last we're going to pop
the X off because that was one that was
put on before and then we're going to do
some operation well what's t he is the
rest of the items in that that that
array that came out of split similarly
we have five four six plus divide so all
of these things that you can discern
very quickly mapping back mentally from
the
input of the string back to what the
calculator is doing so the magic behind
F sharp now and this is this is the
thing that I think is probably the most
important of all of the things in the F
sharp language only people heard of
curried function okay so to me this is
really as I mentioned the most important
thing in the way that F sharp behaves
because it opens up all of the rest of
the expressiveness of the language so
you think about a C sharp application
you call a function you have to give it
the arguments right you have to go say
it's an add function like this you give
it a and B those arguments are applied
at the same time they always have to be
supplied together in this case we see we
see let add a and B gets a plus B and
our sum exactly what we would expect but
notice an f-sharp
we don't have parentheses around our
arguments we're not grouping them we're
not comma-delimited them here we're just
passing them along we know that from our
math classes and years of experience
that adding 10 and 5 should give us 15
and it does but the signature of that
function is int goes to int goes to int
we can even see that if we hover over
this back in the code sample Val add a
event goes to be event goes to int so
I'm taking two integer values and
getting an integer value back but I'm
not doing it the way that c-sharp does
it because the F sharp compiler gives us
curried functions what that means is
that it's really giving us a function
that returns another function and in F
sharp every function must have exactly
one input and exactly one
output you don't have things giving you
multiple return values you don't have
things accepting multiple inputs if you
think about working in c-sharp if you're
trying to work with your delegate types
which is essentially what's going on
here there's a separate class of of
delegates the family of f-sharp func
versus func and action and predicate you
think about the complexity look at your
link signatures I think there are nine
generic overloads of func
I think there's nine or ten generic
overloads of action well if you've
written your language in such a way that
every function has just one input and
just one output that eliminates tons of
complexity right there and it also means
that the compiler can make more
decisions about how your code should
behave and what it should do so our add
function that we saw back here let add a
B gets a plus B is really saying let add
a get a function that accepts B and
returns a plus B so this seems like okay
whatever you know that's that's odd
that's a little different way of
thinking about this what does that
really matter why is this such a big
deal
I mentioned currying is the key to
unlocking the expressiveness of the
language the first point that this
brings us to what we call partial
function application this is where we
apply just the first n parameters and
arguments to a function together give
ourselves a new function so in this case
I've taken that same add function and
I've defined a new function called add
10 and notice all it's doing is saying
add 10 I don't have any lambda
expressions here I don't even have to
tell it a separate parameter because the
F sharp compiler is smart enough to know
what the signature of ADD is and those
it takes an int and gives us a function
that takes another int that returns it
in
well there's an implied implicit
parameter on ad 10 and we can see that
the signature of AD number in Stu
instant has now become int to int on ad
10 so every time we want to call ad 10
we're just going to basically be
supplying the B parameter to add a
number everything is an expression and
even in the C sharp world our custom
operators are functions but we can't
treat them as such in F sharp we can
treat all of our operators as functions
so we change them from being in fix to
being prefix here so if I want to create
a convenience function for doubling
values double I wrap the operator and
parents give it two as its first
argument just like with add we only
supply the first argument for add 10 now
we're just applying the first argument
for for our operator and so we can do 12
is the result of doubling 6 and 30 is
the result of tripling fan but a little
bit more practical when we get into
pipelining
so while partial application allows us
to just specify a certain number of the
parameters up front without specifying
the rest pipelining lets us change our
functions together in a very logical
consumable and composable way and I say
here data stream seamlessly flows from
one function to the next so and you
think of when you're looking at
pipelining just think of it you have
this piece of data that's going to flow
through the pipes and go through some
series of operations and come out the
other end
the simple example take our add function
sometimes we just want to do it and
throw away the result so it's there in
the ignore function I don't care what
it's doing I'm just going to throw it
away
ignore is built into the language
because F sharp requires that everything
returns a value and so if you want to
explicitly not do anything say you've
made an up you've made a function that
updates the database and it returns the
number of rows affected you know you may
want to check that you may not want to
check it if you don't want to check it
you can ignore it but because of the
nature of the language if you don't put
the ignore there then the compiler says
hey you're not using this value I'm not
going to just throw it away unless you
tell me to so it's a compiler warning
that you haven't used some returns that
may actually be important to your code
how about this you know I come from the
United States we have a different
temperature system so this has been
useful for me this week now look at my
watch I see luckily my watch does this
for me but I turn on the TV and it's
telling me it's like zero degrees and
like wow that's really cold now and it
is cold but how about a little
conversion function I'm going to take
the degrees Fahrenheit I'm going to
convert it to Celsius what I've got here
though average temperature so I just Lou
in a couple of random we had a little
bit of a hot hot spurt at the end of the
week a couple of weeks we go back home
and we have thirty thirty two point
eight so a good range you know right
around freezing with it with a warm spot
at the end I want to take those values I
want to average them f-sharp has a
module built in for giving us an average
but notice I've turned it around I
changed the semantics of the code here I
don't care right away about the average
yes I care about it it's still important
but I don't care about it first what I
care about first is the data that I'm
working with so I have my array of these
five or six temperatures
and I use that pipe forward operator to
send that array into the average
function that brings average those
numbers together and give me the result
I don't need an intermediate variable to
store that result I don't care about the
result outside of the scope of this
pipeline the only thing I care about
here is what the average temperature in
celcius was so let a ver egde temp get
array plate to array average pipe to
Fahrenheit to Celsius so this is how you
can write much more concise composable
code emphasizing the pieces that are
important to your software it gets out
of the way you write this you care about
in this case again we care about the
temperature we know the series of
operations in a very linear process and
we don't have any extra code noise to
distract us from the problem that we're
actually trying to solve in this block
of code and this is very idiomatic F
sharp so you'll see this all over the
place now the fact that it allows us to
emphasize those important pieces keeps
us focused on the problems we're
actually trying to solve instead of
making the compiler and so doing things
to make the compiler happy and it's just
a presentation so let's talk about some
of the types that are built in to F
sharp a little bit here so first we have
the tuple type how many people have used
to 'pls and C sharp how much did you
enjoy that experience right exactly what
the hell does item 1 mean right you know
you have no idea what any of these
things mean and it's so cumbersome to
work with okay yeah so let me litter my
code with tuple that create that sounds
like a good time now that's going to
really really add value to my business
partners right no I want to write that
and I know what's coming in c-sharp 7
but it's not as good as this
because the type inference is so much
better here I get let points get 10
comma 12 the compiler knows because of
the comma if you see a comma and I sharp
it's a tuple with one exception and it
knows points is float times float and
that asked trick because these are what
this falls into a category of data types
called algebraic data types that is
really the sum it's really the the
product of the universe of floats and
the product of the universe of the
universe of floats so every possible
float value and every possible float
value is a valid pair in this case a
tuple and we can pull data out of this
so even though we're just passing it
around as 1 value we have point we can
reference point anywhere we want within
the scope of this we can pass it into
another function that accepts a a pair
we can return a pair because it's one
data type right it's containing those
two values but it's still just one data
type it satisfies that exactly one input
exactly one output but we can pull data
out the first thing we can look at is
just some simple easy convenience met
function first and second you know
pretty easy SSTs m d thanks pretty
implicit what they do it gets you the
first item and it gives you the second
item you've got to be a little careful
with these though because if you try to
use them on a tuple that has more than
two items it's not going to work because
these are constrained based on the type
system to a two-member
tuple but we can also do this is our
first second glance at we call pattern
matching we have a let now let X 2 comma
Y to get point the compiler knows the
point is the tuple of floats and knows
how many items are in there so it can
drop those into the appropriate names we
have X 2 y 2
records are conceptually similar but the
compiler has to create a type to hold
them for us simple example we're really
just trying to group three pieces of
related data here red green and blue
values pretty standard single how much
code you'd have to write to do that in
c-sharp even taking advantage of things
like Auto implemented properties keeping
in mind that these are also immutable by
default so by default you can't change
the contents you can do what we see on
line four which is a copy and update
which gives you a copy of in this case
red and now changes the G value to 255
notice the suffixes it's going to
enforce the data type so I can't it's
not going to do an implicit conversion
there are no implicit conversions in F
sharp because that's the side effect
you're changing what you think about the
environment but if you think about what
you have to do to implement those
probably data data transfer objects GU
right that are basically just series of
properties this is that plus a whole lot
more because this is going to give a
semantic structural equality instead in
addition to just having a series of
properties so you can take any two
arbitrary RGB colors and it will know
it'll generate the code behind the
scenes to override --get hashcode and
equals you don't have to do that you
could take any two arbitrary values and
do equality comparisons and it will look
at those values and it will understand
whether they are representing the same
data not the same object in memory as an
object reference the same data
but if you want to use these of the DTO
one little trick you need to do we have
an attribute called CLI mutable what
that does is it instructs the f-sharp
compiler to generate the appropriate
code for working with serialization so
that it can actually create one of these
through the default constructor and then
set the values and whatever it whatever
it needs to so this does not change
inside of our code whether or not the F
sharp sandbox is going to treat this as
mutable it's still going to be immutable
in our code so we still even though we
can serialize it back and forth across
the wire we still have the benefits of
immutability within our sandbox and if
you want to see something a little bit
more involved pattern matching against
records a function get color name we're
passing in the color we're going to
match color with for transferable
patterns the first one is just looking
for red second is looking for green and
the third is looking for blue the fourth
is just give us the hex value of
whatever else comes in one of the things
that F sharp the inter compiler really
forces us into though is because it
knows all of these things about the
underlying types because it knows that
an RGB color has just these three
properties and they are all bytes it
knows whether or not you've actually
handled all of the possible cases that
could come into here so we have three
record patterns to identify the three
named colors and we have one general
variable pattern that's going to catch
everything we just called it C and we
use the string formatter
to generate that hexadecimal value from
that RGB color and notice we just asked
the values the individual values exactly
as we would if this was any other object
that we were working with colored our
color G and color B so we still have all
of all of that benefit we have we don't
have to change our mindset on how we
need to work with this I've got a color
I know what I need to get out of there
and I can just access it by property
like I would on anything else then we
can see some piping taking red pipe to
get color name and then we do a copy and
update red with G equal to 100 pass that
in to get colorize again I'm emphasizing
I care about the color I don't care
about the operation until after the
color now the big is a cool one really
cool one discriminated unions are one of
the things I missed the most when I'm
working in c-sharp I think that's the
people I talk to this is pretty pretty
universal opinion discriminated unions
restrict the values to a known set of
named cases so many times when you're
working on something you know there's
only ever going to be three different
three different possible implementations
of some base class but somebody else
could come in and extend it right you
know maybe somebody else oh hey I need
this this custom writer I don't need
this other writer that we provided
out-of-the-box discriminated unions can
provide us with additional safety to
make sure that we are always working
within the known set so here's one
possible use for discriminated unions we
can treat them as simple a simple object
hierarchies so I'm working on a drawing
program and I'm going to say I'm looking
to support in my my minimum viable
product release circle rectangle and
triangle
I haven't implemented anything else
outside of there I just want to to
handle those three tools right now
well now when I write code I don't need
to worry about somebody else coming in
and saying
I'm just going to throw in an oval
because I think I can know the code
that's working and handling that
rendering doesn't understand how to work
with ovals yet so we can enforce that
and make sure that everything is added
in the right place as we expand and make
sure that the compiler can check it when
we try to do something that's not
supported now just like with up with
records we also get some structural
equality comparisons off of this as well
so we can say all of these circle
rectangle and triangle they are all
shapes you can think of in this case
that's that's to help think of shape as
an interface or something or a base
class and then circle is the
implementation rectangle is an
implementation and triangle as a as an
implementation and they all have their
own Associated set of properties radius
doesn't make sense for a rectangle but
it does for a circle and notice that we
can name them and they look a lot like
how we had named things in the record
it's very nice simple consistent syntax
but we're patterning bringing multiple
pieces of data in for some of these like
the rectangle and the triangle have
additional dimensions that they need to
worry about so we use the asterisk
remember asterik meant to pull this is
what we call a syntactic tuple though
it's not really a tuple behind the
scenes but it's the way that the
compiler uses the tuple syntax to
represent multiple values being
associated to a particular union case
and then we just create those like we
were creating an object if we were in
c-sharp we would have to have new here
but we're not there now the only time we
use new in f-sharp is when we're working
with I disposable implementations but we
say circle we give it 3 for the radius
we give rectangle 10 and 12 and so on
but notice this bottom option that
Square is not highlighted by this by the
syntax highlighter here because Square
is not defined on that Union and so if
we were to compile
this code the compiler would catch that
so you've tried to do something with a
union case that's not defined so we
either need to go and reach in and
remove that code or implement square
this is a little bit more involved
example so we can also use discriminated
unions as trees this is really really
convenient for abstract syntax trees and
stuff it would be real it would have
been really cool if Microsoft were to
use this for rosalind but they didn't
now because it's so perfectly suited for
it so this is very very rudimentary here
but I've got a markup tight just really
intended to represent either some HTML
or some XML in this case I went with
HTML and we say we're going to have
content elements we're going to have
empty elements and we're going to have
just content our contents element is
going to have a tag name and it's going
to have a list of children which will be
additional markup so so we can have
these giant trees if we want consisting
of content elements empty elements and
content empty element just takes a
string that's going to the tag name it's
going to be like your line breaks and
then content is just going to be some
basic text you can see how we can build
this up in a very composable way content
elements of HTML content element ahead
and we can see the nested list there if
we want to work with that we can use
pattern matching I want to convert that
HTML structure that markup structure to
a string this is all the code I need yes
what's rudimentary yes I haven't
implemented attributes or anything like
that it wouldn't be hard to extend to do
that but we have two HTML string that
rec keyword was that for any ideas let
rec to HTML string that's to notify the
F sharp compiler but this is a recursive
function so recursion plays a major role
in functional programming we tend to
favor recursion over iteration
and the f-sharp compiler is smart enough
to do tail call recursion to do
optimization so we don't blow our call
stack and it makes things a lot easier
when you start writing things when
you're working in a functional language
and start thinking more in terms of
recursion and just calling functions
over and over rather than thinking
through iterations but here what we're
going to do match mark up with is our
mark up a content element it is let's
pull out the tag and the children use
we're going to use this class with
string writer to build up some some
strengths what's really cool this is the
equivalent of the using statements in
c-sharp it's going to go out of scope
and dispose at the end of that three
line block so it's constrained right
there the F sharp compiler will
automatically clean up after that
disposable when it's done with within
that block we're just going to take the
children and we're going to pipe it
remember that piping is so important in
F sharp we're going to pipe it to a map
function so it's going to do some
transformation against every element
within that list well what's it going to
do oh it's going to recursively call to
HTML strings so if we have that we look
back at our previous slide content
element HTML okay now let's look at all
of the children in that array so the
content element head so it's going to
start recursing through that entire
structure looking for for whether each
element in that array is a Content
element an empty element or just
straight-up content and ultimately we'll
end up with some HTML if we do some HTML
to HTML string but that's all the code
do you think about that in your own
terms like abstract syntax trees you
want to handle various operations you
can define a discriminated Union that
will allow you to represent those pieces
of
your syntax tree and very easily write a
pattern match expression to handle
converting that into the form you need
whether it's something like expression
trees in out and like entity framework
or something like that these things that
there's so much more concise and allow a
lot more a lot more expressiveness in
the way you write your code name in fact
there's a piece we're not going to talk
about in F sharp more than just this
passing mention but we have a technology
in F sharp called quotation expressions
which rely heavily on these
discriminated unions and it's exactly
that it's an abstract syntax tree and it
allows you to inspect the the structure
of your code and transform it into some
other structure just like what we've
just seen all right the answer is on the
screen but anybody know what that is
yes so this is the depending which
source you read the Mars climate orbiter
and it was a very expensive piece of
equipment that got blasted off into
space and everybody crossed their
fingers and said hey go get us some some
data about Mars well they came up close
to Mars the trajectory calculation was
off and it hit the atmosphere and
promptly burned up and got no data the
trajectory calculation was off because
one team used one unit of measure and
another team use another unit of measure
so going back to the discussion about
should we rely on unit tests or should
we rely on the compiler this is one of
the things that really sold me on on
f-sharp because when I was worked when I
was learning at sharp I was working on a
project where I was working I was the
project was an optical character
recognition we had to run these these
documents through a scanner and we had
all these different templates to figure
out where
pieces of data were on that we had to
convert that from the physical world to
the digital world and so we were dealing
with with dpi and inches and trying to
manage where those little rectangular
areas were and I couldn't count the
number of times that I forgot which
month which function I was working with
whether I needed the DPI or whether I
needed the inches so I mean yeah we can
have a team coding standard that says
okay well let's just make sure that all
of the parameters identify what the unit
is let's let's make sure we got unit
tests behind this but F sharp gives us
Dilton units of measure we can annotate
our data we could annotate typically
we'll use it on floats our values with
these units of measure and the compiler
will say you didn't give me the right
type you can't see it here we'll
actually jump over to the editor and see
how the compiler Flags these in a minute
but to define units of measure and these
are much more involved than this in the
long run there's there's a-- you can do
all sorts of of comparative equations
and do conversions between the different
types they're really powerful one thing
to be aware of if you do use these
though they are erased so the compiler
is fully aware of them but they are an F
sharp only thing if you look at the
compiled assembly these will not be
there there will be no signs it's kind
of like working in typescript with
interfaces you know Java scripts doesn't
have the notion of an interface so it
just goes away but the typescript
compiler handles it the same thing here
the annotations just go away one of the
reasons I like this though is notice
when we define the measure types we get
type F and C for our Fahrenheit to
Celsius conversions but notice how it
looks like a generic type parameter on
the values I like that it's a consistent
way I just know oh oh yeah I'm going to
modify this value somehow
but now my Fahrenheit to Celsius that's
the same function as before except now
I'm accepting a float of F and on the
Celsius to Fahrenheit a float of C so
when I'm calling these functions down
below I have to give it the appropriate
unit of measure so only the first line
of these two three line sets actually
work and I'll jump over to the editor in
just a moment but you'll see so for
Fahrenheit to Celsius I'm starting off
with 212 degrees Fahrenheit boiling
right if I try to pass in 212 degrees
Celsius which is a very different
temperature the compiler won't let me
and if I try to pass over a value that
doesn't have a unit of measure the
compiler won't let me do that either but
what else is interesting here is anybody
notices we've looked at these functions
that there haven't been return types
identified in most places I've annotated
most of the places where I've had
parameters coming in but I haven't
annotated what is coming out because the
f-sharp compiler infers what the output
type is it also has an implicit return
because everything one input one output
it's evaluated top down the last thing
is evaluated must be the return so we
don't even have to tell it to return in
most cases so what I'm getting out of
here though if I look at Fahrenheit to
Celsius I'm accepting a float of
Fahrenheit but the result of that is a
float in Celsius and we can even see the
conversion happen there so then if I get
this in a pipeline that I'm working with
Fahrenheit and now I need to start
working in Celsius the compiler will
enforce that everything from that point
on the Celsius so I can't just pass the
Fahrenheit values into those Celsius
methods let me jump over to visual
studio code I also wanted to kind of
point out that
I'm running this all on a Mac one of the
big things that people say is well it's
so tied to Visual Studio and I've got to
be on Windows well I'm running this in
vs code on my Mac my virtual machine is
not running so let's go find that first
one there we go a couple of things so
here's that same code and notice what
I'm trying to pass the Celsius or the uh
Nana Tate adverse the compiler is
stopping me that beats the unit test
every time in my book because now I
don't have to maintain that and I know
that the code that the data that I'm
passing into that function everywhere I
don't have to write multiple tests
across the application for every place
this was called I just have to write the
right annotation make sure I'm getting
the appropriate value I think that's a
really cool feature that's one of my
favorites the error message is actually
type mismatch so expecting a float of C
goes to objects but given a float of s
goes to float of C so it's confused on
what unit of measure T that it should be
using yeah one thing that is kind of
before we move on when you're using
units of measure so we're doing this
conversion when you're working with
these you're going to have your
signature says okay I'm getting the
stick with Fahrenheit to Celsius our
signature says we are going to accept a
float of Fahrenheit we're going to be
returning a float of Celsius but because
those are not compatible there are no
direct conversions between those and
remember that F sharp doesn't do
implicit conversions we need to strip
those units off and then when we're done
we need to pop those units back on so
the first bit line 328 float of T that's
doing that steps
Sharp's version of a cast so we're
taking if this is how we strip the units
off so tea that came in our temperature
was annotated as Fahrenheit we want to
pull that value off the treat it as a
regular float and then when we're done
doing our calculations we multiply it by
one point zero C and that's going to do
our conversion back to a to centigrade
and we can do the conversion we could do
the multiplication against the float now
and have the attack on the unit of
measure right how are we doing on the
home just okay cool right in front we've
looked at pattern matching quite a bit
and this is one of those things you know
I know that but pattern matching is
coming in c-sharp seven no it's not when
you've worked with this no it's not it
really isn't and and then every time you
set you get excited like oh so bring it
in pattern matching and you see the list
of things they're going to support and
then they cut 90% of them no they're not
oh this is one of the things that will
probably die I will be amazed if we ever
see it in c-sharp so this is active
pattern and when we can do pattern
matching against variables we can do it
against constants we can do it against
records you can do it gets discriminated
unions we can do it against arrays and
sequences and so on and so forth those
are all the built-in patterns but what
is one of those really match what we
want what if we want custom logic around
how we match data active patterns are
the answer to that so everybody knows
fizzbuzz I'm sure well this is probably
a completely overkill solution for
fizzbuzz but look I've constrained
myself into the four values that this is
buzz requirements are supposed to allow
it is very explicit what my values are
supposed to be
fiz buzz fizzbuzz and in this case other
because what are the requirements
fizzbuzz for multiples of three and five
fizz for multiples of three buzz for
multiples of five and the number for
everything else right well how's that
like fizzbuzz fizzbuzz other match we're
going to build a tuple right in our
match expression we're going to match n
modulo 3 and n modules modulo 5 we're
going to do a little bit of tuple
matching if both are 0 both are evenly
divisible well then it's fizzbuzz if
only if it's only divisible by 3 we
don't care what the result that's what
the underscore is that's our wildcard
pattern we don't care what that is we're
not using it for anything
it's got to be buzz the reciprocal for
buzz and then for everything else we're
not even going into we don't even care
whether it's a tuple now the compiler
will enforce that it's a tuple but we
don't even care that it's a tuple in the
last one so we just use the wild card or
give everything and return other and
attach that value then our fizzbuzz we
have our shorthand for pattern matching
so there's actually an implicit argument
here you can see on the intellisense val
fizzbuzz arg1 so the compiler has given
us a parameter we don't even have to do
that with this to tell it explicitly in
the syntax some people like this way
some people don't help I tended to go
this way when I'm when I'm writing this
I know a lot of people do like to be
explicit but I know what function does
so now all of these Union cases what
what looks like Union cases are our
active patterns they all correspond
backups is Buzz fizzbuzz and other these
are awesome
I love these but for reasons unknown to
me and maybe somebody in the room knows
I've never been able to find an answer
they're constrained to seven
cases I don't know why Dean O'Brian yeah
I've never been able to find an answer
to so there's for some arbitrary reason
and Don probably had a very good reason
when he designed the language up they're
constrained to seven so if you have more
cases than that you need to rely on what
we call partial active patterns and
these are basically the same thing
except we have a special type of
function now called a except I can't
remember I just drew a blank on website
out but these are new functions defined
and the syntax on them is a little
unusual we're going to say match this
pattern that's that's a pattern right
there fizz or anything else what this is
converting to is we see some fizz else
none f-sharp has a built-in
discriminated union called option this
is our way around null there was a tweet
a number of years ago basically when I
was writing the book one of the people
very prominent in the community
responded to a tweet about what can be
sharp do that F sharp can't and the
answer was null reference exception oh I
still love that I have it I actually
have an image save somewhere it's pretty
funny out so the way we get around nose
is we which it's an opt-in mentality we
have either some value or none and none
you can think of kind of like null but
it's much safer and here if n is
divisible by three we're going to return
fizz otherwise we're going to return
buzz so we don't need a third case for
fizzbuzz because it's going to be
covered by by default just by virtue of
having those two already when we get
into our pattern match down line five
through nine if is and Buzz return says
Buzz is
just fizz right Rand says so then we're
even more explicit when we compare that
back to you to here we were returning
those values as part of that full active
pattern but now we're being a little bit
more picky because we're just saying now
we're going to look at fizz and Buzz and
this allows us to get past that 7 case
limit all right yeah I get time ok
awesome
how many people have heard of type 2
providers on a sharp okay
aside from currying this is probably the
other and this is probably the other
biggest thing that really sets F sharp
apart from other languages so we've got
a fairly basic description here but
compel type providers are components
that provide types and functionality
based on some typically external source
things like databases Excel out other
languages there's a type provider that
allows you to connect into R so if
you're doing any type of statistical
analysis you can go in and and use the
power of f-sharp in conjunction with the
power of our it's really really sweet
XML documents and the one I love the
demo and the reason I like to demo it is
because it doesn't require an internet
connection
and it doesn't require a database L is
for regular expressions how many people
like writing regular expressions exactly
so I actually don't mind it now but the
way that I make myself not mind it is I
like to make sure that all my captures
have nice names on them
now let's jump over to vs code again and
scroll through those examples and right
here we go other window so this one I
just brought in we have a package
manager in F sharp that's called packet
out it's pretty nice manages your
dependencies a little bit better than
nougat but still plugs into nougat so so
it's pretty nice but I brought in this
package called f-sharp that text dot reg
X provider this is something that if you
do use the book I have this example in
there but the light the code is moved
from one library to another to another
the book hasn't been updated to reflect
that but it's really a pretty powerful
type provider it was it was my
understanding as it was originally
developed kind of as a proof-of-concept
to see if it could actually work and
just show him the flexibility of how
beneficial types providers can be to
your code I like it because I do like
regular expressions for the most part
but you can see I've got this regular
expression here color reg X now that
doesn't look like how we normally define
a reg X does it usually it's like new
reg X this is a type like okay that's a
little weird I've got a type that's
based on a regular expression and I like
that it's got a generic syntax one thing
to be very aware of here
notice that space on line 232 I just
highlighted it I'm sorry it's probably
hard to see in the back but the space
here because of the generic like syntax
is very very important because if we get
rid of that notice it's highlighted this
was just one of the quirks of the
language it's trying to treat this the
string literal as a quotation expression
so getting rid of that that that white
they are making that whitespace in there
will get trick the compiler into doing
what you actually want it to do instead
of making it do what it thinks you're
trying to do but we've defined the type
for our regular expression
and what this is doing is
behind-the-scenes its parsing that
expression so it knows some things about
the structure of it and it's going to
it's going to do some some interesting
things behind the scenes now you work
with named captures typically you've got
to pull them out of the group's
collection right
it's a dictionary of group of names well
that kind of sucks right like you fat
thing or something you know who's to say
you know I've named it red here and I
say are in the hard-coded string to pull
out the value you know what if I decide
okay you know what I can't read this I
can't read this thing in or what just
happened happened then you insert some
text and and you know you know who's to
say that this change that I just made
changing red to R is actually going to
get propagated through all of those the
strings what the type provider is going
to do and if you're watching the the
bottom of the screen you probably
already saw this but I'm going to send
some code down we have F sharp
interactive and I'm going to bring in a
few namespaces and the library I'm going
to define that so I'm just executing it
you can see it running at the bottom I'm
going to create a function let's either
you're going to return some or none and
that's got to bring in system so I get
for doing this one at the last minute
there we go
so now if I go here and run this last
line of code of course mono is breaking
step what did I break oh because I
didn't bring it up head yep I didn't get
this one quite working up I was going to
convert it over to the system that
drawing and I didn't bring that in I've
got a bad image format so it's trying to
do like the 32 bit or 64 but we can
still look at the code so let me get rid
of this then we'll still see the overall
behavior we expect so we get this pipe
red green and blue are our captures and
we can say in here if m dot success have
we matched we're going to take our color
we're going to pass it over to a new
instance of that color reg X type and
we're going to invoke the typed match
method on that color reg X type so this
reg X type provider has generated this
type for us behind the scenes and it
largely resembles the built in regular
expression classes but instead of having
to have things like m dot captures or
ends at groups I'm sorry notice we have
property names here instead it's matched
that red match that green match that
blue and if I come back up here and I
change that from red to R I have red
squiggly the compiler has found that
that regular expression has changed and
it will stop me from compiling and
deploying code that is known to not work
because the regular expression no longer
matches what the code was expecting it
to do that's powerful that's why we rely
on the type system now now if I didn't
have a unit test there I caught it
immediately without having to do any
extra work because the type provider has
already done that now types providers do
come in two flavors
there's generative and erase so just
like the units of measure can be erased
the the types that the tie providers can
generate can also be arrays
and basically everything just gets
treated as object behind the scenes and
then there's some that will actually
generate types that remain and our part
of the compiled assembly I do have if
you really want to see how this
mechanism works because it's really cool
I mean it's running as part of the
compiler itself I've got a Pluralsight
course on building types of providers
the course is specific to erased
providers but I also have a blog post
linked from there that talks about how
to do a generative provider so very cool
stuff there's lots of there's lots of
different type providers out there but
you know I hope you've gotten something
out of this this was I love that sharp I
think there's there's lots of things
that again they'll Brian too said in the
previous talk that this is one of those
things that Microsoft really has going
for it and they don't seem to be aware
of just how powerful the tool they've
created so thank you very much for your
time and enjoy NDC Zion who gets the
book</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>