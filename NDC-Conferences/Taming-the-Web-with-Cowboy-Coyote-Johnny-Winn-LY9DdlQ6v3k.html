<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Taming the Web with Cowboy &amp; Coyote - Johnny Winn | Coder Coacher - Coaching Coders</title><meta content="Taming the Web with Cowboy &amp; Coyote - Johnny Winn - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Taming the Web with Cowboy &amp; Coyote - Johnny Winn</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LY9DdlQ6v3k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right greetings everyone welcome to
tales of the clever coyote I'm Jonny
Wynn better known on the internet says
Johnny Ruger make you gir the next slide
for the past two years I've hosted a
podcast called the elixir fountain prior
to that I did a newsletter for the
elixir fountain so I've been around the
community for about four years I've
contributed to both Phoenix and elixir
itself also a few of my own libraries
that are being used
Cronos and in Flex in Flex is probably
the most popular library that I have
ever written in my entire life and all
it does is do like singular zation and
pluralization of words which is great
it's like I can't believe that that
popular it's really not that complex
excuse me so currently I'm working at a
company called Ambala empower networks
what we do is is we build virtual power
plants to manage renewable resources
these resources are distributed across
large areas as you can imagine when you
think about managing windmills and
things like that it's not a centralized
station like what most people
traditionally think of as Power Networks
when you think of a grid you have a
central power station that is
responsible for generating power and
then pushing the power out to the people
that need it well in our case we have to
actually figure out where all these
pieces are and decide where we need to
pull power from so that we can actually
supply other pieces of the grid what
ends up happening is there's actually
like cost involved in that so you learn
a lot of determining factors on finding
that cost so we have to pull all these
resources run calculations on figuring
out which ones the most economically
viable to use and in the scenario that's
being that's being tested and then we
have to send out signals to them at the
same time receiving a bunch of messages
back telling us what these things are
actually doing as you can imagine
there's a lot of data flow so the idea
of taking advantage of distributed
systems is great because we can offload
things to servers that are more powerful
to handle the complex calculations as
well as having one
the server's that's rule I are handling
all our telemetry coming in and telling
us what these assets are doing and then
we can kind of have another system that
when it can be a little slower there's
just kind of organizing all this data
and displaying it to users
now today though I'm hoping to be a
storyteller quite noble I think but not
a storyteller like what you
traditionally would think of traditional
storyteller in the native-american sense
of a storyteller so the storyteller in
the native-american sense is more
concerned about the truth of the story
rather than the context of the story the
store the truth is actually in the
moment of the story now as we all know
developers truth is truly based on
context because how many people have
answered the question any programming
question out there with it depends
depends on the scenario because I can
tell you today this and this is the
truth today and then you change the
requirement tomorrow and all of a sudden
what I told you yesterday is false and
today there's a new truth so this isn't
actually a story of any great success
I'll admit that but it's not a story of
failure either it's really just my story
that I'm going to share with you about
how I came about writing this library
called coyote now some background on it
coyote has actually kind of been in my
head now for about a year or so if
you're familiar with the elixir
ecosystem how many people here because I
know I see different faces how many
people have used elixir before how many
people have heard of elixir before how
many people thought they were coming to
something completely different okay good
we're on target so if you've heard of
Phoenix which is the big web framework
for elixir and it's great it's bringing
a lot of people to it to elixir one of
the things that I've always kind of not
really sat well with me is that you know
it's the idea that there's this big
framework that's kind of handling
everything for you and I
kind of feel like there's a better way
to do things not to say that that's
wrong but different and that's okay I
just kind of see the way that I like to
build elixir applications and really
pretty much beam applications its
pipelines of data data transformation I
get data in I want to send it off to
something else I want to transform that
data and then present it and I want to
make that the very last thing that I do
is presenting that data one way or
another whether it's to a database or to
a front-end user and so it's all about
the transformation so to me the MVC
style doesn't necessarily fit that just
because there's a lot of hooks in there
you have to do it a certain way I don't
want to do that I just want to send a
message somewhere let it do its thing
and then give me something back Phoenix
on the other hand I think is a great
presentation layer if you're trying to
display to the web because it gives you
a lot of the things that you don't want
to have to deal with CSS JavaScript and
all that sort of stuff I don't want to
have to deal with that on a daily basis
I want to have a presentation layer that
can deal with that I added in there I
just worry about grabbing data and sent
it now so today I'm not just going to
tell you the code I'm hopefully going to
be a storyteller I'm going to share
three stories with you now these are
Native American folklore stories and
you're probably going to stand up there
and sit up there and say what does that
have anything to do with this talk but
if you think a little bit deeper you
might kind of find some patterns that
kind of follow those stories and kind of
apply to this talk and worst case
scenario they're just going to kind of
break it up and give you something to
enjoy for a few minutes without thinking
too hard let's get started it's time for
our first story the clever coyote once
upon a time there was a horrible monster
that lived up in the mountains and he
had gone out onto the plains he grabbed
up all the Buffalo and kept them to
himself well of course nobody had
anything to eat because the people
hunted Buffalo and so kalam comes with
coyote very hungry and says we have to
do something about this we have to free
the Buffalo and the people say but how
do we do this there's this horrible
monster up in the mountains that has all
the Buffalo and so the coyote thought
for a second
he said I've scouted out the monster he
has a little boy that lives with him
well we can't do anything to the boys
the little child no no no no no that's
not what I'm thinking the boy must be
lonely living up there with the monster
why don't we give him a pad and so that
the pet can help us free the buffalo
people like that's a great idea
what are we set let's send the mouse so
he sends a mouse up there the mouse goes
into the mountain the boy finds the
mouse the boy of course loves the mouse
but the monster hates it and drives it
away so no get this thing out of here so
they change their mind say ok let's send
a bird so they send the bird of course
the monster hates the bird and wants to
get the bird out so this annoying coyote
thinks for a minute
says I'll send myself I'll go to the
monster and I'll befriend the boy and I
will help free the buffalo so as he gets
up there of course the boy immediately
falls in love with the coyote because
what little boy wouldn't fall in love
with the little dog especially a lonely
boy but the monster of course is furious
and takes the boy and the dog out and
says that's it I've had enough to go so
the boy looks at the dog very sad at
this point everything he's known is gone
and he looks at the dog and says you
know you must be hungry you probably
haven't eaten and the boy begins to cry
well when the boy begins to cry the
coyote starts to howl because that's how
the how the coyote is actually supposed
to calm you when you're sad well what is
that also going to do it's going to
upset the Buffalo so the Buffalo start
getting nervous they hear this howling
the more the boy cries the more the
coyote howls and the more the boy cries
and more than a coyote howls and the
more the Buffalo gets scared well all of
a sudden one Buffalo takes off and what
happens when one Buffalo takes off they
all take off and they all immediately
scatter across the world far and wide so
that there's all have left the cave now
of course at this the monster is mad
horribly mad because now he's lost all
his food he thought he had food for life
and so he goes out and he tries to chase
the Buffalo but now they've scattered
all across the world
well the Warriors come in and hide in
the cave but wait for the monster to
return when the monster returns excuse
me when the monster returns
the warrior slaughter the monster and so
he is no more and then that is how the
Buffalo became across the world so what
did I do
and what did I set out to do we kind of
started talking about this already I
knew I wanted to be able to build
distributed applications I want things
to be able to run small tiny
applications push them out to different
servers maybe running on the same server
in a different node or maybe even just
small applications but I want to be able
to communicate with these and I want
this completely scalable because their
size is small and they can add the added
to a node cluster they could be pushed
out this is not something that you can
do without actually planning way ahead
in Phoenix if you typically follow the
guys in Phoenix you go ahead and write
it next thing you know you have an
application that is central one
monolithic Phoenix application now
either several talks out there but
they'll tell you Phoenix is not your
application
Phoenix is just another library that you
can use as you can utilize but
unfortunately starting out you basically
end up having to build this application
unless you know better going forward so
I thought I wanted a framework I thought
I wanted to replace it
I wanted something completely different
but what I realized was that I didn't
over the course of the last year so I
realized I what I liked is small
libraries that do something they do one
thing when they do it well and that
they're responsible for that and that's
it
I don't want to build your system I
don't want to tell you how to build your
system I don't really care how you build
your system I just want to be able to
communicate with it time for a second
story
so this is the coyote in the Columbia so
one day the coyote was walking down the
road and it got really hot and as he was
walking and it got hot he decided he was
going to say I want a cloud to cool me
off so a cloud appeared
well the cowboy was our the coyote
wasn't satisfied so he said it's still
too hot I want more clouds give me more
clouds and so there was more clouds
appeared to try to cool him still
unsatisfied he said that's it I want
some rain give me some rain so it
started to rain a little bit and it
cooled a little bit but the coyote still
wasn't satisfied he's like this is not
right I want more rain I want to be I
want it to come down from the heavens
and rain down upon me and cool me I'm so
hot so the rain came down and the rain
came down more a creek formed well he
put his feet in the creek but still not
enough so he asked for more I want more
water send me more water and all of a
sudden the waters came down and it
created a great river and the river
swept up the coyote and tumbling and
tumbling down this river he goes rolling
and finally at some point he washes up
on shore almost dead laying there looks
up and the vultures are swarming around
him and say and he yells up at them I'm
not dead yet go away and that's how the
Columbia was formed so how does coyote
work now if tyranny can be actually run
as a standalone standalone library that
works as a lead server and you can
actually it has a routing table and you
can add smaller applications to it by
connecting into that node whatever that
note is it can be on the same note or a
different node and then supplying a set
of routes so that tie to the server when
it gets an inbound request and then send
that off and then take that data and
return it back to whatever environment
now by default it uses cowboy cowboy is
a Erlang webserver that's a very popular
airline web server so it seemed like the
first place to start but you don't have
to you can actually make it web enabled
or not say you're running a back-end
system you just want to communicate with
all these libraries you don't
necessarily have to have a web interface
but as I was doing this I was thinking
well
if I do is one why not make it
interactive with Phoenix plugs
applications are great they're easy to
use people love using them because
they're simple so why not make coyote
work with anything and so I did so it
basically works the same premise the
only differences is when you have your
lead server you say it's not web enabled
so you basically use it as a standard
library to route your traffic from one
application in many smaller applications
what this does is this allows you to
offload processing to various
applications around your system your
total system now how is that done don't
worry we're going to look at some code
now there's your code this is the so if
you're familiar with macros in elixir
what I did was I actually created a
router that all it really is concerned
with is a way of giving these
applications away to supply routes so
the N routes in the sense of I need to
know what message you'll accept
and so this little macro right here
allows you to put a function call in
your client and then actually go through
add your routes in there it reads them
in now I use a commodity client to do
this now this is our coyote client here
and basically if you're familiar with
modules you can use the using macro you
say use and then whatever it is and it
actually brings it in to makes it part
of it so you have things like your
module name and things like that
available to you this is actually
another macro it's just a macro that's
it's a macro that you don't actually
write the macro you're just kind of
filling in the text for now the key to
this is if you look we have the name
then nodes the topology that we want to
join by default it's the default for
topology but we can actually create
multiple topologies so say you have you
bring up an application that you only
want things that know how to communicate
with a specific topology you can
actually route traffic there so you can
have multiple you can have a single
when they are when the client
application is started the very first
thing that it does if you look at that
an it on 27 it sends the register that
register that register loops through all
the nodes that it knows about those
nodes come from your config file so that
you can actually do any number of nodes
we'll look at that in a minute here's
our actual register routes where we loop
through the nodes we send a message to
the lead server which is there's a lead
server for each node that tells us which
which to actually connect to which is
going to service these requests now you
can do multiple lead servers like in our
case we're actually going to have three
different lead servers one of them is
just going to be an API so we're only
going to give it certain routes that we
want to access through the API one of
them is a Phoenix application and one of
them is a basic ty ot application if you
weren't who was in the talk yesterday -
oh you guys missed it you really need
you'll watch that online because those
people will notice the on 86 we get code
now one thing that I want to mention
about that is we actually when this
application starts up it reads in this
module and then sends a copy of it over
to the lead server and then the lead
server then compiles that into memory
and then calls the function routes to
get the routes for this node so we're
actually passing that data over are
passing the code over and reading it in
now you can also in your config file you
can set up at a completely different
function as long as it provides routes
it'll call that easiest way is just to
use your routes macro now that's great
but what happens when the server goes
down well here we're going to actually
watch for the server so we our lead
server we actually keep an eye on and if
it goes down if we get this down message
we actually start continually pinging it
to see when it comes
back up now one of the things that I
talked about was actually adding a we
don't necessarily need to ping it
constantly let's wait and paint it you
know every couple of seconds because
it's probably not going to just
immediately jump up but the idea is if
you look up on 30
sorry it's easier for me to look at line
numbers over here 39 that's where we're
pinging that node to see when the node
comes up as soon as the lead server node
comes back up
we actually rear edge astir our routes
because it's they've been cleared out
they're not there so we're edge to the
routes now a coyote server when we try
to register with a server on 29 will get
the message to register now we read that
code in with that code load binary on 30
and then we add those routes to the
route bridge now the route bridge
actually uses the topology that you
specified default by our there's a
default by default a default pipe
topology and that's where most of the
routes go unless you specify something
different now that routing table well
actually when the request comes in it
checks the routing table for a route if
it knows how to service that route it
sends a message over if it doesn't then
it just it sends back a message saying
no route available so if your client
application drops off for whatever
reason it clears all the routes that
were associated with that process and or
node so a process can go down you can
lose just those routes or the entire
node can go down and you lose all the
routes for the node when they come back
up of course a tree registers now if
you're not familiar with gen stage which
is a way to handle back pressure I
debated long and hard before I put this
in here so this has been out now for a
little while but when I first looked at
gen stage I was like well do I really
want to add - do I really need to have
this because the idea is that you kind
of queue up request and you can handle a
certain amount at a time say 10 requests
or how many over you configure it to
handle and then when it gets back
pressure it kind of delays sending those
messages slightly so that that way you
can wait till it clears up so you're
never just bombarding your system with
mess
you're kind of letting them taper in and
so you can actually get a nice
throughput when I first started doing it
I was like well I'm just spinning up
request handlers so my requests when a
request comes in I spin up a process it
shouldn't be too much of a problem and
really when my first passes on this
everything was fine and basic
applications now the tests that we're
going to see where we figure out that
hey maybe this is a good idea we'll get
to that a little bit later when we
actually see this thing running but
needless to say I decided that it was a
good idea to add this in to deal with
the back pressure when you're talking
about something that's handling multiple
requests for multiple things coming in
from many clients returning the
information from many clients many other
possible ways of getting into coyotes
say you have multiple applications
accessing the same lead server to
display data you're going to have a ton
of requests so dealing with back
pressure was a major thing so now how do
we do that actually when I decided to go
with the consumer our consumer
supervisor so when a message comes in it
actually spins up a new request handler
but it is actually queued up first
they're actually chewed up by our relay
so the message comes in it gets queued
up and then sent off if that back
pressure gets too much it waits it
delays before it actually starts sending
things but when it does send it goes on
to our consumer supervisor which is
actually going to spin up and a request
handler for each individual request now
here's a big chunk of code but I don't
necessarily expect you to grasp the
whole thing but it is pretty simple
stuff the request comes in on a request
table each process handles a single
request on its own it goes it checks the
topology for the route if it has a
matching route then it sends a gen
server call to the particular Pig that's
registered with that route and whatever
message it was that it received it's if
a response comes back then it actually
relays that response if not it just says
there's a routing error there was a
problem and if nothing comes back at all
from the route bridge it says there was
no router there so you actually do get
some feedback
now remember I mentioned it in our
client config we can set up multiple
leader nodes and so in our case right
here we actually set up web api and
server so this will actually register
all those routes or all those with all
those lead servers now it's only fun if
you can actually build a client
application with it
this is actually kind of grown a little
bit but this is a simple application
where we have what I call Deadwood and
you'll notice a lot of these projects
have Old West references in them but the
deadwood saloon we basically have the
clever the story of the clever coyote
starts out and so when we get an inbound
route and our routes for get slash we
know that this is the client that's
going to handle that and essentially
remember our coyote client is just
another gen server just has a lot of
boilerplate in there for you so you
could use gem servers to route these
messages to directly but there would be
a little bit of cruft you'd have to deal
with so our call is there and our call
is going to get that message do what
it's supposed to do in our case we're
just returning some text back and then
the server will then relay it to the
thing or to the to whatever the caller
was now in this one what I actually did
for this coyote client was I specified a
different leader node than what's in the
config so in this case we're saying that
we only have the API is the only server
that we want to register these routes
with so that way we doesn't care about
anything else it just wants to service
these requests and then of course we're
going to build our response now this
one's actually a little more interactive
where we're going to use postmen to kind
of relay the the put our the post and
the gets from it so let's demo y'all
ready for a demo everybody all right
everybody on board with where we're at
right now any questions comments
concerns nobody nobody all right all
right so here we go
I can let's talk later about it yeah
let's talk about its I mean the symbol
is like a queueing system okay yes it
kind of works out of the box and then
but it is also configurable so like
there's like a set like ten requests out
of out of the box is what it deals with
so in the bits you can change that
however you want as far as the numbers
it's actually going to queue up before
it deals with it I know I debated on how
much Jim server to talk about that
wasn't sure the level of where we were
all at with elixir here but all right so
here's what we have we have our four
sessions set up if you'll notice we have
coyote which is our basic coyote lead
server it's using Talon
it's it's out of the box if you just
wanted to have an application that was
just relaying data out to the web you
could use that one down we have cripple
creek in the lower left that is our
Phoenix application and then in the top
right we have Dodge City which is our
API using Maru my result basically from
if you're familiar with grape the Ruby
library for building API is that's kind
of what it mirrors and then in the
bottom right hand corner we have
Deadwood which is as we know is our
client application we're going to be
dealing with so let's start this up I'm
going to start up our lead servers
and we registered or we started our
client application - if we go over to
here so this here's our pretty Phoenix
application as I said you can deal with
CSS quite easily with it and here's our
cowboy application I intentionally did
not put any CSS in the cowboy
application just so that you can tell
that there is a difference now these are
both being serviced by the same client
Deadwood as we set as I showed you
before that we had the client that
actually just relays the text back
there's not a whole lot to it there's
some links to some of our stories if we
go back these are clever coyote of
course all this stuff works wonderfully
so those are two applications being
serviced by the same client now we also
have like I mentioned the API which
slide this over here postmen so if we
send this request we see we have a
hamburger and we have a hot dog that's
the food that we can get we have two
items now if we do a post I went to a
restaurant five hundred dollars for
Norwegian salmon it sounds a button it
sounds cheap I think I think that's good
so if we post this will see that our
response was we get our params back and
then we get it's actually added to the
list but if and I'll show you in just
one second if we try to go if we try to
go to one of these other routes food
right is what I did yeah food is our
route that we're trying to go to it's
not there because it doesn't know about
that part of the application even though
they're the same client application and
servicing it those routes were not ready
with the server so it has no idea now
what happens when our client goes down
no matching rounds our client went down
we have no way of knowing when it's
coming back up or anything like that
but we just know that we don't have that
route now when it comes back up its back
its rear edge' stirred we did not have
to restart our server now in the verse
if we bring that down
and it pops back up once the lead server
goes down it comes back up the client
application realizes the lead went down
started watching and as soon as it came
back up re-registered its routes
everything and it works I mean one of
the big things that you have with with
Erlang Erlang systems is the idea of
this fault tolerance to where you if
something goes wrong it should be able
to kind of recover for itself so to
build applications that are aware of
that and say hey look there's a good
possibility that something might go down
let me watch it and then figure out how
to resolve the applique or the the
problems on our own so all right other
application comes back up says hey it's
up I'm going to get registered now of
course there's other problems that could
come up but this is a nice way of
knowing that either side has gone down
and the other R and so when it comes
back up to re-register
now
our final story the coyote and the skunk
the coyote is who was traveling decided
he was very hungry but he couldn't
afford to do it alone and he saw the
skunk and he saw some prairie dogs
playing so he got an idea
he said skunk my friend my brother help
me get these coyotes and will help me
get these prairie dogs and we'll split
them up and we'll eat wonderfully
tonight so the scope said now he knew
that the coyote was a trickster he said
okay I'm in let's see what's yet so the
coyote says okay you go over there and
play dead I'll take care of the rest
so the skunk goes over and plays dead
the coyote goes over to the prairie dogs
and says my friends my friends look our
enemy is dead he lays there on the
ground we should celebrate and of course
all the prairie dogs at first were a
little apprehensive but they're like
yeah we should celebrate and he said you
should dance around them but only do it
with your eyes closed because if you
look upon it you'll die too so they were
like okay because period house
apparently under the sharpest animals on
the prairie they start dancing around
with their eyes closed where the coyote
walks up and kills one they all open
their eyes and says he must have opened
his eyes dance again and keep your eyes
closed if you open them you'll die so as
the prairie dogs started dancing again
with their eyes closed the coyote picked
them off one at a time until they were
all dead now of course the skunk and the
coyote were very happy at this point
because now they had plenty to eat
tonight so they said let's go up the
hill and we'll roast these and we'll eat
now the coyote wasn't quite satisfied
because of course he wants the biggest
portion so the coyote says as they were
roasting the the prairie dogs
let's have a race whoever wins the race
will get to choose the prairie dogs
first and then the other one will get
the leftovers
well the skunk wasn't stupid and so he
said to the coyote said ah there's no
way I can win a race with you he said
you're much faster than I am there's
you're going to get around you're going
to get down there and back before I have
a chance of course you're going to win
so the coyote seeing an opportunity says
well how about this
I'll race you I'll tie a rock around my
legs so that I run slower and that could
equal it out and so the scoops is okay
if it's a big enough rock on it so of
course the coyote goes to tie a rock
around his leg and as he's doing some
skunk you go ahead and go on I'll catch
up
so the skunk starts off down down the
hill as it gets down to the hill of
course the coyote now by this point has
got a rock tied down and starts running
the skunk see some bushes and goes hides
in the bushes he said I got this so the
Coyotes running and running as fast as
he can be the skunk is nowhere to be
found and as he's running the rock kind
of starts falling off and falls off his
Lane of course he picks up speed as soon
as this hump sees the coyote pass he
goes back up to the hill sees the
roasted roasting prairie dogs and
decides to take them off the roaster
they're done takes them off takes them
up to the hill but leaves to the
skinniest boniest prairie dogs in the
fire and he goes up there and he sits
and starts to eat well the coyote comes
back and said and thinks that he's won
the race because skunk is nowhere to be
found but he also notices the prairie
dogs are gone he's like somebody must
have come and stolen our meat just about
then the skunk appears at the top of the
hill and said and throws the prairie dog
bones down and says you tried to trick
me you thought you were going to get all
the the good meat because you knew you
were faster but this time I tricked you
so what are some of the takeaways of
this now one of the things that
developers love although they talk
horribly about is cleverness because
keep it how many people have written
clever code how many people are lying
about writing clever code oh yes
everybody writes clever code at some
point there's some time did you go to
writing something you get your kind of
blinders on like this is going to be the
coolest thing that I've ever written and
then you write it and you commit it and
then like six weeks later you're like
what put who wrote this where's get
Blaine oh and it was you so we kind of
have to be careful with our cleverness
there's a lot of little clever tricks
that coyote is doing in our library or
in my library but it wasn't necessarily
intended to be clever I am utilizing
some things that are built into Erlang
leveraging those but I was actually
trying to be clever with how I handled
things as far as like communicating
between those and things like that
reading code in now it is a
do-it-yourself library which that's
where the cleverness comes in a lot of
times we look I can do this myself but
there's benefits in doing it yourself
sometimes doing it yourself allows you
to learn it that doesn't mean putting it
in production it allows you to take a
look at something that maybe you're not
familiar with and apply that knowledge
that you learn from from building it
into something else so that you
understand it if you're going to use a
framework if you've never built a
framework if you've never actually seen
some of the problems that come to the
people that build frameworks you're not
going to really know what to do when it
goes wrong so you're going to have a
very high level of it so there is some
upside to doing yourself of the fact
that you're getting exposed to these new
ideas these different ways of doing
things I know when I first came to
elixir one of the biggest things that
drew me to it was my curiosity every
developer I believe is curious if there
is at the core that's why we're here
that's why y'all are in this room
because if you were you weren't curious
you probably would have gone to another
dotnet talk or some other dotnet type
talk water there or be out there what's
your in here so the curiosity is the
thing that we all build with now do you
need coyote to do distributed systems
you need coyote to do message-passing
know there's things like RabbitMQ
there's many other solutions out there
that you can rely on that are
time-tested and have been around but are
also large and robust they do a lot of
different things we're something like
coyote specifies on one dars is specific
to one use case of dealing with message
passing between nodes using the request
response so I think if there's one thing
that I try to talk about the most is
keeping that curiosity alive where we
code we we tend to get in our blinders
on of work what we're trying to just
get things delivered and get things
pushed through but we need to take the
time as developers to kind of to indulge
in those curiosities to write those
other libraries to see what else is out
there and kind of broaden our knowledge
of how things work in some respects the
three stories that I told are very
relevant to this talk did anybody see
how they kind of matched up nobody so
the first story we talked about the
clever coyote he decided he was going to
help the world he was going to bring
everything that everybody needed and
that was his gift kind of like when I
first started I knew I was going to
bring something that was going to change
the world but really it was just a
library that gave me some experience our
second story was getting greedy
the greedy coyote just wanted more more
MORE
never satisfied until he almost drowned
but when I first started down the path
of writing coyote I thought I needed
more I needed this feature I needed this
feature my cleverness got the best of me
and I started pulling things in to the
point where I realized that oh this is
too much I need to pull back now the
third story the most important story of
it all it was just standing I'm Johnny
Winn there's a liquor fountain link feel
free to come check out the show we do
have we have guests from around the
around the development community we're
not just a lick sir we do although
mainly we focus on it a lot of our
conversation is around functional
languages and functional design of
applications you can check out coyote on
github I know this is confusing but I am
in you are ug ger zero seven new Rutgers
zero seven that'll tell you when I got
on github and then the gen stage library
there's a link to the genophage library
if you want to check that out
any questions
done thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>