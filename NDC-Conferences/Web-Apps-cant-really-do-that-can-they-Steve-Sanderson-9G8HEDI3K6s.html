<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Web Apps can’t really do *that*, can they? - Steve Sanderson | Coder Coacher - Coaching Coders</title><meta content="Web Apps can’t really do *that*, can they? - Steve Sanderson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Web Apps can’t really do *that*, can they? - Steve Sanderson</b></h2><h5 class="post__date">2018-02-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9G8HEDI3K6s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">is my audio on can you hear me it is
it's being on fight good alright then
okay well we shall get started then and
yeah it's really nice to see such a lot
of happy smiley faces out there I'm
choosing to believe that you all
deliberately want to be in this talk and
it's not just that you were so
mesmerized by the Kino that you just
like can't be bothered to get up and but
to be honest with you I don't care as
long as you're here that's that's fine
with me and so my name is Steve and I
work at Microsoft and I'm on the asp net
team and as i'm sure most of you know
asp net is primarily a server-side
programming platform so that is what the
majority of people on the team are
focused on but I'm a little bit
different
personally I spend a lot of my time
trying to help improve the difficult
lives of poor struggling front-end web
devs who are trying to make sense of a
world where they have to use angular and
react webpack and all that sort of stuff
and try and put that into a shape that
at least gives them some kind of meaning
and some kind of hope and as part of
that as you can probably imagine an
important aspect of it is trying to
understand where the web platform is
going in the future what are the new
features that are coming out that are
going to change the kind of programming
that we do on the web or that are going
to take things that used to be really
difficult messy and make them better in
some way in the future and that is what
this talk is about you two are probably
somewhat interested to know how work web
development will change in the future
and if you are then one of the good
places that you can go to get some
information about that is the various
platform status web pages that each of
the browser makers have put up here's
the one that Mozilla has put up about
Firefox and that's got a long long long
list of all the different features that
they're working on and we will be
putting it into Firefox with lots of
information about what versions it's
going to ship in and what the status is
at the moment it's not just Mozilla
here's Google's one that they've put up
for Chrome and that's really helpful it
tells you exactly what versions each of
their different features are going to
ship in it tells you also about what
level of consensus has been reached
among all the other browser makers about
each of the different features and
links to the original specifications so
you can learn more about you-know-what
in detail the api's are going to look
like and so on finally not surprisingly
microsoft also has got one for the edge
platform for example here it's showing
you that there's going to be a
forthcoming ambient light sensor API
which means you'll be able to detect if
your visitors are in a light room or a
dark room I can't imagine what you're
gonna do with that maybe you're gonna
have some sort of special night mode on
your website or something I don't know
but you know it's great to know that
that stuff is there and you'll soon be
able to use it now if you want to go a
step deeper below this stuff to the
original standards bodies and the
specifications that they're putting out
then there are a couple of different
ones they're probably one of the main
ones is the web architecture but
whatever it says there for what WG okay
and they've got all of their specs that
they're working on listed there and you
can get into that in as much detail as
you possibly want but it can be a bit
overwhelming because if you look at it
there's like 900 different
specifications that are being worked on
at the moment there are different levels
of completeness and how do you even
figure out which ones of those are going
to be interesting and relevant to you in
your development life well the good news
is you don't have to because I've done
that for you that's what this talk is
about we are going to spend the next 55
minutes going through four major feature
areas that are coming to the web which I
think are particularly influential that
are going to change the way that you
write your code or at least the first
two certainly the second two are a
little bit more less known the first two
you've probably heard of already I'm
sure you will have actually but
hopefully I'll be able to show them to
you in a little bit more detail than
you've seen before okay so the first one
which I think you'll have heard of but
maybe aren't quite using yet
serviceworkers hands up if you're using
service workers in your production
application right now like for people
okay five right so not surprisingly it's
a bit early days for service workers
because these it's only just started
rolling out to be on by default in major
browsers but for those of you are not
using it yet what is the idea with this
well the idea is to change how your code
can run because since the very beginning
of programming on the web
you've been subject to a very strict
limitation that your JavaScript code can
only run while the user is on your
webpage as soon as they never get away
we just tear down your entire
application and that's it you can't run
any more code but serviceworkers changes
that it allows you to register some
JavaScript with the browser so that the
browser can execute it even when the
user is not on your page and as for why
you would want to do that well that
gives rise to a whole bunch of different
features and use cases that didn't exist
before and the most bit well-known of
them is to enable offline support for
your application but there's some other
stuff as well that I will mention in a
minute but before we get to any of the
other things let's just start by having
a look at what it looks like to write a
bit of Service Worker code so I'm gonna
do a demo now let's switch over okay so
actually let me show you this thing
running in a browser first what I've
done is I've created this very very
simple plain HTML web page that looks a
bit like a newsfeed so you could think
of it as being a bit like Twitter or
something like that but it doesn't
necessarily have to be a social media
type thing it could be say a feed of
deliveries that your company's delivery
drivers need to do it could be a list of
bugs that you've fixed or something like
that
it's just some source of information
that you need to push out to people and
we're going to make this work nicely
using service workers now at the moment
this application does not work offline
and to prove that to you I'm gonna go
into here and I'm gonna change my
browser to simulate being offline and
then when I hit reload what will we get
we'll get there is no internet
connection all right so it doesn't work
it's dead that's just not a good thing
so let's go back to online and we're
going to try and make this thing work
offline and we're going to do it using
service workers so let's see how the
code for that might go right in my
application so far which by the way is
just pure HTML CSS and JavaScript
there's no server-side stuff going on
here I've got this javascript file and
as you can see it doesn't yet do
anything but the first thing I want to
do is register a serviceworker with the
browser so to do that I can use a little
bit of code like this now the only bit
here that's strictly necessary
Terry is this I'm saying browser using
the serviceworker api's i want to
register a serviceworker
at this URL because the serviceworker is
a javascript file that's all it is the
browser will fetch that and it will
register it this other stuff here just
gives us some feedback about whether it
succeeded or failed but we don't
strictly need that now what is in the
serviceworker JS file well it's this
what you need to understand about
service workers is that the only thing
they can do is respond to events you
can't choose when your service worker
runs if you could you could abuse it in
all kinds of ways and just be mining
Bitcoin in the background forever or
something but to prevent that sort of
thing the serviceworker will only allow
your code to run when the browser wants
it to run and it does that by raising an
event and in this case I am responding
to the install event you can probably
guess that that fires when the
serviceworker is first installed and i'm
logging this message i'll just clean
that up slightly and what's the other
stuff then this thing down here slightly
weird looking api is but basically there
are various ways of telling the browser
when your serviceworker is ready to run
and this line here is just saying I'm
ready right now
don't wait for anything else and this
thing here as I'm sure you can guess is
a way of loading one javascript file
into another normally you know
javascript files using script tags but
we can't use script tags and
serviceworkers because guess what there
are no tags there's no page there's no
document this javascript is running
outside the context of any particular
page so there has to be this other API
for loading JavaScript okay so let's see
if this works shall we we'll see if it
logs stuff to the console to say that it
got installed so if I do a reload now
we'll see the page gets the success
result from that serviceworker register
call and then the serviceworker has its
install event fired the install event
only fires once so if I hit reload again
you'll see the page registers it again
because it's coded to do that every time
but the browser will fetch the
serviceworker and go hang on I've seen
this before
that's not changed I'm not going to
bother installing it a second time so
however many times we reload it won't
install again until we change the source
code so let's make a very small change
to the source code there come back and
reload and now the browser will say oh
look I see that that's different
before so I'm going to reinstall that
now but again it will only do that once
so we won't see in the install event a
second time okay so that is the install
event there are other events that you
can respond to as well and one of the
good simplest places to start is with
the fetch event fetch runs whenever the
browser wants to request something from
your domain whenever it's going to do an
HTTP request and here I'm just going to
log a message and you can ignore the
rest of the stuff for now let's see if
this works shall we I'll see if it's
going to log a message every time we
make a request to the site I'll hit
reload and oh it seems to not be working
but it is working really on the first
request all it's done is its installed
the updated serviceworker but when I
load it again
now you'll see it's running my fetch
event for every single HTTP request that
it makes to the domain the point of that
is not just for logging stuff but so
that you can programmatically control
what the browser does with the network
I'll give you a very simple example
let's say that I want to say every time
that we try to make a request for a PNG
file instead of fetching whatever file
it was going to be instead we're going
to fetch a picture of a face and we'll
pretend that that was the response from
the web server so now I'll come back
I'll reload and the first time it
installs the updated serviceworker
and when I reload again then we get this
picture of a face instead of any of the
images which is great because it's
really fun way of cranking your
coworkers
for example now you'll see that every
single time my browser tries to fetch
this BBC URL there it comes back with
this face even though that's nothing
like what the web server would normally
respond to it's so great for tricking
people but that's not the only use case
there are other use cases as well and
like I said probably the best-known one
is to enable offline support and that is
what I will show you right now so let's
get rid of this silly code here and make
sure that our web page has gone back to
behaving normally okay good and I want
to change a little bit about how my
serviceworker gets registered I'm gonna
start by doing a very simplistic and
naive approach to offline support and
then we'll make it a little bit cleverer
in a moment so here is my very
simplistic starting point I'm going to
say whenever this service worker gets
installed we're going to define this
array which is a long long long list of
hard-coded resources that I want to
fetch and make available offline okay
so I've got this long list and then I'm
going to fetch them and catch them and
I'll do that using this new API called
caches first I'll delete any existing
cache with this name then I will create
a new empty cache with that name and
then I will fetch all of those
hard-coded things and add them into this
cache and when that's all done I'll say
to the browser right I'm done I'm ready
now okay
so having done that we can change
through what the browser does when it
wants to fetch stuff for real we can say
okay we no longer need to fetch stuff
from the internet instead we can just
assume that everything that you ever
want to fetch is already inside one of
our caches so we can just populate the
response directly from that cache see if
this works shall we so let's go back
reload again the first time it installs
the updated serviceworker and now when I
reload it it all just seems to be
behaving as normal but it is a bit
different because if we look in the
network tab you can see that all these
responses have been resolved not using
the internet but rather using the
serviceworker
which means that we no longer need the
network at all and if I put my browser
into offline mode like so then when I
hit reload instead of there is no
internet connection I'll just get my
webpage it just shows up as normal so my
page now is completely indifferent to
whether you've got a network connection
or not because it's not going to use it
even if you do all right
so that's fine but that's too simplistic
really this is going to lead to problems
what problems well this is supposed to
be a news feed isn't it what happens
when there's a new news item let's have
a go at putting one in shall we
I'm going to create a new news item
let's say it's CNBC and we'll go
breaking Bitcoin down by 99% ok and then
we'll come back into the browser and
I'll hit reload do I get the updated
news story no I don't well firstly
that's not surprising because I'm
offline so let's go back online and
reload again do I get the updated news
story no I don't what about if I load
again no I still don't why
well because I'm not even talking to the
internet anymore I'm just returning
everything from the cache that I've
already got so we've got no way of
knowing that there's any new data so
let's make our logic a little bit
smarter even though it's still not super
great we'll have an updated strategy
which is we'll say ok we'll try to
request it from the internet with that
there and if that succeeds then we'll
return the response that we got from the
network but if it fails then we'll fall
back on returning stuff from the cache
so it's fractionally smarter let's see
if that works
so I'll load and the first time it's
updating the serviceworker and then I
load again and we get the updated news
story good so that's an improvement now
and of course if I was offline then it
would fall back on serving stuff from
the cache instead of going to the
Internet so that's good but it's still a
bit too simplistic because the idea that
someone is either offline or online well
it's not really a boolean stage you're
not just online it's there's more a
question of how online are you how good
is your internet connection what if you
are online but your internet connection
is so slow that the entire universe will
have like reached its heat death before
we finish
responding to the network request that's
a pretty bad scenario and in fact I can
simulate that exact scenario quite
easily by pretending that I've got plain
Wi-Fi connection ok so how is the user
experience going to be now I'm gonna do
a control shift are to force it to fetch
everything from the network now I will
see how long it takes so it's not going
to quite take til the heat death of the
universe but it will take a while and
you can see we're still loading we
waiting for these pictures we're waiting
and here they come come on pictures come
on come on ok finally it's done it right
so it's not a great user experience
right now it's too slow even though we
were online so let's make our logic a
little bit smarter still we'll say now
we'll try to use the network but if it's
too slow then we'll give up and we'll
use the cached data okay so here's my
third version of my offline support
logic which looks like a lot of code but
it's not too bad really what we're doing
is we're saying ok we'll start by trying
to fetch stuff from the network
and if that succeeds then we will just
return the response from the network if
it takes longer than 200 milliseconds
because that's how long my patience
lasts then we're going to give up we've
got one fifth of a second if it doesn't
finish in that time then we're going to
return stuff from the cache but we're
still gonna let our response our
requests continue in the background even
if we've given up and served from the
cache will still allow the request to
continue in the background and when it
eventually finishes we will update the
existing cached content so the user will
eventually get updated data all right
let's see if this works shall we first
I'm just gonna run throttle things while
we get the updated Service Worker okay
then I will go back to being on the
plain Wi-Fi like that and I'm gonna hit
reload and this time instead of taking
ages it should come up in 200
milliseconds and it does and if you want
to actually see the numbers here let's
reload again you'll see that all of
these responses are coming back in
slightly over 200 milliseconds because
we were waiting that long to see if the
network would respond and then we gave
up and we returned it from the cache and
so now if there's some new content let's
say breaking I don't know
climb base happy Bitcoin up by 99% okay
right we'll go back and we will hit
reload and this time it will complete in
200 milliseconds we did not get the
updated data from the network fast
enough so we haven't shown it but in the
background you'll see it was updating
all the stay so when the user hits up
that reloaded again later now they will
get the updated news story and they
never had to wait too long for him okay
right so what on earth was the point of
me showing you all this stuff the point
was not to say that this in particular
is the right way to do offline access or
anything the point of it is just to
demonstrate to you serviceworker api's
and the fact that serviceworker allows
you to programmatically control things
that you couldn't control before like
how the browser is going to interact
with the network you can set your own
policies for what should be cached and
for how long and how long you wait in -
willing to wait for network responses
and what you're gonna do if things
timeout all that kind of stuff is under
your control
in a way that it wouldn't have been
before and you can apply that logic not
just to requests that are running while
your page is already loaded but to
record to the very first request to your
page even before your pages is loaded so
serviceworker gives rise to that option
but other things as well I'm not going
to demonstrate it to you but
serviceworkers allows you to say what
should happen if the user tries to send
so for example save some changes to
something they've made while they were
offline we can hold that request in
memory and send it later to the browser
even if they're not on your webpage at
that point similarly we can receive push
notifications from your server even if
the users not on your webpage and a new
thing that's just been creeping into the
specs in the last couple of months is
the ability to do large uploads and
downloads in the background in such a
way that even if the user closes their
browser and then reopens it later it
will resume the upload or download in
the background even though they're not
on your webpage and eventually when it
completes it will send an event to your
serviceworker okay so that is service
workers as for browser support on
service workers right now it's looking
pretty decent it's already shipped
turned on by default in Chrome and
Firefox it's also fully implemented in
edge although it is behind a feature
flag at the moment so you have to go
into the settings to turn that on
hopefully that'll be on by default
fairly soon and then ask for Safari
Apple has said that you know they're
developing this this is something
they're going to support so this is
going to be a universal feature fairly
soon all right
that's service workers let's move on to
the next thing now the next thing is
another thing that I know for sure
you're gonna have heard of but again I'm
hoping that I can show you a little bit
more of the internals of it than you've
seen before and some cool things and
that is web assembly where assembly is
pretty big deal in the world of web
programming because for the first time
since you know the anybody's memory it
gives us an entirely new way of writing
code for a web browser it's a new code
format it's a binary
bytecode format which is designed
primarily around performance so it's
very compact over the network it's very
fast for browsers to decode it and to
verify that it's going to be safe to
execute and it's also very fast for
browsers to generate optimized machine
code
in time when they see that so that they
can execute it very quickly and the idea
is of course not that you write that
bytecode by hand you can if you want but
that would be mad the more likely
scenario is that you're going to compile
to it from some other language and not
JavaScript or JavaScript related
languages but other things that you
would never have used to program the web
before like C or NGO or something else
like that so let me show you a little
bit of how that might work I want to run
some code on the web that I would never
normally be able to run and it is going
to be written in C who's ever written
some C oh that's a good number that's
like a third of you okay so C is a very
venerable programming language that goes
back a long long time and you don't
normally use it on the web
here's a simple example of printing out
the Fibonacci sequence Fibonacci is a
sequence of numbers that's defined
mathematically it doesn't really matter
what the sequence is I'm just using it
as an example of some arbitrary code
here and this block of code here all
that does is it reads a argument that
comes in on the command line and then it
calls this function print Fibonacci and
if we look up here here's print
Fibonacci and it's going to just iterate
through printing out each of the terms
one by one okay now if we want to run
that code written traditionally we would
compile it to a native binary using a C
compiler for example the GNU C compiler
I could say GCC compiler Bonacci dot C
and produce a native binary called
Fibonacci and then I can run that
Fibonacci and it says how many terms do
you want and I'll say give me eight
terms and it's going to print out eight
terms of the Fibonacci sequence
very good but can we run it on the
browser via web assembly of course we
can't otherwise I wouldn't be wasting
your time by showing you this so to do
that we don't use GCC we can use EMCC
them scriptum c compiler and that's
going to take mostly the same parameters
we'll compile the same file we'll tell
it that we want it to produce a web
assembly binary as its output and it's
also new gonna need to wrap that in a
JavaScript file which I'll show you in a
second so that compiles now and what
that has just generated is the
two files here we've got the webassembly
file that's the binary 50 kilobytes and
we've got this javascript wrapper file
which is just under 100 kilobytes and
that knows how to load up and execute
the web assembly stuff now you might be
a little bit shocked and appalled that
we've got 150 kilobytes worth of stuff
come out of there for a 26 line C
program but it's not that bad really it
really isn't because something like 99
percent of the size of those binaries
there is the C runtime that's being
bundled by default so even if you were a
much larger application the final
compile size wouldn't necessarily be
that much larger also this is completely
honest and uncompressed so it's really
much much smaller than this by the time
it actually gets sent to your browser
but anyway
does it work let's try and run it shall
we and to run it we're gonna need to
have an HTML page that we can load in a
browser and I've got one right here I
know it doesn't look much like HTML but
technically it sort of works and I've
got a script tag and it's going to load
this javascript file and up here there's
rather odd syntax for specifying what
arguments should be passed to it okay so
let me try running that now I will
launch that in a browser with ctrl f5
there and when that pops up let's look
in the console and we will see that it
is indeed printing out the first 10
terms of the Fibonacci sequence there ok
good so it does actually work can we see
some of the internals can we see the
code well we sort of can yeah so this is
sort of the code it's a bit hard to make
sense of if we want it to be a bit
easier to make sense of we can compile
it with this G flag which produces a
nice debug build then and if I've done
that then when I come back and I hit
reload you'll see there's a new thing
that showed up down here and that is the
original C source code because it's now
produced source Maps so that's sort of
nice but it's still have limited
usefulness because things like
breakpoints and search don't really work
properly yet although hopefully I would
they will do at some point in the future
but still can we get bit more insight
into what's going on inside this well
another thing that got generated when I
did that debug build there is this West
file webassembly Ted
all right and that is a text
representation of the same stuff that is
in the binary wasum file and this is
designed to be human readable although
obviously somewhat depends on what kind
of human you are is to whether you can
read that but I think we're the right
kind of humans we can do this okay so we
want to try and make sense of where is
print Fibonacci in all this giant pile
of stuff so I'm going to search for
print Fibonacci and there it is okay
that looks interesting it's still a
little bit hard to make sense of but we
can make sense of it because look we've
got line numbers and we can see that
that stuff there is what corresponds to
line 5 in our C code all right what is
line 5 this is line 5 I'm declaring to
locals one has got a value 0 the others
got a value 1 okay and here we're
declaring to locals one of them's got a
value 0 and the others got a value 1 so
we can somewhat see the correspondence
and the same in other cases as well like
here's line 11 this is where we're
adding two things together and if we
look for the stuff that corresponds to
line 11 it's all this stuff and in the
middle of there you can see that there's
an integer add operation that operates
on two locals so we can kind of make
sense of this
a little bit you wouldn't want to write
this by hand but you can see what it is
now it's a a stack based virtual machine
if you've ever seen MSI L the bytecode
that underlies dotnet you'll recognize
this as being quite familiar because
although it's not the same thing it's a
similar sort of programming environment
okay so it does similar kind of things
in a similar kind of way okay so that is
web assembly and like I said there's
lots of work being done on being able to
compile to web assembly from lots of
different types of languages
particularly those based on the clang
tool chain so go and rust and Swift
those kinds of things they're doing a
good job of making it possible to
compile to web assembling and this got
me thinking wouldn't it be really cool
if we could run dotnet on web assembly
as well that would be awesome
what would we need well all we would
really need would be a dotnet runtime
that is itself written in C and then I
could compile that using EMCC
to make web assembly and then I could
run the web assembly my browser and I
could load dotnet assemblers into the
browser and it should all just work
shouldn't it shouldn't it so I went
looking to find a dotnet runtime
written in C and guess what there is one
and I'm going to show you right now okay
so this is what I found on github a lot
of C source code alright so this is
about 98 C files and it deals with stuff
like what is it generics he finalizer
JIT they all sound very dotnet II don't
they and that's because this is a dotnet
runtime now it's not the net runtime
it's not daya framework it's not called
CLR it is a runtime called DNA which was
written by mr. Chris Burke and I was
sittin in the front row here I was very
excited to meet him just a few minutes
ago and it's quite amazing that he
single-handedly put together an entire C
runtime that actually works now he did
kind of abandon it six years ago but
still it's pretty awesome that it's
still here and it works and we can now
compile it and then run whatever dotnet
code we want you can compile it to
regular native code or you can compile
it to web assembly so that's what I've
done so let me show you I'll go to Wesen
DNA and we will look at the contents of
what got generated when I compiled this
and we got these two files okay so just
like before we've got a web assembly
binary file which is 150k we've got the
javascript wrapper which is about 200k
so all together we've got about 350
kilobytes of stuff there but again this
is very uncompressed unoptimized in in
practice it's a lot smaller when it gets
into the browser as I'll show you in a
second
but again does it actually work let's
try so if we want to run this stuff
again we're gonna need a web page to
host that in and here is the web page
for that so I've got a script tag here
which is going to learn DNA JavaScript
and I'm gonna need to pass some
arguments to it in some way but I don't
really know what that is yet so let's
figure that out in a minute
firstly let's run this thing shall we so
let's start an HTTP server in this
directory here and then I can go to the
port that that's listening on and we
will see if it actually manages to run
the DNA runtime and we can see it does
look it is actually executing DNA and
DNA says alright fine tell me what net
assembly you want me to execute
so we better do that and we what DNA
what Donna assembly can we use well I've
got everyone's favorite the beloved
console app one right what does console
that one do we all know this it prints
out hello world to the console alright
so I can compile that now I'm just going
to run build and that's going to
generate a dotnet DLL on disk and then I
want to pass that as a parameter into
DNA okay so here are the options I need
to pass I need to say I want you to run
console app one DLL oh but by the way
you can't really read files from my disk
you're running in a web browser so I
need to configure what you're gonna do
when you try to access a file system and
I'll say when you try to access this
file console app one you're going to
need to actually fetch it from this URL
and similarly in order for this stuff to
work in and gonna need the core library
that contains implementations of string
and a list and all the other dotnet
stuff and that's going to be in this
file which has got this URL yeah okay
well let's try it then so I'll come over
here and I'll hit reload and then this
time it actually loads and executes the
darknet assembly
directly in the browser there and to
prove that this is really working and
doing the actual thing that we think it
should do I will put in some extra
c-sharp code for example I'll put in
this print Fibonacci implemented in
c-sharp and then I can run that from up
here ly self print Fibonacci and we'll
have the first 12 terms let's say I'll
do ctrl f6 to rebuild which only takes a
second and I'll do ctrl R to reload and
we'll see now it's running our updated
code right there in the browser which is
pretty super yeah all right thank you
most of that credit goes to Chris down
here because I did like one hour of work
to make that happen okay so that's
webassembly
and now like I said the DNA run time is
not itself under active development but
since we started messing around with
this the mono team has pública me
publicly committed to bringing mono to
webassembly so you will not have to use
DNA you will be able to use a fully
supported up-to-date very efficient and
feature complete runtime mono actually
inside the browser and so given that
sort of prospect you might be thinking a
little bit like I did hey wouldn't it be
cool if there was like some sort of
framework that you could use to build
client-side web applications in net so
that I could do my back-end in c-sharp I
could do the front-end in c-sharp and I
wouldn't have to deal with like 400
different JavaScript libraries and web
pack and all that kind of stuff wouldn't
that be some sort of magnificent utopia
so I had a little go at that and I want
to show you some of that stuff now but
before I show you I want to caution you
that this is experimental this is not
something that anyone is promising to
ship there's a supported product this is
something that we've been messing around
with and playing it and trying to test
out whether it would produce a good
result and whether people actually want
it so I would like it if as many of you
as possible would give us some feedback
about whether you want this sort of
thing and if so how it would need to
work for you what kind of constraints
you would see on it and basically what
you want out of a zone and you can go
and try it yourself if you go to get up
and and download the stuff on this repo
but let me actually show it to you right
now so I'm going to go into Visual
Studio and I'm going to create a new
project using this experimental
framework so I'm going to create a new
blazer
application blazer is browser plus razor
and I'm going to call it NDC London
there we go and I will create my new
application that that's obviously going
to set up the initial file structure for
me on disk and it's going to deal with
restoring all the packages and such that
I need for this thing to actually run
now show you a code in a second but
first let's just start it up and we will
make we'll make it run in a browser and
we'll see what kind of functionality we
will
and what it can do and here it calms
takes a moment the first time cuz it's
still compiling stuff and there we go
alright so we've got a client-side
single page application it's got the
sort of features that you would normally
expect like it's got front and back
navigation it's got an example of a
button that you can click and it counts
how many times you've clicked it and
it's got an example of fetching some
data from an endpoint on the server and
render it and get in a table now the
implementation of that is not the same
as what you might normally do because
normally you would build this sort of
thing with a JavaScript I would like
angular or react or view or something
else like that but in this case there is
no JavaScript whatsoever all I've got in
my project here is CSS HTML and then
c-sharp stuff now the c-sharp stuff
comes in two different flavors we've got
regular C sharp files CS files such as
this one that's dealing with starting
the application up but we've also got
some razor pages I'm sure I know a lot
of you here have used asp net so you
will probably know what razor is but
it's a syntax for combining c-sharp with
HTML in a very clean way that gives you
a really good tooling support and this
is the implementation of the counter
that I just showed you so the counter
looks like this it counts how many times
I click a button and the implementation
is we have an int that counts how many
times you've clicked we use razor syntax
to display that in the UI and we've got
a button and when you click it it's
going to increment the count by calling
this method and incrementing that and
that's really all there is to it so it's
very very straightforward ok but is this
really practical is this going to
deliver a good application building
experience and can we actually build
some useful and interesting
functionality with this let's try it out
shall we so as a very important matter
of professional ethics
I must demonstrate this to you in the
form of a to-do list as you know that's
a legal requirement so I'm going to do
that right now I'm going to move my IDE
down here a little bit so that we can
see both the browser and the ID at the
same time and I want to start by adding
a new item into this list for to-do list
all right so I'm gonna find the nav menu
component and I'm going to scroll down
and I'm going to copy one of these list
items
they're pasted another copy in it and I
will say this points to a URL to do list
like that and I'm gonna set the text on
it to to do list and I'll hit ctrl s in
the browser and as I do you see that the
web page is updated automatically in the
background so we've got to do less than
now and if I click on to do list what
happens well nothing happens
well actually something did happen you
see the URL is updated but it doesn't
know what to render because we don't
have a component call to-do list so it's
not really doing anything else just yet
so let's create a new thing in here I'll
do add new item and I will call it to-do
list I know the text is too small for
you to read there but it doesn't matter
it's called to-do list and there we go
the browser is updated again so now
there is a to-do list but it's blank by
default let's start by putting some
content in there shall we so let's put
h1 to do list with that spelling there
we go all right so we've got our heading
there nice and I want to actually start
modeling and a to-do list now and since
I'm going to do this in c-sharp I will
have a functions block where I can put
some arbitrary C sharps or C sharp sauce
by the seashore
source code and I will have a class
initially and I will call it to-do list
and I'm going to give that a couple of
properties clapping text okay so each
to-do item is going to have actually
to-do item each to-do item is going to
have two properties will have a string
called text and will have a pool called
is done makes sense yeah all right
but we don't just want to have one to-do
item we want to have a whole list of
them so I'm going to define a list of
to-do item to-do items and we'll make
that as a new list very good now what
can we do with that well let's start by
displaying how many items are in the
list and I can do that with some razor
syntax I'll do to-do items dot count and
we will say that and see initially there
are zero items in that list like you
might expect and I want to actually
represent that on the UI in some HTML so
I'm going to have an unordered list and
I'll say for each of our item in to-do
items I want to render a
list item and each one will display the
item text save and we still don't know
and see anything because of course this
list is empty so there's nothing to show
I better add a button on there button
and I'll call it add item and when I hit
when I click on that nothing happens
because I haven't wired up any behavior
to that now so how can we respond when
the user clicks well if we were writing
some very old-school JavaScript we could
do this we could write on click and then
we could start writing our JavaScript
out in that but because this is blazer I
can write some c-sharp code to handle
the event if I want to I'm going to
change this in a minute but for now what
I want to do is I'm going to say to do
items add a new to-do item and we will
set the text on the new item to whatever
alright hit save on that and now when I
click on this button you'll see it is
adding items to the list and it's
updating the count and everything looks
good and we're feeling happy okay but
this is not really great yet because
firstly I don't want to hard code this
word whatever that's not hugely useful
but also I really don't like having a
big chunk of c-sharp code in the middle
of an HD I'm attribute that's kind of
disturbing so instead of that I'm going
to have a method and I'll call it add
item okay
and inside there I'm going to take the
code that I had before like this and
I'll paste that in there and then
there's a sort of convenient shorthand
way of calling that I'm gonna say on
click and we'll pass the add item to it
and this is the benefit of giving you
nice type checking to make sure that any
parameters that your method takes
correctly correspond to the right sort
of event that you're handling that sort
of thing okay
let's just check this still works yeah
it does still work that's good but I
want to remove this word whatever I want
the user to be typing in whatever it is
that they want to add so I'll have an
input and I'll put a placeholder in that
to see it right here yeah
all right so we've got our text box
there but it's still ignoring us we're
gonna have to capture whatever it is
that the user has typed in there and I'm
gonna capture that as a string and I'll
call that next item like that and then I
can bind the value of this text box
to that variable next item so whatever
is typed in that text box it's in this
string the next item and then all that's
nice this is not finished yet as you can
see so we'll remove this hard-coded
whatever and we'll put next item in
there and I automatically want to clear
that text box out as well so I'm going
to set the next item back to null and
that's going to make the text box go
blank after the user has clicked it so
now I can type in first and it because
their second and it goes in and things
are working that's great
okay but why else do I need to do well I
need to make this editable and I need
some way of actually marking items as
done so let's change this a little bit
and we'll have an input that is bound to
item text so that you can edit the text
if you want to and I'll also have an
input of type check box and I will bind
that to the item is done property very
good so now if I add stuff you'll see
that it's got these check boxes but we
can't really see that the check boxes
are doing anything yet so just so that
you can see that actually works
I'll change what we count instead of
counting all the item we'll just count
the incomplete items and we can get the
number of incomplete items by doing a
link query to say give me the count of
all the ones where the inners done
property is still false okay so now when
I add some things you'll see we've got
three incomplete items but as I check
these boxes the count is updating in the
way that you will require it to do so
okay very good so we have just built
ourselves a simple but somewhat
functional to-do list component in what
31 lines of fairly straightforward
c-sharp code that I hope you'll agree is
reasonably easy to understand that's
nice
thank you okay so nice that you're
clapping I bet you some of you are
thinking hang on a minute this is not
gonna work this is gonna be a disaster I
can think of all kinds of terrible
things that are gonna happen here
firstly you're shipping an entire dotnet
runtime inside a webpage you Matt what
is it gonna be like 200 megabytes for a
web page well let's find out shall we
let's see how big this entire thing is
right now if I'll do a ctrl shift our
full reload we'll see that this entire
thing right now 341 kilobytes and that's
including the runtime that's including
all of the libraries that's including
the CSS for bootstrap and stuff so
that's a very reasonable size and that's
not even a production optimize build yet
so that compares quite favorably to some
of the single page application
frameworks so that's nice all right now
I know some other people in the room are
probably thinking yeah yeah that's all
very well if you can rely on people
having webassembly whereas I have to
support browsers that go back to like
the Stone Age and they do not have web
assembly and they are never going to so
this is no good for me well let's see
what happens shall we if I try to use a
web browser that does not have web
assembly support our old friend Internet
Explorer 11 it's never heard of web
assembly probably never well let's see
what happens if we go to this to-do list
page inside ie 11 well it appears that's
surprising isn't it but does it actually
work let's see well this does actually
work it works completely and we've got
exactly the same behavior so how is this
we've got a web assembly application
running inside a browser that doesn't
even know what web assembly is the way
that is possible is because web
assemblies are very cool technology and
it's designed to be easily poly fobel
for older browsers in fact what's
happening here is when we compile DNA
we're compiling both a web assembly
version of it and an awesome j/s which
is pure JavaScript version of it and
we're detecting on the fly whether your
browser supports web assembly if so you
get the fast compact version and if it
doesn't then we learnt the somewhat slow
a larger JavaScript version of it
but you the developer don't need to
really care about that it's just going
to work whether or not the browser
supports web assembling okay so that's
good and yeah I'm sure some more of you
thinking yeah okay that sounds all right
but what about debugging you're not
gonna make that work are you because you
can't connect Visual Studio to your web
browser you're never gonna be able to
see what this code is doing on the
inside and that did stumped us for quite
a while we did not know what to do about
that
but then we got some of the core people
on the asp net team to do a hackathon to
see if they could figure out how to add
debugging support and they did so let me
show you how that might look and I'm
gonna do that by switching over to a
slightly different sample here this is a
different blazer sample that's designed
to show how it could be embedded into an
asp net application does some other cool
things like server-side pre-rendering
and stuff like that but I'm not going to
show you that I'm gonna show you
debugging and so when that comes up
you'll see it looks initially more or
less the same as before because it's
based on the same template again it's
got a counter it's also shows how we can
like interact with third-party
JavaScript libraries and stuff but
anyway here's the counter and I want to
debug this so I'm going to press a
special key combination control shift D
that you just have to know about and
when I do that you'll see a chrome debug
window appears so let's just move that
over there and you will see that it
looks like a normal chrome debugging
window and it does all the same things
that they normally do for example I can
do the element inspector I've got the
console I can go and look at the source
code for my CSS and editor and all that
kind of stuff but what's different and
interesting in this case is we've also
got a list of the.net assemblies that
are loaded in the page and if we expand
them we can even see our original
c-sharp source code such as this here
and it's not just CS files but also CS
HTML files so here for example is the
counter page and I can see my code in
that and I can even set breakpoints on
it so if I've got some breakpoints there
and I click over here you'll see it's
paused in debugger and I've got the
breakpoint over there and I can now
resume execution or I can hit this yeah
okay so we've got our dotnet code we're
running it client-side using web
assembly and we're also debugging it
client-side using client-side debugging
tools which is a pretty sweet user
experience okay so that is gonna be all
I have time to show you about this thing
but go and have a look at it yourself
try it out and let us know if this sort
of thing is of interest to you and and
how you would need it to work like what
kind of platforms you want to support
what sort of performance constraints you
have that sort of stuff there's a
question but would it be okay if I took
it after the talk thank you just because
I'm trying to squeezing every last
moment of content into this talk all
right so web assembly Browns the support
it's looking really really good
okay so it's on by default in Chrome
Firefox and Safari and that's also the
case for mobiles I don't just mean
desktop even on Android and iOS this on
by default in the current versions edge
has also got a full implementation of it
but it's currently behind a feature flag
again I'm hoping that that thing is
going to be turned on by default fairly
soon okay that's webassembly
now let's move on to the last two things
that I want to talk about today these
are features that are not quite as
well-known you might not have heard of
them but they do give you possibilities
to do some cool new things that you will
not have done before okay it sounds
really boring but it's not that bad
honestly credential management okay
what's that about well it's about one of
the many many things that we've had to
struggle with as web developers since
the very beginning and this is user
logins and registration and sign-in and
change my password and we set my
password and all this kind of stuff
that's utterly utterly boring but you
have to just keep doing it over and over
financial management gives you a new set
of api's in the browser that excuse me
allows the browser to do stuff that's
actually useful for you for example it
allows the browser to store credentials
on a given for a given user it allows
the user to pick which of different
accounts they want to use for a given
site and it even does some cool things
like being able to synchronize login
state across the users devices so if the
user registers for your site on their
laptop and then they open their phone
and go
the same page then they're just logged
in automatically with the same account
and they didn't have to do anything to
make that happen okay so that's
credential management and I want to show
it to you and to show it to you I'm
gonna have to demonstrate a little bit
of a business startup idea that I've
been working on in my spare time which
I'm hoping is going to make me extremely
rich indeed and it's a startup called
CEO portal the idea with CEO portal is
that the very powerful titans of
industry the CEOs of multinational
corporations will be able to create an
account on CEO portal and they'll be
able to use it to do all the kind of
day-to-day business activities that
they're used to add such value to our
wonderful economy at the moment ok so
I'm going to start by running that in
the browser right now so I will set that
as my startup project and I will get
that running and when that comes up
you'll see we've got some quality
corporate web design there which CEOs
love as far as I understand ok and when
a CEO sees that they're gonna be like
yes this looks like just the sort of
thing I need but is it secure can I
trust them with my username and password
so I'm gonna have to have a really
bulletproof modern login and
authentication system and that's what
I'm doing using the credential
management API so let me show you some
of the code that is running when this
page starts up ok when it starts up
let's just have a few breakpoints here
here and here and then I'll hit reload
and you'll see what I'm doing is the
first thing I'm doing is I'm checking
whether this browser supports the
credential management API and it does so
we move on to the next stage of saying
right then browser using credential API
I want you to get me whatever
credentials are stored for this current
user and the bursar browser so sure
thing here they are
undefined this user does not have a
stored account on this website and so
you will then have some logic to display
your application in a logged out state
and that's what I'm doing right now
anyway when the CEO sees this they're
obviously going to be convinced to the
benefits so they will want to register
an account and I've got a little bit
more code that handles that down here
and I want to show you what happens so
the the user comes along they click some
register and they're going to create an
account
to let off steam and I'll have a nice
secure password there I'll hit register
and it's going to hit this breakpoint
down here ok so what's that going to do
well it's going to start by constructing
a new password credential object there
are various types of credentials that
exist to do with like federated logins
and stuff like that but the simplest one
is a password credential which is a
username and password pair and I'm
saying I want to populate it by getting
stuff out of an HTML form that's this
form element and the browser can use
some conventions to get the username and
password out of that and so now I've got
this credential object and you'll see
it's got my username and my password
that I use for everything don't hack me
and next after that I'm gonna tell the
browser that I want to store these
credentials so navigate to credentials
store ok and when that line of code runs
the browser will pop up a little bit of
UI to say hey do you want me to store
this password for you now CEOs are very
busy they do not read dialogues so
they're just gonna click on whatever
button is most visually obvious and that
is this button here because it's blue so
obviously the user is going to click on
this button and the browser is going to
have stored the credentials for that
user and now I've got some logic that
will switch the application into a
signed in mode ok so this is what it
looks like when you signed in it says
welcome here's your username here are
some cool things that you might want to
do today ok so that looks good but what
happens when the user comes back later
are they going to have to sign in again
well let's see what happens when I hit
reload when I hit reload this time we
get to please get whatever credentials
are stored for this user and this time
instead of getting undefined you'll see
I've got the password credential object
from before so I know the user name I
know the password and now on the client
I can display the application in a
logged in mode and I can also store that
password credential in my application
state so that whenever I make any calls
to the backend server it will get the
relevant data and it can authenticate
the user properly okay so let's just
remove these breakpoints and you will
see that the application shows up in a
logged in stay and in fact every time I
hit reload it's going to come up
immediately in a logged in state and if
you look carefully up in the top right
you'll see the browser even knows that
we're signing them in because it sees me
using these api's and the user knows
which account they're
signed in as yeah that's good but other
things you can do are for example having
multiple accounts so if I sign out and
then I sign it oh now don't what sign in
I want to start again I want to register
a new account okay and then I want to
what am i doing okay right very good I'm
going to sign out then I'm going to
register a new account this time I'm
going to be Bert and I'll register that
continue save the user account there we
go okay and now I can sign out I can
sign in and the browser will prompt me
which of your saved accounts do you want
to use so I can be Bert today welcome
Bert and then I can sign out sign in and
I can be Steve welcome Steve alright so
the users got a nice quick way of
switching between different accounts
that they've got and like I said the
browser can even deal with synchronizing
logins day across the users different
devices now as for how that works that's
not your problem unless you work for
Google or for Apple or for anyone else
that makes a mobile operating system
because it's just going to somehow do
that synchronization for you in the
background and you can just don't have
to care it's just going to happen okay
so that's credential management the last
thing that I want to show you after I've
talked about this credential management
current browser support is not looking
great at the moment I'm afraid so like
I've just shown you chrome has got this
thing turned on by default Safari as
committed to doing it it's not
completely surprising that Google and
Apple are the ones most interested in
pushing this because of their mobile
operating systems edge and Firefox are
not yet completely convinced they said
they're considering doing this but it is
on a standard track so you would hope
that they will eventually do it and will
have a universal feature there okay so
that's credential management and the
last thing that I want to show you is
another valuable feature and that is
payment requests okay
so if there is one thing that web
developers love more than anything else
is getting money out of people who use
their websites and traditionally that
has been a very difficult and messy
process because you have to ask the user
to type in their credit card number and
their shipping details and like go
through a like twenty five step process
and the users are like I can't be
bothered to take this out and then they
don't even complete the purchase flows
and you don't get their money and
morally speaking that is a crime because
you deserve the money that those people
would have and that is what payment
requests are going to help us with now
you know if you do in-app purchases on a
mobile app you don't have to type out
your credit card number right all you
have to do is press a fingerprint or
face ID or something like that that's
what payment requests allows you to do
on a webpage it makes payment requests
into a native feature where the browser
can show you whatever kind of UI makes
sense for the device that the user is on
and then it can give you whatever
payment details the user has stored for
their credit cards and their delivery
addresses and that sort of thing and
hopefully then the user will actually
complete the purchase flow more reliably
all right so let me show you that and
this is how I'm playing to monetize CEO
portal actually my goal is that when
users come along they'll see all these
things and they'll think oh yes I love
doing all these things especially
changing product goals but today the
thing that I'm going to do because I
really love it is review some key
financials so they're gonna click on
review key financials and what's going
to happen is this ah that's the premium
feature if you won that you're gonna
have to unlock it which is 50 gems and
the user will think oh that's cool
that's fine oh no look at this I've got
zero gems I'm gonna have to get some
more gems so they'll click on get more
gems and that will take them into the
gem store okay
yeah all right and then the CEO will
think how many gems shall I buy well I
don't know why but subconsciously I feel
my attention is being drawn to this 50
million gems option and so they're
obviously gonna click that button but
when they click that button what's going
to happen
well let's freeze time for a moment and
we'll think about what code is going to
run okay
now I'm going to show you the code that
I've implemented when they click on that
buy gems button and it's gonna call this
method here buy gems and what does that
do well firstly it's going to compute
the prices and you need to understand
this about payment requests they do not
have a concept of things like tax and
delivery charges and stuff it's
completely up to you to implement that
sort of stuff so here I've got my
shipping amount I've got a mandatory 20%
tip which i think is reasonable and I
think that will catch on and then I am
computing the total price okay
and once I've done that I can construct
a new payment request object and there
are lots of different ways you can
configure a payment request in this case
I'm saying I'm gonna accept these two
different types of credit cards but you
could also accept things like Google
Play or Bitcoin ferret's or whatever
other things you think that the users
device might support as long as it
supports there and you say you accept it
then it's going to prompt them with that
option and then we can also specify what
line actions we want it to display so
got these two items here for the gems
and the shipping and then I'm going to
display the grand total shipping stuff
and I'm saying I also want to collect a
delivery address from this user as if
that makes any sense in this case and
then I'm going to display display that
payment request and the browser will pop
up whatever kind of native UI it thinks
makes sense in this case and the user
will hopefully confirm the purchase and
when they do we'll get the success
callback and it will pass all the
payment information to you or if they
cancel it then it's going to call the
error callback okay so let's go back
we'll unfreeze time and we'll click the
button and hopefully we'll get some
money out of that juicy corporate credit
card okay so I'm going to click it and
what happens is our code runs and the
browser chooses to display this
particular type of native UI and it's
going to give the order summary and we
can go in and we can see all that stuff
and that looks reasonable we can pick a
shipping address we can pick a
method as if you know there's any other
method for virtual gems and then we will
click on which credit card we want to
have let's have this one here and then
finally I can click on the pay button
and that is going to move the user on to
the next step in the case of Chrome it
chooses to ask the user to confirm by
typing in their CVC number so I'll type
that in other browsers and other devices
might choose to use a different UX flow
depending on what makes sense but in
this case this is what it does and I
click on confirm and that's going to
send the payment request data back to my
application where I can collect all that
sort of stuff now it's not automatically
transferring money it's still up to you
to pass all this data through your
payment processor or whatever kind of
approach you want to use to actually get
the money it's just automating the
process of collecting the information
from the user okay so that is that
that's payment requests as for browser
support well I've just shown you it
working in Chrome good news for edge
that's already shipped and on by default
there it looks different when you click
on pay an edge it brings up the
Microsoft wallet which is a different
way of selecting your saved payment
methods but it's there and it works the
other two browsers are also doing it too
so Safari has already got it implemented
in their technical previews and Firefox
has said at least that they're doing it
even though it's not shipped yeah all
right that's payment requests and that's
all the stuff that we're gonna have time
to talk about today I just want you to
leave you imagining what your next
mobile or desktop web application might
look like you might be able to do some
cool things that you never done before
for example you could use service
workers to make your application work
offline you could also use service
workers to be able to receive updates
from the server or push changes back to
the server even when the user is not on
your web page that's pretty cool
you could also implement your
client-side code not in JavaScript or
typescript or a related language but in
something completely different compiled
to web assembling you could also use the
credential management API so that users
are automatically have their login state
synchronized across all their different
devices and you could even get money out
of them with a really clean user
experience as simple as a fingerprint or
face ID or whatever it is that their
device chooses to do
and none of these things are things that
you would have done a year ago because
it would have been too much of a mess
and the technology wasn't stable enough
but in the coming months this sort of
thing is becoming it entirely practical
so a lot of cool new toys for us as web
developers so there we go that's all
I've got time for today now if you've
got any questions I know there was one I
will be around for a little bit so
please come in chat to me also please
remember to evaluate the session on your
way out and other than that just have a
really good last day of your conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>