<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What were they thinking? Language design choices that seem wrong, until they don't. - Bill Wagner | Coder Coacher - Coaching Coders</title><meta content="What were they thinking? Language design choices that seem wrong, until they don't. - Bill Wagner - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What were they thinking? Language design choices that seem wrong, until they don't. - Bill Wagner</b></h2><h5 class="post__date">2017-02-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PhRFLKtJcSs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so good afternoon so I am bill Wagner
I'm a senior content developer
Microsoft which means I write a lot of
the documentation and learning materials
for C sharp and dotnet core so a lot of
what we're going to do with this
particular discussion is I want to talk
about some of the language design
decisions that generate the most
questions that I get why did they do it
this way and that's usually immediately
followed with a because it was wrong and
they should have done something else
instead so I want to dive into some of
those decisions that were made and why
as John pointed out a couple times in
his previous talk he had still not
perfect there's mistakes which there
always is but now let's talk a little
bit about language design in general and
one of things we're trying to do with
computer language design is we want to
do two different goals one is you have
to be very very precise in terms of how
its interpreted by the computer whether
it's a compiler interpreter runtime or
what have you because we want it to run
exactly the same all the time and we
also want a very rich vocabulary for
other developers so that when they read
the code that we write it's intuitive
and obvious what we met but they're also
just reading it and they'll pick up a
lot of human-like cues which computers
can't which is one of the reasons for
some of the design decisions we make so
if you think about the richness of human
language if I were to say that's our new
French teacher or if I were to say
that's our new French teacher I said the
exact same words the inflection was just
a little different and for most native
English speaker speakers you interpreted
those two sentences slightly different
in the one case I said that's the new
teacher who teaches the French language
you're the one I said that's the new
teacher who happens to be French just
that inflection makes a difference and
that's one of the difficulties in
computer language design is computers
don't get that kind of inflection you
have to be very careful with our symbols
one of the big goals of c-sharp is to
make it easy to do the right thing and
hopefully make it hard to write but
okay so one of the decisions they had
was we're not going to fall through in a
switcher case statement every case block
has to end in a go to a return or a
break or a throw would be the other way
to terminate one you cannot fall through
from one to another like you could in a
classic C style switch statement when
that first came out a lot of people said
you know this just allows a lot of
things that we could do where maybe for
one case we do some things and then fall
through to the next case and do some
further processing and it flows
naturally okay that was always the
critique we got for that why would you
do this you're just making me type more
adding more characters
well first one of the most common
reasons for doing it is it makes it
explicit you have to say what you mean
after this block ends if you want to
fall through to them to the next one you
go to that next label so you can still
write the same code but you have to be
explicit about what you meant someone
else reviewing that code can't look at
it and say I wonder if they forgot a
break there because you had to write
something about exactly where you wanted
to go this is a hidden benefit that
comes up for any given value when you
look at code if you want to refactor it
and move things around at most one case
block gets executed that helps us when
we added the pattern matching switch
expressions because there's the
semantics of such that the first pattern
that matches gets execute it and then it
will exit so the fact that that was
already baked into switch makes it a
little easier to add pattern matching
into the language and there's a hidden
gem that happens is that in general case
blocks inside a switch statement can be
rearranged any way you want and the
runtime behavior will always be the same
almost always I'll show you what we mean
by that so if I look at a little bit of
a switch demo here in terms of some of
the things that we can do in the
statement
if I were to write some things in terms
of just a switch statement looking at
how many points you score for doing
things in different points or different
sports you can see there's a few bits
where everything has to happen in any
case could only occur at once if I were
to comment out the second block for the
third case statement we get compiler
errors on that because it will tell me
that we can't have a second copy of the
same consonant I could rearrange these
in any order and everything still works
correctly I can put this one down
further
and so on the only way you can't
necessarily do that is if I were to
introduce a variable in in one of these
statements I could use it later I would
get a warning or an error that its
unassigned
if I just assigned it in this I would
get rid of that error but now if I
rearrange them and move that block above
the declaration now I get an error but
don't do that anyway because it's really
weird for scoping rules which we'll get
into it a little bit later so I did that
one kind of as a preview for one of the
decisions that we talked about and we'll
go into more depth in the house the
switch statement is really changing on
Friday when I talk a lot about the
pattern matching features that are being
added in c-sharp seven so what are the
next ones that's coming in c-sharp seven
is a feature called local functions
local functions enable the definition of
functions inside other functions okay
seems simple but if we look at that that
feature in general what a lot of people
have said is you know if I really look
at what I'm trying to do with local
functions I can do the same thing with a
lambda expression I can simply define a
lambda expression as a local function
why did we add new language features in
order to put local functions into the
language well it turns out there's three
very very good reasons for that the
first one has to do with how lambda
expressions and functions are defined so
if I wanted to do a factorial expression
using lambda expressions the way I would
have to do it recursively
is I have to first create a lambda
expression and assign it to null okay
that's totally useless but I have to do
that because of the rules of the
language because now later when I want
to actually assign that variable for
that expression in order to use it in
side in terms of this recursive
algorithm here it has to have already
been both declared and initialized at
least once so I have to assign it to
null and then I can declare I've
reassigned it it's different and now I
can use this land expression as a local
function okay that's a lot of extra work
and just in terms of typing if I use
that same implementation as a local
function I get something
noticeably simpler the red squigglies
that are going on here is because my
machine has got a mixture of newer and
older bits in order to run some things
on the Mac so it's balking at any of the
C sharp 7 syntax in CS code if I want to
declare it as a local function I have a
couple different advantages first you
notice the first statement is a return
statement I can call this function
before I've declared it or to find it
because the compiler will do it single
pass like it does today anything can be
used as long as it's a member and then I
define that local function same basic
syntax if you look i've defined it as a
it's a lambda expression but i've
defined that local function it calls
itself definitely simpler to read i
don't have some of the extra generics in
there to do the func of whatever i don't
have some of that extra work so it's
simpler cleaner syntax so that's why we
liked it that's why local functions were
added that's one of the main single
purpose reasons there's a couple other
interesting ones that came out the first
one is that local functions don't
require allocating a delegate object so
in terms of performance and in terms of
if what you're really trying to do is
simply scope something and make it so
you can't call that function from other
places inside your code well local
functions are better in that first
implementation I have to allocate a
delegate object that's a memory
allocation I call it through invoking
that delegate it's a little bit more
expensive than calling a function
not a lot but in a hot past those kinds
of things will matter especially the
memory allocations it turns out one of
the very nice things with local
functions is that what we actually do in
generating the il for a local function
is we just generate a private method so
the il is the same as what you would do
today
prior to C sharp 6 we just made a
private method but the compiler enforces
at compile time that you can't call this
local function from any other place
inside of class so we can nest them
inside there you get the scoping
benefits that you want this method can
only be called from inside the method
where it's declared can only be seen
from inside where it's declared so I
could declare another local function or
another member with the same name
somewhere else and they would not
collide but the compiler generates just
a normal private internal or private
function and runs through it in the same
way ok so that's why we added that
lambdas effectively are different than
local functions so even though there was
a way you could do it we find that what
we've added is a much cleaner syntax
questions on that so far
ok those are the only ones that have
features that are somewhat new in the
language the rest of these are generally
pretty evergreen this is the one that
still we get questions on so I don't
have a demo for this because we can't
demo the feature that doesn't exist
c-sharp doesn't do xml literals our joke
about this is that VB in raisin and
storage is one based so they made this
mistake one time c-sharp is zero based
and we made that mistake
zero times so why wouldn't we do xml
literals VB developers love xml literals
they just have XML inside put some text
inside with variables it substitutes
that generate XML it's awesome well the
first thing we think about this is ok
fine
that's easy to do but we can use library
calls too
pretty much get the same effect why add
a whole new construct to the language
itself in order to support an external
data format that's a lot of extra work
that's the kind of thing really hasn't
happened with libraries because even
when this feature first came out
well we didn't weren't necessarily
certain what would replace XML over time
we were pretty sure that XML wasn't
going to be the permanent data format
for all time
so why tie yourselves to an external
format that's a library type of problem
if we look at a little deeper you know
XML in 2016 as 2017 is a little less
important jason is certainly a more
common format for a lot of web
communication other formats are on disk
and so on so within one time the
language to a format John scan here is
convening the Exmouth c-sharp committee
we have enough work right now without
tying the c-sharp language to changes in
another external format right now the
c-sharp language in our standardization
efforts is tied to the CLR and the CLI
and the B field types okay
beyond that the language doesn't have
firm ties to some other external
standard okay sure Unicode I Triple E
numeric formats there's a few others
that yes we are tied to because that are
pretty universal okay I don't know how
much your Unicode is going to change
coming tomorrow just John's of using
c-sharp talk that will be fine but the
big concern was that if we were to try
to add xml literals into the language
the standardization efforts gets harder
now we are tied to which version of
c-sharp is tied to which version of xml
if the xml standard evolves in any way
in order to support those things we had
to we would have to take that on that
becomes a much harder problem and one
that really doesn't have a lot of value
and overall the standards work on
c-sharp has really helped the language
grow in adoption in a lot of different
ways because C sharp is an ex- standard
xamarin could implement it samer and in
mono could implement it c-sharp already
had some roots in other platforms
outside of Windows we had dotnet core we
implement that standard as well it makes
it easier to run on multiple platforms
without it being taken away some of the
rules for ECLA standards because c-sharp
is a necklace and 'red if Microsoft
decided they weren't going to continue
to evolve c-sharp no there's no plans of
that there's a lot of plans to continue
working on things other someone else
could pick it up as a standard so the
standardization effort was much more
important than adding one feature for
XML ok last one was no demo now this is
the one we have a lot of fun with and we
still get things there were arguments
about this feature to the point of
screaming matches when fire was added to
the c-sharp language because it was
added around the time of length and it
was added as a necessary feature to
support anonymous sites right if we
don't have a name for a type well we
have to somehow declare it so we'll say
it's var and whatever type the compiler
give us that that's the type of the
thing so the type of the variable is
determined by the right-hand side of any
assignment statement if I want to
declare and assign a local variable I
can use var different people at
different times wrote guidance that said
you should only use var with anonymous
types because with anything else you
should type the full thing out there
were people who said var is awesome
we're going to use it anytime we
possibly plant can thankfully we won
so the critique is it's hard to know
what a local variable is it's var could
be anything all variables should be
declared with the type that's the
history of c-sharp
typing keystrokes is not the same as
adding type information any of our
initialization is still strongly typed
so it gets a sight from the right-hand
side well named methods well named
functions obviously constructors tell
you what that type is initializations of
other types tell you what that type is
var works extremely well not with tuples
in c-sharp 7 which kathleen will go into
in a lot of detail tomorrow where i can
declare a tuple is just a few different
fields doesn't have a name it's the
tuples unnamed type those fields have
names and we put those with our works
just awesomely so there's still strongly
typed you still get all the same
benefits you just don't have to type the
keystrokes and it reads fairly fairly
simply so there's a few things that we
are really really important in terms of
working with VAR in terms of local
functions primarily working with
different types that do queryable so to
turn this and this and if we look at a
couple things with bar so as i said the
first two pretty obvious eyes an integer
is a stringbuilder the third next three
are interesting and the reason they are
interesting they are all the same query
but i've declared the variables
difference in the first case i've
declared sequence with far in the second
case i've declared it to be a system
that linked out iqueryable of int and in
the third case I've declared it to be a
system's collections generic ienumerable
event now with that first one with var
remember these are the exact same
queries someone decides John what do you
think that type is for sequence
and I queryable event anybody think it
might be ienumerable event depends on
the source sequence okay and in one
sense you're right where he's looking a
little bit deeper it is an eye queryable
event and the reason that would be true
that you can tell from all three of
these statements together is if the
query returned an ienumerable event the
second statement would not compile
because I would be trying to assign an
ienumerable an object that is an
ienumerable of key to a variable
declared as an that queryable
and that would not compile however going
the other way does because there is an
implicit conversion from iqueryable to
ienumerable okay and that's actually
very dangerous in code that works with
iqueryable data sources again somebody
besides John what happens if i take an
iqueryable and i cast it to an
ienumerable and then i continue to work
with that sequence it all gets loaded
into memory right
remember for working with something like
entity framework or link to Amazon or
link to some other data source that
supports iqueryable when I compose
queries with different statements I end
up composing the query and it's only
when I enumerate that sequence that I
make the call to the remote data source
parse what it should be returned the
data set that I want coming back and
then enumerate the actual items that
come back once I cast it to an
ienumerable that round trip happens I
will get back all that data put it in
memory and all further work on that
sequence would happen in memory now well
that gets really dangerous and why that
can show up easily if you're not using
var is notice that iqueryable and
ienumerable are in two different
namespaces so if you weren't thinking
carefully you might naturally just
gravitate toward ienumerable
declare that as the type because you
know that all linked queries work on
ienumerable
they come back that way and then
everything happens in memory if you
compose a database query out of multiple
statements using ienumerable
everyone likely makes a database trip so
instead of one trip to your remote
database and back you might make four or
five and when those later ones are doing
filtering with where clauses instead of
making one trip that brings back five
records you might make the first trip
that brings back 10,000 and then start
filtering and end up with five much much
less in less efficient much more painful
so because of that I would regardless of
what you think about how code reads
I would make sure that anytime you're
using link and data sources make
absolutely certain to work with var
rather than explicitly declaring what
kind of variable it is okay questions on
that one so go tell all your friends use
var immediately that's better
alright one of the other decisions that
come through in c-sharp that tends to
drive people crazy occasionally
especially if they've ever used C or C++
is it C sharp defined scopes rather
generously anytime you open up new
statements we'll try to define a new
scope it defines new sets of variables
and even though that the compiler knows
that a variable with the same name
declared in a child scope is different
than a variable of the same name and a
parent scope it doesn't let you do that
with one exception you can in
constructors you can have arguments that
match the name of fields or properties
but otherwise if you have a parent scope
you cannot use a name it's sort of
excuse me unique child scope you cannot
declare a variable with a name that's in
a parent scope even though the compiler
knows it just knows so for instance
if we were to look at this if I were to
you I now have this scope I've declared
a variable X is in a child scope here in
inside an else I tried to declare this
lambda expression and then use an
argument X which is clearly in a
different scope it's the argument to
that lambda inside that else Clause the
compiler tells me I can't do that
because I have declared x up above and I
cannot declare variable with the same
scope
now I also what's interesting if I
declare up there if we end up with the
same error and now where this plays in
and sometimes gives people confused in
terms of the compiler errors that you
generate is this code is also clearly
invalid I'm assigning X before I've
declared it but the compiler knows what
it is and just simply says that because
it's in the same scope it says that I'm
using that variable before I've declared
it okay even though it's in the same
scope now why do we care about some of
these areas okay first of all the
critique we often get is you know naming
things is hard I'm using the same
concept or from using these temporary
indexes to different loops why can't I
just use the same the same variable I
mean index should be index wherever I
use it and so on
well first of all you can't substitute
variables with the same name because you
can't accidentally refer to the wrong
thing everything's got to have a unique
name that parent scope is there
I can't declare something else with the
same name anywhere in it it turns out
this makes it easier to refactor c-sharp
for some of the tools because if I pull
a block out and move it to somewhere
else
that child scope has to have names that
all matter I can put it somewhere else
generally speaking
if I put it somewhere else inside a
parent scope that has a name you
immediately get the errors and how to
fix them it turns out it's also easier
to support lam disclosures and local
functions that way because they all
introduced their own scopes as well a
lambda expression has the scope with its
argument and the scope for the body of
the land expression
local functions have a scope that
includes the arguments and the body of
the local function and another scope
that includes locals declared inside the
local function so if it does pull in
those extra variables from outside you
know it's coming in as a closure and you
know it's the variable and the storage
from the parent scope so the decision
was made to make those scopes matter and
make everything named unique because
then anytime you look at a symbol it
should be very obvious where that symbol
is used and other places where the name
has the same name okay yes right that is
historical remnants from C because no no
yes yes it it's a mistaken C that we
wanted to carry forward because it was
comparable to the reason would be this
is if we look at the switch statement
which I hand up here is a switch
statement doesn't require you to have
the brackets around the blocks
okay so switches define if we look at
for instance if I look at the code that
we used on the scope demo where I'm
using if and else underneath it if is a
single statement which may be a block
and if it is a block it must be
surrounded by braces underneath else is
a single block or a single statement
which may be a block if we look at the
switch
well the rules are different under each
case is a block of statements since it
is a block of statements in that a
single statement it doesn't introduce a
scope you know i if you if it and if it
wouldn't break so much code I think we
ought to enforce braces there honestly
if you want to have more than one
statement but that's it is what it is
yeah I knew there'd be something like
that from you okay
now we get to overloads and base classes
so c-sharp and a lot of modern languages
have a lot of very interesting rules in
terms of overload resolution so me I'll
fit this to run the right one we need
that for that now
here we have a base class a derived
class with two different methods that
have the same name if we notice in the
base class the argument is integer and
the derived class the argument is a log
if I create a new derived object and I
call the message with an integer
argument which method gets called so
John you don't raise your hand at all
because we know he's on the size
Standards Committee he knows this all
right so who thinks that the method that
is in the derived class gets called who
thinks the method in the base class gets
called okay this should have been more
hands somewhere around there who just
isn't sure okay so isn't sure is clearly
wrong because the compiler always has to
make the same choice every time right
that would otherwise break that first
rule where we don't really know what a
language does now for those that
thoughts of derived method would be
called the one with that takes a long
why would you think that and sorry it's
an implicit conversion from int along
okay but why wouldn't it picked a better
one that's in the base class that has an
int okay so who of the people who
thought it would pick the base class why
would it do that because there's no
conversion okay let's go ahead and run
and if we run it
did you thing bring up a console app
that we can see how fine I left that
code that doesn't file sitting there
there we go so what it does is a call to
drive class version okay now the reason
it calls the drives class version is the
language accessibility rules say that
it's better to go for the closest class
possible rather than pick the best match
on any arguments so effectively what the
compiler is going to do is it's going to
look in type D which is a static type
for that object and it will immediately
say I've got a message that works you
are corrected part of why it can do that
is because it's an implicit conversion
and then say let's just do this it
doesn't even look in the base class for
a different method so let's do a couple
weird things to make this just so if I
were to change this we go to the D but
it's like you Claire this is a type B
now what method gets called
the one in the base class so if we run
that and they're still there we go and
now it calls a version in the base class
because the static type of that variable
is a base class object okay what we can
have a little bit more fun this is where
this part is hard and maybe there were
some mistakes here huh change us back to
bar let's make this let's leave that
there we'll add an overload here it
takes an int
okay so now you see I get a warning here
and I should introduce the new member
because I'm overriding a non-virtual
method in the base class it's okay so
now we should do we should go ahead and
call the derived class version again
because now I've created one in the
drive class that has the right version
and now it's going to call the version
that takes an int parameter because that
argument is better okay cool we think we
know these rules now let's change this
now to make this virtual and then this
becomes an override not new I want it
needed to change the other keyword sorry
NB thank you
and now when we run it it does call it
calls the overwritten version in the
drive class which we have a version in
there yeah all right now
excuse me calls the version that takes
the lawn this is the one that could be a
bit of a mistake still and the reason is
the rule thing that the message that
takes a long is newly declared in the
derived class the override is actually
declared in the base class so it's still
declared in the base class whether you
override it or not so it resolves the
same way so why are these rules in here
first of all don't do this okay let's
just start with that
but the reason these rules are here is
the idea behind this for the c-sharp
language designers is to try to do what
they could to make it a component
oriented language yes what if it was
from an interface enough from a face so
if I change the class VIII to an
interface that if it was an implicit
implementation would call the version in
the drive class if it was an explicit
interface implementation it would only
do it if it was cast to the interface
okay so to go through the rules here
what the language team was trying to do
and the reason for a lot of these rules
is to try to make a component oriented
language so in addition to being object
oriented light
language constructs the goal is that
base assemblies should be able to be
updated without breaking derived classes
that are in your assemblies that are
part of your application so BCL and
others can update underneath or running
application and you should not have
things break so
that gets to some of these rules if a
later version of the VCL introduces a
new method that happens to be a better
argument match for one you have it
should still call the one you knew about
right if you didn't recompile things
that should still call the version you
thought was there so new methods can be
added to a base class without breaking
overload resolution derived classes win
always the declaration one is well if
you think about it a virtual method is
declared in the base class so even if it
is overridden in a number of derived
classes the declaration space for it is
that base class so that was the reason
why they went there is that those should
in fact always come in that one spot now
this being a fairly small demo and a
small set of code so we can see it on
screen and analyze it this feels wrong
in really large applications where you
may be two three or four levels deep if
you use asp net MVC where you may be
five six or eight levels deep in an
inheritance hierarchy it really helps to
have the methods that you actually see
be the ones that get resolved rather
than ones that you don't see so that's a
lot of the reasons for these rules okay
now you can amaze your friends and write
code that John will have to answer
questions on Stack Overflow
all right and again the main thing we're
trying to do is look at the derived
class should enable you to determine the
best method immediately if you don't
find any match there then you have to
dig deeper new classes can be updated
and new overall is changed without
changing anything in terms of what it
resolves to so if you get a new version
of the BCL any methods that were in your
class should still be the ones that get
called also turns out the static
analysis for overload resolution is a
little simpler if we were following
along in the Rosalind repo we had a
feature in c-sharp six that was added
that was called better better Ness where
all these rules are in terms of picking
the better method that code got really
old and ugly and now it's better so we
have better bitterness we found a bug
and in c-sharp seven you'll see a
feature for even better better nuts
okay last big interesting one that we
get a lot of questions on what's a nice
tip in it is partial classes so you're
probably familiar with tools that
generate classes for you and when they
do that they almost always generate that
class with the partial class keyword so
that you can add your own implementation
of some methods and add methods to that
existing class okay
now the rules for this suddenly become a
little complicated because what we have
to do now is because c-sharp is single
inheritance there can only be one base
class described for that partial class
so either every file that declares part
of that partial class must declare the
exact same base class or it can omit any
base class I would recommend omitting
the base class because then if the tools
changes it uses a new base class it
doesn't break your code the interfaces
are very interesting and different in
that because interfaces you can have
multiple interfaces
any text file that adds to a partial
class can declare new interfaces that
that class must support
and this becomes a really interesting
feature but the critique we get is you
know this can be really confusing I look
at the declaration of a class I can't
tell for sure what interfaces that
implements I'm not even really sure what
base class it is because it may not
declare it and it's just hard you should
make them all the same well no first of
all we're not going to do that so what
we should say is well maybe we want
everything to be in the same if you want
to go right ahead you can read eclair
interfaces to your heart's content
the first thing I would recommend is
don't declare the base class on your
implementation for a partial class
because tools can change the hidden one
that I really like is because your
additions to a partial class can
implement new interfaces it provides a
much much easier way to build test
harnesses around tool generated classes
so let me show you what I mean so the
last demo that we put together if I look
at partial classes one of the most
common places that you'll run into it is
using a tool like entity framework so I
took this code right out of an entity
framework for demo so it's a blogging
context so it's an in any framework
class designed to work with the blog
engine so if we look at the context it's
going to have a DB set for blogs maybe
you have more than one blog on the site
and a DB set for posts individual blog
posts has the override that configures
it I'm running on net core so this would
be using sequel Lite if we ran a full
demo on this and you can see that we
have the model classes for a blog which
would include a list of posts and for a
post which would have an ID a title
content and so on and so forth now this
is incredibly hard to mock if I want to
write unit tests around all the code
that's using this it's truly painful
because the base class is dbcontext has
a lot of methods it has a lot of things
that are tied to a database
implementation a lot of them aren't
virtual it's hard to override them it
wasn't designed to be able to be mocked
out
in fact even the DB set really isn't
designed to be mocked out so what a lot
of companies end up doing is they'll
take something like this and they'll say
I'm going to write a wrapper around the
blogging context which implements some
interface I want and then I can defer
everything and call the methods inside
the context and I can mock that and do
all that that's a lot of work for one
it's also a rather leaky abstraction
right I can still probably get around it
and do something that I want and then
suddenly I'm writing untestable code so
let's think of an easier way to do it
well what I'm going to do is I'm going
to make my own interface that I'm just
going to attach to that partial class so
I define in my application context and I
have a couple different examples here
the one is with the DB set I'm returning
it as an eye queryable of blog which is
one of the interfaces that's implemented
by DB set because DB set itself is also
very very hard to mock and it's not
partial so we can't do the same trick so
I'm going to declare that to be an
iqueryable and the other one I'm going
to do is I'm just going to as an example
add the Save Changes method Save Changes
is one of the messages in DB context so
I can add that to my interface now if
you note I add my partial class here for
my blogging context I don't have to even
have an implementation for Save Changes
because that's already in the tool
generated code in production I'll just
call the version that's in blogging
context and if I wanted to for a but I
do have to do a little bit of work on
the posts and Z blogs because DB set is
different than iqueryable so I'd have to
and I have to massage the return type
there so I've written a method in the
interface then what I want to do is if I
take DB I can write my own mocking class
or use some mocking framework and I'm
going to declare that I'm just going to
implement that interface and I can
expand this to be anything I use in DB
context
as those are the things that I would
have to put together in terms of mocking
out this class so any tool that
generates a partial class I can define
the interface that I want as long as the
return values of anything in that
interface are something I can also mock
it becomes very very easy to work around
and just to add that capability for
classes that may not have been designed
with testing in mind and it ends up
being a lot simpler than wrapping it and
writing a whole lot of one-line message
and making sure that you never touch the
actual tool generated class anywhere in
your code questions okay and was that
we're getting reasonably close to the
end these are some of the most common
things that I've seen in terms of
questions on c-sharp where people really
wonder why did they design it that way
and I'm curious about what any of yours
are what things do you think are just
like why did they do that yes
I'm sorry
why do both read-only dictionary and
dictionary implement I dictionary I
don't know the answer to that one I
think that's more in the framework
itself other than for historical reasons
because the non read-only ones came
first this is really the the biggest one
there yes I see question over here yeah
yeah okay
yes why am I allowed to set an enum
value to a number that isn't in the enum
set that was defined for that I take the
lot of the original designs for that was
due in part for performance because it's
underlying data storage is an int you
know or a byte or whatever you declare
it to be so it's underlying storage is
that and in order to restrict it to
those values the compiler would have to
inject code to check each assignment in
order to make that happen okay so that
would get rather expensive over time
that's probably the biggest single
reason I think serialization was a bit
of a consideration as well but I think
the biggest one was the performance in
terms of making sure that enums are
actually efficient to use
right but that's that's still a closed
set so you could animate yeah right but
if the compiler knows it's a if the
compiler knows that it's a flag enum it
knows that it still has a closed set of
the values that it could take from that
yeah do you want to answer that one then
yeah I don't know the answer to that one
I is it that's not Arctic it doesn't
yeah I don't think it's in there
no well no I don't think it does you're
right okay I bet you can do that yeah I
trust you okay
okay others yes why don't we have
extension properties why don't we have
extension properties it has come up as
an idea a few times what's that I know
it has from a release standpoint it's
come up as an idea a few times one of
the harder things to solve there is
where to store that and to keep track of
that that would be the primary reason is
to try to figure out exactly where that
storage goes for an extension property
is and it has come up and it continues
to come up
it hasn't bubbled up to the top of the
list where it has been implemented and
the same thing is true with extension
indexers which is kind of cool the
syntax proposed for extension indexers
lets you type this more times in a row
than you would ever want to because I
could say see
I just make this
there which would be the how you would
extend righted a an extension indexer so
you get to write this a few times in
wrong that's yeah it has been it has
been looked at and it still is on the
table I believe there is a Rosslyn issue
related to extension properties if you
wanted to comment on it and add your
voice there C sharp seven is coming to
release so discussions are starting on
what will happen in c-sharp eight and
I'm sure that feature will come up again
other questions yes why did they include
the appalling backslash X in string
literals historical there's um you know
there's there's an interesting thing
there and I think and this is more my
opinion than knowing everything about
all the design meetings if you look at
the languages that are getting a lot of
adoption a lot of them the the curly
brace languages are getting art
generally get more adoption whether that
be C C++ C sharp Java JavaScript and so
on because for a large large number of
programmers at any of the times when
those languages were introduced could
read them and despite warts be
productive in them relatively quickly so
I think with all of those languages
beyond C there was a fair amount of
designs that went into saying I want
this to be familiar to the people we're
trying to attract to this language okay
go right ahead I'm sure where you're
going to on this one so this is the Mac
though - that's all right
have you got a brushing full no I
haven't right so if I have 3x equals x /
x 0 9 good ok string y equals and back
slash X 0 9 bad
those look like they're both tab
followed by good and tab fully by bad
yeah more than that no they're not
because b and a happen to be hex
characters and G and Oh ant so this the
second one is two characters long it's
equivalent to u + 0-9 VA followed by D
whereas this is for equivalent to u +
0-9 and sorry 0 0 0 9 good right I'll I
don't think that's intuitive no it's not
but it has a bit intuitive in any of the
other languages that did it either
what's up and see it was probably always
two hex digits right yeah
you would be the one to find us okay
any other question did you write an
issue about that though yes yes yeah so
there are two reasons for this the
question was sort of post as a statement
the new tuples are immutable value types
yes yes they are so the new pupils are
first of all the value types because we
avoid allocations okay which is also why
there are a lot more generic classes for
those she looked at the system tuple
that went up to nine and then the tenth
one was another tuple to add more it's
really bizarre and the new value tuple
there's I believe it goes up to 22 right
I think I haven't I haven't I haven't
stress it yet I think it's it's either
15 or 20 but there there's a lot so
that's why they are and they are value
types because then they can be worked as
value types we don't have allocations
okay why are they immutable because
we've always said value types shouldn't
be mutable or should be immutable the
reason they're mutable is as John says
just think of it as a bag of variables
the problem tuples are really trying to
solve is I want to return more than one
thing from a method right because we
already can pass more than one argument
to a method I don't need to apples there
I want to return more than one thing and
it doesn't have a name it doesn't have
structure it just has more than one
thing okay by making them mutable value
types a lot of syntax gets easier and
more natural and that I can declare the
individual variables I can work with
those individual variables which well
they're not mutable they're copied in
place with integers and such and then I
can return the tuple I can deconstruct
it the copying is generally simpler we
don't have to copy references
and as long as you don't use a tuple as
a key for a hash set or a dictionary or
a hash based container she's going to be
fine the chances that you would really
want to do that because they're an
unnamed type is really pretty low as
what we're thinking and I would say the
prescriptive guidance for tuples is that
I wouldn't make them part of the public
interface for classes it's certainly
legal not sure it's a good idea okay and
I almost certain canceling will cover
this tomorrow the names that you get
with value tuples only get added to
metadata if they're public otherwise
it's just compiler magic that takes your
semantic name and maps it to item one
and item two okay so they've become very
very lightweight and as John says if you
really just think of it as just I'm
returning more than one thing it's super
simple does that mean they break dynamic
typing no they shouldn't because you do
have the metadata on them for when
they're public yeah right yep
it would silly it would yeah it would
still work well once you once it's
dynamic you're not going to get the
intellisense on the type anyway right
well it works let's try that one yeah
I'd have to try that I haven't looked it
I haven't looked at the spec on that
part yet don't do that but and I might
not because the storage is still item1
item2 and so on yeah okay thanks for
probably one more question okay John
oh yeah why is the default literal sites
for 0.5
why is that do you mean 0.5 as a
specific number in general any literal
right the the general case was meant to
be that it was more going to be for
floating point math and use double
precision rather than specific ranges
and currency and such for decimals so
given the community at the time the fact
that scientific competing was probably
more likely than the decimal and
currency and that the decimal and
currency was going to be the more
special case they went with double yes
well it is one thing I would change if I
could yes in height what I actually
disagree with that but that's just me
the one thing I would change John's
John's would be sealed by default the
one thing I would change is in hindsight
I don't think I would have added dynamic
it's a lot of heavyweight stuff and as
it turns out it's been used a lot less
than I probably thought it would have at
the time but that's only with hindsight
honestly yeah that's probably the one
that I'm looking and with that thank you
very much I'll take any more questions
up here as we go description</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>