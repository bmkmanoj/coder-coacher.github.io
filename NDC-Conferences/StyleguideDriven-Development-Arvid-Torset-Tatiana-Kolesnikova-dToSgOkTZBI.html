<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Styleguide-Driven Development - Arvid Torset &amp; Tatiana Kolesnikova | Coder Coacher - Coaching Coders</title><meta content="Styleguide-Driven Development - Arvid Torset &amp; Tatiana Kolesnikova - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Styleguide-Driven Development - Arvid Torset &amp; Tatiana Kolesnikova</b></h2><h5 class="post__date">2018-02-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dToSgOkTZBI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">why name is that Jana and here is arid
we are from Norway but I was born in
Russia and my mother was part of a
Russian space program so my twin sister
and I grew up on a lot of stories about
space exploration and while preparing
this talk I remembered one of them what
do you think is the most difficult part
of training for American astronauts it
is an exact I idea it is an exam in
Russian language Russian language
training is a mandatory requirement for
all participants for all candidates for
American space program why
well Russian was the first language that
was spoken outside this planet if we
don't count aliens that's a huge source
of pride for me but it's hardly a reason
to make people in the whole new language
so this requirement has nothing to do
with history and it has nothing to do
with politics it's not Russia that
enforces this requirement it's NASA
so why in 2003 shuttle Columbia crashed
and that ended American own shuttle
program and since that time is the only
way for people to get to orbit and
return back is Russian spacecraft
silence now of course all controls in
say use are originally in Russian but
it's not such a big deal to change the
controls it's much easier than to make
people learn a language but according to
the agreement it is always a Russian who
is the captain of sails and so users
used to take people to the orbit and
return back and these are the most
difficult and the most dangerous parts
of all space expeditions and emergencies
happen and NASA realized that in case of
emergency the most efficient way for the
crew to communicate will be if
the captain and the command center speak
their own language and the rest of the
crew understands and is able to follow
the orders in this yes
captain and the command center no
English but in these situations not only
seconds but split seconds matter and
there is no time to phrase something to
think how to phrase something in a
foreign language there is no time for
translator of course so the most
efficient way is to speak your own
language and for this only purpose to
establish this most efficient way month
and month of training you see
considerable effort and quite a lot of
money is spent to make American
astronauts learn Russian in order to
establish the most efficient way for
people with different origins to work
together and this is the topic of our
lecture style that German development is
a new way it's the most efficient way
for people with different from different
origins designers and developers to work
together we are going to talk about what
it is how everything works but most
important are twerking this way we
should all cover this from both
perspective I'm a designer I'm
responsible for the design side well out
of it is taking care of the developers
perspective yes hello
software developers have talked a long
time about reusability of code and
write-once principle as a result in 1967
the object-oriented programming was born
the first object object-oriented
programming languages language was
implemented by two new agents in 1767 it
was called similar 67 the pattern is
than 50 years old and still going strong
object-oriented programming allows the
developer to join a set
properties and group the properties with
operations on high level it allows the
program to give the properties and
operations to an object meaningful names
as well as height internal data
structures and business logic you
probably all know all this but the
developers that's going to use your
object don't need to understand all
these internals then we have Model View
controller which is also a whole pattern
describes how the data is modeled how
its viewed and also how you access its
data and if you can even update back the
data if it's modified in its view by
learning and applying patterns
developers get into well-known ways of
how to structure the code patterns allow
us to recognize how to recognize the way
the code is crafted style guide driven
development is also about patterns our
pattern is how we define the structure
and the layout of elements equally or as
equal as possible on the design and the
development side we are taking the
designer into this development pattern
so how do we work now or what we see
happens very often in the project we are
involving we receive a nice-looking
screen or a set of screens and they are
called the final design and then you
build element by element out of that
take this element this button you use
bootstrap or some other framework tweak
some parameters and then you make the
parents fit the design then another
button
okay
okay let's hope it lasts and another
button and this has one pixel taller
than the previous button and then you
need to treat the parameters in order to
match the design this design this was
actual design received from a designer
that did not work with style guys so
here you see they are slightly different
but also the same and you see also the
difference in this one has capital
letters this one has not and then if you
see two similar elements this text label
here and this one here if you work this
way
most likely copy the parameters and then
you don't have any measures to reuse
them so then you just implement another
label and as a copy of the previous
element so here we have a lot of
instances and a lot of different
non-system none of these parameters are
standardized so it becomes a mess also
you need to reverse-engineer the rules
how these elements are laid out in the
interface and there is always room for
interpretation no matter how detailed
the specification is so this header is
24 pixels from the input below is it the
header that is has 24 pixels padding or
is it the input or do they have 12 each
and now it's not an input but a text
right below the header and the distance
is 32 pixels how did that happen you
need to analyze a lot of screens to
reverse-engineer each individual rule
like this one
and then you receive another set of
screens and there are some buttons that
are slightly different and some place
the padding's do not match the rules you
have derived off to the previous set so
you need to apply adjustment in these
cases this is the struggle people seldom
hear about because the developers just
suffer in silence
so working like this we cannot reuse
much of the elements we use the design
system is messy and it's very difficult
to maintain style guide driven
development is building the interface
not element by element but as a system
of reusable components if the elements
are standardized from the beginning if
they are truth in the library and we
reduced both by the designer and
developer we don't need to make them all
over and have tons of variations if the
design of screens come along with the
design system if the rules how interface
is built or made explicit there is no
need for reverse engineering so as it is
the pattern where we established a
design system and the library that
supports it library and the rules and
the key thing here is that both the
rules and the library have to be created
by both designer and developer and used
by both and now when I'm saying designer
and developer I don't mean two people
with these job titles it can be designed
team and the relevant team it can mean
design department development department
or it can be just one front-end that
does everything then it will be about
parts of his work so it's not about job
titles or quantity of people it's about
the work that the parts of the work the
aspects of the work that needs to be
done so what's the work we have to
establish the library and when
establishing the library you have to
understand what
components what elements you put in this
lettering so we need to break the whole
interface into these elements there we
have some interface and some of the
elements on this interface are easy to
see about me an icon a checkbox these
are the smallest components of the
interface we call them the basic
components the smallest standalone
elements of the interface so say a Dalek
is not a basic element because it can be
broken further on the buttons and the
text and background while a label over
the button is also not a element because
it does not exist without a button it's
not standalone
so the basic elements the foundation of
the library are the smallest standalone
components of the interface like this
what we do we call them once and then
put them in the library and they use all
over the interface great that's just the
beginning because the interface is not
flat it's not made only of one level of
components we see that combined together
up there smaller elements create
something bigger here's one here are
four others here is another one
these are more bigger building blocks
more complex components and they can
also be reused they're reduced here four
times when we go further we see that
this header includes this first a bigger
component inside so the level of
complexity of these bigger elements
differ it grows and as we go through the
interface we will see that it grows on
and on and our task is to establish to
understand this here key of elements
when we are looking at our interface and
this here key sometimes is described on
examples from chemistry and biology so
the smallest elements are called
atoms these red ones while combined
together atoms create molecules and then
there are organisms etc etc I will not
go deep into this topic of here kids
first it's a design topic
and it's much wider than the scope of
this lecture right and I will leave all
these molecules and all these atoms to
Natural Sciences and to design what is
important here is that the basic
elements the smallest elements and the
complex sellers there will differ them
only by this one measure and the
important see here is that the basic
elements are already globally defined we
already know what a button is what a
divider is what a checkbox is we just
have to recognize them on the interface
decide how it's going to look build it
and put it in the library while for
complex elements we have to define them
ourselves and moreover we have to define
them for every project because they
differ from project to project the basic
elements reappear almost in every
project that we face the complex
elements do not so that's what needs to
be done and the when we are starting
working on this library on this design
system it's the work that is done by
designers and developers all right we
have elements we know what we put in the
library what do we do with them we need
to understand what properties what
parameters that are defined by what
units we are using and how we measure
them and how these measurements change
depending on the content and this how we
measure their matters a lot
here's a button it has color it has font
color it has size now as a designer I
can define the size of this button at
the total width and total height I think
that this type of this elements I won't
have these sweets and that this height
but you in your head not knowing what
happens is my head may think that the
size of a button is defined by the total
width and the height of their label plus
paddocks and just by looking at a button
saying Zeppelin envisioned just in the
mock-up TNG's you do not know what's
happening in my head you don't know
which rules I
use when drawing this button and you
apply yours okay you have coated this
button and the plug put it in the
library applying these rules next time
you see this and it doesn't fit because
by your rules it has to look like this
so what you have to do you have to apply
adjustments to make it look like my
design and this is exactly what we're
trying to avoid we're trying to avoid
the situation when in order to put an
element in there interface you have to
apply custom adjustments every time
we're trying to achieve the situation
well you can take the elements directly
from the library and for that we need to
agree on how we measure things and I'm
not discussing now which way of defining
the button is best it doesn't matter it
doesn't matter that we do it the best
way it matters if we do it the same way
that's what matters
and the same is about responsive
behavior if you get series of screens
for one screen a series of screens you
do not necessarily see what are the
rules how things change depending on the
viewport or the content you have to
discuss the rules and explicitly discuss
them and then understand on both sides
yes okay one thing down properties then
we have to understand what are how we
shall call these things and calling
things elements with the same names of
course simplify the communication we
understand each other is no
misinterpretation but it's not only
about communication it's also about
helping to each other to understand the
structure and hear of the elements of
this type 'button primary basic small
button what type of element primary use
primary secondary we have to agree on
what types of use we have basic basic
who were small they had to understand
what is there what are the states of
this element small the size we have to
discuss we have to go through all these
parameters all these things in order to
establish the naming convention in order
to after that to name things
and this agreeing on the names forces us
to do this and one more thing that we
have to discuss is how the elements
should look and behave and the most
trait hold on sir is the elements should
look and behave the way the design has
decided but and you can implement
everything right but the question is if
you should I'm not saying that you
should influence design decisions I'm
saying that you have to help us make
informed design decisions because no
matter if you like custom components or
not for some people itself entirely
heads the more fun is to jump over it
for some of them is a trouble and all
this but no matter what is your attitude
whether you like it or not it's
additional development time an
additional development time is a
different development cost we have to
consider this and also it's sometimes
often increase probability of issues
it's sometimes reduce performance you
know that but by default I don't so when
I make a decision whether to put an
element in the design a lot how do I do
this because it looks cool and because
it's user friendly but also we have to
include in this formula the
understanding of complexity of this
element because what makes this slider
difficult for ios and android is that
this non-circular knob is it an icon on
this knob is it a wider background how
difficult it is making this I have to
understand this because this slider
also looks cool and is user friendly and
I can easily go for it too as a designer
but that's slightly different story from
your perspective so we have to agree on
this yes very often we go for complex
custom elements but in this case we make
this decision with our eyes open we know
what it implies so this discussion again
matters so these are the things we have
to go through when we establish the
lightning what the elements are what are
their properties naming conventions and
look and behavior and they bought a
thing to understand is that we don't do
this in one go we don't create the
library and then work with it we are
creating the library as we go we are
creating only the elements we need for
this current release current series of
screams and it's a continuous process
and establishing the library is part of
the work we have to work with it right
but that's your library this level is
built it's a front end library now I
don't I draw I redesign how do I work
with the old library when I started
looking for answer to this question the
only one available was this design
broken browser and this is a dead end
now you may think okay here's another
one that is afraid of coding know myself
I have some IT background and I'm not
afraid of coding it's not the concept of
coding just scares me away it's the
concept of designing by calling decide
designing by Cody is designed by
describing what you want to achieve
describing and that is the total
opposite to designing by doing decided
by direct manipulation design by doing
is the way all creative visual work has
been done since the beginning of times a
prehistoric man took a stone and apply
it to a wall
he sees the wall changed the color
whoops I can do yes I can draw on this
thing and here's a book he's so pleased
swirl change the color
okay I'm not drum I guess we have to
change the cables no
let's see you can admire the blue sofa
the cable seems a bit broken yes yes we
were warned that cable is not great nice
was about the boo
nothing happen
we have alternatives I guess we shall I
guess this must it's not about the
laptop it's about the cable that's here
it's not about us
well it's the cable that didn't broke
and then it's not our cable so thank you
but it does it will not work well last
time when we were giving this talk their
slides were stretched and all the black
sides were getting lower in the colour
so we've been doing this before so
that's not the major cause my facing we
have things like it was the power supply
of this distribution down here that was
a bit fishy but now after changing the
cabling try to switch back to the old
one can you just try to jump back to the
well by now turning on the stage
okay okay
there's a booth don't touch anything
please okay back to the way what I was
discussing so when this prehistoric man
was drawing this bull he saw they won't
change the color exactly as he was
applying the stone okay let's continue
no chance a child takes a pencil and
starts drawing and he sees the paper
change the color exactly where he's
applying the pencil
he draws more and the color becomes more
intensive it's direct manipulation he's
creating with this drawing and the
things happen exactly where he's
applying this manipulation a sculptor is
changing manipulating with a some
modeling clay drawing in design software
we are doing the same thing we are
changing rearranging the objects it's a
direct manipulation while when drawing
by code designing back home designing
but in brows it's like you line for the
artist and suggest him to describe how
he wants the strokes to lay in the
canvas then open their eyes see the
result and then describe the changes he
wants to make
it's a funny experiment you can draw a
smiley face like this but it's kind of
difficult to draw a Mona Lisa this way
you have to see what you're doing and
you have to do it where you are doing it
well I'm not saying that we draw Mona
Lisa's everytime but when we need
something a bit more complex and well
understood well standardized view we
need an ability to draw to design by
doing this is why designing a browser
will not work well I'm talking about it
now so apparently we have found a way to
work
the way to work that we have found is we
create a exact replica of front end
library in our design software sketch
and a'dope allows this and the we have
the same library elements they look the
same they are structured the same way
all the inheritance all the parameters
are the same both in the in your
elements in your library and in mind
this is how a button is described
present on the device
no it's not about the resolutions about
the cable well I guess we shall try to
continue as we are and you shall just
think hope that is we're gonna work yes
so we create the exact replica of front
end library in our design software and
synchronize where it matters and the
main change that happens is the change
in my workflow I'm allowed to draw only
with elements from this library I if I
need something new I created something
new in the library and then use it in
the mock-up and then send to you both
this.l both this element and the library
so as a result you have the mock-ups
that can be implemented directly from
what I sent to you and how they're going
to be implemented are we don't oh yes in
style guide driven development
components are a very useful
construction pattern the components
allows us to write maintainable code we
combine styling new definition
properties and logics for basic or
complex element in a separate part of
the code the easiest way to go is to
select the framework that supports
components natively so if you do not
select such framework that supports it
you see force sort of to organize the
code in a similar way the basic
principle about components I will show
you in a very trivial example from
angular if I'm lucky so the component is
a construct to keep together relevant
information how to render it state an
operation including how its styled this
is a component
very basic in this section we have the
template section defining its view how
its rendered it can also contain
interactions there is no interactions in
this basic example a bit annoying this
here we also have some basic styling
elements
it's nothing revolutionary just plain
HTML tags here is the useful stuff for
the end user and here are the parameters
that are fetched from the data object so
yes a very basic example here you see I
may be a more piece of code that is more
real life so here is from a real
application where we define this
component in this code where we also
have a more advanced styling and layout
grid system and also some what happens
if you click and type in the dialog and
here is part of the implementation code
behind this component and it has some
data and it has some functions to
manipulate its data so to summarize
here's how the component pattern is
useful styling new definition properties
and logics for basic and complex element
in separate parts of the code the
styling system is important here the
styling can change the visual appearance
and the layout of the components without
changing the components themselves so
how do we transfer styles into real code
there's a design system that we received
from the
we start by laying out folder structure
in our code and we typically use this
layout bundles is the term to be used
for complex elements a combination of
basic and or other bundles here is the
same example custom values the preferred
giftcards it's a complex element is a
bundle and consists consists of this
input box and two buttons one on each
side and of course we can reuse it also
for the quantity stepper the same
component elements are the smallest
useful interface component like buttons
and labels and the Buy Now button is one
of these basic elements the text of the
button is not part of the element
definition since every button can have
different text but all the rest is they
are sharing the same definition the root
folder is where we put all our global
definitions I will come back to that one
a second this file loads the other
structure so it's just to describe that
back to the root folder I repeat all the
definitions and we define parameters
once and let all the elements inherit or
refer to these parameters the hierarchy
of the parameters should reflect the
design system
so here it would color definitions
padding margins other layout parameters
from definitions green systems which all
elements implicitly inherit and utilize
so how I'm going to show you the link
between the design system and cold
northerly directly here we see the color
definition from the design system then
we code this one-to-one and define each
color only once so let's follow the
primary color throughout the application
or the code so here in our root folder
we define something called link color
and that is our variable this allows us
to gather all these into organized chunk
of or a place where you put all these
variables so it's easy to change the
whole style and then eventually we put
this link color into the a definition
since it's a link so this is how so
default a's become having this color and
if you need to change that you need to
make an override of these definitions
and then we can if we are not happy
about this color then of course it's the
designer who decides that we should
change it then you change here one place
and all the interface will have updated
its primary color let's have a look at
the typography definition and that is
defined in the root folder - and but we
have a separate folder for that and here
is how we define the font so we use
something called a golden ratio to
define the phones
so it basically calculates the different
types but pay attention to that we have
the namings here coming from the design
and you see the h1 tag is called main
title then we calculate the font sizes
based upon this golden ratio also the
line height and these calculations are
reflected in these values so we don't
hard-code these values we calculate how
the font should be how the different
sizes are laid out and how we have four
parameters that we tweak in order to
change font sizing let's follow the h1
tag and the main title throughout the
code we have font size definition and
line height the definition here and then
we have intermediate layer that allows
is where we define all the parameters
and then eventually we put foam size and
line height in here based upon these
ones
and here you see also its use in actual
code and here it is ending device so
this is how we implement styling in our
library and we can take our library even
further we can make separate screens or
views that shows elements and bundles in
a preview a live style guide is a
separate set of web pages or separate
app where old elements are used in which
is used in the product are listed and
shown it can be buttons basically all
all elements can be laid out here so
that people can preview them and that is
the live style guide this example is
from MailChimp so let's summarize the
advantages of style guide driven
development the rules are automatically
applied to new elements when they are
created if you need to use overrides
it's an intentional action so it's very
hard to make mistakes like accidentally
making about mid roam size absolutely
different color because of typo in the
hex code and so on easy to make changes
when doing redesign we use the rules so
we can change the interface in a smooth
way also for white labeling having
design rules make it very much easier
especially if you have this folder
structure so we can replace chunk of
parameters and the way we organize the
resources and rules is very structured
with std and it improves the quality so
let's need to verify design mistakes
much more consistent because everything
is mathematically correct when working
the old way when you drive the you way
from a mock-up and reverse-engineer it
you have much more freedom how to break
it down to elements and understand the
size and position and mistakes they
happen all the time in this case there
are more or less eliminated so quite a
lot of advantages for the developers as
our main job we run a development
company that builds different products
for IT clients products from different
industries different scale small ones
big ones and also the stage they come to
us differs a lot so we start some
scratch so may overtake from other
developers and in the last part of the
lecture we're going to talk about how we
train new teams to start a study in
projects in different stages either they
are new ones so let's hope it still
works so when we start with a new
project what is important we start
communication between the design side
and development side at the stage when
we have only wireframes it can be that
level of very rough sketches it can be
more refined wireframes we have to
understand what at what are the elements
and they are visible already here
here are some buttons here are some
icons so we need to receive them rather
early because these we start with basics
we see them rather early because as I
have said in my previous section the
basic elements show up on every
interface or the majority of them and
they show up rather early so we start
with discussion on the basics between
the front ends and the designers and we
do not touch the appearance what we
discussed the naming convention the
structure the parameters the limitations
so that when the designer
back to the wireframes and refines and
applies the visual style in whatever
form we have it and goes to more
beautiful the variation of this
wireframes and creates this element in
the library these things the naming
conventions the traction everything is
already defined and it's already there
so from the beginning I'm drawing
correctly from the beginning and wrong
with the right elements and for that
when starting a new project we have to
start very early not waiting for the
final design to break it already we have
to start early so basically that's the
main and that's the most important
probably the only rule that we have to
remember about studying the pro the new
project the rest is close to what I have
described in theory when we have a
existing project product existing
interface then things become more
interesting right have a product itself
to understand to make sense of we have
to derive the system that is already
behind the existing interface and most
probably you'll have to clarify this
system corrected and minimize it how we
do it I will show on an non-id example I
have a son and like kids of his age he
plays a lot with Lego these are the cars
that recently stood on his bedside table
by just looking at this course it's
difficult to see what elements they
built from how many of them they are
what is their structure how many of them
repeat themselves and we have to derive
the system from this we have to
disassemble this cars
luckily my kid was curious enough to
count these elements so we have
disassembled them and they left one
instance of each brick or wheel or
whatever on the table and here's the
result one instance of which 174
elements for these four cars and these
are only unique elements so this gives
us quite good overview of what's
happening here we would try also try to
group the similar elements together kids
worth helping
there was not complete success but we
tried and that is what we are trying to
make for we have to make for the
interface and this is called interface
coded with screenshot all the views are
as many views as is humanly possible of
the interface and we need to capture one
instance of each UI element of each
element that we see here and put them in
some document google doc powerpoint
sketch file and this is part of a
interface audit / security app that we
were mmm building and we have pretty
good overview of what what's happening
in this part of the elements and for
example we see that the buttons here
there are very many of them far too many
it's a very small app very few screens
so there are far too many buttons so
what we need to do is to systemize it
and to try to arrive to a smaller set we
need to see if there are two or several
same or similar looking and behavior
elements that we can merge together so
that instead of several we have one if
we can do without some of the variations
we did the same as lega and here's the
result 60-69 elements ported saw few
bricks no because these are the cars
that can be built from these 69 elements
from 174 he built this from 69 he built
this this is what we are trying to
achieve for the interface to arrive to
the minimum set of elements that will
allow us enough flexibility in the
result so that we have the possibility
to have varied views but at the same
time they visually consistent and the
basic the base of the elements is as
small as possible so this is the goal
and - oops to arrive from this for this
specific product we arrive to this and
so the goal of this
stage of when they are working with a
existing interfaces is to understand
what we have and to understand what is
the system we want to arrive to what is
this minimum set of elements but then
it's what I want to arrive to what US
designers won't arrive to what we have
the product how do we actually go there
how we implement this depends a lot on
the implementation and then it's always
turn to tell about it
yes how do we integrate gradually the
style guide driven development in
learning 16 code base all software that
has been around for a while has legacy
probably all know that it has most
likely been maintained by several
developers and several problems can be
observed in these cases there are
different levels of hard-coding values
colors etc forms margins are scattered
around in the interface and not
standardized of course that leads to
problems if no reusable components are
used in the previous interface that okay
obviously there you have to make new
stuff when you make new screens and when
the code is not made for reusability we
see that since it's copied and not to be
used it's very far from don't repeat
yourself the more copies of an element
of course the more you have to search
for them and fix all places and it's a
lot of testing and a lot of feedback
loops in order to fix all the problems
the original design system is either non
existing or has been applied in
different version
time so the result might be a mess
implementation of the user interface and
makes it hard to do substantial changes
when can we start with study by driven
development in an existing code base
it's never too late so what about today
start with making standard elements
locally very currently make changes try
to extract the global parameters and
make a library of elements all the ones
that you are currently changing like
this example here is an actual design
screen from the from this personal
safety application the button and other
UI elements is them made in a library
this way the standard resize the
standardization of the user interface
starts to evolve and since this is a
small application we did just apply all
these similar buttons all across the
interface before we released it and the
first time you are implementing here you
have many parameters already that you
can put in a global section primary
color typography to name some of them
and if the designer is are available
discuss with them how to how the design
system is supposed to work when the next
part of the user interface is to be
changed we have more tools in the
toolbox and we create components of the
new elements that we see on this new
screen so starting as 2d with an
existing project begin to standardize
parts of the user interface you
currently change and iterate over this
what about the new product so if you
receive the design from the designer
spend some
reviewing it and discuss it with the
designer like tatiana has mentioned here
and organize the global parameters so
that you bring them to one place
understand the elements and bundles you
go in and look at the different more or
less complex parts of the user interface
and try to group them logically and with
all elements and bundles into the
library to summarize what we have talked
about let's say if you need to go from
point A to point B you need a car in
Norway electric cars can drive on bus
and taxi lines so it's it's faster and
they can park cheaper and the fuel cost
is also much lower and it's more
sustainable model from the global
perspective yes you can also buy a
traditional diesel or gasoline car and
it will serve the purpose it will take
you from A to B but it does not have the
advantages that I have just named the
advantages of style gradual development
are the same it's faster cheaper and
more sustainable thank you
can you repeat the question what the
mechanism we use is we try to name
things the same way and we try to
organize the hierarchy in the structure
the same way in that way it falls into
place in both sides or yes yes yes we
don't have direct connection as today it
might be that we do that in the future
follow-up question to the previous one
how do you verify that the code
transformation has been successful from
the mock-up to the final version so I
mean pixel per pixel verification and so
forth
pixel perfect at least in the products
that we are currently building we don't
have those harsh requirements but if we
follow the style guide this is much
easier to get close to pixel perfect or
pixel perfect if we collaborate this way
if we understand how what properties
belong to what say like are we described
about the padding's of the elements they
by just applying an element on the
element on the element with the correct
parameters they just fall into places by
themselves because if we describe if we
define these elements correct
then this dynamic content
sticks together seamlessly without
verification of everything so that's the
goal - there was some question over
there this is the beginning of a little
microphone I'm just curious about about
the parameters just mentioned if you
know if you for instance suddenly you
have to support the site of the site in
Chinese and your pods actually explode
so we need to support this any Chinese
well we can also decide that we need to
support something in Arabic that starts
from writing from the right in this case
we shall have to understand how there
will be transformations in one of the
screenshots where there was
transformation rule between the web and
the mobile in this case there will be
transformation based on the language or
based on the direction of the writing
but then it will be we understand what
is to be transformed described these
rules and then apply them again on both
sides and it's much since we already
have a reasonable structure in there in
the styling and the components then it's
much easier job because we have we know
where we must apply our changes and then
we sort of know that it doesn't break
all over the place so showing was using
roast finding code have you any
experience with using the designer in
the iOS where you want to use the
constraint without programming them but
still want the calculation of the forms
and the views we building some products
are in eyes yeah and we still use the
designer for some of the things welcome
we don't make a very native something so
when we are building the product of
course if you make a native then there
is a system already in this case it
probably will be the part of the eye
developer work to correct this to make
this consistent with the design so
probably the designer part of the work
was smaller but in all our products we
still have we have dual design for
Android and iOS in this case we need to
see to make a compromise between our own
style the iOS oriented style and the
Android style some of the elements do
differ for different platforms but we
trying to understand where we can keep
them similar but the design in this case
is at least in our cases it was still
necessary but we want to use the same
thinking around how we organize the
parameters and we are currently now
preparing one our apps to white labeling
as SDK so we take all the content of the
app deliver to third-party and then they
must be able to either reuse our
components and apply different styling
or they can implement completely new
screens by themselves but if they are
using our components obviously they need
to change the set of parameters that so
that the interface doesn't break when
you apply new parameters there thank you
first for the talk it was really very
informative do you guys have any
experience working with multiple teams
who then are contributing to the same
pattern library and maybe you could
speak to that as far as a lot of this is
a commitment right - speaking the same
language using the same language and
I've experienced a lot of disruption
when you have multiple teams trying to
contribute to a single pattern library
and then the second question is about
third-party application integration and
that sort of crashing into your pattern
library multiple teams when I was
started looking at this question this
contribution from multiple teams at
least at the time when I was researching
this was covered by other lectures
people talk about how we do this for
corporates for big corporations and in
this particular example we try to
concentrate on doing what works needs to
be done not
the rules are that contributing to this
so you're the answer to your question is
we have some sometimes you have several
designers working on or successively
working on the same system we are not
writing huge projects that are that need
several design teams but we have this
sick sequential work for from different
designers when we need to ship them
around but the thing is that we train
them we train these seams ourselves we
train them thinking this way and that
helps to do this correctly for different
projects and we have a code core that is
sort of replicated across different
project and the same core is used for
ember angular so it's sort of adaptable
we are not so much into you try to avoid
tiny too much into one framework so this
core is reused across different projects
so the main thinking behind it is the
same but the level of implementation
might worried we are not yet
synchronizing all different project into
one but we are I guess we are still in
the phase of where we develop this core
but we will standardize it once we think
that is sufficient but that works well
for us at the moment then it allows us
to also push everything further
have you had any experience implementing
this approach in an existing project it
so has there been any conflicts or
problems communicating this approach to
the client in sense of additional
expenses costs and so forth well yeah
what we see on the cost side is that if
we because we have spent two years now
meant that they are not working together
and we started our work by looking at
Linda Valene business development and
user experience process and agile
development tie everything together
so that's how it started and if we are
using the lean approach to also applying
style guide to existing product it we
see that it's easier to to make change
and it goes faster once we have learned
this but we have spent some time
understanding how we can do this
smoothly but now it gives much better
result every time we have shown on this
personal security app we don't sell the
idea let's make a design system because
there isn't set it to be built this set
of features say onboarding for the
onboarding part we need the buttons we
need forms we need labels and these are
the elements we start standardization
from as Alec has shown this screen had
had inputs buttons we sub we code them
for this specific screen so we're making
a job for this specific screen for this
specific part of functionality and then
reusing this library elements
substituting in some other places of the
interface it can be done in one go it
can be done in many several many goals
but it's not effort just to establish
the library again we are doing it
continuously that's how that's what
simplifies selling to the business
owners
hello thank you for the talk I was
wondering if you could tell me or if you
can highlight some of the advantages of
something like bootstrap something where
you can agree that we're going to use
this style of button for example and
then you can tell developers that and so
and then you can decorate your HTML with
it so so that would keep you I can
answer
we are not specifically targeting one
specific framework so applying these
patterns can equally be done in
bootstrap what we experienced is that if
we use too much of the thinking that has
come from other places we will meet
boundaries and that is the feedback from
our front-end developers that ok
suddenly you meet a problem that is very
hard to overcome and because we use a
framework that has its limitations so
this will work with bootstrap it's a
good way of working so use bootstrap if
you want but we have organized it
slightly different yes
naming consistency that things are
equally thought about on the design side
and developer side all these things
suddenly things becomes clear yeah I
guess no more questions right oh there
is something
questions I would like to know more
about the limitations that you may
encounter in a system for example
talking of reactive pages so size of
elements that may change under different
conditions or when the data may be very
long or or change the shape of your
element do you design and screen for any
possible situation or also for
animations things that may change do you
have a establish had some rule to do
with this when it comes to a change of
the content I've described little when I
was describing the buttons how we
measure in how I understand how these
changes what happens if the element the
content changed we understand the rules
how this element is defined based on the
content and yes I understand that for
example a label can be 10 lines long so
we established for ourselves what is the
limit and we established for the users
say if there is an input or some text
that users can input with ok count how
many what is the maximum number of
symbols that can be used here in order
not to break everything then we said
this limit on the front end and that's
it
so we optimized the desire ok it works
for this it works for this it works for
this ok then these are the rules that
works for all corner cases and it works
for everything yes we have obviously a
grid system and we also have a system to
detect desktop and more and more narrow
to mobile display so yes we take into
account this and we must be careful when
the craft components that are gonna
adapt to different screen sizes
obviously but we find it much easier
when we are using this system anyway the
rules were cooler cases they work for
their main stream maybe you can try
applying the rules to a different screen
and see if everything works yes you
weren't created too
all the time thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>