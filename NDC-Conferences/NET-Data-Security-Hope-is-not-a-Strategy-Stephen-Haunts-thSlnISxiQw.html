<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>.NET Data Security : Hope is not a Strategy - Stephen Haunts | Coder Coacher - Coaching Coders</title><meta content=".NET Data Security : Hope is not a Strategy - Stephen Haunts - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>.NET Data Security : Hope is not a Strategy - Stephen Haunts</b></h2><h5 class="post__date">2016-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/thSlnISxiQw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay thanks for coming along everyone my
name is Steven hunts and this talk is
not net data security hope is not a
strategy so a little bit about me first
so I work for a small start-up in the UK
called buying butler where we aim to
make complex purchases like cars very
simple for our customers while also
providing providing high quality leads
to dealers and we also do a lot of work
with insurance companies in handling
their total loss claims and that's kind
of relevant to what I'm talking about
today because we work with a lot of data
from insurance companies and a lot about
is personal information about how
different customers so the security in
the custodianship of that data is very
important so I'm also Pluralsight author
and I've written one debate on six
courses now working on my seventh and
one of them is about cryptography and
dotnet so it kind of goes along with
this talk and I've also written several
books for the sink fusion elearning
library so we're going to cover quite a
lot of material quite quickly today so
what I wanted to do is just make you
aware of some resources you can use
after this talk should you want to
follow up on any of this so firstly is
my book cryptography and net succinctly
the books completely free I'm not trying
to sell you anything you just go to the
sink fusion website sign up and download
it and that mirror is what we're gonna
be talking about today and also have the
cause practical cryptography internet on
pro-science and that covers what we're
going over today but it goes into a lot
more detail and it talks about the wire
as well as the how how to do a lot of
this stuff and if you don't have a
clever site subscription I have some
cards which gives you one month free
access so feel free to come up and grab
one after the talk
okay so I strongly believe that as
developers is your responsibility to
help secure and protect your company's
data and a you just have to look at the
news each day or each week and you hear
new data breaches that are happening and
it's getting quite serious so taking
responsibility for your company's data
is more important than ever and
typically companies tend to make lots of
excuses now I've heard a lot of these
excuses in companies I've worked out so
you know we're too small to be hacked
no one's gonna bother with us that's not
necessarily true it just means you're
potentially an easier target and we have
a firewall no one's gonna get out get
through that and get to our data well
not necessarily it's great that you've
got firewalls in place but what about
your internal operations staff if you
have any disgruntled employees who can
get access to your data and try and
steal it and everyone I've heard before
as well as no we've never been hacks
before so why should we why should we
take this seriously well yeah just
because you've not been hacked before
doesn't mean so you won't be in the
future so I truly believe the hope is
not a strategy when it comes to security
hoping that you won't get attacked or
having any of your data stolen is not a
good strategy for success so how many
people have worked in a company where
you've got a deadline looming and you've
got lots of features you need to get in
and insecurity just gets pushed further
and further down the list of priorities
to get product ships has anyone had that
scenario before I've had in just about
every company I've worked at and you
know as a developer it's kind of your
responsibility to try and push on these
things and try and stress how important
is to make sure security is not pushed
to the bottom of the pile okay so what
this talk isn't about it's not about
deep mathematics or how a lot of these
algorithms work yeah we would not be
able to cover that in an hour and it's
nine o'clock in the morning I'm sure
nobody wants to see lots of complex maps
it's talking so isn't about crypt
analysis so cryptanalysis is sort of the
art and science of breaking code so the
sort of things that our governments
probably spent a lot their time doing
every day that's not what this talks
about
so what this talk is about is about
people like you and me who are regular
developers we work for companies and we
produce code they in day outs to provide
value to our customers so a lot of the
code we're gonna look at today and talk
about is based around the dotnet
framework I suppose you can now call it
the traditional net framework so
server-side web api is WCF services or
client code so you know winforms WPF
applications all that sort of thing but
just because we're talking about
Microsoft the API specifically in this
talk a lot of the principles we're gonna
discuss are kind of relevant across any
platform so the principles are all the
same the api's might be slightly
different but what you're trying to
achieve is effectively the same across
different languages so Java Ruby PHP
Python node the principles are exactly
the same okay so what we're going to
cover so we're first going to talk about
random numbers and why they're so
important we're then going to take a
look at hashing and hash message
authentication codes we'll then take a
deeper look at secure password storage
and password management's we'll then
take a look at symmetric encryption and
then we'll look at asymmetric encryption
with things like RSA and then we'll look
at digital signatures and that will give
us a lot of the building blocks that we
need to go ahead and build what is
called a hybrid encryption scheme so
it's using a lot of these building
blocks together to create something more
powerful okay so what is cryptography so
I think it'd be a good idea to cover
this especially if any people have
accidentally walked into the wrong room
and too embarrassed to walk out so
cryptography is basically about
protecting information and generally
that's done via encryption and when you
encrypt data you have encryption keys
and that encrypted data then becomes
what's called ciphertext so this is sort
of what we're talking about with
cryptography and so the art of trying to
break codes and so work out keys to
decrypt data is called crypt analysis
but there's kind of more to cryptography
than just encryption so there's four
distinct pillars that we look at with
cryptography so there's confidentiality
this is what we typically think of with
cryptography
I have some data I encrypt it with a key
and that data's completely scrambled no
one can read it but also we have the
concept of integrity so if I have some
data and I send it to my recipient has
that date have been tampered with or
corrupted in transit so we can use
cryptography to help us and with dates
of integrity also we have authentication
so I have some encrypted data you know
am I allowed to view this data am i
authenticated to see it and also have
your non-repudiation and this is all
about proving that you have sent an
encrypted message so it's kind of
similar analogy to a contract so if I
send a contract to someone and they then
try and dispute that I sent them that
contract by using non-repudiation we can
actually prove that it was after sending
that contract to them so cryptography is
pretty much everywhere you can't switch
on a device or do anything about any
kind of cryptography being in place so
you know online shopping if you're
buying stuff off Amazon or any of you
have a favorite websites you have the
little padlock in the browser I hope you
have the little padlock in the browser
ATM machines when you're drawing out
cash from the wall there's a
cryptographic handshake that goes on
when you put your PIN number in between
you in the bank mobile phones these days
I mean that's obviously a very hot topic
at the moment especially what's been
going on with the FBI they were trying
to break into the San Bernardino killers
iPhone so a lot of these phones these
days are heavily encrypted
also there's uses like Bitcoin so
Bitcoin as a currency is a cryptographic
protocol that's kind of another another
use for it and another example of
cryptography is in voting and vote
machines so proving that you voted
you've only voted once and using
cryptography so that you can't cheat the
voting system
okay so let's start off by looking at
random numbers so random numbers are
effectively one of the most important
primitives that we need when we're
dealing with cryptography and we use
random numbers generally for creating
encryption keys and a good random number
needs to be truly random and
unpredictable now traditionally in
dotnet when you're doing random number
generation you might use something like
system dot random and you know that's
okay if I trying to do same simple like
a you know simulating the dice roll or
some lottery numbers for example but
when you transgenerational cryptographic
keys system got random is not good
enough and it's also not thread safe our
system dot random e gives the appearance
of randomness but actually it's very
deterministic so if you don't change the
seed every time we need Craney random
number you'll get the same set of
numbers out of it so if it's ography
it's no good so in dotnet there's a
better class called RNG crypto service
provider and this lives along with
everything else were talking about in
the system lot security cryptography
namespace now RNG crypto service
provider is a lot slower to run and
system dot random but the numbers you're
going to get out they're going to be
non-deterministic which makes it
excellent for generating encryption keys
so you'll see examples as we go through
the talk where we generate 256 bits or
32 bytes random numbers which we use as
keys now RNG crypto service provider
it's not all influenced in.net it
actually uses the underlying
cryptographic platform in Windows so the
same sort of things that you'd use in a
lot the C++ or the operating system it
sort libraries
so orangey crypto service provider is
very easy to use and this will be a
common theme everything we're talking
about today is actually very easy to use
so in the looks on bit of sample code
here we have a method called generate
random number but we pass in a length so
that length is the number of bytes we
want so generate so if you want the 32
byte random number you pass 32 into that
we create an instance of the crypto
service provider class and then we
initialize a new array to the correct
length that we want and then we just
call get bias and then we return that
byte array so actually generating our
encryption keys is as simple as those
few lines of code so moving on to the
next part in our sort of stack of
primitives you want to look at we have
hashing the hashing you can kind of
think of it as a bit like a digital
fingerprint of a piece of data so if you
have a piece of data be you know a byte
array of date or a PDF document et
cetera if you generate a hash code or
what yes so if your generates a hash
code of that piece of data you're going
to get a code out the end of it which is
effectively the fingerprint for that
piece of data if you then go and change
that original document in any way and
then we calculate the hash code that
hash will be completely different
so with hashing there's kind of four
kind of requirements that we need from
hashing so first of all a hash needs to
be easy to compute so I have a piece of
data run it for a hashing function I get
hash code out the other end they should
also be infeasible to generate a
specific hash so you shouldn't be able
to say what if I have this hash code
here what's the data I need to create
that hash you shouldn't be able to do
that it's it's the other way around you
have a piece of data you generate a hash
code well you run it through a hash
function and he generates a hash code
another requirement is it should be
infeasible to modify the original
message without changing the hash so as
I said before if you have a piece of
data generates a hash code you think
just changes one bit of that data that
hash code should be completely different
not slightly different but completely
different and the final requirement of a
good hashing algorithm is it should be
infeasible to find two identical hashes
so you shouldn't have you have to get
one piece of des so general
hashcode have a second piece of data and
generate exactly the same hashcode
that's called a hash collision you
shouldn't be able to do that so hashing
is what we call a one-way operation so
once you generate a hash code you can't
then or you shouldn't be able to then go
back to the original message whereas
encryption as you can imagine is more
like a two-way operation so being creepy
so they took with a key then we can use
the same key to decrypt that data so
it's two-way is reversible because
hashing is only one way and the most
common hashing algorithm that people
have probably heard of his md5 and it's
been around for a long time but since
1991 and what this does is it produces a
16 byte hash value it was designed by a
guy called Ron Rivest but probably this
is in 1996 a hash collision resistant
vulnerability was generated so someone
managed to generate the same hash with
different values or different pieces of
data being passed into it so md5 is a
hashing algorithm these days isn't
really good enough to use but I still
mention it here because it's if you work
in a large organization like a bank for
example you may still have a lot of
older legacy systems you need to
integrate roof and they may still use
md5 so an example of that I used to work
for an internet bank in the UK and our
back-end banking platform was a old
as400 mainframe system and whenever we
sent messages to and from that system we
had to generate md5 hash codes so it is
possible you still need to use them but
for a new system you've been want to use
md5
okay so maybe our firm d5 then we have
the secure hash family or the char
family of hashes and there's kind of
three versions of this there's sha-1
which generates 160 bit hash function
and then there's char 2 which can
generate 256 bits or 512 bit hashes and
those two are both implemented in the
dotnet framework but there is also a new
one called char free which is now
available so sha-1 and char two were
both designed by the National Security
Agency in the United States and you know
rightly or wrongly that makes some
people a little bit nervous so there was
a there was a competition
a while ago and the winner was announced
in 2012 to find a new variant of the SHA
algorithm but she's non NSA based and
the winner of that was an algorithm
called always get it wrong is it kick a
coarser sack
well quite sure how you pronounce it and
become a this isn't implemented in
the.net framework but you can get some
open source implementations of it maybe
you want to trust them or not it's kind
of up to you I imagine it I'd be a
matter of time before marks off
implements it in the framework but for
what we're going to talk about today
we're going to look at char two and char
256 so it's very easy to use so in our
little method here we we pass in a byte
array which is our data that we want to
generate a hash for and then we call the
static method creates from the sha-256
objects and then you just call compute
hash i was passing in the data onto hash
and then you get a byte array back which
is your hash code so gains very very
easy to use so moving on from hash in to
the next level we have what are called
authenticated hashes or hash message
authentication codes or H max as are
often called and conceptually this is
exactly the same is like a sha-256 hash
so you pass some data in you get a hash
code out but what's different is you can
also have a key which you pass you and
when you create the hash
and what this does is it means that if I
then send the hash to someone else there
any anyone of you you for you to be able
to recalculate that same hash you need
to have that key this is where the idea
of authentic ation comes in you can only
generate that same hash you have the key
so it's commonly used for both verifying
integrity and authentication and you can
use by FM d5 and the char family of
hashes or hash Mac's and the strength of
this is based on the key so if you use a
good strong key which is say 32 bytes
long 256 bits it could be quite
difficult for someone so then go and
brute-force that same key and most
common attack against this type of
hashing algorithm is a brute force
attack because as I said if you use a
good strong key it makes it quite hard
to do so again using a hash Mac very
very easy to use so we have two pieces
of information in the past into our
method here so we have a byte array of
data to be hashed I may have a byte
array which is our key so that key was
generated using the RNG crypto service
provider so to create an instance of the
H max sha-256 objects whilst passing the
key into the constructor and they need
to simply call compute hash passing in
the dates you want to hash you get a
hash code back it's ok very very easy to
use
okay so next up we want to talk about
passwords and there's various different
ways in which you can manage passwords
ranging from not very good up to
excellent so the first one we'll just
get it out of the way and then move on
is storing plaintext passwords you know
I don't need to spend much time on this
sure everyone knows that that isn't
completely wrong whether there are a lot
of sites out there that do this but you
never store a plaintext password in your
database so the next best thing is to
hash a password and the way this works
is you would say have a person logging
on or signing up to a system they type
their password in you create a hash say
sha-256 hash of that password and then
store it in the database then the next
time they come and log on they type
their password in hashes generated on
the clients and it's then compared
against a hash and database if they
match you put the correct password in
but there's a problem with this and that
problem is that you can either
brute-force those passwords by trying
lots and lots of different combinations
or you can use what's called a
dictionary or rainbow table attack which
is a massive precomputed database of
passwords and different password
combinations even the clever things
where you try and turn the vowels into
numbers to outfox people you know all
that sort of stuff for being there and
the way a lot and the way a lot of these
attacks work is using tools that hash
cat you can use your GPUs in your
computer you know your graphics
processing units to actually do billions
of hash attempts per second so if you
imagine if you've got a big powerful
machine with two nvidia gtx 1080s in
there imagine how many hashes you can do
per second so it's giving an example of
how easy a hash password is to crack
there's a screenshot of a website here
called crack station dotnet so in the
gray box on the Left I've pasted a hash
code in there which is a two hour two
five six hash and you click crack hash
and it's worked out that the password is
secret 69 I mean it's a very simple
example book because actually that's how
a lot of these sites work and you can
you know if you've got an md5 hash you
can just paste it into Google and it'll
reverse it for you
seriously give it a try it's a cross
carry so has anyone ever worked on a
system then where you've used hashing to
store passwords their database yeah I've
worked on systems a dirt before I think
pretty much everyone has so what's the
next best thing that you can do that
sort of an the next level on from that
so you can do what is called a salted
hash and what salted hashes is the
password plus a salt value and a salt
value is just an arbitrary random piece
of data which generally you know you can
it's enough a random number which you
generate with RNG crypto service
provider and then you append that onto
your password and then you create a hash
of that password and the salt and this
is good it means it's much much harder
or probably at the moment even possible
to try and brute-force any of these
passwords so that's great has anyone
done this in any systems yeah you know
that again this is quite a common way of
doing it and you know there's nothing
wrong with that but the problem with
this is is as GPUs and processes
increase over time you know a password
assaulted password which she's secured
now who's to say it wouldn't it might be
vulnerable in five years time you just
don't know and this is a problem with
Moore's law you know processor speeds
and GPU speeds are increasing like that
it's only a matter of time before
someone comes out of a GPU which is
capable of cracking assaulted hash so
what we want to do is you want to go one
step left the one step further and we
want to try and mitigate this problem of
trying billions of hash attempts per
second so the next best thing and so the
recommended thing to use is what's
called a password-based key derivation
function or if you want to impress your
friends down the pub it's a pbkdf2 if
you like acronyms again this is the same
as what we've been talking about so we
have a password that we want to hash we
have a salt but what we also have here
is a number of iterations number that we
pass in and what this is is it tells the
algorithm how many times to rehash not a
password
and the reason this is good is you know
at the moment if you can say test you
know bill two billion combinations per
second if you have enough iterations on
your part of a base key derivation
function you might reduce that down to
the fact that you can only test say ten
per second or two per second depending
on what you pass in there and I'll show
you a graph in a moment of what the
different speeds increases look like so
but first of all so I'll show you how to
use it we have our method here we're
passing in a byte array of our data to
be hashed just as before a byte array of
our salt so it's you know 32 byte random
number of just so junk that you append
on to the password and we have a number
of iterations now the class in thought
net framework you want to use is called
RFC two eight nine eight derived bytes
so you'll be forgiven for overlooking
that one in the framework because this
it's not obvious what it does and under
the bonnet or under the covers the way
RFC two eight nine eight works it uses
sha-1 to do its hashing which means you
get a twenty by a hash value out of it
so when I call get bias I only really
need to get the first 20 bytes for that
hash value so if you look at the chart
here so when I first created this chart
I was using a an older laptop but I
tested some hashes so 100 iterations it
took two milliseconds to hash a password
a thousand iterations to it 16
milliseconds 10,000 iterations took 196
milliseconds so you can see it sort of
scales up and when I did five hundred
thousand iterations it took seven
seconds to hash the password now the
value you put in there is a trade off
you have to look at what you're using
the hash for and what the speed
implications are going to be for you so
if you have a good robust websites you
may notice sometimes when you put the
password in there might be a bit of a
delay as you log in that's probably
because they're doing a part of a base
key derivation function called
behind-the-scenes so systems i've works
on you know i've typically used anywhere
between fifty and a hundred thousand
iterations it's a hash a password for
logging in the system because that kind
of natural delays kind of okay but i
think it's okay
but if you're hashing data or saying
this sort of high-speed transactional
then you know fifty thousand iterations
to be too slow so you need to think
about the trade-offs of how many
iterations you want and what the speed
penalties are going to be so what we're
on the subject of passwords this
company's been brought up several times
while we're here it's fun to talk about
there's a as a tech avons heard of this
everyone saw Troy as keynote yesterday
so one of the things that happens when
Ashley Madison were hacked is the
password tables were all stolen and but
actually Madison had actually been quite
good so there is something called B
Crips to encrypt their passwords now B
Crips is something that's very similar
to the password-based key derivation
function
it's an iteration based hash function
it's just a different type of
implementation so they do this across
their passwords the attackers tried to
you know recover a lot the passwords and
they couldn't that's good but they then
also had access to the source code which
had stolen and what they had found was
that some unwitting programmer had
probably tried to optimize the locking
in system I'm not quite sure what their
motive was but and they'd started
storing a local token of the password in
the username which they then md5 hash so
I think think what it was is you know
when you come back to relog into the
system it we log you in quicker so they
probably thought they were doing
something good you know making the read
login in process quicker so in the
hackers found this out they're like well
let's not let's not attack the beat
Crips passwords let's attack the md5
hashes so they did and they managed to
recover I think it's about ten million
passwords from the system
so the reason why I sign these stories
security is only as good as your weakest
link so their password management
Germany was pretty good they use bcrypt
to store their passwords but they had a
weak link in the chain where they were
storing this token with md5 hash
passwords which meant you know all the
good stuff had done with B Crips was
basically avoided at that point so
there's a really good article on ARS
technica I've put a bitly link there
which goes into that story in a lot more
detail and it's quite an entertaining
read it's I definitely recommend reading
it ok so let's move on to encryption so
first of all we're gonna talk about
symmetric encryption and what this is is
you you have some plaintext data and you
encrypt it with a key which gives you
your ciphertext data but then to decrypt
the message you decrypt it the same key
that's why it's symmetric so you use the
same key to encrypt and decrypt but
there is a drawback to symmetric
encryption and that is that sharing keys
is very difficult to do so if I encrypt
some data and I want to send that data
to say five of you in the audience how
do we share that key
I can't email it to you that's a bit of
vulnerability I can't just put it on the
network somewhere it maybe I could meet
you all in person and hand it to you
it's a key sharing gemonese quite hard
to do and one of the things we're going
to talk about later is how to mitigate
the complexities of key sharing
so this is a diagram we looked at
earlier so we're we're saying the
hashing is a one-way function this just
reiterates the point that encryption is
a two-way operation so you have some
beta you encrypt it but you can also
reverse that operation and get your data
back
okay so ways to metric encryption works
is it works by getting the data you want
to encrypt and it chops it up into
blocks and it encrypts several bytes at
a time and these blocks are padded so
they're the same size so if you have
some data chunk it up in say 128-bit
blocks if the block at the end isn't the
same size or is too small then you just
Pat it out and there's free symmetric
encryption algorithms that are supported
in done that so there's a es des and
Triple DES so we're mostly going to
focus on a es because that's the one
that's recommended to use these days but
the reason I've put des and Triple DES
on though is again if you're working
with legacy systems that use DES to
encrypt data if you need to interact
with those systems you'll then need to
use DES to decrypt that data so a es is
what we're going to look at and it was
invented by two mathematicians Joan
daemon and Vincent Raymond and they
created what was called the rondell
cipher and then in 2001 the National
Institute of Standards and Bill the
National Institute of Standards and
Technology adopted the rhymed out cipher
as the AES advanced encryption standard
and the way AES works is quite simple so
you pass into it your plaintext so a
byte array of the data you want to
encrypt you're also Parsi in a byte
array of saying which is called an
initialization vector and what that is
is a small byte array of data which is
used to help jump-start the AES
encryption algorithm the initialization
vector doesn't have to be kept secret
you can send it along with your message
there the secrecy isn't based on the
initialization vector and then you also
pass in a key so AES supports 128 192
and 256 bit keys so I always recommend
you just go straight for 256-bit keys
which is 32 bytes
so you passed all those into the AES
algorithm and then you get your
ciphertext back out the other end and
then to decrypt that data instead of
passing in the plaintext you pass in the
encrypted data the same initialization
vector and the same key and then encrypt
your data so in dotnet there's two
implementations of AES that you can use
there's one called AES managed and
there's also one called
AES crypto service provider so AES
managed is natively written in dotnet
sorry it's a it's a CL are based objects
and you know it works fine I've used it
several times but the main drawback is
is it's not what's called fit 197 - 2
certified and if you're only encrypting
and decrypting data between net systems
that might not be necessarily be a
problem but if you're working with a lot
of other systems that are saying written
in Java node or any sort of mainframe
systems using implementations of
certified means that you're guaranteed
at any day to eclipse and say dotnet you
can then go and decrypt on a on a
mainframe so the AES crypto service
provider object and on there is Phipps
197 data - certified and it's not
written in dotnet it uses the underlying
windows crypto platform
so it's quite straightforward to use so
we have a method here called data to
encrypt we pass in a byte array of our
key so there's a 32 byte byte array and
we pass in an initialization vector
which is 16 bytes and then we create an
instance of the AES crypto service
provider class we pass in the key in the
initialization vector and we then create
a memory in a crypto stream because it's
tall stream based and then you just
write the data into the stream and flush
it and then that gives you your
encrypted data back out the other end as
a byte array so decrypting data is very
similar so you pass in the key in the
initialization vector create the crypto
service provider objects pass in the key
in the IV and then you create your
memory stream and crypto stream and
you've got a thing here called daes
decrypt so then that gives you that
decrypt your data back into a byte array
so the next one to look at is asymmetric
encryption so what we talked about it's
been symmetric so far you use the same
key to encrypt and decrypt so the next
one is asymmetric encryption and you
probably heard this commonly referred to
as public and private key cryptography
so the idea is you have some data you
on-screen crypts you encrypt it with
your recipients public key you then send
them that data and to decrypt it they
use their private key they're the only
person that will have their private key
so they have to look after it but their
public key anyone can have it you can
post it on your website you can hand it
out it doesn't matter so we're going to
use an algorithm called RSA and it was
developed by a company called RSA data
security incorporated by a free guys
Rivest Shamir and Adleman
and the way RSA works is it's more of a
mathematical process whereas whereas AES
is algorithmic it works on blocks of
data
it's no big algorithmic and how it works
RSA is more mathematical and it uses
modulus arithmetic and the way it works
is that there should be no efficient way
to factor very large prime numbers so if
you have a key which is 2048 bits which
is the current recommended minimum key
length that key length that key is
basically one massive prime number the
one drawback of RSA is because it's a
mathematical scheme the larger the key
size use the slower RSA is and is quite
slow so as the saying the keys are based
on prime number factorization so if you
have two prime numbers 23 and 17 you
know if I say to you multiply them
together it's quite easy so you can
doing your head on a calculator it's
very straightforward
we've asked to say what two prime
numbers do you need to multiply together
to make five thousand nine hundred and
sixty-three does anyone know the answer
to that pretty sure someone's going to
be out to say at one day it made me look
really stupid okay so it's a lot harder
to do so the answer is 67 times 89 is
five thousand nine hundred and sixty
three so the public key is five thousand
nine hundred and sixty three that's the
number that everyone else couldn't know
but the private key is those two prime
number factors 67 and 89 and that's the
bit you want to keep secret so there's a
lot more Tower RSA keys work than that
but fundamentally it's all based around
the complexity of factorizing prime
numbers so that will sounds quite
complicated but to use it really isn't
that hard so first of all we want to
generate some keys so we have a method
here called a sign near key and we
create an instance of the RSA crypto
service provider class and we pass in
the key strength that we want to use so
we're going to use 2048 bits in this
example and in to export our public key
we just call export parameters I was
passing in false and then to generate
our private key moves collects port
parameters whilst passing in true so in
the code there I mean we're just storing
the keys in memory and obviously we
haven't got time to talk about effective
key management strategies but typically
you know you don't just want to write
these out to files and keep them on your
server because that's not very safe you
probably want to use certificates or
hardware security modules which are
network appliances that go into your
data center which is designed for
storing keys but if it but for purposes
of the example which can store the keys
in memory so to encrypt some data we
have our method here and we pass in our
byte array of our data we want to
encrypt
and we create an instance of RSA crypto
service provider again I was passing in
the strength of the key we want then we
call import parameters and we pass in
our public key and then we just call RSA
dot encrypt and then that encrypts the
data and gives us a byte array the very
cryptic data back to decrypt the data
very similar create an instance of RSA
crypto service provider import our
private key and ends call RSA decrypt
and that gives us our decrypted data
back one particular problem with guevara
say is you can only encrypt state or up
to the size of the key so if you've got
2048 bit key you can only encrypt a
maximum of 2048 bits of data so you
could you know have your data that you
want to encrypt and then split it up
into chunks and encrypt each of those
different bits it's a data but generally
you're limited on how much you can
encrypt at once if RSA
that's not necessarily a problem which
will come on through later so the final
primitive we're going to look at is
digital signatures so a digital
signature consists of three different
algorithms that weren't to use so we
have a key generator which we've just
seen of a signing algorithm so we can
assign a piece of data and then we have
a signature verifier so if we have a
digital signature of a piece of data say
a PDF document
only then will some verify the
signatures valid we use a signature
verifier and the key generator is going
to be based on RSA as we've just seen an
away - signing algorithm works is that
we sign a date so using the private key
so look back to when we did our RSA we
encrypted the data with the recipients
public key when we create a digital
signature of date so we're actually
gonna use our own private key to create
that digital signature and when the
recipient wants to verify that the
signature is valid they use my private
my public key
so typically the way a digital signature
works is you don't create a digital
signature of the actual day to itself so
if you're trying to create a signature
of say a large PDF document you'd create
a sha-256 hash of that document first
and then you do the digital signature of
that hash because they're digital
signatures use our essay under the
covers it has the same limitations in
the amount of data you can create a
signature for in one go so typically
create a hash with your data and then
you create a digital signature of that
hash so if we look at my expert piece of
artwork to demonstrate this so we have
guy called Bob and he wants to create a
digital signature so he does that using
his private key he then sends our
digital signature over the internet or
the intergalactic spider's web as my
picture shows he sends that to Alice and
then she wants to verify too that her
signature is valid so she uses Bob's
public key with the signature verifier
and if it was indeed Bob that sent
Matt's signature then it'll be valid
so what earlier on we talked about the
concept of non-repudiation about being
able to prove that someone has sent
something the reason we know it was Bob
that said in this digital signature is
because it used his private key so only
Bob knows his private key so if we can
verify that the signatures valid when
it's sent to us it can only have come
from Bob and their season private key
has been stolen
so it's use digital signatures a game we
need to generate a key pair so same
codes what we use before we export our
public and private key and then to sign
some data we pass in a byte array which
is the hash of the data we want to sign
so PDF document create a hash of that
data pass into this method we then
import our private key and we then
creates an instance of a class called
RSA pkcs1 signature formatter I don't
know who comes up with these names but
again it's one that you probably it's
very easy to overlook it in the.net
framework so we set a hashing algorithm
on that so under the under the covers we
can use sha-256 and then you just call
create signature and passing the hash of
it at the date so you want to create the
signature on and then you get a byte
array returned which is your digital
signature
it's a verified a digital signature is
valid we have a method here to do that
so we pass in the hash of the data to
the sign and the actual by iterator
digital signature itself we import the
public key because we're using the
sender's public key to verify the
signature we create an instance of RSA
pkcs1 signature D formatter just rolls
off the tongue that one again set the
hashing algorithm to be sure to you five
six and any call verify signature
passing in the hash of a data that was
signed and the actual signature itself
and that just returns a boolean true or
false true it's a valid signature false
it's not so if for example when we go to
generate or when we go to verify the
signature that hash don't be trying to
verify if that's been changed in any way
and you pass it in to verify a signature
with the digital signature itself the
fact that has been changed and verified
will come back as false because it's not
because it's not a valid digital
signature for that data
okay so if we recap our four main
pillars of cryptography so first of all
we had confidentiality and for
confidentiality we've used both AES and
RSA for integrity we've looked at
hashing and we discuss a lot about
sha-256 for authentication we've used
hash message authentication codes based
of our sha-256 and for non-repudiation
we've just looked at digital signatures
so now what we want to do is use a lot
of these together to create what's
called a hybrid encryption scheme okay
so as we discuss RSA has limits on the
amount of data you can encrypt in one go
and it's quite slow but a yes is very
fast it so now is algorithmic it's quite
efficient the exchanging keys is very
difficult so what we want to do is
combine RSA in AES to create what's
called a hybrid encryption scheme so
we're using the power of both of these
asymmetric and symmetric encryption
algorithms to encrypt data and share
keys
so if we look at the example here so we
create an Aes session key and that's
just a first two byte random number that
we can use is our key for AES we encrypt
some data with that key
but then what we do is we use our public
key and RSA to then encrypt that session
key we send that across by recipient
they use their private key to decrypt
that session key then once they've
recovered that key they can then decrypt
the message with AES so when we send our
data to the recipient decrypt we're
sending them free pieces of information
so we've got the RSA encrypted session
key we've got the initialization vector
which we use for jump-starting AES and
we have the actual AES encrypted data
itself so it's not this one through that
as an example so we've got Alice she
generates a first two by IES key and she
generates her 16 bytes initialization
vector she encrypts her data with AES so
using that session key we've now
encrypted our data so that's good
we then use Bob's public key and RSA to
encrypt that session key we can then
send all that data package it all up and
then send it across to Bob so on the
other end so Bob's receive this packet
of information so he uses his private
key to decrypt the AES session key so
we've recovered the key we can now use
AES with the initialization vector to
decrypt our data and then Bob can read
the message so meet me at noon blow the
clock tower where a red rose in your
button but we're reading far too many
spy novels so to reiterate this let's
get Bob to send a message back to Alice
so Bob generates his own a session key
because once he's used the other one
we've referring it away we're not going
to use it we can generate a new one so
he generates a new photo to buy a key he
generates his own initialization vector
which is 16 bytes and he uses AES and
that session key an initialization
vector to encrypt his reply
he then uses Alice's public key so we're
sending a message back to Alice so we
can use her public key to encrypt that
session key he packages it up and email
was it or however he's going to send it
back to Alice so she then uses her
private key to recover that AES session
key and then she uses that's recovered
key with the initialization vector to
decrypt the message reply and the
message is I will meet to you I'll be
wearing a blue hat and red boots
she's very fashionable so that's pretty
good so we've used the flexibility of
RSA to be able to securely share keys
between our recipient and sender but
we've also used the speed and efficiency
of AES to encrypt our actual message so
we kind of fixed two of our problems but
now let's add some integrity to that so
if Alice sent some data to Bob Bob wants
to make sure that data hasn't been
tampered with or corrupted in transit so
as before we use a session key which we
generate for AES we encrypt our data you
then use RSA and the public key to
encrypt that session key and then we
also generate a hash message
authentication code of the encrypted
message and because we using a hash Mac
we have to pass a key into it so we used
a session key so that means on the other
side when we sent the message the only
way that they can the recipient can
check the hash message is valid is by
recovering the case they need their
private key to do that which is where
the idea of authentication comes in they
can only verify that that and hash is
valid if they can recover the key the
AES key and they need their private key
to do that
so that means when we send our data
across to our recipient we've got the
RSA encrypted session key we've got the
AES initialization vector we've got the
AES encrypted data and we're also
sending the hash mark of our encrypted
data so that's all pretty good so let's
take that one step further so we've
added integrity to our message we've got
effective key sharing using RSA and
we're using the flexibility of and the
power of AES to encrypt our message but
now we want to have the ability for our
recipient to be able to prove that it
was actually Alice to sent the message
to him and that's where we're going to
use digital signatures so as before we
generate our AES session key we encrypt
our data with that session key we use
our essay in the public key to encrypt
that our session key we then create a
hash Mac of the encrypted message which
of Audion quick super vs using the
session key as the hash blank key and
then we create a digital signature of
that hash Mac so we've created the hash
mark already but then create a digital
signature using the recipients own
private key this means when we send the
data across to the recipient we have the
RSA encrypted session key of our
initialization vector we've got our AES
encrypted data we've got the hash mark
of the data so that's how we check in
integrity on the other ends by checking
the hash and we've also created a
digital signature of that hash so when
Alice sends a message to Bob Bob can be
sure that it was actually Alice that
sent the message and not some other
third party
so we've covered quite a lot in a short
space of time there so we've covered
random numbers hashing and hash max
secure password storage AES encryption
RSA encryption digital signatures and
hybrid cryptography so I'm sure you're
all going to remember that by five
o'clock this afternoon so what next so
what we talked about today you know
we've covered a lot in an hour so really
treat this talk as the art of the
possible what can we do with the stuff
that's in dotnet so if you are
interested in using this I really do
encourage you to download the book it
kind of mirrors what we've talked about
today that book does come with a lot of
sample code so all the code snippets I
showed you on the screen today it will
comes in a solution file you can just
use the code steal it and use it in your
own solutions if you've got access to
plural recite that I say my practical
cryptography and dotnet course covers
what we've talked about in a lot more
detail it talks about the why we do a
lot this as opposed to just the how
again there's lots of sample code you
can download with that course as well if
you don't have access to PROSITE come
see me afterwards I've got some access
cards which I can give you the
cryptography itself is a fascinating
subject I mean when you start looking at
the history of how cryptography came
about it's an absolutely fascinating
subject so if you saw want to read a bit
more into it then there's some books
here that I highly recommend looking at
so the first one is called the code book
by Simon Singh it's a relatively short
book it's about the size of a standard
novel and that covers the history from
back in the days like Mary Queen of
Scots and sort the Romans right away
through so RSA and sort of modern
digital cryptographic protocols it's
quite good it's quite an easy read it's
not mathematical or very complicated it
is you know it's written more like a
novel so I highly recommend that book a
personal favorite book is a book called
everyday cryptography by a guy called
Keith Martin and this book split into
two so the first half goes into a lot of
detail about the protocols and
primitives that we talked about today
but yeah actually salt talks about how
they work under the covers then the
second half of the book is how they're
actually applied to
life so house or Wi-Fi encryption works
how SSL and TLS actually works so we
discuss hybrid cryptography the way TLS
works is very similar in how it does the
key sharing handshake may not
necessarily use RSA but it's it's a very
similar concept and probably the most
famous cryptography book and the book
that the NSA actually tried to ban back
in the 90s unsuccessfully is a book by a
Bruce Schneier called applied
cryptography this book doesn't cover AES
AES kind of came after when this book
was written it's quite a hard book to
read but if you really want to get into
the nitty-gritty detail how a lot of
these algorithms work and you're not
scared by a bit of maths then that books
quite good as well so thank you very
much and I'm gonna be I'm gonna be
hanging around for a few minutes
possibly around the conference the rest
of the day as on your way out I'd be
very grateful if you could vote on the
session as well if you press the green
button you are awesome thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>