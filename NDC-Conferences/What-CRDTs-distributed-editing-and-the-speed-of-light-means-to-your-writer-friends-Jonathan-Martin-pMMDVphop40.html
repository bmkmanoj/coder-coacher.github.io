<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What CRDTs, distributed editing and the speed of light means to your writer friends- Jonathan Martin | Coder Coacher - Coaching Coders</title><meta content="What CRDTs, distributed editing and the speed of light means to your writer friends- Jonathan Martin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What CRDTs, distributed editing and the speed of light means to your writer friends- Jonathan Martin</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pMMDVphop40" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we'll have a nice small group for
today which means we should have plenty
of times for questions and answers and
talking about different ways we can
actually apply some of the things we'll
be talking about today so thank you for
coming to my talk about what CRD t's
distributed editing and the speed of
light means to your writer friends so
hopefully that intrigues you a little
bit and might motivate you as we get
through the rest of the stop so a little
bit about me first
I'm Jonathan Martin I'm an instructor
and web developer with a consultancy in
the u.s. called big nerd ranch or if you
prefer small geek vinaigrette
I've heard it both ways we're based in
Atlanta Georgia in the US and a big nerd
ranch we developed web and mobile apps
for our clients and we teach other
developers to do the same through our
intensive five-day boot camps or through
our best-selling programming guides
which you can find on Amazon so because
I work with big nerd ranch
I'm originally from Atlanta but I've
done a little bit of traveling lately
I've currently in Mobile and then for a
little bit I was in Dallas
so really nowadays I work from anywhere
not any particular place I can work from
anywhere and this is because I'm a
digital nomad so digital nomads are
people who leverage technology to work
from anywhere and consequently they tend
to travel quite frequently and there's a
lot of really cool perks to being a
digital nomad I mean instead of working
from a space like this day-to-day I
might have a view of Italy's Amalfi
Coast from my office on a given day this
is the kind of office I like and so over
the past three years this nomadic
lifestyle has allowed me to nurture my
love for landscape photography but the
nomadic lifestyle didn't really come
naturally to me at first because there's
a lot of interesting skills you have to
have to be a digital nomad you have to
be really good at catching last-minute
flight deals and living out of a tiny
little backpack for a couple months at a
time so some interesting skill sets now
digital nomads come from a lot of
different professions for example a lot
of bloggers journalists developers
foodies I'll travel around the world and
they enjoy the freedom that a digital
nomadic lifestyle gives them
but despite the diversity of these
different backgrounds and professions
all digital nomads tend to face some
pretty similar situations
they're often collaborating with other
colleagues on the go from just about
anywhere including places with either a
poor internet connection or no internet
connection at all
so really hotel and McDonald's Wi-Fi is
pretty much as good as Wi-Fi gets for a
digital Nomad so digital nomads face
these sorts of interesting challenges
that aren't always solved by mainstream
tools and applications that we might
recommend to them well so my personal
interest at big nerd ranch is creating
software for digital nomads for this
interesting class for this interesting
group of people who have these
interesting technological requirements
so to dive into some of the different
technical constraints we'll be dealing
with we're going to focus on two
travelers we have some really nice
avatars up there very memorable github
binary bit art so these two people are
Alex and Beth alex is a foodie he's
interested in food culture and trying
cuisine from all over the world and Beth
is a tribal a journalist and so Alex and
Beth are traveling through Europe
together and they want to write a blog
post about sandwiches just because well
they want to create this incredible
expose on sandwich making as they travel
through Europe so what tools right now
would we recommend to Alex and Beth so
that they can write collaboratively on
the go what we're developers so we might
suggest a version control system like
git it is after all offline first and it
has advanced workflows for merging
changes so yeh git until this it's not
exceptionally well suited to writing
discs tend to be line oriented and
generate a lot of noise and yes there's
a word diff mode but it doesn't work for
patching so you can't patch in one word
at a time so not so great the interface
isn't exactly memorable either
especially for people who don't tend to
open the terminal on a daily basis so
and the git commit workflow is also
kind of untimely so you're not going to
have any real-time collaboration
feedback unless you can really type get
add and get commit and get push within a
few milliseconds so maybe get isn't
quite the best solution for our writers
so naturally we might turn to something
like Google Docs Google Docs is sort of
the holy grail in collaboration for
on-the-go so a lot of digital nomads a
lot of writers a lot of bloggers might
use a tool like Google Docs for this and
it works pretty well especially if you
have an internet connection but if you
don't have an internet connection
you'll probably be dealing with this so
Google Docs is not resilient to being
offline for long spells even though
there is an offline version of Google
Docs you're not exactly going to be able
to continue collaborating if you make
changes for too long and you get back
online Google simply going to tell you I
give up I can't merge these changes so
Google Docs really isn't a great
solution for the kinds of issues that
frequent travellers and digital nomads
might be facing when they want to
collaborate on the go well maybe let's
take a nerdier approach maybe you've
heard of ether pad it's after all Alex
and Beth's if they're traveling together
maybe they'll be close enough that they
can create a little ad-hoc network or
use Bluetooth networking and then use
something like ether pad to collaborate
over that networking connection so that
seems like it could work
except that unless you're a nerd you've
probably never heard of it and writers
probably don't want to be using a plain
text editor so get ether pad and Google
Docs another one of those solutions
quite seems to fit the use case of a
digital Nomad if we really want to help
Alex and Beth we want to give them
something that offline resilient that
gives them real-time collaboration when
they do have network connectivity and
have it all be seamless that's your kind
of hard-pressed to find a product that
does those sorts of things now the good
news is we actually already have the
algorithms to create great software for
digital nomads like Alex and Beth so in
this talk we're going to investigate the
three basic parts that you need to
create a compelling collaborative
experience for digital nomads or
just any kind of creative industry where
you're collaborating so we're going to
be discussing writers but in fact most
of the techniques we look at are
applicable to collaborative music maybe
you have two people who want to
collaborate on sheet music or maybe they
want to collaborate on sound recording
they can do that with these same
algorithms so the first part of this
talk we're just going to look at the
algorithms behind conflict resolution
how do you let two or more people make
changes to the same document at a time
and then resolve those conflicts
seamlessly that's going to make up the
bulk of the stop and then of course
we'll need some way to communicate those
changes between peers some way to say
hey I made a change you should probably
update your copy of the document so we
could either do that over the internet
or we could look at some different
peer-to-peer technology that allows
these computers to collaborate without
being connected to the internet and then
finally since they are writers they
probably want a really compelling
editing experience so we'll take a look
at what web technology offers us in the
way of compelling editing experiences so
let's start with the hardest part of
this talk and that is how do we resolve
conflicts when multiple users edit the
same document simultaneously now in web
development and development in general
we have a fundamental limit and that is
the speed of light is slow it's so our
routers routers make it even slower
computers are slow now relatively
speaking it's not that slow but it turns
out it adds up and so for Alex and Beth
to be able to make changes to the same
document simultaneously we can't force
one to take turns we can't force best to
not touch a document while Alex adds a
few characters here and there that's
simply not feasible when we're talking
about peer-to-peer and real-time
collaboration so we need to look at some
algorithms that allow Alex and Beth to
make these changes simultaneously but
have an algorithm that can merge those
changes without supervision after all we
don't want to have them basically have
the experience of doing get discs and
get merged so we need an algorithm that
can combine changes that were made at
the same time but does it in a very
dick table way so that Alex and Beth
always end up with exactly the same copy
of the document now this particular
constraint is called strong eventual
consistency now if you have looked into
different database paradigms or maybe
you're using something other than
Postgres as your main database back-end
you might be familiar with the BA se
database paradigm normally we think in
terms of acid which always guarantees
that whenever we query a database that
we're always getting the most recent
data and that if something's being
written to it that the database is going
to be locked down until that right has
finished so certain constraints like
that in the acid framework well in BA se
instead we decide okay we're going to
give up read consistency but we're going
to force or we're going to make sure
that at the end of the day once all
these changes do get synced up that
everyone ends up with the exact same
copy of the document we typically call
these replicas so Alex and Beth's if
they're both working on a document we
would say that Alex and Beth have their
own replicas of the same document and at
the end of the day once they communicate
those changes with each other they
should end up with exactly the same copy
without having to do a full resync so
this is eventual consistency and it's
one of the key constraints we need to
build a real-time collaborative editor
that works well when the network is poor
or in some cases when you don't have a
network connection at all so we're going
to take a look at some different
scenarios to see how we can help Alex
and Beth and so on the first one Alex
and Beth are hiking in a German the
German Alps and they decide while
they're hiking they get a little hungry
and they decide they'd like to have a
picnic so they pass the market so
naturally they decide hey let's put
together a grocery list
let's split ways and just start getting
the groceries that way we can get this
done in half the time so initially they
put together this great-looking picnic
milk bread and eggs so they go into the
grocery store and they say alright we're
just going to get these items we'll go
separate ways while they've split up
however Alex remembers oh you know what
I'd really like to grab some apples and
really I'd rather not
bread the bread here isn't all that good
so Alex decides to make a change to his
grocery list he decides to remove bread
and add apples to his copy of the
grocery list best on the other hand is
lactose-intolerant and so she takes milk
away from the list
now when Alex and Beth get back together
we now have a question how are they
going to merge these two different
copies of the grocery lists so that they
end up with the same grocery list so
there's a few naive strategies we could
take the easiest one would be let's
combine these two lists into a brand new
one and just remove duplicates in other
words we should have every item from
each person's list we call this the
Union strategy now the union strategy is
a valid strategy it's eventually
consistent because Alex and Beth only
have to tell each other what items they
added or removed and they will end up
with exactly the same copy of the
document so in other words Union is
eventually consistent so it's a good
algorithm in that case but there's also
another equally valid strategy we could
use the intersection strategy to only
keep items that are common between both
lists so it's also eventually consistent
so which one do we pick well neither of
those strategies solve the fundamental
question if we go back to the list and
we look at what happens to bread in
Apple's we'll see that Alex removed
bread he added Apple's best removed milk
if we look at the Union or the
intersection strategy
neither of these solutions preserve Alex
and best intentions if we look at the
Union strategy we see that Alex was not
able to remove bread like he had
originally intended he was able to add
apples however and we also see that Beth
was not able to remove milk so this
means that in the Union strategy one
person can never remove an item both
people have to simultaneously remove an
item and in the intersection strategy we
have the exact opposite problem you can
never add an item unless both people do
it at the same time so these strategies
really are a little bit too naive but
the solution is right there in the way
we describes this problem maybe instead
of relaying exactly our current
version of the grocery list or in other
words the final state of our grocery
list
maybe instead we should just relay these
changes kind of like a git diff so in
this case we might describe these
operations we might say that Alex
deleted bread he added apples and Beth's
removed milk well when they sync up all
they need to do is combine their changes
not the final state but they combine
their changes together into a single
list and now we can apply these changes
one after another in no particular order
and end up at a solution which preserves
both Alex's and best intentions this
strategy is also eventually consistent
and just as importantly it preserves
user intentions for both Alex and Beth
so this is a usable strategy for
resolving changes to a set or unordered
list unordered lists are pretty easy to
deal with things change a little bit
when you step into the realm of ordered
sequences or an ordered list or if you
prefer a string maybe a text document so
in our next scenario Alex and Beth had
finished their grocery shopping they've
had their picnic and now they're ready
to start working on that blog that
expose about sandwiches from all over
the world eventually it's going to be
this really great piece you'll probably
see it on hacker news but first they
start off with a very modest document
and that is they start off with just the
word sandwich in the document so if we
were trying to think about some
different ways that Alex and Beth can
make changes to this document in
isolation from each other we might try
this scenario so let's say Alex and Beth
started off with this document it said
sandwich then they both lose internet
connectivity for a little while and
during that time alex removes the letter
D from his copy of the document Beth
adds a letter to her copy of the
document she answers to letter H at
index five well we could immediately
revisit the concepts that we just saw an
ordered sets maybe instead of relaying
the final state the final copy of the
document we could just relay those
changes so here's one way we might
describe those changes we might say that
Alex deleted the letter D which was at
index 3
and then we might say that best inserted
the letter H at index five so we could
try that strategy before where all we do
is we combine these changes and we run
them one after another in no particular
order so in this case first will apply
Alex's operation we'll remove the letter
D and then we'll insert the letter H at
index five
unfortunately we end up with this very
interesting permutation of Sandwich
however you can pronounce that that
isn't quite what Beth had intended we
see that Alex's intention was preserved
he wanted to remove the D and it's gone
but the H was supposed to come after the
W so it's not quite enough when you have
order to just apply these operations one
after another we have to make changes to
resolve this so even though Alex I'm
about to perform these changes
concurrently which means they're
basically doing it in isolation for all
intents and purposes that are applying
these operations at the exact same time
but depending on whether we decided to
apply Alex's operation first or best
first we end up with different solutions
this violates eventual consistency for
this algorithm to work it has to be
eventually consistent so the problem
here is that we applied best operation
after Alex's and Alex's operation
shifted the state so if we take a look
at Alice's delete operation as soon as
we remove D it effectively offsets all
of the other letters there so we have
this offset now of negative one which
means if we want to figure out what best
operation would look like had she
performed it on Alex's copy of the
document we can't just insert the letter
at five we need to subtract one from it
to get a better index now we can run
that and now we end up with a much more
satisfying
misspelling of sandwich sandwich so this
particular version of a text merging
algorithm results those changes and it
did preserve user intention between both
Alex and Beth even though they had to be
applied in different contexts
now in a nutshell this is how
operational transforms works so if
you've heard of Google Docs if you use
Google Docs or if you've used pretty
much any collaborative experience you're
probably using operational transforms
and essentially when changes are made
concurrently each client performs the
changes in some predefined order and
they transforms any concurrent
operations so that they can be applied
to a different copy of the document and
still make sense now for operational
transforms to work they have to satisfy
two mathematical properties which we
call TP 1 &amp;amp; tepee to tepee 1 is easy
it stands for transformation property TP
1 is essentially the problem we just
looked at and then there's a much more
complex one called TP 2 but we'll go
back to TP 1 TP 1 is fairly
straightforward it's basically the
problem we just solved it says that when
Alex and Beth makes simultaneous edits
to the same document and they exchange
those changes with each other we need to
ensure that they end up at the same copy
of the document so here's a classic
problem you would use to see if in
operation or if a particular kind of
operational transform was TP 1 compliant
you might get something like this you
might say okay Alex insert a letter at
index 3 and Beth delete a letter at
index 2 and if this problem happens if
they end up with different copies of
documents like Alex ends up with ax C
and Beth ends up with a CX this
algorithm doesn't work so for an
operational transform to be TP 1
compliant it has to avoid this problem
well the particular solution we looked
at did fix that so we should be good to
go then
so the algorithm we just looked at is TP
1 compliant we kind of get a quantum
jump when we hit 2 TP 2 tp2 is
essentially a problem that says when you
have three or more people collaborating
how do you deal with this so this
particular problem says what would
happen if you had Alex Beth and Chris
collaborating on the same document and
Alex and Chris insert letters around the
middle of the string and best decides to
remove that middle letter which is sort
of like a pivot
sort of like a reference point for Alex
and Chris's operations how do you make
sure that all three of them end up at
the exact same copy of the document a
more naive operational transform
algorithm will end up with some people
having a X Y C and some with a YX see
this is a problem because it has to be
eventually consistent so tp2 much harder
than tp1 if you can get TP 1 + TP 2
correct
it essentially means that your algorithm
will work amongst multiple peers and all
copies of the document will eventually
be consistent
unfortunately for text documents there
are actually no correct transformation
functions up until recently there are
this is somewhat of a lie but they're
all fairly impractical so for text
documents there are currently no correct
transformation functions so this means
that operational transforms at least for
a text document cannot be used to build
a safe decentralized collaborative
editor or in other words operational
transforms cannot be used to create a
multi peer editor instead you always
have to have a central server some sort
of go-between that transforms operations
between these different clients meet
Google Docs
that's essentially what Google Docs is
doing so since operational transforms at
least the ones that we tend to use only
support two peers Google acts like one
of the peers and then everyone else is
essentially that second peer so Google
kind of acts like this go-between
between all the peers which is why you
have to have an internet connection
directly to Google unfortunately this is
slow maybe it compared to using it it
isn't that slow but in a real-time
scenario or when you have a slow network
connection sometimes there can be quite
a bit of lag when you're typing so it's
slow its centralized and it requires a
constant connection to Google server so
this means that you can't really work on
a Google Doc with a few friends in say
one room using Bluetooth networking this
is also by the way why Google Docs does
not work well when you go offline for
long spells because it's really only
meant to work between two peers and it
doesn't do a very good job at that so
Google Docs
the Google team did an amazing job they
shipped it it was originally part of
wave and then hit Google Docs so really
cool algorithm but it also turns out
it's kind of the lower rung of
collaborative algorithms we can actually
do better so now we're going to try to
level up we're going to take a look at
some tricks that might help us solve
that tp2 problem in other words having
more than two peers collaborating
directly with each other without a
go-between so two of the tricks we'll
take a look at are called preconditions
and tombstones so first I'm going to
show you guys a little bit of notation
this notation is borrowed from set order
notation it's a just a formal way to
describe how things are ordered in a set
so if you think about it if you were to
see something like this this says that
the letter s must come before the letter
a must come before the letter n you
could also write this as the letter A
must come after s and the letter A must
come before n really fancy terminology
it's just an ordering so if we took our
initial string sandwich we could write
it out with this notation so this
notation is just saying that the letter
s in this document comes before a comes
before n etc now if you have a
background in computer science you might
recognize this as a partially ordered
set or post set and in this case it's a
post set with a total ordering which
just means there's no ambiguity in terms
of which letter comes before which
letter so when three people go to make
changes at the exact same time say now
we have Alex Beth and Chris we're trying
to see if this new algorithm will solve
tp2 compliance we might try starting
with Chris's operation first and so we
see that okay he deletes the letter D
but notice that delete operation has a
little bit more information than it did
before instead of having an index or
anything like that
it now has these preconditions on the
left and right it says before you can
apply this delete operation check and
make sure that there's a letter n
somewhere to the left of me and that
there's a letter W somewhere to the
right of me so to be able to apply this
operation these preconditions have to be
fulfilled well we do see the
letter D and it's between the letters
and NW so we can easily apply Chris's
operation which deletes it but now once
we get to Alex's operation we already
can't get any further it says to insert
the letter Y so long it goes between the
letters D and W but now that
precondition on the left is no longer
met we just deleted the letter D which
was sort of a reference point and now
that it's gone we can't actually apply
Alex's operation anymore and nor can we
continue on the best so fundamentally
the issue here is that we've lost
information when we try to resolve these
conflicts so maybe what if we didn't
lose information what if instead of
deleting the letter D we just marked it
as deleted but we kept a reference in
memory to it this is called a tombstone
it's basically just a reminder in memory
that hey there used to be a letter D
here but it's gone now but that means
that operations that were applied
concurrently can use that still as a
reference point until they get a chance
to catch up so now if we leave that
tombstone in there we can attempt to
apply out this operation so we see ah I
want to insert the letter Y before D and
after excuse me after D and before W the
D isn't there yet but at the time Alex
made this change there was a D there so
at least I know where it should go and
the same can be done for Beth now you'll
notice in best case we could actually
put the e in two different places
because it's not the only letter between
dnw
it's up to you how you decide to resolve
that tie so long as all clients resolve
that tie in exactly the same way and so
then when we want to figure out what the
final string is we just hide the
tombstones and we end up with the final
string so tombstones and preconditions
are a useful trick that allow multiple
peers to collaborate on the same
document without a central server so
we're a little bit closer to multi peer
collaboration there's one catch though
so we dealt with just one tombstone we
just deleted the letter D from the
document but let's say that you've been
editing this document for quite some
time you might have a lot of tombstones
and these tombstones pick up memory
essentially this means that even if you
have a document that only has a few
characters in it the document might take
many megabytes in memory just because
it's got all of this precondition excuse
me all this tombstone information from
previous editing history this is
fundamentally one of the difficulties
dealing with the tombstone strategy it
typically requires some sort of complex
garbage collection strategy and
oftentimes those garbage collection
strategies are much more complicated to
implement than the original algorithm
was in the first place so it might work
and there are some implementations of it
but they're fairly difficult to
understand and they're not always
practical so can we do better we've seen
two algorithms we've seen operational
transforms and then we've seen
techniques that use preconditions and
tombstones we can do a little bit better
so now we get into a class of data types
called CR d TS CR d TS stands for
conflict conflict free replicated data
types and they're not an algorithm
they're actually a data type so kind of
like a tree or a linked list C Rd T's
are a data type that naturally resolve
conflicts without any special resolution
algorithm so C R DTS are really cool if
you implement the data structure
correctly you automatically can handle
multiple changes at the same time and
there's no such thing as a conflict so
they're really cool theoretically and it
turns out they're actually easier in
many cases to implement for real now
there are a lot of different kinds of
CRD T's out there there's one for sets
like grocery list there's one for
counters unfortunately for a long time
there hasn't been a good one for ordered
sequences like text documents
so pretty much operational transforms
was the only algorithm you could use to
deal with text editing that has changed
we're going to take a look in particular
at probably one of the coolest
algorithms that I've seen but so far
it's called LS EQ the linear sequence
all this means is it's an ordered list
so it could suit an ordered grocery list
it could sort or it could work with a
to-do list or it could work with a text
document where every entry of the
character or maybe every entry
a word depends on how you want to
implement it now the interesting thing
about LS EQ compared to a lot of other
text-based CRD T's is that it's actually
fast a lot of text implementations of a
CR DT tend to be very slow and memory
usage gets very high it gets very
onerous to make changes to that document
LS EQ is actually fast and memory
efficient and let's take a look at the
reason why we'll go back to our document
here which was just the string sandwich
now on a computer we have many different
ways that we could represent this string
and memory on a computer the easiest way
would just be to have an array of
characters so a bunch of bytes one after
the other in memory but in a lot of
programs we use tree structures to store
data like a binary tree tree structures
have very useful properties in regards
to performance and memory usage well L
seq is no exception in the LS cqc rdt
data structure we have a very special
kind of exponential tree this tree in
particular has a root node and it can
have up to ten branches so the branch
factor if you're following me in digging
back into your bag of exponential tree
knowledge has a branch factor of ten now
you can actually tune this you can pick
other branch factors but for our
situation we're just going to pick ten
and each branch is labeled from zero to
nine for now zero and nine are just
reserved those are set aside for some
implementation details but all the other
branches can be used and each subtree
works the same way you'll notice that
these branches are labeled with some
number between zero and nine and they're
ordered from left to right so to convert
this tree to a string you might ask
yourself okay this tree looks really
weird how on earth do I turn this into a
string all you have to do is a
depth-first traversal starting from the
left so in this case we just go down the
tree and every time we touch a node we
print out that character and we start
with the left so it's depth-first
traversal and eventually we end up with
a string sandwich so in memory we don't
represent the string as a text document
or as an array of characters we actually
represent it as this
tree structure which will give us some
really cool performance benefits later
now we'll notice in this particular tree
it has three levels so to specify any
particular node in this tree we could
actually point out the particular
branches the particular branch number to
point to a particular node so if I
wanted to point to the node D down there
at the bottom I could say go down branch
three then branch seven then branch
seven and now you know how to find node
D well that sort of gave us a unique
thing it gave us an address you might
even call this an ID now this idea has a
lot of really special properties that
make it work much better than
operational transforms in particular so
this ID you'll notice can get
arbitrarily deep what this essentially
means is that you never have to move
things around in memory you just keep
inserting in between so unlike an array
of characters where to insert something
you have to offset everything after that
character with this data structure you
don't you don't move things around which
gives us some other really interesting
properties so TLDR the address is
essentially the ID for this node so if
we want to talk about any changes we
want to make in the document we could
talk about in insertion so let's say
that someone wants to insert the letter
Y between two other branches between
these two other addresses now if we look
to these up we'd see that these are the
notes for letters D and W so this insert
operation is going to return a brand new
address for us in other words where we
should add this new letter so if we
wanted to insert the letter Y this
algorithm is telling us hey you should
add a new letter Y you should add it at
the address 37.9 now unfortunately I'm
going to have to skim over this but
actually the bulk of the paper if you go
read about the LCQ algorithm the bulk of
algorithm it's actually about how do you
pick these IDs when you have multiple
choices because if you make bad choices
your tree gets very deep which
essentially means you lose the
performance benefits of having it
arranged like a tree structure
but depending on how the user edits the
documents you can't really figure out
which ID you should pick if you have
several choices so most of the paper is
actually dedicated to proving a unique
strategy that regardless of the users
editing behavior picks good IDs in our
case we're going to wave our hands and
we're going to pretend that we came up
with a great idea to start with we only
had two choices after all so to apply
this to the tree all we do is we go down
the tree looking for three seven and
then we see nine hmm there's not a
branch for that let's just add it that's
all we do and again if we were to read
this out as a string using depth-first
traversal starting on the left this now
reads out as sandy which now you'll
notice even though we performed this
text insertion we didn't move anything
we just added a branch now there are a
few edge cases where it does cause you
to move maybe two or three nodes but in
the general case you don't end up moving
anything in memory
this means that inserting into a tree
and deleting from the tree is fast
compared to a lot of other text
algorithms that were CRD tease these
were very slow and typically they didn't
work well what's the typical document
you do in Google Docs this algorithm on
the other hand is very fast but what if
we have Alex investigan and they're
making changes at the same time so let's
say that Alex did an insert operation
he's inserting the letter Y at the
address 37.9 and Beth is inserting the
letter H at 3:02 and these changes were
performed in isolation so now that
they're going to sync up what do they
have to do to resolve the conflict they
don't have to do anything they just
apply the operations they don't even
have to apply them in any particular
order and this is where that word
commutative you might have heard of so
typically we talk about conflict-free
replicated data types you'll also hear
another modifier where we call it
commutative replicated data types this
just means that the order of operations
doesn't matter if they happens
concurrently so a lot of CRD T's
including this one have this really cool
property that it doesn't matter if you
insert the Y first or you insert the H
first
you end up at the exact same copy of the
document this is because those IDs never
change which means they're immutable
which also means that once you delete
characters let's suppose you wanted to
delete that H even though you no longer
have a reference to that note in memory
if someone else was referencing that
node those IDs tell you where it used to
be so you don't even need a tombstone
for it so TL DR L seq allows you to have
very good memory performance because the
tombstones don't need to exist the IDs
themselves tell you where that item used
to be so if we read this out to a string
we now get sandy who which that's a lot
easier than what we were doing with
operational transforms now the tree of
course looks crazier than just doing our
little offset by one trick but this
works for any number of tiers it turns
out it's very resilient for long offline
spells so the key takeaway with CRD T's
is that conflict resolution is baked
into the data type itself so a lot of
times in computer science you'll hear
about algorithms and data types being
two different ways to solve the same
kinds of problems and this is a classic
example of that and it turns out the
data type approach is very elegant it
also works really really well so in
particular that L seq algorithm data
type is very powerful for text documents
unlike operational transforms it doesn't
require a central server in other words
if you have four people working on a
document they don't need a one Pierre
translating operations between them that
can talk directly to each other in sort
of a gossip style so if you had ten
people on the top of a mountain without
any internet connection why not
it totally works this algorithm also
doesn't rely on any tombstones as we saw
or complex garbage collection strategies
which are often the hardest part of
implementing some of the tombstone based
algorithms so in turn this means that
the size of an LCQ tree grows very
slowly and because it's a tree structure
this generally means that when you apply
an operation or like say insert a letter
or delete a letter it happens
in log N
time because the tree structure means
you can get to these different nodes in
the tree much faster so LS CQ the very
powerful algorithm unfortunately it's
mostly hiding in an academic paper
there's one implementation of it I'm
aware of which is one that I've hacked
on this is a JavaScript implementation
of it it's a very interesting algorithm
and the implementation is a very
research paper so it's probably not
something you'll use in a production
application I do have a demo I'll be
showing however to show you that hey it
actually works and it can work with
multiple peers now there's actually some
really cool CR DT at work that's been
happening right now just in the last
year a really exciting new CR DT came
out it actually came out the week or so
before I first gave this talk and it's a
CR DT for JSON documents so imagine
having a tree structure that has the
same constraints of adjacent and being
able to automatically resolve changes in
conflicts to it
so the JSON CR DT is really amazing for
cases where you want the CR DT approach
for maybe something that works more like
a tree instead of a string so some
examples that come to mind read up state
maybe you just want to auto magically
sync state between a couple react apps
that are powered by redux you could
throw Jason C R DT at it or maybe you
are dealing with a no sequel database
and you want to resolve conflicts and
some of those objects you could use that
now unfortunately this is mostly hiding
in a paper this is version 2 of the
paper they massively revised the
notation which isn't any easier for me
to read than it was the first time
there's a reference implementation in
Scala and there's just really great
implementation in JavaScript - not
really
I really wish there was um in fact I
would love to implement this I banged my
head on the paper notation for a couple
months now it's quite beyond me so
actually if you're good with Scala or
mathematical notation or Haskell please
come find me because I would like
nothing better than to work with you for
the over the next few days and hash out
some sort of JavaScript
imitation because what more natural
place to be using peer-to-peer and
collaborative stuff than in the browser
where we all have internet connections
or we're using WebRTC so help me make
this a reality
I would love to build this sort of thing
so now we've looked at some different
algorithms for dealing with conflicts so
now we get to the second part of this
talk which is how do we communicate
those changes now there's a lot of
different strategies for dealing with
this maybe if we have an internet
connection we don't even have to worry
about that but if we're talking about
algorithms that work between multiple
peers without a central server we might
as well talk about peer-to-peer
networking there's a lot of difficulty
to doing peer-to-peer networking and I
am just barely scratching the surface
because I only know the surface because
peer-to-peer networking is hard you have
to solve quite a few problems to deal
with creating a reliable and secure
peer-to-peer mesh network that just
automatically works in particular these
are four of the hardest problems you
deal with creating a peer-to-peer
network so the first is how do you
create a good network topology one that
is fault tolerant so there are ten
people in a room and each laptop is
going to connect to maybe two of its
peers at most how do you pick those
peers in such a way that most people can
get a message to everyone else in such a
way that its fault tolerant that's a
difficult problem how do you discover
those peers to begin with so what's the
discovery mechanism how are you going to
relay those messages in such a way that
you won't hear echoes maybe the same
message makes its way back to you a few
times how you make sure that you haven't
heard this message before and then of
course securing it how do you make sure
that this message is authentic and comes
from someone you trust so with network
topology let's suppose that Alex and
Beth are up in the mountains and they
have a lot of hiking friends with them
probably because they like sandwiches
and they offered the rest of their
picnic and maybe Alex wants to send a
message to Beth and there was this one
connection but the connections a little
bit fuzzy if that connection drops out
Alex now has no way to talk to Beth
that's not good so there's an alternate
network topology that if we had that it
would be much more resilient to problems
so now if any of these connections drops
along the way there's a better chance
that Alex will be able to get his
messages through to Beth and so for the
most part we can just assume that if
Alex wants to send a message to Beth
that it eventually gets there
somehow or another and so then we can
abstract away this networking layer and
we could just assume that hey if I want
to send messages from Alex to Beth the
message will eventually get there and
it's reliable and it's secure all of
this ought to be provided at the
transport and networking level now some
of this should probably sound familiar
because we're basically reinventing how
the internet already works with routers
so the tcp/ip protocol has incredible
fault tolerance if any router goes down
or one of the connections gets clogged
TCP IP can automatically detect that and
pick alternate routes it also handles
things like throttling connection speed
and resending packages that packets that
get dropped
so these are all things that ought to be
handled at a networking level it turns
out it's just a little bit harder with
peer-to-peer because instead of having
routers that handle this sort of thing
now you're making everyone's computer a
router so thankfully some other people
have done the work of reinventing the
internet for us so you might be
interested in checking out some of these
different popular protocols these
different network transports which give
you reliable ways to send these messages
in a peer-to-peer fashion scuttlebutt
gossip hyperlapse there's even a binary
library that you can pull in called lib
p2p that gives you a lot of these
network layer tools that you can use so
there's a lot of really cool stuff out
there it is a little it's a little bit
heady oh but most of it's beyond me so I
just list it it's a little bit easier
than trying to explain how all the magic
works any sufficiently difficult problem
domain is indistinguishable from magic
now if you're interested in seeing some
more peer-to-peer awesomeness some
different things you can deal with that
there's this really great page I spent a
lot of time just diving through this all
kinds of cool demos just showing you
some of the cool problems you can solve
with peer-to-peer algorithms and
peer-to-peer networks now the last
component was Alison best if they're
going to do this writing they need a
really great collaborative editor and
this is where the fun begins for
front-end developers creating this great
experience so Alex and Beth can start
collaborating on the go so I'm just to
motivate this a little bit I'll show you
guys a demo that uses the LSC queue data
structure and in this case I'm cheating
because I'm going to be using mdns under
the hood just to get them connected but
this would theoretically work over any
transport so this is a rich markdown
editing experience it's powered by
content editable in the browser and as
you would expect it doesn't work
probably because I started this a few
hours ago all right
hello sandwiches
so hey it's a markdown editor really
exciting right but the point of this is
to show you LLC Q is doing this in the
backgrounds and LLC Q is just very
powerful for text documents but now
imagine you had three or four people
working on this think about what kinds
of experiences and problems you could
solve with any collaborative approach
maybe you're a musician maybe you're
interested in how can three or four
musicians collaborate on sheet music
together there's some really cool text
languages out there like lily ponds that
allow you to describe music in text
perhaps you could rap a collaborative
editor around it or maybe you're
interested in just replicating redux
state you can pull the json CR dt and
get these incredible collaborative
experiences for free there are a lot of
really cool solutions out there and a
lot of cool problems that you can apply
C Rd T's to if you're interested in
seeing the source code for that
particular demo and some of the hacks
that I did on the LCQ code you can check
out this repository I do have a fair
amount of work I haven't committed back
to it because I just did a lot of
hacking and I wasn't too sure I was
ready to commit it yet but between these
sorts of algorithms and a lot of really
exciting connectivity options that are
coming out soon there's a lot of really
cool stuff you can do that has nothing
to do with an internet connection in
particular I'm really looking forward to
LTE Direct imagine being able to do
peer-to-peer mesh networking with people
from miles away without a cell tower
there's a lot of really cool
opportunities coming out and a lot of
cool new standards coming out that would
allow Alex meds to collaborate with a
crowd of friends over any of these
supported networking options and since
there's no central server and you don't
need an internet connection you can just
directly talk to each other this gets us
all closer to making great collaborative
experiences for digital nomads like Alex
and Beth again we focus on collaborating
as a writer but these same algorithms
could be applied in music or to artists
who want to collaborate anywhere with
the digital Nomad lifestyle
it's just that all these algorithms are
hiding in academic papers you know some
light bedtime reading so there's a lot
of cool stuff out there but
unfortunately a lot of it is hiding so
if you're interested in carrying away
some of the covers and helping me figure
out in particular Jason C rdt please
find me because that is one that has not
proved to be light bedtime reading now
if you're interested just in things
related to the digital Nomad lifestyle
or you like pretty pictures feel free to
check out my site yellow scale.com or
you can find me on twitter at nibbler
any questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>