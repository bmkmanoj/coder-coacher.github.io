<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Post JavaScript Apocalypse  - Douglas Crockford | Coder Coacher - Coaching Coders</title><meta content="The Post JavaScript Apocalypse  - Douglas Crockford - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Post JavaScript Apocalypse  - Douglas Crockford</b></h2><h5 class="post__date">2017-03-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/99Zacm7SsWQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to
bakka lips so what
are some ideas about what should be in
the next language the language that
replaces JavaScript being an optimist I
believe there's got to be a next
language it doesn't stop here
so just be sad for our children right we
need to figure out of so the title of
this talk is actually quite
controversial there is some experts who
who say that it should be
we put JavaScript apocalypse and others
who say now now it's the patched
JavaScript apocalypse in this confusion
post put in patch is due to HTTP the
hypertext transport protocol it contains
three commands for moving some
information from one machine to another
and they are almost identical
but there are concerns that in some
cases it makes a tremendous difference
which one you use that disaster could
occur if you're using the wrong one but
it's not clear from looking at the names
which one that should be and in what
situations so I see this as a problem I
think in a well-designed system it
should be obvious what the correct thing
to do is and you shouldn't have to
struggle with these sorts of confusing
things so I look on this as a source of
clutter and clutter messes things up and
actually makes things worse for us we
spend our lives accumulating stuff it's
been said that the the one who dies with
the most tool most toys wins and silly--
accumulate all this stuff and we think
the stuff that we have has value we
think of it in terms of its cost of
acquisition or maybe its cost of
replacement but actually the more stuff
you have the more likely that the stuff
is going to have negative value to you
that it's getting in the way it's
actually degrading the quality of your
life in some cases you're looking for
something that you know lives in your
stuff and you cannot find it because
there's all this other stuff in the way
so that that extra stuff is reducing the
value of the valuable stuff to zero
while adding no value of its own in some
cases some of your stuff
literally destroying other stuff you
might have a pile of stuff and it's the
weight is destroying the stuff that's on
the bottom or maybe the stuff on the top
is leaking down into the bottom and it's
making stuff worse so there's this idea
that you can improve the quality of your
life by getting rid of some of your
stuff you identify the stuff that you
don't need and then you put it on eBay
or you sell it recycle it or if it's
worthless you can get rid of it if it's
worthless plighted nevermind anyway
thinking about clutter it's a difficult
thing to deal with so I look to an
authority this is Kumari or Marie Kondo
brilliant Japanese woman maybe the
world's biggest authority on
organization she teaches people how to
organize their homes and places so that
they can enjoy them better and she
teaches how to store and organize and
fold and get rid of stuff so one of the
things she teaches is you go into a room
and you take everything in the room have
the drawers off the shelves and put it
in the middle of the floor and then you
pick up each item and you ask a question
of each item you say to chemical deskah
which means you throb do you vibrate and
if the thing speaks to you then you keep
it there's some emotional connection
with that thing that this is something
you keep and if it doesn't then you
think about getting rid of it now when
she teaches in English she doesn't say
throb or vibrate because it makes some
people giggle like that guy
oh so instead she says does it spark joy
which is just delightful so you pick up
the thing you ask it does this spark joy
and if it does then you definitely keep
it if not you should consider getting
rid of it so I would like to apply her
methodology to our programming systems
to our you know particularly to our
programming languages
but spark joy doesn't work for us
because everything sparks joy we love
all the clutter in our languages and we
we can't get rid of it and so sparking
joy is not a sufficient criteria to get
rid of the clutter in programming much
as we need to so I want to show you some
examples of clutter things that we've
lived with for a long time
perhaps so long that we can't even
recognize that they're cluttered and
look at what we might do to clean them
up I'm going to start with ASCII the
American Standard Code for information
interchange ASCII is a really important
code it was for a long time the standard
character set the United States it is
still the first hundred twenty-eight
characters of the Unicode set so ASCII
is still in use everywhere in the world
it contains two characters which are
problematic and they were both borrowed
from typewriters space is from the space
bar it's a thing that allows the
carriage on the typewriter to move
forward one character space and the
other is cab tab was short for tabulator
or cab ulation it was a key that when
you pressed it would release the
carriage allowing it to move freely
until it hit a mechanical obstruction
called a tab stop and the purpose of tab
was to make it easier to type in columns
of numbers so we have both of these
characters and they can both be used in
the preparation of computer programs and
it's not obvious which is better than
the other and so we use from both which
is itself a problem because there's some
coding standards which are hostile to
one another it makes interoperability
more difficult sometimes makes
formatting more difficult but more than
that it's just a colossal waste of time
that this argument about tabs versus
spaces just goes on and there's no end
because it doesn't appear that anybody
is right so there's a brilliant show on
HBO called Silicon Valley
anybody seen Silicon Valley
it's the best show ever made about
programming you should all go out and
buy HBO because HBO deserves to be
compensated for making such a good show
about what we do no one else has done
that so you know you also get if you buy
Silicon Valley you also get Game of
Thrones and Westworld and stuff like
that but this is the show you want this
is the good stuff so it's about Richard
Hendricks who is a brilliant programmer
and his adventure is in trying to start
a software company in California he's a
brilliant guy he works really hard he's
spending so much time trying to start
his companies that he doesn't have time
to find a girlfriend you might know the
type or he might be the type anyway in
season 3 he finally finds someone and
she's perfect for him she's nice she's
smart she's a programmer she seems to
like him for some reason
but she uses spaces instead of cans and
it makes him crazy and it turns out his
affection for an invisible control
character is greater than anything he
could feel for another human being and
so he ends up destroying their
relationship because he uses cows he
just so you know all the human misery
that's caused by this conflict tab
spaces what to do so this is clutter
right with two ways of doing things I
want to get uncluttered I want to do it
one way so I'm going to get rid of one
just so that we stop all the waste and
all the confusion all the craziness
which one do you get rid of there's only
one that I can get rid of I need the
space space is an essential thing it
does things besides put things into
columns so I've got to get rid of tab I
don't need tab and I know that's going
to make some of you cry but that's just
how it is
turns out tab does not spark joy so now
we know
[Laughter]
so ASCII also provided two characters
for quoting things the single quote and
the double quote and JavaScript employs
both so in JavaScript you can make a
string with double quotes or a single
quotes when they work exactly the same
way they just look different and for a
long time I tried to figure out how to
make sense out of that that you know for
some purposes I want to use a single
quote for other purposes I want to use
the double quote and I thought it made
sense but I saw other people who had
different conventions which also made
equally as much sense than they were
incompatible and like there's no way to
resolve this so ultimately I think we
have to get rid of one and the one that
makes sense to get rid of is the single
quote and that's because it's also hope
well no it's because it's overloaded as
the apostrophe and so there are you're
more likely to make mistakes using
single quote than double quote and I
really down on the stakes I'm trying to
figure out how to be error-free as much
as possible so single quote does not
spark joy one of the the most important
things that ASCII did was come up with
the way that we encode uppercase and
lowercase the original plan for ASCII
was it was going to be a six bit
character set that would give you 64
codes which isn't very much and in order
to support lowercase they're going to
add two control characters for doing
shifting so you could shift one way and
you get lowercase characters and shift
the other way and get uppercase
characters if they'd followed through on
this then everything would be just a you
know we teach our kids that's an A and
there are two ways a can look but
they're both a and that's how it works
so we would distinguish uppercase and
lowercase the same way we distinguish
bold and weight or italics or
underlining or color or
thing else but we didn't do that and the
reason we didn't was at that time they
were shipping these character codes over
teletype lines and those lines were very
noisy and so it was not uncommon for a
character to get a bit or more damaged
and it would arrive garbled and their
concern was that if a shift character
gets garbled then the rest of the
message is going to look stupid you know
it turns into shouting and stuff and we
didn't want to do that so to avoid that
particular error they decided to
increase the size of ASCII to seven bits
I gave mine to 28 characters and then it
became possible to give each of the
lowercase characters a unique code and
in doing so they invented case
sensitivity which had never existed
prior to that and the concept and that
is a source of bugs for us today you
know some things want to be case
sensitive because it's faster and some
things want to be case insensitive
because it's correct and boom you know
so that happened I can't fix that's too
late for that one JavaScript gives us
let and far at least sense key at six
they both do the same thing they both
declare a variable in a function which
you definitely want to be doing but it's
confusing having two of them and I've
seen people argue well you should use
var in this case and let in that case
you don't want to be doing that it's
just confusing so we want to be using
just one of them and I think the one we
want to be using is let and the reason I
prefer let is the Java guys don't get as
confused if you're using let because let
respects block scope we don't need block
scope but the Java guys don't understand
function scope and so we should do that
now the problem with this recommendation
is it does not work for ie because an IE
let doesn't exist so it's a syntax error
so my advice is stop ie
write
no more ie even Microsoft doesn't let
any more they want us to move the edge I
think they're exactly right let's stop
doing that yet six also introduced Const
which is like Colette except you cannot
modify that variable anymore or you
can't replace that variable with another
value which is a good thing so generally
when given a choice I would prefer to
use Const than let JavaScript gives us
to bottom values null and undefined
there's an argument in the language
design community share the language even
have bottom values but there's nobody
who thinks you should have two of them
and you know due to some accident
javascript has two of them and they are
not interchangeable for many purposes
they work the same but there are some
specific cases where they're not and
when you have things which look to be
the same but aren't actually the same
for no good reason
that creates confusion and bugs and
that's bad so I want to get rid of one
of them and usually when I have a choice
between two words I want to go with the
shorter one
but not this time this time I'm going
with undefined and getting read null for
one thing null has the the type of
problem type of null is not null it's
object which is horribly wrong and if
you never use null then you don't care
so that I can stay broken and nothing
breaks undefined as a is not a good word
it's really confusing but you know we're
kind of stuck with that now the idea of
null as a special kind of pointer as a
standard feature of programming
languages is due to Tony Hoare there's a
brilliant British programmer everybody
know whore yeah and they should teach
history here the important stuff anyway
he came up with that idea and he now
regrets it he calls it a billion dollar
mistake I don't know why he didn't call
it a billion pound mistake but the color
billion dollar mistake and he came up
with that figure by estimating the
accumulated cost of all of the
nullpointerexception said he
cause so you know it shouldn't be a
special kind of pointer that fails it
should have been something else what I
think it should have done is in a
mutable empty object in the sense of a
JavaScript object where it's a thing and
you can't store anything into it if you
try to store anything into it that'll
throw an exception and if you try to
extract anything from it you'll just get
it all again which would be fine and it
could be implemented in a JavaScript
like language very simply we just create
a constant which contains a frozen the
empty object that doesn't inherit
anything so in fact for some purposes
instead of using undefined you might
actually want to create your own thing
give it another similar confusing name
like maybe nil and non or something like
that or even empty and do that with it
now functional programming is becoming
really really important now finally
after well we started doing functional
programming in the very late 40s early
50s and it's just kind of now getting to
the mainstream javascript is a to senses
of a functional language a functional
language is a language that uses
functions there are two senses of what
functions mean there's functions as what
we do in programming you know like a
JavaScript function there's also the
idea of a mathematical function and that
sometimes called pure functional
programming a mathematical function
isn't really about computation it's
about mapping a pure function will map
values from one thing to another and the
process of mapping doesn't allow for
side-effects or any other stuff going on
it's just one thing so in a mathematical
function in a pure function a given
input will always yield exactly the same
output and they allow for no mutation no
side-effects nothing else is going on
just them happening every one value to
another and that turns out to be a
really cool thing and you get some nice
benefits from that
one of them is testability programs
written this way become much easier to
test because once you've shown that a
function returns the correct value
you're done nothing else can ever cause
that function to now misfire or behave
incorrectly so that significantly
simplifies the process of testing an
even better benefit is in composability
that when functions are pure you can
string them together and compose them in
really interesting ways and that becomes
a very very effective way of programming
much more efficient maybe the best
benefit is parallelism the problem we
have with threads and in a crappy
language like Java is that we're trying
to do read-modify-write of shared memory
and that is an inherently dangerous
thing if you do it incorrectly it means
you get races which are horrendously
difficult bugs to find and correct the
way you mitigate that is by locking
which slows programs down profoundly and
if you're just doing stuff with pure
functions you can run full-speed that
the functions never read-modify-write
because we're not allowed to mutate they
can't have side-effects so they just run
and run and run and there's nothing to
slow them down so the fastest programs
that we can write are probably going to
be functions that are pure which is
again a really good reason for doing it
so we can convert JavaScript into a pure
functional programming language and the
way we do that is by removing the
impurities so we'll start by removing
the date function because every time you
get you'd call the date function you get
a different value and that's not a
mathematically pure function so we can
get rid of that we have to get rid of
the random function same reason every
time you call random you get a different
number that's not pure so that's got to
go we have to take out the delete
operator because it can modify an object
we have to take out object type to
assign and similar functions because
they will attempt to modify an object
we can't allow for modification array
dot splice and and all the other array
methods we have to take those out as
well we can keep slice because it makes
a copy of an array so that one's good
but the ones that modify an array we
have to get rid of array dot sorts could
have been a pure function but it was
implemented incorrectly and it is not so
sadly we have to get rid of that one the
regular expression exec function wants
to modify the regular expression object
so sadly that's got to go
assignment right equals something that
goes the VAR statement if you don't if
you don't have a sign materials we have
to get rid of that as well but we can
keep Const console has a role so we
could call a function and put its return
value in a Const and then we could use
about value in multiple places in the
remainder of the function that's that's
cool that's pure we can do that for
statement that wants to modify an
induction variable we can't be modifying
so for us got to go it's not probably
loops in general probably going to go
users turns out every time the user does
something it could be different users
are surprisingly non-mathematical so
you're going to have to go and the
network yeah and every time you get
something from the network you could get
something else so that's not pure so
networks got to go so a pure functional
programming model doesn't make any sense
because the universe is mutating and
unless no programs can deal with the
mutation of the universe they're limited
in how useful they can be but purity is
still really valuable and so we need to
figure out the models which allow us to
be as pure as we can while still
permitting enough impurity to actually
allow us to get work done one of the new
features in es6 is generators something
that I think shouldn't have happened
just because it's unnecessary
a generator is a function which every
time you call it will return a new value
so generators are not pure but they're
still very useful and it turns out using
higher-order functions you can get
generators without the weird special
syntax with the yield and the asterisk
so this if you need generators this is
how I think you should make them so
we've got a factory function which is
the thing that makes generators and it
can take arguments and the variables of
the factory function become the state
variables of the generator and the
factory returns a function which is the
generator function and each time it's
called it will compute a new value and
update the state variables that are in
the closure of the outer function and
return the value this is a really
straightforward pattern it's really easy
to write so here's a an example this is
the element generator which will receive
an array and return a generator which
will return each individual element of
that array really straightforward I like
this better than the equivalent thing
you would get by using the function star
syntax callbacks are really important
mechanism for dealing with a
synchronicity and and other patterns and
there's a question or callbacks are also
used in continuation passing style it's
a really powerful way of expressing
programs and so it means that a function
not only gets its normal arguments it
also gets a special argument which is
the function to call with result and
there are two places where you could put
it you could make it the first parameter
or you could make it the last parameter
and up until now it's been up to you you
want to put it in the first position you
want to put in the last position and
since you have a choice we will
apparently at random choose one and then
we will argue about it and
that makes it a Ralph's ability much
harder because if I'm putting them first
and you're putting them last my code has
to work together it's just annoying so
it'd be good if we could figure out what
the right answer is and it turns out es6
tells us what the right answer is that
they want to be first the reason they
want to be first is we now have the
ellipsis operator which is my second
most favorite feature in es6 which says
take all the rest of the arguments and
make an array and stick them in there
and pass that as the last argument and
that only works in the last position
which means if we want to call back the
call back really needs to be in the
first position so those of you are
putting in the last yeah it got some
work to do
promises were added in es6 because yes
because w3c was was threatening to
standardize them and echo said you can't
do that you can screw it all up
so basically Ekman took w3w three C's
spec and published it like which didn't
really prevent anything from getting
screwed up so we got that the original
purpose of promises was not to provide
for a synchronicity but that's the major
function for it now and I don't think
they do all that good a job they've
actually do work and they're much better
than doing nested callbacks but I think
we could do better for example I
developed a library called our queue
which is sort of a cryptic name I kind
of regret that now but I was feeling
very terse the day I named it which
provides for a much nicer composable way
of dealing with a synchronicity
particularly for the kinds of things you
would do in a server where I want to do
these things as a sequence or I want to
do these things in parallel and I want
them to all compose together and be good
in an asynchronous way our queue does
that so we get really emotional about
our syntax we love the syntax and it
turns out syntax really doesn't matter
but we don't know that we love it and it
syntax has more to do with fashion than
with functionality and so I want to look
at a few examples of syntax through the
ages so we'll start with Fortran Fortran
4 was my first language and this is how
we wrote in its statement in Fortran in
Fortran well lowercase hadn't been
discovered yet when when Fortran was
made so everything was all in uppercase
in Fortran spaces were not significant
so that if you said if space a that
looks exactly the same to the compiler
as Aoife and so when they design the if
statement they came up with the idea of
using the parentheses to separate the
keyword from the condition because
spaces couldn't do that in Fortran and
similarly they used the closing parent
to separate the end of the condition
from the consequence BCPL was one of the
first good parts languages it was
modeled after an earlier language called
Cpl which I think was designed not too
far from here and it's the first
curly-brace language really nice-looking
language and I think they got it
basically right
so in BCPL the parentheses around the
condition were optional and the curly
braces around the consequence were
required which is really really smart
unfortunately when the B language and
then C and then Java and JavaScript in
all of those languages they got it wrong
again they went back to the fortunate
convention so they required the
parentheses around the condition which
really doesn't accomplish anything and
they allowed for leaving the curly
braces off of the consequence which
turns out to be a problem that it's
really easy to write an if statement
which appears to control several
statements but it only controls the
first very common source of errors and
because of
that I recommend always put the curly
braces in every time on every if and
every else always put the curly braces
in because it increases the likelihood
that somebody including future you can
improve that program without breaking it
l golf 60 was a brilliant language
designed by committee it's very rare for
a good language to be designed by a
committee and that was the one example
and they did such a brilliant job they
decided let's do it again
so they convened a second committee and
they developed Algol 68 which
unfortunately was a mess and very
cluttered and didn't get well adopted
but I really liked their if statement I
think Dijkstra suggested the syntax and
I think it's just lovely so instead of
having the curly braces or blocks or
anything like that be just have a five
statement which balances the if and the
nice thing about this is that when you
look at a program you've got lots of
curly braces and the curly braces
represent the end of blocks the end of
functions the end of object literals and
sometimes it's hard to know when you
look at a curly brace who are you
closing and a lot of what we're closing
is ifs and if the if is using a
different convention that it's much
easier to read the program it's much
clearer what's being delimited and it's
easier to write programs that are
correct which is really nice I think we
can improve a little bit on this one so
this is my suggestion for if there any
language designers in the house I would
like to see this in the next language so
I think Python had the right idea about
respecting line breaks now where a line
break is significant it's probably
significant to us as well as to the
compiler so let's just hard code that
into the language it's not being the
case I don't need for them so we can
take that out and there's a lovely
little language called rebel
which uses Coulomb as its assignment
operator which i think is just so nice
so I would shorten it a little bit more
I don't think I'd want to go much
farther than that
because you know if you get too cryptic
then you start to be APL and we don't
want to go there but I like the idea of
trying to be as minimal as we can on our
syntax without losing clarity and I
think this might be a way to go so
talking about not Cleary so we've got
the try statement exception handling is
an important idea because we don't want
to have after every function called to
query the result and ask did you fail or
not because that really slows things
down so the idea was we'll have
exception handling so that we don't have
to do that testing so this is the the
way you would write a try-catch
statement in java or some other crappy
language now they look like this it's
big there's a lot of stuff in it so the
interesting that is the code that might
fail that's the stuff that we're trying
to protect that we don't want to have to
query everything that happens within
that block and then there's everything
else so the finally bit is there because
Java did not have functions and
basically what finally wants to do is do
this stuff no matter how we exit from
the try and the way that java virtual
machine implements finally is with a
subroutine call there's a subroutine
call in return which is in the language
specifically for try catch or for
finally and they did it that way because
they didn't have functions which would
have been the correct way to do it and
so since we have functions in JavaScript
we don't need finally so I think I see
finally it's just big noise then we've
got all of these catch clauses so what's
going on there the catch clauses are all
there because of a failure in the type
system so
often a particular function or method
might have multiple kinds of things that
might happen there's one that is most
likely to happen but there's another
thing which is expected to happen
sometimes you know like maybe it get to
the end of something and that's going to
be a different kind of response but
that's not the same as failure which is
what exceptions were intended to catch
and so because the type system doesn't
allow a single method to return things
with multiple types it will instead use
the catch clause as an alternate control
flow in order to sneak stuff through so
it's a misuse of the exception system
again motivated by problems in the type
system and so basically what you get is
code that looks like the Fortran
assigned goto which is quite an awful
thing where some other piece of code
will determine what our path is going to
be through this stuff which is quite
awful now JavaScript because it has a
superior type system basically it
doesn't care I'll allow you to send
whatever you need back and see you don't
need to overload the exception system to
handle your current result so in
JavaScript it gets much easier so
basically you try plan a and if that
works you're great and if it doesn't
then you'll go to plan B you don't even
care why it failed it shouldn't matter
why it failed you just know it didn't
work so let's do the other thing and so
that's much better so that was an
example of how having a loose type
system allows you to write better code
another example of Java's dilemma with
with types is in the index of operator
or index of method so it wants to return
the character position at which we find
a particular substrate
but there's a chance that it might not
find it and so what they should have
returned would have been null or
something which indicates whatever we
want returned we got this instead but
they couldn't because ball is not
compatible with int so instead they came
up with minus one and the expectation is
you have to remember that minus one is
this weird thing the problem is that for
some of the string methods - one is
meaningful like on slice it means the
last character of the string and so you
can get into trouble if you're not aware
of this weird stuff it's going to happen
so let's talk about some more about
types and hints so what is the type of
the result of adding 2 into 32 together
anybody know in truth what is the true
answer of the well I didn't think I
would stump everybody but the answer is
int 33 33 because the result of adding
two 32-bit ends together is you could
get one that's one bit more Java and
many other languages get this wrong they
think it's in 32 which means that if
that happens if you get an at 33 answer
the most important of all of those bits
gets thrown away without any
notification and programs go wildly
wrong so let's look at another one what
is the type of into 32 times into 32 any
guesses
well well okay the answer is in 63 in 63
but Java thinks it's in 32
so it's wildly wrong it's going to throw
away a whole lot of bits which again as
a source of terrible errors so there's
this idea that our type systems are
helping us that they're preventing us
from making mistakes but in fact we can
show that the type system is causing
mistakes here's a famous example and
this is true of almost all of our modern
languages today 0.1 plus 0.2 is not
equal to 0.3 and I think this is
shocking I think this is inexcusable
but it gets worse than that it breaks
the associativity you know so 0.1 plus
0.2 plus 0.3 is not equal to 0.1 plus
0.2 Putt plus 0.3 now it associativity
works if in computer arithmetic if the
if the two operands are represented
exactly and if their result can be
represented exactly and if not then then
associativity will give you different
amps will break and the problem is in
these languages including Java Script
0.1 can not be represented exactly even
though it has a very simple trivial
decimal representation and it's because
we're using binary floating-point and
binary floating-point was something that
made a lot of sense in the 50s but
doesn't make sense anymore but we can't
stop doing it so I recommend that we
stop doing it and this is how I
recommend that we do it this is a new
number type called deck 64 it stored in
a 64-bit word it contains two portions a
56 bit coefficient which is just an
integer that's shifted over eight spots
and an 8-bit exponent and the value of
the number is the coefficient times 10
raised to the exponent
this was inspired by a representation
that was used in the EDSAC anybody know
EDSAC nation they should teach it as
more history EDSAC was one of the first
on the scene it was built not far from
here
it was brilliant and wonderful and you
should know this this is important stuff
anyway I proposed modernizing that idea
and bringing it back and when we do this
then point one plus point two will be
point three one of the nice things about
this representation is that in a
hardware implementation adding any two
numbers with the same exponent for
example integers will execute in one
cycle and being able to do that means
the advantage for having int goes away
and so there's no reason to happen so
any more that I propose that all future
languages or all future application
languages use only this number type that
having a single number type in the
system means that you cannot make a bug
by choosing the wrong number type which
is a good thing to have so if you're
curious about it for example if you're
an amateur language designer and you'd
like to try it out there's a reference
implementation in x64 assembly language
it's on github you can go get that so
let's talk some more about numbers
what is 0/0 so it's actually a very
complicated question there are a lot of
answers to this question most
mathematicians would say it's undefined
and not in the crazy sense with Java
scripts undefined meaning it's
meaningless
it doesn't make sense to talk about 0/0
it's just not possible it don't don't
say that anymore just it's not a thing
except in computation things will happen
because someone will divide 0 by 0
anyway so the machine has to have some
defined behavior so one possible answer
is the machine should catch fire
because it's it shouldn't happen so it
shouldn't matter that the machine
catches fire we know that that's
actually not a good thing to do another
possibility is it should be man because
that's a representation of something
that's meaningless although man has much
more meaning than meaningless has but
that's something we could say another
answer is it should be zero because zero
divided by anything should be zero and
if that's for a lot of business
applications that is the preferred
answer or it could be 1 because n over N
is 1 right sometimes I once programmed a
mainframe where the answer was - it was
exactly - it was a machine designed by
Seymour Cray who's the greatest computer
maker who ever lived and when you
divided the 0x0
with a floating-point divide he got 2
and I'm sure somebody at control data
said hey Seymour we checked this out and
we get a 2 here and he said I'm not
going to fix it because if I fix it it
means it's going to add more circuitry
to which is already a very complex
circuit and I don't want to do that
because it's going to make it more
extensive and it's going to add one
cycle to the divide time which will
penalize all of the correct uses of
division and I want the machine to be
very fast for doing the correct things
and only an idiot would try to divide 0
by 0 so I'm not going to fix it and they
got away with it
and as far as I know I'm the only person
who ever divided 0 by 0 on that machine
and I survived they didn't catch fire or
anything it was good so the reason I
went through that was I'm actually more
concerned with this case what happens
when you multiply 0 by 10 which would
the answer cannot be I think the answer
should be 0 regardless of the value of M
and it and compiler writers used to
think so too
so if a compiler saw that zero is going
to be one of the factors of a multiply
and if the other operand is pure meaning
it has no side effects we do not even
need to evaluate it we don't even need
to generate the code for looking at it
we just return zero we're done and so
the compiler goes faster and the program
runs faster and everything is great that
turned out to be an error when the new I
Triple E floating point standard came
out because it said that if n is man
then the answer has to be man I think
this was a mistake that it made things
go slower in all cases to protect us
from something that shouldn't have
mattered in fact there are some programs
that really want to be using zero times
n in a meaningful way so who writes code
like that generally not humans but code
generators do and macro processors
partial evaluators those sorts of
programs can make very good use of zero
times and also on modern CPU is one of
the slowest things we can do now is a
conditional jump and sometimes instead
of coding a conditional jump we can
encode multiply something by something
that might be a 0 or a 1 and that
multiplication can be significantly
faster in some cases doing two
multiplications in an add of either 0 or
1 or 1 and 0 that's faster than doing
the conditional jump and I don't see any
benefit that comes from getting an an
out of that so I would propose in the
next language that all of these forms
return zero just because they allow us
to get a little bit more performance and
that we really don't benefit at all from
getting them from any of these so modern
languages have reserved words
and the reason they have reserved words
is it made it easier for compiler
writers and a time when memories were
very small for example a lot of the
early unix work early B and C work was
done on a I think as a PDP seven that
had like 16 K of RAM really tiny machine
and I got a compiler to run in there
which is pretty amazing and one of the
tricks they used in order to get that to
happen was they reserved a lot of words
in the language so the compiler we
didn't have to figure out does this mean
a variable name or does it
if means something that's a statement
form and we're still doing that our
memories have gotten much bigger we have
much better tools for writing compilers
but we're still using this constraint
the reason it matters is it's a hazard
for programmers because it means you
need to be aware of all the reserved
words in the language even if you don't
use those words because if you name a
parameter or a variable after one of
those then your program is going to fail
that's a bad thing and it's bad for
language maintainer z' because they want
to introduce new features into the
language but if there's a likelihood
that anybody else has ever created a
variable with that name then they're
going to create failure and they're
trying hard not to cause things to fail
so often what they'll do is they'll come
up with the with unpopular names for
example when exception handling was
first being proposed the way we would
cause an exception to happen was through
a raise command we're going to raise an
exception the way might want to raise an
issue or something we will raise an
exception also has sort of a hardware
connotation we're going to raise the
exception line but they couldn't use the
word raise because someone had used it
to raise something to a power and that
would cause breakage so they looked for
a word that means something like raise
that nobody was using and
in desperation that came up with throw
now most of you have never seen anything
except throw so it probably looks
natural to you now because you've never
experienced anything else but it was a
it was not the ideal choice so I propose
that in the next language we do it
better so in any function a word may be
used as a language keyword or as the
name of the variable or a parameter or
something but not both
so the programmer gets to decide so if
you want a variable called if you can
have a variable called if but you can't
also have an if in that function so this
is good for programmers because you
won't trip over features you don't use
if you're not aware that double for
example is reserved word doesn't matter
and it's good for language maintainer z'
because they can introduce new features
without breaking existing programs
existing programs will be using the new
feature already with a variable they're
not going to be using the new feature
nothing breaks another thing we argue
about a lot is how do we represent
variables or identifiers that contain
more than one word and we do this a lot
and we have two conventions for how you
do that we've got camelcase and we've
got underbar and we argue about it all
the time and there is one argument that
says use whichever one makes you happy
which is not good because when code is
written using both conventions it just
looks stupid and so we don't want to do
that but we can't agree on what the
correct thing is and so we just argue
and argue and I've heard really
ridiculous arguments on both sides of it
for example I've heard really smart
people say camelcase is better because
it weighs so much time when you have to
go shift up to the underbar but which is
just nuts so the reason we can't agree
is because everybody is wrong the
correct answer is names with spaces
what's the correct way to do it and we
didn't do this in the old days again
because there
is only a tiny amount of memory and made
it harder to write the compilers but
those constraints have been gone for
many decades now so I think it's time to
reconsider how we write our programs so
I proposed this rule in the next
language a name is composed of one or
more text atoms which are separated by
spaces and starting with an initial text
atom we combine them to make the longest
name that makes sense
that matches something that's been
defined in the scope and if a name makes
sense is yeah and if it doesn't make
sense then we just take the first token
and then we start again on the next one
really easy to implement and I think
it'll give us much nicer looking
programs something else I'd like to see
in the next language would be
programming by contract this is
something that the Eiffel language did
which was brilliant that you could have
a function and then that function you
have a little preamble or a requirements
section which says these things must be
true when we start this function and it
could be just a series of conditions and
and then at the end of the function you
can also say and when we leave this
function these things must also be true
and you can get how these preconditions
and postconditions provide very nice
documentation for the thing that makes
it extremely explicit what the
assumptions of the function are so
looking at that it's much easier to use
it correctly even more important that
stuff can be executed automatically so
we can turn on a mode which says that
stuff turns into code and so we now have
diagnostic checking running in the
program you know we can even leave it on
in production because it's pretty fast
and we get much higher reliability and
it gives us much better information than
types do as to what the expectations of
a function are so unfortunately it fell
out of fashion but it shouldn't have
it's really good stuff I hope we
we have that come back I hope that the
next language doesn't a much better job
of security because as the world is
becoming more distributed and we've got
programs running everywhere
and more and more of the value of our
lives are online it's really important
that our programming languages not
undermine us that they respect the
importance of our relationships and help
us to defend them so I don't have any
specific suggestions but I think it's
something we need to be concerned with
and when we look at the next language we
should look much harder at its security
implications because in the past we have
never done that and finally we should be
dealing with distribution because that's
how we're programming now going all the
way back to Fortran we've been doing
sequential programming where a program
does one damn thing after another and
that's not how we do stuff anymore
that we now have multi cores and we
expect stuff to be running concurrently
in all the cores and even more than that
we now have the Internet and the clouds
and all of that other stuff and so a
program is expected to run not just in
one machine in one memory space but in n
memory space with simultaneously and
providing for the coordination and
distribution of all that stuff that
should be built into the next language
because that stuff is really important
mostly what we get in our language is
our new syntax on the Fortran model
which is nice but it's not sufficient
the next language should take us much
farther
but there's another paradigm we need to
move into and I'd like to find that in
the language that replaces JavaScript so
um so that's the end so just want to
leave you with a warning be careful out
there because the web is cluttered in
full of errors thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>