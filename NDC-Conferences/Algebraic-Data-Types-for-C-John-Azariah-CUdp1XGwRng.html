<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Algebraic Data Types for C# - John Azariah | Coder Coacher - Coaching Coders</title><meta content="Algebraic Data Types for C# - John Azariah - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Algebraic Data Types for C# - John Azariah</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CUdp1XGwRng" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good day my name is John Ezra I'm
actually in Australian but I work in
Redmond I work on the Microsoft research
team doing some work with the quantum
computing group and I do function
programming and F sharp for day job so I
try to infect as many people as possible
with this disease and get everybody to
sort of look at things functionally and
so on so forth one of the interesting
things I've found is a set of tools that
actually make it very easy to solve
certain difficult problems and in some
sense this talk is actually about that
we're going to cover four major
questions you know what algebraic data
types why do we care why do we need them
okay so so now that you've convinced me
twist my arm that we need algebraic data
types what does it look like to have one
in c-sharp and then how do we get
c-sharp to actually give us these types
because it's one thing to write the
thing down by hand can you do something
better than that and really that's the
structure of the talk you'll realize a
little bit later on that there's a bit
of bait and switch but I won't tell you
what it is right just yet
you'll have to stay awake and ask
questions and stuff like that actually
thing too fast too loud to everything
okay
clear awesome who knows what algebraic
data types are Joe of course was cool so
we can start this with with the
appropriate kind of threat I've
threatened to hit you with type theory
at nine o'clock in the morning but this
is actually all the type theory you're
going to need and all the type theory
are going to learn what you're going to
hear next thirty seconds or so what is a
type a type you can think of a type as a
set of values okay so you have a set
which is just an unordered set of values
so now you have a set how do you make a
bigger set with two sets well there are
couple of ways of putting those sets
together to create bigger sets so in
some sense the question really is how do
you create a bigger type order
the type and the algebraic mechanism
that we're going to talk about is really
all there is to know about the type
theory behind this all right
have I lost anyone already no so there
are two ways of making bigger types or
the smaller ones at least two you can
think of them as basically mathematical
operators on top of sets so think of one
way of doing it is take every value in
one set and every value in the other set
and then just cross pair that will like
the cross join if you think about what
happens there the the cardinality the
number of elements in this product set
is actually the multiplicative product
of the cardinalities of individual sets
so if I have byte and character and I
put two of them together
well my composite type will have all the
possible bytes multiplied by all the
possible characters that's the
cardinality that I would get right and
some sense we're very familiar with this
because this is really the only sort of
type composition stuff that see c-sharp
and Java kind of encourage it's
basically structs of some kind another
way of doing looking at it is to
basically take all the values in the one
type tag them up with the name of the
type all the values with the other type
tag them up with the name of the type
and put them together in one set then
you'll have a sum of the cardinalities
of the constituent types you guys with
me sofa turns out that's actually very
useful to represent choice and when you
start doing domain modeling and stuff
like that with just product types
usually you'll end up having all kinds
of convoluted mechanisms to try and
limit the kind of limit limit the the
space of values to just valid ones and
so you'll end up having a whole ton of
things that are composed in the type
system but I actually invalid for use
and and then you have tried a unit test
to make sure that that invalid thing
doesn't actually show up or if it does
then you do the right thing
and in some sense you lose the ability
for the compiler to tell you hey you
can't possibly create one of these
things and you push it down to a unit
test kind of thing or a runtime check to
figure out whether you've got something
that makes sense or not
the other thing that we need to kind of
be careful about is value semantics now
if you think about sets sets and
actually sets of values but if you think
of a Java class or a c-sharp class the
cardinality of this of the type that
takes an int in a string for example of
a string is bad idea but an int and say
a byte right when you create a class
with those two properties the
cardinality of the set of those types is
not related to the cardinality of the
concision types because we can create
reference we can create references and
pointers so you can create a hundred
objects with the same int and the same
byte and the type system will think
they're the same but the runtime system
will tell you that they are different
because you're comparing references and
so it's important in our discussion here
to talk about value semantics and we're
going to try and get values actually to
be the the primary way we think about
types and sets and values and so on and
so forth so let's see so how many people
here do like domain driven development
for a living you know build business
applications boring business
applications yeah me too I used to do
that when you do modeling with a boring
business application at the moment so I
was just talking with Joe a couple
minutes ago we're talking about payments
right what's a valid payment or give me
cash of some kind you can give me a
credit card and you give me a check of
in the u.s. you can get a check nobody
nobody's checks you anymore do they know
but you can do this Abbi pay or whatever
it is and you'll end up having different
mechanisms for doing that and each of
those has a valid sort of adjoint value
associated with it so a check will be
associated with a check number credit
card associate with a credit card number
and the traditional way of actually
modeling one of those things is to
create this huge big record that you
store in database with the whole bunch
of fields are going to be null and then
somewhere along the line you have to
write a little piece of validation code
that says hey hang on make sure that at
least the correct thing is here so if it
says that it's a credit card account
there better be a credit card number in
there and that level of validation makes
it very difficult for us to reason about
the code itself how would it be if the
type system didn't let you put in a
check without a check number or a credit
card without a credit card number and
still treat the whole thing as a payment
and some sense that's really what
algebraic data types kind of good for
they make it easy to represent the
values that are valid and make it
difficult to represent values that are
illegal and consequently they do that at
a compile time rather than a run time
kind of 3x check so the type system in
the compiler is actually going to
support you to make sure that you're
doing the right thing and this is not
whimsical and this is probably the only
time you'll hear me say this in the
entire talk but there's actually
mathematics behind it there is actually
strong mathematical theory that equates
or relates propositional logic and type
logic and it turns out that if you have
a strong type system you can actually
make strong claims about when the
compiler passes a program whether it's
actually correct or not you can make
certain claims about that so algebraic
data types are useful for that kind of
thing and now let's go and see what they
look like in seizure so we looked at two
different types there's product types
and there's product types and then
there's sometimes so the way in which we
do product types is very familiar
everybody knows how to do this modulo
the value semantics piece right
everybody knows how to build
code in a struct or whatever it is
that's kind of a product type it's
basically a tagged tuple if you want to
go with strict mathematics you have you
know a name associated with each of the
of the fields and that becomes in effect
a product type
the thing about value semantics there
that changes things because you can't
modify anything anymore right because if
you say make something immutable you
know a struct of B comma 3 is always
going to be B comma 3 it'll always be
that so if you want to change the struct
you have to actually have a new struct
that that has the appropriate value if
you want to make 3/4 then you have to
have a different struck there is B comma
for a different value in the type system
that needs to come out and of course
that makes it kind of difficult to write
because you know every time you want to
do something you're going to copy it and
then set the things so the only time you
can actually make a change in the state
of the the struct the container is at
construction time and so every time you
know imagine a struct with 40 40
different values in it you got to make
sure that all the 40 different values in
copied over very brittle code every time
someone adds a new property you're going
to be more trouble right and it just
looks like you're about to shoot
yourself in the foot the way to get
around it is to use a copy constructor
so effectively we will have some way of
actually saying here's a different
constructor that allows me to set just
one or two or three or four properties
and everything else that I say is
actually from the source object and
should automatically happen now I'm
going to show you what the code looks
like but let's just talk about the
structure for the moment and just get an
idea of what what the code would look
like you know we'd create a sealed
partial class because you know we don't
believe inheritance like there's no
inheritance of values what is it what
does it mean to inherit 3 doesn't mean
anything well you can't inherit a tuple
of 3 comma B well so we'll create a
sealed class we'll call it will make a
partial though because then we can do
some interesting things with adding
other behavior to the type but as far as
the type itself is concerned we only
need to have it as sealed
it'll have read-only properties because
you want to be able to look at the
individual fields inside the tuple we
need a constructor because the
constructor is how we actually create
the initial parrying in the first place
and then we talked about sort of vaguely
about this width thing which basically
turns down and says yeah I have 15
properties you can set any two of them
or any one of them whatever it is you
want and I'll copy the rest over from
the original source that you have and
that should make it easier for us to do
something functionally and then there's
value semantics which make sure that
when you equate be comma 3 with another
object that says be comma 3 they
actually do turn out to be truly equal
so there are a couple of interfaces that
dotnet has to that Norden its ask you to
provide you need to override a couple of
methods and there's a bunch of
boilerplate that needs to go in there to
make well your semantics book right now
some types are a damn sight more
complicated actually what we'll end up
doing is how do we normally how do we
normally model some types in
object-oriented world base class bunch
of derived children some kind of runtime
check to say which of the types of
children you've got and then you have
you know so how I mean payment if you
know if you crack open a book on c-sharp
and ask how payment is actually
implemented there'll be an abstract base
classes called payment and then there
will be a check payment which inherits
from payment and there will be a credit
card payment which inherits from
something else and so on and so forth
and you'll end up having this mechanism
where you see treat something as a
patient payment but when you want to
actually figure out what kind of payment
it is you've got to do some runtime type
dispatching or runtime type checking to
figure out whether you're dealing with a
cheque or a credit card or whatever it
is there's a problem with that what if I
had a new type of payment how does the
compiler tell you that there's a whole
ton of code there that's actually only
trying to check against three different
types when there's a fourth type that
I've just added you guys must be using
resharper so because you don't have the
sense
horror on your face but the reality is
that in a very large system or in a
system that is only dependent on an open
hierarchy and open open inheritance
hierarchy you're going to land up having
this problem and we don't want to have
this problem we want to have a closed
hierarchy that basically doesn't allow
you to add something without you knowing
about it you want every time something
changes in the payment hierarchy you
want all the places where payment is
used to actually turn around and say yes
I know how to handle this new case or oh
we don't have check payments anymore I
don't need to handle this new case I
don't need to handle this old case so we
do that by basically creating a closed
inheritance hierarchy and we make it
opaque so that we don't actually allow
anyone to see what the individual types
are inside because I don't want any
runtime checking because once I do that
how in the world am I going to get the
behavior that I want which is going to
be different for checks and different
for credit cards and different for cash
how am I going to actually make that
happen well we use functional techniques
for this what we'll end up doing is
we'll create a method called match and
we'll give a different lambda for each
different case and what that can do is
delegate to the appropriate match
implementation inside the class and that
can actually do the right thing so
that's the structure the code might
actually look something like this let's
you'd have a private constructor with a
sealed partial abstract class so nobody
can actually extend this class anymore
nobody can actually instantiate the
outer class there's no concept of making
a payment because you have to tell me
what kind of payment you want so there
is a private constructor that prevents
you from doing anything funny with the
outer class but I need to create one
value constructor per type on the inside
so I'll have to have a check payment
type of thing over there or a cash
payment type of thing over there so the
choice constructor would allow me to
create any instance of an object
and the instance of the object would be
one of those private sealed partial
choice classes so I created
one class for every type of discriminant
in the in the discriminated union and be
able to create an instance of those so
the only way you're going to get at one
of those choice classes is through this
constructor and the only way you can
actually get the choice class to do the
right thing is to call the abstract
match function and say here are the four
things that I the four choices that I
have run the lambda against each of
those run the right lamda against each
of those and because that is abstract
and you have a concrete match function
that overrides that abstract function
the right kind of payment will will
accept the call and call the right
lambda with it and so in some sense you
basically do a dynamic kind of dispatch
but you're doing it with static safety
so imagine what would happen if I create
a new type of payment well I would have
to open sealed partial I would have to
open this class add a new choice class
inside it and because I added a new
choice class inside it I would have to
add a new argument to the abstract match
function fix all of the others to
actually fix the right thing fix all the
call sites to say hey you now have a new
type of payment that you have to deal
with what if I have a Bitcoin payment
give me the lambda that I need to use in
your case and and so compiler will now
step up to the game and say I'm not
going to let you go until you fix every
one of these things and the whole bunch
of runtime problems go away and in some
sense this is exactly how of course I
know on top of that you have value
semantics which is a constant now this
is in fact how most function language is
actually implemented if you look at the
inside where I shop Union it'll look
kind of like this if you look at a
scholar discriminative Union they
explicitly tell you hey this is what I
want you to do create me a trait and
create me these three classes they're
actually inherit from this trade and
close the hierarchy for me
and in some sense this is kind of what
we want now I've wasted 18 minutes of
your time blathering on about type
theory why because really the problem
that we're trying to solve is this one
it's all well and good to understand how
you create an algebraic data type with
all of this boilerplate stuff but we
humans right we're lazy
we are error-prone who wants to be
writing this kind of stuff do you I
don't
I want the language to give it to me I
mean that shop gives it to me why try
and see shop do it it's Carla gives it
to me why can't she shaft do it so
really now what we're trying to do is
step back a bit and let's try to solve
the real problem that we won't solve
right what we really want to say is I
intend to have a discriminated union or
a an immutable record I don't care about
the implementation detail I only want to
tell you hey by the way I have a choice
class that is either maybe of something
or none because I don't want to have
nulls in my my code all I want to do is
represent that and then I want to use
some functional technique some
mathematically transformational
technique to write the code for me
because what are you going to do when
you have to write the code you're going
to follow a recipe
what is a recipe it's a program what's
good at running programs computers so
why don't we write a program that takes
this intent declaration and generate the
code does it sound familiar you kind of
do this all the time don't you this is
what compilers do this exactly what
compilers do you don't talk about bits
and bytes and moving things around you
talk about for loops you talk about maps
and you've talked about you know link
the higher level abstractions you want
to extend the language the compiler of
the language isn't giving you the
support right now what you want to do is
extend the language somehow and in some
sense
this is the bait-and-switch part of the
column that the whole talk I'm actually
not going to talk about type theory at
all that was just a sneaky way of
getting you into this room at 9 o'clock
in the morning on the day after the
party right because the Fayetteville
will be here
the really sneaky thing that I'm doing
the real thing I won't talk about is the
approach of being able to create
domain-specific language a little
language to represent an abstract
thought find a way to actually do the
transformation into code integrate it
into some form of tooling that allows
you to use this on a daily basis without
having to actually take a hair out by
the roots and start writing tens of
thousands of lines of code for all kinds
of stuff this approach I have found is
actually very very useful I've written
all kinds of stuff with it including
state machines running on our lanes and
all kinds of other things this is a very
useful pattern it's a very useful tool
to have under your belt so I'm going to
spend the rest of the 40 minutes talking
about how to go about doing that the
approach that you take the tools you'll
need and how you can actually start
experimenting so if you're here looking
for real hardcore type theory it's the
example not the point of the talk it's
the example in the talk is that okay
cool right Scott lation comes up with
really cool ways of saying things he has
a website called F sharp of one prophet
of course we're going to now do DSL for
fun and profit so I'm pologize team and
these are the sort of concepts that you
need in your mind in order to make this
kind of thing work so there's
representation right we need to figure
out what it is that we're trying to
represent we need a syntax we'll
probably need some semantics we need to
basically make sure that we understand
what it is that we're representing in
some sensible way not arbitrary way by
the way the arbitrary way is called a
spec and you give it to a developer and
then they sit and have discussions over
it for several months
this is math you're going to talk about
it in precise unambiguous terms and
there are tools for doing this and we're
going to talk about couple of them and
we're going to talk about how we're
actually going to implement some of this
stuff and this becomes unambiguous and
when you have unambiguous input you can
have reliable predictable deterministic
output and that's what that is and the
last bit we're going to talk about is
because we'll have Microsoft I work for
Microsoft and we use Visual Studio
because it is the best we have a way of
actually incorporating whatever tooling
that we have in here right into the
visual studio so you can have a
completely seamless dev experience even
though you cooked up the language on
Tuesday and you whip the whole thing up
by Friday people coming in on Monday
morning won't have to change anything
about the way they work they have power
in this right so let's actually talk
about how we're going to go about doing
this so the first thing we need to do is
figure out what idiomatic representation
of your problem looks like right you can
start by being simple you can talk about
you know I would like maybe you know you
you draw the architects will draw the
Maybachs programmers will write some
pseudocode of some kind and really what
you're saying is the pseudocode is in
some sense idiomatic
with what I want to represent and it
hides the detail underneath another way
of doing about it is actually using
proper semantics engineering now there
is actually a whole slew a whole
spectrum of tools that you can use
starting on the one hand which is simply
expressing the grammar of what you're
trying to do in EB and F or some fairly
low level tool going all the way up to
you know PL reread X and actually
building out you know an evaluation
context based semantics puzzle you can
do that you don't need to go all the way
to that side but there's benefit in
pushing things further to the right
because you'll end up getting more and
more structure in what you're doing
the outcome of doing the semantics
design is what is known as this an
abstract syntax tree and that is
effectively a type that tells you what a
valid node in this tree that represents
what you're going to represent what a
valid node looks like and again there it
becomes fairly straightforward to
actually use algebraic data types to
represent the tree so we'll use that in
a sensible language let me show you what
what I mean by that so can everybody see
this I'm going to show you the class
maybe okay now I would like okay let's
look notionally at this line right there
I'm really saying there's I'm going to
define a type which is a some type I'm
going to call it maybe it's a general
type of type T and it has two choices
the value constructor of a constant
called done a singleton a value
constructor that takes a value of type T
and I'm going to tag it with some so
remember that we had the two types that
we talked about and we're going to tag
each of the types and then put it
together the cardinality of this is
effectively the cardinality of T because
every T we're going to tag with some
plus one which is this unit that tells
you hey there's a value that is not of T
but it represents you know the absence
of something if I had to go through and
do just this one line and go through the
process of actually implementing the the
types that we talked about you know the
hierarchy and so on so both this is what
it would look like there is your private
constructor
there's your match function there's the
two value constructors here's a
container that holds the two choice
types here's what none looks like here's
the value semantics peace of none which
basically says if the other is none then
I'm equal to it otherwise make sure that
you know I am
actually the same as that because I'm
comparing to Singleton's and here's the
match function that basically takes two
lambdas one for man and one for some and
in the case of none it says call the one
that I need to do for now right and then
you do the same thing for some in here
but here you need to store a value and
so the constructor is a bit complex and
then you do the same thing over here and
here's the value semantics for the
top-level thing that says given 2 maybes
are they the same who wants to write
this on a daily basis I don't nobody
wants to the moment you start putting
credit card payment and all of this
other stuff you've got to keep track of
all of this thing and it just becomes
difficult to do the pattern here is like
I said safe because it sealed opaque
partial class that just doesn't you know
you can't do anything funky with it
but to get this level of safety you
really want someone else to do the work
for you you want to know machine to do
the work for you so this is an example
of what syntax might look like and this
is idiomatic if you saw this in c-sharp
9 you wouldn't bat an eyelid it doesn't
look like some other funky language it
just has a new Union keyword and all the
things inside are basically separated by
pipe it's not entirely unreasonable and
the record type is exactly what you
would expect from a struct again not
unreasonable so if I want to represent
this little language now I need an
abstract syntax tree that represents it
so I need to have something which
handles a namespace which handles what a
namespace name looks like handles an
arbitrary block of members in it a union
member looks like that
the record looks like that they can be
generating on Jan break this method this
constructor in here could be generally
cannot so it starts getting a little
complicated the moment you start sitting
sitting and thinking about this it
becomes a full-blown
exercise in language design so we
represent the ast
and in about 50 lines of a webshop
because the ast is actually builds on
top of things they start with the bottom
and work backwards
you got namespace which has a name which
is a kind of dotted name namespace
members have a list of namespace member
a namespace member is one of these three
types a using has a dotted name
associated with it a record a vaster and
so on and so forth then you build the
whole thing up all the way to the top
and you finally come up with I know what
a symbol is and symbol is just a bit of
string right so this is the most basic
piece in this and we're composing it all
the way down and we can build up an ast
with it now if I create an object of
type namespace will I get a valid
namespace you bet I will
there is no concept of giving me a non
using with a missing dotted name you
can't do that it's just not possible to
do it because if you say that the
namespace has a name space member the
namespace member is using it better have
a dotted name or method inside and
there's no way to construct one of these
things in an invalid way so now that you
have this thing and you have this thing
you need to find a way from go from here
to here and this interesting piece of
technology is called a puzzle now I'm
not going to go down and get into the
nitty gritties or how to use the puzzle
there's several very good references out
there Scot lation has one filter:alpha
it has 1f POSIX just go look for it
you'll find the nitty-gritty details on
how to get into that the purpose of this
talk is to say here's all the pieces
that you need in order to make this big
picture happen so and of course I'll
answer questions but I'll give you an
idea what that looks like right so
positive Combinator libraries like eff
posit do a very succinct beautifully
clean job of actually representing
pieces of code that transform text into
ast nodes they look something like this
which I will raise my mouse so if you
think about this forget about the the
prelude which is there just to make the
rest of it not look so red but a symbol
is basically a an identifier that may be
surrounded by spaces that's what we
defined the symbol as when we create the
ASD and this function called symbol now
basically we'll take a stream of
information a stream of text and return
to you the first bit of it if it matches
a symbol
similarly dotted name says get me a
bunch of identifiers x' separated by
dots and make sure there is at least one
of them because the dotted identifier
might actually come in useful somewhere
and we go all the way down you know we
have something that says you know here's
a list of symbols in the type argument
so for example you have the type
argument is very different from the type
parameter list of an instantiation so if
you look at if you look at this thing if
you look at this thing you can only get
type arguments over there you can't put
system dot enumerable dot list in there
you can't do that it's a type argument
on this side so this better be a symbol
it should be a list of symbols
potentially and that's what this says so
give me a type declaration is basically
the type argument has a bunch of symbols
separated by commas that have a point on
either side of it and then that should
be followed by basically a symbol
followed by optionally type hogs will
give you a type declaration and so on
and so forth so we go down to type
reference and then we figure out a whole
bunch of things and this is not quite 50
lines but 100 lines of code and we'll
actually figure out how to handle hole
all the way down to name space again the
brevity of this should astonish you
it doesn't take much to actually do the
heavy-duty work that we're talking about
the tools are there there's just a whole
slew of them that you just may be aware
of and then movement
have that under your belt this becomes a
valid alternative to actually hand
coding a bunch of stuff right how are we
on time 35 minutes okay
clearly writing now I lied when I told
you the DST wouldn't represent invalid
values somewhere along the line you can
pass in an empty string is it okay to
have a namespace with an empty string as
a name
well the symbol regex may give you an
empty string and what am I going to do
with it I need to find some way of
actually validating it so in many cases
when you're starting to write more
serious languages many cases you'll take
the ast that came from the positive
which would have actually gone through a
whole bunch of syntactic types yeah you
know a syntactic checking and if you add
a simple table to it you can actually do
type checking type of stuff so you can
build a C+ if you want using this
mechanism all right and have a symbol
table and pass it around make sure that
you're only referring to things you've
already declared and all that kind of
stuff but at the end of the day you may
have some semantic rules that you need
to apply so usually there's a second
pass in this whole thing where you've
given a tree and you write a visitor
pattern kind of thing that takes that
tree and returns another tree and this
the result may have nodes missing in it
because you've removed them or it may
have nodes injected in it or you may
replace a given node with two other
nodes or whatever it is that you want to
do the rewriting portion of this is
actually one of the phases in this whole
sequence now because we're writing the
stuff in F sharp we have some
interesting ways of composing these
building blocks I will use the word
monad only once just because I have a
reputation for being I have the
propensity to use it evidently so I'm
going to keep the reputation in life so
I did say monadic composition of these
individual blocks and that's actually
how you glue the pieces together so you
have a positive that gives you a monadic
value of an ast and then you
have rewriters to take monadic values
AST and then give you more of those
until at the end of the day you come up
to the last stage now how many of you've
used Roslin before Joe of course and
okay so we have one other person so
brave person who's actually used Roslin
have used quote dom has anyone use code
dom back in the day okay
so code Roslin is basically Microsoft
compiler services it has a full-blown
positive for c-sharp and so on and so
forth in the front it also has a code
generation piece which is very similar
to code the effectively replaces code
dog so how did how do you think Rosslyn
works well Roslin has its own EST right
it's good text it's going to take it
it's gonna look like c-sharp the text
looks like c-sharp it's going to create
an est that looks like the the meaning
of the seizure program it's going to do
a whole bunch of rewriting there so you
know all your refactorings and all the
other stuff that can happen happen in
the in the ast rewrite and then they
take that ast and they actually generate
seizure code with it that's frozen Allah
already knows how to do that if you give
it an ast that is valid now we want to
actually cheat Roslyn now we say yeah
I'll give you a valid AST oh you well
it'll trial Roslin AST you go off and do
the code generation for me and so the
last transformation that you do is write
a transformer that takes your AST
instance and converts it into a Roslin
AST instance and then you let draws and
deal with the rest of it and that's kind
of how we do this stuff but that's
actually kind of how do you say easier
said than done
let me show you what the Roselyn st
looks like so I'm going to again cheat I
want you to pay close attention to this
class so starting in line 23 I'm going
down to line 39 pay close attention to
that because the tree I'm about to show
you is only for that class now
the whole thing just this bit right
there's a handy tool out there that
actually allows you to generate the
Roselyn equivalent of one of these
things and it actually buffs if you give
it the whole class so I'm just asking
you to look at this so it's got a
constructor with an argument
it sets a property there's a private
property there's a match function
there's a bunch of overrides that even
you had there I'm asking you to not even
bother everything just ignore just let's
look at just that class if I did that
you see that thing over there
you're looking at that bit this is what
Rosaleen ast looks like anyone think
that it's easier to read boilerplate
code than the Roslyn ast because I
actually think that right you just shot
yourself in the foot by saying I'm going
to build this thing and this thing is
not even human readable I can at least
write the boilerplate code and look at
it and have somebody code review it and
make sure that it's actually doing I
think anyone want to code review this
right so how are we going to create this
thing from the ast that we had we had
nice clean ast that said here's a
namespace and it's got a union type and
it's got the Union type has a union type
member of you know something that takes
the argument E and just that one node is
going to generate this kind of thing how
am I going to actually get this piece
out and the answer to that is another
DSL that we clever cleverly wrote a long
time ago using sort of F sharp black
magic okay now sharp allows you to write
functions that have any number of
arguments and you don't have this
ceremony of putting brackets and commas
and things like that inside so because
everything in F sharp is just an
implicit list of arguments and you can
call things whatever you want we can
actually create complex looking
functions with the very complex argument
and make them look like the code we want
to generate i'll give you an idea what
I'm talking about here so I could write
a function called class that looks like
that which takes one argument called
class name followed by some white noise
argument which I'm never going to use
followed by a list of potentially type
arguments another white noise : and then
something that tells you about the base
classes and then a list of interfaces
that I implement followed by a list of
modifiers followed by something that
looks like a block and in that block I
will give you each of the statements
that I want to put inside now if you
look at this code it kind of looks like
what we want we want to create a class
right I mean this is what we want to
create we would create this class right
here okay a public partial class some
colon maybe T so class this would be
maybe of T and then it has a base class
which is the other maybe of T and it's a
public washroom class and it's got a
constructor inside it which has the same
kind of principle behind it and it has
an override for equals which has an
arrow method so you put a fat arrow in
there input in equality expressions oh
and so forth
this is much easier to write than it is
to actually compose the a Steve from the
transform and this library is available
on github so you can now go and get this
library down and it's got its funky set
of functions in there and you can go off
and actually write the code that looks
like that I'm going to switch to visual
studio now and I'm going to show you how
the real code actually looks and have I
lost anyone yeah I'll give you a second
give me give me a half a tick and I'll
show you the exact code all right right
so it's a good question so the question
that you asked was what does the
structure that function look like and
why would I use it so in some sense this
is what I talked about so here's our ASD
here's the posit that I showed you right
and this time you know it's all
compiling so it's you're doing the right
thing and here is the Declaration
builder for the Union type class and in
this case what I'm actually doing is I'm
going to turn around and say hey given a
union type member I want to create the
constructor formatter right the Union
type member will give me a name the
member name of the type and that's going
to be useful if the Union type member
has a type then I'm going to put a set
of arguments that says I need to have an
argument named value of that type
otherwise I don't so if I go back to
looking at this thing we look at both
the cases here
there's none and some in this case we
don't even have to create a constructor
because it's a singleton in the other
case we want to put a constructor in
there as long as there is a type there's
a type argument and in some sense that's
what this is
but what does this look like this
basically says hey I'm going to create a
tuple that looks like a tuple to you
right and it's good to have these two
things in it which is the name of the
variable and stripe so as soon as I
create a tuple it knows that that's
going to be the value that I want
outside and what is the statement inside
is basically please set the value
property the big value identify that
with a little identifier value and this
funky-looking operators effectively the
assignment inside our second DSL so
we're using the F sharp DSL the Roselyn
DSL to allow us to create expressions in
a nice clean way so that we don't have
to deal with Rozlyn at all
all the Roselyn member declaration
garbage that you need to put in from
this piece all of these member explicit
expressions and with the expression body
and so on and so forth all of these
things which form part of the Rosalind
language that creates the Rozlyn ast for
you is actually hidden away inside
things like this so this dsl is actually
available as I said it's available on
github so it now means that you can
write code that looks like this so here
is given my thing you know here's what
the constructor looks like I have the
assignment set up and that's based on
whether I had a type constructor or not
and then in the same way I have a value
property that only does something when
you have a so here's a they get a
singleton or a value and then I have a
type reference to tell me hey you know
that's a value of that type or just a
singleton value similarly the match
function over it does the right thing so
all of this starts to look similar to
the code that you want to write in the
first place and you can test each piece
individually and then it will generate a
piece of string that looks like the
thing that you want and you can make
sure that hey okay it's it's matching
what I want and that that passes my unit
test so I am now generating the right
thing compose the right set of builders
into this game if you like
then all of a sudden you have this
concept of the top level function taking
a whole bunch of these creators to give
you this so you know make sure that I
have the base value set up make sure I
have private constructor match function
extract the access members themselves
any wrapper type that you need inside
the equatable equals so on so forth each
of these things is now a method and that
goes into this thing so I take class
class name and then inside that you have
the members so this is a knot cleaner in
terms of being able to build up the
structure of the thing that you want
code generate rather than having to
navigate through the Roselyn muck
somebody else has already done the same
thing for you already
in that library so you can use that and
get this thing done right so are we
doing on time for you seven okay right
so does everybody see how you can
actually generate the Roselyn ast from
this thing using these transforms
because in effect this is the last pile
of transforms that take your ast which
is of this kind so this thing basically
takes a union type and gives me a member
declaration syntax right and these are
individual composable so rather than get
this huge morass of things that you had
in the past to get this whole tree and
then do tree splicing and all kinds of
other stuff you actually build the thing
up from the inside out by actually using
this functional composition mechanism
and you'll create a bunch of these
functions so this one goes from union
type to remember declaration there'll be
another one that does records
there's the namespace itself which if
you think about it has you know I want
to put in some warnings I want to use
the usings in there to make sure that
the right things he used so because I
might actually reference a dotted type
in the class I won't have a using line
put in there
that's going to get generated correctly
and then you have namespace
on apply and then you have this thing so
it turns out that it's actually fairly
easy to start putting these things
together because you're building them up
piece by piece and then composing them
into larger and larger blocks but at the
top level you'll end up getting
something that turns around and says
give me one of the names namespace which
is your ast on the left and I will give
you back a namespace declaration syntax
which is the Roslyn ast on the right and
then you can take that and give it to
Roslyn and say here's a valid tree go
off and generate code for it
and it'll do that so that's what the
code generator does actually
so it basically does this given a file
open the input file open our foot file
read though the text pause the namespace
from the text and then go from that
namespace to a declaration and then
write all the output in the output
you're done so in effect we built a
little compiler for a little language
using all the various stages of a proper
compiler and you can build an X and
executable out of this which you can run
on the command line but who wants to do
that let me actually come back to that
in one second actually I want to go back
so visual studio now gives us a very
cool set of extension mechanisms for
doing this has anyone here programmed in
asp.net WPF right so you guys know the
idea of the code behind file right what
is that code behind whether that code
behind file is the code representation
of the intent that you declared in
whatever markup that you had up in front
right why is that any different from
what I did just now I created some
intent in this Union thing
why can't I have a code-behind file that
actually has the same code and speak at
the back and then I'm done I can
generate break points and all kinds of
other stuff look at the code so it turns
out there's a very cool way of doing
this you take this instead of creating
an executable like I showed you you
create what is known as a single file
generator itself is a little bit of
black magic because it's not well
documented but it's roughly been the
same in terms of its ethos since 2003
it's the only place I still use com in
Microsoft in 2017 right it has not
changed at all there is actually a place
we do a query interface for an interface
and then you do a marshal whatever on it
so the single file generator approach
and the v6 packaging is a little bit of
black magic and I'm happy to show you
the code that does it
it's extraordinary simple you can
literally take the code that's in my
project and replace it with the function
that you have and what it is is every
time you save the the top-level file it
calls the tool gives it a bunch of text
and then expects to get a bunch of text
back and if anyone attended Joe's talk
yesterday about how to get two processes
to actually share memory it actually
uses shared memory to do precisely that
that's exactly what it does so it's a
very old fashioned comm inter-process
communication kind of mechanism but it
works it works beautifully it has worked
since 2003 continues to work today you
can provide even language support like
code coloring and so on and so forth
which I won't get into right now and if
you actually generate enough information
why you generate your c-sharp code you
can actually put breakpoints now in our
case we're only defining a type so
there's nothing to really put a
breakpoint on but you can quite easily
see that if you were representing
sequences of operations you might want
to step through the top-level language
rather than stepping through the back
end of it and you can actually do that
very straightforward way of doing it
through this through this mechanism both
of which I'm not going to talk about
right now
so let me how are we doing on time ten
minutes
excellent right yeah it's going to show
you the v6 code in the v6 code this is
what the code generator looks like it is
ugly as sin it might have been less ugly
if I done it the F sharp but then again
you wouldn't have you'd have it
this should horrify you and it in and if
that is the intent let's just put it
that way so we have a come visible true
you have to create for yourself a new
grid and you have to register yourself a
different type for the generator and has
to implement i via single file generator
and what it does I did not lie we
actually do get I unknown for object and
query interface and release yeah but
here's the magic you get the byte string
that gives you the input on the on the
input it gives you a string and you
generate code for the text and it
generates code which you then put into a
byte array and send back Yuko I like to
make sure that you have seen some shared
memory back and forth literally the only
thing you will change is the entire file
when you create your own little language
is this one line or this one but that's
it so everything in here the black
magics being sold out for you just
change that one function and you're done
you can it's text in text out and it'll
make sure that the generated file is
product and then they have a funny way
of actually making this code thing
available to anyone you wants it you
have to create a v6 project and go
through some mumbo jumbo to do that
again there's references out there that
allow you to pack is the thing properly
and then you'll get sent off to go and
put things on visual studio marketplace
so let me see actually do that
I think I killed the browser but there's
a video stream marketplace that you can
actually publish your your stuff on and
then that'll come up and you can I'll
show you how to do that so there's a
little bit of extra little effort you
have to put but it ultimately turns
around and gives you a very nice
experience developer experience I'm
going to show you the developer
experience I'm sorry for for fumbling
around like this but I'm losing my mouse
I'm so used to not having so I'm going
to take a look at this I'm gonna look at
the test classes here and we'll take a
look at this reference class you see
here and I've created this maybe CS
Union thing which has a bunch of union
types in there and I'm going to remove
the code generator right and what this
can when you're in a co-op project and
you create one of these files you can
associate it with a custom tool and this
is that custom tool that you registered
in in the comm database and when you
install a package you'll go in here to
the extensions and in the visual studio
extensions you can actually get from the
visual studio marketplace so the whole
process is a little bit correlated but
this is how we package it for everybody
to use you write this tool you put it
into v6 you upload the v6 to the
marketplace and then use extensions
updates to pull the thing back down and
now it's available to everyone the dev
experience is easier but this is how you
actually publish the thing out and then
you have this Union thing which I've
created and it has documentation and so
on and so forth and once you do that
this becomes available the custom tool
interface becomes available you can
stick that in here and let's say that I
go off and actually just make a change
and save the file and voila
it creates the code-behind for you and
this code behind should look familiar
this is exactly and now because it's
partially you can actually
create add adjuncts to it and do all
kinds of cool stuff so if you want to
actually figure out if you want someone
to tell you if you want me to tell you
how to turn this maybe type into a
functor or into a more ad I'm happy to
show you in fact you can actually get it
so that you can do link based syntax on
one that maybe now it's very trivial to
do it because I generated a partial and
then write another piece of partial code
and I'm done so it's a very powerful way
of actually building extensible code and
this is how it works alright so I'm
going to summarize now on what are the
steps that you need looks like a long
list design the semantics you need to
basically make sure that you have the
language grammar sorted out properly
think about the edge cases try and use
powerful tools they'll help you and then
once you do that make sure you get the
AST that that is equivalent to that
design reasonable syntax which actually
gives you the the AST once you pause it
write a parser for it
validate the thing using some tree
rewriting stuff write the code generator
to convert your ast into a Roslyn ast
and then set it up so that you invoke
the Roslyn code generator and put the
visuals who your plumbing in there and
pack is the whole thing into v6 and
babji don't go it done so even now
extended c-sharp now anyone who uses
this effectively extends it c-sharp to
have union types and product types
without any change in the developer
experience so instead of creating the
300 lines of boilerplate you write the
one line of top-level code someone does
the generation for you and it's all
idiomatic seizure up after that so
you're not doing anything funky there's
no background like you know binary doing
generation and all kinds of stuff you
can go back and put breakpoints look at
the code you know satisfy yourself with
this what's doing so in terms of
actually even bringing the concept of
Union types itself into the language for
you to use as a first generation type of
thing the key takeaways for c-sharp
programmers is effectively this
use ADT's they'll make your life easier
right and it's a good thing right using
this mechanism you don't really have to
even make life difficult for anyone
functional programmers think about the
idea of writing a domain-specific
language when you want to abstract your
problem up to the level where you only
need to talk about intent not the
implementation so the moment you lift
the abstraction level to the point where
you can talk about it sensibly there's a
whole ton of mathematics that you can
lean on that does the transformations
that you can actually generate the code
so favor machine written code over
hundred code favored higher level of
abstraction and there are tools that are
freely available the parser Combinator
library is available the code generator
is available and you basically can use
that to do you know good stuff and
sometimes you know you have to show the
seizure program is what they're missing
so you you got to get them across and
say this stuff worked for me it made my
life easier so it's good to learn it
kind of thing I think I'm done I want to
acknowledge Scott who basically has been
extraordinary influential in giving us
new concepts and stuff like that making
available for everybody to use a couple
of guys three guys from New Zealand and
the US and Australia who who helped me
with the functional side of things and
then Microsoft who I work for who is
sponsored by coming here so thank you
very much I will take questions for the
next five minutes though all the stuff
is available on github the v6 is
available in the workplace and yeah if
you have a problem with any of the code
I've written and you think you can do
better which I think you should give me
a pull request and I will happily accept
it
thank you Joe
yeah so like I said the type theory part
was the example not the point of the
talk right you are right in that you can
do you can you can use genex to do that
the issue will end up becoming when you
have none and some of T how do you
represent the thing that doesn't have a
value and in some some cases like that
you'll end up having okay payment
delinquent versus credit card partial
versus credit card full you don't know
that there's there's probably one
discriminant in there that doesn't take
a value how do you represent that and
there are also places where you'll end
up taking more composite types inside
and so and so forth so you'll end up
having two pools of tuples and things
like that so yeah I mean there's ways to
solve the the Union type problem then I
picked this because this is actually the
canonical way of doing it in Scala and F
now and it turns out that the the once
you put the syntax in place the the
syntax is favorably terse in c-sharp
it's actually more terse in c-sharp than
it is in F sharp because you don't
create some of T you just say sama T and
you're done so yeah you have a valid
point you can you can do your type
theory stuff however you feel like to
solve the problem at hand
but really the point of the talk was to
actually talk about using a bigger set
of guns that you can bring to the
problem to talk a more abstract way
anyone else cool thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>