<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Understanding parser combinators: a deep dive - Scott Wlaschin | Coder Coacher - Coaching Coders</title><meta content="Understanding parser combinators: a deep dive - Scott Wlaschin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Understanding parser combinators: a deep dive - Scott Wlaschin</b></h2><h5 class="post__date">2016-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RDalzi7mhdY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right well I think I'm going to
start a minute early this is pretty much
time so this talk is understanding cars
or Combinator's my name is Scott lotion
that's my twitter handle I have a
website f-sharp fun and profit calm and
the code and the slides and the video
will be on a directory called parser at
some point so this is one of my talks
where I try to squeeze like a whole
day's worth of stuff into like 60
minutes so as usual I'll be going very
fast and covering a lot of ground I
don't really as always I don't I don't
really expect you to remember everything
but you can get just some of the
concepts and if it gets demystified so
that's the main thing so it just becomes
less intimidating so I'm going to be
using f-sharp for code examples the
concepts will work in pretty much any
programming language other than COBOL or
something so here is a some typical code
using pars of combinators and when you
look at it when you first come across
code like this it looks kind of
intimidating the main thing is there's
all these strange symbols there's a like
a vertical bar thing and a angle
brackets with dots and stuff and I think
that's one of the things which is
particularly intimidating and so I guess
the goal of this talk is if you can
understand this code or at least not be
intimidated by this code that'll be a
success in my book obviously it's really
hard to learn everything in 60 minutes
but if you just look at this and say
that kind of looks vaguely familiar let
me look that up and see what it does so
first of all I'm going to talk about
what is a powers of Combinator library
and then we're going to build a very
very simple parser which will be the
foundation for the rest of the talk
we're going to build three very simple
parts or Combinator's and then we'll
start using those Combinator's to build
more complex Combinator's from the
simple ones we'll have a little
sidetrack
site excursion on improving the own
messages and then finally we'll get to
the core thing which is how to build a
JSON parser using these techniques so
what is a part of Combinator library so
when you write a parser there's
something you're trying to match it's a
keyword or SS into a string or a float
or something you're trying to match this
thing and you know in this model you
create a step in a recipe a parsing
recipe and you end up with this object
which is a parser of something so this
part of something is really a recipe
that when you when you run it later on
it'll give you back what it whatever is
the thing you're trying to look for so
you have these parts of things and then
you combine these parts of things with
other parts of things to make new kinds
of parts of things so this combination
of
combining things together that's what a
Combinator is that's all it is it's not
particularly mysterious but the whole
point is that when you combine things
you get things of the same type you can
then cascade that you can build on that
and make bigger and bigger things from
small and small things this is the whole
concept of composition why composition
is so important and especially in
functional programming why people are so
strong on using that technique so here
we have in this case a recipe to make a
thing see from an A and a B and then
finally when we've got the recipe the
parser we have to run it and when we run
it we get a success or a failure
depending on whether we succeeded in
matching the thing and in order to run
it we also need some input which is the
stream of characters that we're running
over so that's it that's parser
Combinator's in a nutshell
now why parse accommodators as opposed
to something like lex and yak or at low
or the various other techniques so the
first thing is that they're written in
your favorite programming language which
is nice you don't have to kind of drop
out into a different language to do it
which means also you can use your
favorite tools to do the programming in
which is nice there's no pre-processing
needed so the lexing and you know in
traditional parsers you have a lexing
stage and a parsing stage and you trance
on the ast and all its kind of stuff in
the pulse of Combinator model that's all
one thing and because there's no
pre-processing it's very well friendly
which you can use it interactively which
is kind of nice
because it's such a small kind of thing
you can use it to create little dsls
really quickly like a full creek the
software company they use the F parsec
which is the F sharp library for this to
write little DSL for parsing query
strings a search engine and you know
very very simple DSL do you say you know
something and something old quoted
string and or you know whatever just
like Google has a little very simple DSL
and finally from my pony this is a fun
way of understanding functional
composition so even if you're not going
to use it for anything it's a fun thing
to learn because it gives you insight
into what a nice functional library
looks like so let's start with a simple
parser and I'm going to create four
versions of this parser starting with
something really simple and getting more
complex so the first version of the
parser is going to be just parsing the
character a that's all it is
so in all this is going to be a function
there's at this parsing function this
gray box and there's going to be an
input which is a list of characters or a
string or a stream of characters
whatever it's going to return true or
false if it succeeds in matching the
character and it's going to return the
remaining input now if it matches the
character is going to it's going to
consume that character from the stream
and returning and return the meaning
characters what's really important is
that the inputs and the outputs are
immutable just like in all functional
programming and in particular that's
very useful because that means if the
parsing fails you can take another
parser and apply it to the same input
you don't have to worry that the file
pointers moved around and you're not
starting at the same place so that's a
key aspect of the Combinator design
so let's show you the code so here's my
peach I'm going to call it parts of
character a if the input is empty I'm
going to turn false if the first
character is a then I'm going to return
true and I'm also going to take the
remaining characters just by starting
from index 1 and returning the rest of
the string and if it's doesn't match the
first if it doesn't match a I'm going to
turn false so that's really brain-dead
kind of parser if you're not familiar
with f-sharp these are actually the
return values you don't need a special
return keyword in a shop so that's what
we're returning okay so that's version 1
version 2 is a little bit better
the problem with version 1 of course
it's a hard-coded four character a let's
make it a bit more flexible and allow us
to pass in any character so I'm going to
pass in an extra parameter now which is
the character to match so it could be an
A or B you could get really you know
really exciting here the other thing is
the output is going to be a bit more
complex this time because if it matches
I need to return the character that I
match because I don't know you know
whether it match not and the remaining
input and on the failure I want to
return a nice error message I don't just
want to turn true or false I want to
return a message like you know I was
looking for an A and you gave me a be
something like that so let's look at the
code for that very similar this time and
we're turning a nice error message know
what input if it matches the character I
returned the match character and the
remaining and if it doesn't match I have
a nice little error message if I was
expecting this and I got something else
the problem with this code is it doesn't
compile because the return values here
are different types that return value is
different for the other one and the
failure case and returning a string but
on the success case I'm returning a
payer a tuple of the matched character
and the remaining string so this work
compile so the way to fix this in a
functional programming language is to
create a union type a choice type I like
to call them which is a choice of either
case
so we're going to create a type I'm
going to call it results and it's got
two cases and see their success or it's
a failure and if it's successful it's
going to have a tick a that's the
f-sharp way of saying it's a generic
type in C sharp or Java without just be
like a capital T or something so those
the two choices and then our output now
has two choices as well on the success
branch it's the payer and on the failure
branch is the message so let's change
see how the code has changed so the now
that went in instead of returning the
string we're going to return the failure
of the string and it winds instead of
returning the pair we're going to return
success of the pair and again on the
failure case we're going to turn the
failure with a branch as well so that's
our version to code hopefully this is I
know going through very quickly but this
hopefully is really kind of obvious
roughly again the concepts are really
obvious the details of the code you know
don't have to worry about too much so
the return values are now the same type
when the compiler is very happy right
so that's version two how can we make it
more complicated so one of the things
about this model is that currently we
have this character to match and we know
this in advance when I'm looking for a
particular character I know that I'm
looking for a quote to a semicolon or
something I know that when I'm designing
the parser the input we don't know this
advance we don't know the input until
later on so what I really want to do is
be able to work with all the stuff with
with information I do know and and kind
of delay working with the rest of stuff
until I actually have it at one time so
the way to do that in a functional
programming language is to return a
function so instead of having a two
input function like this I'm going to
turn it into a one input function which
returns another function so you see
there's before and there's after so this
thing is now going to return a function
that function is just like the original
one it's got this little input stream
and it's got the result and so on so now
what we've done is we we've got a way of
building
a function that when we run it with an
input stream would actually do the work
inversion for we're going to take this
function which is kind of awkward to use
I'm going to wrap it in a type we're
going to just wrap it up so it becomes a
thing and we're going to call this thing
a parser and in this case it's a parser
which returns a char and here is the
type this is where it starts getting a
little bit ugly so the type of Plaza
it's a it contains a function inside the
type so this is definitely functional
programming here it's a a function which
is being would have been treated as an
object and the function in there takes a
string and it returns a results and then
we're wrapping it up in this parser type
so that's our basic parser so let's see
we'll go back to our recipe model and
see how it works we've got this
character we want to match we run it for
this thing we now have this parser right
and then we're going to combine all
these parses and remember that a parser
just basically means it's something that
if you give me some input later on I
will then give you a success or failure
later on ok and when I want to run it I
give the input and again if you look
inside the partically it's just a
function inside there so all I have to
do is run that function with the input
and it gives me the success or failure
let's look at how the one code works so
to run a parser with an input basically
you just unwrap the parser to get the
inner function and then you call the
inner function with input so the running
the piece of code that runs it is really
trivial all right let's see some code
that's enough talking
so this is the wheel coat there's the
result type
there's the posit i'p there is the code
that matches the thing there's the run
code see if this works
and so here is a a parser for the
character a whoops there's some inputs
if I won that character whoops no I
don't thank you very much if I run that
parser on that input I get this down
here it's a success this is the
character that was returned that's the
the character was matching this is the
remaining string but if I run it on bad
inputs like the first characters as a
Zed when I try and run it I get this
failure message I was expecting an A but
I got a Zed instead so that is it that
is our poles are done and dusted pretty
straightforward so hopefully that makes
sense that parser is that's it we're
done with the part of logic everything
else is now combining these parses so
let's look at some basic ways of
combining the pauses so this word
Combinator it has a technical meaning
which is basically any function that
depends only on its inputs which is not
really a very helpful function so
typically when we talk about
Combinator's we talk about Combinator
libraries and a Combinator library is a
library designed around combining things
to make new things okay
there's a Combinator library very common
in functional programming you have a
parser common little library you have an
HTML Combinator library you might have a
database Combinator libraries it's a
common way of designing libraries so
here's an example of a Combinator
addition is a Combinator adding two
integers you get a new integer if you
come if you can catenate two lists you
get a new list and in F sharp the the
app sign is the list concatenation and
finally if you add
do parsers together you get a new parser
so here's the question what is one of
the different ways you can add two
parses together what can go there
between the two so the first thing is
you can chain them in sequence so you
can say match this thing and then match
this next thing so I'm calling it at the
end then Combinator or you can say match
this thing and if that doesn't work
match this thing instead so I'm horny
Lee or else operator and another really
useful one is a map Combinator which
basically says whatever you've passed
transform it in some way into something
else so you might have passed a string
and you want to transform it into an int
just because you know it's a string of
digits for example so let's look at
these three basic Combinator's so the
and then one so this is the logic for it
you run the first part if it fails give
up otherwise you take the remaining
input and you give it to the second part
if that fails give up if they both
succeed we're going to return a pair
because we've got a result from the
first pass that we've got a result from
the second part so we're going to
combine them into a pair and return it
so let's look at the code so we're going
to define an inner function because
we've got this inner function all the
time we won the first parser we check
the result if it's a failure return if
it's a success we go to parse or two and
now I'm going to page down to the next
page so there's the inner function
there's the remaining and we're going to
use that remaining input for the next
bit we take this remaining bits we went
on the second parser we test the second
part of results if it's a failure we
return if success we've now know that we
have these two pieces we need to combine
so we create a combined value which is
the pair we call that a success and we
also we've now got the remaining thing
after the two parters so it's the second
remaining stream and then we finally
take this in a function and we wrap it
up in a parse and return it
so that is a really fundamental
Combinator written in you know 15 lines
of code so there's just important that
we have to keep track of which is the
reigning code there's the combined value
and there's the in a function that gets
wrapped up again the all else is kind of
similar one the first parser if it
succeeds we're done if it fails we take
the original input which hasn't changed
and we won the second parser on that
input and if the second person succeeds
we return and if the second player fails
we've returned it anyway so either way
we return the result of the second
parser and finally the map similar kind
of thing we when the parser if it
succeeds we take the last value and we
run it through this function to
transform it in something else and if it
fails we just give up so this is where
these funny operators come from because
we don't really write and then and all
else it's quite nice to use in fix
operators so in the F sharp parsing
world we use the dot angle brackets
angle brackets dot to mean the and then
and the dots are important we'll see why
the dots are important in a minute um
the else is a vertical bar and the map
is a vertical bar with double angle
brackets so when you see these symbols
that's what they are and then or well
sand map so let me actually give you a
demo oops
are the two
there we go there's the end then coach
there is the in fixed version of and
then there's the oil's codes
there's the in fixed version or else
it's the map codes and there is the in
fixed version of map all right so here's
some little pauses a then B right so we
take a and then we try and get B and we
want both of them and if we try and run
it on ABC we get a success we return a
pair and the remaining string is C if we
run it on ZB see the a is going to fail
so it's say I'm expecting an A and I got
a Zed now if we run it on a different
string the first the a is going to match
but the Zed is going to for the B is now
going to fail and you actually get the
nice own message I was expecting a B and
I got a Zed
so it you can actually tell you where it
actually knows about the different
parses and it keeps track of where you
are in the string so it's not bad here's
the or else thing very similar so it can
match an a certain set that works you
can also match Abby's head said that
works and then you can start combining
them you can say it's a B or C and then
it's an A or L and then a B or C and
here is a the map in action so I'm going
to take an A and a B and then I'm going
to map it I'm going to take this pair
which is a pair of characters I'm going
to turn each character into a string and
then we're going to add the two strings
together
and when I run that I now get a string
back rather than a pair of characters I
get a string with two characters in it
so there we go and here's let's do an
integer one so now matching these two
characters 1 &amp;amp; 2 again I got a pair of
characters I'm going to turn them into
strings and do that and then I'm going
to turn the resulting string into an int
so this should actually be an int like
this and let's see if it is there it is
it returns an int you can actually see
it says it's a result which returns an
int down here alright so that's it for
the basic Combinator's so already we've
actually done quite a lot we've got a
basic parser we've got a couple of basic
Combinator's and now we can really go to
town and start combining these basic
ones in more complex ways so let's look
at some of the ways you can do that
there's a function in functional program
languages reduce the reduce function and
what it does is it basically give it a
list of things or sequence of things it
takes some sort of operator and it
sticks it between every element in the
list so here is a 1 2 3 list with three
elements and it's going to be reduced by
the plus symbol and that's exactly the
same as writing 1 plus 2 plus 3 ok
that's what would use does now if we do
with pauses here we have a list of
passes so passes are things and we can
put them in a list so here's a list of
three doesn't pass and we're going to
reduce them using the and then operator
so that's exactly the same as writing
pars at character a and then pass
character B in m-files character C or we
can use the or else operator and combine
them that way
so that's the same as pass caret a or
else pass character b or else
bias character c so that's quite nice
and this vertical bar with the thing
that's the F sharp pipe operator if
you're not familiar with it it's just
kind of like the UNIX pipe but it takes
the one thing on the left hand side and
it feeds it into the function on the
next side okay so here's our first kind
of compound Combinator choice you give
me a list of passes and I will make a
single parser that matches any of them
so I'm just doing the list reduce that's
very nice but then we can take that and
build on that so let's say we have a
list of characters we want to match we
take that list of characters we won the
normal map which is built-in and we turn
we map each of those characters to a
plaza for that character so a mapping
using peach R so now we have a list of
parses and then we want choice and now
we have a single parcel which matches
any of the characters and here's a real
example let's say I want to cause any
lowercase character I just say any of
and I give it a list of characters that
I'm looking for or let's say I want to
parse any digits I just say here's the
list of characters 0 to 9 and any of
those things will match so already I can
even see I've built up beginning to
build up some complex stuff just for
some basic things
another important Combinator is the
sequencing thing so I have a list of
passes and I want to do them in sequence
and the code of this is a little more
tricky and first we're going to add the
helper function that given a pair of
passes it takes the the output the pair
and it basically lists can catch them
together from so I have a list of passes
I match each parser to a list singleton
and then I use this reduce with this
little helper function don't worry about
how this works the point is that in you
know six lines of code I've got quite a
powerful Combinator
and I can use that Combinator now to
make a parser that matches a string so a
string is basically a sequence of
characters and I want to match each of
those characters in turn so if I'm
matching the string true for example the
string literal true TR u e I want to
match each of these and if any of them
doesn't match then the parser fails so I
take each character in the string I map
it to a parser I use sequence to turn it
into a parser which returns a list of
characters I then convert that into a
list into an array of characters and
then I convert the array of characters
it back into a string and now I have a
parser for Strings and like I say the
code you notice I wouldn't I won't worry
about the other code really understand
the code but the point is that this is
like a few lines of code once we got the
basic combinators done the the other
Combinator's become very simple to write
so there's pars lowercase there's part
of digits so if I'm if I won the
lowercase parser it says yes I succeeded
and I found an a if I pass a lowercase
and it's the first letter of uppercase a
it's a failure I was expecting a Zed now
it's interesting because it's expecting
any of these characters and it's the
last one it gave up on the a gave up on
the B when it got to the Zed when it
gave up that was the error so say I'm
expecting a Zed that's a kind of ugly
error message and we will deal with that
shortly similarly with parsing a digit
let's move down to parsing a string so I
want to pass the string ABC if I pass in
a proper string that's successful it
matches ABC and the remaining string is
de if I put a bar in the second position
it knows that it's expecting a B there
and got a vertical bar if I put a bar in
the third position
again it knows that's expecting a C
there
so the error message is you know already
pretty good there could be better but
that's not bad considering we've
literally written like 30 lines of code
so far all right so we're not done more
combinators many many more Combinator's
you can build a huge library of
accommodators accommodated library so
the first set of Combinator's is what i
call the more than one Combinator's so
sometimes you have something where you
want to match more than one of a certain
thing more than one comma more than one
character whatever so there's a many
Combinator and a many one Combinator
which is one or more zero more and then
optional which is zero or one there's
really common and here's a good example
white space a white space character is
any of a space or a tab or a new line
and then white space in general is one
or more whitespace character so there we
now have a whitespace parser and we can
then combine that white space parser
with other process another ones I call
the throwing away
combinators we saw this one with a dot
on both sides that's the and then
Combinator sometimes you want to parse
something and then ignore what you've
passed you just want to match it things
like double quotes in the quoted string
or list literals or something you want
you want to match you and then throw it
away so in this one you put the dot on
the left hand side that means you keep
the left hand side you throw away the
right hand side in the second one you
keep the right hand side and you throw
away the left hand side
and another useful one is a between so
you have three passes and you pass the
first thing but you throw it away you
keep the second one and you throw it
away the third one and again that's
something like a double quoted string so
let's look at that there's a double
quotes pars of single cat has a quote
and a quoted int basically says between
a double quotes and pars an int and a
double quote so we'll throw the double
quotes away and just return you the int
that it's passed there you go
that's another one and separators is
another one really really common you
know a comma separated list or a
semicolon separate the list or something
same kind of thing one or more zero or
more here's a comma positive comma part
of digits and then parsing one or more
digits in a list is its digits separated
by commas and you have to have at least
one of those so I can demo that and here
we go some more you can see this this is
a little bit this some of this code is a
bit more complicated the overall parser
library is about 500 lines all together
so I can show you the full thing later
one all right so there's digits so to
define a digit and then digits is what
one or more digit and then an integer is
basically one or more digits and then
we're going to convert we find the
digits and we're going to convert this
using map into an int somehow with a
little helper function
and then when we run that it finds the
one but when we have two digits at the
beginning it picks up both digits and
when we have three digits at the
beginning it picks up three digits so it
is picking up as it will basically pick
up as many digits as you have before it
hits a non digit and similarly here's a
list same kind of thing
oops
so this is a comma-separated list and it
returns
I didn't positive problem
so you can see it's returning a list of
digits that it found
and if I change this to one two three
it successfully picked up a new one
there you go that's that's so I know I'm
whizzing through all this stuff but like
I say it's really the concepts of how
you build these things together all
right now we're doing for time here good
so what can we do now to improve the
parser the first thing we do is is named
the parses because as you saw in one of
those cases when it gave an error
message it said I was looking for as
their doors looking for nine and what
you're really doing is you're really
looking for digits and because the it
doesn't know that it's a digit it will
just give you the last thing it was
looking for which is kind of unhelpful
so what you can do is you can take this
parcel objects because it's an object
now you can just add a property which is
a name property and in this case we'll
give it a name we'll give it digit and
so when we use it like this with that
again as always we'll we'll create some
sort of cryptic operator to make our
lives harder for to hide it from other
people but in this case it's the
question mark so this is what the code
looks like when you run it without a
label is trying to parse the digits the
digit is defined as 0 up to 9 when it
when it can't find a 9 you'll say I
can't find a 9 which is a really helpful
message if you give if you take that
same parser and you give it this label
digit when it fails now it will now say
I was trying to pass a digit
I couldn't find a digit and again it's
much more helpful
and the other thing you can do obviously
which is really nice is to give you the
line number and the column number where
the parsing failed if you have a large
file obviously you don't want just say I
was expecting a comma here and doesn't
tell you we're expecting a comma that's
not at all helpful so again we just have
to take change our inputs take the input
object and so just having a stream of
characters we have a stream of
characters along with the current line
and the current column and then every
time we pass a character we we often you
know we increment the the column number
and the line number and we can wait a
nice little the error handing the
messages become it's nicer so here we're
trying to pass an integer the minus is
okay the Zed is not a valid integer and
so it says column 1 is an error and we
can put the even little caret saying
here we are in the line here's a float
this is Zed is long so on column 4 is an
error and again we can we can write the
the error line and we can also write the
little carrot telling you where this so
that makes the error handling much more
friendly so this is not very hard to do
is I'm not going to show you the code
because it's this is where does get it
about ugly but it's not that hard you
can see we always had to do it okay so
building a jsonparser and when you use
the JSON spec at JSON org and that has
lots of pretty pictures and this is the
first picture which is that the J
adjacent value is one of the following
things it's a string or it's a number or
as an object or as an array or it's true
or false or it's null so how can we
represent this in a shop well in F sharp
we can use a choice type so here's our
choice type adjacent value is either a
string with a string inside it a number
with a float inside it's an object which
is a dictionary of key value pairs
where the keys are strings and the
values are Jason other Jason values an
array is just a list of Jason values a
boolean is just a boolean and a null has
no value at all so that's a type that
represents a Jason value all right let's
start parsing it so let's start with
some easy ones the true and the false
and the null these are just literals so
we can just write we've already got a
thing that parses a string little
literals already so that's easy let's
start with null yet another little
helper operator and more cryptic symbols
and so I apologize for these cryptic
symbols but this is you know part of the
reason why these operate these libraries
look complicated because they have all
these obscure symbols you just have to
get your head around them make sure you
have a reference sheet on hand there
aren't that many though I mean you've
seen five or six of them and they're you
know once that once you get the hang of
it there's not that many you have to
memorize so what this one is going to do
is it's going to run the parser and it's
going to take the output but it's going
to ignore the output of the parser
assuming it succeeds and give you back
some result that you specify and that's
very common if you have a string literal
so in this case I'm looking for the
string null if I find it I don't really
care what the characters are because I
already know it's a null so I'm just
going to give it the null value which is
this J null is an f-sharp type or the
type constructor so I don't need to
process the contents of the string in
any way so I can just ignore it so
that's how you pass a null
and then I'm going to give it a label so
that when it fails rather than saying I
couldn't find an L it's going to say I
couldn't find a null which is much nicer
message
similarly for billions I have a parser
for the true literal and then I'm going
to map it to the a boolean value called
true I have a parser for the false
literal and I'm going to map it to the
false and then my boolean parser is just
a choice between the true parser and the
false parser so there it is than just
using the choice that or else operator
and then I'm again I'm going to give a
label boolean so that if it errors out I
get a nice error message all right what
about strings okay this is now it starts
getting a bit more complicated so a JSON
string can be any unicode character
runabout or it can be various escaped
characters or it can be a hexadecimal so
let's start with this one I'm going to
break it into components so one of the
nice things about parser combinations
like this is you can break the task into
small pieces and build the bigger one
from the smaller ones so I'm going to
just work on the individual subsections
and then combine them later on
so the first subsection I'm going to
work on is this one which says any
character other than double quotes or
backslash or control characters and I
microrna call this the unescape
character parser and here is the code
unescape character is something that
satisfies a character pauses so satisfy
the one you haven't seen yet it
basically says it give me a function
which is a predicate for characters and
if it matches that character it's okay
and if it doesn't match the character it
does it fails so in this case it it'll
work as long as the character is not a
backslash and is not a double quote and
I'm going to forget about control
characters now so if it satisfies that
condition which is any other character
that parser will succeed we will get an
unescapable
okay the next one I'm going to call this
set the escaped characters and there's a
lot of them there's like eight of them
so what I'm going to do is I'm going to
create a list of all the all the eight
possible things in the list and for each
thing I'm going to say here's the string
that I'm looking for and if I find that
string here is the output that I'm going
overturn so if I unfortunately we look
at you know escapes escapes so in this
case I'm looking for a backslash
followed by a double quote and I have to
escape them both and if I find it I'm
going to return the quote character if I
get a backslash followed by a backslash
that's going to return a backslash and
everything's doubled up if I have a
backslash followed by forward slash
that's going to turn a forward slash a
backslash all by B is going to turn the
backspace character and so on and so
forth and then I take all these pairs
and for each pair I'm going to convert
it into a parser and the parser is going
to take the first item in the pair that
the string to match and that's where it
says P string to match at the bottom in
red and if I find that thing I'm going
to return the results which is the
second part of the pair so I can process
basically a whole list of items in one
go and this is one of the nice things
about using a programming language to
write your parcels in is that this is
standard a sharp code this is nothing
special about you know the part library
so if I was using c-sharp I could use
link for example this would be the print
server using list map I'd use you know
dot select and that would give me the
same thing
and now I have a list of passes how do I
combine the list of passes into one
parser I use choice and so I've combined
all my pauses into a single parser
alright and then I'm going to label make
it nice and make the error messages
nicer and this final one is the Unicode
character I'm not going to show you the
code for that but basically you define a
parser for an individual Unicode
character and you have four of those
passes in a row starting with you you
know and that's how you define that and
now I have my three sub pieces and I
want to combine them together so the
string is basically a double quote
character followed by zero or more of
these characters followed by another
double quote character how do i define
that here's my quote character so it's a
peach R of a quote and I'm going to give
a label so it says I'm looking for a
quote the adjacent character is either a
none scape character or an escape
character or a Unicode character and
then the main parser for that is going
to be a quote character followed by zero
or more JSON characters followed by
another quote character and I'm going to
throw away the quote character so you
can see the dot is on the inside so this
is basically the same as the between
okay so that's the important thing that
can build up more complex parsers by
combining the simpler passes so it's
tedious to write apart I mean the Jason
spec you know it's not that hard but
it's kind of tedious you have quite
complicated little things but if you
just follow you can just follow the
railway diagrams and write the code
pretty much corresponds exactly for the
railway documents one of the really nice
things about this style of parsing and
then a proper JSON string is that as a
quoted string and then I have to map it
into one this j string objects which is
one of those cases in the main in the
main type we had and give it a nice name
alright numbers okay this has been more
intimidating so break it into smaller
pieces there's a sign which is optional
there's what I'm calling the integer
part which is either a 0 or digits 1 to
9 followed by zero or more normal digits
ok so let's look at that so there's the
optional sign I match the - and I say
it's optional I can be zero or one of
these hyphens the zero part is just
matching the string 0 ok the digits 1 to
9 is basically any any parser that
satisfies where the character is a digit
but the character is not zero the normal
digits are anything where it satisfies
where the character is a digit so and
I'm using the chars digit well than 0 to
9 just in case there are some unicode
digits that either not an ASCII digits
I'm not an expert in Unicode but almost
certainly this weird numbers out there
somewhere all right so nonzero integer
we said is a one to nine digit followed
by zero or more normal digits so I'm
going to combine them using that dollar
and then and then I want to turn that
into something useful so I map that I've
got a little pair
I turn the first one into a string
because the first one's a character the
second part is going to be a string and
I combine them into a new string so I've
now got a string there and then finally
the entire integer part is either the 0
bit or the non 0 bit so it's tedious but
it's it follows the design you can see
it follows the well wave you know it's
not hard to write it's just boring to
write
same thing for the fractional bits a
fraction is a decimal point followed by
one or more digits that's easy to write
there's a decimal point it's a decimal
point four by one or more digits the
exponent part is either a lowercase e or
an uppercase e followed by an optional
sign followed by one or more digits blah
blah blah same kind of thing so you know
it kind of gets boring after well
writing all this stuff but there you go
the good thing by the way is that when
you do like this it will do type
checking for you so you won't be able to
mess it up too much if you try and
combine something that's not the right
type they won't compile so you're pretty
much guaranteed at least whatever you
type in is going to work you might not
pass exactly what you want but it won't
crash with some weird error so now we
have our four different parts we're
going to combine them so we say it's an
optional sign combined with an integer
part with an optional fractional part an
optional exponent part we're going to
take this whole thing and convert it
into a J number and give it a label and
so on and so on and so I'm not going to
go through the whole jsonparser
but you get the idea and so finally we
have all these pauses for these
individual pieces now we want to combine
them into a parser that passes any JSON
function and here's the code to parse a
json value you have a choice of
something that parses a null something
that parses a billion something a
positive number so I think it parses
string something positive away in
something person object so the code
really really matches the parsing
diagrams which makes it which is which
is very nice so you know it's pretty
easy to write this kind of stuff
all right so let's actually see the demo
right so before we just get I think I've
got enough time to show you one thing
here yeah I just want to show you here
is the entire parcel library including
all the line number handling stuff quite
a lot of you know it's a little bit
complicated but even with all this line
number handling and some some utility
stuff the code itself altogether is
there's parsing an integer those parsing
a float 496 lines okay so less than 500
lines for the entire party library which
includes utility things for parsing of
floats positive integer parsing spaces
parsing whitespace parsing a string all
that stuff all these poses are in Lesson
firing lines the JSON parser itself here
we go here's the adjacent Valley like I
said it's the real code there's the
escaped character codes there's the
number code tedious tedious tedious but
the whole Jason thing is 295 lines
so let's actually test that
when you come up yes it does come up
okay so here here's here's example the
null so there's the J null parser and it
succeeds and it returns a g null if I
pass in null P well than just saying I
was expecting an L it gives a nice
message column three error parsing null
unexpected P at that position so that's
a much more helpful error message
similarly parsing a boolean if I try and
pass trucks
it says I'm trying to pass a boolean you
gave me trucks there's an unexpected oh
the next rate to t I guess it gives up
on them
it can't find the true so it tries to
find the false it can't find the false
so that's what that error message is
okay
it's backtracking here's the string
stuff just go down to a real piece of
JSON code so here is a real Chasen
fragment and you can see it's got a
string it's got a boolean it's got a
birthday which has another object with
three properties in it and then the
favorite colors is a list of strings so
if I pause this show this up here you
can see it successfully passed it it
returned adjacent objects the JSON
object contained a map or dictionary
inside the dictionary there's the
property or birthday which in turn is a
map which in turn has the de property
which is a J number a month which is a J
number a year which is J number favorite
colors is a JSON array which contains a
JSON string another JSON string and so
on and so forth if I change this to a
adjacent number let's see if this works
it should say it's adjacent number
and there's the JSON the way and the
first thing is JSON string and the
second thing is adjacent number now if I
put a bad character in there like an
angle bracket or something square
bracket and I try and pass it again line
five column zero parsing an object's
unexpected square brackets and here's a
sum of the adjacent org site has some
other examples this is this is one from
their site so it's quite more
complicated one and if I run it
I get the complete thing successfully
passed it it's a map container widget
the widget is a map containing debug and
image and so on and so forth so there's
a full JSON parser in three hundred
lines of codes not bad I think so like I
say you know the details can get quite
complicated but you can I think you can
see the concepts how look how you build
up the more complicated part of some
simpler ones so what have we got I think
I'm pretty much done the most important
thing is we're treating functions like
objects so the original parser returned
a function right that's a very
functional programming kind of thing to
do we treat functions as things in their
own right and in this case we wrapped
that function in a type and once we'd
wrapped it in this parser type we could
then manipulate it those types
I was calling recipes people normally
call them effects or computations but
the point is you've got to these recipes
they don't actually work until you
actually give them the input stream but
what you can do is combine them before
you actually have the input stream you
can basically do a little programming
with these recipes you can take two
recipes and combine them to make a
bigger recipe and that's all very cool
things are actually kind of programming
with types you're programming with
combinators so you have a little program
and then you run the program with the
input and I think hopefully you get the
idea of the power of these Combinator
libraries we just started with three
basic Combinator's and from that we
could build a choice and the any of and
the sequence and the string and the you
know all sorts of other ones built from
those basic ones and that's this whole
thing of building complex things from
small things it's really the essence of
composition that the essence of
functional programming
and they're very small but they're very
powerful lack of the Combinator library
is 500 characters 500 lines not bad and
with that library we could actually
write a JSON parser in three headed
lines and people using these kinds of
things you can even like binary parsers
as well you don't have to write string
pauses so you could write so you know I
would they wouldn't be particularly
efficient by the way this code that I
shown it is not at all efficient it's
really an example to get the concepts
across if you want efficiency I would
use a commercial you know more serious
library so for example in F sharp the F
par set library is the one to go for and
there are similar libraries for other
languages so thanks very much the code
will be the parser directory there
contact me if you've got any questions
slides video if you want help with F
sharp F sharp works consulting and if
you want more of our F sharp itself go
to F sharp at hook thanks very much and
if you've got any questions just come
and see me afterwards and don't forget
to fill out the thing at the back thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>