<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Servant: Web APIs at the Type Level - Erlend Hamberg | Coder Coacher - Coaching Coders</title><meta content="Servant: Web APIs at the Type Level - Erlend Hamberg - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Servant: Web APIs at the Type Level - Erlend Hamberg</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UTgxdcADGa0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi I like cheating at programming and
today I'm going to show you my cheap
mode for creating web api's so I'm
Erland I write Haskell micro services
when people aren't looking and I know
the weekend has actually begun so this
will be a short talk and I will save you
from all the gory details
those are super interesting though so if
you ever meet me later just ask and I'd
love to explain so just warning at first
there will be Haskell don't run away
Haskell is not scary I come in peace and
actually been quite a few really good
functional programming talks here at NDC
which is fun so lots of f-sharp
Scott loss skins I hope that's this name
more or less talk on the main modeling
in Asha was awesome you should really
see it if you didn't and yeah this has
anyone here actually used f-sharp or
something no oh yeah okay so you'll
recognize it some bits so first actually
spoke at an elm conference last weekend
and I just mentioned in passing that I I
i needed a back-end right now at some
point so I wrote it in Haskell and
people came up to me afternoon said
that's really well surprising because
that's really not how we imagined high
school to be because for some reason
this is what people imagine like Haskell
being which well I mean kind of cool
that people think I'm smart when I write
Haskell but I have an actual picture
from work and this is I mean this is
much more close and I actually really
mean this and we'll get back to this but
let's get to the point
so servant is a library ecosystem for
building web services and it's really
really amazing and I really mean it when
I call it a cheap mode
so more precisely it is a type level
domain-specific language and it's a
family of libraries for using these API
types so type level language language
probably sounds quite cryptic but let's
look at actually what what I mean by
type level so there will be lots of hand
waving through this explanation and if
I'm not actually waving my hands just
imagine I'm doing that because it's yeah
that will I mean we're not saying here
all night I promise you a short talk so
the value level you all know that's
familiar I mean that's where your
variables and your function and contents
live that's everyday bread-and-butter
programming and we're used to these
values having types I mean the printers
are mixing them up and adopts some
classes of errors from happening at all
but if we look at types as well it looks
like they to kind of have types
sometimes so why do these lines probably
make a bit uncomfortable well it's not
well you're tempted to say well typed I
mean list takes one type argument not to
and that takes two not one so it looks
like these pipes kind of have super
types again and it kind of looks like a
list and maps are functions at the type
level they take pipes bring it in in the
first example and then string well this
is one and then return let's call it a
proper type that you actually take as an
argument or return from a function so
let's inspect this types of types and
now I'm just throwing some high school
at you and just bear with me so list
it's clean of a type level function that
takes a pipe and then returned to type
so if you give it an int then you have a
good old fashioned type you can return
from your function take it as an
argument you can read the double colon s
has pi
and map takes two types before it
returns a good old-fashioned type that
you can use on the valley level again
and don't be confused by the error
orientation in Haskell you can kind of
pretend it says type comma type two type
I won't really get into the details it's
not really important here but if we give
it a string well then we have a function
from type two type and only when we give
it for example a string element then we
have a good old-fashioned type so so far
so good
any questions just yell out at any time
so this kind of makes sense but let's
take it a bit further so let's pretend
we have or we create a type called EB
type and it has to construct your secret
lies in PostgreSQL this is kind of like
an enum and let's make a function at the
type level so it says type family which
is a really fancy term but it just means
function at the type level so we have a
function at type level called DB fetch
it takes one of these DB type types and
any well a T of any type and then return
to type which I know is kind of
strange-looking but we can create
instances of this type level function so
for sequel Lite we are returning the
function type file path to IOT again I
kind of all gloss over the details but I
mean a file path we understand key is
the type we're going to return for
example and i/o just means you can
perform I ll do in this PostgreSQL let's
say we take a connection pool and then
returns an i/o of T and we could then
write a function at the value level and
we could compute its type so we call DB
fetch equal add user that will compute
the type file path to i/o user this is
kind of silly and you wouldn't really do
this but it looks like we can manipulate
tiny types at least and we can have type
level functions take and return types
okay so I think that was the most maybe
unfamiliar and advanced part and the
details aren't super super important but
the important part is we can actually
use and manipulate types alone I mean so
let's just push this on our mental stack
and get to the point
so servant let's look at the servant
language so I talked about it as a
domain-specific language at the type
level and that's exactly what it is and
as I mention it's this language and
library so let's look at some examples
even though we don't really know the
language at all so this describes end
point under slash users that respond to
get requests for a list of users
represented as JSON or XML so we don't
know servant yet we haven't really
looked at it but I mean this kind of
makes sense already there's a strange
take on the list just ignore it just
means I mean the type I mean the list
type not the actual list but ignore it
slash users slash and ID well we have an
endpoint under slash users it will
capture an integer we're going to refer
to it as ID and it responds to get
requests and we'll return users so I
mean we're still just playing with pipes
there this is just a pipe alias actually
and we can go farther I mean let's have
a post endpoint so under slash users if
you give a request body that contains a
user type represented as XML or JSON we
will respond to post requests and return
XML or JSON and a user up send an XML
adjacent and again this is only theis or
you can kind of imagine what an actual
server and implementation would look
like here I mean so it's apparent that
this user type needs me
to have some from XML on from Jason
instance and to XML on to Jason but
again we're only playing with the API
and we're only a pipe level so let's I
mean this is Scott talked about like
almost readable by non-programmer codes
this is almost readable but we can do
much much much better and we'll get back
to that
so let's actually look at the language
so we've already seen some building
blocks like this post pipe so post is a
pipe constructor taking well a list of
pipes and pipe to return we have delete
I mean you can imagine put post and so
on we have a wreck body type that we can
use in our API descriptions query
parameters header I mean you can
describe a full API at the type level we
also saw some glue I mean so you have
the drunk happy bird Combinator for like
combining parts within an endpoint and
the well angry screaming bird for
combining like whole endpoints it's kind
of like an alternative thing so that's
cool and all kind of vague but let's
build an API with this so let's pretend
we have a super simple blogging system
so you have users and you have posts
I'll just focus on the users because
that's the simplest so let's pretend we
have a data type called user as one
constructor user as true stringfield's
username and name and syntax isn't super
important but anyway and we have one
endpoint and our slash user you can ask
for a specific user we capture a user
name as a string and we return a user
and we only respond to Jason so if a
client asked for SML which is got a
content type not supported whatever
that's in HD in HTTP
and we also have what I guess is an
update endpoint so you can send a user
encoded jasonandrhe in the body and we
respond to a put and will spawn with
Jason and with a user so I mean this
probably just takes representation of
user say you sit if we think as a server
and then just returns the new
representation so I review the the
combining endpoints operator and if we
had similar a similar API for post we
could just call our API well that's just
a combination of users API and posts API
and these would probably live in
different modules and you could like mix
and match your API as you want maybe you
want to expose different API s for about
different versions of your server but
again we're only playing with types at
this point so and of course we could go
further and maybe protect with dot like
our users API while our post API is
public kind of a weird setup here and of
course we could just choose to version
or whole API so maybe hide everything
but some versions so here's everything
just living under v1 so okay so we have
our type but that's well we won't want
to live on the value level I mean what
can we do with the type well actually we
can do a lot with a type so the most
obvious one but not the only thing is
just well writing a server so probably
what you want to do not always so a
server as you all know is well it's just
really I mean a handler for an endpoint
is just taking a request and returning a
response I mean abstractly apart from
things like your routing and so on but
we have a lot more information we don't
want this kind of lower-level stuff and
most of all because HTTP it's freaking
complex and this is the decision tree
for status code for a GP 1 1 &amp;amp; 2 0 and I
mean if you read the RF season can do
this I mean good for you but this is
freaking hard and if you juggle headers
and status codes and so on you I mean
one it's hard and you will make mistakes
just inevitable so it's so complex so
let's try to do better so just a
reminder so this is our our users API we
have encoded this as a type this is
really what we want to implement as a
server so a top-level server type is
called users server as a function and
you can see the type signature calls
kind of type level functional function
called the server taking our API type so
this is one of the type of functions
like the DB fetch we saw earlier and at
the value level we just say this server
is a combination of a get users Handler
and an update users Handler and the
functions are quite nice so I mean the
get users handle to take a string
representing the user name or ID and it
just returns a user type and it can do I
owe so and well the update user takes a
string for the ID a new user and returns
presumably I mean that that user after
it always written database and I've
included the implementation but it kind
of gives itself because you're so
constrained at this point which is
awesome because you can really only do
one thing and the the hard part has
already been taken care of that was
defining the API that's probably
something you did with your teammates
and so on and
the other hard part is like a TSP itself
and that's kind of abstracted away here
which is super nice so we got a lots of
free
I mean decoding the request body and
dealing with all the error cases
encoding the response I mean we just
returned user we don't care if it was
XML or JSON the compiler will make sure
that if we have said we can return an
XML we better have a to XML instance for
that type and validating the query so if
you take a user as a request body and
it's invalid I mean you will never I
mean the requests will not even reach
your handler because the framework is
already taking care of returning a 400
bad request so so this is good I mean
these handlers are super simple and the
hard part was is really just defining
the API so while actually writing the
server that's why this is a picture me
because it's it's super simple and I
really like that but there's more I mean
we have this type and we can actually do
more than just to create a server that's
the obvious use case so we can derive
documentation from the type so here I'm
using a library called swagger a certain
swagger swagger and I'm basically saying
that actually what I want to serve is
under slash swagger UI I want to serve
the swagger you I also want to serve
swagger JSON file in addition to my API
so every time I push a new version of
the server and it spun up I will just
serve up-to-date documentation which is
also nice I mean you could also just
build the documentation and maybe not
service from a server but that's a
detail so from our simple API definition
where we get this an interactive version
where you can play around with the
request this is really really nice it's
a very I mean as you probably know a fun
way to play around with AP ice and
always up to date
and yeah super simple another thing we
can do is deriving client functions so
here I'm calling right js4 API I'm
specifying but I want vanilla jeaious I
could have send it said the jQuery
angular Axios and I don't know what else
and this means you can actually build
the the the client functions for let's
say the front-end at Build time which is
pretty cool so you'll get something like
this which just plain old JavaScript and
you don't have to write it because you
really don't want to but yeah I think
there is typescript support I I just
check now I mean every time I check so
the question was is there typescript
support every time I check there is
there are like new libraries there are
like code generator for well Haskell
JavaScript c-sharp Ruby Python pure
script
yes typescript and this is pretty cool
but I mean you can I mean with
typescript you can take it even further
I guess if their support because this is
what you get for Elm so Elm for those
who don't know it's also like a
front-end language typed runs in
language and this is actually something
I use in in a project right now so I
specify that I want to create I mean
this is a jumble of of code but I mean
the important part is it will generate
these decoder functions for for Elm I
will make sure that any jason it
consumes will be will have to be decoded
into l types before it can be used
because l doesn't have like null or
undefined or I don't know what you can
find in jason and you probably want to
do this anyway but i mean writing them
writing them as a hassle it's it's it's
really not fun but if you specify your
api with search with servant you can get
this for free so it will generate this
kind of elm code or
has the pipes it has a decoder which I
mean it's really simple in this case
we'll just look for a username and a
name in the Dacian and then return that
as a user type and you get these query
functions so you have a get users by ID
taking a string and returning it just be
a request type and patch user Spidy
for if we had a patch endpoint and so on
and this is pretty magical so the
project I'm currently currently working
on we actually have a back in britain
Haskell but it wouldn't have to be
written nasca we just need to specify
the API in the servant task a library
and since we generate the API functions
at Build time if I go to the backend and
change a type let's say that we have a
person and we say that actually we don't
always have an age let's change age to
maybe age maybe it's an option type and
if I just compile the project the front
will tell me all the places I assume
that I have an age and it says actually
well you have to now account for the
possibility that the age is not there
which is pretty amazing that's it feels
really good when you change stuff in the
backend and the front-end will just tell
you all the places you need to update so
that really really convinced me and
there's actually a lot more there is a
well you can generate HTML of course if
you just want to serve a web page there
is a quick check library which is a
property especially a property taste
property based testing library because
of course if you can expect the type you
can generate random valid requests which
is pretty cool
there is client generation for well
c-sharp Ruby Python probably tons of
other languages I just had a really
really quick look at the Haskell package
database and you can also do other cool
stuff like checking that internal URLs
are correct if you're actually serving
some sort of web app I haven't done that
but that's cool
there is a servant graphical project I
don't know how mature it is I haven't
really looked at it and as I kind of
alluded to I mean you don't really have
to implement the server for this to get
some benefits I mean you don't have to
convert your back into a Haskell I I've
used servants several times without
actually implementing a server because I
just want let's say client functions for
JavaScript I don't I don't want to write
them myself all the time with change
system zone and for Elm I would probably
just like specify my API with servant
just to get like the generated decoders
and client functions because it's really
nice to do not having to do that kind of
boring work so to sum up my quick
version of this so specifying an API in
the type system I'm using that's
specification specification it's
actually really nice it sounds super
strange fancy wizardry but it's a cool
stuff and it's real benefits and
advanced features can actually make your
our job easier and if you want the gory
details I gave a technical version of
this talk at flatmap oslo in May and yes
I'll go I go into the the type level
function details behind all this and
yeah it really depends on what you want
to know but I really want to stress the
fact you can use this without
implementing your server in Haskell and
it's pretty cool stuff thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>