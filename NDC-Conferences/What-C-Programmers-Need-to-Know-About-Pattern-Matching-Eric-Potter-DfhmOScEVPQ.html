<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What C# Programmers Need to Know About Pattern Matching - Eric Potter | Coder Coacher - Coaching Coders</title><meta content="What C# Programmers Need to Know About Pattern Matching - Eric Potter - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What C# Programmers Need to Know About Pattern Matching - Eric Potter</b></h2><h5 class="post__date">2018-02-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DfhmOScEVPQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right well I know we've got the
attendee part
so I don't want to get started late and
I probably won't run long either but I'm
glad you guys came up here today we're
gonna talk about pattern matching this
is a feature in c-sharp 7 that I have
been excited about since long before it
was ever actually in the language I'm an
f-sharp
fan I wouldn't say I'm an f-sharp
developer because when I hang out with
real-life sharp developers they're way
better than me but from playing with
pattern matching in F sharp I've always
wanted it in c-sharp and now we finally
have it so we take some time today to
look at what it is and how cool it is
and why you want to use it my name is
Eric Potter you can follow me on twitter
at potter eric when i'm here in london i
get asked about my family quite a bit
yes i am related to harry potter i got
to visit him and his wife Jenny it was a
good time but weird stuff always happens
I was telling him about my
pattern-matching talk but he doesn't
care about c-sharp
he's a parcel mouth so he only ever
wants to do Python
this is some code from the Roslyn
codebase actually so this runs in your
c-sharp six compiler and it's c-sharp
six code and it's totally fine there's
nothing wrong with it
other than it doesn't use pattern
matching because we didn't have it then
but what we can do with pattern matching
is say reduce EO and we can shrink it
down to this just looking at a quick
side-by-side comparison you can see that
this is much cleaner much tercer code
here's another block of code this is
from a different open source project and
don't worry about it I'll get into the
details of this later I just want to
show you why this is so cool but I can
take all of this code from c-sharp 6 and
reduce it down to that in c-sharp 7 it's
pretty good so what is pattern matching
exactly if we think about it it is a
language construct that we've not had
before when I talk about language
constructs I could say things like we
have iteration constructs like while and
for and selection constructs like if and
switch and since the beginning of
c-sharp we've had these more powerful
structures or a more powerful structure
for iteration in the for each loop and
we've never really had a more powerful
selection statement until now this is
what pattern matching gives us in the
same way that a for each loop doesn't
really give c-sharp developers anything
that you couldn't do with a do-while
loop pattern matching doesn't give us
anything that we simply couldn't do
before but in the same way that I'm
guessing you guys use for each loops all
the time pattern matching is one of
those features that you'll start to use
a lot once you understand
and understand how it can benefit your
codebase to get a better idea of the
importance of this feature I wanted to
step back just for a second and talk
about some history and this goes back to
1972 where Dijkstra said that we have
now seen three types of decomposition
and we could call them concatenation
selection and repetition that's kind of
hard to understand Uncle Bob is set it
more modern lis where he says once you
strip away all the syntactic sugar our
programming language has essentially
boiled down to three things sequence
selection and iteration every construct
within these languages a combination of
these so these are like the three
fundamental building blocks of any
programming language you've ever seen
and what pattern matching gives you is
an improvement in one of those three
fundamental constructs so it is
simultaneously not something that you
couldn't do before but something that
really improves a language at a very
core level so let's look at some code
let's say that you are working on a WPF
application and you need to be able to
reset all the controls on a given form
user has entered some data for whatever
reason they don't like it you just want
to set it back to back to the default
State well what we can do is loop
through those controls and depending on
the type of control we're gonna have
some different behavior so we can get
the main grid children and just loop
through them and then check their types
and given the type we will then cast it
from the control which is our iteration
variable to the more specific type of
either textbox radio button or combo box
but because we want to say is checked
can't it's not enough simply to know
that the control is a radio box we have
to keep it as a pickle button
nothing really wrong with this code but
with pattern match you write it like
this there's a couple things going on
here that I want you to recognize the
first is that we are switching on an
object that is not either an int or a
string in c-sharp 6 switch statements
only worked on things that could be
resolved to integers or strings now we
can switch on anything and what we're
going to match on in this case is the
type of that variable and it's going to
switch on the dynamic type so the static
type of the variable named control is
control we want to know what the the
dynamic type is what you know what's the
more specific type here this is called
the type pattern where I'm actually
going to match on the type and so now I
can say text box text box and if control
is a text box that variable we've
populated and we'll be given that type
so we now have a text box variable whose
type is text box or we would have a
radio button variable whose type is
radio button and so I could say a radio
button that is checked so there's no
need to have that additional cast in
there so this cleans up our code quite a
bit the old way is on let's see my right
your left the new ways over here this
code would be significantly shorter if
it wasn't for the break statements we
have to have but you can see how this
code is is cleaner and more readable
it's yeah
okay so you're asking about what if a
control if we had a variable that
matched at two different levels in the
heritance hierarchy that's a great
question
how about I promise you I'll answer it
in like 15 minutes
no it is a very it's an important
question and there are some interesting
ramifications which is why we'll circle
back around to it so there's another new
language feature that we have that goes
along with this this is another
variation of the pattern matching code
we just looked at but if you've done any
WPF you know that a combo box could be
editable or not and so we might need to
have different behaviors based on
whether or not it's editable so we now
have this new when statement this one
statement is called a guard and so what
I'm saying now with this line of code is
I don't want to match simply when the
type matches but I want to match when
the type matches and this other
expression evaluates to true so I now
have two cases for combo box yeah so the
question was if it would match - which
one would it match on yes so it's going
to match on the first one that's true if
the order of these two was flipped we
would actually get a compiler error
because or a compiler warning because it
would say that there's two two that
match and the second one would net the
more specific one would never be reached
but if we put the one with a guard first
it could match and if if excuse me
one about that they read yeah some other
property I believe so yeah so the
question was could you have multiple
cases with guards and I believe so I
mean as long as the guard has the eval
evaluates to a boolean expression you
can put almost anything you want in this
case I'm using my type pattern variable
in the guard I don't have to do that I
could have a guard that depends on a
variable somewhere else in scope so this
is what makes pattern matching
absolutely magical
is that it combines type validation
variable evaluation and variable
assignments into a single statement
going back to this I am validating the
type of control when I see if it matches
the combo box I am evaluating it by
checking its property and if those
things are true it will populate that
variable combo box this is why we can
reduce the amount of code so much is
that I'm able to do multiple things in
one place and it all makes sense it's
not like some kind of wizardry where
we're doing a bunch of stuff and making
the code more complex it just makes it
simpler and more compact
one way you can think of it and let me
preface this by saying this is not valid
code but it kind of you could think of
it kind of like a tryparse if you could
also pass in a lambda because the
tryparse will evaluate the input and if
it's valid assigned a variable which is
in this case the output variable
but it also does the selection it
returns true or false based on the
parsing and if it were like pattern
matching you would also be able to pass
in a lambda in the based on whether or
not that lambda evaluated to true or
false you could you would parse it or
not again just this is not valid code
don't try and do that so one of the
reasons I like pattern matching so much
like I said it allows you to do multiple
things it's kind of like we put a switch
statement and an is operator and as
operator and like a try parser regex and
a blender mash them together and got a
language feature at the bottom more
generally it's a mixture of selection
assignment and evaluation so it's a nice
little it's kind of like a three-headed
monster you know like fluffy let's look
at some code here
so you guys are all familiar with the
fizzbuzz problem it's kind of a classic
programming kata and I could have a
method like resolve that is going to
check each integer for either fizzbuzz
fizz buzz or just the integer number and
this code is fine you can see all my
unit tests are passing but it's a little
esoteric because we have to kind of know
what the mod operator is doing there
with pattern matching and another C
sharp 7 feature we could reduce it down
to this let me kick the font up here for
you
so I've got a method called resolve
pattern matching and the first thing
it's gonna do is gonna call another
method called is multiple of three
multiple of five and that's actually
going to return a tuple this is one of
the other language features in c-sharp
seven if you haven't seen this you
should really go check it out it allows
us to package up two variables that
travel together without needing to
create a class for them and we don't
have to use generics and so I can simply
do the one evaluation of my input
variable I for mod 3 and mod 5 and
return those two boolean x' back
together
the other cool thing here is that I can
name the members of the tuple so I can
have multiple of three and multiple of
five as a boolean as boolean names so
now what I can do I call that method I'm
going to switch on the result and this
is using a different pattern to match in
the previous example we were looking at
the type pattern this is what's called
the VAR pattern which basically means
that we are going to match on any type
but we're going to evaluate a guard to
decide whether or not it matches or not
and that kind of makes sense because
we're evaluating on the return type of
that method so it's always going to be
the same type it's going to be that
tuple so I can say now is for the case
of status when status multiple of three
and status multiple of five return
fizzbuzz I can do similar things for
when the status or just checking
multiple three just checking multiple
five and then we still have the default
case or we're going to return a string
this code also works it works just fine
we in fact we can change this around so
we're using the pattern matching code
instead of the older way if I run my
unit tests then they should all pass
again yep Oh yep they all passed so
functionally it's the same but I would
argue that this code is much more
readable and the code is much more
expressive of the problem we're trying
to solve and you can almost read the
requirements out of that code it's great
this one here
yeah so this is the function call two is
multiple of three or five which is
defined here and this is the syntax for
returning a tuple that's where we're
putting the names on him and this is the
syntax for composing the tuple
well when we have when so the question
was do we need to have this variable
declaration here and we do because
that's how the variable pattern works we
could actually have cases where inside
of a single switch statement we match on
type patterns and the variable patterns
and so it's kind of important that you
say this is the VAR variable name this
example might not show that as clear as
others but it is there
so the examples I've shown so far were
kind of contrived what I thought would
be really interesting would be to look
at some real-world examples and the neat
thing about this is that Microsoft is
now developing a lot of their code in
the open it's up on github and a lot of
those projects were started before
c-sharp 7 was a thing so we can look at
how the Microsoft teams implemented code
without pattern matching and see how
they've changed it now that pattern
matching is available so I wrote a
little search tool using Rosalind to you
know it compiled the code and then I
just searched for the syntax nodes for
the pattern matching we're able to pull
some of these examples out of either asp
net core any framework or net core or
the Rosalind project the ones in
Rosalind are really interesting because
you're seeing how the language
implementers are using their features so
we'll see a handful of those so this is
some code from the entity framework code
base or the EF core code base I should
say and they're getting this column and
basically we the first thing they have
to do is check for null on both the
column and the property with c-sharp 7
they actually added functionality and so
there is the code gets a little bit
bigger but it's doing more and what they
can do is they can remove that null
check so here's the new version of the
code and you can see that we're matching
on that expression the same way but now
we're just matching on the types and
that null check is nowhere to be found
one of the reasons for that is in
pattern matching
the type will only match if the variable
is not null and so if expression is null
it's gonna fall through to the default
case it's actually really useful it gets
us out of a lot of places where you have
to see is this null well it doesn't
matter it's gonna fall through the
default I can handle null for any of
those cases because it'll fall through
here's a larger example of code that's
using guards and this actually is
already C sharp 7 with pattern matching
but the thing that I wanted to point out
in this code is that we can match on the
type and we populate that variable and
we can use it straight away in the guard
so we match in the case and then in the
when we can already use that variable
and then of course we can use the
variable once we're into that block
here's another interesting bit of code
again already using pattern matching but
I wanted to show you a couple of things
one is that just like before with switch
statements we can stack up a couple
different cases and have them result in
the same block but this is a case where
I'm going to look at the type and I
don't need that variable and so the new
syntax here is actually that guy that's
an underscore and it's now the discard
operator so what I want to do is I want
to inspect the type of the variable that
I'm switching on but if I don't care
about using that variable again I just
throw it away
so the underscore is basically saying I
don't care what this is
the discard operator doesn't only work
in pattern matching it actually works in
other places it is very valuable in
pattern matching but for example if you
want to call tryparse and you don't
actually care about their output value
you can just discard it now and accept
the boolean result of the try it's worth
noting that before c-sharp seven and a
single underscore was a valid variable
name or a very valid identifier and so
if you have code that uses a single
underscore as an identifier you don't
have access to the discard operator
anymore if you have code that uses a
single underscore as an identifier you
might want to ask yourself some
questions about that to begin with
with the exception fake it easy actually
uses the single underscore for very
similar reasons basically to saying we
don't care about this but just be aware
that that's like it's a funny little
language thing where it could be an
operator or it could be a variable name
I I think it wouldn't necessarily
because in fake it easy the underscore I
think is a property and so it rescanned
not just like a bear identifier yeah
here's some code taken right out of the
asp net core code base and in this we
are going to switch on one of the
attributes that we found in the markup
remember when I said I promised I would
come back to the whole ordering thing
okay now we're back in this case the
class attribute that value could be
in HTML string and the HTML string
implements I HTML content so in theory
both of those could match on a given
input variable the new thing about
switch statements is that the order that
they're listed in is now important in
c-sharp six and previous because things
always evaluated two strings or numeric
values there's no way you could have
these collisions and so the order really
didn't matter now because multiple of
these things could match the order is
important so basically it will evaluate
to the one that it finds first the
exception being the default block is
always essentially at the bottom so if
you start with the default block that
won't like match every single time other
than that order is now important
this is one of the examples I showed at
the beginning and it's actually one of
the most useful ways to use pattern
matching remember I said that pattern
matching is essentially a way to do
evaluation and assignment in the same
statement and so when we have code like
this where we are going to take a
variable and try and cast it which would
be the assignment and then see if that
cast worked which would be the selection
then this becomes a prime candidate for
pattern matching so in this case I've
got this expression and I'm going to do
an as operation on it which as you know
if the as fails it's going to return
null so we then we have to do this
expression or we have to check for null
and we're actually going to do that
three different times for the three
different types the expression syntax
the statement syntax and the global
statement syntax but we can see now with
pattern matching we can clean this code
up right down to this because now
instead of having to check the type we
can just match on it so if the node
matches expression syntax we're going to
evaluate in that we don't have to do the
as cast because the pattern will
populate the variable already so that
gets you know a fairly significant
reduction in code there
this is another one of those places
where we're doing something similar
where we're going to do an evaluation
with an is statement and then if the is
evaluates to true we'll do the cast this
also can be cleaned up and now the
pattern will populate the expression
variable and we can use it right away
but there's another interesting piece of
this that I haven't talked about so far
and that's that this doesn't use a
switch statement
so pattern matching primarily gets used
inside switch statements but it can also
be used as the expression following in
is statement so here I'm saying node is
expression syntax and expression syntax
expression is the pattern and we can
just use it right here right outside of
that cast
lastly and this is yet another example
from the Rosalind codebase we can switch
on enews and have guards so everything
we've shown this up to this point was
switching on objects the switch
statement in this case is the same as in
C sharp six because we've always been
able to switch on in ohms they result in
numeric values but I can now have my
case statement on the enum and have the
guard so the guard doesn't have to
follow a tight pattern or a variable
pattern alright any questions on any of
the code we've just looked at yeah so
the question was can you put a guard on
an is statement let's find out so if we
had a method
and we'll say that it's going to pass in
a control oh I don't have oh it's not in
scope will say object actually let's
let's return a bool and we will return
is oh is straying s when yes
Oh apparently can't do it'd be a cool
feature though good question
when that case is is returning a bool
either way so right now the is returns a
bool based on the type and so we're just
talking about extending that bullet to
also evaluate the guard right so I could
just do a boolean yeah so I could I
could say a stun length grand 0 yeah so
I could do that that's not necessarily
pattern matching other than we I mean
this is still the pattern matching but
then this is just the evaluation
all right any other questions about
c-sharp yeah yeah so you're asking does
the performance improve using pattern
matching I don't know that's a really
interesting question I'll do some
research on that and I'll throw
something up on Twitter about it because
the guys that would know are in the
building
so I'll find out for you yeah other
question over here
yeah so you what you're saying is it's
just syntactic sugar I think that's the
case but I don't want to say for sure
because I don't know but let's find out
I'm curious now
all right so pattern matching is new in
c-sharp but it's actually been around in
some other languages for a while and
when you see a presentation by a guy
that has an f-sharp sticker or two on
his laptop you know you're gonna see
some F sharp at some point so let's look
at what you can do an F sharp
so an f-sharp we can have this match
operator and I can match on variable I
and the thing that I want to show you
here is that while this probably does
kind of what you think it does where
this gets more interesting is let's say
that I take out the default match so
this line basically says if nothing else
matches fall through it's kind of like a
default let's say that that goes away
I'm now getting a little green squiggly
and if I hover over it you'll see I'm
getting a error that says incomplete
pattern match on this expression so the
compiler will actually run through and
see is the bonehead programmer writing
this code missing something and as a
bonehead programmer this makes me really
happy this is something I don't know how
hard it would be to do in c-sharp it
would be really cool I would like it
where this gets a little more
interesting is if we were using
something like enums f-sharp has a
construct called discriminated types
let's say that another color got added
I'm now getting that same error because
another possibility was introduced you
could see how in a large code base this
would be incredibly useful and one part
of the code base I add a new enum and
another part of the code base that I've
never seen somebody's switching on what
they think is all the e-news or was all
the enums at the type at the time and so
now that becomes an error to me and I
know that hey I change I added something
to this enumeration here's this other
place I need to go make some
modifications I think that's really cool
another pattern type that f-sharp is
called a list comprehension and so what
I'm doing in this code here is I've got
a method called what might my list be in
that it's actually going to match on the
different values that are in the list so
if the list that's passed in starts with
zero and then has one and one and two
and three and five and eight and
thirteen and then some tail some
continuation of the list I will return
this string Fibonacci and then I have a
similar one for Prime's this is
something I find really fascinating
where I can actually match on members of
the list an example that might be a
little more relevant is trying to
evaluate command-line parameters to my
application so this is the main method
and I've get this list of arguments I'm
going to cast it to a list and so now I
can match on the argument list and I can
either look for - help or - V or - greed
and in the same way that in c-sharp I
could assign values in F sharp what I
can do is I can look for constants but
also populate variables so in this case
tail is a variable greet is a constant
and so I can use this variable in my
output so if we ran this and you and I
passed in dot greet Eric it would say
hello Eric so
so if so you're asking what if I called
this application and and did - greet and
didn't have anything else so then this
pattern wouldn't match and so we would
fall through - the default case just
like in c-sharp if the pattern doesn't
match the variables don't get populated
so you're asking could I could I match
on the middle of something so what I
could do is throw some discarded
operators in here which the underscore
kind of works like the discard operator
and I could you know blank out some of
these and so this would achieve what
you're talking about so now I'm simply
not going to look at those first four
and then match on three five and eight
and thirteen so could I could I with
pattern matching look for anything in
the middle that matches you could do
that enough sharp but not with pattern
matching so if you guys want to talk
about F sharp I would love to talk about
it more with you but we will get out of
the scope of this talk believe me
there's nothing that would make the
attendee party more fun than for me to
talk about F star for three hours are
you guys familiar with the rust language
rust is a really new language it's it's
cool it's really low level it's actually
the language they're using to implement
some of the core bits of Firefox and
it's one of the reasons why they're
getting such good performance
improvements in Firefox right now but
they also through pattern matching in
there it was interesting to me that they
did that because pattern matching is
traditionally a functional programming
language construct and rust is a
low-level language it's a lot like C but
they did throw pattern matching in there
they have the match keyword and a lot of
the pattern matching looks similar to
c-sharp but they have this this is the
range pattern so now if I have a
function that's passing in a grade which
is a 32-bit integer I can match on
anything in that range so ninety to a
hundred would match on that first one so
if I had 93 it would match that range
I'd print a if the value that was passed
in was 75 it would match on that third
statement and print C I think this is
kind of cool
there's
a lot of times and my coding career that
I've written code that's like if a value
is greater than or equal to this and
also less than equal to that and one
thing that's really cool is that this is
almost a c-sharp feature if you go up on
github and look at the c-sharp Lang or
posit ory you'll see that this is
something that they're seriously
considering for c-sharp 7-3 it is still
a proposal might not be there but yeah
here's the URL you can go out and follow
the status see if it makes it in or not
interestingly the thing that they're
hung up on right now is whether zero to
ten should be inclusive or exclusive and
actually rust I think if you use the two
dots for the range is inclusive and
three dots is exclusive maybe it's a low
era but I asked Bill Wagner yesterday
about that and he said that they didn't
like that in c-sharp they didn't think
having like a two dot operator and three
dot operator made a lot of sense
another newish language that has become
really popular really fast as swift and
their pattern matching looks a lot like
c-sharp but they have an additional
feature that I really like which is
where you can pattern match in your
iteration so let's say that I have an
array of optional intz which if you've
not looked at it Swift before optional
is kind of like nillable nil is
analogous to null and so I have this
array that I'm declaring they're on line
one that has five slots in it two of
them are nil where the pattern matching
comes in is this question mark right
here that guy
so what I can say is for case let number
question mark in array of optional intz
and I'm just gonna say print found a and
then the number what's cool is that that
means that the iteration skips over all
the Nils so I don't have to have a nil
check every time I go through the loop
it's just gonna skip right over pretty
cool all right how many guys have ever
played with a lick sir so if you haven't
played with elixir you really ought to
go check this language out it's really
cool
it takes pattern matching further than
just about any other language that I've
ever seen
it does some things that I will not be
able to explain in the next 10 minutes
I'd encourage you to go look at it if
you have a plural site subscription
there is a course called getting started
with a lick sir by Nate Taylor that I
recommend if you want some more
interactive material Rob Connery has put
out some some tutorials where you're
actually kind of writing code as you go
it's pretty cool as well and look that
up but as a c-sharp developer when I
look at this code I think that those
functions are overloaded I have two
functions named first that they're in
the same scope and they seem to do the
same thing but they're not really
overloaded because they actually take
the same number and types of parameters
this is probably foreign to you but this
square brackets indicates that something
is a list so I have two functions
it looks like named first that both take
a list what that means is that I'm
actually pattern matching on the
arguments and then selecting which
clause to execute based on the contents
of the list not on whether or not it's a
list right in c-sharp we can overload a
method and the right one will be
selected
based on the argument types or the
number of the arguments basically what
is happening here is if I call first and
I pass in an empty list it's going to
return nil there's nothing in between
the square brackets of the list is empty
the second Clause is going to look at
the head or the first element in the
list and then it will look and make sure
that there is a tail which we're
discarding here oops
again the underscores the discard
operator and then since the method is
named first you could expect we just
can't return the first item or the head
but I found this to be really
fascinating that I could actually pick
which what these clauses I'm going to
execute this is called multi Clause
functions it's not really overloading
because they take the same argument list
but it's multi Clause functions and one
thing that's really common is to have a
bunch of clauses so again going back to
that list example I had earlier I could
match on things like match on whether or
not the list starts with 1 3 &amp;amp; 5 or 2 3
&amp;amp; 5 or 1 2 3 &amp;amp; 5 now I'm going to return
a string based on which one it is
now I've got three clauses but the way
that you would typically do this in a
lick sir the idiomatic way that you
would do it in the cinah lick sir is to
shrink it down to this we're going to
have each method Clause have the pattern
and then the return type just on that
same line this starts to look kind of
foreign to c-sharp programmers but I
think it's really neat you're doing some
really powerful evaluation there in a
very small bit of code if you think
about why this works it helps you
understand what pattern matching is in
c-sharp because really what we have is a
couple of different clauses and we need
to select which one of them we're going
to do right so we've got our selection
and when we pass arguments into a method
the parameters essentially get a sign
and so we have that assignment piece
that we have in c-sharp as well right so
you have the selection you have the
assignment elixir also has guards that
you can put on methods but that's
actually a little bit outside of pattern
matching you can put a guard in any
method and so you have that same
evaluation piece like c-sharp has and
it's pattern matching so let's switch
gears back to c-sharp I think those are
the language that are awesome they help
us think about pattern matching but
let's be real when I get back to the
office I'm gonna be writing c-sharp code
so let's talk about when you should
think about using it when you have
different behaviors based on the type of
an input variable consider using pattern
matching with the type pattern I say
consider because this isn't like a law
this isn't always going to be the case
there are going to be other situations
where you have different types and you
want different behaviors and what you
actually want to do is use object
orientation right you say have the
default behavior in a base class and you
override that behavior in the child
classes if you don't control those
classes you might want to consider using
pattern matching that's why I use WPF in
the example I don't control the code for
textbox and so I need to switch on it
and get the right behavior for given the
type when you have a case statement with
nested if blocks consider rewriting the
blocks to have guards this is an easy
one to pick up visually if you have a
case and then immediately have an if a
lot of times that might be an if
variable equals null or it could be some
other you know if something else about
the variable very frequently you can't
combine that just into a case with a
guard and that will clean up your code
get rid of some of those unnecessary if
statements
when you have an is check immediately
followed by an as cast consider just
using the is statement with pattern
matching this is probably the most
obvious one this is the one that's like
if you see this you should almost
certainly use pattern matching because
that ad as cast is now completely
superfluous just use the type pattern
you get the variable signed in the right
time it'll be fine in in a similar way
if you have an AZ cast followed by a
null check combine that into the type
pattern with the is statement there's no
reason to use that more of our but the
more verbose way to evaluate that I
really enjoy this feature I really love
pattern matching it's why I'm talking
about it but this is the one thing that
I want you to remember this is the most
important slide in the whole thing just
appreciate the fact that you now have
one construct that represents three
different functionalities it allows you
to really clean up your code it makes it
more expressive it makes it easier to
understand all those illah T's that we
want in our code pattern matching helps
you get I know we've got the attendee
party coming up so I won't run any
longer if you have further questions
please let's come up and talk about it
or find me at the attendee party or find
me tomorrow I'll be here all day I'd
love to talk to you more about this
stuff if you have questions later you
can certainly hit me up on Twitter
that's the easiest way to find me online
if you want to see any of the code that
I ship it today
it's up on my github also at Potter Eric
I've blogged about a lot of these topics
if you want to see further explanations
my blog is at humble tool Smith comm and
you can find the pattern matching tag
there so I hope you guys take this I
hope you guys start using it is great
it's one of those features that really
makes the language moving forward or
move forward in
awesome awesome ways so thanks guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>