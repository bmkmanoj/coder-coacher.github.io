<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Flow - Am I Your Type? - Mark Volkmann | Coder Coacher - Coaching Coders</title><meta content="Flow - Am I Your Type? - Mark Volkmann - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Flow - Am I Your Type? - Mark Volkmann</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5kt3urZOg4g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone as you can see there's
a lot of people missing out and you're
the lucky ones that get to improve your
life with JavaScript so I'm Mark Volman
I'm from st. Louis Missouri in the US
and I work at a company called object
computing and we do all kinds of things
we do consulting and training and we
work on open source software probably
the most well known open source software
that we are in kind of in charge of that
you might have heard of is Grail it's a
framework for building web apps in Java
and I have some literature up at the
front here that you can take at the end
if you'd like information about the
training we offer and our consulting
services there's some pens and stickers
so help yourselves to that so I would
say that there are three tools that have
really improved my life as a JavaScript
developer I've been working primarily in
JavaScript for the last seven years
before that I was a Java developer for
15 years and many other languages before
that but the three tools that have
really made a big difference for me our
es lint for checking my code for errors
prettier for formatting my code I highly
recommend that and a third of course is
flow and so we're going to get into that
today before I do I want to say a word
about my slides they're going to look
different than all the other slides
you've seen here and you might think to
yourself what's the deal did I not get
the message that today when you make a
presentation you're supposed to have
slides that have a picture and five
words and when you get the slides later
you can't decipher them they're
meaningless to you my slides are not
like that
my slides will help you learn how to use
flow and if you give them to a co-worker
that didn't attend the talk they'll be
able to learn flow from these slides so
that means that they're quite dense but
a lot of good information that you can
get later and that URL in the corner is
real important if you go to github.com
i'm m Volkmann and i have a repo called
slow material all of these slides are
there so you don't have to take a lot of
notes while you're listening
so the talk is broken up into these
parts we're going to go through an
introduction to flow and talk about how
you specify types and flow the flow
server which is the brains behind it and
then we'll walk through an example of
setting up a project that uses flow
there's so much I could say I really
need two hours to talk about this since
I've included some bonus slides at the
end for additional things that you might
have questions on and I also wrote an
article about this recently and there's
a URL to that article there that you can
get when you get a copy of the slides so
static versus dynamic so types are
specifying the conditions under which
your code is going to run things about
the functions and the classes in your
code and in a static language of course
you find out about the errors in your
code when you compile it in a dynamic
language you typically find out when you
run the code which isn't ideal and so we
have these type checking tools that you
can use with dynamic languages and in
the world of JavaScript there are two
big ones there's typescript and there is
flow so why should you use types well
there are lots of reasons one is that
you want to find the errors before you
run your code that's more convenient the
other is that it gives good
documentation about your code when
someone else is reading it they know
what you were expecting them to pass to
this function or they know what methods
this class provides and the types that
they expect it increases your confidence
if you need to do refactoring on the
code and boy did I hit that big recently
I'm working on what has become a fairly
big project and I had to do a big
refactoring and I just think it would
have been way more difficult if we
hadn't been using slow because it found
lots of errors that I was making as I
attempted to do the refactoring it
removes the need for you to write code
that text types sometimes people do that
when they're not using a tool like this
they'll write a function that the first
thing it does is it might use type of
and check what kind of parameter it
received and then you don't have to
write unit tests that are all about
testing types you get to skip that part
another reason is that there's probably
a plug-in for your editor or IDE that
supports these tools either typescript
or flow and I highly recommend if you're
going to use one of these
take the time to set up your editor ID
so that it can help you with this and
show you the errors with all that said
all these good reasons that you want to
use types there are also reasons that
you shouldn't and one of them is that
it's going to take some time to get used
to specifying the types in your code and
mastering how to do that it also is
going to make your code more verbose
which is kind of distracting while
you're trying to understand what is
happening and it will hamper you if
you're trying to create a prototype are
you doing a rapid development it's going
to slow you down
and initially when you use a tool like
this you might feel like you're spending
more time trying to satisfy the tool
than you are getting some coding done
but after you use it for a while and you
get a bit better at applying the types
and you have to do some refactoring the
tables kind of turn and you start to see
oh this is why I put in that effort it's
helping me a lot now so you want to use
types when your application is large or
complex or it's a critical app you're
working with a team of developers you're
expecting this code to have a long
lifetime if none of those apply to what
you're doing then maybe you shouldn't
use types right now and as we're going
to see one of the nice things about flow
is that it lets you gradually add types
to your code so you can take an existing
app add the use of flow and it won't do
anything to you at first and then you
have to annotate your files to say this
is a file that I'd like you to check and
so we're going to see that syntax in
just a bit so this is a tool that comes
from Facebook and it catches lots of
errors without you even adding types now
you do have to annotate the file and say
I want flow to run on this but you don't
have to specify the types of function
parameters for example and so it uses
type inference and it's really good at
following the flow throughout your
application to find that this variable
got passed to this function and it did
some operation on that and then it
passed it to this function into this
function and it traces all of that and
find errors without you even having to
add any
types you can gradually add them it has
support for all the new es6 and beyond
features and we get a lot of these
things from babel so you might be using
javascript features that aren't
finalized yet but it turns out that slow
can support a lot of those now and so
you can type check that newer code and
of course it has support for reactant
JSX since it comes from facebook but
flow is not just for use in react
applications i should say a bit about
typescript of course this is a competing
tool from Microsoft and it is a superset
of the JavaScript language and this is
really a key difference typescript is
doing more than just giving you types
it's adding new language features and
for some people that might seem like a
good thing and I think that it is as
long as those features end up getting
standardized as part of the JavaScript
language but if they don't if they're
subtly different than what JavaScript
lands on then now you're coding in this
thing that isn't quite JavaScript for a
lot of people I think they want to stick
with JavaScript they're comfortable with
the pace at which tc39 is adding new
features and they want to stay with
javascript and we just want to add types
and so that's what you get when you go
with slow instead of typescript and I
have a box up here to talk about Paul
Graham's blub paradox some of you may
have heard of this this is from an
article he wrote quite a while ago I've
got a link to it there and the main idea
that he was proposing here is that if
you consider programming languages
there's a spectrum of features there's
very simple languages that are easy to
learn and just do a few things and then
there's very complicated languages with
lots of features you might put Haskell
up there in that category and then
there's everything in between and it's
your natural tendency to look at the
language that you like and to say
there's all these things below me in the
spectrum I can't use those because they
don't have all the features that are
really important and all those languages
above me why do they have all that stuff
it's just confusing and I don't need
that
that's the Blum paradox where you
rationalize why you like your language
and that sort of applies to this
paracin between slow and typescript a
flow person might say all that extra
stuff that typescript adds I don't need
that but somebody that likes typescript
would say can't use flow because I need
those extra features that Microsoft
added so that's an interesting point of
comparison so both of these typescript
and flow they complete they give you
JavaScript code actually in the case of
flow you're not changing it you're
always working in JavaScript but
typescript compiled down to JavaScript
and the way that you indicate that a
file is using typescript as you change
the file extension to dot ES and then it
does two things for you it does type
checking and it does the translation
from the types typescript code into
JavaScript that might seem like a good
thing that it's doing both of them for
you but I actually think it's a bit of a
downside and that's because if you go
with flow and have it just do the type
checking for you then you can use babel
to do the transpiling and why would you
prefer that
well because lots of people write babel
plug-ins to do fancy things including
supporting features that are just that
stage one in tc39 and if you want to use
those somebody has written a babel
plugin and you can start playing with
that now and so I think that's an
advantage of using flow that you can
stick with using babel and get to all
those new things sooner another point of
comparison is there support for
specifying types for third-party
libraries that you might might want to
use a very common example is lodash so
the utility library that a lot of
JavaScript developers use and you would
like it to be the case that if you're
using typescript or flow that somebody
has created type definitions for that so
that you can check your use of that
library and any other libraries and so
in the typescript world they have this
thing called definitely typed and
there's a website you can go to and you
can see that they have lots of
definitions for third-party libraries
and the last time I checked it was over
2000 that they had specified there the
corresponding thing in the world of flow
is called flow type and it only had 570
and so that's a big difference
and kind of a sad thing I hope that it
catches up eventually actually it's made
big progress to make it to five hundred
and seventy fortunately there is a tool
that can read in a typescript type
definition file and convert it to one
that works with flow it's not foolproof
but at least it gets you part of the way
there but still I would say this is a
point in typescript favor that it has
better support for tech definitions of
third-party libraries both of them flow
in typescript have good editor and IDE
integration and another good point here
is that flow wants to remain compatible
with the typescript syntax and so it
turns out that if you start to use flow
and you decide six months later hey I
think maybe I want to use typescript
instead it's not really that hard to
switch over because their syntax is so
similar so if you want to install flow
it's very easy the trickiest thing is to
remember that you shouldn't install flow
you should install flow - bin and you
can install that so that it's globally
available and then you can ask what
version of flow you're using and you can
ask for help this is not really the way
you want to use it this is more for
experimenting really you want to set it
up to be a part of your project and
we'll show how to do that toward the end
of my talk so then when you want to use
flow remember I said you have to
annotate your files to let it know which
ones should be type checked and you have
to do that by adding a comment at the
top
slash slash at flow is the simplest way
you can use the slash star kind of
comment as well and any files that don't
have that will get type check it's easy
to forget that we forgot that in one of
the files in our project and just
discovered it last week and of course
when we added that some of those types
were getting exported and now all these
things are getting checked that weren't
getting checked before and so we had
like an hour's worth of work to do to
fix things that we would have fixed
earlier if we wouldn't have skipped that
file so keep that in mind you got to
mark all the files you want it to check
there is a way that you can tell flow
just check this one file don't check my
whole project and you use that check
contents option on flow you might want
to create an alias that does that for
you but really you want to run it on all
the files in your project
and we'll get to that later when you're
getting started it might be useful for
you to ask slow to suggest what it
thinks the type should be until you can
run flow suggest and give it a path to a
javascript file and it will output it
suggestions and so if you look up here
you can see that my original code right
there rectangle area computes the area
of a rectangle and then the output here
tells me that with probably a number and
Heights probably a number and this
function probably returns a number okay
and then here where I use it what kind
of variable is area and it says I think
that's a number so this is a really
simple case it can do more complicated
suggestions than that but it's nice that
it gives you a head start on that well
once all your type errors are gone now
you'd like to run your code and as you
might imagine no js' doesn't know about
flow and your web browser doesn't know
about flow you've got to strip the types
out of your code we're going to talk
about a couple of ways to do that but
for right now I want to focus on doing
this just for code that I'm going to run
with node and so what I want to do is
install this thing called flow - remove
- types and that's going to install two
things for me flow - note and flow -
remove - types and so the first one flow
node assists a replacement for the node
command and before it tries to execute
your code it removed the types so that's
real easy and then the second one is
when you actually want to generate a new
source file that has the types removed
and so you run flow remove types and
give it the file you want to run on and
direct the output into some new file if
you do that without the - - pretty
option it's just replacing all the types
with spaces and so your code is still
lined up the original way it's just like
whited out all the types if you want to
get rid of that space where the types
were used - - pretty and now with a new
file you can just run it with node
either way you've got to remember to
annotate the files and tell it about the
type checking there's another option
that I really don't like and that is
that you can put special comments around
all the type annotations in your file
with the slash star colons and Dax for a
single type or two
surround a type alias which we'll talk
about what those are in just a bit you
have to use a double colon I think
that's kind of an ugly approach I'd
rather just use standard flow
annotations and then have some tools
strip them out before I run the code and
then the project based approach we're
going to get to that later so let's look
at some more examples here this is an
example where I've annotated a file but
I haven't added any type so I just have
a simple function that's going to
multiply two numbers for me and calling
that in the line where I'm logging out
the result and I'm passing it a number
in a string and clearly this is not
going to work because I can't multiply a
number by a string and Slow will catch
that for me and say hey you gave me a
string but it has to be a number the
interesting thing here is that
typescript will not detect this that's
because in typescript you not only have
to opt in by changing your file
extension to dot TS but you have to add
in the types if you don't have the types
it's not going to detect that for you
but slow it's following the flow
throughout your code and it can see that
you pass in a string and it can see the
operation you're trying to perform and
it'll catch those so that's a big reason
why I have a bit of a preference for
flow another part of flow is catching
uninitialized references so here I have
a function where I'm going to pass in a
person object and I'm expecting this
person object to have a property called
last name and so I'm using es6 d
structuring right there to pull the name
last name property out and then I'm
going to check and see if there was a
last name and if there was I'm going to
return the first character of it
otherwise I'll return an empty string
but if I don't pass in a value for
person if that's undefined or null or
even if it's a number or boolean or a
string this is going to be a problem and
so below that I create a person object
this one happens to have a last name and
then I call the function and everything
is good and it outputs a V for me but
then I declare that variable key don't
give it a value it's undefined right now
I make the same call that's going to
give me an error and flow is going to
say hey that's a possibly uninitialized
value
so this is a really good thing and when
I first started using flow this was the
number one kind of error it was catching
for me wasn't the kind of thing where I
passed a number but it needed to be a
string it was that I didn't account for
the possibility that something might be
mill or undefined so I think this is a
really good feature of flow so now let's
jump over to talk about how you specify
the types in a bit more detail I've got
a URL where you can get all the
nitty-gritty details and I'm going to
give you an overview of that here and so
the kind of things where you want to do
this you want to specify the types of
variables properties and objects
parameters to functions and their return
types and you do this by following a
name of something with a colon and then
it's type description
now often typescript our flow can infer
the types for you and this is an example
where you might think surely I don't
need to say that it's a number because
I'm assigning a zero so it shouldn't
know that right and that would be true
if this was a Const because then it
would know that it's always going to be
zero so it's always a number but as it
is with the let flow has to look at all
the rest of my code because it's
possible that somewhere else I might
assign a string to that and if I don't
have the type annotation then that's
okay and so the type of score then would
be number or string it can be either so
you want to do that if it's something
that could change there's also this
concept of a maybe type now maybe type
says it's this type but it also might be
null or undefined and you specify that
just by putting a question mark in front
of the type okay and when you do that
it's going to make sure that any place
you use that variable in this case score
that you've accounted for the
possibility that it might be no are
undefined and if you're just multiplying
it by something and you didn't check
first to see if it was no undefined
that's going to be flagged as an error
type script used to not have any support
for this now it has this feature called
strict null checks that you can turn on
to get this same behavior but it's
by default inflow this is on by default
nothing can be null or undefined unless
you put that question mark in there to
say that that's allowed
so the basic types are what you might
expect boolean number string the wrapper
classes for those which almost nobody
uses then there's null as a type void is
what you say if it's going to allow
undefined then you can use literal
values that's interesting you're saying
that it's not that the type is a string
it's the specific string or not that
it's a number it's 19 always so you
might think that that's not a useful
thing but I'll show you an example
coming up later where I'm going to use a
string literal and that will make more
sense then you can also take the lazy
approach saying that the type of this is
any it's kind of like turning off type
checking for that thing in general you
don't want to do that instead you should
prefer to use mixed mixed is like any
that means it could be anything but I
don't want to turn off type checking I
want you to require me to make some
assertions about the type before I use
it and there's an example of that done
at the bottom here I have this function
foo that takes parameter V and it's type
is mixed and I want to maybe multiply it
by 2 or maybe get the length of it but I
can only multiply it by 2 if it's a
number and so I have to check for that
check the type and I only want to return
the length if it's a string if it's
anything else I'll just return it so if
I don't do those if checks I will get an
error from flow because it requires me
to do that what they call type
refinement if the type is mixed so
here's a basic example I have the
function get chars that takes three
parameters the first is a string then I
have a number and a boolean and what I
want to do here is return some
characters out of the string either some
characters from the beginning or
characters from the end based on the
value of that boolean from start and so
I have those types annotated notice that
I did not specify the return type of
this phone
I could have said right at the end there
: string because that is what it's
returning but I'm not required to
specify the types and then I have three
calls to it the first two they're just
fine but that last one everything is
wrong three is not a string false is not
a number fubar is not a boolean and so I
get three flow errors from that line
flow understands all the built-in things
all the things from the JavaScript
language like array and console it
understands everything about the Dom it
knows about nodes and elements and the
methods that you can call on those and
knows about the browser API like
geolocation and web workers and web
sockets so it knows if you say that a
variable is that type what kind of
methods you could call on it it knows
all about node J s so if you just
require a node module it knows what you
can do with that and know some things
about react like the special kind of
event objects that you use with react
and more and so you'll find all of this
if you go to the github repo and go down
that branch you can see these files I
have them listed there core J us Dom J
us and so on and it's very easy to read
what it thinks the definitions of those
types are when you're taking the time to
specify types in your code it's highly
likely that you're going to use it in
more than one place and so it's very
convenient to give a name to that type
so you don't have to keep repeating its
definition this is especially true for
functions and for objects that are
supposed to contain certain properties
so you give a name to that and then
later you refer to that type now in the
case of an object when you specify the
properties you still can have additional
properties added you're just specifying
kind of like the minimum requirements or
if these are present they have to have
these types when you want to define one
of these type aliases you say type and
you give it a name and then there's some
type definition here and we'll see lots
of examples of what goes there coming up
there's a strong convention that your
type name should end in the word type
but it's just a convention you
have to do that another keyword inflow
you might want to look up later it's
interphase it's a very similar to type
and I have a URL where you can read
about the difference between those two
most of the time I think you'll use type
instead of interphase your example the
PI you specify types for a function we
saw an example like this a couple of
slides ago so here's another one like
that I have this function monopoly and I
can specify whether I'm passing go what
I rolled on the dice what piece I'm
moving and then I'm assuming that that
result type is a type that I've defined
somewhere else so that's adding types to
that function now what if I had multiple
functions that have the same signature
then I might want to define a type alias
for that function signature and so
that's what I'm doing right here and the
only difference is that I've got that
arrow right there instead of the colon
and so that's the difference when you're
defining type alias for a function
signature remember that you add a
question mark before something that is a
type where it allows null or undefined
and that's what I'm doing in this last
example here this is a typical node.js
callback function where you first get an
error if there was one and then the
result if there was one and so that's
why this is optional the error might be
null or undefined back up to this
example I want to say that Z is an
optional parameter I'm getting a
distance from a point to the origin and
it might be just a 2d thing and I just
have x and y values but if it was 3d
then I want to specify the Z parameter
and so that's optional I put a question
mark after the name of the parameter
okay I'm doing the same thing here for
the result of the callback function so
pretty simple to add types to your
function definitions next up arrays
there are two ways that you can say
something is an array you can refer to
the array class and then after that in
angle brackets you can specify what kind
of elements go in that array so flow
wants every element in your array to
have the same type you can also specify
it by giving it a tie
first and then square brackets after it
and so these things are equivalent an
array of dates or a date
array okay and you can nest them so I
can have an array of arrays of numbers
and specify that in two ways and so
here's an example of creating a type
alias for that with a very crazy name
that you would never pick and then an
example of using that and there is an
array of arrays of numbers another
variant of an array is called a tuple
and this is just an array that has a six
size where each of the elements don't
have to be the same type and I get to
specify what those types are by their
position and so in this very simple
example I have a point type and here I
really want both of them to have the
same type okay but they don't have to
but in this case I want them to be two
numbers and so it won't let me add more
things to it it always has to have a
length of two and I can change values at
a specific index but I can't use all the
array methods that would normally mutate
an array so tuple is a very specific
kind of an array there are three ways
that you can specify objects the
simplest thing is to say it's an object
they haven't said anything about what
properties it can have you're just
distinguishing it from other types like
string or number or boolean you could
also just use curly braces to say the
same thing but most often you want to
specify what properties are going inside
it now if I had written an es6 class or
defined a constructor in the kind of old
JavaScript way I would want to refer to
that instead and that's the third option
referring to a class or a constructor
function name but the second case is
really common I know that you're aware
that in JavaScript you often create
object literals that don't belong to any
class and so in that case you want to
use this and specify what properties it
can have and the types and so here's an
example where I have person type that
has these three properties in it and
notice that spouse is optional I don't
have to specify that property and if I
do specify it I
can set it to null or undefined probably
don't want both of those but you could
all right and then I want to create an
instance of that and some creating this
Tammy object which is a person type and
it has to have the name property and it
has to have the birthday property but
notice I specified a height well when
you specify an object in this way you're
just giving it minimum requirements you
can always add additional properties to
it so then I specify another one down
here the mark type and that one I
specified the spouse I didn't do that on
Tammy and so this appears that mark is
married but somehow Tammy is not married
we're going to fix that on the next
slide when we define a class for working
with this okay now what I said about
specifying the minimum requirements and
not being able to add more properties if
you don't like that there is a way
around it you can use this extra bit of
syntax to say I need this to be an exact
match in there are two ways to say it
that's pretty ugly I think I would do it
that way with the vertical bars okay and
then I already mentioned just using a
name of a class or a constructor
function okay so if I decide to go at
the class I could use es6 syntax and
here I'm defining a person class and
it's kind of similar to that person
object we saw in the previous slide here
at the top of my class this is unique to
flow I'm specifying my properties and
their types but yet again this doesn't
mean I can't have more properties it's
just these are kind of a minimum set and
here I want to require a height and
notice spouse is a reference back to
itself okay now one thing that I cannot
do here is I can't specify here that
those properties are really required I
wish that there was a way to do that so
I'm really relying on the fact that I
have this constructor and I'm setting
those things and there's no other way to
create this but I can't specify up here
and the types that they're required the
absence of a question mark doesn't mean
that in a class definition okay so when
I create an object I could do it like
this
and then I can call this merry method
and so Tammy marry Marc and you notice
that I'm setting the relationship in
both directions there okay so with that
class in hand and I've created a couple
of instances I have this function where
I can log out information about a person
and it's going to print out who they're
married to if they're married and some
checking that here and then I log out
mark and that's good but obviously
that's not going to work I can't use a
date object where it's requiring a
person object okay we get into some more
interesting features this is a feature
that is present in elm that I think is a
really great feature and when you read
the Elm documentation you'll see that as
its touting its own features that at the
same time points out how bad it is that
these things are missing from JavaScript
and there are two things you'll notice
about the Elm documentation one is that
it ignores the existence of es6 it only
compares to es five and the other is
that it assumes that you're not going to
use any kind of a type type checker
so if you add flow to JavaScript you do
get a lot of the benefits that you see
in Elm certainly not all of them but
some of them and this is one of those so
I can say that a primitive type means
that it's a boolean or a number or a
string and then if I say that something
is a primitive type I can assign any of
those in so it's not just one type it
can be any of these types so sevens good
food's good trees good assigning on an
empty object that's not good because
that's not one that I was allowing then
this next example is one where I'm going
to use a literal value for a type and
this is called a disjoint Union so I
have an animal type and I want to say
that every animal has a name plus it has
a type property but it's always set to
animal and then I have a mineral type
which is similar it has a name but it's
type property is set to mineral and
likewise for vegetable and then I can
create a type that combines them all I
have a thing type which might be an
animal or a mineral or a vegetable then
if I want to create a dog object I
have to set the the type to animal and
then I can put it in a variable that has
a type of animal that's all good and a
similar thing for mineral and a similar
thing for vegetable but notice that if I
left off the type or I said something
different that would be an error and so
why do I want to do this well one reason
is that you can take advantage of this
in a switch statement and I could switch
on the type of one of these things and
down here I want to say that sing is a
sing type and I assigned in a dog but I
could also assign a mineral or a
vegetable and then if I use that in a
switch statement and I switch on the
type property it would know what other
properties are present here now in my
example they all just have a name
property but suppose that animal had an
extra property that mineral and
vegetable didn't have that in my switch
if I switch on the type being animal it
would let me access that extra property
but if I was working with a vegetable
and I tried to access that same one it
would know that that won't work because
that doesn't have the extra property so
these disjoint unions are really useful
for that level of checking you can also
use unions for a plain enumeration so
here I have an activity type and you can
either have it be swim bike or run and
then if I have a variable that's
activity type I can assign any of those
three strings but if I try to assign
anything else I'm going to get an error
from that so we finally have good
support for enums as long as you're
using flow or typescript another
interesting wrinkle on this is that you
might want to say that the enumeration
values you allow are whatever the keys
are right now of some object and so your
application could start up you could
populate some JavaScript object and then
run code like this which will look at
that object and extract out what keys it
has right now and give you a type which
is an enumeration of those and then from
that point on you can only use keys of
the object for a variable that has that
type of course after you define all
these types you're going to want to
share them with other files your
application isn't just one javascript
file and so you need to be able to
export a type definition out of a file
and then import it into another one and
so there's export type and import type
but as you might guess just like working
with normal JavaScript code if you want
to use es6 imports and exports for say
JavaScript functions
something has to bundle that together in
order for the browser to use it and most
people use webpack for that and the same
is true here you need a module bundler
if you want to take advantage of that
but for most web applications you're
probably already using a module bundler
so here's an example of that in this
file that is type alias export Jas I
want to define some things and export
them and so first I have this thing
called named type a name type is just
any object that has a name property
which is a string it could have extra
properties but it at least has that and
then I have a function say hello you
have to pass it a named type doesn't
return anything so that's why I have
void on the end of that definition and
then I'm just going to print out hello
comma and then the name property out of
that thing so both of those get exported
then in this other file I want to import
those two things in so I'm using import
type there might be many things defined
there and I'm using this sort of
destructuring like syntax to pull out
that one definition and the same thing
for pulling out the function and now I
can create something that's a named
type that has a name and maybe other
properties and if I call say hello
that's going to work this one here I'm
creating a literal JavaScript object I
didn't say that it was a name type but
it does have a name property and so that
works just fine but here I pass it just
a string and flow is going to catch that
because it's not a named type sometimes
not very often you're trying to satisfy
flow and you just can't make it happy
and so when you hit a wall like that and
you just want to move on
and the easy way to do that is to add a
special comment that says dollar flow
fix me and optionally you can describe
what the issue is and then it will
ignore the next one but I want to
emphasize that it's very rare that you
run into cases where you need to use
this but it's really useful when you're
just learning flow and you've got
everything working except for this one
thing and you just can't figure it out
now and you don't have time to work on
it you can turn off flow just briefly
for that one case all right so now we
want to talk about slow server this is
the brains behind everything that's
happening here it's analyzing everything
about your code tracing the flow all the
possible flows through your code and
keeping track of the types of variables
and parameter types it's keeping track
of where everything is defined and so
there's a very good reason for that and
that is because the purpose of flow is
not just to do type checking but also to
help editors and ITES do things like
provide method name completion or find
all the references to this function or
in the future maybe do refactorings for
you because it knows so much about
what's happening in your code and so
when you run the flow server it starts
up a bunch of processes so that it can
evaluate your code in parallel and
that's just for performance on my
machine I noticed that it's starting up
10 flow processes but that really
depends on how many cores you have in
your machine and you can control that
there's a configuration option that can
change that if you need to but the
default has been working great for me so
by default what flow is going to do is
examine all of the dot J's files that
are underneath the directory that
contains a file called dot flow config
and we're talking a bit about how you
create that file not any mystery here
you say flow in it and it creates this
file for you and that's where you
specify some options in most cases the
defaults are just fun so if you're in
some subdirectory of your project it's
going to search upward until it finds
the directory that contains dot slow
config and once it's found that now it's
sir
is down for every J s file and evaluates
them after it runs once which might take
five or ten seconds if you've got a big
project it has now cataloged all this
information about your application and
then from then on it's watching your
files and if you change something it
will run flow on just that file but if
that file was important in another one
it will see that and run flow on that
one because that might have changed
something and it will see if you create
new files and run flow on those but the
interesting thing about the flow server
is that it doesn't output anything it's
checking all of this and it may have
found some errors but it doesn't tell
you about them you have to ask it if it
saw anything and so we're going to see
the command to do that in just a bit and
of course your editor our IDE is going
to do that for you and show you the
errors so to start up a server you say
flow start and that starts it up in the
background and usually that's what you
want if you're using an editor or IDE
plugin it's going to do this for you and
so you don't have to worry about it you
could start it in the foreground if you
want and then if you want to ask the
server if it found any errors you type
flow status or just flow and that is not
running a check it's just asking the
server have you seen any problems if you
want you can run flow check which says I
don't care what you saw before could you
do a fresh check of everything that's
not something that I do commonly and
then finally you can stop the server if
you need to by running flow stop so now
I want to walk through using this on a
real project and all the steps that you
need to go through so this will be a
good checklist for the first time that
you use flow so the first thing you want
to do is install a bunch of dependencies
we'll get to all these steps on separate
slides coming up then you want to put
some NPM scripts in your package JSON to
automate some things for you you
probably want to set up es Lind
hopefully you're using it already and
then you're just going to add some new
rules to your EF lint configuration file
to tell it to check your use of flow and
make sure you're doing a good job with
that then you want to set up Babel
because that is going to need to strip
floo types out of your code so that you
can run it then you've got to create
that dot flow config file so that flow
knows where to stop when it's looking up
the directory structure and then
showering down looking at all of your
files you probably want to set up flow
type so that you can install definitions
for third-party libraries that you might
be using and then you want to set up
your editor IDE so let's walk through
how you do all of these things so first
step is all the dev dependencies so step
one make sure you've got a package.json
for your project and if you don't you
just run NPM in it and it creates that
for you then you want to do an NPM
install and all of these are development
dependencies that's why I've got the
dash D you could use yarn as well to
install them and then you just go down
this list and set up all these things a
bunch of things related to Babel and its
plugins a couple of things related to es
lint and being able to check your use of
flow flow itself you want to install as
part of your project optionally you can
install flow watch this is good for when
you aren't using a editor IDE plug-in so
that you could separately ask it to
continually watch your files and output
errors in a separate terminal window but
if you've got the editor plugin you
don't really have to have that and then
finally NPM run all isn't really related
to this it's just that it would be
convenient if you could have an NPM
script that would do a bunch of things
for you you would like it to run yes
lint and run flow and then build your
application with Babel bundle it all
together and maybe run the code and some
NPM run all lets you bundle all of that
now you notice some of these things have
a green checkmark these are the things
that you're going to get for free if
you're using create react app if you
happen to be using react but otherwise
you can just manually install all of
those these are some NPM scripts that I
recommend so you want to have a script
for babel that's going to bundle up all
of your code get it ready to run you
want to be able to run flow itself flow
W is just a name I use for the variant
that is doing the watch and continually
watching my files and running flow
again if anything changes then I want to
run ES lids and I have the - - quiet
option so it only tells me about errors
I want to be able to run my application
so I'm assuming here that this is a
node.js app it's not a web app if I were
using a web app create react app would
take care of that for me or I could set
it up myself but here I want to run a
note app and then finally my start
script which I'll run by saying npm
start does these four things it lists
all my code it checks it with flow
it runs babel to bundle everything up
and then runs my application so we'll be
relying on these scripts in our example
coming up then i want to set up es lint
and the bird in the corner means i'm
going to go through this slide pretty
quickly probably don't need to jump into
detail but you've got your es
configuration file and it specifies a
bunch of rules and here's a list of
rules that are very specific to using
flow and you can obviously pick
different settings but it's really great
for making sure that you're doing it
correctly now i want to set up babel and
so here's a very stripped down version
of the babel configuration file and the
most important thing here is that I have
this transform flow strip types and so
that's going to enable Babel to remove
the type annotations so that I can
actually run the code in a browser I
need to have this dot flow config file
so all I have to do is run slow and knit
to create it for me and it will give me
this file it won't have this line right
here all these sections will be empty
and that's mostly okay the main thing
you'll probably want to add is that line
that I have there to tell it hey don't
bother running flow on the files in my
node modules directory because that's
third party stuff and they probably
weren't using flow so don't worry about
that part but I can tell it what files
to check by default it does what you
probably want lives is where it should
look for type definitions for any
third-party libraries by default it's
going to look in a directory called flow
typed that's probably what you want to
stick with there's some options you can
specify but there are none that I
commonly
and then there's also a ignore section
to say I don't want to run on these
files and then you can pin yourself to a
specific version of flow if you want to
do that so a big red box at the bottom
it's very important that you have a dot
slow config file because as I described
earlier
if you run flow and some subdirectory of
your project it goes up and up and up
looking for that and what if it doesn't
find it it keeps going up and up and up
and eventually it hits your home
directory and it says I can't go any
further
I guess you wanted me to run flow on
every javascript file on your hard drive
there's no way you wanted that and I
don't know why they have this behavior
they should say if they don't find a
file it does nothing and so the impact
of this is that your laptop all the
sudden sounds like an airplane taking
off because it's checking every file and
your CPU usage has spiked like crazy and
you've got to kill these flow processes
so in a UNIX II kind of environment like
a Mac I type kill all flow and that does
it but you could also run flow stop this
also happens if you've got a flow plugin
for your editor and you're off in some
directory where you weren't even using
flow and you start up your editor now
that plug-in starts up slow and it does
the same thing and hits your home
directory and your fans start spinning
this is the biggest problem in flow in
my opinion right now so you'll know it's
happened because you hear the fan come
on but the important thing here is
create that file so this doesn't happen
to you okay
I only take just a bit more about slow
typed so it's very easy to install and
then you run flow typed install and what
that does it's not installing flow type
it's installing type definitions into
your project and what it's doing is it's
looking at your package JSON to see what
you depend on and then it goes out to
its site to see if definitions are there
and if they're there it pulls them down
and it puts it in a flow type directory
that it creates for you if it doesn't
find them it will create type def
on the fly and not good ones one for the
type of everything is any just very weak
definitions just to put something out
there for you so that's not what you
want if you see any of those it might be
worth your while to take the time to
write the definition to yourself and
submit them back so that this doesn't
happen to other people in the future
that wants to use that same library but
to give you an example of the kind of
things that are out there here's a list
of some commonly used libraries that do
have flow type definitions then you want
to set up your editor IDE the final step
in my checklist and so I have here a
list of some popular plugins for each of
these that you might want to consider
and I tested this out in a demand and
Visual Studio code those are not editors
that I use but it was very easy for me
to get it running and I opened up code
that had flow type annotations and it
rightaway was showing me errors the
integration is really nice my editor is
them and so I have a bit more
information about this but I won't bore
you with the details
suffice it to say that if you do use
them this plug-in ale is just wonderful
it supports all kinds of syntax checks
for many different languages and flow is
just one of them that it supports for
JavaScript it automatically sees that
you have them installed and it just uses
them and shows you the errors right
inside them okay
so let's close up here by looking at a
sample project that pulls all of this
together so this is a node.js project
that uses a very popular library lodash
and a very unpopular library liner which
is one that I wrote liner reads lines
from a file and give them back to you
one at a time you would think that would
just be a easy thing and no js' but
that's not the case no J's wants to
treat everything as a stream streaming
across the newline characters and so you
need to do something special if you want
to break it up at the Newlin's and so
that liner module does that for me so
I'm going to use the start case function
out of lodash which takes the string
that has words in it and it makes the
first character in every word the
uppercase so when I'm ready to run this
I'm going to say npm start we saw that
script earlier remember that's the one
that uses npm run all and it does lint
and flow and babble and then it runs my
code so first i need to install my
dependencies and so we walked over all
the tooling dependencies I needed
earlier but for this specific project
I need liner and I need lodash and so I
run that command to install those as not
dev dependencies but there are
dependencies of my project all right and
so here is our code I'm going to start
with the main bit of the code and then
we'll look at the utility that I wrote
in just a bit so I'm importing this
thing called filer that's on the next
page in a file called file or gif and
that gives me a function and I call that
and I passed to it a path to a file and
here is that file ok and it's going to
invoke this callback function when it's
done and it will pass to me the number
of lines that it process so so I give it
a function where it has a parameter
that's a number and it doesn't return
anything and it's just going to print
out the line count and here is that
output right there and filer itself is
going to read these lines and then
output the same lines but notice that
the first letter of every word is
uppercase so very basic thing that I'm
doing here so let's look at the code for
filer so here we got filer j us and i'm
pulling in the liner module and i'm
pulling in the lodash string module and
then I have this one function that I'm
exporting at the bottom process file and
so here we have some flow annotations
Kaz is a string and then the callback is
a function with this signature it
expects a number and it returns nothing
and that this function process file
returns nothing and so it's type is void
so I set my count at 0 I create a liner
object I tell it about the path then I
have to register for
some events when I get a readable event
that means that there's some text for me
to read I've got some lines and so as
long as that remains true I call liner
dot read I get a line a lot to check to
see did I really get one if I didn't and
I'm done with this event but if I did
I'm going to call start case on it
convert the first characters to
uppercase and print it out and bump up
my count by one and if this was a really
long file I may get several of these
readable events and when it's finished
I'll get an end event and that's when I
know it's time to invoke my callback
function and so I call the callback with
the count I might get an error in that
case I'm printing out the error and then
export that and so going back to the
previous slide notice that the thing
that I'm exporting is a function called
process file but over here on the import
I could call that anything I want so I
called it filer over there
so the main point here is that I threw
in some flow type annotations and I
could say npm start and it would run yes
let it run all the flow checks and then
run my code including stripping out all
the annotations so my summary of all of
this is that you need to think for
yourself does the time required to learn
how to use this and to actually put the
types into your code is that justified
you're going to get some benefit out of
that and in my experience I've gotten a
lot of benefit as I said initially it
was finding simple things like you
didn't account for the fact that this
variable might be null or undefined and
a bad thing might happen at runtime but
then later when I had to do big
refactorings it was finding all kinds of
issues that would have taken me much
longer if I wasn't using flow so there
are some reasons why I prefer flow to
typescript but bottom line is I highly
suggest that you use one of these it's
made a really big difference in my life
as a JavaScript developer along with es
lint and prettier that I recommended
earlier and you should probably start
simple and that's a nice thing about SLO
is that it does let you start simple you
can just annotate some of the files and
leave the rest alone until you're ready
to add types to those and over
time your confidence in being able to
work on that code is going to increase
and so I have I think five minutes left
as I said there are many more bonus
slides here that you can check out later
but we've got time for questions and
maybe one of your questions will be
addressed by one of these slides that we
haven't seen yet so who's got a question
the first one is the heart well let me
jump to one more thing to show you that
is a difference between flow and
typescript and that is this distinction
between nominal and structural typing so
nominal typing is when you recognize a
type just by its name structural typing
is when you think a thing as that type
because it just matches the other thing
earlier we had an example where I had
something called named type and so it
could be the case that anything that has
a name property is good it's kind of
like duck typing that you've heard about
but in nominal typing if your type is a
class you might say that just because I
have this cat class in this car class
and maybe they both have a name I don't
want to be able to use a car everywhere
where I use a cat if I said it should be
a cat it should be a cat or at least
something in the inheritance hierarchy
of that but if you use nominal typing
that would allow you to use the car
anywhere you use a cat as long as they
have the same properties in the same
methods it turns out that typescript
uses why I reverse that there I was
talking about structural typing nominal
is by name so typescript uses structural
typing or duck typing flow uses
structural typing when you specify
object literals and their properties but
if you specify a class and in that case
it uses nominal typing and that makes a
difference and so I walk through an
example like that
and here I have a living thing class and
then I say plants and animals are living
things and dogs and cats are kinds of
animals and then I create this array of
animals it's empty now and then I push
into my array a dog and a cat and a
plant that's not good I shouldn't be
able to put a plant object into this
array that is only supposed to hold
animals and Flo says that's an error
typescript says it's all good and the
reason it's good is that all five of
these classes they don't have any
properties or any methods so they all
match I think that's a little bit odd
that it doesn't complain about that and
so that's another reason why I prefer
flow over typescript all right well I
think that's all the time that I have
but if you have any questions about flow
or anything in the JavaScript world
please catch me sometime have lunch with
me tomorrow I'd be glad to talk with you
about that and you have all my contact
information on that first slide feel
free to shoot me an email thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>