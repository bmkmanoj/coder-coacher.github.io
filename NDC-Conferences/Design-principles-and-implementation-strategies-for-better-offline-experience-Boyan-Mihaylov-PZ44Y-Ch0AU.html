<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Design principles and implementation strategies for better offline experience - Boyan Mihaylov | Coder Coacher - Coaching Coders</title><meta content="Design principles and implementation strategies for better offline experience - Boyan Mihaylov - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Design principles and implementation strategies for better offline experience - Boyan Mihaylov</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PZ44Y-Ch0AU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Brianne and today we are
going to talk about offline application
experience before I start let me ask you
how many of you are developers is there
anyone here who is doing any kind of
design interaction design or or just
design in Photoshop maybe or something
like this there are a couple of you all
right because what I want to do today is
to go through all the aspects about how
we can improve the experience of our
applications when we are talking about
offline so we are not going to focus
only on the technical part but also on
the experience part what principles we
have to go through that and although I'm
going to focus mostly on the web apps
the same principles are actually true
for native mobile apps if we're working
with that we live in a well connected
world everyone has here I assume a
mobile device a phone a tablet or
something like this connects to the
Internet but it's not enough
we have appliances connected to the
internet maybe your coffee machine is
connected to the Internet where your
washing machine is connected there or
maybe you have one of these fancy
buttons on your fridge so when your milk
is is over you can press the button and
then you get a new bottle milk delivered
to your place in a couple of hours so
our world is pretty well connected then
we owe a part of this this is a map of
the internet connection speed worldwide
and as you can see the northern part of
the world is pretty well connected the
connection speed is pretty fast however
the more it goes south the more things
change so the connection is not that
stable and if you think this is really a
big number big mountain population
living in these areas and when we design
applications
which we want to make popular worldwide
then we really have to think about these
people living in such areas where the
speeds are not quite quite fast let's
imagine that you're travelling around
the world and working as a freelancer
maybe and you've been doing that
probably do note that let's say working
from Asia could be a challenge because
you may find difficulties with Faneca a
place where you have a good connection
where you can work from sitting and our
office here is fine because we are used
to have the best the best setup for us
we have really fast machines we have a
good connection but moving a bit there
the things change dramatically
but even if we live in the northern part
where we can see that the quality of the
Internet is pretty good there are two
situations where we can have problems is
there any one of you commuting to your
workplace using train let's say or
something like this there are a couple
of people doing that so when you are
commuting let's say in a train you could
also see that even though you're trying
to do some work there the connection is
quite unstable and it could change once
in a while so the thing that we
statistically live in a place is where
the connections are supposed to be good
there are still situations where we may
have some problems another example could
be that if you are at the big festival
somewhere you know when trying to use
their mobile phone you could also see
that when there are so many people at
one place this could also become a
challenge for you let's take a look at
this example that you are sitting in the
train and you are writing your report
that you have to hand to your boss in a
while and while you are writing this in
online to online collaboration - at some
point after writing a couple of pages
you decide to press the Save button and
what is happening there is
this you see this kind of screen because
in this very moment when you decided to
save your work you suddenly lost
connection maybe you are going through a
tunnel or something like this just a
place or an area where the internet
connection is missing and then it spits
annoys you because you have already
spent time working on something and it's
suddenly lost but then you think hey I
can press the big button of my browser
and I will probably go back and then you
press the button of your browser and
well you see the same picture basically
so now everything is lost you know that
everything is lost and your time and
your effort is lost as well and this is
not cool this thing shouldn't happen
what we want to do is that we want to
design applications that can tolerate
when the connection is gone or when the
connection is unstable because this
situation improve the user experience
drastically so how can we do this now I
want to go through a couple of
principles what what means to have a
good offline experience what what could
it be
and one of the first step is when the
internet connection drops please
degrades gracefully basically don't
crash my app or don't show me any
warnings or whatever just just show me
maybe a message what's happening so in
our example this is this is basically
the example of something called Google
Docs I guess both of you know it and
what happens there is when you go
offline there is a small icon up there
saying that hey you're offline so that
you as the user know what is happening
so the application is still there it's
still open in my browser but I do know
now that something has happened with the
internet connection so I can expect that
there will be a different experience
from now on for me give me always access
to this content so basically content is
always mutable doesn't matter
I mean I'm writing my report
doesn't really change it if I'm online
or offline I am still writing my report
and the things are there because I have
I have downloaded the contents right and
I'm modifying it right now so this
doesn't really matter again if I have
connection or not so what I expect in
this moment is when I get offline I
expect to be able to continue working on
my report so that I can I can basically
do finish my job what I started right
there when we do something is users we
expect some feedback clear feedback from
the machine from the computer so if I
press the button I expect something to
happen maybe to see a loading indicator
or maybe to see a pop up showing up
something should happen demonstrating
this my action has been accepted the
same the same this is basically a
general general principles when
designing application so I expect the
application to provide me a clear
feedback what is happening when I'm
doing anything so in this example could
be while I'm still working maybe trying
to save my stuff there is a message out
there some hey you're offline but don't
worry we have saved your work offline so
you don't have to worry because your
things are not lost and this is this is
feedback that makes me feel safe as a
user so that I know that everything that
I have spent on my time and effort they
are saved the content is always there
and I guess I have open it so I have it
so please give me constant access to
this because I care about this so we
have to already open this application
and let's say that suddenly my browser
crashes or maybe your Windows has
decided to install updates and
predictably and you have to restart the
machine Oh at respect that when I open
the tab I should be able to see my
reportage it was there instead of just
showing a blank screen or anything else
because I I have opened it and I have
used it I have seen it it was
there so I do expect it to be there even
if I start application again without
internet connection when we are using an
application we as users are basically
moving from pass a to pad B so we are
navigating and doing some stuff and what
we want is to be able to go to the last
thing we have done so if if I close the
application and start again so please
take me to the last step where I've been
there so in my case let's say that I've
been working on page 10 in my report if
something happens and I have to go there
again please show me the TAS been
working on page 10 and everything is
fine with the data they have had I have
written there so these are just some of
the principles of what it means to have
a good application design when it's
considered to the to the availability of
the internet connection there are many
others
that could be implemented as well so now
we have to think how having these
principles what does it mean how do we
go on with that as a developer because
most of us here in the day and in the
and this is the room our developer so we
want to see how we can take it to the
next step and the first thing we have to
do is we have to go back and revisit to
what is called the request response
model what does it mean well let's say
that we have a mobile application that
is listing some news and you have the
possibility to mark muses favorite very
very simple so what you go there the
typical request response model will be
implemented like this you go there you
click on this circle to the news that
you want to mark as a favorite what may
be happening is probably get some
waiting indicator showing that showing
that the pace I'm updating yourself so
what is happening right now
is a request is sent to the network then
we are awaiting to reply and then when
we get the reply we are delivering
status to the user saying that ok I have
now marked this item as February's so
that I know that my action is
implemented what is happening here there
are a few drawbacks with this model the
first thing is that it only works when
you're online so basically if you're
offline it doesn't work because you
can't make connection to the Internet
and what would normally happen is that
you'd get probably an error message
saying sorry you don't have connection
to that another issue is that even if
you have internet connection it
experienced really ver eyes best of the
quality of that connection if you have
really good internet connection you
basically see a blinking of this model
of this model dialog right so it will
just come up for milliseconds and just
disappear right away because the request
will be executed quite quickly on the
other side if the connection is very
poor it will stay there for a long time
and some people we decide all right I
would expect that most of my users have
good connection so I don't show the
model dialog at all I just freeze the
application because I don't expect it to
be frozen for a long time at this work
of course as long as your internet
connection is indeed fast but if you get
in the area where you have poor
connection then the whole application
will be frozen for certain amount of
time and this is not what we want this
is not good user experience if you have
to make a very short architectural
description or module description of
this application it could be something
like that so basically we have a view
out there we have any kind of a view
controller or whatever you can call it
and and then we have the network so
basically every action from the view
result in some action that is translated
to a request to the network then we have
the reply back and the view is updated
with the response from the from the
network
how can we improve that well what we
could do instead is that well
what if our actions are always possible
what if we don't need the internet
connection at all let's say that
everything we do in our application it
is possible it could happen so this
would work like this we have the same
application with the same list when I
click on an item it will get a color
visualizing that hey I have accepted
your action this is not the final result
but I have accepted your action and I'm
working on that and in the background we
are going to make the request in the net
so basically we have accepted direction
but then making the request in the
background and then once the response is
back then we get the final agreement and
of course if there is no response or if
there is own Network then we will still
having this mark out there we can still
see that our action is accepted what is
the difference here all the difference
is that we don't need the turns
connection because it will always work
like this how can we do this well let's
say that we introduce a model which is a
global model for our application and the
view is always representing what's in
our model so every time we do an action
we update the view and the view is
synchronized with the network once in a
while if there is a network connection
available we do it right away otherwise
we do it when we get connected at some
point in the future and this is dramatic
change in the thinking because now our
application can be used at any time of
course you need to load the list of news
and if you don't have connection this
time you can't do this but the next step
is really independent of the
availability of of your connection we
could do even better let's imagine that
you have the same list you have marked
your item out there and the item is
waiting to be synchronized with the
network then then you maybe open another
vacation maybe you are looking at your
pictures or something like this
and at some point your mobile phone
decides to kill the other application
because it needs more memory or
something like this then you open the
application again and you can see that
hmm I'm quite sure that I I press this
button out there so suddenly you have
missed your action there so what's
happening is that our model wasn't
persisted because it was only living
within the application and as
application gets closed
we of course lose everything in our
model so what's the solution well we can
introduce a persistent model so what we
could do in this case is we can have one
another module code application logic or
something like this which is the one
updating the model and the model is
always persisted out there so every
action results in a change to the model
and at some point this will be
synchronized with the with the network
and once it is synchronized the model
will be updated again the difference
here is that no matter if you're closed
application and open it again you still
be able to see the last state of your
application as you have left it out
there and this it doesn't really matter
what kind of framework you use on or
using MVC or or nvm or redox maybe it
doesn't really matter this is just an
idea concept how you can implement this
one network is our enemy because it is
unstable and could be unavailable tisk
is our friend so it means that
everything could this device can be can
be stored there and if you're doing
native mobile applications this is quite
easy because you have access to to these
things if you are doing web apps
it could be bit more tricky but there
are still ways how you can persist data
and this is what we are going to for
now and a couple of slides you see how
actually we can implement persistence
and caching as a tool to be able to use
when we are developing web applications
the traditional HTTP way of doing things
is that you know you're making a request
to some resource and you know that in
the response you can get some special
headers indicating how this resource
should be cached and there are different
ways how you could do this the problem
with this approach is that it works
individually so it works for resource
but what if you have a different
resource is that they depend on each
other
and what if you are dead unlucky that
once you get offline just one of the
resources has to be renewed from the
server and you don't have connection
this time so basically your web
application is not going to work just
because one of these resources has to be
requested from the server again and you
don't have connection so as long as as
long as we talk about offline the
traditional methods of fusing HTTP
headers doesn't really help us that much
another variation of this is using
so-called cookies and idea there is that
of course we can set some key values
that we could use between the client and
the server the problem is of course the
same that if we want to do something
then we need the internet connection for
that and furthermore we have to send
these cookies with every request
although there may only be aware or if
they need it for one part of your
website or web application we tried
something else in the in the past we use
the flash or Java applets they gave a
sexually this opportunity to store some
data locally in your browser so this was
a good opportunity for us to be able to
do some some caching for our apps
however nowadays we don't use these
third-party plug-ins for different
reasons what do we use them well we use
html5 and although on the standards the
mechanism that came with it and that are
being developed on top of it so now I
want to go through some of these and see
what are the pros and cons of these
mechanisms and these standards that came
with html5 and to whether we can use
them when you want to implement caching
and persistence for our web applications
one of the first mechanisms that came
it's called application cache the idea
here is that we have a file called
manifest file and in this file we could
define how and which part of our website
is being cached then we could also write
some some rules about exceptions
fallback etc so this file has to be
loaded with every request on our page
and the thing there is that once you
catch the things these resources that
you have defined their cached forever
the only way to remove these cache is to
basically provide a new version of your
manifest file all the browser's
implemented this so it was implemented
as absolutely all the browser quite good
browser coverage the problem is that it
was very very inflexible it wasn't it
was very hard to debug what was
happening there and it also could
introduce some problems with caches the
manifest file itself which some people
try to end so that it was a very big
problem for them so all these different
problems led to this standard became
deprecated basically so no one is using
this nowadays anymore
we're using files over day we have
operating systems where a file structure
is one of the basic structures that we
know so then we thought why don't we use
files in the web as well I mean we are
good at using files we know how to use
them and this led to the creation of the
so called file system API and that is
the same is basically a file system
sandboxed in your browser where you
could do all the operations that you
know with the files the thing is that
this is not a standard basically because
it was only primarily developed by by
Google into implemented in chrome so
using it in other browsers Safari
Internet Explorer Mozilla this wasn't
possible out there so focusing only on
one browser vendor is not a really good
solution especially if you want to
develop apps that are used worldwide by
many users with different settings then
we came to a very simple concept what
about just a simple key value store and
this is how the web storage was created
web storage exactly this key value
string store so we can put values there
and we can retrieve values there and
they can be saved globally for your
domain or just for the session of your
users out there it is also very well
implementing the browsers it has quite
quite good support or it is very
simplistic to it means that we have to
care for everything that we do so if we
want to cache a big object to persist a
big mall out there we have to manually
serialize it maybe it's a JSON and then
put it to the shrink then digitize it
back so we have to put a lot of code on
top of that so that so that we can make
it a bit more flexible for simple
scenarios is perfect but then once our
logic becomes a bit more sophisticated
then then it wasn't probably the right
tool so what else could we do we know
databases you know sequels so why don't
we use sequel in the browser
that's also another solution that came
out their web sequel database allows us
to create tables and basically to
execute sequel statements in the browser
and it gives transactions as though we
love transactions so it was a good - the
problem was that it kind of didn't
really get implemented by the browsers
as well and eventually led to to being
deprecated this the application cache oh
if not sequel then we go to no sequel
right so this is what indexdb is in the
business oh no sequel database basically
in the browser so you can create against
tables and you can put just JSON object
in this table and this is also really
good - that good mechanism that's
actually got good support from other
browser vendors which means that
Institute that we could use the day if
you wanted to do something opposite of
the web storage what using kindig the be
is is good for a bit more complex
scenarios but if you want to use very
simple ones then this is probably a bit
overkill so there can end up on the two
sides of the simplicity like web storage
is for very simple stuff this for more
complex but if you have kind in the
middle maybe you want to use a bit from
both of them or maybe you need some
other - or some other mechanisms how you
want to implement head cache and this is
what led to two service workers service
workers gives us a way to
programmatically define what is
happening with our resources all the
previous solutions they were fine if you
want to work with data the problem is
that a part of our web site our
resources that we request from the
server this probably our JavaScript
files our style sheets another HTML
files so this is the resource this is
not data this is something that we have
to load using HTML unless you want to
load
in JavaScript there because there we
could probably do this but if we allow
them to think things like resource with
HTML using normal HTML tags we can't do
anything about these that we can't
implement caching mechanisms that will
be usable for offline scenarios right
away and this is something that we could
do with service workers and the reason
for that is service workers are
intercepted their proxy between your
browser and the internet so there we
have the possibility with using code to
describe what we want to happen with our
resources and our data a simple life
cycle of the service worker looks like
this so we are basically rising
different events and the service worker
the code there that we writer is just
listening to these events and performing
different actions so basically we have
install event then we have activated
where we do the what we want to do at
some point our service worker becomes
idle it can use some messaging to
communicate with the browser or at some
point if there is nothing left to do it
can just terminate how does it look like
well this is how it looks like to to
register service workers so basically we
check if the browser support service
worker and then we point to a javascript
file which will be our implementation of
the service worker and then this file is
of course downloaded after this so it's
pretty simple the code doesn't look very
pretty so on the install event so what
we do so this is already in the Service
Worker implementation that we have so we
are listening to the install event and
then we want to do something in this
case what we do is we're using the
built-in cache API that comes along with
the service workers we could see that
when we are installing the service
workers we are automatically
these three resources index.html our
stylesheet and our application
JavaScript we could see that this is the
static part of our application so we
want to cash it out there so this is
just putting it into the cache and we
are putting it at the cache forever
basically then we can intercept the
fetch event and the fetch event is rest
when the browser tries to load the
resource out there so what we could do
now is we could intercept these events
and then what we are doing now is hey is
there anything in the cache matching
this resource that you're trying to load
and if yes then we'll just get it from
the cache otherwise just get it from the
network as you want to do so this is a
very simple example what we could do
with the service workers and one one do
with them the good thing is that you can
see this is JavaScript code so we have
control over everything that is
happening between the browser and the
network so we get both we can both
intercept beta work with data and we
could intercept resource fetching
started by the browser service workers
give us a lot of opportunities but they
have some specifics that we have to be
very careful aligned with they're
working only with HTTP due to security
reasons and they're working in a
separate background thread so the
communication with your UI thread is
happening using messages as I saw so
there are events and you could post
messages to the to the browser and to
the UI thread and back to them one thing
that is very important here is not that
the serviceworker could be still
possibly working or doing stuff even if
you close your browser so and this is
something that is very powerful in a way
but it could go so very dangerous and
that's why there are two discussions
about the security implications of using
service workers into the
browser right now so what can we do with
this service workers I just show one
example but what else could be doing
what kind of scenarios we could
implement with this so now I will just
show you a couple of caching strategies
that how they can be implemented using
service workers and what kind of data we
should be using for that scenario the
simplest one is or basically this what
get the default one is the network only
so it means that everything goes pass
through your service worker to the
network right and you want to use this
basically for all your non get requests
right you don't want to catch post
requests or something like this and you
don't want to catch any kind of
analytics maybe Google Analytics that
you have because they usually make a get
request or an imager or another resource
there so we want to let them pass
through this event you don't want to
catch them on the other side you could
do the opposite you could set cache only
so you could see everything that is
indication returned only from there and
this is like an example once you get the
request first time you cache it's
basically forever or until you manually
save it this should be replaced with a
newer version and if you think many
applications they have a kind of static
part which rarely changes and this could
be some style sheets or this could be
just general general framework that you
are using in your web applications such
things
they are usually reasonably static or
they change very rarely and you could
control how these are cached of course
if you want this so in these scenarios
you want to take them always from the
cache another way is that what we also
and example is that hey what we if on
every request we try to get it from the
from the cache if it's not there then we
do connection to the internet so this is
one of the majority of the requests will
be implemented using destruction it's
one of the most popular one right
then we could do the opposite we could
say that alright we try always the
internet first but if it's not working
then we are getting the data from the
cache and what we are doing here is the
operative cave connection to the
Internet cool you always get the newest
data but if you happen to be in a
situation where you are disconnected you
will be still getting data though a bit
old problem so in these situations of
course you should be able to tolerate
that some users for certain amount of
time would get some old data then
variation of this is then we always get
it from the basically to the cache but
you also do an internet connection
request so we show the data from the
cache and then we make a request to the
Internet once we get the response we
have data cache with that and this is
used basically in situations where you
don't you don't really need to the
latest version right now but you want to
be closest to the closest to the online
version that you have out there so
basically the net the next request to
the same resource will get the updated
version right there and this is useful
in situations where these resources are
don't updated that often then we could
use something else if you really want to
update the version so we could do the
same but when we get the response from
the internet if we are connected then we
are updating our view right away and
this is useful for example if you if you
think about the Twitter or Facebook you
know you have this timeline with events
so what is happening there is that you
always see number of the latest events
and then once you get a new recur so
basically you are polling every once in
awhile and once you get a new request
you response from the internet you're
just updating the whole timeline but of
course if you are not connected then you
be still sync this static listed has
been cached recently in your
in your local cash in other situations
we could do the so called networking
catchphrase what does it mean we could
say that all right I want to always show
the online version of this resource but
I'll give it a timeout I want to be very
fast so I really want my applications to
show quickly so I'll do try if you are
in situation where you have fast
connection good just show me the
resource otherwise just show me the one
from the cache and this is in very
interesting patterns that you could use
situations where you wanna make sure
performances is very vital for your
application and and your users you
always be getting the newest one given
that they're in scenarios with areas
with quality connection so these are
just some of the patterns there are
strategies what we could do with service
workers and how we can implement the
different caching strategy the only
thing that we have to be careful with is
that when we start working with cache we
have to really understand what data what
resources we are caching because
different resources in our application
will require different strategy and it
always means when we are showing the
newest version to our users so in some
scenarios you don't really care about
the data but in others the data is
really vital and you want to make sure
that what you show to the users is
really important so this is very
important in these scenarios what else
could we do with service workers well
the thing that the service worker is
working in a background thread give us
one more opportunity we could actually
implement background synchronization as
we talked in the beginning so which
means that every now every request did
want to make to the network we could put
in a crew and this crew can be
synchronized with internet if you have
connection so basically if you are
connected now
it would be executed right away but if
you are not connected then it will be
put in this synchronizing queue and it
will be seen for a nice little aid so
this is just an on another model or
another way how we can build on the
service workers and and use their
advantage what they provide us the
question now is is it ready so if we
have to take if we check like on can I
use you know this website where you can
see the current status of its workers
you could see that majority of browsers
have already implemented service workers
and they are few doe that are still
waiting and it is Internet Explorer
basically Microsoft and we have fo with
with the Safari version of that so there
are still browser vendors that are not
really considering implementing service
workers and the problem here is the
security implication that we get there
are two very very active discussions in
the community whether it's a good idea
to approach it or there should be
another mechanisms how we could
implement these benefits that we would
normally get with service workers
whoever the community really likes them
and this is basically recently from the
Apple conference that it was a couple of
days ago so you could see the
presentation about the new Safari
browser and what it can and all the cool
features that it has and these are just
a couple of the examples about people
asking them if service workers are going
to happen because they are not part of
it yet so the community is there and and
they request this service or because
this is a very good solution to many of
the problems that we have right now with
the development now I want to finish my
talk with discussing some myths in
relation to to this application
experience when we are considering
offline scenarios because we already saw
all different opportunities that we have
we saw different strategies so these
myths are something that we should
consider and see what else we could do
to solve it and to be more active out
there one of the first myth is that as
we see these developers we expect that
everyone has good deterrent connection
everywhere at every time and this is not
the case and suddenly if you start
moving from place to place the things
changed and if you want to deliver
applications of high quality worldwide
you want to make sure that we understand
how our users live how they use our
application in what scenarios and what
situations they do this because this
could be really vital to the experience
that we want to provide them then we
could see all right I mean we're
everyone has internet connection
nowadays I mean why why shall we
consider this where this is not the case
it could still happen two different
reasons that we are offline once in a
while and these situations could be
really life-saving imagine that you are
doing mobile applications for rescue
team in the mountain let's say it
suddenly they don't have connection
mobile connection anymore there so of
course you can use communication this
way but you could still do some part of
the application that is too usable even
though there is no internet connection
we went through a couple of scenarios
about how we could catch that and how we
can proceed data in order to help us
deal with offline scenarios offline
situations however these implementation
strategies they are not only helpful for
offline scenarios these are only
available to help us to improve the user
experience you can imagine that even if
you are still online by changing from
request response model to to the
synchronisation model you're drastically
improving the performance of your users
because suddenly they do everything
right away instead of waiting to get
response from the network then we also
fought alright when we are doing mobile
applications native applications we have
access to kind of to the everything that
our device allows us however on the
other side when we are doing
replications we are depending on what
our browser allows us to do and we may
see that many of the standards they got
deprecated because of different reasons
but still there are tools that we can
use and there are possibilities and I'm
not mentioning here the whole bunch of
JavaScript frameworks out there that are
building on on indexdb or web storage
that allows us to be very flexible in
the different scenarios that we might
want to use this offline persisting
mechanism the only thing that we have to
do or the first thing that we have to do
is basically to change to switch our
mind for thinking that the network is
already there we have to see that our
application is isolated let us make
let's give the best of it to our users
let's make them capable of accomplishing
every single action on their phone on
their mobile device thank you so much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>