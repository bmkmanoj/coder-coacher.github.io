<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ReST 3.0 – A lap around HTTP Apis' next generation - Sebastien Lambla | Coder Coacher - Coaching Coders</title><meta content="ReST 3.0 – A lap around HTTP Apis' next generation - Sebastien Lambla - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>ReST 3.0 – A lap around HTTP Apis' next generation - Sebastien Lambla</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/M-QXYLygo2M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and now ladies and gentlemen it is 1340
please welcome on the stage serial Serb
awesome there you go there's even an
alarm to tell me that the show is
starting now alright let's make sure I
mean do not disturb ok how many of you
have been to my talks before ok good
you'll new I apologize in advance we're
going to talk about rest 3.0 how many of
you think it's a linkbait title very
good the other half of way too much
confidence in speakers it's not exactly
linkbait there is good reasons behind it
but before we start beyond the fact that
they printed my face on a nice little
schedule why would you listen to me go
on and on about rest whoops I'm cereal
said that's my Twitter it's the only way
to get in touch with me you can also
catch me at the pub usually but once
upon a time I started thanks to Clement
Buster's and a absolutely awesome
presentation on service-oriented
architecture I started my path on trying
to build distributed systems if you
calculate between 2017 and 2001 that's
16 years of failing in so many ways and
then in 2003 2004 I started resting all
the things I was resting a lot enough it
happens I was out of a job rest does not
pay
so because I got absolutely no money I
thought there's just you up until that
way we'll just continue on that trend
and in 2007 I built back when there was
nearly nothing on net a resource
oriented framework called open roster
and I started talking about stuff I
thought I knew in a lot of conferences
and user groups so I've been wrong
enough often enough to have something to
say so I got you here to talk about
mostly HTTP api's and where we are in
the industry right now which means a few
things I'm going to try to sell you
concepts and ideas that exist are
deployed that you can feel touch and
look at implementations of I'm not
selling you a silver bullet I'm not
selling you the death of rest I'm not
selling you rescue porno because
apparently your new product is claiming
that so I'm selling you the next version
which exists right now
and rest is good because if we go back
to history the web started in 91 not the
internet but the web Tim berners-lee and
the other very smart guy that I can't
remember the name of in 1999 we had the
first specification for HTTP 1.1 which
has been with us as the only network
protocol for the biggest a most reliable
distributed system ever built which is
the web and loosely and rest I just
killed the funny image there and in 2000
Rho fielding wrote a thesis that
unleashed the term rest very well
specified and of course by 2001
people started talking about how rest is
not rest and it's plain old Jason and
XML at a time which is Jason burr with
different brackets and anyone knows who
that is
Don bucks John box in a bus
I wanted to preserve you so I kept him I
kept the picture where he still has his
t-shirt which is a first five seconds
I'm pretty sure code of conduct would
not allow this anymore
but nevertheless so the web exists
already the since 91
and that's rest of your point nine right
its wrestles away until the term rest
has been coined and then we all know the
rest Juan puno in reaction to serve web
services code generation static
contracts and all these nightmares that
ended up all the way to WS transfer
we've really implement HTTP GET over
soap because why not the loop is closed
so that's stuff that we all started with
right how many of you still use services
like that but you could say it it's not
it's not it's not bad it's just old and
so back then I was around 2009 I was
defending the term rest very heavily I
was a little bit in my constraint view
of the world no rest is not that this is
not rest you don't understand rest stop
using the word rest let's fight for the
term rest and as you can see I was also
not a very nice person back then a
poorly written pleasure that my god I
just I keep all these long entries just
out of integrity but that's not very
good for marketing and then having
conversations with a whole bunch of
other rest of areas which we used
call the people that were interested in
rest nothing to do with style really and
really nothing to do with stuff we
discussed and I said well maybe we need
to drop that term completely I'm not the
one that started this of course there
was already a feeling that rest was dead
as a term it didn't mean anything
vendors have started to implement
terrible frameworks that all came to the
rest and so everybody changed that term
so we started talking about the
hypermedia that's what I call rescue
porno right
hypermedia is where we start using
documents and we have links and it
starts looking like static HTML in your
API so right how many of you use API is
where they are links in it that's not
bad right
half of the room how many of you have
never seen a JSON document with links in
it all right so the other ones have made
a conscious choice of not using links
since then a lot of stuff has happened
in the industry I don't know if you've
noticed but the HTTP world has been very
excitable in the last couple of years
and they've built a whole bunch of stuff
and it's difficult to follow and so I'm
going to try to present you a partial
view of all the cool stuff that exists
and the stuff that people are investing
a huge amount of money to make HTTP
better and I searched I shall call this
rest for a point oh and I think it
should be like the HTML specification a
living thing so that we stop versioning
for anyone that's oh my talks know that
versioning is evil
so of course the first question is is it
retro right the community in rest has
always had issues with telling people
what is not restful a very very hard
time to explain what restful is so
there's a website for that
there's a great website for that call is
it restful calm I encourage you to go
there only my website is not on there
it's not restful but then again if you
ask again you will notice that the site
actually doesn't care at all and the
reason they created the website is to
save the millions of hours that we all
wasted trying to understand if our
systems are rest or not and if we can
have the stamp of approval of the term
rest so I'd like to reverse that and I'm
going to stop talking about rest from
now on I'm just going to talk about
features that we want in our
applications or features that we could
have and we may not be knowing the
possibilities of so we're going to talk
about features and of course also being
an Agilent with a small eight because no
certification I i've wrote a bunch of
user stories right so in order to stop
reinventing the wheel sorry devs might
not be an idea not invented here
syndrome I want to use my existing
knowledge tools and libraries right how
many of you have written your own TCP
stack how many of you have written your
own HTTP clients how many of you have
ported your HTTP client OC to be two
there you go the costs are increasing so
much and it's so cool to reuse something
that kind of works some of the time and
that's generic processing it's called a
network effect the more adopted a
technology is the more software we have
to do cool stuff with and so we should
probably stop trying to reveal
systematically stuff because it saves
time saves money and knowledge gets
spread and everybody understand at least
some of this stuff that it is in HTTP
and that's of course in contrast with
the old RPG approach the old RPC
approach has an interface that you
interact with that is specific to the
application you're using and so if I
want to call get customer I generate my
little
proxy from some wisdom file back in the
days
people do that now with a swagger urban
API and I call a specific remote
procedure that usually has a fixed
format just like Web Services did so
then these systems evolve and then you
get customer to get customers 3 then you
start having code of gateways with
thousands of lines of code just passing
stuff along and of course if I go to
another application in another business
and another team there's another dead
customer and it's not quite the same one
and I need to have another piece of
information in it right that makes sense
we've seen that ok in HTTP the way we
access information is always the same
one right we have a request we have a
method some people call that a verb term
from the 90s and and we can access any
of the services we have over the same
protocol using the same semantics and it
doesn't matter how people have built it
behind because we have one HTTP client
and that's called the uniform
intervation
uniform interface which is part of the
rest and part of a whole bunch of other
architectures allow us to leverage our
existing knowledge of HTTP and I were
existing tooling so that we can do calls
to servers using exactly the same
semantics now of course you can still do
our PC over HTTP but I think you don't
have to implement your own network stack
and of course that allows you to
leverage tooling every single service
you want to diagnose you can use the dev
tools you can use fiddler you can use
Chandler you can use Wireshark and it
will show you the HTTP and even if you
don't know that service because it's
self descriptive there's enough
information
for you to understand roughly what is
going on unless of course you use an RPC
system in which case nothing makes sense
but who would be crazy enough to still
do this stuff I'm not talking about any
technology in particular that claims to
replace rest and so we want to leverage
HTTP but the next step of course is to
leverage the format's that already exist
again because I can build tooling across
various services that don't implement
the same thing at all but have the same
semantics for some stuff and here is the
home document it's one of the
specifications that can have a lot of
interest for developers I want to
document how you go on my read six
application as you can imagine I may get
in trouble for the trademark but it's
obviously a funny comedy reference so
the copyright laws should accept that
fingers crossed and and so this document
is the way that the first time you hit
an API you want to know where my movie
list is so I built a movie browser that
wants to show me a bunch of movies and
they cover and I don't want I want to
know where that movie list is because
actually my restful experience can go to
multiple services just imagine if you
can have one browser for all the places
that sell you movies it would be a
revolution but that will never happen
and but in theory you reuse the same
document and the movie list is the thing
that your heart codes this is your level
of coupling you say I'm looking for
movie lists you'll notice it's a URI but
that's just because we use your eyes as
identifiers so you encode just the name
of the thing you're looking for in your
code you bake it you ship it and when
you access the system you go to the home
document and you find the URL so that
everyone that implements that can put
the movie list
anywhere they want on any server at any
URI why do we do that well we do that of
course because we can start coding stuff
that we can reuse across all the
services that we use some review lists
some customer service system your own
little toy project at home and it's the
same code and that allows me to discover
links in an application whatever the
application actually does which i think
is pretty cool I'll show you another
example how many of you have seen in
api's custom errors declared in Jason
right I mean you try to do something and
it returns you of formats telling you
more or less what happens right github
does that everybody does that and each
and every single one of them is
different and again that means that I
have to code for each of my services a
different way of viewing and handling
errors so we have a problem details
specification now again which allows any
service that I use to declare what
happened so for example in my risk link
on flash things again this is just a
name it's not something that you go to
is just a name it could be a string of
could be any URL and some of these
things are specified for every single
error and then I can expand a little bit
of things by putting a balance that you
have and I charge 50 rest box my local
money the only one that doesn't vary on
the market for no one uses it but it
allows you to write code like that
instead of caching and this is they
should be this should be readable by
most developers that are used to see all
the C derivative languages that our
industry keeps on inflicting on us
I can I can now have a layer above just
having an HTTP exception right all
reading a 500 and then going to the
github documentation try to understand
what
problem was I can now model for all my
api's in a generic fashion put it into a
package or allow everybody to be in
versioning hell as they use your stuff
but here I'm going to have a problem
exception and I can have the type so
that I can actually start handling
errors that I exceptional other of
course this is a very bad example
because people running out of money is
not exactly an exceptional circumstance
once we have a uniform interface the
advantage we can start we can start
intercepting stuff and making
intelligent actions and decisions on it
so for example instead of littering your
code with loads of logs and implementing
or logging framework and all the stuff
that we have to do in certain
applications well you can actually just
return HTTP and we have a an
intermediary here a little proxy that
will read the 500 error and because it's
a standard media type it can log exactly
what happened and it knows where to put
it and it knows who to alert because you
could extend the problem document saying
please call someone at 3:00 in the
morning
to tell them that someone ran out of
money and I can love to Filan the
advantage of course of that is I can I
can write a hundred of services they and
they can all go behind that thing I
don't need to rewrite it all the time I
don't need to read the code it even runs
in another process and in different part
of the network and the last thing of
course is one can be written in go for
performance and the other one can be
written in web forms if you want if you
want to process things very slowly and
of course we already know layering - all
right we already know layers we use them
all over the web anyone have any idea of
the kind of intermediaries that we use
no one
load balancers proxies reverse proxies
CBN's and as I showed your own in your
infrastructure for example for logging
any orthogonal concern that is not
related to your domain can be
implemented generally across all teams
across all domains and what is
interesting is that the majority of web
frameworks and the majority of languages
have adopted and embraced that layering
because you find middleware than a lot
of technologies you found them in HP
dotnet core
you find them in nodes you find them in
open roster you find them everywhere and
again it's because you want to have also
a little concerns with generic
processing over time the next thing we
want to do is to be able to update our
software and we want we don't want to go
and version our remote procedure call
with a 2/3 X or whatever we don't want
to try to do come if anyone remembers
the beauty of versioning income so in
order to allow independent developments
of clients and server applications so
that you don't have to rewrite your
client every time you extend your server
or change anything so you can do half of
the work release and do the other half
of the work having dependents clients
for multiple languages and platforms how
many of you are using at least two
languages in anything you use everyone
right unless you don't do web
development or don't do JavaScript so we
end up having multiple languages
multiple applications and I want to be
able to evolve those independently
because I can't have a client's team
responsible for building all the clients
I mean I could but it's very inefficient
and it doesn't work across domains very
well and I want to evolve my server
applications without breaking customers
we don't break
because if we just want to fix a typo in
our media type for obsessive-compulsive
reasons mostly I'm not sure your
customers are going to be very happy
when you break absolutely every single
one of their systems at peak traffic
time which is always somewhere in the
world so we don't break customers
because we like making money and if you
break them they don't make they don't
give you money or rest box for my
customers
as I said I'm not very good at making
money so in order to do all these things
I want to build an API that can evolve
and so in the past once we had linking
people started documenting this kind of
thing I apologize for my writing I
should have been a doctor unfortunately
too many years of studying so I have my
little client here and I do what people
recommend I have URI template for people
that have not seen that we have little
variables in curly braces and when we
want to access a movie by title in the
client we automatically put the movie
title where the little brackets tell me
to most api's are described like that
even the good API for this grab like
that and so this is what you encode in
your clients you deliver it you ship it
you put the nougat package and then
that's that stuff exists for hundreds of
years because a lot of people don't
update their packages regularly right
anyone to keep on supporting them
because as I said you don't want to
break them
so my refseqs 1.0 works people are happy
they're buying my movies I'm making a
profit finally and then I see breadstix
2.0 and I just fixed a thing I didn't
like with my you are eyes unfortunately
I don't control the client because it
might be the team next door which
doesn't like me or they're in another
building in another country
I don't know which one is more probable
so that makes people unhappy so we
started talking about hypermedia in a
dynamic way instead of sharing the
knowledge out of bands and including it
in our clients we discover those links
dynamically invent I go to the service
the service gives me links and from
those names I can navigate what else
does that what technology does that the
browser write HTML has been doing that
for ages so model we understand and
somehow when we go to applications we
don't do the same thing because why not
reinvent the wheel and I don't like
reinventing the wheel so when we talk
about machine to machine scenarios and
when we talk about API development with
the atrocities at SPS are we use links
that need to be discoverable so when you
are a human being and you're in HTML you
have an intent to go to the website to
do something and then you look at all
the links and you try to find the one
that can do what you want so I'm in my
movie list I click on the movie I'm on
the movie page I want to order I click
on the order button machine-to-machine
scenarios are going to use the same
concepts you need to encode where to go
based on my intent the thing you're
going to bind to a button I want to edit
the details of a movie and we use a
relationship for that which is part of
the web platform I have my movie for
terminator and I want to edit it because
someone says the movie was great and I
wanted to download to downgraded to
about ok or worse and that relationship
is going to be one of editor because the
relationship between the two I have a
movie and I have an editor for the movie
and so I describe those links and we can
do those links using plenty of new media
sites like how as I say the hypertext
education language maybe I don't know
and this is a way to format your
documents again in a standard fashion
across all your domains across all your
API and we have a little on the school
link that you can add to any document
you return not going to give me a rel of
editor a relationship of editor and then
the actual URI where I can find it and
now I can discover each of my each of my
links as I navigate the application so I
hard-coded less stuff in my clients I
have more flexibility in evolving my my
server and this is at the document level
right the HTTP is above a wonder that
depending on how you draw things but we
have the same technology that is even
more generic and that's the link header
that's existed for a very long time
actually since HTTP is your point nine
and then it disappeared and it's
reappeared now and the link is going to
do the same thing is going to say that
your eyes actually own editor so if
you're looking for an editor here's
where you can find it and by the way
here's my new personal HTML version
called wobble wobble wobble I don't know
why I thought it might be funny below I
think I that boat okay so I don't know
you know sometimes you get it wrong and
so that's great we can discover stuff
dynamically but really if you look at
how the browser works the browser which
doesn't does not need to be updated ever
she don't want to and see a same if I
can link still work on most websites
except for the SP a I'm not going to
swear we can start building one step
further instead of just decide or
discovering where we go we can even
decide and discover how to build the
requests so I have a level of
indirection to find where to go and now
I can also have so this is siren it's
another format and you will see that it
has a bunch of actions
and those actions allow me to have an
encoding in my application for loader
movie and that's the only thing our
builds in my clients and I have a bunch
of fields just like an HTML so for
example here I can have a hidden value
of 50 for the price that's why I ship so
that the clients when it builds its
request can sense that along we've all
done that until people try to build
events on top of HTML which didn't pan
out I'm looking at you web forms they
know they're not the only ones it was
cool at the time but we thought it was
cool at the time so you can have a bunch
of hidden values and you can also have a
bunch of text and so when the client
receives its form its blindly Maps all
the information it knows about to
whichever format it was requested to do
so we can read and write to the web
dynamically like a browser using an HTTP
clients that you need to write once for
the rest of your life until we break the
specs which I don't think will happen ok
so now we have a dynamic system we have
to update the clients less often we
don't break people we can make money we
are very happy are you happy no one is
happy very grumpy audience the next step
of course is to get our system scalable
in order to scale my application
horizontally I want to deploy more and
more stuff up because I know the rest X
is going to be an international success
I want my server to function
autonomously and independently if my
servers have to share state I am limited
to the scalability of the C that they
share stayed with how many of you run
sequel server Wow
I'm sure the numbers will go that
eventually how expensive is it to scale
sequel server those machines cost money
a lot of money it's big machines and the
more clusters you add the more the cap
theorem applies the harder it is to
scale the more expensive it is to scale
and then you realize that each of your
web servers are becoming less and less
useful because convention happens
somewhere else
Soto numbers components exist for the
sole purpose of having independent
systems that do not rely on sharing
space continuously and having one source
of data they are self-contained they
communicate with the rest of the world
and those exist and have existed for a
very long time they used to be called
autonomous components and then as we saw
with rest
people like coining terms so where do we
get now they call it micro services
because it's the new thing right but
micro services are now server less where
you are absolutely stateless when you go
back to the same persistence medium so
we're back to square one so really if
you've adopted all the stuff that we've
seen right in the web when I order
something I go back to a credit card
system that does not interact that does
not share a common data store with my
application it would be against a whole
bunch of certifications it would be a
security nightmare so instead we have
independent services that just
communicate over a network protocol and
that's it so really we're not talking
about micro services we're talking about
micro resources because that's why we
just built a really when we talk about
micro resources there's nothing micro
about resources they all just resources
they just stuff that we build over HTTP
we've built over HTTP for 25 years
so we pretty much should understand how
it works and the web just like your
application can scale better if you
don't go and retrieve stuff all the time
when you don't need to and caching is a
very efficient way to do that right in
order to interact with my application
efficiently
I want to avoid retrieving things over
and over again how many of you have
built their own cache how many of you
use an application layer cache alright
so you know about caching caching is
good caching helps and yet you use four
or five different caches in each of your
applications because every single vendor
like building plenty of caches a little
bit everywhere with slightly different
API and all of them having different
ways of expressing caching in HTTP on
the web right now and for the last
twenty five years that's not true the
last 17 years now we've needed a bunch
of stuff to cache documents and that's
not just the web right we need to
identify the document we will not we
need to cache we need to be able to
refer to it back so that we can retrieve
it from the cache so maybe you use your
internal IDs maybe you use grids maybe
you have a URL for your document and the
grid which is crazy if you consider that
URI means Uniform Resource identifier so
we have IDs that we slap another one
because why not fair enough so we
already have a way to uniformly across
the whole internet across all your
applications all your services all your
domains a unique way to identify
everything and anything that has a URI
is a resource we also need to know how
long to cache stuff right if I'm serving
you a picture of Schwarzenegger from
Terminator the movie well that picture
is not going to change
that pictures are we doing to stay the
same so I can cash it for however long I
want right but we also need to know how
to remove stuff from the cache maybe we
posted a picture that is illegal to post
because we broke copyright law I don't
know you caught Streisand ago half-naked
in a somewhere I don't know a picture
you need to take down so you need to
remove that from the cache and so you
need a way to invalidate this stuff or
you updated the Terminator movie file
and you now say that that movie is
actually pretty bad when you consider
all the other ones and so you want to
invalidate the cache which you have
dated a movie and then the browser still
see the old version and that's not very
useful so as most of you use caches and
you've implemented your own or you use
half base stuff that is based on objects
and your grids we recommend not to build
your own cache because doing it right
it's pretty complicated and as you know
there are two things in computers in
computer science and in development that
are difficult naming things cache
invalidation and errors that are off by
one got it okay so how do we control the
cache so this is really old technology
everybody should be aware of labs we
have a cache control we can say freeze
your document out I'm allowing everybody
to go to cache this stuff you can use
this wherever you want however you want
for 3600 seconds and I can invalidate
the cache with new technology as well
this is called the invalidation through
links so how many of you use results sub
resources in your api's no one one
person
there is no such thing as sub-resources
people call it that because on your
server you say well you know there's an
editor for my movie but if I delete my
editor if I did it my movie obviously
the editor should be deleted as well and
because it's slash movie slash
Terminator slash editor people assume
that there is such a thing as an
implicit relationship between the two
which is absolutely not how stuff works
they're two completely independent
things and an absolutely no way to know
that one that gets deleted should mean
that the other one gets deleted no one
looks at slash terminator and decides
that anything that starts with that gets
deleted that would be crazy that's why
it's not imperative that way so there
are links this is a proposal I think
it's implemented in some caching
software that allows you to say well
I've just deleted Star Wars part one
because really I should not be on sale
or having ever been produced I'm sure
you agree and so ideally that movie
completely I want to stop selling it
because I feel very bad about making
money while people watch a terrible
movie and so when it returns 200 okay
it's happy that is deleted stuff and it
tells me by the way you can also
invalidate the cash for the editor
because that will not be available
anymore we're removing this as well and
they use a relationship or invalidates
which makes everybody happy
the next thing of course is that I want
to serve my movies and some product
vendors will tell you that rest only
serve one thing at a time and as such
it's very inefficient and it's the end
of the world and it's unusable and of
course they're still true because there
is no silver bullet but we have a way to
manage collections collection being my
list of movies about I have a whole
bunch of movies and I want to retrieve
those movies efficiently so first I can
describe them manually like this I can
create my own custom Jason that
doesn't reuse anything that needs this
so that's on top of writing custom code
I have to write a documentation myself
who likes writing documentation who's
good at writing documentation alright
anyone is good at writing documentation
please join my open-source project
everybody will be thankful for that but
then again I don't have users so it's
not a problem that's not entirely true
and so I can build my own stuff but
again we have the same problem I've been
hammering about and you must be sick of
hearing it but you really don't want to
have to re-implement collections of a
single one of your domains every single
one of your servers every single one of
your applications every single one of
your teams that was a lot of lot of
breathing so of course they are formats
that allow you to reuse stuff for
example collection plus Jason fantastic
middle format and it describes the
collection it describes a bunch of stuff
now I has a version identifier which I'm
not entirely happy with but it's not my
spec and it tells you that the list of
movies has a bunch of movies that has
Terminator Terminator 2 and if you read
that then you know that there are two
things that you could try to get
information about of course I could
embed all the details and the
description and do a sub resource but
what would happen with caching if I
embed the information about the
Terminator inside my collection what
happens when I go to the actual URL of
the Terminator it is cached who thinks
it's cached who think it's not cached
who doesn't think ok so of course it's
not cached because if you embed stuff
into one resource the other ones are not
visible so you don't have good caches so
you can probably not do that for
efficiency because we have other ways to
do it
so if I take this of course there is no
detail so I need to go and retrieve
each of them to have my details which
might be a little painful if I'm
retrieving thousands of movies in my
catalog so this is another cool
technology that is implemented in
browsers and everywhere else I can say
when I return you the list of movies
that you should probably as soon as you
receive the headers and beliefs on the
list you should put you should start
downloading all this stuff very very
very quickly because I'm going to need
them and so you put in the
infrastructure the capacity to fill your
cash in advance so that your code can
look at the list and then do HTTP
requests for each of the items as if you
were doing over the network but you
would using your using the cache you
never leave your machine and caches are
pretty fast because even if you're using
dotnet you still use the HTTP cache of
the platform and as we know vendors try
to optimize their software if the cache
for the browser was slow you would hate
them and they're really trying to reduce
the amount of time it takes to download
in view cats being cute images which is
90 percent of the traffic on the
Internet
so you'll see that this link
relationship has the name preload and of
course it has to have a relationship
between that link that you're pre
loading and the current document and
here we have the as which replace the
link so I'm describing that Terminator
is an item it's part of a collection and
so I can start downloading because my
current resource is a collection I can
start downloading each of the items in
advance and you code it once in your
HTTP client and actually if you're using
the browser it will do it for you you
don't have anything to do and if you are
not native on the drive are in other
frameworks you build once the code that
will do this and start using the cache
efficiently but we steal
want to get a little bit more
performance out of all this because
after all all these competing formats
that declare res dead tell you that res
can not perform well for those scenarios
because of all those requests because I
need to go and download each of the
items independently and while I can load
the cache while I try to process the
information it still needs to do a whole
bunch of requests right and in HTTP 1.1
we don't do that we have plenty of
servers with different DNS we ship all
the images in CSS in big grids right
who's doing that in CSS there's a term
for it can someone tell me what it is
huh tiling and we do minifying on our
documents and we do bundling we do all
these stuff which is just mechanical
crap but you have to do to have a quick
page loading so of course I want to
increase my performance without having
to do all this code that tries to
optimize a broken protocol and keep
things simple because simple is harder
to bugger so in order to respond faster
to my clients and look like I have a
really cool API I want to increase the
performance of my application and so
this problem of doing many many many
many requests in HTTP one is due to the
way the protocol is implemented you go
and do a request you have to wait until
the response comes back in the case of
my collection I need to wait until I
retrieve the collection before I can
read each of the items it's not entirely
true because that's per connection and
we open six in the browser but we still
have six things waiting continuously on
the response before during the next
request let's say CB 1.1 but actually
the HTTP 1.1 of a feature that mobile
devices tend to implement and browsers
have not been too keen on implementing
and it's called pipelining
so it's a safe HTTP methods the browser
can send 12 requests for example from my
link headers for all the items and
sender 12 requests in one go and then it
will receive the 12 responses in one go
you can only do it full get another safe
HTTP methods but at least you know you
don't have to wait until the next one
arrives before sending the first one but
there's still an issue with this there's
still an issue with this until let's
just imagine that the first response
take a lot of time what happens to the
second response hmm it will wait because
you have a head of queue problem I send
the first one but my server is stuck and
could not send the second one because
the first one has not finished
transferring on that connection and so
we now have the solution to all this
stuff
in HTTP - who's using HTTP - one person
now that's that's about right but it's a
really really really really cool
technology I was lucky enough to spend
some time with the IETF guys and the
implementers and the people from Chrome
Mozilla Apple H a proxy really really
smart people
I felt very stupid I usually feel very
stupid but this was really up three
nodes and they may investing huge amount
of money and one of the things that
they're doing with HTTP - is
multiplexing you can now send as many
requests as you want in any order you
want and the server will respond in any
order at once as soon as it can and so
the head of queue problem the head of
line problem that we have in HTTP 1.1
pipelining goes away it completely goes
away that's a very efficient way to
transfer information and on top of that
all this stuff is over one TCP
connection
everything that happens to a server is
through one TCP connection because of
multiplexing we can have parallel
requests just like we did with six
connections or the one connection and
they didn't stop there of course because
they want to make it as performant as
possible so they did HTTP binary they
made HTTP binary now of course that
means you can tell you can't tell net
from a terminal anymore with your VT
hundred terminal from IBM you know this
big big machine with mechanical keyboard
anyone remembers that yeah so for the
young ones with young good is a is this
thing you should check on Wikipedia M so
they made the protocol binary which
means it's very very fast and of course
everybody should use curl or W gets to
inspect stuff of course but that means
there's much less stuff happening on the
wire it's much more efficient but of
course they didn't stop there all the
HTTP headers always the same ones over
every single one and requests and
responses so they lost lots of bytes
being wasted on the connection there's
some statistics I saw but I can't
remember the percentage we'll just
assume that it's ten percent of the data
traffic is actually just plumbing for
HTTP check the number online I have no
idea but there is a significant amount
of space for small requests which we
want to we really want people to do
splendor of small requests but
increasing costs with all these headers
so they created h-back which is a way to
compress and gzip or it's a custom
protocol that is safe and secure that
compresses per connection a whole bunch
of information that is repeated in HTTP
so of course there's value formats I
talked about it but the wonderful thing
about this multiplexing is that as you
may know TCP stacks in operating systems
when you open a TCP connection starts by
going pretty slowly right if you look at
your brighting system and the network
graph and you start downloading a file
everybody should see that it's
a little bit slow then it starts in
freezing the capacity to transfer
information the more you download anyone
has seen that before yes people see that
if you issue in a Radisson Blu Hotel and
the internet is terrible so that's
called that's because of the TCP window
the sensitive mechanics that are not
interesting for this talk but it means
that the longer you keep the connection
open and the more you use it the faster
it becomes and because multiplexing up
in server 1 TCP connection you get the
maximum bandwidth that you can for the
server really really performance system
compares to some technologies I'll sit
and text over one single endpoint over
HTTP I really have nothing against that
technology good a little bit but that's
not just enough as we've seen we've done
the prefetch but I still need to wait
until the whole response has been sent
to start loading stuff right
I send my collection that has all my
links but I will not be able to read the
links until the server has actually
retrieved the information from the
database I do my gear to go to the
database retrieve stuff I have to wait
until it comes back to start prefetching
in the browser but I can be smart about
this as a new thing as well called
sending links early so once they have an
RFC that describes things clearly so
that's great and it's the one with three
status so you probably know the expect
100 temporary response when you try to
upload a file instead of waiting until
you're transferred for gigs to tell you
you're not allowed it actually tells you
I expect to get a 100 so that you can
cancel before you start transferring
stuff and so you really get two
responses that's implemented everywhere
will the servers or the clients they
implement that one or three is the same
principle I do my get the server happy
to go to the database and wait but I can
respond immediately with partial headers
for that response I can start to tell
the system I've seen this stuff before
you
I need all this you're gonna eat all
those eggs probably so try to download
them with whatever bandwidth you have
available so we really maximize the
usage of the tube and then when the
database comes back I can return the
document and so you can go even faster
and with fifteen two minutes in so we
are at the last slide which is pretty
cool for me because that means I can
stop talking and we're not stopping
there and when I say we I say they
there's a whole bunch of other stuff
coming that's really exciting that is
allowing thanks to the browser's your
smart clients and your codes is going to
get a faster better more efficient
people are abandoning TCP well
abandoning their building on top of UDP
the HTTP 2 protocol which means you'll
go even faster than trying to maintain
your TCP connection you'll be able to
maximize massively how your connection
works as far linking is support we're
going to have with Hydra which is a
specification using json-ld which is a
hyper media format just like all the
ones I showed you
a little bit more complicated but
solving a whole bunch of other scenarios
we're going to approach the capacity to
write semantically correct
understandable completely generic
clients that will be able to be
completely flexible which means you'll
be able to update your clients much less
and you'll be able to keep all those
horrible JavaScript clients without
having to touch them if you have such
things which I'm sure you don't because
you're all great developers that love
great languages written Internet in 10
days so generic lines are happening and
of course it wouldn't be me if I didn't
start announcing stuff that may or may
not happen but due to all these
technologies combining together and not
being available
all in.net very well and I think we
really have a very poor story on the
client and on the server run hypermedia
in generic terms I've restarted open
raster with the help of some of the
customers that are using it and are very
happy with it
so expect to see me renting moaning and
demoing and talking and blogging about
it in the next couple of months I will
take any questions if anyone have
questions we have six minutes yes so the
question is if you screw up the link
headers that fill the cache then you
could screw up the data access plan on
your mobile which is very true but the
browsers are intelligent enough to
prioritize they don't have to follow the
preload they do it if they have spare
bandwidth and usually they would detect
the kind of network they're on and
probably try not to preload them if
you're on Wi-Fi I don't know that I can
probably ask the Safari guys if they use
that and I can probably try to figure
out what browsers people on Android use
it's and I'm not entirely sure of all
Samsung which have their own browser now
I'm sure they implement something like
that because you're absolutely right if
you start sending them gigs of data
they're not going to be very happy plus
I need them to have data access plan
gigs left over so they can watch the
movies able any other questions No okay
so this is the last slide there will be
as usual for my talks there will be this
URL that you will be able to go to have
all the links of all the specifications
I talked about as I start blogging about
some of those subjects you will have all
the links on that as well we were
attending else know if you want to tweet
about this please do use the hashtag rs3
I
all feedback on my talks if you have any
feedbacks you can just hashtag I will
read everything and if they're nice I'll
retweet them and if you wanting to have
more personal feedback please feel free
to tweet me I would really appreciate it
my website has a huge amount of content
going back since 2003 so don't judge me
- hardly I was young once a book from
the time I was Sebastian Amla and thank
you very much for attending red soup or
now</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>