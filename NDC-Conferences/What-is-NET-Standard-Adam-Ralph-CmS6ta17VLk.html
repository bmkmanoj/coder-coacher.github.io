<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What is .NET Standard? - Adam Ralph | Coder Coacher - Coaching Coders</title><meta content="What is .NET Standard? - Adam Ralph - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>What is .NET Standard? - Adam Ralph</b></h2><h5 class="post__date">2018-02-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CmS6ta17VLk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right hi everyone ready for the last
session of the day my name is Adam Ralph
I originally come from the UK just
outside London these days I live in
Switzerland I've been living in
Switzerland time and I work for a
company called particular software we
are the makers of n service bus start of
shameless plug if you're interested in
our service bus do go and have a look at
some really cool monitoring stuff we're
doing around monitoring of endpoints
that's the end of the shameless plug
I'm not going to talk much more about
our particular software apart from one
thing we are a 100% remote working
company so everyone works at home even
the sea we do not have an office
anywhere and I decided to take advantage
of that and buy one of these and I spent
the whole of the summer traveling around
in this thing this was my office and my
home my girlfriend also also works
remotely now if you're more interested
in that I am going to be doing a talk
about this called code on the road so
look at the count for that if you're
more interested in that at some events
later this year I look after if you get
packages some of the more interesting
one interesting ones are fake it easy
which is a mocking framework that
supports botnets down at 1.6 light guard
is a guard clause library I'm sure
you've all seen heard of those so you
can write guard against null argument
that kind of thing in your methods names
I think it's going to be redundancy
sharp aid with the with the Opera t
nullable reference type thing so I'll be
quite happy to put that to bed but
anyway for now it supports dotnet
standard 1x behave net is an X unit
extension for writing test using natural
language that supports the next and at
one point one and n service bus rabbitmq
the current beta which is RC any day now
and we do run proper our sees it's not
like the dotnet core one our circuit
stuff if any of you remember that and
the RC will be the RTM if there are no
bugs that supports dotnet standard - so
what is this dotnet standard malarkey
but I love speaking in the UK because I
can use words like malarkey and you can
most of you understand what I mean
sorry if you don't it just means stuff
so don't let standard let's look at the
problem it's trying to solve so in the
early days we had the dotnet framework
so you compiled against the dotnet
framework you ran against the dotnet
framework and mono was a cross-platform
implementation of that and still is and
that allowed you to run a Windows server
and using mono Mac and Linux anyone here
used much mono much I see like two hands
going up so yeah it's it's not something
which is used very heavily and I think
realistic you'll get your kind of
mileage varied a little bit as to how
well it worked but mono went on to
become something else then dotnet core
came along and that allows us to run
Windows something to run dotnet on
things like Windows Windows Server Linux
Mac and Tizen does anyone know what
Tizen is anyone yes
you've got to shout it out
correct correct it's an operating system
by Samsung 4 it's a mobile operating
system but they put it in all kinds of
devices like fridges and smartwatches
and TVs and that kind of thing and it's
yet another place it's Linux based but
is it is yet another place where you can
actually run dotnet core and then we've
got xamarin iOS and xamarin mac this is
what mano actually spawned mono cat kind
of became went onto to spawn these
projects that allows us to run dotnet on
iPhone iPad and Mac when you want a GUI
samer and Android kind of just runs and
all kinds of different things these days
so all the things and UWP none of the
things no no I'm being mean now it does
run on a few things so the point is that
the gone are the days have just a dotnet
framework we want to run we actually now
have the ability to run dotnet on all
kinds of different platforms via all
these new runtimes that are coming out
of the woodwork so when you write a
typical dotnet app it's not long before
you bring in some kind of NuGet package
right it's a it's an unusual app that
doesn't use some kind of external
library via and usually these days where
I knew get packaged so as a producer of
a nougat package and obviously as a
consumer you want to be able to use
those NuGet packages in potentially any
of these platforms in the early days
people only really built the dotnet
framework these days people want to be
able to use NuGet packages from the
gallery in potentially any of these now
there was a solution for this previously
called portable class libraries does
anyone know about portable class
libraries yeah a few of you heard of
them so portable class flavors were
designed to solve this problem
unfortunately it became kind of the
portable class library fiasco in the end
it sounds a little bit harsh but bear
with me so in the beginning as I said we
had dotnet framework for all right
things are very simple and then this
thing came along
Silverlight 5
are you smiling about so late it's great
what you have to sport it lucky you I
actually miss spelt this when I wrote
the slider it's sliver light five but I
think it has a kind of ring to it so
I'll call it sliver light five for today
there's an intersection between the API
is that are available between net
framework 4 and silverlight 5 right
there is some stuff which is common to
them system object being the most
obvious right with the same methods and
properties so the idea was well why
don't we define a thing that you can
compile against which defines the
cross-section of these two frameworks
and that was called the portable class
library profile 14 if anyone knows what
that 14 means please let me know I have
no idea but anyway it was called profile
14 it defines the the overlap between
these two frameworks now this is great
because you can now compile against a
set of reference assemblies called PCL
profile 14 and then that assembly which
you compile you can pick up and run
against either of these two platforms we
can then introduce another platform into
the mix dotnet core 4.5 anyone remember
that that was a thing if you're
interested in dotnet version numbers
come to pub come up tomorrow because
Mark Rendell's going to be doing a talk
about dotnet version numbers so all will
be revealed but anyway there was a thing
called dotnet called for core 4.5 and
the Indus and the intersection or rather
that the bit that exists in all of these
all three became profiles profiles 37
and there's a there's there are some
stuff that only exists in dotnet
framework 4 and 5 so I've labeled that
there with the profile 14 and there's
some stuff which only exists and that
come in in the overlap of these two
right and that's profile 5 up there
there didn't happen to be a profile
released between which covered donít
call 4.5 and silverlight 5 i don't know
why but they didn't actually fill in all
those
gabs so far so good then we introduce a
force platform to the mix which is
Windows Phone 8 now there is a
fundamental problem with this diagram
can anyone spot it I can't understand it
that's the main problem with it yes and
there's a one little technical problem
which I'm a little bit embarrassed about
because I did maths at university so I
should know this stuff but there is
nowhere for me to put a label on for
profile 14 for the intersection with
only Silverlight 5 and dotnet for I
can't put it anywhere on that diagram
and it turns out I'll go back a slide so
it turns out that this is a Venn diagram
alright and a Venn diagram describes it
actually shows all the intersections of
all the sets on the diagram Venn
diagrams were described by a British
mathematician called John Venn in the
19th century it turns out that this
isn't a Venn diagram this is actually
what's called an Euler diagram which was
described by Swiss mathematician called
Leonard Euler in the 18th century and an
Euler diagram only shows some of the
intersections of of all the sets in the
diagram so I googled for a fourth set
Venn diagram and I found a so that's
that that's another example of a Venn
diagram by the way so I guess most of
you here probably from the UK so when we
kind of described the layout of the of
the British Isles and Ireland everything
all we have to do is verbalize this very
simple diagram and and we can we can we
can tell people from elsewhere what it's
all about so it turns out that so yes
this is not a Venn diagram this is a
Venn diagram right this is a four-set
Venn diagram and applying our profiles
back to this we found a place for
profile 5 we found a place for profile
14 right that was a problem ok and we've
got this new one here coming out called
proform on three six all right so that's
for now if you look at the list of all
the PC ELLs that are available it goes
further than four
this one has one two one two three four
five and of course it's not possible to
draw a five-set Venn diagram or so I
thought this is a five-set Venn diagram
when you wants five sets you have to
kind of use this weird I don't know what
to call it really Frankfort or in kind
of it was sabe bread roll or something
but that is a five site and you can go
you can get silly with this right you
can go six set Venn diagram you can go
seven set Venn diagram and in 2011 a
guy's a bunch of people from the
University of Victoria in in BC in
Canada
drew that for the first time ever an 11
set Venn diagram getting quite nice now
and applying our profiles to this I
think the the problem you called out
Brian is really becoming apparent now we
cannot understand this anymore
I made that profile number up it's just
good as any other so this is why I'm
saying portable class library Fiasco
right this doesn't not work anymore
and it's a bit harsh because the it was
when intentioned and given the same
problem back then I may have come up
with the same solution myself but with
all these new platforms appearing it
soon became clear that this was not
going to scale because every time you
add a new platform you potentially
double the amount of profiles right it
just it just spirals out of control so
we needed a new solution for this and I
did pour myself a glass of water before
a bit of stolen and the solution is of
course dotnet standard do you like that
logo I submitted this as a logo but I
got knocked back though I'll try again
alright what is that net standard so
don't their standard tries to do this
right instead of trying to take the the
intersection of all these of all these
sets and trying to cut it and try to
come up with some really kind of
complicated scheme and what it does is
it looks at the intersection of all of
these platforms so there's there's a
place here where all of these overlap
and there's a whole bunch of api's which
exist in all these platforms and don't
let standard takes the biggest
intersection of those that it possibly
can so for one set of versions of all
these platforms there is just one dotnet
standard you only have to target one
thing on that standard you don't have to
choose between profile this and profile
that and profile that it's actually it
was really difficult to know what which
profile to choose back then you know do
I choose one do I choose many is really
complicated this makes it much easier
and the way that the versions of.net
standard it's self work like this so
each one is a superset of the one before
so we've got dot next and one in the
middle we've got dot lesson and one put
one a little bit bigger a little bit
bigger little bit bigger until we get
two knocked on that standard to which
was in fact much bigger than nest and a
1.6 bit more on that in a minute what
this means in terms of platforms is this
so for a given sorry for a given version
of.net standard these are the versions
of all these platforms that it supports
oh yeah versions this is some really big
version number it's like 10.0 point one
six two nine nine and when I wrote it in
it expanded these columns and maybe look
horrible so I just wrote versions silly
it's a silly version number I don't know
why it's not just 10.1 or 11 or
something now the implication of this is
that when you when you target a given
version as compared to targeting another
version OHSO 1.0 this is one point one
point one if we target 1.0 your library
has the biggest set of compatibility
with the platform so you can use your
you can use your library on all of these
platforms including Windows Phone
Silverlight as you go along towards the
right so if I decide to Stargate dotnet
1.1 instead of 1.0
I lose support for Windows Phone
Silverlight I'm sure that's going to be
a problem for too many people but the
way these version numbers is in some way
a little bit counterintuitive because as
developers we like the new shiny right
so ODOT net standard - I should target
that that's the best in a way yes it
gives you a lot of api's but the problem
is if you target dotnet standard - you
can know your your package can no longer
be used on these older versions of the
libraries now if you go between dotnet
standard one one 1.2 you kind of start
to lose support for these old Windows
Phone 8 and Windows Phone Silverlight
things doesn't really matter too much
right they're kind of they're kind of
dying if they were really truly alive to
start with but when you go from 1.2 to
1.3 you drop support for dotnet 4.5
right I would hope that most people are
and 4.6 these days but I know it's like
working a big company we get held back
we get held back on old frameworks so
moving from dotnet standard 1.2 to 1.3
just you know that's an example of where
you might suddenly cut out a bunch of
users now just because a package targets
dotnet standard doesn't mean we can't
multi target anymore right so you could
choose to support dotnet standard - and
 a dotnet framework 4.5 assembly in
the same package so you keep supporting
the - in that way but I spoke to one
person he told me that when he creates
new library he's first of all targets
don't nest own at one and tries to write
the things he wants to do when he finds
that there's an API he needs which
doesn't exist in one he goes to one
point one to see if it exists there and
so forth and so forth so in many ways it
can be a good idea to always target one
to start with now this this there's a
kind of shift sliding-window relevance
here because obviously as time goes by
this older stuff is going to become less
and less relevant you know but I still
think that if you can just target one we
know why not because and you can be you
your platform your library can be used
everywhere a little no one's got that
standard too so the original intention
was for dotnet standard to support
semver in its versioning what that means
is that 2.0 you Rev your major version
when you make breaking change and
originally dotnet standard 2 was going
to be a breaking change originally it
was going to actually cut out some ap
eyes which were in 1.6 at 1.5 and when
this was kind of announced the community
kind of threw its toys out of the pram
and complained about this and a lot of
feedback was given and listened to and
the decision was made no we'll make it
back as compatible will actually make it
a superset in the end however so what
this means is that dotnet standard 2
only really needed to be called 1.7
according December but for whatever
reason the 2.0 moniker stayed somewhere
doesn't say you can't upgrade the major
version when you don't make a break in
change so I guess that's fine but Donna
Steiner - is quite a change from 1.6 so
in kind of understand what they wanted
this to be a bigger a bigger kind of
thing with a bigger kind of announcement
associated with it the documentation
around this is really really good so if
you follow URLs like these by the way
don't bother trying to memorize these
now or take photos old I will tweet the
link to the slide decks they are HTML
based so you can just browse them this
is my twitter handle if you don't see
them just tweet me and I'll I'll make
sure you get them this is the diff if
you go to these kind of links you'll see
things like this this is a diff between
dotnet standard 1.4 and 1.3 this is
actually the smallest diff of all of
them it's really really small all you
can you can see that all they've done
here is added a class another class here
and a few enum members and they have
this for every single revision so you
can see the different every revision so
how does this work well
when you when you build your don't nest
down a class library what you do is you
build it against an this thing called
net standard DLL and this thing is
completely empty and that standard deal
is totally empty all it is effectively
is a definition of contracts so I'll
show you it here in a Niall spy so it's
this one here net standard to nest
standard DLL and if you actually drill
into this thing there's actually nothing
in it
apart from type definite type and method
definitions so if we look at something
like array for instance and if you look
at the void methods there's there's just
nothing in them at all right it's just
empty it's it's almost like it's almost
like the concept of an interface it's
just something you compile against when
you produce your package if you look at
some of the methods that return objects
they they do something slightly stranger
they throw they throw no did you know
that you could throw null the the the
constraint of only throwing an exception
type is actually a c-sharp thing
actually the c-sharp compiler which
enforces that in il the CLR will let you
throw anything in Castro null 0 false 1
2 3 it really doesn't matter so it's
clear that this wasn't written using
c-sharp this must have been written
using some kind of like il generation or
something like that
the reason for that is because the CLR
will not let you just do nothing in the
method which returns something it either
has to return something or has to throw
something so I guess that the cheapest
thing you can possibly throw is null now
it's important to make the distinction
between the package and the application
so and if you like this is more like
compilation time versus runtime so when
you compile the package so you're not
running the package you're just
compiling it you compile it against next
standard DLL when you use it in an
application things are slightly
different so this is a dotnet framework
application up here so the good old
dotnet framework
we wish you all no fur for many years
now and that points to the dotnet
framework assemblies for example MS core
lib the.net framework application
references the dotnet stand a class
library and that is referencing net
standard dll as you just saw however
this is not the net standard dll that
was in the previous diagrams the
previous diagram there are many net
standard dll's the one I just showed you
in this diagram this is the one that
ships with dotnet standard itself this
one ships with the dotnet framework and
it uses something called type forwarding
does anyone know what type forwarding is
no one okay so type forwarding is type
four winning is a mechanism whereby an
assembly can effectively pretend to own
a type think about system objects right
system object is not just system object
system objects is actually MS core lib
system object that's the type identifier
in dotnet the type I a complete type
identifier is not just system dot object
its MS core lib and I think it's special
emotion mark system object that's a
complete type identifier so when the
dotnet framework talks about system
object it's talking about MS core lib
system object the.net standard class
library is talking about net standard
dll system object back here that system
object in that standard dll is empty
let's call those men empty method
definitions of throwing throwing of null
system object in this assembly says type
forwarded to system object in ms call
lib so it's a way for the type for
wordings away from an assembly to say
that one time so to the runtime
I own this type but when you actually
access it I'm going to forward you and
send you over there to this other dll
that's basically type fourteen
nutshell it's existed since I think I
think that's one point I have done that
because it's done a quite a lot on the
gag question does it have a performance
impact so that's a question I very often
get asked I would say it
the strict answer is probably yes the
practical answer is probably no this is
such a low-level thing that this has
been happening probably every single
time we've run our dotnet application
since 1.0 definitely since 1.1 so
whether you know whether you know it or
not
the.net code that you're running today
is doing a hell of a lot of type
forwarding already in the background so
it's a kind of thing which is going to
be kind of micro micro Pico optimization
that kind of level I had a question is
is it the same thing as you've sometimes
finding config files no it's not so what
you're talking about binding redirects
no that's for the fusion binder that's a
mechanism whereby at runtime you can say
when you've got conflicting versions of
these assemblies use this version of the
assembly now the tight forwarding is a
lower-level thing that is that more or
less makes sense so far yeah okay I see
most of you nodding so that's good all
right now I promised to talk a little
bit more about dotnet 2.0 dontist and a
2.0 this is Todd next and a two point
was released last year and this was a
major change right it was anyone here at
Richard Campbell's talk yes that I bet
history of dotnet yeah a couple of you
so he talked there about how dotnet
standard 2 is kind of the first real
kind of like industrial-strength one and
donate core 2 and I do tend to agree
with that
don't let to donek standard 2 was a
major change don't know standard one you
know was all well and good but there was
there was two main points of feedback
from the community
the first was limitations so limitations
is what by limitations I mean there was
just not that many API is available
right so if you try to actually
change your package to target dotnet
stand at one point whatever as oppose
has done that framework you'd soon get
it come up against this problem of well
the api's I need just aren't there so
what they did with dotnet standard too
was this is the picture you saw earlier
bomb nest and at one point six looked a
bit more like this right it was just a
much much smaller intersection of the of
the various platforms Don that standard
to said well let's just expand it let's
just expand what we are saying should be
part of Don this standard in order for a
platform to support dotnet standard and
it moved the picture back to this so
it's actually not too far out of scale
those two those two circles because Don
net standard honest out of one point six
had about thirteen and a half thousand
api's where an API is a method or a
property or an enum or or whatever
dotnet standard to had around 33,000 API
is put into it so it's something like a
hundred and forty percent increase so a
massive massive increase and what it's
effectively done to some extent is
brought these platforms a bit closer
together
because it's saying that well in order
to support net standard two you need to
support this much much wider set of API
s so by necessity the overlap between
all the platforms is much much greater
now and now dotnet standard two has
probably most of the API is are sensible
on every single platform you know it
doesn't have things like the registry
obviously which doesn't exist on Mac and
Linux and Nicolas exists on Windows but
all those API switch makes sense across
all the platforms the idea was to get
them all into dotnet standard too and I
think that's largely being achieved
so that should hopefully take care of
the limitations and I showed you this
diagram early on this is a difference
between done that stand at one point for
a month or three if you try and look at
the difference between dotnet standard
two and don't nest and at one point six
github just blows up and says sorry we
can't show it if that big it really is
it really is that enormous
so that largely takes care of
limitations hopefully the second thing
is this thing I referred to as paralysis
taking the example of fake it easy fake
it easy depends on a castlecore taking
the example of n service bus rabbit
which is the package I look after my day
job
that depends off obviously online
service bus not too surprisingly it
depends on the RabbitMQ client and n
service bus itself depends on auto FAQ
and surprise surprise Nutan softer jason
now this is a dependency graph right
here we've got a what this is just a
simple one dependency this is a two
level dependency graph right this one on
this one this one on this one on this
one so the problem is if you want to
support don't let standard in your
library your dependencies have to
support it right until they support it
you're kind of stuck so with fake it
easy we had to wait about we were
actually kind of we wanted to release
don't fake it easy on that standard but
we were kind of you know we were ready
to go one to do the work we had to wait
about six months for castlecore to
release a version that supports dotnet
standard so we're kind of stuck or six
months right we're just paralyzed now
Newton soft that Jason does support
don't net standard has not quite a while
now
maybe that's fixed after problem right
so how often you get Gallio depends on
Jason dotnet but the point is you can
you can imagine much deeper dependency
graphs hero you can have dependency
graphs for five levels deep or more and
the community felt itself in this state
of paralysis where it just couldn't we
just couldn't move because something
down the dependency chain still didn't
support that net standard and it was
quite frustrating so we've got net
standard to the simple solution was
reference anything I will take away this
restriction or just let you reference
anything right now this is where the
real magic comes in right so I'm gonna
I'm going to show you this in a
because it's a kind of a little bit hard
to believe until you actually see it
happening so I have here a solution
named dotnet standard magic and what
I've got here is a dotnet Core 2 app and
a dotnet standard 2 library now what I'm
going to do is I'm going to reference
from the dotnet standard 2 library I'm
going to install they're really old but
really good package called power
collections
okay now power collections is is a
dotnet frame I've actually got it open
here somewhere
how collections is a dotnet to package
right this is not dotnet core to there's
none that standard to this is the old
dotnet framework to write from yeah
there we go from 2005 right that's about
time it's released so this is way before
any of this dotnet stand and don't let
course stuff what I'm going to do now is
I'm going to well first of all I'll just
use it I'll just do something using that
package so a couple of using statements
now I'm going to reference from the
dotnet core app I'm going to reference
of that net standard app and let's just
call into it here couple more using
statements oops
right and let's run that
and it works right so we've just
referenced from a dotnet core
application I've referenced a dotnet
standard library and that don't net
standard library is referencing a dotnet
framework DLL I was pretty amazed when I
first saw that I didn't think I didn't
think this thing I think was possible
and it becomes really interesting when
you look at how this thing actually
works so again we need to think about
the the package and the application
separately when you're compiling the
package things look like this we've got
the dotnet standard class library and
that reference is as we saw way back and
Eve in the first example this net
standard DLL alright this is the empty
one the.net standard class library is
referenced in the dotnet framework class
library
alright that's power collections in this
example the dotnet framework class
library is looking for MS core Lib which
is someone that dotnet framework
assemblies now the these not net
framework assemblies here are not the
usual don't net framework assemblies so
there is a these are shipped by dotnet
standard so there is a version of MS
core Lib in these assemblies down here
which is type forwarding back to the
empty net standard DLL
I'll show you what the assemblies look
like so this is the this is the the net
standard DLL hang on them it I'm
confusing myself now ah here we are
it's this one here so this is a version
of ms core Lib which is shipped by
dotnet standard - and this one is type
forwarding - let's just pick that it's
tight forwarding back to that empty net
standard DLL from dotnet standard right
now that's the easy bit if we look at
the application things are a bit more
complicated still the.net core
application is looking for the.net core
assemblies so I think the system what
object is in there is in it is in an
assembly called system dot runtime in in
the concepts bottleneck or rather than a
mess called it so these are just the
standard runtime assemblies that run
they're used when you run any dotnet
core application the dotnet stand the
class library is pointing to net
standard DLL this is yet another version
of net standard DLL this is net standard
dll ship by the dotnet core platform and
that is type forwarding back to the net
core assemblies the net the dotnet
framework class library is pointing to
yet another set of dotnet framework
assemblies which are shipped by the
dotnet core platform
so there is an MS core Lib in here in
the dotnet core assemblies which is
pointing back
- the actual runtime assemble is for.net
core right so at runtime everything this
this and this either directly all of our
tight forwarding are all pointing back
to the runtime dotnet core assemblies I
still have trouble remembering this
myself I have to go back to these
diagrams and work through it but if you
think about yeah question
thank you that's a good question so the
question is what happens if the dotnet
framework library tries to call
something in here which actually doesn't
exist in here it's a really good
question it's the first thing that I
asked as well when I saw this you'll get
a runtime exception right there is just
no way around that it can it can't do
any kind of magic to say well I'm
actually going to make something happen
which doesn't exist in here right
so in it so this is this is a bridge
this is a bridge towards allowing you to
use current dotnet framework class
libraries which are out there against
don't nest and and libraries and in
dotnet core applications until those
libraries actually support that net
standard all right so in this scenario
testing is quite important right you
want you want to have fairly thorough
testing if you're doing this right it's
a bit of a hack ultimately but it
unlocks that paralysis because it means
we no longer have to wait for power
collections to support on that stand we
can just go and do our work now and
create a dotnet standard package
referencing something like power
collections question
okay the question is does it work with
dotnet framework applications as well as
we've done as well as with dotnet core
applications the answer is yes it does
and the reason for that is that where
we've got this net standard DLL here
ship by donut core we've also got an
octet standards deal out a net standard
DLL shipped by the dotnet framework
which does the same job pointing better
don't net framework assemblies so yes
you could replace dotnet core up here
and donate core up here and donate core
up here we've done that framework and
the dog and the diagram looks the same
the reason that this was done was that
an analysis was done as a nougat gallery
and the vast majority of nougat packages
on the gallery which target the botnet
framework actually used api's which were
available and don't let standard - so
that's the reason this was done so in
the vast majority of cases you're
actually going to be ok you won't hit
that runtime exception which you
mentioned now I for just for fun what
would what would happen if I cut out the
middleman alright so what would happen
if I didn't have the dotnet standard
library sitting between the app and the
dotnet framework library and this is
actually completely irrelevant to this
talk this is about that net standard but
I just wanted to see what would happen I
can resist it so what I've done here in
this net core magic solution is all I've
got here is just a dotnet core app right
just a dotnet core console app and I'm
gonna reference power collections
directly so this is the same power
collect as you saw before
and I will just make some kind of cool
into it couple of using statements right
so this is a dotnet core a.net core app
installing a dotnet framework package
only who thinks this is gonna work not
many of you are so pessimistic I don't
think it was gonna work either but let's
give it a try
it works alright that's that was a real
Wow moment for me I don't think most
people realize this still you can do
this now you can actually take it you
can actually write a dotnet core app and
reference a dotnet framework assembly
right you do not have to wait
necessarily for dotnet core and that's
not net standards of support again you
know test it in case you get those
runtime exceptions but but yeah it is
pretty amazing sorry I'm not sure I
heard you this is it right so if that
application run on non Windows platform
and tried to touch the registry actually
windows are not Windows doesn't make any
difference because it's just on that
core so if you took that dotnet core app
and ran it on Linux you it would it
would explode if the dotnet framework
assembly tried to touch a registry if
you ran it on Windows it would also
explode because the dotnet core platform
on Windows doesn't have the registry
either right because don't Annette calls
common every platform doesn't it's not
different for Windows yeah so you're
going to get that runtime exception so
again you know this is a kind of bridge
while that library doesn't support
either dotnet cord on that standard to
allow you to get things working but
ideally you're gonna want that package
you're installing to support on their
cord on that standard
and really this just works as simply as
that is literally just cutting out that
middleman there so we've still got the
dotnet core application pointing right
through that into it on that frame at
class library and we've still got the MS
core Lib shipped with dotnet core
pointing back to the dotnet core runtime
assemblies so things just work it's a
cool bit of magic it is a hack you know
be careful with it but I think it's it's
pretty cool does it work with lower
versions of.net core does it does it
work with lower versions of.net core so
that don't let call 1.1 for instance the
answer is no well as far as I know I'll
be I'll be amazed if it does because
this this type 14 magic was part of the
whole 2.0 release give it a try if you
know if you want to try this yourself
you need dotnet core 2 you need the
these are the minimum versions of the
ideas you need and obviously Visual
Studio code is just being released all
the time these are the repos again you
know you'll get the slides afterwards so
you can click through those and give
this a try for yourself so that will
hopefully get rid of most of the
paralysis and kind of unlock the the new
get community and that in a nutshell is
not net standard - this was the big
thing there's a release last year in
this space more AP is and the ability to
effectively reference anything I say
reference any I say anything with a star
it's not really anything all that all
that type forwarding magic ships for
the.net framework and I think for some
of the PCL profiles because the problem
that was trying to be sold was that the
gallery was full of packages for the
framework for the.net framework and
sometimes for PC ELLs and we want to be
able to use those in the new platforms
so it's effectively almost anything
right if I've got a package what do I do
if I want to port my package what
happens if I want to port my package
from the dotnet framework to Don that's
standard this is a really really good
resource right Don that API port it
comes in two different flavors it comes
as a visual studio add-in which I
believe is actually packaged with the
latest versions of Visual Studio you can
just right click and say analyze project
project portability or you can run it by
the command line analyze - f2f to a file
and it goes through analyzes the entire
assembly and it spits out of all things
an Excel report but I think you can
actually configure it to to output 'html
and JSON as well in that excel report
you'll see something like this so I ran
it friend service bus core and this is
the current released version of
in-service bus and service bus for
dotnet stand and dotnet core is actually
in beta right now the current RTM event
service bus targets dotnet framework
4.5.2 so unsurprisingly the analyzer
told us that dotnet framework 4.5.2
supports 100% of the api is a 10 service
bus needs for dotnet - for dotnet
standard 1.6 and news isn't quite as
good dotnet standard 1.6 only supports
66 percent of the api's certain service
bus needs with dotnet standard - the
situation is much better it's 87 percent
and we decided that that's probably a
reasonable gap to try and close so we
are aiming for dotnet standard to
support and then service bus
what do i do what do I do to close that
gap where do just to close that 13% gap
or whatever the percentages in my
library there's a couple of things you
can do you can change your library now
there's two types of change you can make
you can make an internal change where
you're using something internally in
your library to achieve something as
part of your package you can change that
to perhaps some other API and don't let
standard right sometimes that is an
option that's really nice because you
don't have to change your public API
it's just a matter of just changing the
API to use internally or you can make an
external change so you might be
returning some object from your API
which only exists in the.net framework
or you might have a parameter on a
method or something you may have to
change that you may have to change that
to some other object which happens to
exist in the.net standard that's
obviously a breaking change if you're
following assembler you're gonna have to
upgrade your major version but that's
just part of part of part of making that
kind of change you can separate now this
is a very very powerful pattern so in
the example of n service bus and service
bus works over queueing systems so you
can use n service bus with a rabbit you
can use it with RAM as M s and Q and as
your service bus and other things the
original version of n service bus have
MS MQ support built into the core DLL so
it's like the default queuing system
however ms mq doesn't exist on linux or
mac so it makes absolutely no sense
whatsoever
to have the MS mq API is as part of
dotnet standard now only a certain
subsection of our customers use M s mq
right so we thought well why don't we
just separate that into a separate
package arguably should have been done
to start with but we just took that
whole m sm q slice out of the core
package put it into a separate one and
then made n service bus call depend on
don't let standard instead whereas the
MS mq package is dotnet framework so
means if you want that you have to stick
to Windows if you don't want that you
can use Linux or Mac or something else
and use one of the other libraries like
the rabbit mq into
creation which had forced on that
standard so that's a really powerful
strategy for this if you think there's a
certain slice of your library which
clearly depends on things which aren't
cross-platform slice it out put it into
another package and that only makes
sense of a certain subsection of your
users need that if all of your users
need that you're gonna find some other
solution but if you know that only some
people need that bit put it into another
package for those people and those
people could continue to rely on Windows
or and the.net framework instead and
lastly if all else fails it might be a
chance to kind of get rid of those those
obscure API is that you think no one
uses or you know no one uses you know it
might just be time to chuck away
something perhaps again you know that's
going to be breaking change so a new
major version but hopefully you won't
have to resort to that too much and you
can get by with kind of change and
separate strategies first api's and
versions of API of dotnet this is a
really really good resource this is the
most kind of complete resource out there
for all the api's of that are available
every single platform in there every
single version with not that standard
you can go in there you can search for
anything like something like I data
reader okay so search for that and it
will actually it'll actually tell you a
little bit about it you know methods and
things it's a bit like the speed like
the usual standard Docs but then it will
tell you every single platform it's
available for so it's available for all
versions as on their core all versions
is on that framework it's only available
in dotnet standard - alright so this is
one of the ones which was missing from
dot nest and at one point X it's one of
the ones that came back in and very
various versions of mono and so forth
and so forth so that is a really really
good resource there isn't there is an
amount of works on my machine here who's
heard of this kind of platform not
supported exception yes lean oh sorry
yes question that was api's have done
that yeah like I said I will tweet the
slides afterwards and you should be able
to get hold of them
there is an animal that works on my
machine because there is a single
platform not supported exception some of
the platforms have effectively cheated
in saying that they support the dotnet
standard 2.0 and there was a very small
set of api's where at runtime you'll
actually get a platform not supported
exception this is like the thorn in the
side of dotnet standard alright and I
hope I hope that this won't continue and
it is just a very very small subsection
of the API is just something to bear in
mind you're very unlikely to hit them
but some platforms do do this right so
for instance for process set this
property on Linux you'll get a platform
not supported exception and on OSX for
this one here you're gonna get platform
not supported exception for other
processes so that this is well
documented if you go to this API compact
page it actually lists all of these so
you can sort of take preventative action
to make sure you're not going to get hit
by this
don't let standard versus dotnet core
alright so this is something I keep
hearing confusion about now I am hoping
that through what I've already shown you
in this talk that the difference has
started to become apparent
so dotnet core is just another one of
the platforms they do get conflated a
lot in the in the literature and in when
people talk about these things but
effectively dotnet standard is that
empty contract I showed you the the base
don't nest that a nest standard DLL and
it is empty
alright you don't you don't run in the
context of net standard because the next
standard dll ascent ultimately is empty
it is the platform's which should
provide the implementations it is dotnet
framework it is you WP it is don't net
core you know don't let go is another
one of those platforms which happens to
implement the dotnet standard
question okay so the question is you can
create dotnet core libraries so why do
they exist why do they exist alongside
dotnet standard libraries so a dotnet
core library is the equivalent of a
dotnet framework library for the.net
core platform so before all this started
right back when it is simple single
dotnet right when it's just a dotnet
framework you created dotnet framework
libraries to run on a dotnet framework
platform right that was the old simple
days that's that's a platform right so
that's that's an app and it's a library
which is designed for the runtime which
that app targets over here we've got
dotnet core we've got a dotnet core app
and a dotnet core library which is
designed to run on the.net core platform
only it's it's completely analogous but
on that framework here darnit core here
don't nest standard sits in the middle
because don't let standard says well I
only I only I'm only calling API is
resist in both so they don't let's
download be something you can take and
run in the context of the.net framework
app and the context is don't net dotnet
core library now the reason for creating
a dotnet core library might be because
you simply can't achieve what you want
to achieve using the ape not that
standard API is that's getting much much
rarer now with dotnet standard 2 because
it's so big but it's still a valid use
case you might find that dotnet
framework has the API is you need dotnet
core has another set of API is which you
need which do the same kind of thing and
those and there's just no crossover and
overlap and dotnet standard so you might
choose to ship a dotnet framework
assembly in a dotnet core assembly to
support just those two platforms does
that answer your question yeah yeah cool
and yeah these things doing it conflated
because this was for instance this was a
snapshot this page has moved on but this
is a snapshot this page last year where
dotnet standard to preview is scheduled
for q2 done that standard ITN was shut
off for q3 and they hit these targets by
the way right smack bang a middle of q2
smack bang on me like you three I said
kudos to the team but when you actually
looked at this top of this page you
actually said this
it's like dotnet core and dotnet
standard to.net core and that's an or
two so watch out for that so that
they're often mentioned at the same time
in the literature sorry and I think that
does add to the confusion but they are
two separate things dotnet standard
could potentially exist if dotnet calls
stopped existing tomorrow it would still
be useful because you could target you
could produce the dotnet standard
library and use it in done that
framework and uwp or something right it
is not in no way dependent on the
existence of dotnet core but in many
ways botnet call drove the creation of
dotnet standard because it was it was
the most popular alternative platform to
turn on that framework so they kind of
got developed in tandem but there are
completely independent things oh that's
more or less clear but they're slipping
a bit on the dotnet core 2.1 the rules
for them what they did hit them for
dotnet standard this is another way of
thinking about it this is something that
David Fowler put together
he created a repo where he actually
defined an interface called net standard
1.4 and then he kind of showed that the
net stand of 1.5 inherits from that and
that caught up inherits from that and
Don net framework 4.6 one inherits from
Don that frame of 4.6 and haratz
from.net stand at 1.4 to show that the
to show this kind of like interface
versus implementations thing I see a few
furrowed brows I hope I haven't just
undone all my good work by showing you
that but I think it does help to think
about it in that way sometime so go and
have a look at that it may help to give
another kind of perspective on on how
this das put together a understand of
two point one to point two and three now
what's gonna happen that I haven't heard
any whispers about Don their standard
two point one year right there seem to
be anyone even talking about a dot nests
down a two point one one of the concerns
are that people raise sometimes is that
each version we've done their stand is
going to get bigger and bigger and
bigger so every time a new version comes
out it's going to put more burden the
platform providers to support a bigger
API and that is true right because
unless they make a breaking change and
take something out don't less down a to
put one by a necessity has to be bigger
than got nets down to however don't nest
an or to was such a massive change from
dotnet one point six it was such an
increase that it does well the idea was
to include virtually all of the API is
that make sense on all the platforms so
while I think there may be a dotnet
standard two point one at some point or
a two point two I'd be really surprised
if there was a 3.0 because that would
mean either making a breaking change
which I don't think they're gonna do or
it means they've added a massive hole
that the API is and it's a massive kind
of thing that I want to mark it and say
you know this is the the latest and
greatest I mean who knows marketing
powers might self take over from there
and there may be a 3.0 but from the
technical point of view I would be
surprised if there's a need for a 3.0 so
how do I do before I wrap up there any
more questions about anything I've
encouraged yeah-hoo-hoo now thinks
they've got a reasonable idea of what
dotnet standard is
that's almost all of you great who who
thinks so you understand the difference
between Donna Cornett standard almost as
many of you that's really good
excellent I've so I didn't ask that
question when I came in so but I'll give
myself the benefit of doubt and I said I
helped a bit with that understanding
before I wrap up any more questions yeah
is there any benefit to understand the
complicated diagrams
the answer may well be no but they were
quite interesting when they know hey
there's maybe there's a bit of
indulgence on my part I don't know I
mean maybe there is I think I think it's
I think it's interesting to know what's
going on with the hood the Penn's ear
application runs or not yeah I mean
ultimately there are edge cases and
everything and if we know what's going
on there under the hoods you might
discover some kind of weird bug or
something going wrong so I think that
there are uses but I would say the
majority majority of the time I would
hope there isn't much use because
everything should be working as design
all right do you need to wrap up maybe
so did have one more question somewhere
down here yeah
the special analysis tool how detailed
is it is it something we're using friend
service bus it is actually very detailed
I didn't show you the second sheet of
the spreadsheet it actually lists all
the methods and properties that do exist
and don't exist the ones you're trying
to use it won't go through the pendants
ease because that's that's the that's
that's the part of getting that
dependency to work on don't know
standard but it'll analyze all the calls
at your libraries making and it's a very
detailed output and yes we did you
absolutely use it for n service bus all
right I try and wrap up now because the
party is starting any minute now if
you're interested in know more about
what we're doing then service bus in
that context and that this will probably
give showed a bit more light and your
question go to these URLs there's more
information about what we're doing to
support on their standards this is just
a little tweet which was put out I think
2016 was rough near Martin saying that
here but I was up to miss about 2017 and
I think the team have read the live in
2017 I think we were on 2.0 which is the
first usable versions dotnet cord under
standard and I think 2018 is going to be
really great let's get down to the party
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>