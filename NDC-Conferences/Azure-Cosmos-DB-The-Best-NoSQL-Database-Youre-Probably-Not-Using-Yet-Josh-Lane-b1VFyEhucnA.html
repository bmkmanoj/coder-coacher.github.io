<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Azure Cosmos DB - The Best NoSQL Database You're Probably Not Using (Yet) - Josh Lane | Coder Coacher - Coaching Coders</title><meta content="Azure Cosmos DB - The Best NoSQL Database You're Probably Not Using (Yet) - Josh Lane - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Azure Cosmos DB - The Best NoSQL Database You're Probably Not Using (Yet) - Josh Lane</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/b1VFyEhucnA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so welcome to the last slide
of the day wasn't exactly sure what kind
of a what kind of a room I get I didn't
know if everybody would be be done by
now
have all have you seen some some good
stuff this is my first NBC by the way
it's been it's been a great conference
aya I really enjoyed it I've seen three
or four really good sessions today
hopefully you've had the we've had a
similar experience alright so I know I
realized the last talk of the day we
have after this we have what shrimp and
beer on some sort of a large boat is
that is that what it is
so I'll try to a I'll try to make this
as as enjoyable as possible so that we
can we can cruise through that and then
then get on a boat so thanks for coming
we are going to talk about a sure cosmos
DB just real quick about me my name is
Josh I've worked in industry for 20-some
odd years as a consultant built a lot of
software done some training and
instructing right now I work for a
company called cloud Academy comm we do
AWS as your Google Cloud based training
or training around the the three major
cloud vendors we do some other things
like some DevOps training and that sort
of thing as well yeah I'm an azure MVP
and I also tweet at JP Lane occasionally
all right so quick show of hands before
I get started how many of you are using
as your cosmos TV today actually like
doing something with it making money or
attempting to make money okay a few of
you document DB probably before it was
cosmos we'll talk about that how many of
you have done just like tried hello
world so you've at least sort of like
seen it and now okay not not too many
others about things like MongoDB
Cassandra those kinds of things so any
familiarity with no sequel in general
it's okay you know it's okay if you
haven't we'll talk we'll talk about a
going to give a broad overview of no
sequel or at least I won't go into too
much detail on kind of deep no sequel
kinds of things for those of you maybe
who are less familiar but at any rate
cosmos DB so let's start from the
beginnings and especially since most of
you don't have a ton of familiarity with
kind of the no sequel paradigm itself
cosmos DB was kind of first incarnated
or thought of back in 2010 as an
internal Microsoft Project the the
called project Florence the story goes
that there are a number of teams inside
of Microsoft as you can imagine of
course Microsoft being this kind of
large multinational organization they've
got several large software teams that
have to deal with the you know proper
areas problems of data at scale right
things that maybe the rest of us don't
necessarily have to do or at least don't
have to do in as much of a regular basis
as they do so you know these are teams
like office 365 X a couple of teams on
the Xbox or organizations teams within
the Xbox organization that sort of thing
and the story goes that these teams kind
of kept bumping up against the same
sorts of problems over and over again
they have to deal with large
geographically dispersed user bases they
have a gigabytes if not terabytes of
data that they sort of have to shuttle
around and move around the planet and
make various bits of that available with
a very high uptime very low latency for
a very wide widely geographically
dispersed audience millions of
simultaneous users potentially and so
you can imagine if you've got two or
three teams or four teams internally
kind of all banging their heads against
the wall like how do we do this how do
we accomplish these these things at some
point somebody inside Microsoft says
well gee let's spin up a team and figure
this out ourselves so in 2010 they
started to do that it took them a couple
of years but they were successful and
those teams by all accounts were able to
kind of use that that in that tool
internally and then of course in 2015
the the decision was made to make public
some element to that or some kind of
subset of that and that was called
document DB and that's been around again
since 2015 you if you're an azure
customer or a
as your consumer than you've been able
to use that for a couple of years now
those of you who maybe a few of you who
are familiar maybe have paid attention
and saw at billed six weeks or so ago a
new product called cosmos TV was
introduced and this is basically the
thing that subsumes document DB so it
again I'll talk about the features in a
moment but document DB now no longer
exists properly it is now called cosmos
DB all of the features all the
functionality of document that was there
and document DB kind of carries forward
it's still there in fact you literally
we you know all of us who were using
document DB the day prior we woke up the
next day billed was going on and now all
of a sudden we were all cosmos DB users
which actually is an interesting
testimony towards the the power of a
managed service because the team W
literally there was nothing to install
there was nothing to upgrade no buttons
to click we just literally woke up the
next day and there we were alright so
more generally about the service itself
first and foremost it is a no sequel
JSON data store so that's a sort of a
fancy way of saying that basically what
you're what you're dealing with
fundamentally is JSON data individual
documents or individual elements that
are packages as JSON and defined as JSON
that again that may be obvious to some
of you but you know those of you maybe
who are familiar with things like
MongoDB it's kind of a very very similar
kind of paradigm kind of at its core
another kind of core feature or core
element of cosmos is the notion of this
push button here replication so this
this quite literally allows you to go
into the azure portal if you're familiar
with the Agra portal you can log in you
can also do this programmatically via
api's but you can go into the azure
portal and you kind of presented with a
map of the world and a you know some
icons that represent all of the data
centers for Azure and you can just you
pick a primary one when you create your
account but then you had you can click
on any of the other secondary icons to
create secondary replicas of your
account meaning of all of the data in
that account and this is you can pick
one extra one you can pick forward I
think there are forty some data centers
I think now in Azure and you can
replicate your data into all of them if
you wish now of course you're going to
pay for all of that and typically that's
you know that's the the size and scale
of organizations that maybe would want
to do that it's relatively small of
course the number of them that would
want to do that but still it's there if
you if you're so inclined the the next
kind of major feature or thing to kind
of be aware of with cosmos is that it
provides an SLA back guarantee for low
latency reads and writes now this is
sort of you know kind of a generic of a
generic saying here or a generic you
know this isn't this isn't talking
specifics but specifically the current
SLA guarantees at four 9s so 99.99% SLA
guarantee for 10 millisecond reads or
less and 50 millisecond are 15
millisecond reads are rights or less in
fact the this is this is a region rights
occurring within the same data center
where the data you know that you're
trying to read or write against resides
of course there's additional latency you
know network and that sort of thing if
you're going across data centers the the
the median reads and I have another
slide on this but the median read and
write time is actually closer to two I
believe it's two milliseconds for reads
and six milliseconds for writes so this
is this is a it's quite fast and again
its SLA backed at four nines so the team
is a is pretty proud of their ability to
to deliver on that kind of guarantee and
I have another than the very next slide
actually I'll talk a little bit more
about the SLA s
another aspect of this to keep in mind
is this notion of provision throughput
so the way that cosmos DB works it works
differently than your kind of standard
database that maybe you're used to like
sequel server Oracle that kind of thing
first of all it is a managed service so
you're not managing the infrastructure
but fundamentally when you use it you
you one of your responsibilities is to
specify specify at your account creation
time or really it's actually at the
individual collection creation time
convenient collection of JSON documents
you specify the
the required throughput that you
anticipate needing for your application
so this may be you know this could be
something like a thousand you know you
you're a you're either a Software
Architect yourself or a developer or you
work with the team who has built your
software which is going to run on top of
Cosmos and your responsibility is to
sort of understand well I have this many
users my application behaves in these
ways and has these kinds of access
patterns against the data and so I might
need a thousand requests I might need to
support a thousand requests per second
meaning reads or writes or maybe I need
a million maybe I'm a big organization I
need I literally need a million reads
and writes per second I need to support
that level you specify the provision
throughput that you require from the
service and designate that when you sign
up and when you create your collection
and the service guarantees again in a
four nine level that you will you will
get that provision throughput now of
course the trick or at least you know
you can imagine that the the higher
throughput that you designate I mean
nothing's for free right that's sort of
more throughput that you designate and
say I need this I need you to guarantee
me this the ability to have this this
many reads and writes per second the the
higher that number is the more you pay
and in addition you pay regardless of
whether you use it or not so if you
provision a million requests per second
and then you only do 50 then you're
paying for a million you're not paying
for what you consume you're paying for
what you asked for
for what you asked for so there is your
responsibility as a developer and as an
architect and as a consumer of the
services to understand your needs and
you know try try as best you can to not
over provision or certainly not under
provision I'll talk a little bit more
about kind of what that looks like and
at least some ideas on kind of where you
can go to get some help there because
that is quite frankly one of the
trickier aspects of using the service I
mentioned that it's a managed service so
again you're not installing something
you're not running this on your servers
it's literally I won't go through it
because it takes a couple of minutes to
spin up but if you're in the portal you
just more or less just doesn't you know
give your account a name you specify
what data center you want to be your
primary
other things it's like four or five you
know small fields and you click Submit
it takes a minute or two usually and
then you have an account and you can
immediately start using it but again
you're not packing servers you're not
you're not a responsible for any of that
the cluster you know if you if required
if you require a million requests per
second then obviously that's going to
happen across a number of machines it's
not going to happen on one single
physical machine someone but again
however that happens is sort of
abstracted away from you you don't have
to worry about that what you worry about
is that the service provides you a four
nines SLA for that throughput that
you've asked for
another I have a separate slide on this
I won't go into the detail too much to
many of the details right here but one
of the really big value propositions for
cosmos again we're talking about data at
scale is you have this notion of
multiple consistency choices or multiple
consistent consistency levels that you
can choose from and this is a this is
basically helps you solve the problems
that come with cap theorem so if you're
familiar with dealing with a good cap
theorem and the the consequences of cap
theorem when you when you have
distributed data essentially across
multiple physical nodes these
consistency choices allow you to kind of
tune tune the behavior of the database
that to something which works well
within the confines of cap theorem but
works well for your application and
again I have some more details on that
so I'll skip the rest of the details
right now but later in the talk well
we'll go into that a little bit more so
this next one again from the standpoint
of the database itself it is not a
relational database so you're not
dealing upfront with with any formal
notion of schema cosmos DB just like
Mongo just like Cassandra and other kind
of no sequel databases it will not
enforce schema on your behalf you can
certainly do that in your own
application if you need to and of course
you know typically we need to at least
to some kind of loose level but but it's
not going to do you know you're not
going to define any of that ahead of
time in the database the other thing
that does from the standpoint of
performance you know getting these kind
of low latency reads and writes it by
default that auto indexes all of the
data that's in that
the json data that you submit you push
into the service and again if this is a
million requests per second and you're
pushing a very high volume of writes
into the service all that auto indexing
behavior is happening and in the those
get that guaranteed 15 millisecond SLA
for writes
that's all inclusive of auto indexing i
don't mention encryption on here but
everything is encrypted by default in
cosmos DB so all that stuff is included
in all of the those performance metrics
for the SLA last a last quick thing that
we'll move on to the a little bit more
on the SLA itself cosmos DB is a
multiple data model database and it
supports multiple SDKs and basically
what that means is it is doc the
precursor document DB that we saw in the
last slide that was a document-oriented
database very similar to something like
Mongo and that was kind of the original
incarnation of the service but now that
cosmos is out there are additional model
data models that are essentially
projected on top of kind of the core
model that that cosmos maintains
internally of your data so you have JSON
documents that's still there you can you
can do that if you want to and
manipulate and work with the data that
way there's graph already entered data
I'll do a demo of the graph oriented
data in a little bit and then in the
world there are also currently two other
kind of compatibility modes that you can
work with with cosmos there's one for
MongoDB so if you happen to have a
MongoDB based application and you're
kind of comfortable and familiar with
that you've written a lot of code you
don't really want to change all your
code but you're kind of interested in
this man this cosmos DB thing and maybe
maybe I want to try that out you can
actually point your applique existing
Mongo application to a cosmos DB
instance I just give it a different by
giving it a different connection string
and by and large there's they're still
working out all the compatibility but
it's actually pretty close right now and
most applications Mongo applications can
just talk to cosmos DB as is without
changing any code same thing for oh yeah
question
it's schema and read yeah good question
yeah if you have more questions on that
then you we can certainly talk about it
afterwards but yes exactly right the the
other compatibility layer that exists so
we have Mongo the other one is Azure
cable storage anybody familiar with add
your table storage or use it or yeah
okay that's cool
yeah anybody who's used as your for for
a little while certainly is familiar
with that service there is a
compatibility layer for cosmos DB that
works similar to Mongo but it's for as
your tables so if you again if you know
table storage has been around for a
while I mean there's nothing wrong with
it it's not going anywhere
but if you're interested in cosmos and
you like the features it offers and
you're kind of interested in trying it
out then again you can you can use the
compatibility layer point your app your
existing table storage application which
is its existing API you have to rewrite
any code give it a different connection
string and now it's talking to cosmos
instead of table storage so that's
that's that's pretty clever and there's
actually more work that the team is
doing to to support additional databases
as well additional scenarios like that
real quick real quick on the SLA s so
every managed service every cloud based
service that that anybody ever works
with certainly supports an availability
SLA right like how long is you know how
much downtime are we guaranteeing or
maximum downtime we're guaranteeing
you're going to have over the course of
a year that kind of thing and so cosmos
certainly offers that and it offers it
at a four nines SLA so that's what is
that like eight hours six hours
something like that a year it's it's
very high I mean it's that's certainly a
very good very good availability SLA but
there are there are three groups I just
had to hit my button here in my remote
there are three other facets of the SLA
which are worth noting and this is
something that the cosmos DB team and
Microsoft sort of hold up as a bit of a
differentiator relative to some of the
other options and competitors that are
out there and so these other these other
vectors are latency consistency and
throughput and and they're they're more
or less kind of what they sound like
Layton sees obviously that that ten
milliseconds kind of maximum
window four reads 15 milliseconds for
rights that's that's that that's the
four nines SLA regarding latency for
consistency this goes back to the
consistency models that I sort of
skipped talking details about a moment
ago but essentially if you pick one you
will pick one of the five consistency
levels in cosmos when you use it and
each of those sort of had certain
consequences regarding kind of how your
data will behave when you actually use
when you when you pick a consistency
level and then use it use the service
itself and so the the SLA more or less
guarantees that behavior which is kind
of spelled out for you again at a at a
four nines SLA the last one is
throughput so again this is the this is
how how many reads and writes per second
you designate and you say you want you
that you require your your instance of
cosmos to to allow you to to to perform
and again this is this is maintained at
a four nines level and you know this is
financially back this is this is very
similar to the financial backing aspect
is very similar to existing competitors
and certainly pretty consistent with
what's already there and Azure with
other similar services real quickly this
is a bit of an eye chart in kind of a
long list and I did this intentionally
just because there are a lot of like
really nice things I'm a I'm a developer
and and kind of software architect by
trade I'm not not really a DBA or a data
guy I've done a lot of work built a lot
of software that works with a variety of
different databases but I'm certainly
you know from a from a develop to this
and use this from a developer standpoint
and there are a number of really
interesting features the kind of
developer or architect oriented features
in cosmos and I just kind of want to
call these out here and you can kind of
read about them on your own time but
just know that some of these things are
there a couple that I will mention just
those first those first two I'd already
the default encryption so you can't you
I say default but you can't actually
turn it off the the encryption of
certainly the encryption of data when
you're when you're making a connection
and you're actually talking to the
service that's all done the HTTP using a
SSL so you can't you can actually turn
that off but then you also have
encryption at
as well so all the data that's stored in
the service is encrypted and again
that's inclusive of all of the you know
the SLA guarantees for latency and
throughput that's all that includes any
encryption that's happening behind the
scenes the other one that's interesting
here from a developer standpoint is the
that's stored procedures triggers and
UDF's are supported in the service and
they are authored in JavaScript which is
kind of an interesting choice but
basically the the service itself embeds
and hosts a JavaScript runtime and all
you know in all of the physical nodes
where your data exists so if you define
a stored procedure that kind of works
against a certain collection then you
know that that's that's kind of running
local to to your data so that's actually
one of the patterns in cosmos document
DB before it and certainly cosmos coming
forward one of the patterns is to use
stored procedures for like big batch
operations where you're trying to insert
thousands of records at a time as
opposed to kind of iterating using an
SDK or something and yeah because
essentially you're making kind of
long-distance calls at that point it's
much better to kind of just stream the
data or you know store the data in blob
storage or something and then suck it in
using a stored procedure yeah there's
some additional items on here I won't go
through them all but certainly if you
have questions about them or you're
curious come and talk to me after the
talk and we can we can talk about it all
right so let's do a let's do a quick
demo here the the demo that I want to do
is to demonstrate the MongoDB
compatibility support and you can't see
that let's see let me switch my screen
sorry about that
yes very good project duplicate
it looks better okay so what I want to
do is demonstrate the MongoDB
compatibility support this tool that I'm
showing you is a it's basically a
MongoDB shell some of you may be
familiar with it if you've used I think
it was originally called Robo Mongo or
Mongo chef something like that there's a
there's a handful of open source freely
available tools for talking to a MongoDB
instance so again the short the short
thing here is that this tool knows
nothing about cosmos DB so but I do want
to connect to a cosmos instance I'll
show you real quick in the in the azure
portal I have I've created ahead of time
since again it takes a couple minutes
I've created a cosmos DB account called
Mongo doppelganger and I already have a
collection in here called complaints I
have some CSV data I'll show you in a
minute it's basically some data that the
US government makes available it's like
consumer complaints like you know
somebody was calling my my mobile phone
too often or somebody's scammer you know
charged too much money on my credit card
that kind of thing and so there's a big
database of all that stuff and you can
get a CSV extract of it so I just
grabbed that and I took just a little
small slice it but it's only a couple
hundred K of documents but there but
there's actually gigabytes of this data
so this is the this is the the portal
kind of view this is if you just real
quick I mentioned this earlier but that
that map for replicating the data so you
can see here this is the the Northern
Europe is where this data is currently
located that's where that blue check box
is but if I wanted to I could click on
any of a handful of other data centers
and oh not from this view sorry I have
to click replicate data globally and
I'll get the same map that I can
actually click on so I can just click on
any of these you know it's like 2 3 4
I'm not going to actually do this
because it'll it'll cost me money but
yeah discard that but that's that's the
replication feature so let's go back to
our tool I want to connect to this I'm
going to I'm going to edit this I've
already connected to this before
just tested it out to make sure that it
will actually work here but if i zoom in
again any of you who are familiar with
Mongo know that when you connect to a
Mongo server basically you need the name
of the server you need a port you
probably need authentication information
etc etc so you kind of have this tool
for for connecting to a Mongo instance
so if I go back to the portal and click
on connection string you'll see that I
can get all that information
conveniently enough right from the
portal so I've got the hostname I've got
a port number that I would talk to a
username and a password a big long ugly
password that I would use and so I've
already configured that in here server
name port number authentication user
name password default database and I'm
going to connect to or authentication
database the last thing I need to check
is SSL protocol support because again
you can't talk to cosmos DB using an
unencrypted or an authenticated or a a
sorry an unencrypted connection so oops
wrong way all right so let's cancel out
it there we'll connect now come on
say this would be a very boring demo if
I can't connect alright so I already
have a couple of databases in here again
anyone who's used Mongo you know that
kind of the hierarchy of kind of
elements in Mongo you have you have like
a database and you have a collections
inside of a database and then you have
documents inside of the collection and
Cosmos kind of works the same way again
in kind of document mode and certainly
in Mongo compatibility mode so I'll keep
my existing database again I've already
got a collection but I'll create a new
one and we'll call it complaints to
conveniently enough and you can see here
let me zoom in now I have complaints -
this is my new collection it's got
nothing in it yet if I switch back to
the portal just to show you nothing's up
my sleeve
you can see that I now have two
collections I had complaints already now
I have complaints too so again I'll kind
of repeat myself and I'll kind of be
beating a dead horse here but again this
tool that I'm using doesn't know
anything native you know it has no
notion of Cosmos DB it's just using this
compatibility layer talking to it it
thinks it's talking to Mongo so ya know
it's actually using its directly backed
by SSD disks like very fast disks it
yeah yeah it's a virtual and/or physical
machine I actually don't know what
they're using I probably virtual
machines but no you can't you can't you
can't go directly to the machines I mean
it's all that too abstracted away from
you on purpose on purpose because that's
all managed by an infrastructure team
with in Azure you don't have you can't
not only do you not you know you don't
have to manage it you're not able to
manage it if you wanted to run your own
no sequel database you would need to do
that using like Mongo or something like
that and host it in your own VM yeah
okay so let's import some data here
that's that's really what we want what
we want to see so I'm going to click on
import CSV and go find the CSV file this
is this this is this complaint file it's
only it's like 100 160 7k it's not very
large just something we can you know
won't take too long to import let me
zoom in a little bit so everybody can
see this this just kind of gives you
know this tool this kind of gives me a
little preview of what the data looks
like it's assuming it's it's comma
separated and you know the defaults are
mostly fine here I think you can see on
the on the right hand side this is kind
of a preview of what the JSON is going
to end up looking like when I when I
insert it so I'll keep going again I
don't think I have to change anything
here Sara Cole so I'll just start the
import this takes 45 seconds or so
something like that yeah we can see it's
already 10% done in fact
I can or I can I can even before this is
done I'm pretty sure I can start to
browse this so if I open the collection
yeah like you can already see I've got
some JSON in here I can get a tree view
and start to start to drill into this
and see the the data in kind of a tree
view and we don't we don't have to pick
through all this data but the but the
interesting thing is if I go back to the
collector so I go back to the browser
I want to browse actually I don't want
this view one query Explorer view and
I'll go to complaints to now I'm going
to use the even though I use kind of the
MongoDB compatibility layer to kind of
get the data into the database I can
still query against it using the sequel
cosmos DB has a sequel query projection
layered on top of its kind of core data
this core data model so I can do it's
not a it's not full anti sequel to
second it's not fully ANC sequel it's
kind of a at the moment it's kind of a
restricted subset of sequel but it lets
you do kind of simple filters and
projections that kind of thing and the
the team has actually said publicly that
most of most of the the sequel query
language like kind of the ANSI sequel
query language constructs could be could
ultimately be supported by cosmos it's
sort of a matter of priorities and if
and when they're actually going to
support all that yeah it does not
support MongoDB aggregations at least
not that I recall but I remember I
remember at some point having the same
thought kind of internally and I don't
I actually don't recall the answer I can
I can find out all right so anyway I can
say select star from C where well I can
just say select star from C I think
it'll just return the first 50 records
that's probably the easiest thing to do
instead of trying since I don't remember
all the all the values that are in here
yeah here we go
so you can see again nothing up my
sleeve there's actually data in here
okay
that the the purpose of that demo is
really just to sort of demonstrate that
you know if you're if you're talking
about a kind of a manga bility layer at
a protocol level with with with
something like Mongo one of the best
ways you can demonstrate that certainly
is just to run an import because imports
are going to kind of exercise a lot of
the core functionality of the of the
protocol okay I think yeah we can see
the cool let me get a turn to water see
how we're doing on time okay we're good
all right so I've talked about some of
the the data models that are supported
so I'll just kind of breeze through this
real quick
this is the document oriented model
again that was in document DB which was
the the kind of original incarnation of
the database that's still there today we
saw that's kind of the sequel query
projection on top of it and this is
supported by a number of languages and
platforms so there are SDKs for dotnet
Java nodejs
Python couple that I'm forgetting so you
know you can also talk to it using a
REST API so if you if you're using a
some stack that doesn't have a native
SDK or if you just want you just prefer
using a REST API then you everything
everything you can do in cosmos
ultimately is all done is all
accomplished we can all be accomplished
via rest that includes management
function functionality as well as kind
of interacting with the data reads and
writes I just demonstrated the MongoDB
compatibility layer so that kind of
speaks for itself again you can do that
from any there's no there's no SDK
support there per se it literally works
at the protocol level so if you have a
no js' application that's that's
currently talking to Mongo using
Mongoose or something like that then you
can talk to cosmos same thing with
Python etc I mentioned as your table
storage compatibility this currently is
only supported in the as I recall in
the.net SDK that's it's kind of in
preview right now so I think the I
assume the goal is that to support this
and other other SDKs as well but right
now they're kind of just
getting the tires and kind of shaking it
out but this this does work today if
you're if you're using dotnet the last
one which is interesting and I'll
demonstrate this in a few minutes the
last one is the graph based API so is
anybody familiar with Apache tinker pop
by any chance done any like graph
oriented yeah okay so so Apache tinker
pop is basically a framework it's
maintained by the Apache foundation it's
a framework for interacting with graph
oriented data you know kind of obvious
but but it has it has a query language
called REM 'ln and so what the team did
was to basically build the on top of
that so that that you can issue gremlin
queries and I'll again I'll demonstrate
this but you can issue gremlin queries
against cosmos DB and interact with the
data and kind of graph form that way and
that's pretty interesting and again that
that support is there today for.net and
java and I pretty sure I'm pretty sure
the goal is to extend that to other SDKs
as well okay so sorry to Deb question oh
okay
programmable data consistency we haven't
I've mentioned this a few times we
haven't gotten into the details yet but
so let's talk about that for a moment
most most no sequel databases at any
rate support either either strong
consits called strong consistency or
eventual consistency some of them a few
of them support both and let you choose
between the two but typically it's kind
of an either-or proposition so a strong
consistency is kind of what we're used
to you know if you if you've used sequel
server or Oracle or Postgres that kind
of thing and you you know you do
transactions against the relational
database you're used to that's you're
using strong consistency basically you
know you can play with query hints and
and isolation levels and that kind of
thing but I'm kind of skipping all that
for the moment
what transactional consistency is
basically you do a bunch of work in a
transaction update this update that etc
and it either all goes in and it's all
it's all committed at one time or it all
rolls back because something something
bad went wrong and it fails we all kind
of know this right so that's that's that
strong consistency eventual consistency
is in a distributed system where you
have multiple physical nodes eventual
consistency basically says I submit a
right I submit an update to my data it's
going to be handled by some physical
node in this in this distributed cluster
that's a panel at processing all my data
but it's going to take some time maybe
milliseconds maybe seconds maybe longer
it's going to take some time for that
data that that update to propagate
around to all of the physical copies all
the physical replicas that may exist in
these other nodes in this distributed
system and both of these choices have
advantages both of these choices have
disadvantages somewhere some of you know
one of these is appropriate for some
applications one is appropriate for
others there are some applications for
which neither one of these are
particularly a good fit which is exactly
where we go to what cause that leads me
into what cosmos Phoebe offers from a
consistency standpoint and again I'll
preface this by saying that this is
probably Microsoft certainly holds this
up as as perhaps the kind of
differentiating feature for cosmos
relative to things like google has
BigTable and now they have cloud spanner
AWS as DynamoDB then you know there are
other kind of similar competitive
offerings
none of them and again Microsoft makes
this claim none of them offer five
different as many as more than two
really consistency choices but certainly
not five different consistency models
that you can choose from so you can see
on the on this spectrum we still have
strong and eventual consistency you can
choose either one of those you basically
what happens is when you use cosmos you
pick one and you say for your account
you say this is my default so you can
pick strong meaning you get that strong
notion of transactional consistency and
that that allows you to do to to do
things like ensure that if you make an
update among other things there are lots
of kind of consequences of choosing
these options but for example if you use
strong consistency you make an update
and/or you do you perform some work in a
transaction and nobody else is going to
see the consequences of those updates
until that transaction fully commits and
is fully fully executed
fully so you know that that may be
something that your application you know
you kind of examine your application you
think yes I'm going to need this and so
I'm going to use I'm going to pick and
choose strong consistency the problem
with that of course is kind of like the
slide says at the bottom you get you get
lower latency higher availability and
better scalability the further you go on
the right-hand side of that spectrum so
transactional consistency strong
consistency is nice it you know we all
you know as developers we probably
understand it pretty well we're kind of
used to it and comfortable with it and
so it's nice from that standpoint but
there is definitely a perform overall
performance and scalability penalty for
choosing that model so then you can go
the other direction if you want you
could say yeah you know what I I'm
comfortable with eventual consistency I
built systems like that before and
that's the way of the world and and you
know I've been doing this thing for
years so I'm happy with that now I'll
deal with the consequences of eventual
consistency myself in my application and
so I'm good I'm just going to choose
that you can do that but these other
three options kind of give you some some
other choices that may work better for
your applications so just real quickly
bounded staleness I can summarize that
as saying bounded staleness is basically
eventual consistency if you're familiar
with eventual consistency its bet its
eventual consistency where eventual has
a definition has an upper bound so
eventual consistency again could be you
know your data has to get propagated to
all the other nodes in the in the
cluster that could take milliseconds it
could take seconds it could take longer
there's no guarantee you don't know how
long it's going to take bounded
staleness basically allows you to
specify how long it what kind of what's
the maximum time that your application
can tolerate time or number of versions
essentially a number of updates to a
single piece of data it gives you a you
can basically say this is the maximum
window that my application can tolerate
the data being kind of stale or
out-of-date and what that does is a
course it gives you it gives you a
little bit of a mix of eventual
consistency with some guarantee it's not
strong consistency but it's a little bit
of a guarantee and you'll get a little
bit better performance a little bit
higher availability etc then you
with strong consistency if you're able
to tolerate that if that doesn't work
for you you can pick something like
session consistency in fact this is the
default in cosmos as I recall if you
don't choose anything anything else
explicitly session consistency is
interesting because it works really well
for unsurprisingly for session oriented
applications and there are lots of
applications kind of deal with sessions
so if you is to be anything from like an
iOS imagine like an IOT application
where you've got you know a million
devices out in the field you know
measuring condensation on grass or
something like that and so all these
devices are uploading data or maybe
reading data from the cloud but all they
really care about all the device cares
about is its own data right I mean all
those typically and not always but
typically in an IOT scenario the devices
aren't all kind of like interacting with
one another and aggregating data at the
edge that's all being done by some
analytics package kind of on the backend
so the device the device essentially
represents a session it represents its
own kind of unit of work or scope of
work when it talks to the database or
the cloud which is you know has the
database behind it and so if you can use
session consistency and this'll this
model basically guarantees that the the
device in this case can if it updates
data it can immediately read that data
that it just updated and it's guaranteed
that it will see its own updates because
that's one of the problems I mean there
again there are a number of potential
consequences of eventual consistency one
of them is I submit a write and then I
immediately submit a query to kind of
view that that data that I just updated
but I may not get it because again if
Mike if my update was serviced by
physical node one and my query that
immediately follows that update was
serviced by physical node 17 because
again this is just one you know some big
cluster somewhere but it's just one
service to me but if it just so happens
that physically that data hasn't
propagated yet I'm not going in eventual
consistency I'm not going to see my
update right away
necessarily with session consistency if
it's my update that I just made then the
service guarantees that I will see that
update
and again you the whole point is that as
you move further on this the spectrum
you get a little bit better availability
a little bit lower latency and so you
kind of choose the model that works best
for you the last one consistent prefix
well I can sum that up this way eventual
consistency one again one of the
consequences of eventual consistency is
out of seeing updates out of order so if
I'm using eventual consistency and I
update a piece of data I have update one
then update two then update three then
under eventual consistency you as a
reader as a consumer of that same data
you may see my updates out of order you
may see three two one one two three two
three one whatever again there's no
guarantee with eventual consistency that
you will see the updates in the correct
order that I that I submitted them with
consistent prefix you do have that
guarantee so again the guarantees here
all in remember back to the SLA slide
the SLA guarantees these behaviors with
these different consistency levels so if
your application is maybe ok with the
eventual consistency but you really kind
of need the you know to see you kind of
want to see the updates in order like
maybe you're building a cueing system on
top of Cosmos for some reason you're not
using you know some other cue mechanism
you just want to use cosmos it's kind of
a glorified queue then consistent prefix
would be your friend that would be the
option that you would choose alright
there's I mean this is I could probably
do a two hour talk on consistency but I
I won't in the interest of time and in
the interest of not putting everybody to
sleep yeah real quick yes you can you
can you can you can choose a you can go
from left to right essentially and
choose a less stringent consistency
option on a per query basis yes you can
yes yeah in the SDK yes
I don't know if it's supported with the
Mongo compatibility layer that's
actually a good question I don't I don't
know I don't I've never tried that so I
assure to answers I don't know how that
works and I'm not even sure if it's
supported that may only be supported in
the kind of the the natives kind of
document the document oriented store
probably in graph as well is your
dessert was there another question yeah
it's I believe your only your you only
overwrite it on the reads as I recall I
can again I can find that out and and
certainly let you know yeah I don't
recall actually I know definitely on
reads but yeah I think yeah I'm not sure
I'm not sure what that there would be
some weird consequences with that so I'm
pretty sure it's just reads what good
question how are we doing on time by the
way yes that's also a good question
I don't recall I've actually believe or
not have actually read the SLA it's not
as boring is it I mean most SLE A's are
incredibly boring right written by an
attorney
this one the the one for cosmos is
actually pretty digestible and I but I
don't recall if it I don't think it
specifies a consistency level in the SLA
for under latency I'm trying to remember
now if it actually designates it and
says I understand your question and I
can't remember if it actually specifies
which consistency model the ten and
fifteen milliseconds falls under again
hold that let me know afterwards and
I'll write a couple of these down and I
can I can give you those of you with
questions I can give you my email
address we can certainly resolve it
afterwards fair enough okay all right a
couple other things I'll breeze through
these and I have a couple of things that
I wanted to talk about as far as like
you know
I've worked with a couple of clients of
using document DB at any rate the
precursor to cosmos and so I have some
kind of good and bad or kind of things
to watch out for as you start to use it
as well as some maybe some speculative
stuff that I anticipate maybe the team
will will start working on but in the
meantime a couple of other things a
couple of other things on availability
and performance the service supports
both manual and automated failover
so that's pretty cool because basically
you can you can either designate if you
if you replicate into multiple other
data centers you can specify the
priority in which those fail so or
should failover
so if your primary fails for some reason
then you can say well I mean in my
primary is in East US and I want my
secondary to be Western Europe and you
can get you you can just kind of
designate the order in which they
they'll occur
the other cool thing you can do is you
can do manual failover there's a button
literally in the portal to go to the you
can't see that well that's alright you
can trust me there's a button in the
portal where you can just you can go and
you can say I want to failover basically
well it doesn't it doesn't bring down
the data center it basically just makes
your instance of Cosmos unavailable in
that date in your primary data center
and then you can test your your disaster
recovery strategy so you know when your
boss says to you hey you know we have
this dr strategy have we tested it this
is actually a way for you to do that and
of course if you're using cosmos is kind
of like the basis you know the the
backbone or foundation of your of your
application then this is a very I won't
say easy but it's certainly an obvious
way that you can initiate a failover and
kind of test all of the failover
mechanisms you know your application the
database should failover but of course
all of your applications that talk to it
should also failover in some appropriate
manner as well and you can you can test
that yourself
the other interesting thing that this
allows you to do you can do all that
there's a button in the in the portal to
do this there's also API is to do it and
so I've not worked with anybody
personally who does this but I'm aware
the team has talked about they have
customers who have the azure team has
who themselves have customers who were
geographically dispersed around the
world like e-commerce style customer or
physical commerce customers where you
know that typically their their their
workloads or their their requests are
kind of follow the follow the clock or
the you know they occur in like these
eight or ten hour windows as the some
you know or as the Earth rotates around
the Sun so they you can basically you
can basically turn off or make
unavailable data centers kind of as the
as the Earth turns and just kind of
follow the clock as it goes around and
ensure that the customers the the folks
who are using your database are always
talking although the database are
talking to is always the one that's kind
of physically closest to them you kind
of get the lowest latency that way you
can you can talk to cosmos TV
programmatically using both physical and
logical endpoints so more or less what
this means is you can you can create a
connection and specify exactly the data
center again if you're in multiple data
centers you can specify exactly that the
data center you want to you want to
connect and talk to or you can use a
logical endpoint which is more or less
just like a DNS name but does that
excludes kind of any geography in it and
then you can also when you do that you
can sort of designate again the the
sequence or the priority of the actual
physical data data centers that you want
to talk to so you use the logical
endpoint you say well the first one I
want you to try is East US and then the
next one I want you to try is West US
and etc you can kind of create this
prioritized list that allows it's
basically a way to to kind of provide
uptime and availability kind of from the
client side and ensure that if a data
center goes down that the SDK
essentially the the client SDK will
automatically retry using using the next
data center by priority okay
real quick I've mentioned a low latency
reads and writes again ten milliseconds
and 15 milliseconds the median is for
both is less than ten which is a which
is a good to know every day again this
works because everything is index
and it works independent of the fact
that or it works inclusive of the fact
that everything is encrypted as well I
mention the provision throughput model
the other thing I will note about the
provision throughput model is you can
change that both programmatically and
through the portal so this is another
example where say you need a million
requests per second but you only need it
in a certain window of time again you're
paying for that so if you if you only
need it for eight hours a day and you
know what those eight hours are then
spend then essentially use a script or
use some sort of process that calls the
API and says ok I need a million
requests per second right now and then
wait eight hours and then you can you
can dial it back down to half that or
you know whatever it is you need at that
point yeah hold that thought
great question hold that thought okay
that's a great point I'm going to try to
get to the last slide in fact what I'll
do is I'll skip this last demo just in
the interest of time so that we can talk
about some of that stuff well we have we
have 10 minutes and it's probably not
enough time all right real quick on use
cases so there are this is one of the
things that the questions I usually get
from from folks when they're we kind of
talked about cosmos T be like ok it's
this big distributed thing and it's no
sequel and you know I'm used to sequel
server and kind of you know what am I
going to use this thing for and so there
are a couple kind of primary things to
think about first of all certainly if
you need something which is geo scale
something that's going to you know
you've got users or applications that
are distributed around the world and and
users that are using those applications
and you you need something at that kind
of scale certainly you have other
options it's not as though cosmos is the
only option at your disposal even things
like address equal database now does geo
replication nevertheless it is a good it
is a good option and it's certainly one
to consider yeah I mentioned the follow
the clock scenarios as well I the next
one is again it sounded like we didn't
have too many folks who were kind of
using no sequel or terribly familiar
with no sequel today and that's fine
but if you if you do find yourself in
the situation where you you're sort of
hamstrung I guess maybe one term
hamstrung by the notion of a defined
scale predefined schema you know a
relational schema that's where all of
your data is highly normalized and
you're kind of doing a lot of joins that
sort of thing to to kind of get at your
data and present it in a user interface
that kind of thing and and maybe your
maybe your rights are slower because
you're taking big blobs of data and
shredding all that data into this nice
highly normalized series of tables if
you find yourself in that situation then
then uh then something like cosmos DB is
a good fit precisely because it doesn't
enforce scheme it doesn't have that kind
of formal strict notion of schema behind
the scenes and that's you know that can
be good for things like IOT for example
I mentioned IOT earlier but but uh you
know every IOT device has its own notion
of state and and events that it produces
that kind of thing and it would be it it
often is kind of impossible even imagine
like a firmware update if you do like a
firmware update on a small device that
could radically change the the schema
quote-unquote of data of the data that
it produces and that you need to store
and so you know chasing chasing all of
those kinds of updates you know when
you've got millions of devices out in
the field can be very tedious and that's
that's often a good fit for something
like cosmos DB a schema list no sequel
store another another thing where this I
know Microsoft has some case studies on
this they use it they use cosmos DB
extensively on the Xbox team for Halo
and I know that there are some like
third-party gaming companies that have
used again they've done some case
studies and they've used cosmos DB or
the precursor document DB so you know
basically low latency requirements
gaming is a good option but or a good
example of that but there are others so
that's that's certainly one - the last
thing i will mention and this this is
definitely worth noting perhaps
something I should have said originally
but but I think it's important to note
there's nothing wrong with it's not this
is not the kind of thing where we're
saying relational databases or crap
don't use those anymore
cosmos DB no sequel those things it's a
tool it's it's something that it's a
it's important that it's out there it's
useful it fits well in certain scenarios
and quite frankly in other scenarios it
isn't a good fit and there's nothing
wrong inherently with relational
databases
it's just they are tools as well so this
essentially what's happening is your
your your tool box your potential
options has just expanded which is great
and so now it's sort of up to you as a
developer as an architect to sort of you
know put your thinking hat on and say
okay well these are my requirements what
am I going to use that what database am
I going to use the best fits those
requirements in many cases I will say
and I work with some clients where this
is the case in many cases the answer is
used both use relational relational
engine where it makes sense and use like
a no sequel style database where it
makes sense even within the same
application and that's that's not
uncommon at all yeah quick question as
of today you can't use you can't you
can't you're not if you're using
document DB you're using this now if in
fact document DB had the geo scale as
well
cosmos DB was basically was when it was
introduced it was a lot of it was sort
of like a marketing branding kind of
initiative when they introduced it but
but document DB is now it's not even
it's not even so much that's deprecated
just more or less has a different name
and it has new capabilities and new
features like the graph oriented data
that kind of thing it's a cosmos DB is a
superset of document DB with a different
name yeah okay areas for improvement
real quick so the biggest one the ones
I'll talk about here the biggest one is
knowing how to how to provision
throughput this this is by far again
working with folks and trying to figure
this out when they're using cosmos the
this is a hard thing to do there's no I
wish I could tell you there was a tool
if there
was the such a thing I would I would
probably try to build it and make a lot
of money maybe there is but I haven't
thought of an easy answer for this yet
although we'll talk about the machine
learning in a second but but that's a
hard thing typically what's going to
happen is you'll you'll over-provision
first the pattern is usually you'll
over-provision then you'll under
provisions that that means you're making
more requests than you've actually you
know you provision for or set-aside then
basically the the service will throttle
you you'll get you'll get a HD HD HTTP
errors that you can recognize that
you're being throttled and basically
that's your cue that oh yeah I need to I
need to ask for our provision more
throughput and it's so it's a bit of a
dance back and forth and you know just
requires some testing and some QA work
to kind of arrive at the right answer
for for your application some of these
other things are kind of minor things a
you know take a moment and read it and
if you have questions about it certainly
come and ask me afterwards just in the
interest of time okay so so this is the
last one that I wanted to last slide and
I want to preface all this by saying
that these are all my own personal kind
of musings or thoughts I this is not
like any sort of an official list that
the team is working on these are just
things that you know having having user
service and having a you know having
some familiarity with it these are
things that I expect are likely new
features or things that they're working
on kind of into the future
certainly it's fairly obvious that
there'll be more over time there'll be
more and better kind of query api's so
there's C saw sequel
there's the MongoDB compatibility layer
there's table storage there's the graph
api's which I didn't show just because
we ran out of time but there will be
there's almost certainly going to be
others I mean there's think about it
there's other databases in the world
right there's Cassandra there's a
elastic searches may be a database may
be something else but there are any
number of other possible stores that
that that the team could decide well gee
it'd be really nice if we could get the
x.25
users who are using this tool and see if
we can attract them to use cosmos DB so
it's not unreasonable to expect that
something like that will happen more in
better eco system integration that one's
kind of obvious because the easier it is
for you to use cosmos with all the other
azure services that then the more money
you're spending and happier Microsoft is
certainly about that architectural
building blocks so CQRS event sourcing
stateful services those kinds of
patterns if you're familiar with them
the more comfortable you get with cosmos
DB and kind of you know kicking the
tires with it
cosmos would make a great foundation for
building systems using some of those
patterns for for a variety of reasons
not the least of which is the the Geo
scale but but yeah I think there are
some interesting possibilities there and
I I personally like to see somebody
whether it's Microsoft or somebody else
do something a little build some
examples of that more runtime
integration so I we mentioned that
JavaScript you use JavaScript for store
procedures and triggers that kind of
thing if you again if you paid attention
to build at all you saw how you can
actually take the azure functions
runtime and like run it in a container
like on your laptop like for debugging
purposes it's not much of a mental
stretch to imagine imagine the cosmos TV
team saying well gee we can we can use
we can host the Azure functions runtime
and now all of a sudden you can write
short procedures in Python C sharp F
sharp like all the languages that you
can use in Azure functions so something
like that I don't know if it'll be at
your functions or be some other
languages but hosted in some other way
but that wouldn't surprise me
the pricing innovation so back to this
gentleman's comment a moment ago some of
the other things like spot markets and
secondary markets yeah maybe maybe not
but I your your comment I think is very
very intuitive and quite frankly that's
probably to me the most interesting
thing on this slide and it's the one
that I will be frankly shocked if if
they don't do precisely because that
that idea of figuring out how much
throughput I need to provision it's hard
I mean it just flat-out is not an easy
thing to do and why not use a machine
learning pointed at your your account
your application starts working and it's
over time
it's going to under start to understand
your patterns your application patterns
your how many you know your users you
have a big spike first thing in the
morning because everybody logs onto the
system and tries to do this and that and
then it goes down at 10 a.m. and then
it's kind of you know that it Peaks back
at noon time you know whatever whatever
the pattern looks like but whether it's
seasonal throughout the year
machine learning that's that's
essentially a machine learning problem
and so again it'll shock me if that's
not if that's not part of the the
service eventually I don't know how long
it'll take quite frankly the data is
there today for you to to to make some
of those decisions you could use machine
learning today and kind of yeah you'd
have to set it all up and build it
yourself but you could do that the last
one is just you know convergence with
sequel database I don't think that they
might just look personal guess I don't I
don't imagine that cosmos DB and Azure
sequel database will just become one
thing but I do think over time it's
likely I mean because you know sequel
database now does geo scale and it has a
lot of high availability kind of
features that cosmos DB certainly has
cosmos DB has a sequel language support
so there's just a lot of overlap between
the tour some overlap between the two
and probably more over time so I would
just expect that to kind of continue as
well
yes that's all I had thank you everybody
for sticking out sticking it out to the
end of the day appreciate it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>