<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>IdentityServer4: New &amp; Improved for ASP.NET Core - Brock Allen &amp; Dominick Baier | Coder Coacher - Coaching Coders</title><meta content="IdentityServer4: New &amp; Improved for ASP.NET Core - Brock Allen &amp; Dominick Baier - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>IdentityServer4: New &amp; Improved for ASP.NET Core - Brock Allen &amp; Dominick Baier</b></h2><h5 class="post__date">2017-02-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YXdJ2HLAOdE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">come on does that mean we're supposed to
start okay okay hi welcome oh I know
you're probably a little bit too excited
right now to say anything but it will be
a casual talk hi hello thank the other
so who has used identity server good so
who who is using identify free almost no
one and you're using identical for
already so who's using for what using
free and where are all the other hands
that just said they're using it maybe
two maybe two really
okay okay good so this talk is mostly
about the Delta between identity of
three and identical for the things that
have changed if you never used it before
you will still get something out of it
because you see how we going to set it
up and all that at the same time I think
it's also a story about how a spirit net
core has changed in comparison to katana
and asp.net that allowed us to leverage
features that are now in the platform
which didn't have existed before okay so
it's a bit of lessons learned and and
what did we do and how maybe are even
how how did you sail so basically like I
think one-and-a-half years ago to the
Microsoft Microsoft 80 net team
approached us and said you know we're
going to remove a couple of our
components from the system it says it
different the ones that produce tokens
we're going to focus on the consuming
token side of things and they said like
are you guys willing to fill the gap and
and and update identity server in the
same cadence kind of as we update a
tunic or so people have something to
build their token based solutions and
you know we were young neither the money
I guess there was no money but we were
young said yes we're going to do that
and you know we try to keep up with the
changes
happened in eight who doesn't call by
the time and you know build stuff and
then they changed something and we
realized oh that something that's
breaking us build stuff again and you
know a couple of months ago it was
released I mean a genetic or and I
dental was released end of December so
we try to stay as close as possible but
it's kind of hard if somebody changes
the platform all the time you're running
on to write some meaningful software on
there
so basically yet this is kind of like
what has changed between three and four
where where did we end up and we enter
the polls now right we were young before
and after all yeah all the Cray hey I
didn't have that one year ago so you
know so a maybe the first thing that's
new is we have a website yay that is
kind of like the starting point for
everything you want to know about that
ends before it you know gives you like a
high-level overview blah blah blah but
really the important things are you can
go to the source code from here yeah we
have documentation you can go from here
which we do training on on a spinet core
security in general and identify in
particular which are spit that on Monday
Tuesday so you can see the schedule when
this is happening here we do consulting
we have production support which is new
by the way something we work with with
partners on that if you want to put an
Indian production and you know you can
sleep better if you know there's an SLA
around that then that is also possible
now maybe jump to the soft code first
so that's on github it's in our
organization with college into a for
school all the way down it's all the way
down
it's a dotnet Foundation project have
you heard about the dotnet foundation
it's basically well a foundation for
dotnet space project so I guess that
makes sense yeah and also since a couple
of weeks you can certify your
implementation of open MIDI so in other
words you can go through testing process
and they make sure that you implement
the protocol in the right way for you
are compatible with other
implementations of other vendors and
that also means for you guys that if you
use
nd server it's not not you're locking
into a proprietary implementation of the
protocol you you know it's proof
basically that we just behaves of any
other certified implementation of open
early connect okay so I want to show
what we have the soft code sure so to
sort of model the scenarios the the you
know people moving from my Dennis over
to three to four is you know people may
have put out identities over three a
year or two ago you might be using it
you might have older NB C katana
applications using it but we found you
know people are now starting to build
more and more asp.net core applications
and so of course they want to secure
those but you have identity over three
in place so what we have is a little bit
of it is totally fine by the way yeah
absolutely so we have a little bit of a
you know sample here you know
demonstrating that that set up so what
we have here is an identity for three
hosts pretty bare-bones just to show you
the you know the the basic moving parts
we have a web api that we're going to be
invoking and then we have a couple of
applications clients using that API we
have a console client that's sort of
simulating a scenario where you have a
server to server communication there's
no human involved you just need to to
call an API but do it securely and then
we also have an MVC application where a
user can log in and then you know log
into the MVC application get an access
token and then on behalf of the user
invoke the the Web API so I guess we can
just run these here real quick
to illustrate them so here's a just my
web API we're just hosting them a
console applications the Web API is
pretty simple just a straight-up
controller you know we're going to echo
back the claims that come in from the
token these are all by the way asp net
core so to protect your web api what
we're using is our authentication
middleware this basically wraps
microsoft's json web token middleware
but we add a few other features on top
of it like reference token support so
this is our web api console application
is pretty straightforward this is using
you
what would be known as a client
credential flow so main just comes up
we're going to get our token on behalf
of our you know server-to-server
communication and then invoke our api
with it so I guess we can actually just
run this one first to see that it's
working and really all this did oh I'm
not actually running identity server
okay let's do that first so here we have
our identity over three actually while
I'm here I guess I can poke through the
config so we have a registration for
both our console application and our MVC
application and then down below we have
the user data that we're going to be
exposing to our MVC application when the
user logs in the app may want the name
and the email and then of course this
models our API so I think if I can run
this first that's identity server 3 now
running good and now I run my console
application ok so basically the console
app launches ghost identity over first
gets a token and calls the Web API great
that'll works and then our MVC
application a by the way if you have any
questions in between just yeah give us a
sign so the MVC application now wants to
log a user in so we'll go to our secure
endpoint this is redirecting us then
first to identity server the user is
going to log in there you know get their
single sign-in or if you want to do your
Google logins we can do that here's our
consent screen and then we're back into
the MVC application alright we've now
authenticated we know the user their
name their unique ID and then we can
invoke our Web API again on behalf of
the user so the Web API knows who who is
invoking it so that's the set up we you
know this is some of the common use case
scenarios so building new applications
this pretty much models that so what
we're going to do next is take the
identity over 3 as our Open ID Connect
provider and just move the configuration
over to identity over 4 and we can see
what's different so it's like I guess
the most fundamental thing that is
different is the hosting and so in in
additive-free both hosted on katana
right in katana was this add-on thing to
8p dotnet which had either an IIF space
hosting model Oran self-hosting model
year for empty services or you know
console applications like like rockets
running here the fundamental difference
in 1800 is that you're always writing a
console application yet the notion of a
web application as we know it from
Visual Studio doesn't exist anymore
right you want to write a verification
you basically write a console
application which happens to have a web
server okay
so let's have a quick look at the old
hosting code I mean after the old
hosting code basically you know you use
this thing called web app you passed in
base URL you pass in a type name
colorful for a class that holds the
configuration of that HTP pipeline and
then you called start on it okay and
that was just an option in katana if you
wanted to do is that you know use the
IIF your web config and the way it works
in a donut
so now switching to oh oh yeah and maybe
the other hosting concern that that if
that exists here is logging right so
logging is a hosting concern we had
because in katana or asp.net itself
there was no built-in locking
infrastructure right I mean you all know
that if you're building applications you
come up with your own locking mechanism
somehow right and they're a framework
for that and so on and we use something
called lip lock and anyone ever used to
lip lock yeah a couple of people damien
hickey good guy and the idea was that
basically you as a library developer you
don't want to assume a certain locking
framework right we just want to lock
stuff out but we want to give you the
freedom of using your favorite logging
framework yeah and that's kind of a not
so easy thing to to solve and lip lock
had this approach that you basically had
an abstraction of a logger okay because
they need more abstractions right and we
were just logging out and then lip lock
was picking up whatever at a hosting
level the witch locking framework was
configured and that was a bit of magic
it was poking around in the loaded
assemblies and use reflection and all
that stuff
so how does it look like now in agent
core well agent core is a set of
self-hosting model only so your
application will always be self hosted
it will always be a console application
and then you can either run it self
hosted like we are doing here in them in
the control window or you run that same
code in an empty service for example or
there's a special integration piece if
you want to run it from I is right but
is is not special anymore because a
pineco is cross-platform so that the
role of iis could also be taken by
apache or nginx or whatever the web
server you want to put in front of your
application and that's pretty much the
same model as being used by note no
chairs for example these days you know
same same intent different keystrokes I
guess are you building a web host
builder use you tell it where to run
which server to use we were using
Kestrel here which is Microsoft's
cross-platform built-in web server we
set the working directory we say if
there is a is use I is integration again
same idea there's a class called startup
arm that has the configuration and then
we say build and then run on that and
that's a blocking call and as this will
bring up the web server and our
application will start taking requests
so now how did startup look like in free
so in free they in katana they have this
thing called the F tilde the I F tilde
so you have a class called you know you
could you can name it whatever you want
but it must have a method called
configuration and it's part of in an AI
app tilde and this is basically the
thing that configures your pipeline okay
so and then you can wire up what is
called middleware in that pipeline and
one of the middleware in that case the
only one is the identity server
middleware so that's a piece of code our
code that runs in the HP pipeline and
takes takes you know process due to the
request going to identity server
in a very common pattern in katana was
that you basically pass in an options
class into the middleware which
configures the whole middleware okay so
that's the thing called the identity VAR
options here and that was basically our
only if you like top-level configuration
object and from there all of the
configuration hang off yeah so for
example you know your site name which
signing certificate do you want to use
do you require SSL you know all kinds of
more options with derivative a tons of
options yeah the point is that and that
because we will see that that that will
change all of the configuration in
katana happened at the middleware layer
and this is changing in in a spinet core
the other thing which is interesting
here is is this class called the
identity service factory and the factory
is our own DI system now you might
wonder why did you guys have an own DI
system here isn't that a stupid thing
the problem was there was nothing
built-in in katana but eight p.net
before or katana didn't have a built-in
dependency injection container okay so
we had basically we took the one we like
the best by the time which was Autofac
and just you know wrap that up in our
internals kind of and the factory was
our abstraction of that di container so
basically on the factory you had like
extension methods needed like okay you
know register something that gives us
clients and registers a meter gives us
scopes and users and there are many many
more extension methods and oh yeah you
can see there are all kinds of things
with ability all the extensibility
points could be blocked into this
factory class and again under the cover
this is nothing else as assembling an
auto effects container at startup time
okay let's have a look how that changed
in for
well we don't have anything yet though
so we're gonna we're going to code this
up but yeah so the big change here with
asp.net core is that dependency
injections built-in so what that means
is that our factory object that we used
to have in three goes away right we
actually removed a lot of code from
identity server 3 when porting over to 4
because we can rely upon the the
platform services of asp net core so the
logging is also one of them that went
away
dependency injection that was another
big one too so basically the first thing
we do here is we need to put well
actually to talk to the new method here
so there's a new method called configure
services and this gives you basically
the container that you're going to
register any of your services in and so
this is where then you register things
for di so as is the pattern what we have
is an ADD identity server extension
method off of the service collection and
it is to this one line of code that puts
in all the necessary services that we
need by default so in the past then when
you need to override a feature or you
know extend the functionality you had to
register your own implementation on our
factory now all you have to do is take
your implementation of the I client
store or whatever the extensibility
point is and just stick it into di here
as well ok we do have some extension
methods off of this for adding you know
various things so we have some
convenience functions to easily you know
wire up the right thing but again it's
just putting things into di so you can
just configure things yourself if you
want or use these extension methods and
the middle way itself you know so we had
to touch just to conclude that they
split up this style of graph in two
methods at Brock set one is for just for
configuring the DI system and one is for
configuring the pipeline ok so the
typical pattern a speedcore is that that
sufficiently complex middleware has two
parts one is the upper part Wade adds
the DI services in the lower part Wade
inserts itself into the pipeline MVC for
example uses the same the same pattern
okay so and now it turns out since all
of
configuration is happening at a DI level
there's actually no not a single contact
option anymore on the middle way it says
okay so we've seen in free we had to
load an x.509 certificate from somewhere
and stick that into our options class
and what we internally did is really we
we put the options class into the DI
system right so at any point in time
when we needed to load the certificate
for signing a token we went to the DI
system got the options class went to the
signing certificate property and got
this thing okay so how would that
conceptually look like in for now well
we're going to put that into di off of
our ad identity server we have a helper
here for ad signing credential that
would be one way okay so in the end yeah
this has several overloads depending on
where your key materials coming from so
you can just you know find your own RSA
security key or your own x.509
certificate for example and then I think
we have even another helper here that
even allows us to such the certificate
in the same way that we were actually
doing in identity server 3 so over here
in ident over 3 we had a helper to look
that up from the local machines
certificate store and that pretty much
has just wrapped up into this other
overload and technically again implement
an i signing credential service in the
pipeline to the eye right which return
to do the certificate you you stick in
right but that's a very common pattern
you'll see in agent core in general
there's another method here called at
temporary signing credential so we had a
lot of we got some feedback saying you
know all these certificate stuff is too
hard for me can you kind of just create
a key for me and and I don't have to
think about how that works that's this
guy okay so when you're saying at
temporary signing credential it will
create a random key pair at startup time
for you that you can use to play around
you know you don't you don't have to
wait for the admin to hand you the magic
you know floppy disk with the
certificate on it and but this is only
for for development time really so never
ever use that in production you will
not find that a pleasant experience them
okay what else do we have all right so
the prior one we had to configure then
well the other configuration here and
again as traditional with identity
server we had to teach identity over
about three things one were your clients
those are the applications
one was the users the users that needed
to get authenticated and then the other
thing were the scopes which were the
resources that are being protected by
identity server so let's start with the
scopes mam so one of the big changes we
made pretty pretty late in the game was
three so we we've been for the last two
years or so we've been teaching open D
Kinect and we've been consulting people
and and people immediately get what a
client is people immediately get what
the user is but the scope concept in oak
MIDI Connect is a bit confusing so we
found ourselves over and over saying
think of a scope as a resource and there
are two types of resources identity
resource like first name last name and
there are api resources and then at some
point said like ah why don't we just
call the class resource and we don't
have to explain it over and over again
and that's what we did okay so we
renamed scope to resource scope is the
term that is used in the specification
and we just try to be true to the
document but it turns out that it is
just in the way when you're modeling
your architecture so now we have two
types of resources in our system one is
called an API resource which is an API
you want to protect right and one is
called an identity resource which is you
know things like first name last name
ma'am and we're going to start with an
API resource first now if you get a
thing that hasn't changed is you can
still load your configuration data from
wherever you want yeah so if you want to
use a database we have an entity
framework you know service for that if
you want to use a context file then you
load from the context file we have we
have a couple of customers who want to
use it in code and just use continuous
you know integration to update their
configuration or something in between
now and again technically speaking
there's an eye resource store and you
implement your favorite in
limitation of that in the DI container
and that was what we're going to use now
we have a we have a built in one which
is useful for testing and for
development time and for doing channels
like this which is the in-memory
resource API resource right okay so you
just define the api's you want to
protect you pass them into our configure
method and from that point on we can now
reason about these API so when somebody
asks for tokens about for them and so if
you've been using these protocols and
you're familiar with requesting scopes
that's exactly what this is creating
right this API resource models your API
as a whole and these constructor
parameters are indicating that's going
to be the name of your API resource and
the scope that is going to be requested
by a client application to access that
resource and this line of code actually
models the most common scenario you have
a logical API which you want to assign
to a scope name okay this API might
might consist of multiple physical
endpoints now but you want to give it a
name that you know clients can ask for
what is model also enables is is a much
much easier modeling of more complex
scenarios yeah so just quickly create
another resource that has multiple
scopes for example yeah that was a bit
you know sometimes a bit complicated so
create a new a more complicated API
right maybe take the calendar API
whatever or a complicated API right and
then you want to have multiple scopes
that refer to the same API but maybe you
want to have like a full access scope
and a read-only scope for example now
and then you can do that you can
configure when somebody asks for a token
for the scope which claims should go
into that token by setting the the user
claims I think it's called
collection
and the idea is now that when you know
regardless of which scope we are asking
for the token we will always have name
an email but you can also now consider
if it's asking for full access in
addition to that you know add another
claim like one that would only be able
and included if you know the client is
asking for this for this additional
scope okay oh yeah this model we think
simplifies how you can model api's in in
in our dentists ever okay so it just
commented out you don't need it really
okay cool so now we have a resource the
next thing we need is a client that can
use that resource
this configuration didn't change as much
so we might be able to get away with
copy most of this okay so that looks
about right client ID client name flow
flow we have renamed flow so so when we
learned when we started learning about
automatic connect and OAuth we realized
that there are certain flows in these
protocols that when used together can
create security problems like for
example you allowing a client both
implicit flow and authorization code
flow or for a session code being the
more restrictive and more secure one but
if you allow both for the same client
somebody has just fiddled around with
the clue string parameters and down
create the security from one flow to the
other so we thought a safety fall could
would be to just allow one flow to a
client okay and that's what we did in
order to a free just you know
defensively coding all there yeah it
turns out there are situations where it
actually makes sense that were more than
one flow is allowed to a client let's
say you know for your for your MVC app
it wants to act both as an implicit
client but also wants to do
server-to-server communication so we
need client potentials and implicit flow
or want to do some custom current
whatever so we kind of relaxed that
restriction you can now define more than
one slope of line but still when setting
it
we make we run some plausibility checks
in the background making sure that you
don't choose the vulnerable combinations
of flows okay so for the most part is
you should be fine if not you will get
an exception at the other time saying
hey that's not secure okay good okay so
I think all we have to do is take this
guy and put him into our in-memory
implementation as well
Oh a couple of more things okay well I
actually know just just what the client
first or look at the clients well yeah
so that should be it right for for
client credentials yeah there's no human
involved yeah okay so let's shut down
identity super 3 let's now run identity
over for suresh it will just kill them
all okay there's a dancer for again
rerun ra yeah again go go back to the to
the client code first before you run it
with the dream is not on to the client
code on sole client yeah a couple of
things I want to point out that that we
also changed here so when you scroll
down when you get to token yeah so
there's this you know this class called
token client which is our client library
you don't have to use that but basically
what what proc passing in here is in the
token client is the address to the token
endpoint at a client ID and the client
secret yeah another thing that the OAuth
spec allows per specification is having
clients without secrets now again being
a security guy I fought like math that
sounds wrong to me again it turns out
time will tell and you you know get more
experience there are situations where
clients with our secrets actually make
sense for example for publicly deployed
clients write your javascript client
well that we are maybe but also your
native client is you deploy in the app
store what's the point of adding a
secret to that client that secret
in the source code now so we just force
people to manage more secrets even if
they weren't really secret yeah so again
a new feature in for is you can you can
have clients without secrets okay that
was a lot of feedback we got on that
ma'am
the other thing is when Brock is
requesting the Chokin he passes in the
scope yeah
in free scope was a mandatory parameter
if you want to get the token again we
got feedback saying you know in my data
center I have all these clients and all
these scopes and whenever I give that
client access to another scope I have to
update identity server and I have to
update a client that he knows to ask for
this new scope so what we did now for
for client credential flow is an/fo
resource owner if if you don't ask for a
scope at all you get all the scopes
which are in the allowed scopes list
okay so this reduces a bit of the
management you know there's a ceremony
every time you um you're changing a
configuration okay good so let me rerun
the API which I think I didn't there we
go and now our console client we used
all the same configuration values in
most importantly identity server for is
now running on the same URL so this guy
should see work come on any questions on
that
that's server-to-server style
communication it's pretty much the same
just you know a bit more polished and
and a bit easier to use cool the bigger
the more complex scenario is interactive
applications right where you have a UI
and login and use us and we have to deal
with humans and all that so I guess the
first thing we should do is add some
user for the system okay so we had a
class called in memory user in an
innocent mmm I'd enter free and it
serves the same purpose kind of as the
in-memory stores like if you are in the
in development mode so to speak right
and you don't have a database right here
but you want to have
some something to work with here then
you our recommendation well yeah use the
in-memory user and that simulates a user
database yeah now from the the feedback
we got and the issues that people open
this they started using in-memory users
for their real user so they asked us
like okay how can we load the 'memory
user collection from the database okay
that doesn't make any sense
so so we went back and forth back and
forth removed it all together brought it
back and put it into a different
assembly added more comments to it and
we ended up with in the end calling it
test user I hope this makes it really
clear this is not for production okay so
it's a test user now besides their test
users they are very similar to the
in-memory user they have a subject ID
they have a user name they have a
password and they have a list of claims
ok good
we do have to register them as well WI
test users good ok excellent so it
starts to look more and more like the
old version just different yeah ok cool
what's the next thing we need to let a
user login and that's the UI ok again
one of the maybe third biggest point of
feedback is that you know in when we
when we designed a free our mayor one of
our design goals was to host it outside
of AI is right we have many people
customers also that all they want is is
a install an empty service on a server
and that is your open ID connect
provider no need to install I is now the
problem we were facing is huh how do we
implement the UI if we are not running
in is because by the time there was no
good UI framework for server-side stuff
that was running out of ideas and M
see was tied to iis and there was no
solution inside so what did we do me to
write around we build our own few engine
fun
yes few engine with templating and ante
for tree protection and layout template
layout templates and again like the nice
thing in this version is because we can
now rely on asp net core we can assume
that MVC is going to work especially
cross-platform and we're removing more
code form identity over for in other
words you now build the UI okay but
using your favorite technology right
well right now there's only MVC you know
that there might be other UI frameworks
coming to 18 core and it's up to you
really what you want to use to build
your own UI and to be honest the UI is
the thing you will always change yeah
that that was the probably the most
customized piece in identity server 3
people want their custom workflows at
login time and we had a little bit of a
UI framework where we we show you a
username password screen we could handle
dealing with external providers but if
you wanted to break out of our
predefined workflow you could do it we
had a way to exit that workflow but you
had to come back and kind of coordinate
with us and that was you know a bit of
work so we just decided ok no UI that is
the most customized piece people have
all these different requirements let
them write all that code so does that
mean you have to write everything from
scratch no ok so there are a couple of
different ways how you can start
building your UI well you can start from
scratch
yeah so or maybe you have an existing
application or maybe an existing login
page for example that you just want to
carry over then copy it to identity
server we wanted to make it as easy as
possible so for example another valid
approach would be to just start with the
standard MVC template with the login
page and just at the item identify
middleware to it and that will also work
here so that the way the UI works is you
know a request comes in to us which has
to a redirect to slash account slash
login and that's configurable of course
and behind that URL you can do whatever
you want and when you're done with
whatever you want you're setting the
authentication cookie and with a rack
back to us and then we continue the the
protocol work and just do you know
issued a tokens and all these things so
it's totally up to you now how complex
how easy how how look and feel you want
to do in between ok now they used to be
a thing called new get content packages
you know like we you you get a new gate
and it spits out file static files into
your project that's gone now I mean in
that's like kind of like one of the
victims of the the whole change between
dotnet core and all that so what we what
we did is we created a repo on github
called the identify you I QuickStart UI
and what this contains is only the UI
pieces yeah there's a sample login page
in there that is a sample logout page in
there there's a simple consent screen in
there and you can just download that and
just copy it into your project and you
should use it as a starting point yeah
if you know bootstrap and all the bells
and whistles Sam so either that or we
have a little script file that you can
just execute and it will just download
the folders into your into your local
directory ok so what do we get here so
what we do is we have Dominic mentioned
we have like a login page it's just to
get started it's sample code you can go
and this is you know start from here and
tailor this as you need but the main
pieces of UI that identity server needs
are you know sign-in and sign-out
capabilities so we have an account
controller for those sort of things also
the account controller helps deal with
integrating with the external providers
if you want to plug in Google or Azure
Active Directory and have those users
come back and I authenticate your
identity server you have to have some
amount of code to coordinate from the
external provider back to your matching
account in your database and then of
course issuing the cookie here so
there's code in here that deals with
sign-in and sign-out the only other
pieces of UI we have the consent page as
well which may or may not be appropriate
for all
scenarios but you know if you need a
consent page this will get you started
with that and then I think we just have
a home page in an error page so that's
pretty minimal UI
and it's the sort of thing you would
build in your obviously in whatever
login system you need to we have the
Associated views here it's not much
there we have some styling so there's
some dub-dub-dub root files with CSS
within the the account controller
because this is the place you'll
probably write most of your code we have
first of all the constructor is where we
are injecting in the things that the you
know blogging code needs of course one
of them has to do with your test users
so this is you know coded to deal with
test user so that's one thing that's
injected here of course you would
replace this with your own library that
did whatever database query to look up
your users so if you were using asp.net
identity that would be the user manager
from asp.net identity okay
another important thing that we inject
here is something called the I identity
server interaction service so as part of
the login process you might want to know
the context of the login of the sign in
which client application was the user
coming from right aspects about whether
or not you should be prompting them or
other requirements that log in like
maybe a tenant was passed or maybe a
certain expiration on the the login was
passed a law like a you know a UI locale
hand like you have to show the looking
page in German or English or whatever
yeah all these things are made available
to you why it is just service here that
you can query so this is how you talk to
identity server from your your login
code so then the first login is really
this is just showing a login page when
you post back you know valid credentials
and you validate them we're basically
going to you know once you've done that
you authenticate the user you issue the
local cookie and this is just using the
standard cookie authentication
middleware in asp net core and then the
other thing is part of this of course is
dominic mentioned the workflow is your
your application needs the user to log
in so they first send the user to
identity server
an identity server sends the user to
your login page which is this thing we
then pass you as a parameter where to
send them back once they have signed in
so this is back into our authorization
endpoint so you have to have maintained
the return URL as part of your you know
round-tripping the data in the UI that's
basically the last thing once they're
signed in you take them back and then we
continue the protocol processing and
send them back to your client
application and again this can be
arbitrarily complex yet it doesn't have
to be a single page you can have a
complete registration workflow do
whatever to affect whatever just hold on
to that return URL because you're going
to need it at the end to go back to us
now which is pretty standard in asp.net
applications so is that good for now
we're looking yeah for now okay we need
to add MVC we didn't add NBC so yes this
is of course using MVC so we'll just add
the normal services than VC which is the
same thing as us now they're putting
their stuff into the eye the day Nemo we
need static files yep and we need MVC I
think those are the only few things we
need to add okay
so let's add the MVC climb now and by
the way one more thing is we we will
register the cookie authentication
middleware automatically or if you don't
tell us otherwise but if you would like
to control any aspects of the cookie
middleware itself then you can register
it yourself and then it's just part of
our configuration up here in our options
you just tell us the scheme and we'll
just use that one okay so that's another
point that people wanted a lot of
customization in the past on I'm sorry
would you say let's have a look at the
MVC client for a second uh of how we
invoke that so you see that basically
here in the Amika and we use the open ID
connect middleware for Microsoft so dad
says there's epoch line called MVC it
has a secret it has a response type it
asks for some scopes so we now need to
recreate the same configuration in
identical for the first thing we should
create are the scopes and the scopes
don't exist anymore as
just learn so api's dapi scope became an
API resource and open ID in profiles
they are identity resources okay so
these are the two types of resources we
are guarding with identity server so we
need to register them
the one is open idea by the way open ID
in profile they are they are standard
resources if you like coming from the
open respect so we just have them built
in but obviously you can create your own
scopes and associate them with any
claims you want the issue back to the
client application but for now that
should be good
okay oh and those need to get registered
as well yep good and let's add the
client last step and probably can copy
most of that from the prior
configuration oh yeah so I don't really
typing all those URLs and so where did
he go yeah pretty pretty much all that's
the same the only one is this you can
remove 47 this is a something that we
change to default value for that we have
to redirect you arise aware we're going
back to we have to post logout direct
your eyes of where do we want to go back
to app the lookout we have to log out
clean up URI we have a secret and we
have the allowed scopes so pretty much
the same so the clients haven't changed
that much at all it's mostly around
scopes and resources what with what we
did yeah okay Levitt and we made it a
little bit nicer yeah yeah good in other
words that should work should good let's
run our API set that up and in the last
ones the MVC quiet
so I guess he's still logged in plus
close up okay
interesting dude what did we forget at
NBC static Oh whoop default route ah
thank you there we go
and he
okay one more time there we go so that's
the you know the template UI or the
sample UI looks pretty much like the old
UI that's the content screen again you
can change it in whatever way you want
and here we are back so another thing
that has you know that has changed
you wanna quickly show how you actually
get the token now in agent core yeah
because that is it that some of my
didn't ever change but an 82 net change
yeah so in katana you have to ride quite
a bit of code to handle various events
of the augmentee connect middleware get
the tokens from the request and store
them somewhere and contact the user into
endpoint and these are now all built in
into into the new middleware so they are
safe tokens safe tokens by default
basically just take the tokens coming
back from a dentist's server and store
them in your cookie to be honest that's
not a really good idea it's a very
convenient demo friendly feature but if
you store the identity token in there
and the X is talking and the roof
refresh token maybe if you have that
your cookie becomes pretty big very
quickly and they are kind of masking
that problem by having a clever cookie
middleware that takes the you know once
the cookie or gets bigger than four
kilobytes which is the allowed upper
upper limit they overflow into a second
cookie into a third cookie into a fourth
cookie until you know or basically
there's no more cookies left so in
reality probably you want to store these
token somewhere else maybe in the cache
or in a database depending you know how
long you want to keep them that being
said if you use the safe token feature
there's a an API hanging off the HP
context you say get give me a token pass
in the name the access token and then
they give it to you from this properties
form from this magic property collection
and then you can use it to call the API
which work right here you show them I
did run it yes
does it change something to touch
anything okay okay cool
any questions on that that's interactive
authentication using a web application
and then calling an API on behalf of the
user
yeah pixie so your question is what what
about pixie pixie is a specification
which is targeted at native client
applications not native server-side
applications if you want to want to pre
well we mentioned pixie in the next talk
when we talk about clients but pixie
doesn't apply to to web applications but
we still do support it we do support yes
okay so last thing missing I think is
Google right like let's enable in
addition to user name/password let's
enable Google authentication how did
that work in free I can't even remember
so in three what we had to do was
because we were coordinating a lot of
the UI and the cookies we had to be very
clever about where external middleware
was configured in the identity service 3
pipeline because we had a bit of our own
UI in there so we had this little
callback function where you could
register where you would register you
know whatever middleware Google
middleware or W Federation or open ID
connect to 80 as your active directory
whatever but again now in identity for
for again you can still or you're still
going to use the Google middle
middleware to connect up to an external
provider but you just put it in the
pipeline because now you're entirely in
charge of the UI so we will still need
the Google middleware in in for the
other thing about this is there's a
common pattern when you were using an
external provider like Google is that
when the Google user came back into your
application you didn't want them to
immediately be logged in with your
primary authentication cookie usually
you wanted some
way to capture the user before you fully
log them in so that you could see oh
this is Dominic from Google let's look
him up in our database oh there is a
record okay good he's allowed to
continue or no I've never seen this user
before so I need to show a registration
screen or something else so what we had
is a second cookie middleware to hold
that temporary cookie during this sort
of process of identifying the user and
again that's not really necessary
anymore in identity over four you'll
still use it like a temporary cookie but
you'll just use your own okay
so that's what we need to have in for so
let's go over to for start-up of CS we
can then use the app use cookie
authentication we're going to use a temp
cookie of some sort automatic oops it's
below or above we need to add it hold on
one second here so you know in that in
the way the pipeline works native core
is all die it's really really important
yeah so I always forget if we need to
put the cookies before off that empty
server well what's going to happen is
once they are done authenticating with
Google they are going to issue our
primary cookie I am right and so are
because we're holding the primary cookie
they have to run basically between our
cookie and NBC and at the same time I
want me the way I must be before your UI
framework now which crying makes sense
so now we do have again in our
QuickStart our account controller has a
little bit of code to deal with
triggering this external authentication
so when you come in well I guess I
should scroll back up are a little
extension method here to build the view
model to show the the UI this will
actually go and query if I can find it
here all of the external providers that
are configured in your pipeline so in
other words this already knows how to
how to detect Google or any other ones
that you have so our login page will now
show buttons for Google Facebook as your
Active Directory what
again that's all customizable so then
when we trigger that that is down in our
external code here somewhere so this is
what triggers the external
authentication basically down here at
the bottom we're then triggering you
know Google or Facebook or or whatever
and then the callback occurs and on the
callback this is where we're assuming
the pattern of you having used the
temporary cookie so what we'll do is we
need to go and query the temporary
cookie to look at the Google user to
find out who they are so there is a
little bit of coupling here we need to
know what name that's going to be so we
just have a constant for that and that's
essentially what the name is for this
middleware here that we need to register
like that so then when we use Google
authentication we'll do the
authentication scheme will call this
Google will then do sign-in as same
constant and then we need the client ID
and secret and in fact I think we can
just grab the same ones we already had
from here pop those in okay so temporary
cookie here to hold the the temporary
identity coming from the external
provider to really identify them in your
system and then whatever other external
middleware and again this works pretty
much the same way for Google and ad FS
and Facebook and I'm sorry Azure Active
Directory yeah okay I think that's it
all right so run it I think it's good
run well maybe the game yeah yeah let's
close this all down
and there's the MVC client so secure yep
Google shows up here I'm already signed
into Google so I think it's going to
come immediately back maybe not yeah
there we go so we came back from Google
already and we continue on and now we're
back in our app okay cool
so that's it we've plotted everything
over yep so one one very general thing
that we often get questions about it
where where can we use that where can we
use a tentative of for it runs on HP net
core right and Microsoft has a lot of
marketing in these names again to it it
kind of feels like a signet core is tied
to dotnet core right but that's not the
case the other a fews net core despite
its name can run on the standard dotnet
framework starting with four or five to
I think or something like it or fall for
up to yeah for for back to so in other
words if you have the feeling that
jumping to dotnet core and everything
new at once is a bit of a you know too
long chump and too risky for you you can
just use your dotnet framework you know
and you know love probably and and know
how to install and to manage and to
troubleshoot and your support staff
knows about it and your customers know
what what's going on there and you can
just run a spinet core on top of that
normal clock net framework ma'am so
that's that's totally fine and that is I
think also the most common scenario you
how how our customers are using it today
you know just take the dotnet framework
run dead on top now if you are you know
want to make the jump to.net core you
get some interesting extra features that
you won't get from the full framework
one of them is obviously cross-platform
so we actually build in in parallel
every every single check in gets built
on Windows on OS 10 and on Ubuntu so
it's working
actually you get support for things like
poker melt or if you want to run
identifying a container dev a guy who
writes samples for that as well
so that's working as well and maybe
maybe one of the my one of my my most
compelling features is that we've
thought meant core you can deploy the
dotnet framework and dotnet core itself
with identity server so it's one
self-contained install that you bring on
a server it doesn't need to have started
pre-installed you can run multiple
dotnet versions side by side on that
server and it's just a minimal impact
kind of way to deploy that okay what do
you think said okay good enough good
enough good any more questions yeah
so the question is can you write the UI
as a single page education absolutely
yeah again you know what all we do is we
do a redirect when you come in to us we
redirect to some URL that you configure
yeah and then you do whatever you want
as long as you at the end call a
server-side endpoint that sets the
authentication cookie and that's the
final redirect back to us yeah that's
always the problem so so writing a spa
is going to be harder I think sure but
yeah technically absolutely possible
it's just that you know when you're done
you need to somehow trigger something
that sets the cookie on the server and
then go back to us okay good thank you
very much for your time thank you and
enjoy the rest</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>