<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cloud nano-bots: Strongly-Typed State Machines In The Cloud - John Azariah | Coder Coacher - Coaching Coders</title><meta content="Cloud nano-bots: Strongly-Typed State Machines In The Cloud - John Azariah - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Cloud nano-bots: Strongly-Typed State Machines In The Cloud - John Azariah</b></h2><h5 class="post__date">2017-02-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8nFYg_KkKrE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well last session of NDC hell you guys
have you been having fun today
was it anyone learnt anything you very
good
right so how many people here because
they're only about yeah how many people
here have actually written an
interactive application before something
that involved actually having input
coming from you user and doing stuff
with it you know all that anyone
business application any kind of cool
right so I'm speaking to the choir
everybody understands what I'm going to
talk now that's good so what I'm going
to do is I'm going to take a little
business application and I'm gonna
dissect it and put it back together and
then maybe it'll be better than when we
started with it and hopefully along the
way we will talk about what we did some
principles and so on and see if we can
learn something new so in my past life
right right so in my past life I used to
be a consultant
anyone seen what a blob eyes is anyone
does anyone know what a blue eyes
yeah so Scott lash in one of my friends
is in the room over there doing his own
talk cause boring line of business
applications right and usually it's
something like order processing I mean
insurance claims management or leave
application backing or something like
that and you know customers would come
to me and want one of these things done
and most of these minor business
applications they're obviously very
interactive they tend to want to process
you know some thousand of these you know
in some time period right you know tax
return so so many thousand tax returns a
year or so many invoices a month or
something like that right so there's
usually some element of scale associated
with it that you have to design the
thing for and then there's the concept
of a business rule which is kind of
specified in terms of everyday life
because you know people have been doing
insurance you know three or four hundred
years or something before computers
anyway and so they want to apply the
same business rules in the computer
process so even if you go and try and
get admitted in hospital they want you
to fill out a form that looks very much
like the paper form that they used to
fill out fifty years ago right and so
the business logic is sort of very
domain-specific and people basically
want to keep the existing ones so they
tend to be a bit complex and you don't
necessarily fully understand the
complexity of the domain so this
requirements are usually presented to
you progressively now to make things
worse I was actually a consultant with a
development team overseas so they
definitely give everything to you
piecemeal right so you can't get it you
can't understand the whole system
upfront you can't design everything
upfront you've got to spend a fair bit
of time building something that they
need right now
but leave yourself enough wiggle room in
order to be able to accommodate change
later we're definitely not writing
fire-and-forget kind of things now
usually when you have this kind of a
system what lands up happening is that
the systems are key dates you know the
big guys they go off and they talk about
scale and they talk about should we you
know design for the cloud and what kind
of clusters do we need and how much
memory and what kind of databases should
we use what's our failover strategy and
this and that and most of it centers
around you know some very interesting
problems and most of its and spend
centers around spending money so you buy
a new kid and you do all kinds of cool
stuff the capability side that's most of
us developers and systems and I mean
applications engineer's will try and
design the system in such a way that it
meets all the requirements that the
customer needs and does so in a way that
gives us you know as I said earlier
wiggle room so we bring craftsmanship
into it we bring rules of experience
we'll bring you know Best of Breed
technologies whatever it is we look at
new stuff that's happening but most of
it is really I've done this before it
doesn't work we have to do it this way
and that's the learning process that we
all you know yet conferences like this
you guys can relate to what I'm saying
right cool so at some point we actually
finish this thing off it's a good thing
we you know apply TDD and BDD we do on
the domain driven design and all of that
bring the whole thing kill it up and
running have a shipping party right
Consultants get sent home everybody the
team moves on to something new and then
thing goes into production and there's
some team in there who has a vague
relationship with the team that wrote
the stuff in the first place and some
change request comes in and that's when
everything starts falling apart
right and I think the reality that we
have to understand is that things
starting to fall apart is not a
necessarily a function of bad coding
practices or anything like that in the
please you.your you cannot build
something and make it future-proof
perfect today it's just not possible to
do that and the reason for that is
simply because of this we have human
communication that's the problem
somebody has to communicate the specs to
us that's lived with ambiguity then
somebody writes some code that's
dependent on the specs and that's an
interpretive function of understanding
the spec so the person now who's reading
the code has to deduce intent has to
deduce context right has to figure out
what the breadcrumbs are so that they
can do this thing make the change and
then once they make the change
they've got leave bread crumbs for the
next person that comes along and there's
a new mystery that needs to be solved
you know six months down the line why
this line of code is here is there the
developer do something clever they
understand something more about the
nuances of the system that he put the
score in or did he just not get it and
dizzily introduced about I mean we don't
know just by looking at it so the only
hope for actually doing anything at all
must be to try and communicate better
and that is you've got to make stuff
declare intent and formalism as early in
the process as possible now we've
started with the whole you know let's
not have a spec written in word let's
write BDD and do stuff because then the
spec becomes a live kind of document and
that's a good thing but that doesn't
really inform us about the quality of
the code and how the code is actually
going to degenerate over time because
when someone makes a change they are not
necessarily communicating everything
they can with the change and comments
not really help let's be fair about that
right so what does better really look
like we want to write systems that make
it easier to reason about the
application that we're building reason
about what we're trying to do and then
when you make a
the approach that you take and the chord
that you have and the platform that
you've built this thing on better make
sure that this change is done safely so
you don't introduce unnecessary
side-effects into the system the third
one's the most contentious you know it
should not involve a wholesale change on
what you're doing right now so this
isn't to talk about where I say you
should start programming Haskell you
should but not because of this or if
sure you should not because of this
right the the the need for the change it
is not special you won't get the
benefits that you want just by changing
wholesale everything that you do so what
we need to do is find a way to
communicate intent and raise the level
of clarity of what we want to do and
that's kind of the background for where
we are right now or what I want to do so
with that in mind let's build a bank
right I have only three business rules I
am putting on my custom and only three
business rules right a bank account
should have an initial balance of zero
it can support deposits of money without
limit when you deposits a certain amount
your balance will be increased by that
amount if the balance is positive then
I'll support withdrawal and you can take
some money out and the balance will be
decreased by the amount that you take I
don't think the requirements get any
simpler than that does anyone have a
semantic problem with those rules no
okay
so how do we build an application that
would do this now I don't know if any
hope you'll came to the talk we did a
three o'clock on Orleans and we talked
about the difference between stateful
and stateless and so on so forth so I'm
just going to assume that you're dealing
with standard best-of-breed
today and we're going to go with you
know building a service-oriented thing
or something so we'll build a bank
account service sounds reasonable
yeah so I have a bank account service
this is what my first rule looks like
when I initialize my bank account there
has a balance of zero and I've got to
save it somewhere so in a standard SOA
kind of thing this this sounds
reasonable and you want to have the
fundamental problems with this no good
deposit please will shout out if
anything's unreasonable right so we have
this concept of this now let's say we've
not just written this web service right
we've got TDD in place we've got mocking
I've tested the order this thing we can
do what we want to make sure that this
thing is running production stable but
we've had the party people have gone
home right and some junior guy is now
taking over the maintenance of this
thing and the first change request comes
in all its support closing a bank
account and here again two simple rules
a closed bank account shouldn't allow
you to do anything on it and bank
account requires a zero balance before
we should close it it's just simple
rules now when agile shop right so
somebody actually puts this card out
then there's a team that sits down and
figures out what you need to do in order
to make this thing happen again shout if
anything here is unreasonable right
you've got to create a property you've
got to modify all the existing code to
win it the test to make sure that
existing this are talking about closed
or non closed bank accounts then you
write all right new tests for the bank
accounts that are going to be closed
ensure that they don't accept deposit
and withdraw right modify the service
code and then add a test
to verify clothes then write the code
right any of this
am i forgotten something it looks good
fair bit of work but it's dead and I've
captured everything initialize what
happens if I bring a bank account in and
it turns out to be if it turns out to
exist but it's closed already
now a normal person would not have asked
that question but somebody was skilled
at maintaining this code would realize
hey this change is coming in this is
likely to come down the pike sometime
soon
so let me while I'm looking at the code
put a flag in you're saying something
else we may have to look at something
and the beer of course junior guy is
looks at the spec is is clearly says
that a closed account should not allow
anything right no I don't know the
reactivation the trusty old beard like
me and say ok that may change we'll see
what happens so then we say ok if the
bank account is closed make sure that we
don't proceed further and we do that for
deposit and withdraw and then we write
code what happens if you try to close a
closed bank account well somebody says
it should be an OP should be implemented
or by returning or should be implemented
or by just calling all the way through
I'm belaboring this point to show you
that a reasonable set of rules that was
very simple and clear to understand
leads to ambiguity with the best
intentions in play and this is the state
of reality now think about this when you
don't have everything in together and
you can see how everything is going to
just the entropy is just going into the
system and systems are going to fall
apart so
let's on the plane coming from I would
say this is the first source of pain is
because we started by trying to deal
with skin in the first place so in our
previous talk at 3 o'clock we talked
about our and we were all babes in arms
in you know cs101 we landed up going to
the school and they gave us this old
manual and they said everything's going
to be golden from now on you know we got
a encapsulation abstraction data hiding
inheritance and all of that not and so
we started writing code that embodied
all those principles we had controlled
access to make changes we had full
control of the object data in place what
operations are supported and everything
was self-contained and then we went to
ride our two machines and all of a
sudden you have to go stateless so you
put the guts of the thing the data in
the object in some separate store have
multiple services that stood in the
front of the thing and now the logic
lives in the service the data lives
somewhere else you call it separation of
concerns everyone's happy people write
books and all of that but in reality
what's happened is you invited a whole
bunch of really dangerous people to your
party and now you're trying to figure
out strategies to how to how to deal
with those people right so we gave up
controlled access and we got concurrency
headaches so now we've got you know
optimistic locking and all the other
joys that comes with that we give away
abstractions so we could get scale and
we give away abstraction by taking out
all the logic and putting it somewhere
else and then we have the elegance of
just doing the object-oriented Ness of
it and we we put in an ORM the OMS got
leaky abstractions everywhere along the
line it's not really an object you still
have to deal with this idea of
persistence and all of the other garbage
that goes with it so we have some major
issues
so let's look through the world through
slightly different lenses at the
right if I wrote the thing as an object
that's what it look like you know it's
got a banker and ID balance a
constructor a private property tells you
if it's closed or not methods to do
deposit withdrawn closed and just to be
correct I opened out what withdrawal
looks like and that's kind of exactly
what you do everything self-contained
you can't mutate balance without going
through one of these things all right
you have a hell of a lot more control
over what's going on and it's not likely
that the thing is going to go out of
hand easily everything all the changes
aren't in one place but I'm actually not
oh and the service for this would look
like this notice that all it's doing is
the is calling deposit on the object
itself and now immediately we've done
two things we've taken away the deposit
the business this account does not exist
business or the account exists already
is not really a concern of the object
itself it's a concern of your storage
this is part of the leaky abstraction
that's coming in why should the bank
account be worried about whether it
exists somewhere else
that's some representation of the
storage that's the problem here right so
by separating this thing out we've
already said that we're going to push
all of the storage related stuff out a
little bit and try and contain the
business logic inside of it into the
into the object everyone with this offer
you guys probably already do this right
so none of this may not may be new but I
want to point out these two pieces in
here I think this is the place in
Denmark it smells
there's a red bit and a green with can
anyone so from what I have for most
people be comfortable in this code by
the way and that's perfectly all right
I'm only trying to be a little bit more
nitpicky on it I think that the red bit
has something to do with the structure
of the object and
behavior and the green bit is about its
performance its capability what it's
actually doing to the data that it's
holding and I think those are two
actually separate concerns they're not
the same thing but given the way in
which we've built our object structure
in the languages that we use we can't
really separate those two I wanna
introduce two kind of big issue another
$64 one's the affordance and the
capability these are actually
representations of the two things the
affordances what an object allows you to
do to it and the capability is what the
object does to what the object itself
does and separating those two out I
think goes a long way towards helping us
understand what the system does a little
bit better right so let's rewrite the
thing as a table you know and you can
see that there's a form of the the
object that is in zero balance when it's
in zero balance I can close the account
at which point the balance stays
unchanged if it's if I deposit into a
zero balance it goes into a positive
Alun state and I increase the balance
and those are two different things those
are actually two different things so if
I do this and I try to map out the
affordance of it and the capability of
it the first thing that leaps out is
that you're not writing one class you're
actually writing a separate class for
each of the forms of the system but
you've only got the one object so how do
you separate the things out and make it
so that the object shape-shifts itself
into the shape that you want so I'm just
going to put this there I've taken the
table and I've just made it look like a
little different right does anyone have
a problem with the last four sections
can anyone tell me that that
last four sections different from the
table they're not they're actually the
same just reimplemented this piece in
with curly braces okay
in the meanwhile I'm going to take a
short digression now
I happen to be a big fan of our shop and
we have a way of modeling choices so in
in the world the f-sharp and the Haskell
in this color world there is a special
type of there's a special kind of type
that allows you to model choices and
those types are difficult to do in
languages like C sharp in Java you can
do them they take a lot of effort and
there's a lot of work that you need to
put in place to make that work properly
and there's a reason why we need this
because if you look at the set of things
that we want to deal with if you look at
the bank account object itself it's
really one of four different types as we
just pointed out there for independent
little pieces of work of little shapes
of of that object and in some sense you
can model that using Union types they
called Union types of choice types right
we also have a restriction kind of
situation now most most of you anyone
here to have have you used Java okay so
you know the extends keyword explicitly
says that a derived class is the base
class plus something the C shop guys
just used : and that that meaning is
kind of lost right an extension by
inheritance is a traditional
object-oriented concept you we need to
understand that well right but with
Union times you can actually restrict a
type as a subset of another type so you
know if I have three choices red amber
and green I can say that two colors that
represent when I have to actually break
and stop or read an amber I can actually
make that modeling choice so you need
restriction types and union types and
the announcement I have is that you can
now do this in sireesha
we actually have the
to do this this is not an official see
shout release yet but it's an
open-source project that I've basically
worked on and you can now start writing
stuff like that now with the end of that
digression we can go back to this and
look at it as a set of choices if you
look at the message a message is either
a deposit message a withdrawal message
or a closed message we know this
similarly the set of states is a set of
choices the set of events I mean set of
messages handled in each state is a is
again a choice type the set of valid
return values is also a choice type and
so by looking at this from a type and
driven perspective we can actually
generate the various shapes of the
object and put it all together and we do
that by basically building the class
hierarchy in c-sharp that looks like
that using a tool because writing all of
this stuff my hand is actually where a
good bit of pain comes from if you look
at the kind of work that you would
normally have to do you know traditional
web application a good amount of work
that you're doing is actually hand
rolling this logic implicitly into the
code and I'm trying to get it out so we
can make it as general as possible and
you can write say for example the shape
of a an active message handler only
handles deposit and withdrawal and it
has special types for its result and we
can generate all of that for you I'll
show you how it's done but it's just
move on how you inject the capability
though is exactly like this if you think
of the active deposit result as an enum
of some sort you can tell that it's
actually the sub it has only one element
in it which is active and depositing
money into an active account can only
leave it in an active State so the whole
idea of you having to cut and copy and
move things around and
and unfortunate state-transition
somewhere in your code is completely
eliminated by using this approach and
that means also that you don't have to
write the test to ever say I'm in an
active state I can never get to a closed
state because there's actually no way of
representing the fact that this
withdrawal function ever puts you in a
state where you are closed so giving you
the type safety goes one step further in
making sure that the changes that you
are about to make are going to be safe
and supported so what have we done we've
kind of dissected the system and buy a
little bit of sleep hand and hand waving
I've told you that we can declaratively
specify a state machine I may not be
worth anything right now but just take
my word for it for the next two minutes
from that state machine I can
automatically derive the types that
enforce the safety of the code that it
generates and the safety of the code
that you will have to write in order to
make that work and doing that has
removed a great deal of hand written
boilerplate logic that you would have to
do to handle the if cases you know the
read bits that I showed you earlier all
of those are taken away out of the
equation even remove the entire classes
of tests were ensuring that transitions
that cannot happen cannot be represented
and then by decoupling the capability
and affordance you are only limited to
handwriting the capability piece the
affordance part of it the shape-shifting
se aspect of the solution is actually
taken care of by the compiler the
compiler of this new language and of
course once we're done with that we can
actually take a look at the FSM and
realize that it's just a representation
that we can analyze by ourselves so for
example we can say hey we're looking at
this state machine you are never going
to get to that state
it may have handlers in it but it's no
longer needed in the code so how many
people have looked at existing code and
wonder whether function is actually
being used anywhere oh whether we are
capable of just blindly removing this
block of code because it doesn't seem to
be hit anywhere and tests don't fail
because I can remove it and then it goes
boom in production because somebody's
still got some old ways another thing
that runs and puts it in a an illegal
State this will remove entire classes of
that kind of analysis and make it easy
for you to reason about the changing
shape of your object because you've
declaratively put it somewhere where
someone can reason about it also
infinite loops when I receive this
message and it goes into that state that
state moves to another state and another
state and another state and then the
only way to get back is to go back into
this so you're now stuck in a loop
that's got five or six messages in there
you can't look at that by looking at
code and deducing that easily it's just
not possible to do that you can't expect
somebody to do that and so you come up
with novel ways of actually testing the
thing and doing all of that all of it is
complete nonsense because you can you
can evaluate the shape of these states
well before you even generate code for
it to tell you whether you're going to
have a system that will have an infinite
loop in it
so by doing all of this we're actually
you know and and the last one is most
important is we guarantee that if you
change the set of something it changes a
type which means something is going to
break in compile time which means you
have to deliberately go and look at the
impact of your change in its code in the
code before you can actually ship it
again which means that you can write
code with some level of certainty that a
change that you made to the behavior of
something was dealt with deliberately as
you went through the whole development
process so the cost of doing this of
course was that we had write our own
language to do it
I'm very simple I'm going to dive into
Orleans now but does anyone have any
questions so far
is anyone still awake excellent all
right so let me outline Orleans in a
slide and and my co-presenter Sergei
here will probably look at it and wonder
if you must talk to me again
so basically to put it in very succinct
terms Orleans is object-orientation
across machine boundaries in object
orientation you have an object you deal
with it by through a reference the
reference happens to be an address in
memory in Orleans you deal with an
object or a reference happens to be
hidden from you you deal with the
reference in memory that object could be
anywhere in the cluster but the
programming model is literally this that
it's that simple that's really what I
want to leave you with the salient part
of it it's basically a traditional
programming paradigm you call messages
on it everything is built-in with
asynchrony because you know distribution
is involve involves asynchrony we
embrace that right from the start right
Orleans will take care of your object so
think of it as garbage collection in the
cloud it's got that so base and the one
thing that's very interesting is that
Orleans will guarantee single-threaded
access to members of its object so you
don't have any concurrency headaches so
you just remove the entire concurrency
problem decorative persistence allows
you to save the object state in in the
cloud on the disk whatever storage
platform you want so it's entirely
possible for you to write this thing and
deal with it you know at terabyte scale
without having to leave the principles
of object orientation that you learnt in
CS 101 I think that's a very compelling
proposition but I'm about to make it
even more compelling at this point
anyway when you could run at scale and
then we write an idiomatic seizure so
it's all familiar stuff no one's asking
you to do anything funky if you want to
do it now have you can you do
after at all the you can do all of this
f is a shot
what we do is we take this FSM and and
generate the code for writing an Orleans
grain that has the shape-shifting
behavior that I pointed out earlier
built into it and that's what I'm going
to show you right now right so let me
see I'm going to we will see that all
right the first stop point of call is
God is the visual studio marketplace
this tool already exists it's up in the
registry marketplace if you got Visual
Studio 2015 you can download tool and
it's um it's inversion point eight at
the moment but it will get improved the
codes in github and I'm not connected
that's the code in github I'll give you
all these things but basically that's
what it is and the c-sharp Union type
stuff there is is there as well as I
mentioned earlier so what we will do is
we'll fire up this video
sorry
can everyone see that do you want me to
zoom in further cool so here's a bank
account which we knew about before
whatever they specified we specified
that it has an identifier so this is the
objects handle that we're talking about
right we're going to operate on the
balance we're going to process these
messages cynically in that state these
are the four states that it can be in
the handler speech of those so I'm going
to take the second and there's a custom
tool that comes when you install the v6
and you install the nougat package to
get this reference and we just save this
file and lo and behold the code
associated with each of the states and
the Union types and all of that is
written in code that you can actually
debug so you can put a debugger in this
if you like to figure out what the heck
is going on at some point in time right
and I would assume that by the time you
get to the point we say it's five
hundred six lines of code and if you try
and look at what's actually being John
it's a fairly complex piece of work but
you didn't have to do any of it and the
net-net of that is that you can generate
a partial class and it'll tell you hey
I've done all of the hard work for you
please
what am I gonna do one of us and it
tells you that in the overrun state I
can only do a deposit and if I try to
return anything other than something
from overdrawn deposit result sorry
hey I'm just going to look at this I'm
showing you this enum the overdrawn
state basically allows you to go from an
overrun state to an active state or a
zero balance state it does not let you
go to closed which is the rule that we
said earlier when we handling an
overdrawn message the only thing I
should be able to do is put a deposit on
it and depending on how much I deposit I
should be able to either stay overdrawn
if I didn't put enough money I'll go to
0 if I put in exactly how much I owed or
go to a positive State if I put in more
so it's not even possible for me to
write a state here that's my mistake
closes the account and the reason why
this is possible is because of that we
hold restriction type thing because at
the end of the day the state machine
message handler still has to return a
state a real state but I need a subset
of the set the set of states for this
specific purpose and that's kind of
where the restriction types come in if
you didn't have restriction types you
could not make this strong guarantee
that you can you know if it was just an
enum and you return something you could
potentially return anything you wanted
it's because this is a restricted type
that you're able to make the strong
guarantee that the transitions are all
well understood right from the start
right anyway so here's an example of the
Union in place and to give you an idea
of what I what it takes to implement the
Union that's what it takes to implement
the Union so there is a reason why
nobody writes Union type since Asia
because for a single item Union it takes
45 lines of code and most of its
boilerplate and they will get pretty old
pretty fast and you probably cut and
paste stuff and it'll be draw and make
mistakes but a compiler like this can I
think do the work now if I went in and
actually read the business logic we
could make sure that
this thing could actually be testable
and run also the individual functions
here are actually so well constrained
that you almost never have to mark
anything you know there's nothing to
mock it say put the bank account in the
overdrawn state and then try to make
this this change to see what happens you
already put in a condition in the
conditional state where a simple unit
test will suffice so by using an
advanced technique like using DSL to do
this stuff we can actually make things
much much more efficient and much much
safer right now I'm actually done with
the orléans part of it and with with the
state machines part of it I anticipated
a bunch of questions and if there's
anyone who's really interested in
figuring out how this stuff works I'm
happy to show you that as well so it's
over to you guys
any questions from anyone on anything so
okay so basically there's a there is
there's a concept of an algebraic data
type okay and then algebraic data type
basically is a way of building bigger
types from smaller types there are two
ways of doing it
and c-sharp people we only know of one
way which is we create a class or a
struct that has a bunch of properties
and if you think about it the
cardinality of that set is actually the
product of the cardinality of each of
the members so those things are called
product types union types are the dual
of that they are the sum and as far as I
am aware c-sharp doesn't have a road in
this roadmap a way of putting union
types in there but if you have some
types million types together you can
build up a type algebra that's actually
pretty expressive and you can actually
restrict a lot of issues you can make as
Scott lashes input set you can make
illegal states
representable which is kind of the
example that i have it's not possible to
actually model a failure case and make
the thing compile it's impossible to
actually get into that state so in terms
of the relationship c-sharp itself
doesn't have union types it this is a
visual studio tool so you can actually
run it with visual studio if you want
there is also a command-line tool in the
in the v6 package that allows you to
basically run I'm sorry in the nougat
package that allows you to run against
the FSM file manually and generate the
code so you don't need Visual Studio to
run with this it's just that it's a
convenient because every time you make a
change the visual studio engine will
kick in and actually generate the code
for you right but it's basically written
in such a way that you can pretty much
run anywhere including water and stuff
we have
okay does anyone want to know how this
works you want to see there so the
secret behind this is actually a whole
ton of f shop so I'm probably going to
lose a whole bunch of people maybe I'll
end the talk here because they are
videoing it and then we can talk about
you can show the code later or put
everyone want to see their tool does
everyone want to see it okay
okay let me finish the presentation and
with this formal acknowledgment so let
me yeah so I have to acknowledge a lot
of people who helped me to get this
across the line
Ascot lash and of course is the huge
influence on a whole bunch of things I
have colleagues I haven't told in mark
and George who basically maybe they're
pausing and getting the rest of it going
Sergey of course in an invaluable
resource as far as the orderly inside of
it goes and I work for Microsoft and
they've graciously let me actually
present here so I'm actually presenting
on behalf of Microsoft so thank you to
them and those are the links if anyone
wants them and I'll make them available
to you later as well we just hit 50
minutes ago so I've got five minutes or
so cool let me just fire this thing up
Oakley
so the actual work required more to
create the DSL and to PA's it is
actually very very small indeed
so this is the language representation
internally where I have identifies and
datatype names and elements and blocks
and messages and so on and so forth
and I built that using a Basel II 50
lines of code that actually walks
through the text and causes the elements
out into the object and then I analyze
the validity of the thing because you
don't want to have transitions to states
that don't exist in so on generate code
that doesn't compile and the state
machine itself has these properties as
you can tell you know this is how I
build up the various pipe names and so
on because I use Union types I can
actually directly use the class
declaration of the Union type itself I'm
just using the Union type as a library
and this generates the code so here's
actually the constructor of the Great
Green Green State class and gets
injected into the into the thing so if
you look at the green state class which
was in but if you look at the grain
State class this actually generates the
audience but basically says that it
means a grain State it needs a grain
interface and so on and so forth and
each of those things so the grain
interface which basically looks at the
various methods it's actually this piece
of code so each piece of the code
generation doesn't look like much and
that's one of the beauties of using F
sharp for this because it's very
succinct then you can actually all these
funny-looking things that you see here
are actually Roslyn calls and you don't
recognize it as Roslyn because I hidden
all the ugliness hue and do something
that makes it look like something that
it actually will generate so for example
in this case I generate an error method
that calls through and has the type of
task
of the data type name which if you look
if you remember the code that I wrote is
exactly what was generated out and so
there's more of that and we eventually
just generate code using awesome means
that's kind of how it works for the
questions confused everybody what mark
Simmons looking very pleased so I'm
happy yeah what is yes
correct I've dispensed with the
pleasantly of making F sharp being able
to call that deal natively so the C
sharp one is actually separate from
their sha-1 oh yeah yeah for sure
actually so that code is actually not
here it's in the C sure it's in the it's
actually in this in the C shop do types
a different project entirely but
actually deal with that and use pattern
matching to do a whole bunch of stuff so
the types are actually fully closed
you can't extend a deal even though it's
written in C sure nothing else
oh no no no so why are liens so the most
important thing stems back also there's
there's several pieces to answer the
problem right the first one is this when
you write an interactive system the
whole idea of the shape-shifting Ness of
the object and removing the capability
and the affordance and big coupling
those two that's kind of a very
important property and so it's an
approach for doing the development that
I don't really like now another thing I
really like is to be able to be able to
build applications at scale easily using
the same kind of principles or
principles that allow for that kind of
affordance and capability deep
decoupling so because it is easy you
have taken a problem that is interactive
in nature and made it an object-oriented
problem and then I've taken the object
or in paradigm that's exposed by Orleans
and it's just a natural fit to put the
two in place but any other
object-oriented system can also be
generated you know the language the the
DSL is language agnostic so pauses
language agnostic the code generator is
positive hmm it's the only thing that
generates Orleans you can quite easily
plug in another code generator on the
same ast in fact what I wanted to do if
I had the time before doing this talk
was to process the ast using a graph
mechanism so I could just draw the state
machine out and it's very easy to do
that and basically it opens out the
ability for us to write code that is
easy to reason about because we're
talking about it at an abstraction level
that removes ambiguity about its
behavior and that's really the key piece
and this whole thing is trying to
promote and lift and declare the intent
in such a way that we can actually
reason about it without having to dig
through the code so so there's its
audience because Orleans is the most
elegant way of actually building that
Torian scalable approach but you can
definitely apply to any other scenario
that you want
you know you kind of need the restricted
pipes because if you don't you have no
way of actually modeling valid
transitions the valid transitions piece
the safety type safety and the valid
transitions piece is kind of the thing
if you look at the state machines out
there all of them effectively take I'm
in a state I take a message I go to
another state there's no way to tell
that the set of states that are going to
is a valid set of states you can only do
that by modeling it as a type problem
and saying this set is actually a
restriction of this set and that's a
very critical difference in this
approach every other day every other
projects in so far shall we break early
cool thank you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>