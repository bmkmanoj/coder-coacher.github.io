<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional C++ for Fun &amp; Profit - Phil Nash | Coder Coacher - Coaching Coders</title><meta content="Functional C++ for Fun &amp; Profit - Phil Nash - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Functional C++ for Fun &amp; Profit - Phil Nash</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tc9CDdJmoWE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hello everyone thank you all for
coming
so welcome to functional C++ for fun and
profit I think that there's at least
free talk to this conference with the
for fun and profit so at least one of
them going on in another room right now
in my defense I did choose this title
for a reason I'll come on to that in a
second but just introduce myself first
of all I'm bill Nash some of you may
know me as the author of the catch test
framework as on this mug here you can
have a look at others but more recently
I've also got a job at JetBrains
some developer advocate for their C++
tools it's a sea lion cross-platform IDE
to C++ app closed for Mac and iOS
development and resharper C++ like
individual studio so I'm not gonna be
talking any more about those today so
what this is about but we do have a
booth down the exhibition also come see
is there you haven't done all done so
already so we're going to be talking
about functional C++ as we said and
about that title the for fun and profit
bit the reason I put that in there is
because a lot of material on functional
programming even functional programming
in C++ it's becoming increasingly
popular these days tends to have a much
more academic slant to it you know
interesting stuff that says you if you
like functional programming or curious
about this as interesting to read up on
but not necessarily that practical for
real-world code but everything I'm going
to be talking about today is based on my
real-world experience in a real codebase
in my previous job mostly which was at a
bank on a coin library so you know quite
a large scale legacy seed LastPass
codebase they've been able to put these
idioms to to very good use in tool I'll
touch a little bit more on that as we go
through but this one had went to size
that real-world quality to it so we'll
also go off in a check off in a slightly
different direction to some other talks
that you may have seen or other articles
or will draw on material from other
talks and articles and right at the end
I'll post some references to to some of
those as well so let's get started and
actually want to start
just by defining what functional
programming actually is because it may
not be exactly what you think it is so
before I do that just take a moment to
think to yourself what you think the
functional programming actually means
what's the core concept that it all
stems from you may be thinking of
something like first-order
though the first class functions or
higher-order functions the name
functional programming implies that or
maybe immutability purity referential
transparency maybe even monads all these
things are important terms to be sure in
functional programming you could drop it
like a tag cloud of functional
programming concepts they'd all be there
right right close to the center but not
the silly right at the center that's
what I want to get up and I want to
start there and see where they go from
it and what I'm going to do is go to
pull up the Haskell wiki which you know
it's a reasonable authority on these
matters and it defines functional
programming like this says that
functional programming I'll highlight it
actually functional programming is a
style of programming which models
computations as the evaluation of
expressions that's the interesting bit
and be further down the same page says
in functional programming programs are
executed again by evaluating expressions
in contrast with imperative programming
where programs are composed of
statements which change global States
when executed functional programming
typically avoids using mutable state
there's a few interesting things to
unpack in just a few shall very simple
sentences there we haven't gotten into
any of academic stuff we're just pitting
evaluation of expressions against
statements and we know that C++ has
statements and we're going to cover that
in just a moment why that doesn't
necessarily stop us from writing
functional code but what does this
really mean what does it mean to
evaluate expressions but notice also
that it ties it in with changing global
States and functional programming we
offer
say it's free from side effects when it
when it's pure and side effects in
mutable states tend to go together we're
going to unpack that a bit more as well
but doesn't also say at the end at
functional programming typically the
voids using mutable state doesn't say
they entirely avoid fact that will be
impossible over different levels of
abstraction is going to be running on a
CPU that's there's going to be mutating
so to some level but also just in terms
of getting anything done cure a
functional program that doesn't mutate
any state at the level is operating at
would just make your machine run warm I
see any effect it would really have so
we need needs ability in order to get
stuff done
it is useful functional programming is
more about controlling where that occurs
and making sure that's explicit and
that's something we're going to totally
bring out during the course of material
so I want to drill into this idea of
expressions a bit more in a way reframe
the idea of functional programming as
expression oriented programming
I will plug at this thread and see where
it takes us so let's have a look at some
typical C++ code that we've also
statement so here we've got you know a
point of this screen because I can't
point it all three at once here we've
got a variable there Carlos obviously
Nina of some sort and what we're trying
to do here is give it an initial value
dependent on some other condition I'm
using a statement to do that here so
we're calling a function does really
matter what it is or what the condition
is just that in order to now give our
variable a value depend on that
condition we're doing it within the
statement and that statement is acting
like a sort of a firewall for values if
you like the only way we can really get
the value out of the statement is by
using an assignment here so we're
mutating your values and therefore it's
a side-effect it's pretty much the only
thing we can do within a statement and
that's why right right at the beginning
we said that statements imply mutability
and so the antithesis of functional
programming so this is not very
functional at all and as a result it has
a number of problems
in such a small simple piece of code as
well as that assignment
we've got mutability there there's a
result our variable has to be non Const
we'll come back to that in a second
but also has to start off with there's
an uninitialized variable because
recovery to give it a meaningful value
that's our we could add one we could
give it some sort Sentinel value perhaps
or we could give it say one of these
values and then only set it so the other
value given the condition that would be
okay but it doesn't really express what
we want to do which is to just say the
initial value is one of these two values
depend on this condition that's really
what we want to say should be simple the
statement is making that hard in fact
impossible and going back to the non
constable the real problem now is
actually much trickier to see because
we're so used to non-comp in the default
in c++ and most mainstream languages in
fact but consider what happens in the
rest of the globe when we don't know how
much code is beyond this but in the rest
of that code in order to reason about
what the value of color might be we have
to consider every line of code that it
could possibly go through if we really
want to to read about it we don't do
that typically what we do is we sort of
you know hope based on conventional or
expectation but it's not going to change
somewhere else and then we'll end up
debugging after the fact of that
assumption doesn't hold true that's our
typical approach to this but it doesn't
have to be that way if we can start off
with using immutable values not just
Kant's but actually immutable then the
whole class of complexity that we've try
to pretend this in there that actually
is it just goes away that's incredibly
freeing and you can see now that this
statement is stopping us from you being
able to do that so what can we do about
you just for a moment let's imagine that
c++ was an expression oriented language
a true functional programming language
then it would allow us to do something a
bit like this so now rewritten it with
this veritable version of C++ so now if
is an expression rather than a statement
so now rather than within the statement
having
to rely on a side effects it does
evaluates to a value the value of it
where she wanted so the whole expression
the whole list expression evaluates to a
single value we can use that value now
to initialize our variable as we wanted
give it that value right at the start so
we can make it Const as we wanted and as
a bonus we can now use type inference as
well
we didn't even ask for that we got that
for free so that's great so that's
exactly what we would want and that's
exactly what most full functional
languages I know of gives you and once
you start writing code like this it's
really hard to go back Factory is an
example from one of my favorite
functional programming languages f-sharp
apart from some little syntactic
differences that's basically exactly
what we were trying to write in F sharp
that's exactly how you write it well we
can't do that in C++ now I have this
superpower which is I can read minds and
I know exactly what you're thinking
you're thinking actually you can do this
in C++ you can use the ternary operator
and yes you can do that here we can use
a ternary operator to achieve all of
those benefits that we just talked about
so what's the problem well first of all
a lot of people don't like the ternary
operator or maybe you've got a style
guide that's ability from using them or
or at least advises you not to and there
are some downsides to them in terms of
things like readability can very easily
get formatted correctly or you try to
use too much nesting becomes very
unreadable you have to be very careful
of operator president ii should nurture
if you up quite easily but if you're
careful if you keep it simple this sort
of code I think is absolutely fine in a
good use and I tend to use this sort of
code all the time where I can so that's
not actually the problem the problem is
that it just doesn't scale right fine to
this simple case but or what if you got
little more than one condition
so you know here I'm using a switch
statement with three cases we don't have
some you know hard coded way of doing
things like the ternary operator
so what can we do here we got back all
those original problems again what can
we do about it well I said earlier there
was no way to get the value out of the
statement without a side effect and
actually I lied that there is one way
and it's ironic lis using another
statement the return statement
see if shift that switch statement into
a lambda expression we can now return
out of it
so we will capture the variable coming
in do our switches normal return out of
it and you clear the bottom and pointing
to the screen again we're immediately
invoking that lambda expression in some
other communities as actually a name to
their CD is called be immediately
invoked lambda expression or immediately
invoked function expression
I think that's first became popular in
JavaScript so I remember rightly do it
C++ as well and that works actually that
gives us all of the benefits that we
were looking at earlier with the
expression oriented version this is a
way of psyching expression int
programming in C++ so again what's the
problem well the first thing you might
think is it's a bit of a heavyweight
solution for a simple problem now
bringing Landers in but we didn't
actually need them well this is actually
less code than the previous imperative
example mostly because in this case
because there's a switch table to get to
the break keywords but the point is it
is actually less code we don't have to
worry about it being more typing maybe
if you did that's not necessarily a bad
thing
so the next thing might think of these
for what about performance we've now got
this function call overhead
we've got things being returned out
their functions and surely there's going
to be a performance here but you
probably also expect any decent compiler
to optimize that away and in fact I did
check with visual C++ and GCC check the
disassemblies projects on on god bolt
against a number of different versions
of GCC and clang
and all of them gave identical code to
the imperative version for this
particular example since the last time I
did this talk the month ago now I made
that same statement someone came to me
and they said oh but I tried this ever
example and it could produce more code
so it's not guaranteed and if that
performance really is critical then then
you may need to still profile or be
careful but as a default using this
approach shouldn't give you any
significant issues and in fact again
this is a simple case just involving
basically integers if the state variable
here was actually more complex this may
actually be more performant because
you're given the optimizer more scope to
to optimize things you're going to
return by the optimizations for example
that can come into play so you may
actually get a performance improvement
because of this because the things that
make code easier to reason about to
humans
also make it easier to reason about to
the compiler the optimizer so the more
declarative will make the code the more
spoke there is for that sort of
optimization so that's another thing to
bear in mind functional programming in
general is often issued because we're
we're worried about performance
penalties but actually the opposite can
be true again always measure because
it's not always true so that's if
statements and switch statements loops
are also statements in C++ so what do we
do about those we've got much the same
problems again the statement accident
threw a value firewall we could use the
same sort of techniques but actually the
real problem with loops is we don't
really want to be writing low-level
route loops in the first place we have a
number of facilities in the standard
library for raising the level of
abstraction of our loops which allow us
to write things in a more functional way
I wouldn't necessarily use for each
these days if you are reaching for that
there may be disarrange base for loop is
what you want what you really want to be
reaching for were the more specific
algorithms transform and accumulate here
these are all examples of what we call
higher-order functions so they're first
slightly academic word and it just means
any function that takes some sort of
callable object like a function and/or
returns a call of an object that
therefore Leeming so these all qualify
and in fact this was I thought the
complete list from the standard again
after Mike the last version is talk
someone pointed out the worst law that's
not important the important thing is
I've highlighted the ones at the top for
a reason
standard transform copyist and
accumulate loosely map on to the
functional concepts of map filter and
reduce in by a third of technically
accumulate debatable villus reduce or
more accurately less fold but it's in
the ballpark these are roughly
corresponding functions so they're very
important functions in the functional
programming world unfortunately the way
the standard library is implemented the
SQL in particular they don't quite work
the way you would want to use in a
proper functionally function functional
programming style we'll come back to
that a bit later what we can do about
that but for now release the subject of
loops I'm going to move on to another
section and I'm going to now sort of
build up a bit on this idea of trying to
maintain immutable types we looked at it
to single values now when I look sort of
more aggregate values and calling this
section the Builder pattern you think of
it more like a sort of extended
constructor that's where the word build
is coming from sort of some similarity
with the factory method it's not exactly
the same thing either so where this all
starts is if we want to build immutable
types in C++ we can do it but it's bit
noisy so we're going to sprinkle
everything with Const because console is
not the default console is not
transitive so we need to put it on
things we've pointing to as well and
those objects themselves and they need
to be mutable because if they have
noncoms well you know the drill
it's a pain but we can do this so we go
to the trouble to put in words comes
from and now we find well we can't
really write a a default constructor
most of the time so in fact I've deleted
it here just to be clear that we're not
even trying
because we're going to always have to
construct one of these in fully valid
state because we can't you take it after
the tax obviously you'll notice that
there's there's other methods on here
either
if you think of this is like a typical
domain type so I chose an employee here
to try and represent that idea you
wouldn't use it for through all types
but in this case I think it's it's a
reasonable approach the reason we don't
have any additional methods here is a
lot of methods we might add to an object
for all to do with encapsulating the
changing of state and if you can't
change that state then you don't need
those methods to maintain the invariance
so there's certainly no setters they
wouldn't make sense though getters
because well this is the collection of
values we can just make them all public
that's always the right approach but
more often than not it is once once you
sort of free of mind of no years of zero
baggage so with any getters and setters
we don't need any other mutable objects
method sorry but there may be some other
methods you need better depends on your
types but very often didn't need any so
we get these simple Delaine types it
just expressed the data we're moving
back towards this time where we separate
the data from the behavior opposite
direction of our own so that's where
we're starting from
now to create one of these well I
haven't added the constructor because
now we can just use member wise in is
realization most new feature going C++
11 allows us to dis initialize each
field is this
there was a constructor there for us so
that's great we can do that we've
constructed it in the fully valid state
and often times us as far as we need to
go but in the real world it's never
quite so simple then a typical large
complex code base
clickity thinking of the type of
codebase I was working on in the bank
you'll get all these dependencies
between objects they'll try to represent
me here but with this person and address
object we've got to get them from
somewhere they've also got to be built
as immutable types we're going to go
through this process for all of them
though we can't do all that manually but
we start then sort of thinking back
about what we're losing because if we
made employee a mutable type we could
progressively build these objects up as
we get these objects in so maintaining
immutability wind that we've code like
this where we've got to build up all of
the fields ahead of time so that we can
then populate our mutable objects so
effectively replicating the structure of
our object of our class outside in local
variables like we're doing in all that
work twice and we're going to do that
every time we construct one of these so
it does start to feel like we're you
know working against the grain a bit so
what can we do about that well just
noted that we're effectively replicating
that structure again anyway so let's
just formalize that a bit and put that
into another class so I call this one
employee builder that's why called the
whole pattern to build a pattern you can
see we've got basically the same fields
again this time they're mutable but only
the first level so the the personal
address they're still they're still
Const because we've got to get those
from somewhere else still but now we can
actually progressively build this
objects up I've also put this build
method on there so that's not essential
to this pattern I just found it really
useful because it just gives you one
place that packages everything up and
produces the correct type you could put
any validation in there as well and that
saves you having to write constructors
and your your built object if you want
to keep them pure and clean again under
that's really essential so go back to
the code that built it up now we still
have a little messy stuff but you can
see now we're declaring our employee
builder at the top we're progressively
populating that as we get values you'll
notice we've got dependencies between
values here so they need to find the
person before we can find the address
so all that's taken care of and they're
finally at the end once we're ready then
we say build and we get a built object
that seems simple something so simple
that if it were wife why even bother but
actually what have we achieved here
we've now got this really clear
separation between this sort of mutable
phase where we're building something up
and the then immutable phase where we
can using that value in the rest of our
program so we actually use in the type
system to enforce those boundaries which
is really a nice property so for this
point on enzyme you see this employee
you know you know that's not going to
change but we haven't given up all the
conveniences of immutability either and
this idea of delineating these are the
mutable and immutable stages it's really
fundamental to a lot of functional
techniques where we want to still get
the benefits immutability so for what
else we can do here again leaning on my
experience my previous role what we
found was sometimes some of these values
we don't even have at the time we're
trying to build this we might need to go
and fetch it asynchronously so simulated
that here by saying contacts but maybe
that's a fund for a database we're going
to go away look it up so I've got this
highlight that it's called sore whites
here hopefully co-routine to make this
simpler but we'll be working with avi do
this for some time I think so we're
passing the person that we got in the
previous steps and then we give it a
lander that's going to get called back
when it actually has the value so first
of all notice that I'm using generalized
Lander capture to move our builder type
into the lambda so that's another
advantage to using the Builder type
rather than just this massive local
variables is we can just do that move in
one go just it's a convenience but it's
a nice property and we vacillate the
lander mutable because that's the way
c++ works but yeah it works is it's
actually quite a nice way of
doing this sort of asynchronously
building up the graphs of object objects
so it's difficult to convey just on a
few slides of some toy code how this
really works in a large-scale software
code base I've used it to a good effect
if I haven't convinced you of this just
remember that pattern of separating the
mutable and immutable places which you
sometimes see referred to as the the raw
and cooked phases of the values because
we're going to build on that and in fact
the next section we're going to start by
take a little detour but it's going to
come back to this point we're going to
talk about strings and you may wonder
what reference counted strings has to do
with functional programming bear with me
so it's talk about a fast and safe
reference counted string and if you've
been around C++ for for a while you may
recall that originally the original
design of standard string was such that
it could be implemented in a reference
counted manner then most early
implementations were but there was a
problem with that and that's a standard
string has a mutable interface and
mutability in reference counting then
mix very well so we have to go through
some contortions to make that work so we
use a technique to show you're familiar
with called copy-on-write where you
gated of course to to cow so hence the
visual so I'm sure you know how that
works but I'm just going to recap
briefly to to set the stage so we have
our actual string here as a buffering
memory and then our logical strings have
got freedom here pointing to the same
buffer sharing that and then increment
in this reference counts I've got a
reference count of 3 there simple so far
and then we come to make a mutable
operation that saved the third string
needs to mutate it's it's copy so at
that point that mutable operation checks
the reference count sees that it's
shared and says I need to make a copy so
a new copy to that point hence
copy-on-write so now we have two buffers
one with a reference count of two will
move a reference count of 1 sure that's
just a recap for you
but there's a problem with this and
that's that well first of all we have to
protect the reference count either using
some sort of mutex or make it atomic and
back in the early days of reference
counted standard strings the Atomics we
had if we had them at all one
particularly performant would come along
a bit since then
so between that and the fact that you
can accidentally trigger these just by
calling a mutable method even though you
didn't actually need to mutate it meant
that we we really suffered on the formal
side because of this so much so that
well we found out that caravans like a
dog that was the first reason that we
decided to addition but it was actually
a second in many ways more important
reason which is that you can actually
get into a situation where you had these
shared strings and you maybe you've got
iterators into them and then because
some other string has wheat ated and
taking a copy you can end up with
invalidate edo phrases and first version
of the standard actually allowed for
this
it was illegal and so we were able to
write these reference count these
strings but C++ 11 change that real bad
out so you can no longer implement a
reference counted string in C++ and be
conformant and actually have any benefit
at all which I believe is the main
reason that GCC eventually moves away
from reference counting strings because
one of the last holdouts so Sander
string now is typically implemented
using the the small string optimization
which is going to find the
general-purpose but now if you do have
lots of copies of strings it's much more
wasteful of memory as well as the
copying overhead but if you remember
back to when we first started talking
about this we said the problem was
because these strings have a mutable
interface so if we started with an
immutable string design then we start
with the same situation we've got our
shared butter could our reference count
and that's it we're done
we don't have the mutability causing the
problem
so this worked works absolutely fine
except there is a reason that standard
string has a mutable interface and
that's that we do actually sometimes
want to mutate strings so can we have
our cake and eat it
can we achieve what we want with mutable
strings while also maintaining all the
benefits of this design the answer is
yes again there's two ways the first is
a lot of cases can be handled now by
string of u so u + + 17 or you can roll
your own quite easily about one for
about seven or eight years it's pretty
easy to write and they just allow you to
have non owning copies of a string but
you can also change the where in the
string you point to and how long it is
so you can have sub strings so as long
as there are no non-overlapping
ownership issues that can be a really
good solution for a lot of cases but
when you really really do what actually
wants and you take the string in place
then go back to the builder patent so we
have a specialized string type record
here string builder and string builder
is now optimized to mutability only
meant to be used in that raw builder
stage so yeah we can mutate it in place
we can make the buffers smaller we can
we can realloc to a bigger buffer it
does have a reference count there's
always one we never actually touched
that in the string builder and the
reason we have the reference count at
all is because once we've got this
string into the shape that we want then
we can just detach the underlying memory
but typically by using a standard move
our very references into one are very
mutable string types you know we
transfer that ownership in so now the
immutable string owns a memory string
builder no longer does so it can't
change it so it's now safe we can now
freely share this around as before we
can take additional copies we'll
increment the reference count so it's
only when we take the additional copy
that that reference can't even gets
consulted so that's quite nice
well then sometimes we may want to take
a string that we've been using immutable
in somewhere and it still make changes
to it and we can even handle that so
we've got any an immutable string if it
is shared and we take a copy into a
stringbuilder
then it will have to copy the butter so
this is basically like that points in
copy-on-write where we we have to decide
except now we're making it explicit in
the code you're actually passing it from
one site to another you're in control
you know exactly where that's happening
but if it's not shared then we can move
the the memory from the immutable string
into the stringbuilder that's not
technically immutable then because we
are changing the string but that's in
according to the well understood
semantics is of no semantics and C++ so
he choose to do that that that's safe
within those constraints and what I
found was my previous role well we had
one of these string string builder pairs
this particular pattern we sort of use
once or twice in the whole code base
almost all of it was building the
strings up to begin with and then using
them immediately so that cost that we
have to play there that we were playing
and copy and write we really had to pay
at all we've got all the benefits for
free and almost none of the downsides
that's why this is a fast and safe
reference counter string all by
concentrating on keep them now they'll
use immutable using those builder stage
types and just to be absolutely clear
this is like a view of the the lifetimes
of our our strings so moving from the
the raw string builder stage into this
completely safe sea mutable stage that
we can we can share around freely if we
need to then go back to a string builder
and then from there we can move back
into into strings again so we control
when we transition between those types
that that's really the important thing
here so that strings and strings in a
way are just a special case of a race so
your by a score can be apply same ideas
with array types
the simple answer is yes we can and
again my previous role we did have for a
builder's and array views and that sort
of thing and immutable arrays but
they're not quite as useful in the
general-purpose sense because our usage
of arrays tends to be a bit different
we tend our very big arrays quite often
we do tend to mutate them in place a lot
more so we are not paying the cost a lot
more so that they weren't quite so
useful we ended up using vectors a lot
more instead where it gets more
interesting is more complex structures
particularly associative data structures
because we can do a lot more there and
what I want to talk about next is
something called persistent data
structures so this is another idea we've
borrowed from the functional programming
world and just to be clear about what a
persistent data structure is when we say
persistence we're not talking about
writing to a file the database so that
sort of persistence it's the sort of
persistence where when you have some
some value some data structure of a
particular value and then you take a
mutation on that the old value still
persists so what you were you typically
doing is getting a new mutated version
of it and you still got the old one
which you can choose to hang on to if
you need it or throw it away but that's
the underlying principle so a naive way
of implementing these will be to take a
complete copy of that data every time
which would work but it'll be very
expensive so the trick to persistent
data structures is to share as much of
the underlying representation as
possible and you can do this to a
greater or less extent depending on what
the data structure is so to illustrate
what I mean take the simplest case which
is a singly linked list so truly know
how singly linked when this works but
again I'm just going to really quickly
refresh on that so we have a number of
nodes each contains a value and a
pointer to the next or previous
depending which way you look at it node
in the list it's important that it's a
singly linked list because if you have a
doubly linked list if doesn't work
because what you can do next is well if
you want to add a new head to our list
then all we need is the new node with a
pointer to the previous head and the
important point here is the original
list which can still persist still exist
doesn't know anything about the new list
the new list only knows about the
original one that's the defining
characteristic so typically we would
have some rapper class say list that
will have the pointer to the first
element so we'll have a new copy of that
and we could do the same removing
elements just have now a pointer to an
earlier node instead we can you know
pile these things up to be kind of
multiple instances of our list with
different values through memory at the
same time all efficiently sharing all of
the common state all the time you're
doing operations at the head at least
it's a very efficient way to do if you
need to do operations further down then
it becomes less or less efficient
progressively and so you could hold a
release in memory at once at fairly low
cost but if you're not interested in
Bilbo's you can just let them go with
its reference counted or using garbage
collection they'll just disappear and
you're left with final lists as if that
was what you created in the first place
so that so it works for a linked list we
don't tend to use lists so much in C++
mostly because we'll see that the points
are hotting and all the cache misses
they're not particularly efficient for
our purposes these days the bread and
butter the functional programming world
for this reason but we don't sense use
them but we can apply the same
principles to tree based structures so
take a clip of a simple binary tree like
this one here so we got all these values
in a strictly for during so each node
has two pointers now instead of the one
in the list left and a right and in
order to find a pointer the node we just
go down comparing the values and if it's
less than go left it's greater than they
go right again I'm sure this is
fairly familiar now if you got want to
enter a new value into this tree then
we've got to find where to put it so
which reverse down the list to find that
we can either put it to the right of the
free or the left of the five there I
will simply add it to an existing lease
we should always be able to do that so
we can add that to the foot to the left
of the five so nice and simple and if
this was a typical mutable tree then
we'd be done job done but if we want to
make this desist n't and immutable we
can't do that because now we've got to
write our pointer in to be the five note
there and can't mutate it so we have to
take a copy of it and then write the
pointer into the copy instead so we
effectively invalidating that node but
because they've done that we've now got
to do the same for its parent for seven
and all the way up to the root we
validated all those nodes up to the root
so similar to with the list if we are
mutating elements further down the list
but now we don't have to touch any of
these other branches in the tree so we
can still do that relatively efficiently
so we did that and once we've done that
since we've got a new root the old value
from the old root still persists
we've still got that around we have a
new tree with your sharing all of the
common state well not all of it because
we're that to invalidate some additional
nodes now but most of it it's important
point so that's quite nice but that's a
simple binary tree which has a few
limitations and to illustrate the the
biggest of those limitations if you try
to load one of these things up with
sorted data then you could quickly see
that you're going up with a linked list
down one side or the other it's not
going to be very efficient so we came up
many decades ago with lasers
automatically rebalancing these trees in
an efficient way and believe the most
common one that the we tend to use today
is the red black tree I'm not going to
go into it in a lot of detail but just
to whiz through these are the rules
the root note is black the color is
arbitrary really just a way of
characterizing these notes already knows
our black children you leave the red and
all paths in the route of the same
number of black nodes don't need to try
remember that that's not that important
but I will illustrate what effect that
has when I tree so if we now go back to
our example we're reading our foreign
but now this is the red black tree which
might be kind of like this to start with
so we put our foreign as a red node
because that was the sorrel all new
nodes are red attached to the five but
now we invalidate the the red node
invariant that all red node should have
black children so what we do when we
apply these rules we always consider the
parent node grandparent note in any
uncle notes so just looking at those we
just have to recolor them so now the
four is a child of a black node so that
works at least in that group but our
looking further up we've invalidated the
red node invariant server up between the
three and seven we've got two red nodes
again
so we just apply the same rule going up
in this case it's just read coloring all
the way to the root in some cases that
you mask and shuffle the nodes around as
well and actually when you get to the
root we've got a red root now again the
root node should always be black so we
could just recolor that and now the
invariants about having the same number
of black nodes in every branch that
holds it's that invariant gives us the
the rough balancing by the way because
it means that the tree can never be more
than twice as deep on one branch than
any other given branch so that's fine
let's say the specific rules are not
that important what's important is that
now in order to do that we've had to
touch all of these notes you can see
that ones I've highlighted so not just
the ones on the path to the root but a
few sort of collateral nodes as well
we've also been touched so you can
imagine what that means for persistence
we've now got to copy more notes so we
can do that again you can make this work
I know because I've done it
but there's this extra overhead you can
mitigate that somewhat ironically given
what we've said about strings by using
copy-on-write
so you can measure in all of these nodes
are reference counted then as you come
down the tree to find the place you want
to put it in you just keep a track of
where nobody shared or not if a node is
shared then you consider what it's
children to be shared but if you're
mutating a node that's not shared then
you can afford to do that in place so
when you're first building up these
trees you can actually do most of the
operations notably before anything
outside you can see it so there's our
raw vs. cooked stage again
so that actually mitigates a lot of
overhead what we found was with our
implementation loading up and loads of
financial market later we had a roughly
10% overhead on insert with our red
black tree compared to standard set
which we found quite acceptable what
wasn't too bad so that'll works and in
fact if you look on Wikipedia under red
black tree it does say the red black
trees are also particularly valuable in
functional programming where they're one
of the most common persistent data
structures used to construct associative
arrays and sets which can retain
previous versions after mutations so
exactly what we talked about and but the
benefits of having one of these
persistent data structures by the way
there's actually a few of them one that
we have a refreshed on yet but is what
most people are interested in is with
concurrency because now when you insert
something into one of these sets you get
a new root and nothing else changes so
if you've got one place in your code
that holds this this root node you can
do an atomic swap on that well use your
compare and swap there may be a loop
around it which means you can get the
fairly trivial lock free implementations
of these things fairly safely exactly
what we did with great performance
benefit but also another thing we did
just leave being financial data will be
running scenarios against different
versions of our market data with small
mutations at night
and with this technique we were able to
hold all of these big data sets in
memory at once knowing that most of the
common state was being shared and that
was that was a really nice property as
well but ultimately the most important
benefit is it's much easier to reason
about the code when you know exactly
which points do involve mutations again
with strictly controlling where we allow
the mutations to occur so we only use in
those places that we benefit from them
and not anywhere else and that's that's
really liberating so that was red black
trees and we could stop there most
people do but red black trees aren't
necessarily the most efficient data
structure and C++ we're always looking
for the most efficient ways to do things
on me so what's what's the problem with
red black trees well the problem is that
the trees get quite deep and I teach a
verse down the tree you're doing lots of
point ops again more cache misses and in
fact if you loaded up one of these these
trees we've say 15 million items you're
going to get a tree depth of about
twenty four nodes deep I sell a lot of
pointer hops to look up every every item
in the tree and the reason that the
trees get so deep because we've only got
two pointers in every node maximum of
two in fact so you can see there's
obviously a limit on how wide it can be
so the solution then must be to read
more pointers and in short yes it is but
that raises two more questions now first
question is how'd you know which pointed
to follow into traversing down with the
red black tree for the simple binary
tree sister case you're comparing the
value less less then or greater then
left or right what do we do here
well what we can do is
laughter Mia click the hash of the value
and we look at the first say five digits
of the hash we get a number that number
is now an index into an array of
pointers simple so this gives us 27
there gets us to the next level down the
next level down we then look at the next
five bits could be six if we want to 64
bit 64 elements array don't got another
value another index into this array
gives us the next node and each node is
now either a branch node with one of
these arrays in or it's a leaf node with
value or set of values as it happens so
this is what we call a 3 TR ie more
commonly associated with we've strings
like a string dictionary where each node
you use each letter in the string or
each character in the string rather to
to say which which pointed follow next
here we're doing with a hash parts of a
hash so we call this a hash tree so that
that's the part of the solution I said
there are two problems the other problem
is as you can see here most of the time
most of the elements in this array are
null maybe have a few pointers at a time
so though we've got 32 available slots
we're not using them all but would
obviously seem to be quite wasteful of
memory if you add up all of these nodes
it can actually be very wasteful so what
can we do about that that sounds like
the ideal place for using some sort of
sparse array so it would typically do is
we store it into gel which is a bitmap
for all the set bits being the indices
that contain the pointer and the on tip
bits of the null ones and then we just
saw a compact array with only the
pointers at a set then all we have to do
is just for any given index we just
finally The Associated bit and count all
the set bits from that bit and to the
right and that tells us the index into
the compact array now doing that
counting the set bits is itself an
interesting problem I'm not going to go
into here
in fact I've done another talk on this
C++ now just a couple of weeks ago which
is just come up on YouTube so they'll be
linked to that at the end while I go
into my complete implementation of this
go into more information there but that
now gives us a nice efficient
implementation of this in fact this data
structure is more space efficient than a
hash map and is approaching the same
level of performance or what you end up
with it's ever like this so now you've
got a tree with some of these that only
have two pointers that you can have up
to 32 pointers of each tree you go down
you consult different parts of the the
hash to get down to the root and there's
also some interesting properties now so
for start the maximum depth of this tree
if you're using five bits of the hash
each time there's going to be six or
seven depending on whether you include
the last two bits from the 32 that's
doing a lot less than our 24 bits out
earlier in fact that example with 15
million entries will have an average
tree depth of 5 that's significantly
better than the 24 in the red-black tree
because it's hash based you're going to
get hash collisions so the the leaf
nodes will actually be an array of nodes
array of values sorry which can IV do a
linear search on if you're doing the
hash hash map or you can actually do a
binary search on those well to make it
even more efficient as I said it's more
space efficient in the hash tables the
complexity technically is a log 32 lens
which is an unusual one in practice I
found that for most I'll use say it's
very close to sometimes even exceeding
the performance of the hash table and
really nice point compared to red black
trees you don't need to rebalance it
does assume a good hash distribution to
start with receiving that the tree
effectively balances itself according to
the hash distribution because you use in
the hash in order to construct the
structure of the tree so you don't need
that rebalancing step it's much more
shallow so the copying overhead compared
to red black tree is also much less
which means it's ideal for making
persistent much simpler
and more efficient to make assistant
than a red-black tree we've almost the
performance of the hash table it seems
like the ideal data structure for our
purposes in fact if you watched my total
column I do exactly that case so this is
really nice it's called a persistent
hash array Maps tree to give it its full
name watch that talk for more
information I think I've just got time
for the final section we're going to
switch it up a bit now and we're
actually going to talk about another
data structure that's we've now gotten
C++ 17 it's probably the simplest
container you could possibly think of so
of course I'm talking about optional
sure you're familiar with how optional
works so basically it gives us the
ability to say we've got a value or no
value at all without having to resort to
pointers or Sentinel values but in
practice the way we use it it looks like
a pointer so we can test it for true
Venis it can be reference it which will
get the value out if it has one or throw
an exception if not so we get small
improvements over pointers there but
it's a shame that they haven't put more
the semantics around this to to make it
safer to use but there is one method
that that it does have as useful let's
see the value or method this allows us
to effectively coalesce value so if our
optional doesn't have a value at all
then use this default instead which is
nice that's quite a common use case
unfortunately slop that general in
particular I mean here with an integer
is fine but though there may be some
cost associated with constructing or
calculating the buddy you want to put
here you don't to pay that cost if
you're never actually going to use the
value so it'd be nice if instead of a
value here you can put a lambda but it's
sense enough to write your own helper
function so here's a helper function
I've just called a value or again but it
takes the optional is its first argument
and then a lambda there's a second
argument and all it does inside is check
the optional if it has it use that if
not
returns the results according the
simple and now we can write code like
this some that haven't really taken
advantage of it here still returning
just the content into jet but now now
we've got lambdas here we could actually
go off we could call a database if we
wanted to and it would only do that if
we needed to but we're still written it
in a life compact and expressive form so
that's the first little improvement
let's talk a little bit more on this
thread because in this case we're doing
something only if the option doesn't
have a value we can do it they'll be
around as well I've called this one with
another helper function it takes a
lambda and what we say is if the
optional does have the value then call
the lambda passing the dereference value
along and this is the start of making
usage a little bit more a little bit
safer so now in our example usage we're
using a dereferenced type suggested
integer here we have a net to do to do
referencing ourselves so there's no way
that can blow up on us that's all been
relegated to the helper function but
then the lambda will use the ironic
thing we can only do side-effects here
now we've made this into a sleepin by
only there doing something with the case
for the optional has a value but we can
fix that simply enough we just returned
an optional of the same type in this
example so now I'll and also returns
over an optional or the value itself and
if we didn't have a value then we just
return an empty optional never got value
semantics we've made this into an
expression so rather than doing
something in a lambda we are
constructing a value that we're
returning out so the return value here
is also an optional and of course now we
can we can chain that with other calls
but one little limitation here and
that's that I've made this return an
optional at the same time to keep it
simple it's baby steps but we can take
it a little stage server bit of
simply boilerplate that you can write
once and forget about to add
opportunities the type is not already
optional we can now use devil type to
work out what the return value of the
lambda is whatever that is we're going
to return an option of that type okay
so internally the rest of its just the
same now they can use different types
just by returning a different type from
a lambda so in this example at the
bottom we've got an integer coming in
there converting it to a string long way
around and we're returning a string so
what we'll actually get is an optional
string coming out the other end but
because we always returning an optional
like I say we can chain these together
as well so in this example let's code at
the top the same but we're starting
right in the middle the middle is we
passed our original option into it and
if that has a value we execute the inner
lambda this close multiplying by to
return the result of that so if we still
have a value then the outer width gets
executed at the last lambda which has
one it's called simply enough this is
actually composing it's a functionality
that's a nice property but it's not
particularly readable and unfortunately
C++ is not very good with functional
competition so a real functional
programming language that encourages you
to write code like this will have a wave
effectively inverting this flow so that
rather than writing inside out like
we've done we will push the values in at
the top we write like a series of
operations and the value pops out to the
bottom now can't do that in the general
case in C++ but we can't do something
specific to this case and all get to do
is change our helper function to be an
infix operator this case I've chosen the
pipe operator because reminds me of
mutex pipes now with that one change
look at how this affects the code so
same example as before now we can see
the option of going at the top because
the first operation gets the form the
second operation it gets performed
optional drops out at the bottom and we
can construct some quite complex
pipelines here in some comparatively
simple code it's a more complex example
look at our strengths aversion in there
there's this is interesting the second
line that's doing a filter because we're
only going on if the value that we've
unwraps out the first optional is
greater than 10 so some of those values
may they still end up with an empty
optional and we'll skip the remaining
stages if you're starting to look really
nice and in fact there's another
property about this which is that apart
from that returning an empty optional
for the filter there's nothing about
this code at the bottom it has anything
to do with optionals all we're saying is
we've got some value coming in and I'm
going to do stuff with it where it gets
that value whether it's wraps in an
optional or a pointer or a vector or a
future whether that values coming from
we can apply these operations to it
those two things have been affected
we'll start to write different helpers
for those different cases but we can do
that it's a very general pattern that
leaves a very composable code that
allows us to separate concerns out very
clearly especially we're writing things
in a very expression oriented way so
with all those factors and a few others
that I brushed under the carpet what
this gives us is a monad over optional
it's called the maybe monad usually I'm
not going to discuss what a motor
actually is but this is a good example
of one and if you want a slightly more
general example you only have to look at
it needless ranges library we did a talk
cpp con 2250 no think I think it was
that's us on YouTube if you haven't seen
it I definitely recommend you go and
watch it if you have seen it I recommend
you go watch it again
because it's an amazing mind-bending
talk and what he ends up with you work
through this demo of building a calendar
on standard out actually here's the
output so it starts off with a range of
dates and he ends up with this being
printed standard out now think of the
complexity of that layout code there but
this is not the entire code but this is
what
all the pieces together and in fact all
the rest of the code is to extend early
very expressive I believe that there was
exactly one if statement in the entire
code base no loops and basically no
meter did't II think we'll see the
upshot of that so we've used the same
pipe character to to compose these this
piece of the functionality not all of
these are magnetic some of them are most
of their close to we're going to be the
subtleties involved there but to give
you a nice idea exactly how composable
these things are look at this this one
in the middle which is chunk free if you
look at the output again exceed there's
there's three months across well it
could change that to two that it will
display out two columns instead that's
completely separate from all the rest of
that that code is completely orthogonal
it's a really nice property that's why
people get so worked up about monads
from the functional programming world
because it gives us the ability to to
write our code compose our code and
reuse our code in these sort of ways
that is really nice and once you
understand what's going on really
readable and expressive so hopefully
that's open your eyes a bit too to the
plow there now things a good point too
to recap what kevin Henny said about
monads a lot sure when he said this
exactly that's I'll let you read that
one he actually did a talk on functional
C++ here I think a couple years ago
anyway I think we're getting close to
game so I'm going to wrap up this is a
summary of what we've talked about if
you remember we started off discussing
or expression oriented programming once
and why that's significant how that
leads to local reasoning on may not have
even mentioned that term but that's
that's what we get when we can read it
about variables and values in isolation
without having to consider well the
other code all that complexity involved
we saw how this implies the need for
immutability where possible but what we
also need to allow mutability just
control
that we have to help build the types can
help us to to manage the explosion of
complexity in our code as a result of
that we extended out into business and
data structures that can help us with
collections and the finally we just
looked at monads we've be the maybe
monad / optional hope that's given you
some ideas of some things you can join
your own code bases is that all of their
staff see stuff that I've used to go in
effect so it's a good place to finish
thanks for the listening on my my
website level of indirection comm
reloading read that flash storage /f CPP
reps by HTML my second photo all the
references to two other talks and
material you can find there
it's me on Twitter still underscore Nash
that's it thanks all for listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>