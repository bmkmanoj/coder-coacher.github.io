<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>I put 7 years of meal data in Datomic - Here's what I learned - Christian Johansen | Coder Coacher - Coaching Coders</title><meta content="I put 7 years of meal data in Datomic - Here's what I learned - Christian Johansen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>I put 7 years of meal data in Datomic - Here's what I learned - Christian Johansen</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ORQ2qs8GHsQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so thank you for coming to the Late Show
my name is Christine Johnson and I will
be talking to you about the atomic today
so who has heard about the atomic for a
few view so the atomic is a fairly new
one several years actually but it's a
new wish database that has a lot of
unique and quite interesting features
it's sometimes referred to as a
append-only database so it only
accumulates data over time it never
deletes data unless you explicitly tell
it to and it has an interesting
architecture that allows you to
independently scale reads and writes you
can query historical data you can query
across multiple databases and it has a
really nice and flexible schema of at
the bottom so hopefully before you leave
this room you'll have a working
understanding on what they Tomic is and
what you might want to use it for so my
name is Christian Jensen like I said I
work as a developer for school to market
which is a consultancy here in Oslo and
my experience with stay atomic is
somewhat limited
I learned yes last year so like my
abstract promised you some juicy details
on my dieting habits so I I have a text
file I've been maintaining for seven
years with my family's dinners so last
year I decided to put that into a
database so I could gain some insight on
what's going on like trends and stuff
and then since January of this year I've
been working with this company event
enno which has built their service on
top of stay Tomic so I've actually now
worked with it on a daily basis in
production for six months so I I know
means an expert but at least I've worked
with enough to have a working
understanding of how to use it well and
and where it shines and what some of the
limitations are right so that's me this
is the atomic logo I I'm a hands-on guy
so I like concrete stuff so I'll be
showing you I'll be focusing on the data
modeling capability
is of stay tonic and the practicalities
of working with it as a developer and
I'll be doing that against the live
database with some queries and so we can
explore it together that's the way I
like to do things but before I do that I
think it's interesting to discuss the
architecture a little bit because it
differs quite a lot from most databases
you've probably ever used whenever you
tell someone that they atomic is a
append-only database it never deletes
data
invariably the first question or remark
back is like that doesn't scale who has
can afford to keep all their data around
forever right and this is one example of
a system that does that for you and
people use this without hesitation right
and even I read that Microsoft recently
put a 300 gigs of code in to get so you
can't have this historical model and
still have it scale and I also think
that if you've used a system like it for
any amount of time you will understand
that having this history history of your
data at your fingertips is about more
than simple backup like we'd get you
have your entire history of your
codebase at your fingertips and it's
fast and reliable you can find
information and you use it for more than
just backup right you can use it for
experiments by creating new branches
where you speculatively apply some
changes if you like them maybe you
commit them back to master you can go
back in time to look at what happened at
a certain date if you find a problem in
your code you can run tests against your
code like through time time-traveling
and it can help you identify where the
problem occurred and all kinds of
interesting stuff that you can do simply
because the data is there get them
delete all your data for you and the
atomic offers this model for your
database your production data so imagine
you create some new feature that tracks
behavior over time then all of a sudden
all the existing production data is
available for you to test with there's
many interesting applications of
destroyed data and I'll show you a few
examples for my work
later so this guy's this is rich Hickey
he designed the atomic and he also
designed closure the programming
language so who here has heard about
closure okay good so one of the stated
goals was to design a database that that
breaks free from limitations of four
years ago so most of the databases we
use today were designed during the 70s
and while there were many great things
that happen during the 70s especially in
the prog rock scene and also in the
computer science area that the hardware
back then really was something different
than what we have today so the atomic is
an attempt at designing a modern
database for modern computers and this
is basically how it's built up so at the
bottom you have the storage service and
the atomic innovates under the database
design but it doesn't necessarily
innovate all the individual pieces so
storage is handled by existing solutions
you store your actual data with the free
version you store it on disk using a
hibernate h2 database on the local
filesystem with the pro or the paid
version you can store data in react or
cassandra Amazon DynamoDB and pretty
much any sequel server out there and the
atomic does not store your data in a
database format that we just use as a
database like a database would use the
file system stores just blocks of data
inside us but that allows the atomic not
to worry about this persistence which is
already a pretty solved problem on top
of that the atomic runs one of its two
most central pieces which is the trans
actor the trans actor is what you would
think of it's a traditional database
server except that it only handles
rights that's all it does
this trans actor has nothing to do with
queries or any attempts of retrieving
information from your database and this
design allows you to scale the right
part of a database independently from
the reads
so you can have long-running queries
that will not hamper your ability to
process transactions the trans actor is
interesting for a few more reasons it's
the atomic is a single writer system so
there's only ever one active trans actor
running and that's you cannot have any
more and this is how the trans actor
delivers acid transactions and it
handles isolation by simply processing
transactions sequentially so you pop
transactions on the queue in the atomic
process them one at a time the blue
shading on the box here indicates that
you can have a standby trans actor so
you can actually have two trans actors
going but only one of them are going to
be active the other one is for high
availability so when you want to
retrieve data you do that from a peer
process and a peer process is
essentially read only database that runs
inside your application process if
you're on the JVM so the atomic is
implemented in enclosure and it runs on
the JVM and you can basically run the
database as part of your application
platform process on the JVM and the peer
process is the one that's processing the
queries and retrieving all the data it
builds up a cache it builds indexes and
it there's always needed for you to have
efficient data retrieval from your
database the peer process will read
directly from storage and it will also
receive updates from the trans actor so
whenever someone puts something into the
trans actor the atomic will assume that
recent data is probably going to be read
back so it's strange that data to the
peers if you're not on the JVM I'm sorry
I should mention this if you're running
multiple application processes and you
don't want to pay the memory fee for
each process you can run a memcache
cluster for a shared object cache now
because the atomic is append-only
it has a immutable data data structure
for all this data so there is no need
for cache invalidation in this in this
architecture the peer server is an
alternative if you are not on the JVM or
for some other reason you don't want to
run the the peer inside your application
process and it's basically the same
thing except that it exposes an HTTP
REST API so you can talk to it and then
you will find client libraries for a
multitude of languages which can talk to
that HTTP API so the example that we'll
be showing you here today will be with
closure with the peer process running if
you're going to use it from some other
language it will be similar but the
actual API will be slightly different
and I would also say that the peer
server is a it's a full-featured
alternative to the peer but the pair
gives you probably the best experience
because it actually bolts the database
into your application that means that
you can do queries and data retrieval
with basically no network overhead at
all because it's all local to your
process okay so let's start is the font
size readable to you guys okay
so first of all I want to talk about the
data mollette atomic cache and data is
model in the atomic much like it's model
in RDF so in RDF you talk about triples
you have an object predicate and I'm
sorry subject predicate and object and
they sound like you have an entity and
attribute and a value and this thing is
called a fact so the atomic only stores
facts it's the only data type it knows
about and an entity is in practice just
a number it's an ID of some thing and
then you have an attribute which is a
closure a keyword if your language does
not support keywords it will typically
be a string and then there's some value
exists so this is very much like RDF and
like I said the entity is usually just
an ID at least technically it is
conceptually and the entity is an ID and
all the attributes associated with that
ID but in addition to these three parts
atomic tax on two more pieces of
information here and the first one is
another number which is the ID of the
transaction that created this fact so
whenever you put facts into the atomic
it happens part of a transaction and
that transaction is also an entity which
has metadata about it and then finally
there is a boolean at the end here which
tells the atomic whether this is an
assertion data being added or if it's a
retraction data being removed from your
database so let's say that this was the
first transaction only inserts one
attribute for one entity if I wanted to
change my name this would look like the
following in the atomic you would have a
new transaction with two facts and there
would be a new transaction ID here and
then first of all it would remove the
old value and then it would set a new
value this is how datum the atomic
Mull's changes at the basic level I for
you as a developer you would just set a
new value and then the atomic will
actually create it two facts for you so
this is all you really need to know
about how they distort the atomic stores
data and we will see this again when we
start talking about queries in a little
while okay so what about schemas
whenever you use an attribute to store
something in the atomic you have to use
a named attribute that has been defined
ahead of time so a attribute looks
pretty much like this you give the
attribute a name and then you have you
set a type for that attribute like so
string and then you have to tell data
the atomic what's the cardinality of the
attribute is and the cardinality tells
the atomic that what to do when you add
this attribute to an entity the
carnality can be one or many
if it's one then writing this attribute
will overwrite the existing value if
it's many then it will keep adding to a
list of values and then there are some
other things you can tell do as well you
can say that an attribute is unique you
can have it specifically indexed and a
bunch of other things but this is like
the gist of it okay so before we get
into the data retrieval we need an
actual scheme and some data to look at
so this is one of my dietary habits come
into the picture so this is a this is my
database that I told you about earlier
so this is an emacs org-mode file which
has been working on for seven years and
it contains like for every week like on
a Saturday I will plan what we're going
to eat the next week and I put it in
here and then for some reason I just
kept it going and I have lots of data so
if you go to the bottom list file
literally like shopping lists and
budgets and it was very ambitious at
some point but it's now it's just meals
so I created a schema to hold this data
and I'll just walk you very quickly
through it so we can have some example
queries when I run on it so I defined
some users okay I forgot to say one
thing the attributes you specify you
have to specify each attribute you are
going to use but what about the entities
like the person entity the answer is
that the atomic does not care about
entities at all the atomic only cares
about attributes so what attributes goes
with what kind of entities is up for
your application to decide so in the
atomic you cannot say that an entity can
only have these attributes or it must
have at least these or this one is
required whatever that's all left to
your application this might seem like a
weakness at first but it's actually a
strength and it allows your schema to be
flexible and grow organically over time
and also because the atomic keeps
historic record of all your data if you
if you would add a new
attributes how will that apply with the
old ones and so on so and another
interesting aspect with this is that if
you do like I've done here is called its
users and I have a user name like you
can see here and a user email and then
you use the namespace part of this
keywords and you can indicate what kind
of entity it is this is similar to a
table style designed in a relational
database system but the strength here is
that if you have an entity that could
have a hundred different attributes but
most entities only have like five or ten
then the atomic can efficiently store
that because it does not have to store
nil columns right so you can emulate a
table style design with this but you can
also store data in a graph if you want
to want to do that and the same entity
could have and entity attributes with
different namespaces and it's really up
to you so but I've gone for a fairly
straightforward table like design here
or that's the intention at least
so there's users there's a group which
is just a bunch of users typically this
is the user system is me my wife and the
group is our house no that's it and then
there are dishes and the dishes the
thing that you put on a table like
Lavanya and it's it's the abstract
concept of the dish and then a dish is
realized by a recipe so the reason I
went this way I wanted to be able to
tell how many times if I had Lavanya but
from these like 20 different recipes so
the details of this schema is not really
that important but you can tell here
here's a important attributes recipe
slash dish so this has the type of ref
and that means that the atomic will
enforce that this attribute can only
ever hold IDs of other entities in the
database so this is a relation that the
atomic knows about
again it doesn't care about what kind of
entities there's only ever like one kind
of entity but it will ensure that you
make valid relations between your data
and whenever you're designing
relationships there's always a a problem
deciding on which end of the
relationship you want to model it if you
want to have recipe dish or you want to
dish recipes if you fall and the atomic
makes this decision very simple because
no matter where you put it you can
navigate both ways of that relationship
which I'll show you very soon okay
so then in my app I also have some seed
data because I started with a bunch of
manual data not very important let's get
on to the querying part okay when you
want to retrieve data from your database
if you're in the relational database you
are handed a hammer the hammer is called
sinkhole queries and you use that hammer
to insert data into your database to
retrieve data from your database and to
solve logic puzzles about your data like
who's the most popular eater of
vegetarian food stuff like that you use
queries for all this in the atomic you
are you have more fine-grain tools so
like they already saw right is handled
by another process altogether so if you
think about stuff like sequel injection
if you were to ask about information
from the atomic about little bobby drop
tables he could never drop tables in
your database because the writes are
handled by another process entirely but
then again there's even when you're
retrieving data there's different
mindsets sometimes you know about a
thing I know about this user I want to
know where does it live and other times
you want to solve like puzzles and the
atomic ask queries for the latter thing
but for the first thing there's two
other api's that are easier to work with
so okay this is closer apologize it's if
you're not very familiar with it but
hopefully it
it's going to work for you so first of
all you require the atomic API so this
is the peer API that I talked about
earlier you can also use this from Java
or any other JVM language and then you
have a connection that I made up front
so this is just a connection to my data
to my data database and to pull data you
can use the entity API here and then
you're going to pass in something really
strange which I'll discuss very shortly
and something else here okay so this is
a not very spectacular at this point it
was hard for you guys to read okay so
what's happening here the entity API
retrieves an entity from the database
like it says and the entity is
identified by a unique attribute so
whenever you've said that a attribute
can be unique you can reference it
directly like this you don't know you
don't have to know what the entity ID of
this thing is you can use an unique
attribute to identify and what is this
thing you're passing in here well the
connection is a connection to the that
trans actor that you're the database is
running but you don't run queries on the
trans actor you run queries on the
client and you have to run the queries
on a view of your data so if you
remember when we looked at this so your
database is basically this part it's
just a collection of facts and by
default it will contain all the facts
ever created in your system but before
you ask for information from you you
have to define some kind of view because
as I told you earlier if we have these
three facts then I only actually need
one of these facts to know what the name
of this person is and the DB function
here provides you a compressed view of
all the text in your database
represents the current state and it does
that at some point in time and that
point in time is exactly when I call
this function it gives you an immutable
value back which is your entire database
at this point in time with the current
information I will show you in a little
bit that there are other views you can
gain as well to access different kinds
of information so this entity function
here it returns back to me the recipe
but it does it does represent that with
a lazy map so it doesn't look very
fantastic right now but we can ask it
for information like what's the variant
name of this recipe okay something like
this what kind of dish was this and then
you can so this is another entity that
I'm getting back so now you can lazily
pull information about this entity into
your process and with the relational
database you probably would not want to
go this route because you would have the
n plus 1 queries problem which is you're
paying the network cost for every time
you want to access an attribute with a
Tomic you don't do that because the
atomic creates indexes that are stored
in blocks in the in the underlying
storage and whenever you pull out one
piece of fact is going to pull out also
1 to 20,000 other facts along with it
and if we're accessing attributes on the
same entity after you've accessed the
first one there's a good chance that the
rest of them are in memory in the same
process so this actually works quite
efficiently and most of the time when
you when you know who you're talking
about you just want to retrieve more
data about then you can use the entity
API there's no query symbol to do that
ok but there are also queries so let's
take a look at those and I'll get back
to the other kinds of database views
later
so queries are run with a queue function
and in the atomic you have a language
called data log implemented
like I said initially the atomic does
not reinvent the things that it doesn't
need to reinvent and datalog is one of
those things so that allow comes from
prologue originally and it's implement
is here for diatomic I'm not going to
give you like a thorough explanation of
all the syntax but I will tell you to
notice one interesting thing so here
remember I told you about the facts at
the atomic store they look like this
there's an entity and attribute a value
a transaction and whether it's being
added or not in data log what you can do
is to declare relationships between your
facts and then the query processor will
just solve the logic puzzle and give you
back everything that matches and you do
that by specifying question mark in a
name to put in place holder for four
values and you can realize other kinds
of values so for instance I could say
give me the entity that has the recipe
ID that we had before this one and then
I don't care what transaction and I
don't care if it's being added or
removed I just want all the facts that
talked about this entity in this
attribute with this value and again you
have to pass in a database to run the
query against and what it gives you back
is a list of ID's that matched this
thing okay so that's the very basic
query most of the time you don't want to
inline concrete values like this so
instead you would say here's the ID and
you would provide it as an input to the
query and when you do I have this weird
thing here which is the explicit
database argument and what this might
tell you is that if there's one database
here maybe I can put in some more
databases into that same query and that
you most certainly can okay then you
pass in this value from the outside and
what you achieve with this is that the
query
Scizor can cash this query in the
efficient manner so basically the same
thing we had before okay moving on when
you have trailing underscores like this
you can just rely them for a more
readable query not that one okay but
let's take a look at so this is a
basically the description of a datum or
fact and you can have as many of these
as you want and you can cross-reference
variables to connect various facts so
this one has a transaction associated
with it let's first just start by taking
a look at it
so now I get two ideas and this is the
ID of the transaction that could be
rested the ID on this thing and the idea
of the transaction but like I said
before the transaction is an entity in
its own right and also has attributes so
we can get those as well and the one
that the atomic creates for us is the
one called VB sorry D BTX
instant and this is the time the
transaction occurred okay so I'll call
that TX I and I'll pick that one instead
and what what I'm getting back now is
the ID here and the time that this thing
was created and you can see that it was
created in 2011 and I just explained to
you that I put this in the atomic last
years when you initially fill data into
your database you are allowed to
backdate transactions the only thing
that the atomic requires is that the
time is monotonically increasing so at
the very first time you put that in
there you're allowed to backdate but you
can never put data in that is older than
your newest data if you fall and usually
by default they tell make a little
handle time for you okay so that's good
most databases nowadays typically have
or like tables and relational databases
would have an updated ad and they
created as attribute in in in their
tables and database the atomic Soulstice
for you and this is basically what I
showed you here we can write this query
a little bit different I can say okay
give me the entity that has this ID and
do not get the transaction from there
but I do want to find all the
transactions that pertain to this entity
so I'm using this first fact to identify
the entity and the second one to find
all the transactions that are about this
entity then I can get the transaction
instances back and this is where this
database is becoming a poor example
because it really only have my initial
data loaded into it so I'm going to
create a simple database so we can play
with the time aspect here okay here's
another one I have to have a connection
I do not okay so we're now just going to
create a new database create database
and then the atomic and this is just
going to be an in-memory database which
will be gone when I kill this repple
this is just for demonstration purposes
but this can also be used for tests if
you want to test your code so now I have
a database I have to create a connection
for it so I connect to that same string
like so and then I have to have a schema
before I can put data into so we use of
transact function comm and then it takes
a list of either facts or entity maps
which are collection of attributes so
I'll create two two attributes for this
test person full name which will be a
string Oh
string and there will only be one this
is the one we created before and one and
we will have another attributes which
will be person email which will also be
a string so the atomic offers a few data
types that you can use but they're not
very finely grained so you can number
strings there's a UUID data side you can
put in there and a few others but this
one is a string as well and then
cardinality and this will also just be
one and we'll make it unique points
identity and this enables absurd
behavior for diatomic so whenever you
put in data about something with with an
email if the email exists from before
you will update the existing entity if
it's the first time you've seen it it's
being created then it gives us a bunch
of information back I will get back to
the two on top here but the TX data here
are the actual facts that were created
as part of this transaction finally
there's a map here of temporary IDs and
this number here was not explicitly
available in my transaction but if you
need to insert two entities that have a
relationship to each other you can
generate a temporary ID to use within
your transaction and then the
transaction result will tell you what
entity IDs they were actually assigned
when they were created so that's what we
can use this for anyway
I have a schema so we can transact them
data okay I will create a person with a
full name of my name and my email like
so okay so we can tell now that the ID
was given here so I can make another
transaction for the same entity I'll
show you two ways to do that the first
one is to use two dB
function I will add this entity and then
set the full name attributes to my full
name that's one way of doing it like I
said because the email address is now
unique if I write to this thing again
it's just going to update the existing
entity so I'll just do like this okay
boom okay now I have three transactions
in my database and I've created one
entity and change this name twice you
will see that the maybe you don't see it
but the ID here and here and here are
the same so let's take a look at this
entity in the database now entity DB con
and then here and then we can do such
poof okay this is what this entity looks
like currently if I perform another
transaction we will study the other
result here like so and then you can
tell here that the atomic is telling me
this is the database before this
transaction and this is the database
after this transaction so those are
alternative views on all the facts that
we can use for querying a database right
so this rest is okay so now I can say DB
before
that's a atomic DB okay let's pull out
the entity from that one is that entity
here touch and then instead of using
this database sorry we will use DB
before from the rest and then I can see
that this is my old name and if I ask
the database that was created after I
can see my new name so where's different
points in time here and we can take a
look at what the data looked like just
like your get commit log basically I'm
doing gets checkout on my database and
looking at what's inside
but now we can also take a look at the
query that I did before with the
transaction because it's going to tell
something interesting now I want the
entity and the transaction where let's
see II has user email I'll just do this
for simplicity and all the transactions
here yep
did something wrong it's not called user
it's called person okay so this is where
this is one entity ID and one
transaction ID so what happened to the
other transactions well all my
transactions only wrote to one single
attribute right so the compressed view
only has to late as one so in order to
get the rest of them we can ask the
atomic for the history database so they
turn the atomic manages for indexes for
us in addition to the transaction logs
and every time you commit something to a
transaction things go into the
transaction log which is the source of
truth in the atomic but they also go
into for other indexes and those are at
all covering indexes because they do not
contain pointers to your data they
contain your actual data so the
atomically actually stores when it's
running it stores all your data up to
five times only one of those is required
for recovery though and those indexes
are partitioned into three parts and one
is the current view and then there's the
history view and there's the in memory
of you and by default the history of
view is not available because most of
the time we just want the current state
of the database but you can ask for the
history of you and now I'm asking all
the facts aha okay so I'm making a
mistake here as well and let me just do
this the mistake I'm making is that I am
explicitly now asking for the
transaction that touched the email
attribute so we're going to have to do
this that entity any attribute any value
and
and give me this transaction and now I
get a whole list of transactions that
did touch this thing and we can use this
if I wanted to know when this entity was
created I could give take pick up the
minimum transaction sorry about that
minimum transaction which gives me the
ID if I wanted to know the time when
that happened we can do that as well
just have to perform the join on this
one again DB TX instance TX I okay this
is when it was created if we ask ask for
the max that's when it was updated if I
just want to know when was the name last
updated I can put the name in here so as
you can see I can get all kinds of
information about when things have
happened to my data hmm yeah TAS TAS
sorry thank you okay and here's another
thing you can do I can figure out like
what attribute changed when so just give
me the attribute and the time it changed
and you get a list of the attributes and
when they changed if I only want to know
when they were added
I could add true here and I could keep
going on this is where you can rough
around in your database and find
historic data and actually the project
that I'm working on now my very first
week I use this to answer a question
because someone had misused their access
to an account and changed some data in
their favor and our support staff asked
me like gee I don't want the clients a
finding out what happened can you figure
out what he did and sure I could use
this API to tell her exactly what it did
and when it did it and then we can just
go and revert those changes and
everything was back to normal
so that's but that's the back of
part of this another more interesting
use of this is this example I will show
you now oh okay here can you see this
okay so this is from the application
that we're working on so event them does
they call himself like Airbnb of event
spaces so if you need an event for
birthday or party wedding company
holiday meeting whatever you can search
their site for venues in your area and
meldova criteria and you can send
request to them or you can call them and
then you'll call to a proxy service that
we run and you will get access to this
kind of like email thread thing and in
this app you as the organizer can
communicate with the venue owner so here
i've placed a phone call lasted one
minute i can write a little message to
say hey did you think about our talk and
i'll send that oh maybe it's not running
okay you can attach files i can make
changes here so the event is actually in
the twenty second and also you should
probably want my just pictures of some
sort this might not work when I'm
offline okay
whatever cancel on come on okay so
basically what we do is that you can do
things here there's two parts I can
communicate in various ways and then we
build like an event blog down here of
the various things that have happened
and the way that we implemented this or
the way that this is designed in the
database is that we have this thing
which is called a booking request and
then we have a list there's a booking
request slash calls attributes which has
a list of call entities
like this one you see down here and then
there's the booking request / messages
list which is this thing and this thing
and then there's stuff like this like
when you edit certain attributes we
displayed in the thread here like in the
timeline and all this we use the
historic record of the booking request
like I just show you to build this event
log so we haven't had we did not have to
explicitly design any part of the time
aspect of this the time aspect is fully
managed by the atomic I think this is a
really neat thing to be able to do
without having to think about it up
front so we we started this we had not
yet gotten the calls part in so when we
decided that we wanted to take phones
phone calls to the system we just added
a list of phone calls and voila we could
place it correctly on the timeline on
all our data of like existing and and
old another thing that we're working on
now is to figure out we want to figure
out for the venue owners what's their
average response time and that would
just be a matter of taking a look at
these messages when they're sent from
the client and when they're sent from
the venue owner and we can do some math
on the time that elapses between them
and we can answer that question and not
only for new messages coming in but also
for the entire history of our database
and I think to be able to do this is
very interesting because it means you
don't have to think about all the users
for your like temporal data upfront you
can figure out as you go and I this is
similar to doing a git bisect - to find
a bug in your code right like you figure
out that something is not working now I
know that it was working last month
let's just replay all the commits in
between a figure out where the problems
occurred and I also saw another example
from someone building a bank in Brazil
and they had improved their fraud
detection algorithm which we'll take a
look at like what cards are being used
in what places and what kind of
transactions typically change the amount
after being used in Starbucks or or
whatever and when they improve their
fraud detection algorithm they can run
in on all their historic data to see if
there will be any false positives or if
it would like catch things that they
haven't cashed in the in the past so my
point with all this is that like having
all these stories that at your
fingertips is really useful for a number
of reasons okay I'm running out of time
I showed you the history database one
thing I did not show you but that you
also can do you can go back in time but
you can also go forward in time so when
you have a database and say that I get
the current view my database you can
speculatively apply changes to that
database and query the result to solve
problems so I can say with I'll just do
that press here and so with this
database please apply this transaction
data person
yeah full name Bob and then we could
pick up the entity for instance from VB
after salt and then person email
shouldn't have such long names okay ah
okay and this is this API here with can
be useful for as for we use it in in our
production code but the easiest example
to understand is to use it in tests
right so in our tests that touch the
database we could create an in-memory
database loaded with the schema and then
just use with two speculatively apply a
bunch of changes run some code and see
what happens okay what if the data
change it this way what will happen then
yeah so there's a way for you to go both
for runtime and backwards in time and
there's lots of other things that I
didn't have the time to show you but you
can take a look at for
yourself the last thing I want to say is
that and are there anyone here is
usually working on front-end web
applications that we used like react or
Redux or stuff like that yeah so this is
a page from the redux documentation
which talks about normalizing stage
shape and it shows you that sometimes
your state looks like this
basically a big nested javascript object
of data and the clue here is that lots
of this data is duplicated throughout
the payload and then they suggest or
first of all they say that this might be
a problem and I wholeheartedly agree but
then they say that maybe this could be
the solution and that's where I kind of
fall off because here there are
suggesting that you hand roll a
relational database system in JavaScript
which is probably not what you want to
do what you can do instead is to use
data script which offers you the entire
day Tomic model on the client so I don't
have any spectacular example for you
right now
but there's only one but and that is
that the data script does not have the
historic view of data and that's because
it's running on the client perhaps on
your phone or you wouldn't want to use
unlimited memory but it offers you the
same data model and schema possibilities
and you have the full query engine at
your hands and it's it's really really
fun to work with and you can use it from
JavaScript you can use some closure
script or whatever i really suggest you
take a look at it if you work on
front-end JavaScript projects in in the
example I showed you here we serve a
data script database over an event was a
call event source event streets or even
stream yeah server sent events so when
you load this page we send a data script
database over the server sent events
whenever something happens on the trans
actor on the server we calculate what
changes you need for your client
database and we ship it over and it's
yeah it's been a joy to work with so
that was it hopefully you now have some
idea of what the atomic does and how it
might work for you and maybe like I did
when I first started working with this
maybe you'll realize that this database
solve some problems you didn't even
realize that you had before his side so
yeah I hope you enjoy it
and thank you for your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>