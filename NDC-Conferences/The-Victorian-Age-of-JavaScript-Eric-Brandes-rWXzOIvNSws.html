<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Victorian Age of JavaScript - Eric Brandes | Coder Coacher - Coaching Coders</title><meta content="The Victorian Age of JavaScript - Eric Brandes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Victorian Age of JavaScript - Eric Brandes</b></h2><h5 class="post__date">2017-04-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rWXzOIvNSws" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's get started welcome to the
Victorian age of JavaScript and thank
you all for coming on a Friday
ternoon and I know things are winding
down so I really appreciate everybody
coming here so what am I talking about
when I'm talking about the Victorian age
of JavaScript what does that mean well I
was thinking about JavaScript and how
it's moving very quickly right there's
new frameworks all the time it's almost
too much to keep up with or assimilate
and there were some parallels in my mind
between that and kind of what happened
with medicine 150 years ago in the
Victorian era right
there's loads of new treatments back
then right they were coming out with new
ideas all the time about how to click
through cure disease
javascript has a similar situation right
now there's loads of frameworks build
tools package managers all kinds of
things and within all of those new ideas
there are some real advancements right
we've got fat arrow syntax now we can
actually do string templating 20 years
after JavaScript was developed right
that's awesome
we have Const now so we can actually set
a variable and say I don't want it to
mutate that's great but like medicine
there's limited regulation or oversight
that at this time in JavaScript right
now anyone can start a github repo
anyone can start a new framework and say
it is the best thing ever right like
Victorian era medicine charlatans are
peddling dangerous drugs right we've got
all kinds of frameworks out there
javascript weekly is talking about new
things all of the time and in some cases
the cure can be worse than worse than
the disease for example everyone right
now wants to use single page
applications single page applications
for everything when in fact that's not
always the right choice I mean some of
these treatments actually literally can
kill people like angular 2 for example
and it's not entirely fair that stopping
some people here that really like
angular 2 and it's it's not actually
going to kill you right that's not
that's not my intent but angular 2 is
kind of a one of those examples of a
framework that I think is a good example
of the problem that we're seeing with
too much new ideas in JavaScript so who
my my name is Eric Brandis I'm the
co-founder of Trek j/s which is a
javascript error monitoring tool we've
got exhibition booth out in the expo
hall so if I say something that really
offends you feel free to come yell at me
afterward
I also am a consultant so I spent a lot
of time doing advanced front-end
development for big fortune 500
companies so I've kind of seen both
sides of this JavaScript world I've used
a lot of these advanced new frameworks
and then I've seen how they break and a
lot of them do break and it's not clear
that they're actually adding value so
like Victorian era medicine there were
some good ideas back then
for example the smallpox vaccine right I
think everybody here would agree that
that was a pretty good idea save several
million people hundreds of millions of
people probably and so we've got similar
ideas with JavaScript right I think
everybody realizes that bundling and
minification is a good idea right we
take all of our disparate scripts we put
them in one to save on the requests we
minify them to save the bytes over the
wire so the script load faster and the
user experiences the webpage faster it's
a good idea one of the other
advancements in JavaScript that I think
most people would agree is a good one
we're starting to get sane modules so at
first javascript was kind of the Wild
West we didn't really know how to like
block up our code we didn't really know
how to distribute it how to actually
make real applications with it
it started with advanced or asynchronous
module definition right we had to work
within the framework of es5
but then came node in common Jas and
people like oh that's actually a pretty
good idea and now with es6 we've
actually got a fully Specht out module
framework import/export all those kinds
of things there's an asterisk on this
slide though the reason for the asterisk
is because the es6 team didn't actually
fully think out the spec and it turns
out that they can't actually know if
something is a module in a performant
way just from that import syntax so now
they're actually advocating that we
added an MJS file extension to any
module javascript so that's still in
play nobody's really figured out what's
going to happen with that but we are
starting to see some some module
rationality we've got new language
features we've got Const right we've got
fat arrow functions we've got string
templates these are all good things
but like Victorian era medicine there
are some bad things so back in the day
people thought it was a good idea to
real holes in your skull it's called
trepanation all right we don't think
that's a good idea
anymore some things that I think are
similar some things that I think are
here today but are going to be the
trepanation of tomorrow I things like
these structuring particularly nested
restructuring does anyone know what the
actual output of this is there's a
variable called first that has a name of
Eric or it has a string value of Eric
but if I actually caught someone using
that code I'd be pretty upset because it
is not immediately clear what is going
on the same thing exists with the new
spread operator so it's very easy to
write code that is obtuse that's
difficult to maintain is difficult to
understand and what's worse is we do
have a spec now there's an echo script
tc39 committee whose job is to actually
push the language forward the problem is
they think that they need to push the
language forward with new syntax all the
time and so they get proposals like this
this is a strawman bind operator
proposal basically we've already got a
bind function right that will take
whatever you pass in and make it the
context of the function that this value
right because everyone knows in
JavaScript this is one of those
landmines that you always have to be
very careful about so they decided that
the bind function was maybe a little bit
too verbose so the city decided they
wanted to C++ it by the language a
little bit with two colons for example
this has not been ratified but this is
the kind of stuff that people are
thinking about this is what people
consider progress in JavaScript and I
guess my stance on it is somewhat
measured
another example is frameworks in terms
of things that aren't really going I
don't think they're going to be good
ideas five years from now and one of
those is angular I was going to say
angular 2 are you getting similar with
angular 2 have you heard of angular 2
did you know it's actually called
angular 4 now or will be in a few weeks
so they decided that angular 2 was good
but they wanted to go to cember and so
they decided that we want to make
breaking changes and communicate those
and so that requires a new major version
so you might think well the next version
of angular probably be three right we go
from two to three but they that didn't
happen either because actually it turns
out angular router was already on major
version three and so they said well we
can't have we can't go back in time with
that so just standardize on four and now
they're saying that every six months
they are going to release a new major
version with braking changes of angular
- I actually got into a big argument on
Twitter with these guys about that and I
said you guys are nuts
like the upgrade treadmill here is way
too fast people don't want to be
upgrading every six months of breaking
changes to their app they said nope too
bad that's how we're going to do it
somewhere let's us do it and that's the
way it's going to be so let's talk a
little bit more about angular two or
four or angular I think it's just
angular now they want to call it which
is interesting to me because there's
already angular one so if you're like
well I will ground an angular app is it
a just angular app or is it an angular 1
app or is it an angular next app is an
angular 7 app I don't know it's
confusing it's hard to tell and they're
not even very similar angular 1 is very
different than angular 2 right so
there's a lot of confusion here so this
is the output of an angular 2 QuickStart
so if you actually go to get up get the
QuickStart like the blessÃ¨d official
QuickStart for angular 2 if you pull it
npm install NPM start this is what comes
up it's essentially an h1 it says hello
angular right seems pretty simple it's a
great base to start from the problem is
if you actually look at node modules
you've got 108 megabytes of files in
your node modules just to put hello
angular on the page you've got 13,000
740 files that actually help to do this
this is what the top level of your
folder structure looks like in the in
the editor you can see we've got system
jas config extras j/s protractor config
karma comp for all the stuff right is
this really all necessary to put an h1
on the page here's the component itself
right at first it seems pretty simple
and in fact this component is pretty
simple
but you might notice the @ component
syntax that's a new typescript attribute
thing the angular 2 makes use of
you'll notice the template is a string
so we've come all this way we've got 108
megabytes of node module it's got 13,000
files to do this and we're still
actually writing template strings right
so you've got no tooling help you've got
almost nothing if you screw up when we
actually request this page and Graham
this is Deb this is not production mode
angular 2 when we actually request the
page it's 39 requests to put that h1 on
the page it's 2.2 megabytes of script
that gets transferred just for that so
my thesis is that this is too much this
is too complicated this is a bad idea
right how do we get here
like what like what happened where we
actually are thinking that angular 2 is
a reasonable solution to our problems
well like medicine in the history of
medicine the early web was basically
religious with rituals based on agonism
right if you look at like for example
Amazon coms original homepage right it
looks pretty nasty it's a static it's
boring right if you want to do any kind
of like dynamic work you're actually
doing a full form post right so we
didn't have JavaScript back in the day
you probably had some Perl sitting in
like a CGI bin gateway and it was taking
in form input parameter dynamic
scripting language on the page so just
like medicine we've got kind of this
this emergence of a new technology right
nobody's really standardizing on it
nobody really knows what's going on one
of the first things that you could do
with JavaScript you can actually change
the status bar on your browser does
anyone remember the days of like you'd
hover over a link and it would say
something awesome I click here for cool
stuff
and then you had no idea where it was
going to take you right unfortunate that
doesn't actually work anymore
we had some frameworks come out of this
people said well we should probably do
something to kind of standardize some of
this and we had script calculus we had
prototype we had mood tools there were
several others at this time right and
these are all pretty good frameworks and
actually for those that remember
prototype came well before jQuery as the
stuff went on JavaScript started to be
more mainstream but people started
running the browsers with JavaScript
turned on all the time similar to
medicine this was kind of the rise of
science and study right we saw
say okay JavaScript here to stay we need
to actually kind of put some regulations
some oversight around this and one of
the people that actually really push the
ball forward was Microsoft believe it or
not the original XML HTTP requests with
an ActiveX object but it was actually
created for Outlook Web App and so you
could actually so the great folks at
Microsoft said hey we don't want to do a
full page post all the time
sometimes we want to actually get some
data out-of-band right and then draw in
the page it's kind of a very seamless
app like experience so for those who
didn't know Microsoft actually is the
inventor of Ajax which is kind of cool
we also saw that jQuery sort of won the
framework war so there were many
competing servers dojo there was all
these things the Ajax control toolkit do
people remember that from Microsoft that
was kind of a sad day wasn't it
but jQuery sort of won the war we can do
that same angular two example that took
108 megabytes of node modules and 13,000
files we can actually do that same thing
with jQuery because one line of code
right now that's too simplistic right
the angular 2 example is doing more and
this is the road to a very bad place
right if you just start doing Dom
manipulation like this but this jQuery
stuff got people thinking because I'm
thinking about client-side rendering
which I would kind of called the
Renaissance in web development terms we
had frameworks like knockout right you
guys remember knockout it's kind of
first mvvm thing that Leslie Sanderson
it wasn't exactly a single page
application framework but he was getting
there and it led the way to backbone jas
right so backbone came out and
everyone's like oh this is cool actually
got structure for our JavaScript now
right we actually can put these things
in different places there's kind of a
prescribed method to do event delegation
to do rendering that kind of thing and
people actually started at this point
building full-on single page
applications where you would load a
metric ton of JavaScript and you would
never have to leave the page for a full
page load again but unfortunately like
all good things it had to come to an end
and so now we're in why would call the
Victorian age of JavaScript or
JavaScript fatigue right and so this is
a term that actually has come out in the
last few months
and essentially it's talking about this
it's talking about the fact that there
are I mean I googled for five minutes to
get that list of images right like if I
thought about it longer I could probably
come up with several hundred frameworks
you know 15 different build tools and
all that and so how do we make sense of
all this how do we know what's good how
do we know it's bad how do we know like
if I take this tool is my client going
to kill me when I don't deliver the
software on time and when it's super
buggy right so the rest of this talk I
kind of want to talk about some good
ideas and some bad ideas that's kind of
already existing in the JavaScript
landscape today I want to talk about how
you can avoid the landmines and pick the
tools that I think are going to last
into the future so the first thing that
you need to decide when you're building
a web application is how are you going
to render this thing so everybody right
now is saying that single page
applications are kind of the way and I'm
here to tell you I don't think that's
true at all just like lobotomies were a
bad idea back in Victorian era medicine
single page applications for everything
is a really really bad idea right now
your app in my mind is probably not
Gmail right you probably don't need that
level of interactivity it's probably not
a to-do list right because this is the
classic sort of hello world for your
average MVC JavaScript framework right
probably not that either it probably
looks more like this right it's probably
line of business app or is probably
something very complicated doing some
business e things and there's probably
not a lot of advantage for you to
actually do client-side rendering just
like antiseptics were a good idea back
in Victorian era medicine I think there
are some good ideas that we know about
today that are going to continue to be
good ideas in the future I think static
site generators are a good idea for
those that don't know one of the most
popular is called Jekyll it's actually
what runs github pages and in my mind
there are so many applications for these
things if you have documentation that
you need to write if you have a blog
that you need to make you can statically
generate the HTML ahead of time and then
just deploy it on any simple old web
server and your necks will do right
you're just you're just sending static
files down the wire it doesn't mean you
can't use JavaScript
the marketing site for track J is the
documentation site for track j s they're
all built with jekyll but they actually
do have JavaScript interactivity as well
it's just that we don't have to think
about it we just submit the code to
github they do the build and then they
host it for us right it's great server
rendered templates are still a good idea
all right we've been doing server
rendering for a really long time we're
pretty good at it and it's actually not
the end of the world if you actually
have to make a full request and response
all right it might not be as flashy it
might not be as app like or web 3.0 but
it will work and it will work every time
and browsers are really really good at
the request response model so something
like a simple server render template is
probably good enough for a lot of
applications especially internal
applications we don't need some of the
fanciness but maybe you do want the
fanciness right maybe you do want that
kind of Ajax load business but without
all the client-side headache one good
idea and this is probably my favorite
idea actually if you guys look up
anything from this talk I think PGX is
probably the most interesting thing if
you haven't heard of it and it was
written by chris wanstrath who is the
CEO of github actually and it's how
github does their rendering so github
actually renders almost all their
content on the server but they Ajax it
in and it's not like they're sending
Jason so this is actually a picture from
just you know chrome dev tools and this
is me clicking on a link of the pjx
repository and you'll actually see
they're sending back a big HTML chunk
and browsers are really really good at
dealing with big HTML chunks all right
it's a lot more work for them to take a
JSON blob parse it spin up the rendering
engine and do all the Dom manipulation
that needs to occur trackjs actually
uses as metha this is such a good idea
that I stole it for our site and we
actually have one of the more responsive
app like fields of a website that I've
used YouTube does something similar they
rolled their own it's not it's not
something you can just go get on my
github but they're using a similar idea
they're actually sending back JSON which
in my mind kind of loses some of the
appeal but you can see that they're
actually putting HTML in their JSON
responses which is kind of cool
so let's say you don't believe me and
let's say you're like okay I can't serve
a render right I've got to do this whole
client-side shooting match you have a
whole bunch more decisions that you need
to make now the first of which is which
package manager to use right because you
said well server rendering is not going
to work I've got to do this JavaScript
thing well you have a lot of options
when it comes to package managers
believe it or not and like medicine of
old there were some there's some bad
ideas right so just like leeches turned
out to not be a super smart idea to
solve health problems it turns out Bower
actually isn't a super good idea to
solve static file issues now you might
say well Bower school is made by the
guys that wrote bootstrap and it's like
you know I think some Twitter dudes were
involved with it it's got some cachet
well the problem our this is actually an
example of a bower JSON file for those
that are familiar with package jasons it
looks almost identical to MPN packaged
die Jason and in fact it is and it's
supposed to be so the guys that built
flower thought hey you know wouldn't be
great if we had an NPM like thing but
for front-end JavaScript files so let's
just let's just kind of duplicate the
idea behind NPM and at first that maybe
seems like a good idea until you
actually see how you include a bower a
bower file so this with no other work
this is how you actually put a bower
component on your page you link to it
just like you did before right there's
no advancement here in fact if you want
a bundle or minify a bower components
directory you have to choose from one of
these like nine different options that
can help you these tools aren't
supported by Bower they're supported by
the open-source community right in
various shades of maintenance mode or
activity and you've got to kind of put
all these pieces together yourself so in
my opinion Bower does not really give
you a lot of advantages and in fact you
don't see a lot of people doing a lot of
Bower anymore another bad idea in my
opinion assisting Jas also known as JSP
m dot IO right so the JSP m you guys are
pretty funny and they're like well we've
got Bower and we got NPM and we've got
like filesystem so we've got like these
three different places
that your packages are going to come
from so we should probably make a fourth
thing that kind of coalesce is all of
those together right so that we can kind
of have one place to do that from but of
course now the problem is everyone knows
you have four things that you have to
maintain right so you can see here this
is angular 2 uses system J s of course
and so here you can actually see this is
the system j s config and all its really
doing is delegating to NPM so just like
anesthesia was a good idea in the
Victorian era of Medicine and continues
to be a good idea today NPM is really
all you need as far as package
management goes I do want to talk just
briefly though about what yarn so have
you guys heard of yarn nothing from
Facebook so Facebook said ok NPM has a
few failings right NPM doesn't it's not
very good at security it's not very good
at check something the packages that it
pulls to make sure you actually get what
you're supposed to get it's also not
very good at caching so for anyone who's
done a lot of JavaScript stuff when you
do an NPM install you are like melting
your network right and if you're on a
slow network or like your build machine
is doing a bunch of competing builds you
are saturating that network and just
like hammering and p.m. with requests so
the do you that Facebook came up with a
solution called yarn I don't want to
talk too much about yarn just because I
think it's too new to know whether it's
a good idea or a bad idea but my initial
impressions of it are actually fairly
positive I think they solved the issues
in kind of a novel way by continuing to
use NPM right so when you use yarn
you're not using the Bower repository
right you're actually using NPM under
the covers the same packages that you're
getting from NPM you're getting from
yarn I think though that yarn is
ultimately maybe going to be a good idea
for its time but the guys at NPM now
said well NPM 4 is going to just solve
all these problems that yarn did so for
now I'm sticking with NPM personally so
once you decide on your package manager
you need to find the transpiler right
some people call these compilers and I
call them code amplifier size well the
reason the guy is yelling into a
megaphone because to me transpilers are
this really interesting idea where we
take some code and then we amplify it
into more code but it's not necessarily
going down a level of abstraction like
you would with a compiler right we're
just taking some fancy JavaScript
and converting it to JavaScript that a
browser can actually run right a lot of
times the JavaScript the browser to
actually run is much larger and much
more difficult to debug but transpilers
are here to stay people want to use them
so we got to talk about them just like
exorcism with a bad idea 150 years ago
although I guess some people still think
it's a good idea CoffeeScript is a bad
idea so I don't know if anybody is doing
CoffeeScript about the only big project
that I know of it's still using
CoffeeScript is Adam the Adam text
editor but it turns out people don't
actually want ruby in their browser
right for the most part it also turns
out that the language is advancing and
so a lot of the things that made
CoffeeScript a good idea four years ago
you don't really need anymore fat arrow
syntax some of the list comprehensions
those kind of things that are now
standard in es6 are things that
CoffeeScript was realy touting as
advantages it's simply not necessary
anymore
another bad idea I think are other kind
of esoteric languages right you're going
to see things like closure script like
people are actually like trying to write
web apps with closure script and I think
that's in my opinion I think that's a
little a little crazy if you look at
that syntax that is pretty wild syntax
unless you're like a closure genius that
is going to be pretty hard to maintain
and so I guess you know the answer in
software is always it depends is there
ever a reason to use closure script
maybe maybe if your team is a bunch of
like functional wizards that's been
doing you know lists since the 70s
yeah closure script might make a lot of
sense but probably not for your average
project just like bacteriology was a
good idea 150 years ago it turns out
that it wasn't you know demons that were
actually hurting us it was bacteria yes
five classic is a good idea when it
comes to transpilers you don't even need
a transpiler
cs5 it's what the browser's speak and
understand and you can actually write
pretty expressive apps with just echo
script 5 you don't necessarily need all
of the fanciness of es6 or at least I
don't another idea that I think is
pretty solid I think is going to stand
the test of time as typescript two years
ago when it first came out or three
years ago whenever it was I was kind of
a little iffy on it
but Microsoft has shown significant
support
right Anders house Berg is the one who
designed it and he's pretty good at
designing languages if you like c-sharp
and Delphi and Microsoft is actually
putting a lot of support behind the
tooling of it as well I'm the typescript
compiler catches all manner of issues
right so if you guys have done a lot of
typescript it's once you get used to it
and kind of the discipline of adding
those type annotations it can be a
really effective way to work with really
big teams too so I think typescript has
some longevity I think that's a thing
that's going to stick around and finally
I have to talk about battle because
probably everyone in this room and they
think of transpilers are taking a battle
right and like what do I need to do to
get Babel working babbles what does es6
write and sew Babel the history of it
actually it was written by like an 18
year old kid from Australia it was
really called 6-2 5-5 yeah six to five
was what it was called
of course now it's called Babel and it's
got hundreds if not thousands of
contributors and it has what we're
called presets and so when you choose
Babel as a transpiler you have to pick a
preset they've got presets for react
es2015 es 2016 es 2017 latest each one
of these presets as more and more
features the problem with that is a lot
of these features are polyfilled a lot
of these features are sort of transpiler
magic and that can result in some issues
right so translation can be too much of
a good thing
for example Babel also has this thing
called stage X presets these are
experimental you'll note in red they
even tell you hey these are subject to
change for use with extreme caution the
problem of course is I see a lot of
companies using stage 0 battle presets
right and it causes them all kinds of
issues the other thing is the
transformation can be slower so this is
pulled from a website called 6 speed
which is on github and it's a guy that
actually looks at the common
implementations for various transpilers
and it compares them to the es 5
equivalent so classes are you know
depending on your browser and things up
to 23 times 27 times slower right
generators are quite a lot slower object
assign and some things is actually
faster but still slower right you're
taking several penalties when you use
some of this translation normally it's
not a big deal normally it's
fast enough but it's something else to
consider right now you got to think
about build tools so you've got your
transpiler right so you pick babble or
you've picked high script or whatever
and you decided you're going to
client-side rendered with with npm is
your package manager how are you gonna
build all this stuff how are you gonna
put it all together well there are a lot
of bad ideas radium water was a bad idea
hundred fifty years ago it turns out
that putting radioactive water in your
body didn't actually help anything just
like all of these things are bad ideas
each one of these I don't even know the
names of some of these are like the one
on the bottom left is like a PlayStation
controller layout or something and then
I don't hear ones like Turkey or
something
these are all actually supported things
for battles if you go to the babble
setup page start - broccoli Jas like
brunch is the one on the bottom middle
these are all supported build tools
don't use any of these okay they're
super esoteric they're super niche and
you're gonna run into so many problems
if you try and use something like this
there are some other big-name build
tools I also think are bad ideas today
I think grunt is an outdated idea I
think it was a pretty good idea when it
first came out I think people needed
task runners when you want to do your
minification step but you want to run
your unit test when you want to do your
you know whatever you kind of need a
test when you're when you're publishing
to artifactory or something because you
have a java shop and so everything needs
to be like maven defied grunt could do
those things for you the problem with
grunt I think was that it was too
configuration based so you had this big
JSON file with all of this sort of magic
configuration and it wasn't very
extensible right if the plug-in that you
use for grunt didn't do the thing you
wanted it to do you were stuck you
didn't write your own tasks or you have
to like hopefully the maybe there was
some kind of new version that was alpha
that you could use so it wasn't terribly
extensible another outdated idea was
browser fine but it was a really good
idea basically the guys that wrote
browserify said hey we really like the
idea of common j/s modules right I want
to write modules with require statements
just like I do in node so there's sort
of synchronous requiring statements
but I also know that I want a bundle and
I want to minify and I want to do all
these things what if we just put them
all together what if I just pointed a
tool at a file that used commonjs style
modules and it just kind of walked that
tree and built me a single output since
the browser if I did it was awesome but
again it has been supplanted by
something else so just like hospitals
were a good idea in the medicine world
task runners are still a good idea in
the JavaScript world now I happen to
like go there are a lot of people that
don't think gulp is very cool or
interesting in my mind gulp just kind of
works it stays out of your way it's easy
to write tasks so the ecosystem is huge
and it's super simple if something if a
task doesn't work quite the way you want
it to it's generally easier to fix or to
extend on your own and it's kind of got
an interesting paradigm with source and
destination type pipelining capabilities
I think gulp is still pretty cool
I think webpack is pretty cool I think
web pack is the thing that kind of put
the nail in browserify coffin so what
that kind of does everything that
browserify does plus a few extra things
and it doesn't really fast and it's got
a lot of mind sharing it's got a lot of
people working on it right now and while
there is some configuration pain to web
pack I think that you know if I was
choosing to start a new stack and go
all-in on this client side stuff I would
definitely use web pack and you can use
it in combination with dult quite easily
it's got a great programmatic model in
terms of kicking off web pack getting
the results all those kinds of things
another good idea is plain old NPM
scripts so NPM actually gives you this
this block and your package Jason where
you can say in this case you know NPM
run web back or NPM run server you can
just put bash commands in there right
and that works pretty good most people
are pretty familiar with whatever shell
that they're using and it works pretty
reliably it's not great if you have a
really complicated set of build
processes but it works really really
good for simple things so I think NPM
scripts is also worth a look
but it's JavaScript so now you've got
your your transpiler and you've got your
build tool but you've got to deal with a
think it's actually pusher to anything
actually I couldn't think of a good idea
for async pictures but how do you how do
you manage async in JavaScript right
it's kind of as necessary
cost so just like bloodletting was a bad
idea hundred fifty years ago right it
turns out that just when someone's sick
you don't want to take all the blood out
of their body callbacks actually weren't
a great idea either so javascript said
well we don't have threads so everything
is going to meet everything that's
asynchronous is going to need to be done
via callback we don't want to block the
one thread that we do have and so node
actually bought fully in on callbacks
right the problem with callbacks is that
you can get what's called the callback
Christmas tree right and so this is
you've got nested callbacks right and
this gets very very complicated to
maintain so I think people kind of
realize like hey this isn't a great idea
so other ideas were tried one of the
ideas that people seem to like right now
is rxjs
has anybody done any reactive extensions
async work did you like it
it's okay so the rxjs premise is sort of
like inverts things sort of good for
stream processing right imagine you have
a stream of events coming in rxjs gives
you a whole lot of ideas on how to like
process that stream and manipulate it
the argument for why you should use it
in UI apps is that a UI the argument
goes it's just really a series of user
input stream events right so as the user
is clicking and typing those are just a
stream of events that you should process
I actually don't buy that argument
personally I think that's a little bit
too simplified I don't think the
paradigm quite works I think actually
the reason rxjs is currently super
popular is because Netflix uses it a
Netflix said we use this for our async
and like look at how cool we are because
we're Netflix which i think is
interesting because actually if you guys
use Netflix UI before it's not very good
they redo it all the time it's kind of
like your classic master details UI like
you'd think that this would take about
five guys about one month to build and
yet they have a whole like army of
engineers working on this stuff so I'm
not sure that Netflix endorsement is
super compelling to me personally
another idea that we see for async these
days generators so a lot of people said
okay maybe rxjs isn't right but
javascript now has generators which are
very similar to like in c-sharp if you
guys ever use the
yield keyword is very very similar to
that generators are actually pretty good
for a sink for small things but there's
a whole bunch of frameworks now that
have come out that are using generators
kind of everywhere right it's kind of
like beating you over the head with
these things one very popular web
framework on the node side of what was
called co-op I wouldn't use generators
for every single thing and it turns out
that generators are good sometimes in
small doses but they can be very very
painful to debug and generators or
actually isn't like a hundred percent in
the language like it there are some
weird edge cases and bugs so you do
still see generators being used quite a
lot but it's another idea that I think
is going to not stand the test of time I
think it's going to be proven to be a
bad idea because I think there are new
things coming that will supplant it so
empirical research turned out to be a
good idea actually applying some rigor
to like sort of medicine problems turned
out to be a good idea on 50 years ago
and has stood the test of time
I think native promises are going to do
the same thing so jQuery sort of put
promises on the map with deferreds when
it came out you know I don't know how
many years ago four five years ago
promises are now standard and es5
actually I think but fix for sure and so
almost all browsers support promises
natively and if they don't there are
tons of polyfill libraries for promises
I'm not gonna spend too much time about
promises because I think you guys
probably already know it pretty well but
I think the really interesting thing is
coming is async/await
so I don't know if they copied c-sharp
exactly but the syntax looks awfully
similar to how you write async away in
c-sharp and the cool thing is just like
in c-sharp they handle so ultimately
you're dealing in promises still right
so promises are still the currency of
async/await
but there's a lot of like sort of
syntactic sugar here to unwrap those
promises for you don't need to think
about it and the best part is error
handling is one of the pain points with
promises right if you forget to put a
dot catch on your promise chain those
errors are just going to get swallowed
but you can use regular try catch
semantics with async await once it's
available the reason I say it's a good
idea eventually is because
right now you have to use Babel for the
most part there's a couple of there's
like v8 has it right v8 like modern v8
like if you're in node you can actually
use async/await I think as far as is
node seven but on any sort of browser
that's mainstream you're Paul is going
and I don't know if anybody knows but
you know how to implement async/await
with Babel actually use generators under
the covers so when you're actually
trying debug your async/await
you actually looking at this big nasty
generator state machine right and so it
can actually be really really
complicated to debug this stuff but the
language is moving fast and the engine
like that you know the JavaScript VM
guys are really pushing this stuff so I
think that sooner rather than later
we're going to see async/await is like
an actual first class citizen so now
let's talk about frameworks so you've
picked all of these different paradigms
and things that you're going to use now
you want to make sure you pick the right
framework and there are literally
hundreds of frameworks and so I don't
want to talk about all of them today but
I do want to talk about a few of the big
ones so back in the data you see is
heroin as medicine I thought this might
be a good idea how to like you know
maybe cure pain of various kinds and
actually it was quite effective at that
I just killed people too and so again
we've got angular right so I keep coming
back to coming back to angular I won't
spend too much time on it cuz we talked
about it a little bit at the beginning
but the angular guys in my opinion are
kind of rewriting a j2ee so if you've
done any like angular 2 stuff a lot of
it might feel like spring was like back
in the day right there's a lot of setup
a huge learning curve it's a lot of work
to get anything sort of on the page and
one thing that I think is worth worth
talking about is um these complicated
frameworks they're not going to get
easier as the application increases in
size right so a lot of people say well
it's complicated now because the example
is really simple but once you get this
really big app then you're good to go
the thing is I don't actually believe
that I don't know how many times have
you seen a complicated thing get them
like way better once you added about ten
thousand lines of code do it right it
doesn't happen a lot so I think that's
the mistake the angular guys are making
and because they're sort of Google
they've got a lot of clout they can
really push this thing but I think anger
is pretty dangerous
I think meteor is a bad idea so I don't
know if anybody here is used meteor but
the premise behind meteor is that you
don't actually need to care if you're on
the server or the client you can just
kind of write your code and meteor will
marshal that data for you and everything
will just work has anyone used that net
remoting or decom they too have the same
premise right like don't worry about the
network boundary like see SLA if you use
that framework you don't need to worry
about it except for you do right I mean
like you can't just pretend that this
network doesn't exist right and so I'm
trying to guess we've seen all kinds of
issues that people have with meteor and
we've had to do a whole bunch of support
for customers where it wasn't anything
related to us it was just that meteor is
so diabolically magical that no one can
figure out what's going on with it
when it breaks so I think that meteor is
one of those things that you will you
want to stay pretty far away from I
think another bad idea is if polymer or
web components so I don't know if you
guys have heard of this one either but
this is a kind of a standard that was
pushed unilaterally by Google so Google
said we think this is a great idea they
started it on the standards track
Mozilla said hey we think is actually
kind of a bad idea and Google said we
don't care we're putting it in chrome
it's out there so today in chrome you
can actually use web components and what
does that mean well you've got things
like the shadow Dom right so they said
well I want to be able to style my
component I don't want to let anyone
else style my component with cascading
style sheets so they give you this thing
called a shadow Dom and there's shadow
roots for your CSS classes to like
attach to and it turns out they weren't
really solving problems anyone normal
had and the other problem of web
components is you build this component
that's great but the problem with all of
these components really angular two as
well because they're like super huge on
these components a lot of times on my
website I've got two components that
need to know about changes in one or the
other right like so if I update my cart
in a shopping cart I need to update the
price as well so those are two different
components web components
angular2 they don't really give you any
good tools to deal with that so usually
you end up seeing like an event bus
right we're just like firing these these
you know string based events or you know
an angular twos case you get this kind
of weird dependency injection thing that
works most of the time but they didn't
really solve the core issue of how do
these components communicate with each
other another kind of idea that I don't
think is bad idea I think ember will
continue to stay around but there's some
things to be weary of with ember so if
you haven't used amber and you're
thinking about starting a project with
ember the thing that you should remember
is that those guys have changed how they
do things about four times like
significantly and so I've actually
helped on a number of ember upgrade
projects where like when you wanted to
move from one major version of ember to
another or even like minor versions they
would have significantly changed how
things work they change their rendering
engine midway through and kind of copied
the same ideas as reactive to thing
called glimmer that they go so I think
you want to be really careful if you
pick ember because you don't really I
don't person have confidence in their
commitments backwards compatibility also
the dudes that row number are kind of I
would say a little bit academic they'll
kind of do the right thing academically
whether it's sort of the pragmatic
choice or not so I would definitely be a
little bit careful of those guys
penicillin was a pretty good idea I
don't think it 150 years ago I think
it's newer than that but it was one of
those things that people were like this
is a great idea and if you ask me what
framework I would choose I would choose
reacting redux I know that's like kind
of that's kind of a party line at this
point everybody likes react and redux
like that super cool but I've been doing
react now for about two years and I
think as far as the client-side
rendering world of s.p.a s goes I think
it has kind of the best of both worlds
so it's got it has a solution for when
your different components need to be
aware of each other right redux is
basically a global state bag so when
something changes one place that state
is actually plumbed through to all of
the other places that need it the other
thing that react does that I think is
really useful is is one-way dataflow
there's been a lot of talk about that
and how cool that is but I think it's I
think it's deserved I think that you
know angular
to knock out several other from ember we
do a lot of two-way data-binding right
and a lot of people really like mvvm or
- i data-binding
I think it's a really great solution for
small things but I've worked on a lot of
mvvm apps where just maintaining that
app as things get more and more
complicated the business as more and
more requirements it's actually very
very difficult because you don't really
know you know somebody set some data
over here which causes a cascade over
here until these things are sort of
two-way changing all of the time and I
think the one-way data flow actually
solves a lot of those debugging and
maintenance issues the other reason I
like react is a they've kind of got all
this boilerplate figured out for you so
you can just ignore most of the crap I
just said and you can just download this
thing called create react app so it's on
github and they have basically come out
with their sort of opinionated version
of like here's the settings which you
should use to use a react app you can
either use this as a boilerplate on your
own so you can just like spin it up and
it's good or you can type NPM eject or
create react app eject and it will
actually spit out all the configuration
files that it's using internally so if
you kind of like most of what it chooses
for you you can actually kind of get
those raw files and tweak them for your
app this to me is a pretty huge
game-changer because I've been doing
this JavaScript stuff for for so long
that a lot of this tooling &amp;amp; stuff
doesn't really bother me and it kind of
makes sense at some point but I got to
tell you if you're new to this stuff
there is so many things to think about
just to get hello world on the page
right and just to get any kind of value
from this so I think this is a huge win
and some people are probably saying well
what about view what about really what
about inferno
what about intercooler what about
pre-act I explicitly chose not to
include these frameworks right now
because I actually don't have enough of
an opinion about them right but to talk
about them briefly I think view is going
to be pretty interesting I think view is
going to supplant angular 2 possibly
it's got that two-way data-binding that
people seem to enjoy but without all of
the ceremony oh really is another
two-way data-binding thing written by a
guy named Rob Eisenberg who did Durand
if you remember that but they took a
pretty pragmatic approach to a lot of
this stuff too there's not a lot of
ceremony and getting in or really app up
and going I think it's kind of an
interesting framework Inferno and
pre-act are sort of interesting they're
sort of react clones isn't the right
word but they aim to be API compatible
and so they take some kind of different
techniques but their whole premises if
they're going to be very very fast
versions of react and so if you've
written your app and react and now you
want you have some speed issues say you
can just drop these guys in and it'll
work you know I don't know if that's
true you can almost never just drop
anything in and have it work intercooler
is also pretty cool it's kind of like a
PGX framework it's so more for
server-side rendering it's pre meet
again it's been around for a while but
there's not been a lot of uptake but I
think that you're going to start seeing
more intercooler uptake in the future as
well so what's the bottom line let's
look what's the hole what's the whole
point of this well I guess my main point
today of like even talking about all
this stuff because it's I mean really
it's a lot of stuff to consider when
you're talking about building a web app
I guess my main point is that we're
making web apps too complicated all
right
it used to be that you could just take a
notepad XE double-click it make it you
know index.html put some angle brackets
on a page FTP it somewhere and you're
off to the races right I think we've
lost that a little bit and I think that
we're finding that all of these
abstractions that we've created all
these complexities that we've put in
there they're not really helping us
right I think are they helping us get
our apps out faster do they deliver
client value faster and I don't know
that they do client rendering has a
significant cost so I hope that everyone
realizes that if you choose to go down
the single page application route
there's a whole bunch of things that
you're going to encounter that aren't
going to work like you thought they were
like something as simple as the back
button right like in a server rendered
world the back button always works it's
great in a single page application world
sometimes it works sometimes it doesn't
unless you do specific things to handle
it you might not have a working back
button right there's also all of this
tooling there's all of this turn in
terms of
javascript language right and so you're
actually like on this upgrade treadmill
whether you like it or not and the
browsers are constantly shifting things
out from under you like Chrome in
particular has broken a number of things
that are pretty critical a lot of people
are using source Maps right so a source
map is basically hey I've transpiled my
code but I don't like I don't really
want to see the output well I debug in
Chrome I want to see the original source
input so you can use source maps for
that the problem is chrome breaks at
some time so there's various flavors of
source map generation and for awhile the
source type that webpack generated just
didn't work in chrome for a whole major
release of chrome it just didn't work so
you're going to have some pain
potentially with this stuff the tool
chain is improving rapidly so things are
getting better I don't want to say it's
all crap but a lot of it's crap and so
you should be skeptical of new fads
right like I don't think anybody file
asthma cigarettes is a good idea anymore
it turns out that probably wasn't like
super super good for you at the other
day I guess we're putting angle brackets
on a page okay we're not not actually
curing cancer this isn't something
that's supposed to take 108 megabytes
and no modules it's also takes 13,000
files to put an h1 on the page right so
yeah so that's it that's the that's it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>