<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Tension Between Expediency and Correctness - Josh Adams | Coder Coacher - Coaching Coders</title><meta content="The Tension Between Expediency and Correctness - Josh Adams - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Tension Between Expediency and Correctness - Josh Adams</b></h2><h5 class="post__date">2017-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/daD_qwPR3SA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hey everybody thanks for coming if
you came to here to talk about
in some form then this is the right room
so who who in here is like 100% happy
with their software stability or like
its speed either what you build or what
you use hopefully no one I think we can
do a lot better than we do right now so
I want a world with better software and
if you want something to happen you
should take action and so like if I
wanted apples I'd plant a seed or
nurture a tree so I could get as many
apples as r1 so this talk is me planting
a seed I want better software so the
purpose is to convince you to care about
building better software or building
software better and once you care about
that I think that we will get better
software but who gives a crap right why
should you care at all about any of this
like we go to work we get paid we buy
donuts and if this doesn't change that
dynamic like what's in it for me well
this is what you spend your life doing
we all die eventually so sorry to kick
off the talk with morbidity but if it
makes you feel better there's more to
come so wouldn't you like your time on
earth to be spent doing doing something
that makes an impact in a positive way
software is the biggest leaver the
world's ever seen I like I like using
this picture for sort of this analogy so
using this software as a big ol lever
metaphor the best thing to do to have
more impact with our software would be
like to extend the lever right because
you get more leverage and so that's kind
of what computer science researchers do
so they you know every time they come up
with something novel
we get a little extra little bit of the
lever but I think it's sad but it's
basically unimportant that they do that
right now and the reason for that is
nobody uses like nobodies at the end of
the lever right now most of most of the
industry at least is sitting very close
to the fulcrum and like pushing and when
they want more done they push harder or
they get more bodies to come to push
harder
but like you need to move down the lever
to have more impact so anyway I think I
think often I see people get frustrated
by software being hard but they don't
like I can tell them hey you can move
down the lever by doing this or that and
they just kind of don't care because
it's not how I do stuff anyway so the
good thing for you is if you want to
like beat them
you can move down the lever and beat
people that are still doing doing stuff
dumb ways so what come back to sort of
that a little bit but let's talk about
where things are today so what does it
mean to be successful with your software
company if your software's useful I
assume that some people use that
software hopefully a lot of people use
that software because most business
model is not developed by the wu-tang
clan revolve around convincing a large
number of people to use your product so
let's assume you're working on really
successful software and do some math so
you have 10 million users this is pretty
good that's a decent number to get the
value out of the software that they need
they visit on average say 10 pages per
day I think this is an unusually a low
number if you have useful software but I
so that means I think that this is a
conservative estimate but you didn't
build your software very well so each
page load let's say takes on average six
seconds we probably don't have any
software extent in the world that has
long load times and that you wait on
regularly right not banks or other
financial software that have massive
massive basically everybody has to deal
with one of these or like the dashboard
of what is maybe the biggest modern
hosting platform that people care about
at least one of ok so 10 million users
visiting 10 pages per day that each
takes 6 seconds to load turns out that's
10 million minutes a day it's not an
easy number to wrap your head around 10
million is big and we don't handle big
numbers well so I wanted to break it
down so it's 166 thousand six hundred
sixty-six hours per day or six thousand
nine hundred forty four days per day
which is not a unit that I actually deal
in very often or 19 years per day so
that's 19 years a day spent looking at a
loading screen that's a lot of time but
who cares right we're making money we're
buying the doughnuts and everything's
good on an unrelated note the average
human lifespan is 80 years so
congratulations your software kills a
human every four days and it's software
so it doesn't ever sleep in its
bloodlust so I want to I'd like to
propose that our metrics dashboards
maybe should track a mortality rate
based on like you know load time right
alongside our other metrics to kind of
drill this into your head I think it's
kind of important but people don't care
about it but why do I bring it up to
convince you that you have an obligation
to do your job well if you aren't great
at it but you write successful software
that people use
you're basically more efficient at
snuffing out snuffing out human life
than the most effective serial killers
the world seen so I found this comic
from Saturday morning breakfast cereal
pretty relevant it says you know your
theorem and if your morphic function
construction I found a way to use it to
cure cancer
with the caption funtime activity
forcibly converting pure mathematicians
into applied mathematicians so think of
the person in the background as me and
my math earlier as the thing that makes
you cry at night as you come to grips
with your obligation so this leads me
into the point of the talk should we be
worried about getting things done now or
right this is the trade-off at the heart
of this tension between expediency and
correctness with that in mind let's talk
about object oriented programming versus
functional programming I'll talk about
my transition personally I just sort of
- I don't know personalize the situation
so this is a language Ruby that's near
and dear to my heart I learned about
Ruby with rails so like that was when I
became aware of it as before rails 1.0
came out it was in the comment section
of some slashed article I've looked for
it I have been able to find it but I do
remember that's the case so that people
don't think that I'm saying ruby is
awful in this talk since I am sort of
not bashing over P but suggesting a
transition understand I really love this
language before Ruby I was not
developing software in an expedient
manner and I wasn't building correct
software so Ruby introduced me to the
joy of test-driven development and this
helped me make my code substantially
more correct than it ever could have
been before I knew about this or sort of
vaguely knew about it but no one did it
because I was in a Microsoft dominated
space at the time it also just made made
me develop software much faster but in
the course of running a consultancy
building ruby apps for a decade some
things happened we got to build bigger
and bigger software more interesting
applications and these ultimately
required various forms of concurrency
and made me care about concurrency so I
continued to build the applications in
Ruby and at this point I stopped being
expedient or correct with my software
development practices so things were
basically awful any time we had any
scale on a concurrency focused
application either for the end-users or
you know if we are taking our obligation
seriously for the developers depending
on where we placed our concurrency
concern
so this point I felt like there were
cracks in my superpowers before I could
build stuff and build stuff that I
hadn't been able to build before and it
was like fast and people used it it was
great but once I got to this point it
stopped being fast it was not pleasant I
had a lot of people tell me that like
functional programming is great that's
like made them happy and it would help
me solve my issues but there was a
problem and it was this I folks the
programmers seemed really smart but the
ones I talked to seemed to not actually
build stuff and put it out in the real
world that they really enjoyed
programming so they'd spend a lot of
time seemingly just talking about like
how monads are like food stuff while I
was building applications with a real
business value and my clients were
selling their companies that we built
applications for for like nine figures
so I had a hard time taking it seriously
because no one that was telling me about
this was actually building software out
in the real world seemingly at least at
least the ones that were close to me but
conversely this is how folks know
programmer saw me and in a large part we
were both right at the time I think part
of the reason it felt like functional
programmers weren't building stuff
though is there's not a need for things
like the solid principles right and
consequently there were fewer smarmy
blog posts with very trivial concerns
that people still found interesting your
apps are composable by default if
they're made of functions their
functions are composable so fewer smarmy
blog posts meant that when they did post
they they had put out things that were
very dense or confusing seem like a lot
of work to somebody who you know there
were no beginner posts right so like
there's this big gap this gulf so I
think function programming wasn't
picking up very widely but my
superpowers had broken down and I didn't
want to do functional programming at the
time so I got interested in the actor
model in Ruby via celluloid as a library
there's an another sort of actor model
library out as well I forget the name of
it it was alright it was pretty good I
could do neater stuff and I get to
handle a little bit more load if you're
not familiar with the actor model it's
all about concurrent processes that like
live at the same time and send messages
each other and don't share memory with
the actor model I was able to build like
real time things that I couldn't have
dreamed about building successfully
earlier but it's not cracks because in
Ruby at least the default implementation
of celluloid depended on basically
threads and so you couldn't have you
could really get to like a thousand
actors
but you know tens of thousands of actors
was a no-go and so eventually again as
we hit scale things got bad I had to do
things like multiplex the purpose of
actors just so that they could do enough
stuff that we could support the load and
at that point I didn't really even get
the benefit of I got sort of the benefit
factors but I didn't get it was I was
not living the dream for sure all right
so do you know this guy is yeah so he's
a hero of mine if you're not familiar
with him you owe it to yourself to look
into him he invented the concept are ya
I mean the phrase I Victorian
programming while working on small talk
so he said this about modern
object-oriented programming he said I
invented the term object-oriented
programming our object-oriented and I
can tell you that C++ was not what I had
in mind the actor model is really what
he meant by object-oriented he's
confirmed this on like hacker news a
comment thread recently I'm not just
making it up I find that really
interesting these things get lost in
industry because people in industry
basically don't care about programming
history or reading about stuff I met
it's a broad broad brush I know but not
everyone in industry but industry as a
whole is mostly concerned with like
let's build this thing and maybe we need
a factory of people to do it and move on
anyway so people don't care as much
about programming history as maybe me so
I read everything that I could on the
actor model and if you do this this will
lead you to Erlang I really hated that I
couldn't ever seem to write my like
commas and semicolons and Erlang in the
right spots which on the first pass I
mean obviously I got it but I love the
primitives that Erlang provided and I
was like very very impressed with the
runtime I'm not saying the syntax is bad
it's just it's not necessarily
beginner-friendly to at least some
subset of people a friend then sent me a
talk by Jose a villain a tor dev and I
immediately decided that I needed to
look into his language which was elixir
and learn it but of course time is
finite so it took me a while eventually
though I did come to elixir and I fell
in love with it so this talk is a little
bit about elixir because the licks are
allowed me to start writing code that
was more correct than the code that I
was writing in Ruby but it still gave me
like the expediency of development that
I got in Ruby and so consequently
obviously correctness and expediency
aren't actually a dichotomy you can have
both
it's possible to expediently write code
that is correct
so there's actually one of the draws for
me to elixir I'm not trying to sell you
on elixir specifically in this talk but
I am suggesting there are some very
serious correctness benefits that a
language like this get you that you're
not really likely to achieve in practice
without this kind of tool at your
disposal if you're unlike the dotnet
stack there's F sharp it'll give you a
lot of the same benefits and it seems
awesome if you end up getting play with
or liens on the.net stack then I'll even
be jealous of you but probably not
without that and if you're a Java Scott
shop there Scala there's closure there's
Kotlin there are other things that might
fit the bill and still allow you to do
the work that you're doing but we're
gonna talk about elixir for now and just
discuss at a high level the parts that
were important in helping me write far
more correct code than I've been doing
before so the parts that normally come
up in any kind of survey of Aleks are
sort of a small part I'll discuss these
are the details that bring people to the
language typically and they're important
to get right so it's a functional
language this matters a whole lot if you
have a functional language especially a
highly concurrent and fault-tolerant
functional language then you can build
systems that are fast and isolated so
isolated failures that have insane
uptime while keeping the code easy to
reason about like my multiplex actors in
Ruby they were not easy to reason about
you had to know way too much to actually
figure out what was going on and I was
forced into that by constraints on kind
of the fundamental like the lingam
there's not a runtime really in Ruby but
the you know the language itself so
functional languages are inherently
composable so like all the work that you
put into building like foo which at
factory factories and stuff you don't do
that you just bend that focus on
actually building the software that
you're dealing with instead of these
weird abstractions that you ultimately
have to make so that you can compose
object-oriented stuff it's immutable
this is one of the most important things
right global mutable state is the source
of all evil
it's the worst but immutability makes
things way easier so for instance I
wrote a Tetris game in elixir and I have
like only allow valid moves function
right and so what I could do is I could
apply the moves and then look at what
the new state of the world would be and
be like should this be able to happen
and if it shouldn't I just throw it away
and if it should then that becomes the
new state so this is how I handled
collision detection in the game and it
was great I was not going to be able to
write that code
that way in Ruby because if you're
writing a Tetris game or something in
Ruby you're almost certainly mutating a
bunch of objects right you can't really
roll back easily you can't do deep
duplicates very easily especially in
Ruby but in most most other languages a
deep duplication it's like hard or
something anyway so once you mutate it's
very hard to like undo and rollback so
here's the code this is the collision
detection code I'm still dealing with
state a little bit more than I'd like to
but basically you handle input you give
it the original state and the thing that
happened you get news what the new state
would be bypassing and deferring to this
other do handle input function that
knows like what left arrow and right
arrow mean and then just a conditional
like if the new state is valid then cool
that's our new state and if it's not
valid then we just return the original
state and so by doing that nope any
button you press that returns an invalid
state just doesn't do anything because
we just throw away the new though what
would have happened if I were to model
this in a language that had like maybes
built into the standard library I would
do a little differently but I still
think it's pretty good I like it anyway
so this is one of the reasons that
immutability being first-class is really
important you can though get
immutability and almost in the language
it's like in Ruby there's hamster there
are various immutable libraries for
just about any language I'm sure and
those are good but generally they tend
to not be as fast as they could be if
they were like first-class they
definitely don't have as many users and
you have libraries that just won't work
with them right because they expect to
mutate things anyway so then there's
concurrency this is why I think most of
the people that I talk to come to the
language the early vertical machine that
elixir runs on has concurrency like
completely figured out if you're not
familiar with how the virtual machine
works or how Erlang scheduler works then
you're in luck I wholeheartedly
recommend reading up on it it's like one
of them like wonders of modern software
development because it's so simple but
so powerful in the meantime here's a
quick crash course and actually I stole
this live from Brian Hunter there well
he gave it to me so don't guess it
counts as stealing but in early and you
have they have a lot of these concurrent
processes that are running along they
can't block each other because because
of how they work so the way that works
is there's a schedulers and is really
one of these schedulers per core in
general you can tweak it and the
scheduler gives 2000 reductions to each
process in the loop by the
again you can tweak it and then the
scheduler handle the next process and a
reduction you can think of just being
like any machine instruction there's
that's essentially what they are because
they designed this this way like all of
the other concurrency things fall out of
it and so this is like this little
picture is why early age concurrency is
amazing they had to get this part
correct so there's an example of where
you can't really defer to expediency
right they could have built a virtual
machine or a scheduler that was like
faster to build or not fought through it
as well but if you do that you don't get
our Lang you don't get what we like to
like about the virtual machine but it
might also be an example of how
expediency still is okay kind of because
they're laying soft real time it's a
hard real time so it's conceivable that
you could build something like this
maybe with hard real-time properties but
I'm sure it's way harder and that's not
what our Lang did anyway so I think this
is fascinating I really love it I don't
know there's like just some aesthetic
about how it was built and when you read
up on how it works it's just very
impressive and also it's required that
you don't share state for this to be
sort of feasible anyway I found hard to
explain why I love it so much but just
the simplicity of the design makes me
feel warm like whiskey and then fault
tolerance is the other reason that
people come to the virtual machine so an
elixir application built properly just
runs forever just forever Ericsson built
the telephone switch that had nine nines
of uptime in Erlang that's a lot of
nines
it's basically unheard of I have a small
anecdote to mention here my consultancy
we had a client that was building
real-time delivery as a service so part
of the platform involved like a
WebSocket thing that would expose driver
location so drivers phones would you
know update us on where they were and
then people would view a map on the web
or mobile app and they would get
WebSockets to push the data down to them
I built that piece in elixir like before
elixir 1.0 before phoenix 1.0 and I
literally deployed it on a screen
session like I the first time it went
down to the first time we updated it I
was going to like do a proper proper
release and build a service and all that
but I never did all this thing did was
shuffle data and tweak some stuff and
handle encryption and authentication so
it's pretty basic service but still
eight months after I deployed it the CTO
called me and said hey just wanted to
double-check with
you were shutting down these machines on
Amazon and just wanted to make sure that
like you don't think we need them and
this was one of them the thing that I
built and he didn't know what it was
because he had never had to deal with it
because it never had a single problem
ever in its history I was still running
on screen eight months later and had
never dropped to anything this was
awesome this is not my typical
experience they actually pivoted
business models and didn't need this
feature anymore and so technically I'm
claiming 100% uptime of the service I
feel good about this although I'm told
that 100 uptime is also code speak for
we don't do monitoring properly so the
grain of salt okay so those are reasons
that people tend to come to the to
elixir and they're awesome but there are
few other really important parts of the
language that don't necessarily get as
much public love as they should and I
want to talk about those as well so
there's likely an equivalent these in
whatever your language of choice is
whether it's o or not now I'd like to
talk about the features that help you
ratchet up the correctness of your
software so there's dialyzer if you're
unfamiliar it lets you do what's called
success typing this isn't as strong as
like a hiddenly Milner type system but
it's way better than not having tied
checks and your software now the sweet
spot is that you can build software
without spending time specifying types
really think you throw together a
prototype whatever and then later you
can come back and you can add some sort
of type declarations on top of it and
let dialyzer run over your code and
it'll say turns out you said that this
thing could return only positive numbers
and if you know found a negative one or
whatever or you know or or you turns out
that this has to handle all negative
numbers and there's this one particular
case it doesn't handle or whatever so
with Ruby and Friends there's no way to
do this really reasonably your language
might have something like this if it
does I recommend you start using it
because you'll find your bugs before
they hit production like find them at
compile time or in your continuous
integration server rather than finding
them in your bug tracker for JavaScript
there's flow jeaious I'll talk about it
briefly later if you write JavaScript
you should use flow j/s so what benefits
do you get from a tool like this yeah I
mentioned it you can find case
statements they don't cover all their
cases sort of sort of like just general
stuff that you should handle and we
often don't okay then there's quick
check so it's a property based testing
tool and property based tests are
amazing they let you write code that
will
right tests that will verify code based
on properties that should have so for
instance you could specify some property
that a particular function should have
like this thing should act like the
native array module or for all of the
integers squaring the integer is the
square of the integer is greater than
the absolute value at n or equal to the
absolute value of the integer and they
then generate the equivalent of hundreds
or thousands or hundreds of thousands of
unit tests for you depending on how you
configure them and so this is another
example of a tool that lets you bolt on
correctness after the fact what's
amazing about it is that once it's found
a property failure may be our state
machine that through some weird thing
gets into a state it shouldn't get into
it will do something called shrinking so
it'll reduce it down to just the
smallest number of steps it could find
that led to the same bug and then that's
what it gives you and so you can see
like I do this this this this and this
and you hit an invalid state so I've got
a video that's linked in my slides that
I'll put up somewhere I guess
that has John Hughes actually talking at
NDC 2013 about how they built a quick
check harness for Volvo and it found
bugs in basically everybody's
implementation of the the protocols
where messages go around inside of your
vehicle so if you like not having people
run over you because of software bugs
like there's something to be given to
quick check and I'll give you a fun case
about this so one of the nastier bugs
that he found he actually goes into
detail in the video is higher priority
messages so like when you're building
these things that go over the canvas you
specify like this high priority there's
low priority and obviously the high for
already messages should come first
but there is one vendor where because of
an intricacy some low priority messages
could could go on the bus before the
high priority messages which it sounds
like okay what I like here well among
other things imagine that you have a lot
of low priority messages like hey turn
up the volume by a little bit and you
have a high priority message which is
like applied the brakes if you have
drive-by-wire brakes the low priority
messages would get processed before you
high priority message so realize this
the consequence of this is an edge case
where like when you want to turn up your
jams you might actually just not be able
to brake and squish that lady but
stroller
anyway so background to the morbidity
and the obligation to get things right
that is a thing that could could happen
if you write bad software
but enough about manslaughter let's talk
about tracing so it turns out that
you'll eventually one figure out what's
happening in production and if you're
using the Erlang VM they're great great
great tools to check this sort of thing
out if you're doing a lick sir or Erlang
there's this tool called early burly
that's really cool it's a java
application that connects to Erlang
Network and you can just do tracing and
other things so if you wanna play with
tracing it's a good starting point the
interesting thing about tracing in
elixir Erlang is you can hook into a
production system and you can just find
out about calls to a particular function
or to a particular function when the
third argument is seven or you know
anything else really you can think about
doing and this is good because doing
tracing like lowers the throughput of
your application right it's doing more
stuff so it's nice to not just like get
a log of everything that happens and
being able to filter very very tightly
the Heroku router is built in Erlang and
Freddie bear from their team talks a lot
about it in a book he has called Erlang
and anger I think anyway so really cool
stuff and in Java there's a thing called
like virtual VM it's not the same thing
but if you want if you aren't using if
you're writing job and you have not
played with a virtual VM you should play
with it it's great I'm not sure about an
equivalent tool on the net CLR I'm sure
one exists and then there's other just
really neat stuff that people ought to
talk about more and they don't really so
there's hype this is the one I wanted to
talk about which is high-performance
Erlang so the way this works is it
compiles an Erlang module into machine
code and then that machine code is
shipped so early modules are like
compiled into this beam file which is
like the virtual machine language and it
has all these parts and one of the parts
is the place where it stores the machine
code and so what you do is you have like
it compiles the the Erlang version and
then the machine code version and so
they both get shipped in the same file
so that means if you like if you build
that if you compile with hype and then
you move to a different architecture
your app still works the machine code
part isn't being run anymore it's back
to the interpreted part but that's very
cool it's really neat thing I haven't I
don't know of anywhere else that does
that anyway so this is important in the
context of expediency versus correctness
because people might bring up that
Erlang or leaks are slow and the first
certain workloads they definitely write
but height gives you like an escape
hatch that's fall short of having to
just rewrite your inner loop in C so
consequently gets the right code
you can get the guarantees from dialyzer
you can unequip tech on it and then you
just you know compile it to machine
language and you get better performance
anyway I think that's a nice trade off
so that's a lick sir and were the
lecture I found that I was able to build
software and more easily more quickly
that was way way way more correct and
provably so and when it wasn't correct
it didn't cripple everyone because of
default tolerance so anyway this is a
huge win even though elixir is
considered slow my stateless response
times drop from like 100 milliseconds on
a web server to like 4 milliseconds on
average and I know that's a very like
abstract context-free number but just in
general like doing the same thing and
say rails I hadn't drastically it's like
25 times worse performance anyway so
that's why folks with programming
languages can make the backend great but
these days you end up having to have
users and that means inevitably have to
write some sort of front-end code which
often means that you have to use
JavaScript so in the Expediency in
correctness flow javascript air is
entirely on the side of expediency and
says like yeah correctness is stupid
anyway so that's why I brought up
Facebook's flow at Jas
there are now some options for proving
correctness on JavaScript code and
that's really good it's nice to know
that your code does what you think it
does so as I mentioned flow is kind of
like dialyzer for JavaScript so if you
want to move your JavaScript along more
towards correctness you should be using
this but maybe just don't write
JavaScript at all because there's this
thing called elm and it's amazing so
it's beginner-friendly to a fault it's
really really beginner friendly john
carmack said that it has the best error
messages and everyone should should you
try to be like it it's got a
hindley-milner cell type system it's
instantly reactive strongly typed abs
they're very fast without a whole lot of
effort the renderer is faster than
basically all the other extant
frameworks for building friends and
JavaScript if focus is really really
heavily on favor and correctness over
expediency but it's still very fast to
build things I'm faster in it than I was
in react or anything else and I was
broadly considered a fairly fast
developer in those languages and it also
has manage side effects which are nice
if you if you care about that thing
that's a good thing so this is a diagram
of a typical Ellyn program so just look
at that for a little bit you'll you'll
figure it out sorry okay
so it might seem confusing but the
important part is just you provide those
green boxes so there's like four
functions basically that you provide the
man
and I'll kind of go through them so the
unit function returns your applications
initial model state so like your
application has some state and then like
it looks a certain way view is like a
function on the state the update
function handles incoming messages and
update your model and could send outside
effects that's what that command type is
those are things that like the commands
are like gosh would be nice if somebody
would make this HTTP request for me so
like their a a request for a thing but
not doing the thing and then the runtime
handles doing excuse me doing the things
and so everything is pure like all of
these functions are pure you can't write
an impure function actually every
function has a single expression that's
all the function can be so the type
system because that model and command
separation in the output of update
encourages our forces strict separation
between things that change state in a
pure fashion and things that ask for
outside help anyway so the view function
just takes your model as input and it
produces say an interface to the user
right whether it be HTML buddy mine made
a thing that rendered as the view it
rendered like this cork synthesizer grid
of buttons on a hardware device so
anyway when the user interacts with the
view they can produce messages and those
messages ultimately get routed by the
runtime back to your update function so
pretty the user produces a message that
goes through update you say what to do
with that message and then the view
updates if the state changed and then
you have subscriptions and those are
just things that happen in the outside
world so you can think of this as
WebSockets right somebody sent me a
thing I didn't ask for it it just
happened or the ticking of a clock right
that's why I have a clock down there
and then those also produce messages and
then all of those same messages get
routed through the update function this
might seem complicated but we'll see a
basic program real quick this is a
stereotypical first Elm application so
here are the types our model is just an
integer we have two possible met so our
message is a union type or a algebraic
data type it has two possible values
increment or decrement
so again message is literally every
single thing that can happen in our
application is you know exists in that
type when we get a message it ends up
being provided to our update function
along with the current model so the
first are
his message the second target is model
and you know the result is a model and
we have just a case statement here it
says do a case statement on the message
if I didn't handle all of the messages
this won't compile right so if I just
forgot to say what happens in the case
that somebody sends me a message that
you know has a nil or whatever it would
be like you know nothing but then I
can't compile my code and it'll tell me
but here we're saying look if we get an
increment message we just increment that
integer that is our model we get that
commit message we just decrement it by
one you could get these same guarantees
in elixir Erlang by using dialyzer and
specifying a type for your handle cast
functions with like type specs if those
words mean anything to you and then
enforcing the dialyzer passes in your
test test script so you don't get them
like it's not like it won't compile but
you wouldn't be able to run your tests
successfully all right so then we get to
our view our view takes the current
model and produces that type HTML
message that's a parametrized type so
HTML can produce something and the thing
it can produce is our define type of
message and so that means that we know
all of the possible things that could
come out of this HTML that we're
rendering and so we just have a div the
HTML stuff basically consists of like a
function that is for the type of thing
and then a list of attributes in the
list of children so we have no
attributes on the div and then we have
children three of them we have a button
when you click it it's decrement it
sends out a decrement message and it's
like inner containers a text node with a
minus sign in it same thing for the plus
button although obviously with plus and
then in the middle there we have just
the models count the current value of
the model I should actually say model
based on what I said the model was but
whatever model not counting is not a
thing and then this is kind of how you
wire stuff together so this is a
beginner program there's two variants of
it but basically you say here's my first
model here's my view here's my update we
have no subscriptions in this
application that's the difference
between like beginner program and
program program anyway so that's it
that's how you wire everything together
and that basically though that's a data
structure that you handle the runtime
and so that it knows what to do with the
messages that it gets from the view
where to send them anyway so if you get
one thing out of this talk I want it to
be the math at the beginning if you get
two things out of this talk I want you
to try ohm
if you haven't used if you've never felt
like just joy at a type system which
maybe sounds weird we'll give you that
and it'll make you think about
programming and
in a different way can potentially if
you don't already think of it this way
and it'll make you want to write more
correct code and this is the brief
portion of the talk that we refer to as
advertising where I mentioned that I
happen to run a startup that does daily
continuing education on elm elixir react
natives with three other things because
I want to make people help people
they'll talk for a better anyway so if
you want to like look into elmer elixir
i can help you you can come talk to me
later are there any questions so far
there's no more advertising the talks
just a bit moving forward so now is like
a really good time if there questions
specifically about this part awesome
okay so let's talk about computer
science before i move on i want to
reiterate the two primary technical
takeaways i want you to leave with which
is slow software is killing people and
you should check out home but like why
did i decide to give this talk in the
first place at all historically i've
given very code focused talks that focus
almost entirely on like hey we built
this thing and like here's some cool
stuff that came out of it and let's talk
about that very light on the philosophy
typically but this is this is john
backus
if you don't recognize his name you'll
definitely recognize a couple of things
he's known for so the first is Fortran
in 1953 he worked at IBM he convinced
his superiors to let him build a
language that made it easier work with
like math equations than coding assembly
directly for trains the imperative
language it's been developed ever since
1953 it also now supports parallelism
and object-oriented programming this
strikes me as hilarious because it did
not I mean if you like what it looked
like originally so different anyway so
there's one reason that you might know
who yes here's an example Fortran code
just so you've seen it before it's
extremely imperative there's just a
recipe so I always call these recipes it
tells the computer what to do step by
step so it's essentially just a thin
shim on top of assembly but you know
easier to write he also invented what's
known as the Bacchus normal form or
discovered probably invented you might
hear backus-naur form because there's
another guy that also kind of at roughly
the same time discovered it it's a means
of defining the rules of a context-free
grammar and essentially every
programming language or markup language
that you know has a BNF or an e be
enough definition this is part of the
BNF grammar for json just so you can
have some in front of you
RFC's they're littered with BNF
definitions and so john backus is
responsible for Fortran which is one of
the longest-lived if not the
longest-lived extent programming
language and the means by which people
define what what their programming
languages are the grammar so he's pretty
influential he knows what he's talking
about and here if you're sure he'll
notice I'm now making what's known as an
appeal to Authority he's also extremely
familiar with imperative code and his
invention of BNF got him won him the
1977 Turing award which lady I'm giving
a talk titled kin programming be
liberated from the von Norman style so
he was so troubled by what he saw
happening as a consequence of this
imperative coding that everyone was
doing he took the opportunity of his
most prominent speech of his life to
tear imperative programming to shreds
and he does this guy named Freddy and
Kowski from The Omen community is the
person who linked me to this paper I'd
heard of it before but he mentioned that
it was you know that had it affected him
pretty strongly and so I'd heard about
it hadn't read it so I sat down one
night with a whole pot of coffee at
midnight like one will do it was only 26
pages so I thought it should go pretty
quickly but it took me two hours to
digest it the first time and since then
I've read around ten or twenty at this
point more times so it changed my life
it's it's a good paper if you want just
like to play with papers it's not too
dense it's it's easy to get through with
sufficient coffee it's worth talking
about a few things here before we get
into the paper itself too far so first
off what does he mean by the von
Lehman's style to explain that let me
first introduce this guy this is Alan
Turing in 1936 he came up with the
universal Turing machine this is the
foundational model that all of our
computers are built on it consisted of
an infinite tape and a read and write
head out of these simple pieces anything
that we can do in a computer today right
we can do so the one thing you couldn't
build from this model was an actual
computer because we have a shortage of
infinite tapes but that's where this guy
comes in
in 1945 john von neumann described the
machine that they had built to do some
math for some reason or another and this
machine was an actually constructible
realization of Turing machine it's
philosophically identical to the laptops
that everyone has you program it by
giving it essentially a recipe of
instructions right that's the imperative
stall that we're all familiar with
that's how it works in essence you have
your input you have a CPU you have some
memory that it's connected to
you read your input does some stuff
maybe store stuff in memory and then put
stuff out the output oh also those
arrows right those are the bus between
the CPU and the memory because it has to
get data over there somehow
anyway back to back us here's some code
this is written an algal which is what
he developed to be an f4 originally so
this is some code that he uses in his
paper to make a point if I leave it here
for a bit and you look at it and squint
real hard you might figure out what it
does does anybody know what it does it
there's no way I would have figured it
out in this time period okay so it took
me a long time to figure out it is inner
product so it defines inner product and
imperative fashion there are few things
that back has found interesting and
suboptimal about this style of coding
and so I'll just kind of list them he
said there's there some invisible state
that a that being that in they don't
appear here and it's being operated over
by complex rules this is not
hierarchical it's not building up from
like these basic simple operations
really in a composed fashion it's
dynamic and repetitive right that for
loop is the essence of repetition right
that's what it does you have to work
through what it does in your head in
order to properly understand it you have
to internally handle bookkeeping for
mutating that see variable you have to
remember that that I variable is
incrementing that's not hard right we
all learn to do it but we all did have
to learn to do it but his biggest gripe
was that it computes word of the time
because it's mutating the state its
modifying something in memory right like
you can imagine maybe this fits in the
CPU cache or whatever but in general
like any time you're mutating state
you're going over that bus and putting
something in memory or getting something
out of memory so yeah in this case it's
modifying the high in the see it has
named arguments a B and N and that means
it only works on vectors of links in
though there's nothing that says that
you'd have to know that and only on the
vectors named a and B and granted we
could like handle these with a function
call by using named parameters but that
too is assignment and so ultimately that
means taking data out of memory into the
CPU and vice versa so let's talk about
how that works again this is the von
Neumann machine and that thing at the
bottom is the bus so those two errors
are what is referred to as the von
Neumann bottleneck each bit of mutation
that happens essentially move some data
across this bus from the CPU to memory
and this is slow it's way slower than
keeping computation and data on the CPU
itself like if you have to go fetch the
data
it takes time way more time than doing
the math his complaint was that most of
programming in the imperative style
revolved around bookkeeping and that
meant that we were going over this all
the time
and that's that's slow both physically
and it's low for the program raised you
think about it as you reason about all
the data interchange because you have to
think like you know what was that
variable name or like if ivory if I've
used that variable for then I'm
overriding it and oops that's gonna
cause a bug but not an obvious bug it's
some insidious bug that just kind of
happens later anyway so my whole life I
heard about the vonroenn bottleneck but
this is the paper where he coined the
term and he explicitly talks about it as
also being this bottleneck for the
programmers mind and I'd never heard
anyone tell me that before so this is
why I think it's valuable to read papers
because it is you have to spend a lot of
time like learning to write code
learning to do the mutation in your head
to read it successfully and before I buy
the paper I thought he was only talking
about the physical bottleneck so there's
a different way to write the same inner
product function this is just some
pseudocode you can imagine that each
carriage return is just compose like
compose this function with the next one
so this is a point free notation form of
inner product so it's a pretty
straightforward way to implement inner
product you kind of have to have dealt
with point free programming style for it
to be quick to read I think but it is
small and you can see that it's sort of
composable right we've built up these
pieces and we compose them by composing
the function in this what's called and
that gives us this bigger function but
what's interesting about building
something this way is when you make a
recipe you've you know what the
relationships are between these things
in your head and then you write out a
recipe and if the computer does it then
the outcome you desire happens but
you've lost you know it's a lossy it's
basically a lossy compression form to
turn it into this imperative code
because the computer can't infer what
you were trying to do with your recipe
right you know mentally like I want to
zip the things together on a map over
that and multiply the two things and
then I want to reduce that by adding but
when you do it the other way like to get
optimizations that you could get for not
for free but way easier if the
relationships between these things were
like actually still in the code we end
up spending
centuries of like master-student time
adding edge case optimizations to the
java virtual machine anyway so what do
you found interesting about this is
there's no implicit state required a b
and n don't appear there are no
variables there's no assignment at all
it's hierarchical it's constructed of
functions that are composed together and
then three very simple functions using
two sort of even simpler functions and
you can as long as you're familiar with
reading the style you can understand
what it's doing without really executing
it mentally in your head so it says what
it's doing is it's a couple of lists it
maps a multiplication across them and it
reduces them with plus the other code
didn't read that way you couldn't read
the code and know for sure what it was
and you could figure it out but it
didn't just lay it out there for you and
it's not repetitive it contains three
steps the previous thing contained in
step so the size of the vector changed
how many times you mutated data right
this doesn't do that so it's just just
better it's fewer steps it's easier to
read I know it's a loaded term to call
this a more correct version of that
function I don't think this is actually
a value judgment I think it is like very
clearly more correct but that's up to
you to decide the fact remains though
that here we're not describing sequence
operations and recipe for describing a
relationship between these functions and
that is not lossy compression right
that's we keep that so recap the things
that are important here there's no
assignment we're not concerning
ourselves with the bookkeeping across
the funnel and bottleneck and no point
do we as programmers have to think about
what variable holds but data make sure
we increment in make sure we don't have
an off by one error none of that happens
we just describe the relationship that
this function has with other functions
so you can't accidentally shadow a
variable you can't have your off by one
errors you can't have yeah but this one
you can have a division by zero because
it's not using division anyway so I can
almost guarantee that like shadowing a
variable or you know overriding a
variable accidentally or off by one
errors have cost you or your employer
employer money and time whether you're
aware of it or not because we described
it the way we did it's strictly
composable so we don't need to define a
function that takes named arguments or
anything like that we can just like
compose these functions and that's
the thing we have each of the individual
bits are also composable so if we want
to go something that's very like inner
product but instead of multiplication it
has some other function you just like
you use the first two bits like and then
just change that that sort of top piece
we don't have to fill it with like
dependency injection or plug-in
architectures or build this complex
object Factory to make things that are
composable and then we get back to the
professor at the blackboard because
Bacchus spoke about being able to do
algebra on programs and this is really
what he actually cared about so being
able to do higher-order reasoning on our
programs themselves so here we define
the function in terms of fundamental
mathematical operations and that's what
you do algebra already so we can do
algebra on this this type of program but
if you have a recipe right and period of
stuff I think of as a recipe if I said
to you my goal is to do algebra on
recipes you would think that's the
craziest freaking thing I've ever heard
and it shouldn't be and that was this
concern right you should be able to do I
mean programming his math we can do
algebra on like mathematical structures
so why can't we do algebra on programs
and this was a concern his in 77 and
we're still basically doing the same
thing yeah so that's it basically this
is that's the reason that I think of
this style is more correct ultimately so
what's the point of the talk there there
are three things that I want you to take
away from the talk and if you've been
paying attention you'll note that I've
lied to you twice no because I've
changed the number of things I wanted
you to take away so how does it feel how
do you feel about that anyway this is
the real note this is the real number I
swear
first stop killing people you have an
obligation to build your software better
if we as a community don't take our
obligation seriously we're gonna be in a
world of hurt so politicians will start
regulating us right if we have
essentially a bridge failure we will
have regulation of our industry or worse
we could be forced to write JavaScript
if you can come to grips with the naked
like sheer cruel truth of my math then
you already know that you have an
obligation to do stuff better I think a
great way to stop doing it to do stuff
better would be like to learn now more
elixir feel free to do it via daily drip
but that's up to you murderer and then
secondly give them a try it's an amazing
language
it'll if you have not dealt with things
like Haskell or you know something like
that it will change the way that you
think it'll also change the way you
think about tooling because it's tooling
is really really good
the beginner experience is better than
any other language I've ever used which
is good because like I kind of vaguely
knew Haskell but not really and now I
know how school way better because I
learned Elm
it'll also teach you that you can take
some time upfront and encode like the
types in your system like encode
semantics into the types that make it
impossible to do to ever have a certain
state right imagine you have the
software equivalent of a bridge right
and it in some way like if you had this
off by one area right there be a problem
or the equivalent so like I haven't have
another example that is in my talk
tomorrow but the point is you can build
your type such that impossible states or
states that would be really bad just
can't be in or it can't be expressed in
your types and so you can't write code
that would get you into the mess as long
as you encode stuff properly by you know
thinking a little harder upfront about
your types you can avoid you can just
type away edge cases like just they're
gone you never have to think about them
again this is really awesome it'll give
you confidence in your code that you
don't have if you don't have a type
system like this anyway and finally
think functionally it's still possible
to write in period of code in most
functional languages you can't really do
it in Elm but it looks like you can it
does make it a lot harder to even have
it look like you can though you can do
it in the lick sir I often do write
things that are more imperative an
elixir I'm trying to get better and then
so you could write less in period of
stall code you can both on correctness
starting out with unit tests make sure
you run them automatically every time
you commit anything you know you should
have a CI server ideally you should have
a CI server that protects your master
branch we can't even merge code into our
master branch unless it passes tests so
and then you can add tooling like
dialyzer a quick check or whatever the
equivalents are in your language and you
can gain even more confidence in your
code so we can do better we have an
obligation to do better so let's make
the world suck a little less together
thank you any questions alrighty then
that is my talk</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>