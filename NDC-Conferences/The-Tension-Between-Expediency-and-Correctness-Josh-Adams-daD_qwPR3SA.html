<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Tension Between Expediency and Correctness - Josh Adams | Coder Coacher - Coaching Coders</title><meta content="The Tension Between Expediency and Correctness - Josh Adams - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Tension Between Expediency and Correctness - Josh Adams</b></h2><h5 class="post__date">2017-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/daD_qwPR3SA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so everybody
for coming if you came to
in some form than
the right room so who in here is like
one hundred percent happy with their
self for stability or like its speed
either what you build or what you use
hopefully no one I think we can do a lot
better than we do right now so I want a
world with better software and if you
want something to happen you should take
action and so like if I wanted apples I
plant a seed or nurture a tree so I can
get as many apples as I want so this
talk is me planting a seed I want better
software so the purpose is to convince
you to care about building better
software or building software better and
once you care about that I think that we
will get better software but who gives a
crap right why should you care at all
about any of this like we go to work we
get paid we buy doughnuts and if this
doesn't change that dynamic like what's
in it for me well this is what you spend
your life doing we all die eventually so
sorry to kick off the talk of morbidity
but if it makes you feel better there's
more to come so wouldn't you like your
time on earth to be spent doing doing
something that makes an impact in a
positive way software is the biggest
leave for the world's ever seen i like i
like using this picture for sort of this
analogy so using this software is a big
ol ever metaphor the best thing to do to
have more impact with our software we
like to extend the labor right because
you get more leverage and so that's kind
of what computer science researchers do
so they you know every time they come up
with something novel we get a little
extra little bit of the lever but I
think it's sad but it's basically
unimportant that they do that right now
and the reason for that is nobody uses
like nobody's at the end of the lever
right now most of most of the industry
at least is sitting very close to the
fulcrum and like pushing and when they
want more done they push harder they get
more bodies to come to push harder but
like you need to move down the lever to
have more impact so anyway I think I
think often I see people get frustrated
by software being hard but they don't
like I can tell them hey you can move
down the lever by doing this or that and
they just kind of don't care because
it's not how I do stuff anyway so the
good thing for you is if you want to
like beat them you can move down the
lever and beat people
that are still doing doing stuff dumb
ways so we'll come back to sort of that
a little bit but let's talk about where
things are today so what does it mean to
be successful with your software company
if yourself airs useful I assume that
some people use that software hopefully
a lot of people use that software
because most business models are not
developed by the wu-tang clan revolve
around convincing a large number of
people use your product so let's assume
you're working on really successful
software and do some math so you have 10
million users it's pretty good that's a
decent number to get the value out of
software that they need they visit on
average say 10 pages per day I think
this is an unusually low number if you
have useful software but I so that means
I think that this is a conservative
estimate but you didn't blow your
software very well so each page load
let's say it takes on average six
seconds we probably don't have any
software extent in the world it has long
load times and that you wait on
regularly right not banks or other
financial software that have massive
massive basically everybody has to deal
with one of these or like the dashboard
of what is maybe the biggest modern
hosting platform that people care about
at least one of okay so 10 million users
visiting 10 pages per day that each
takes six seconds to load turns out
that's 10 million minutes a day it's not
an easy number to wrap your head around
10 million is big and we don't handle
big number as well so I wanted to break
it down so it's 160 6666 hours per day
or 6944 days per day which is not a unit
that I actually deal in very often or 19
years per day so that's 19 years a day
spent looking at a loading screen that's
a lot of time but who cares right we're
making money we're buying the doughnuts
and everything's good on an unrelated
note the average human lifespan is 80
years so congratulations your software
tools of human every four days and it's
software so it doesn't ever sleep in its
bloodlust so I want to I'd like to
propose that our metrics dashboards
maybe you should track a mortality rate
based on like in a load time right
alongside or other metrics to kind of
drill this into your head I think it's
kind of important but people don't care
about it but why do I bring it up to
convince you that you have an obligation
to do your job well if you aren't graded
it but you write successful software
that people use you're basically more
efficient it's nothing
snuffing out human life than the most
effective serial killers the world scene
so I found this comic from saturday
morning breakfast cereal pretty relevant
it says you know your pyramid if your
morphic function construction I found a
way to use it to cure cancer with the
caption fun time activity forcibly
converting pure mathematicians into
applied mathematicians so think of the
person in the background as me and my
math earlier as the thing that makes you
cry at night as you come to grips with
your obligation so this leads me into
the point of the talk should we be
worried about getting things done now or
right this is the trade-off at the heart
of this tension between expediency and
correctness with that in mind let's talk
about object-oriented reaming versus
functional programming I'll talk about
my transition personally just sort of
two I don't know personalize the
situation so this is the language Ruby
that's near and dear to my heart I
learned about Ruby with rails so like I
was when I became aware of it before
rails one point 0 came out it was in the
comments section of some / article I've
looked for it I have been able to find
it but i do remember that's the case so
the people don't think that I'm saying
Ruby is awful in his talk since I'm sort
of not bashing over PA but suggesting a
transition understand I really love this
language before Ruby I was not
developing software in an expedient
manner and I wasn't building correct
software so Ruby introduced me to the
joy of test-driven development and this
helped me make my code substantially
more correct than it ever could have
been before I knew about this or sort of
vaguely knew about it but no one did it
because I was in a Microsoft dominated
space at the time i also just made made
me develop software much faster then the
course of running a consultancy building
ruby apps for a decade some things
happened we got to build bigger and
bigger software more interesting
applications and these ultimately
required various forms of concurrency
and made me care about concurrency so i
continued to build the applications in
ruby and at this point I stopped being
expedient or correct with my software
development practices so things were
basically awful any time we had any
scale on a concurrency focused
application either for the end users or
you know if we are taking our obligation
seriously for the developers depending
on where we placed our concurrency
concerns
so this point I felt like there were
cracks in my superpowers before I could
build stuff and build stuff that I
hadn't been able to build before and it
was like fast and people used it it was
great but once i get to this point it
stopped being fast it was not pleasant i
had a lot of people tell me that like
functional program is great it's like
made them happy and it would help me
solve my issues but there was a problem
and it was this i Function programmer
seemed really smart but the ones i
talked to seemed to not actually build
stuff and put it out in the real world
but they really enjoyed programming so
they'd spend a lot of time seemingly
just talking about like how monads are
like food stuff while i was building
applications with real business value
and my clients were selling their
companies that we built applications for
for like nine figures so i had hard time
taking it seriously because no one that
was telling me about this was actually
building software out in the real world
seemingly at least at least the ones
that were close to me but conversely
this is how functional programmer saw me
and in a large part we were both right
at the time I think part of the reason
it felt like functional programmers
weren't building stuff though is there's
not a need for things like the solid
principles right and consequently there
were fewer smarmy blog posts with very
trivial concerns that people still found
interesting your apps are composable by
default if they're made of functions
their functions are composable so fewer
smarmy blog posts meant that when they
did post they they had put out things
that were very dense or confusing seemed
like a lot of work to somebody who you
know there are no beginner post right so
like there's this big gap this golf so I
think folks are programming wasn't
picking up vary widely but my
superpowers had broken down and I didn't
want to do functional programming at the
time so I got interested in the actor
model in Ruby via cellular way to the
library there's another sort of actor
model library out as well I forget the
name of it it was alright it was pretty
good i could do neither stuff and I
could handle a little bit more load if
you're not familiar with the actor model
it's all about concurrent processes that
like live at the same time it's in
messages each other and don't share
memory with the actor model I was able
to build like real-time things that I
couldn't have dreamed about building
successfully earlier but it's odd cracks
because in Ruby at least the default
implementation of celluloid depended on
basically threads and so you couldn't
have you could really get to like a
thousand actors but
tens of thousands of actors was a no-go
and so eventually again as we hit scale
things got bad I had to do things like
multiplex the purpose of actors just so
that they could do enough stuff that we
could support the load and at that point
I didn't really even get the benefit of
Omega sort of the benefit of actors but
I didn't get it was I was not living the
dream for sure all right so do you know
who this guy is yeah so he's a hero of
mine if you're not familiar with him you
owe it to yourself to look into him he
invented the concept or yes I mean the
phrase object Orion while working on
small talk so he said this about modern
object-oriented programming he said I
invented the term object or any
programming object-oriented I can tell
you that C++ was not what I had in mind
the actor model is really what he meant
by object-oriented he's confirmed this
on like hacker news comment thread
recently I'm not just making it up I
find that really interesting these
things get lost in industry because
people in industry basically don't care
about programming history or reading
about stuff i mean it it's a broad broad
brush I know but not everyone in
industry but industry as a whole is
mostly concerned with like let's build
this thing and maybe we need a factory
of people to do it and move on anyway so
people don't care as much about
programming histories maybe me so I read
everything that I could on the actor
model and if you do this this will lead
you to Erlang I really hated that I
couldn't ever seem to write my like
commas and semicolons and Erlang in the
right spots which on the first pass I
mean obviously I got it but i love the
primitives that Erling provided and i
was like very very impressed with the
runtime i'm not saying the syntax is bad
it's just it's not necessarily beginner
friendly to at least some subset of
people a friend then sent me a talk by
jose a villain at or dev and I
immediately decided that I needed to
look into his language which was a lick
sir and learn it but of course time is
finite so it took me a while eventually
though I did come to elixir and I fell
in love with it so this talk is a little
bit about elixir because the lick sir
allow me to start writing code that was
more correct in the code that I was
writing in Ruby but it still gave me
like the Expediency of development that
I got in Ruby and so consequently
obviously correctness and expediency
aren't actually the economy you can have
both it's possible to expediently write
code that is
correct so there's actually one of the
drawers for me to elixir I'm not trying
to sell you on the licks are
specifically in this talk but I am
suggesting there are some very serious
correctness benefits that a language
like this get you that you're not really
likely to achieve in practice without
this kind of tool of your disposal if
you're unlike the dotnet stack there's
FG ARP will give you a lot of the same
benefits and it seems awesome if you end
up getting play with Orleans on the.net
stacked and i'll even be jealous of you
but probably not without that and if
you're to java scott shop there scala
this closure there's Kotlin there are
other things that might fit the bill and
still allow you to do the work that
you're doing but we're gonna talk about
elixir for now and just discuss at a
high level the parts that were important
in helping me right far more correct
code than I've been doing before so the
parts that normally come up in any kind
of survey of elixir are sort of a small
part I'll discuss these are the details
that bring people to the language
typically and they're important to get
right so it's a functional language this
matters a whole lot if you have a
functional language especially a highly
concurrent and fault-tolerant functional
language then you can build systems that
are fast and isolated so isolated
failures that have insane up time while
keeping the code easy to reason about
like my multiplex actors in ruby they
were not easy to reason about you had to
know way too much to actually figure out
what was going on and i'll sports into
that by constraints on kind of the
fundamental like alam there's not a
runtime really in ruby but the you know
the language itself so functional
languages are inherently composable so
like all the work that you put into
building like food widget factory
factories and stuff you don't do that
you just bend that focus on actually
building the software that you're
dealing with instead of these weird
abstractions that you ultimately have to
make so that you can compose object
oriented stuff it's immutable this is
one of the most important things right
global mutable state is the source of
all evil it's the worst but immutability
makes things way easier so for instance
i wrote a Tetris game in elixir and I
have like only allow valid moves
function right and so what I could do is
I could apply the moves and then look at
what the new state of the world would be
and be like should this be able to
happen and if it shouldn't I just throw
it away if it should then that becomes
the new state so this is how I handled
collision detection in the game and it
was great I was not going to be able to
write that code that way in Ruby because
you're writing a Tetris game or
something
Ruby you're almost certainly mutating a
bunch of objects right you can't really
roll back easily you can't do deep
duplicates very easily especially in
Ruby but in most most other languages a
deep duplication it's like hard or
something anyway so once you mutate it's
very hard to like undo and roll back so
here's the code this is the collision
detection code I'm still dealing with
state a little bit more than I'd like to
but basically you handle input you give
it the original state and the thing that
happened you get news what the new state
would be bypassed man deferring to this
other do handle input function that
knows like what left arrow and right
arrow mean and then just a conditional
like if the new state is valid then cool
that's our new state and if it's not
valid then we just return the original
state and so by doing that nope any
button you press that returns an invalid
state just doesn't do anything because
we just throw away the new though what
would have happened if i were to model
this in a language that had like maybes
built into the standard library I would
do a little differently but I still
think it's pretty good I like it anyway
so this is one of the reasons that
immutability being first class is really
important you can though get
immutability and almost into language so
I can Ruby there's hamster there are
various immutable libraries for Amelie
just about any language I'm sure and
those are good but generally they tend
to not be as fast as they could be if
they were like first-class they
definitely don't have as many users and
you have libraries that just won't work
with them right because they expect to
mutate things anyway so then there's
concurrency this is why I think most of
the people that I talk to come to the
language the Erling virtual machine that
elixir runs on has concurrency like
completely figured out if you're not
familiar with how the virtual machine
works or how earling scheduler works
then you're in luck I wholeheartedly
recommend reading up on it it's like one
of them like wonders of modern software
development because it's so simple but
so powerful in the meantime here's a
quick crash course and actually I stole
this slide from Brian hunter there well
he gave it to me so I don't guess it
counts as stealing but inner Lane you
have they have a lot of these concurrent
processes that are running along they
can't block each other because because
of how they work so the way that works
is there's schedulers and is really one
of these schedulers per core in general
you can tweak it and the scheduler gives
2000 reductions to each process in the
loop by default again you can tweak it
and then the scheduler handle the next
process
and a reduction you can think of just
being like any machine instruction
there's that's essentially what they are
because they designed this this way like
all of the other concurrency things fall
out of it and so this is like this
little picture is why earliest
concurrency is amazing they had to get
this part correct so there's an example
of where you can't really defer to
expediency right they could have built a
virtual machine or a scheduler that was
like faster to build or not fought
through it as well but if you do that
you don't get our lang you don't get
what we like like about the virtual
machine but it might also be an example
of how expediency still is ok kind of
because they're laying soft real time
it's a hard real-time so it's
conceivable that you could build
something like this maybe with hard
real-time properties but I'm sure it's
way harder and that's not what our link
did anyway so I think this is
fascinating I really love it I don't
know there's like just some aesthetic
about how is built then when you read up
on how it works it's just very
impressive and also it's required that
you don't share state for this to be
sort of feasible anyway I find hard to
explain why I love it so much but just
the simplicity of the design makes me
feel warm like whiskey and then fault
tolerance is the other reason that
people come to the virtual machine so an
elixir application built properly just
runs forever just forever Erickson built
the telephone switch that had nine nines
of uptime in Erlang that's a lot of
nines basically unheard of I have a
small anecdote to mention here my
consultancy we had a client that was
building real-time delivery of the
service so part of the platform involved
like a WebSocket thing that would expose
driver location so drivers phones would
you know update us on where they were
and then people would view a map on the
web or mobile app and they would get web
sockets to push the data down to them I
built that piece in a lick sir like
before lecture 1 point 0 before Phoenix
1 point 0 and I literally deployed it on
a screen session like I the first time
it went down and the first time we
updated I was going to like do a proper
proper release and build a service and
all that but I never did all this thing
did was shuffle data and tweak some
stuff and handle encryption and
authentication so it's pretty basic
service but still eight months after i
deployed that the CTO called me and said
hey just wanted to double-check with you
we're shutting down these machines on
amazon and just
make sure that like you don't think we
need them and this was one of them the
thing that I built and he didn't know
what it was because he had never had to
deal with it because it never had a
single problem ever in history I was
still running on screen eight-month
eight months later and had never dropped
anything this was awesome this is not my
typical experience they actually pivoted
business models and didn't need this
feature anymore and so technically I'm
claiming one hundred percent of time of
the service I feel good about this
although I'm told that one purpose is up
time is also code speak for we don't do
monitoring properly so the grain of salt
okay so those are reasons that people
tend to come to elixir and they're
awesome but their feel the really
important parts of the language that
don't necessarily get as much public
love as they should and I want to talk
about those as well so there's likely an
equivalent these in whatever your
language of choice is whether it's 00 or
not now I'd like to talk about the
features that help you ratchet up the
correctness of your software so there's
dialyzer if you're unfamiliar it lets
you do what's called success typing this
isn't as strong like a hidden Lee Milner
type system but it's way better than not
having type checks and your software now
the sweet spot is that you can build
software without spending time
specifying types really think you throw
together a prototype whatever and then
later you can come back and you can add
some sort of type declarations on top of
it and let dialyzer run of your code and
it'll say turns out you said that this
thing could return only positive numbers
and if I found a negative one or
whatever or you know or you turns out
this has to handle all negative numbers
and there's this one particular case it
doesn't handle or whatever so Ruby and
friends there's no way to do this really
reasonably your language might have
something like this if it does I
recommend you start using it because
you'll find your bugs before they hit
production like find them at compile
time or in your condition of Grayson
server rather than finding them in your
bug tracker for JavaScript there's flow
jeaious i'll talk about it briefly later
if you write javascript you should use
flow jas so what benefits do you get
from a tool like this yeah I mentioned
it you can find K statements they don't
cover all the cases sort of like just
general stuff that you should handle and
we often tell okay then there's quick
check so it's a property based testing
tool and property based tests are
amazing they let you write code that
will write tests that will verify code
based on properties that should have so
if
for instance you could specify some
property that a particular function
should have like this thing should act
like the native array module or for all
of the integers squaring the integer is
the square of the energy is greater than
the absolute very cool to the absolute
value of the integer and they didn't
generate the equivalent of hundreds or
thousands or hundreds of thousands of
unit tests for you but depending on how
you configure them and so there's
another example of a tool that lets you
both on correctness after the fact
what's amazing about it is that once
it's found a property failure may be out
of state machine that through some weird
thing gets it of state it shouldn't get
into it will do something called
shrinking so it'll reduce it down to
just the smallest number of steps that
could find that led to the same bug and
that's what it gives you and so you can
see like I do this this this this and
this and you hit an invalid state so
I've got a video that's linked in my
slides that i'll put up somewhere i
guess that has john hughes actually
talking at NDC 2013 about how they built
a quick check harness for volvo and it
found bugs in basically everybody's
implementation of the the protocols
where messages go around inside of your
vehicle so if you like not having people
run over you because of software bugs
like there's something to be given to
quick check and i'll give you a fun case
about this so one of the nastier bugs
that he found he actually goes into
detail in the video is higher priority
messages so like when you're building
these things that go over the canvas you
specified like this high priority
there's low priority and obviously the
high priority messages should come first
but there is one vendor where because of
an intricacy some low priority messages
could could go on the bus before the
high priority messages which it sounds
like okay what about here well among
other things imagine that you have a lot
of low priority messages like hey turn
up the volume by a little bit and you
have a high priority message which is
like applied the brakes if you have
drive by wire breaks the low priority
messages would get processed before you
high priority message so realize this
the consequence of this is an edge case
where like when you want to turn up your
jams you might actually just not be able
to break and squish that lady with a
stroller anyway so background to the
morbidity and the obligation to get
things right that is a thing that could
happen if you write that software but
enough about manslaughter let's talk
about tracing so
turns out that you'll eventually wanna
figure out what's happening in
production and if you're using the
Erlang vm they're great great great
tools to check this sort of thing out if
you're doing a lick sir or early there's
this tool called early burly that's
really cool it's a java application that
connects to Erlang network and you can
just do tracing and other things so if
you wanna play with tracing it's a good
starting point the interesting thing
about tracing in a lecturer lying is you
can hook into a production system and
you can just find out about calls to a
particular function or to a particular
function when the third argument is
seven or you know anything else really
you can think about doing and this is
good because doing tracing like lowers
the throughput of your application rise
doing more stuff so it's nice to not
just like get a log of everything that
happens and being able to filter very
very tightly the Roku router is built in
Erlang and Freddie bear from their team
talks a lot about it in a book he has
called or laying in anger I think anyway
so really cool stuff and in Java there's
a thing called like virtual vm it's not
the same thing but if you want if you
aren't using if you're writing job and
you have not played as a virtual vm you
should play with it it's great I'm not
sure about an equivalent tool on the net
CLR i'm cherylin exists even then
there's other just really neat stuff
that people ought to talk about more and
they don't really so there's hype this
is the one I wanted to talk about which
is high performance Erlang so the way
this works is it compiles an erlang
module into machine code and then that
machine code is shipped so early modules
are like compiled into this beam file
which is like the virtual machine
language and it has all these parts and
one of the parts is the place where it
stores the machine code and so what you
do is you have like it compiles the the
Erlang version and then the machine code
version and so they both get shipped in
the same file so that means if you like
if you build that if you compile type
and then you move to a different
architecture your app still works the
machine code part isn't being run
anymore it's back to the interpretive
part but that's very cool it's really
anything I haven't I don't know anywhere
else that does that anyway so this is
important in the context of expediency
versus correctness because people might
bring up that are laying or leaks are
slow and for certain workloads they
definitely right but height gives you
like an escape hatch that's follow short
of having to just rewrite your inner
loop in C so consequently gets the right
code you can get the guarantees from
dialyzer you can run a quick check on it
and then you just you know compile it to
machine language and get better
performance anyway I think that's a nice
trade off so that's a lick sir and with
lecture I found that I was able to build
software and more easily more quickly
that was way way way more correct and
provably so and when it wasn't correct
it didn't cripple everyone because of
the fault tolerance so anyway this is a
huge win even though elixir is
considered slow my stateless response
times drop from like a hundred
milliseconds on a web server to like
four milliseconds on average and I know
that's a very like abstract context-free
number but just in general like doing
the same thing and say rails I had
drastically it's like 25 times worse
performance anyway so that's why folks
with programming languages can make the
back in gray but these days you end up
having to have users and that means
inevitably have to write some sort of
front-end code which often means that
you have to use JavaScript so in the
expediency and correctness flow
javascript error is entirely on the side
of expediency and says like yeah
correctness is stupid anyway so that's
why I brought up Facebook's flow that
Jas there are now some options for
proving correctness on JavaScript code
and it's really good it's nice to know
that your code does what you think it
does so as I mentioned flow is kind of
like dialyzer for javascript so if you
want to move your JavaScript along more
towards correctness you should be using
this but maybe just don't write
JavaScript at all because there's a sink
old elm and it's amazing so it's
beginner friendly to a fault it's really
really beginner friendly john carmack
said that it has the best error messages
and everyone should should try to be
like it it's got a Henley Mulder cell
type system instantly reactive strongly
typed apps they're very fast without a
whole lot of effort the renderer is
faster than basically all the other
extant frameworks for building friends
and JavaScript if focus is really really
heavily on favor and correctness over
expediency but it's still very fast to
build things I'm faster in it than i was
in react or anything else and I've
broadly considered a fairly fast
developer in those languages and it also
has managed side effects which are nice
if you if you care about that thing
that's a good thing so this is a diagram
of a typical Ellen program so just look
at that for a little bagel you'll figure
it out sorry okay so i might seem
confusing but the important part is just
you provide those green boxes so there's
like four functions basically that you
provide the matter
and I'll kind of go through them so the
unit function returns your applications
initial model state so like your
application has some state and then like
it looks a certain way view is like a
function on the state the update
function handles incoming messages and
update your model and could send out
side effect that's what that command
type is those are things that like
the commands are like God should be nice
if somebody would make this HTTP request
for me so like they're a request for a
thing but not doing the thing and then
the runtime handles doing excuse me
doing the things and so everything is
pure like all of these functions are
pure you can't write an impure function
actually every function has a single
expression that's all the function can
be so the type system because that model
in command separation in the output of
update encourages our forces strict
separation between things that change
state in a pure fashion and things that
ask for outside help anyway so the view
function just takes your model as input
and it produces say an interface to the
user right whether the HTML buddy mine
made a thing that rendered as the view
it rendered like this corec synthesizer
grid of buttons on a hardware device so
anyway when the user interacts with the
view they can produce messages and those
messages ultimately get routed by the
runtime back to your update function so
pretty the user produce a message that
goes through update you say what to do
with that message and then the view
updates if to stay changed and then you
have subscriptions and those are just
things that happen in the outside world
so you can think of this as web sockets
right somebody sent me a thing I didn't
ask for it it just happened or the
ticking of a clock right that's why I
have a clock down there and then those
also produce messages and then all of
those same messages get routed through
the update function this might seem
complicated but we'll see a basic
program real quick this is the
stereotypical first Elm application so
here are the types our model is just an
integer we have two possible mets our
message is a union type or algebraic
data type it has two possible values
increment or decrement so again message
is literally every single thing that can
happen in our application is you know
exists in that type when we get a
message it ends up being provided to our
update function along with the current
model so the first organ
his message the second target is model
and the you know the result is a model
and we have just a case statement here
says do a case statement on the message
if I didn't handle all of the messages
this won't compile right so if I just
forgot to say what happens in the case
that somebody sends me a message that
you know has an ill or whatever it would
be like in a nothing but then I can't
compile my code and it'll tell me but
here we're saying look if we get an
increment message we just increment that
integer that is our model we get a
decrement message we just decrement it
poem you could get these same guarantees
and elixir erling by using dialyzer and
specifying a type for your handle cast
functions with like tight specs if those
words mean anything to you and then
enforcing the dialyzer passes in your
test test script so you don't get them
like it's not like it won't compile but
you wouldn't be able to run your tests
successfully all right so then we get to
our view our view takes the current
model and produces that type HTML
message that's a parametrized type so
HTML can produce something and the thing
it can produce is our define type of
message and so that means that we know
all of the possible things that could
come out of this HTML that we're
rendering and so we just have a div the
HTML stuff basically consists of like a
function that is for the type of thing
and then a list of attributes in the
list of children so I have no I have
utes on the div and we have children
three of them we have a button when you
click it it's decrement it sends out a
decrement message and it's like inner
containers a text node with a minus sign
in it same thing for the plus button
although obviously with plus and then in
the middle there we have just the models
count the current value of the model I
should actually say model based on what
i said to model was but whatever all
that count is not a thing and then this
is kind of how your wires stuff together
so this is a beginner program there's
two variants of it but basically you say
here's my first model here's my view
here's my update we have no
subscriptions in this application that's
the difference between like beginner
program and program anyway so that's it
that's how you wire everything together
and that basically that's a data
structure that your handle the runtime
and so that it knows what to do with the
messages that it gets from the view of
where to send them anyway so if you get
one thing out of this talk I want it to
be the mass at the beginning if you get
two things out of this talk I want you
to try on if you haven't used if you've
never felt like just joy at a type
system which may be sounds weird elm
will give you that and it'll make you
think about programming and it
different way can potentially if you
don't already think of it this way and
it'll make you want to write more
correct code and this is the pre force
in the talk that we refer to is
advertising where I mentioned that I
happen to run a startup that does daily
continuing education on Elm elixir react
natives with three other things because
I want to make people help people build
software better anyway so if you want to
like look in to Elmore elixir I can help
you you can come talk to me later are
there any questions so far there's no
more advertising the talks just a bit
moving forward so now is like a really
good time if their questions
specifically about this part awesome
okay so let's talk about computer
science before we move on I want to
reiterate the two primary technical
takeaways I want you to leave with which
is slow software is killing people and
you should check out out but like why
did I decide to give this talk in the
first place at all historically I've
given very code focused talks that focus
almost entirely on like hey we built
this thing and like here's some cool
stuff that came out of it let's talk
about that very light on the philosophy
typically but this is this is john
backus if you don't recognize his name
you'll definitely recognize a couple of
things he's known for so the first is
Fortran in 1953 he worked as IBM he
convinced his superiors to let him build
a language that made it easier work with
like math equations than coding assembly
directly for trains the imperative
language it's been developed ever since
nineteen fifty-three it also now
supports parallelism and object-oriented
programming this strikes me as hilarious
because it did not mean feel ago but it
looked like originally so different
anyway so there's one reason that you
might know who he is here's an example
fortran code just so you've seen it
before it's extremely imperative there's
just a recipe so i always call these
recipes it tells the computer what to do
step-by-step so it's essentially just a
thin shim on top of assembly but you
know easier to write he also invented
what's known as the bacchus normal form
or discovered probably invented you
might hear Backus now reformed because
there's another guy that also kind of at
roughly the same time discovered it it's
a means of defining the rules of a
context-free grammar and essentially
every programming language or markup
language that you know has a BNF or
Annie BNF definition this is part of the
dnf grammar for JSON just so you can
have
front of you a feud RFC's that littered
with BNF definitions and so John Backus
is responsible for fortran which is one
of the longest lived if not the
longest-lived extent programming
language and the means by which people
define what their programming languages
are the grammar so he's pretty
influential he knows what he's talking
about and here if you're sharp you'll
notice i'm now at making what's known as
an appeal to authority he's also
extremely familiar with imperative code
and his invention of bmf got him won him
the 1977 Turing award which led him
giving a talk titled can programming be
liberated from the von lemon style so he
was so troubled by what he saw happening
as a consequence of this imperative
coding that everyone was doing he took
the opportunity of his most prominent
speech of his life to tear imperative
programming to shreds and he does this
guy named Freddy in kowski from The Omen
community is the person who linked me to
this paper I've heard of it before but
he mentioned that it was you know that
has it affected him pretty strongly and
so I heard about it hadn't read it so I
sat down one night with a whole pot of
coffee at midnight like one will do it
was only 26 pages so I thought it should
go pretty quickly but it took me two
hours to digest that the first time and
since then I've rather around 10 or
probably 20 at this point more times so
it changed my life it's it's a good
paper if you want just like to play with
papers it's not too dense it's easy to
get through with sufficient coffee it's
worth talking about a few things here
before we get into the paper itself too
far so first off what does he mean by
the von linemen style to explain that
let me first introduce this guy this is
alan turing in 1936 he came up with the
universal turing machine this is the
foundational model that all of our
computers are built on it consisted of
an infinite tape and a read and write
head out of these simple pieces anything
that we can do in a computer today right
we can do so the one thing you couldn't
build from this model was an actual
computer because we have a shortage of
infinite tapes but that's where this guy
comes in 1945 John von Neumann described
the machine that they had built to do
some math for some reason or another and
this machine was an actually
constructible realization of Turing
machine it's philosophically identical
to the laptops that everyone has you
program it by giving it essentially a
recipe of instructions right that's
being fair to stall they're all familiar
but that's how it works in essence you
have your input you have a CPU you have
some memory that it's connected to
a cpu read your input does some stuff
maybe store stuff in memory and then put
stuff out the output oh also those
arrows right those are the bus between
the CPU and memory because it has to get
data over there somehow anyway back to
back us here's some code this is written
in algal which is what he developed to
be NF for originally so this is some
code that he uses in his paper to make a
point if I leave you here for a bit and
you look at it and squint real hard you
might figure out what it does is mi know
what it does it there's no way I would
have figured it out in this time period
okay so it took me a long time to figure
out it is inner product so it defines
inner product and imperative fashion
there are few things that back has found
interesting and suboptimal about this
style of coding and so I'll just kind of
list them he said there's there some
invisible state that a that being that
in they don't appear here and it's being
operated over by complex rules this is
not hierarchical it's not building up
from like these basic simple operations
really in a composed fashion it's
dynamic and repetitive write that for
loop is the essence of repetition right
that's what it does you have to work
through what it does in your head in
order to properly understand it you have
to internally handle bookkeeping from
mutating that C variable you have to
remember that I variable is incrementing
that's not hard right we all learn to do
it but we all did have to learn to do it
but his biggest gripe was that it
computes word of the time because it's
mutating the state it's modifying
something in memory right like you can
imagine maybe this fits in a CPU cache
or whatever but in general like anytime
you're mutating state you're going over
that bus and putting something in memory
or getting something out of memory so
yeah in this case it's modifying the I
in the sea it has named arguments a B&amp;amp;N
and that means it only works on vectors
of links in though there's nothing that
says that you have to know that and only
on the vectors named a and B and granted
we could like handle these with a
function call by using name parameters
but that too is assignment and so
ultimately that means taking data out of
memory into the CPU and vice versa so
let's talk about how that works again
this is the van or no machine and that
thing at the bottom is the bus so those
two errors are what is referred to as
the von Neumann bottleneck each bit a
mutation that happens essentially move
some data across this bus from the cpu
memory and this is slow its way slower
than keeping computation and data on the
CPU itself like if you have to go
fetch the data it takes time way more
time than doing the math his complaint
was that most of programming in the
imperative style revolve around
bookkeeping and that meant that we were
going over this all the time and that's
that slow both physically and it's low
for the program raise you think about it
as you reason about all the data
interchange because you have to think
like you know what was that variable
name or like if ivory if I've used that
variable for then I'm overriding it and
oops that's going to cause a bug but not
an obvious bug at some insidious bug
that just kind of happens later anyway
so my whole life I heard about the von
roan bottleneck but this is the paper
where he coined the term and he
explicitly talks about it as also being
this bottle night for the program his
mind and I never heard anyone tell me
that before so this is why I think it's
valuable to read papers because it is
you have to spend a lot of time like
learning to write code learning to do
the mutation in your head to read it
successfully and before I buy the paper
I thought he was only talking about the
physical bottleneck so there's a
different way to write the same inner
product function this is just some
pseudocode you can imagine that each
carriage return to just compose like
composed this function but the next one
so this is a point free notation form of
inner product so it's a pretty
straightforward way to implement inner
product you kind of have to have dealt
with the point free programming style
for it to be quick to read I think but
it is small and you can see that it's
sort of composable right we've built up
these pieces and we compose them by
composing the function this what's
called and that gives us this bigger
function but what's interesting about
building something this way is when you
make a recipe you've you know what the
relationships are between these things
in your head and then you write out a
recipe and if the computer does it then
the outcome you desire happens but
you've lost you know it's a lossy it's
basically a lossy compression form to
turn it into this imperative code
because the computer can't infer what
you were trying to do with your recipe
right you know mentally like I want to
zip the things together on a map over
that and multiply the two things and
then I want to reduce that by adding but
when you do it the other way like to get
optimizations that you could get for not
for free but way easier if the
relationships between these things were
like actually still in the code we end
up spending
man centuries of like master student
time adding edge case optimizations to
the Java Virtual Machine anyway so what
he found interesting about this is
there's no implicit state requires a B&amp;amp;N
don't appear there are no variables
there's no assignment at all it's
hierarchical it's constructed their
functions that are composed together and
then three very simple functions using
to sort of even simpler functions and
you can as long as you're familiar with
reading the style you can understand
what it's doing without really executing
it mentally in your head so it says what
it's doing is if a couple of lists it
maps multiplication across them it
reduces them with plus the other code
didn't read that way you couldn't read
the code and know for sure what it was
and you could figure it out but it
didn't just lay it out there for you and
it's not repetitive it contains three
steps the previous thing contained in
step so the size of the vector changed
how many times you mutated data right
this doesn't do that so it's just just
better fewer steps it's easier to read I
know it's a loaded term to call this a
more correct version of that function I
don't think this is actually a value
judgment i think it is like very clearly
more correct but that's up to you to
decide the fact remains though that here
were not describing sequence operations
and recipe for more describing a
relationship between these functions and
that is not lossy compression right
that's we keep that so recap the things
that are important here there's no
assignment we're not concerning
ourselves with the bookkeeping across
the bundle and bottleneck at no point do
we as programmers have to think about
what variable holds but data make sure
we increment in make sure we don't have
an off by one error none of that happens
we just described the relationship that
this function has with other functions
so you can't accidentally shadow
variable you can have your off by one
errors you can't have about this one you
can have a division by zero because it's
not using division anyway so I can
almost guarantee that like shadowing a
variable or you know overriding a
variable accidentally or off by one
errors have cost you or your employer
employer money in time whether you're
aware of it or not because we described
it the way we did it's strictly
composable so we don't need to define a
function that takes named arguments or
anything like that we can just like
compose these functions and that's
thing we have each of the individual
bits are also composable so if we want
to go something that's very like inner
product but instead of multiplication it
has some other function you just like
you use the first two minutes like and
then just change that that sort of top
piece we don't have to fill it with like
dependency injection or plugin
architectures or build this complex
object factory to make things that are
composable and then get back to the
professor of the blackboard because
becca spoke about being able to do
algebra on programs and this is really
what he actually cared about so being
able to do higher-order reasoning on our
programs themselves so here we define
the function in terms of fundamental
mathematical operations and that's what
you do algebra already so we can do
algebra on this this type of program but
if you have a recipe the imperative
stuff I think of as a recipe if I said
to you my goal is to do algebra on
recipes you would think that's the
craziest freaking thing I've ever heard
and it shouldn't be and that was this
concern right you should be able to do I
mean programming is math we can do
algebra on like mathematical structures
so why can't we do algebra on programs
and this was a concern his in 77 and
we're still basically doing the same
thing yeah so that's that's it basically
this is that's the reason that I think
of this style is more correct ultimately
so what's the point to talk there are
three things that I want you to take
away from the talk and if you've been
paying attention you'll note that I've
lied to you twice no because I've
changed the number of things I want you
to take away so how does it feel how
y'all feel about that anyway this is the
real real number I swear first stop
killing people you have an obligation to
build your software better if we as a
community don't take our obligation
seriously we're going to be in a world
of hurt so politicians will start
regulating us right if we have
essentially a bridge failure we will
have regulation of our industry or worse
we could be forced to write JavaScript
if you can come to grips with the naked
like sheer cruel truth of my math then
you already know that you have an
obligation to do stuff better I think a
great way to stop doing it to do stuff
better would be like to learn el amor
elixir feel free to do it be a daily
trip but that's a few murderer and then
secondly give them a try it's an amazing
language it'll if you have not dealt
with things like Haskell or you know
something like that it will change the
way that you think it'll also change the
way you think about tooling because it's
tooling is really really good
the beginner experience is better than
any other language I've ever used which
is good because like I kind of vague the
new Haskell but not really and now I
know Haskell way better because I
learned l it'll also teach you that you
can take some time upfront and encode
like the types in your system like
encode semantics into the types that
make it impossible to do to ever have a
certain state right imagine you have the
software equivalent of a bridge right
and it in some way like if you had this
off by one area right there be a problem
or equivalent so like I have another
example that is in my talk tomorrow but
the point is you can build your type
such that impossible states or states
that would be really bad just can't be
entered can't be expressed in your types
and so you can't write code that would
get you into the mess as long as you
encode stuff properly by the you know
thinking a little harder up front about
your types you can avoid you can just
type away edge cases like just they're
gone you never have to think about them
again this is really awesome it'll give
you confidence in your code that you
don't have if you don't have a type
system like this anyway and finally
think functionally it's still possible
to write in period of code in most
functional languages you can't really do
it in Elm but it looks like you can it
does make it a lot harder to even have
it look like you can though you can do
in the lick sir I often do write things
that are more imperative and elixir I'm
trying to get better and then so you can
write less imperative stall code you can
both on correctness starting out with
unit tests make sure you run them
automatically every time you commit me
thing you know you should have a CI
server ideally you should have a CI
server that protects your master branch
we can't even merge code into our master
branch unless it passes tests so and
then you can add tooling like dialyzer a
quick check or whatever the equivalent
are in your language and you can gain
even more confidence in your code so we
can do better we have an obligation to
do better so let's make the world suck a
little less together thank you any
questions
alrighty then that is my talk</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>