<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Travel Guide to Software Systems - Patrick Kua | Coder Coacher - Coaching Coders</title><meta content="Travel Guide to Software Systems - Patrick Kua - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Travel Guide to Software Systems - Patrick Kua</b></h2><h5 class="post__date">2018-02-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tuVdq6Jnh_c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Hey good afternoon so I'm going to be
talking today about the Travel Guide
systems but I want to talk a little bit
about the company that I work for so I
work for a company called N 26 we're a
challenger bank based in Germany so we
actually have a banking license based in
Germany which means that we operate in
the eurozone and it's kind of an
exciting place to be I've actually
started there about three months ago as
a CTO and since then we've grown from
500,000 users to 700,000 users so we'll
be launching in the UK some sometime
later this year we get very strong
recognition from Google and Apple about
our application and we're really focused
on usability so it really comes through
in sort of our banking solution the role
that I play there is really around sort
of technology in the CTO through the
leadership around that and for us the
theme of documentation actually makes a
big important aspect of being compliant
with the sort of banking regulations so
what I really want to talk about is we
don't really want to sort of challenge
just the technology but also the way
that we we sort of maintain compliance
and also helping people understand the
value that documentation can bring which
is what the point of today's talk is a
little bit about my background is I used
to work for thought works for about
thirteen and a half years I have sort of
worked in agile methods for about 15
years so I have a book about
retrospectives which for me is really a
key about learning I invest in sort of
building technical leaders and so that's
the second book around technical
leadership talking with tech leads most
recently published building evolutionary
architectures with two other authors and
this was really about how do we actually
think about architecting foot change and
I've got talks out there if you'd like
to learn a little bit more about that on
the internet but itinerary for today is
really thinking about perhaps why we
might consider using something like a
Travel Guide what's the value of a
travel guide when we're actually trying
to navigate a new software system we
also want to think about maybe what you
want to have in preparing for your trip
of getting onboard with a new sort of
system or helping other people prepare
for their trip when they're about to go
to a new destination now obviously when
you're actually working in a software
system you want to make the most of your
time and this is where we want to maybe
explore how you make the most of
building your travel guide such that the
time that you invest is actually paying
back the value that you have
I think one of the things that I really
also want to focus on is perhaps
comparing examples from real life about
how other people have been putting
together their travel guide for their
software systems to hopefully inspire
you on making your own travel guide for
the systems that you have and hopefully
leave you with the message that it's
important to make sure that we as
developers and software builders pay it
forward for other future travelers like
we do when we're actually traveling
around to different destinations so the
first part of this is really thinking
about why we might consider a travel
guide now how many of you like to go on
the holidays okay hopefully most of you
do right and hopefully you maybe like to
go and explore something different that
you've never been to before somewhere
exotic and maybe one of the things that
you're thinking about is where do you
decide to go and how do you prepare for
experiencing the wealth of what an
exotic location may have now when we
actually go in and sort of turn up and
there are some of you that maybe you
would love to maybe live by the seat of
your pants a little bit more and sort of
turn up and then just explore and often
you might end up in a place like this
you find yourself on a street in a
foreign town and maybe if you're like me
maybe you're a little bit more cautious
about where you turn up particularly as
you know the day it turns into night and
the alleyway that looks very promising
is now starting to look a little bit
scary and so you're starting to think
about in this new foreign land maybe
you're starting to question well where
am I so where am I as part of this sort
of software system or this new town that
I'm actually in more importantly am I
actually safe where I am so I've
travelled a lot to places like India and
Brazil and you know it's really hard to
sometimes know if you're in a safe place
if there's no one around you in some
sort of side street you want some sort
of guidance now if you're going to a
foreign sort of country perhaps where
English or your native tongue isn't
spoken you have to think about well how
do we actually communicate with people
what are the customs and cultures that
we have to understand so that we don't
sort of violate or upset people that we
get along and that we can actually
openly communicate with the things that
we actually need to have and also how do
you achieve your goal so when you're on
a holiday some of you may be there to
see the sights some of you may be there
actually meet locals and sort of
experience and live local culture now in
any sort of holiday or journey that you
have you have some sort of task and the
question is when you're in some sort of
side street where do you begin with your
particular goal now if you're like me
one of the things that you're kind of
thinking about it is how does this
actually apply to us in software systems
so I've seen a lot of different teams
and I've seen the way the little people
sort of on board new engineers and it's
kind of interesting because often one of
the first things that people have is
that you know we want people to write
code get into production and so they ask
people to sort of set up their account
and sort of check out the code and it
looks a little bit like this okay so
they're looking at code and they're kind
of under trying to understand what does
this actually mean and then they maybe
start scrolling through the code trying
to decipher what is the context of this
now can anyone have a guess as to this
kind of a famous codebase that some of
you might be familiar with I'll give you
a hint it's one of the largest code
bases out there that's used quite
heavily yeah so it's the UNIX kernel
Linux kernel so it's more than 200
million lines of code and what I've
shown you is only just a small portion
of it so excluding comments and white
spaces we have 19 lines of code so
imagine yourself as a person who wants
to contribute to the Linux kernel where
do you even begin to even navigate
yourself to understand how you
contribute to something as massive as
scale as this kind of project you need
something to help you navigate your way
around and to orient yourself such that
you can be really productive and this is
definitely the experience that new
engineers have when they join a new team
when they join a new industry and even
when they shift around in your new
company to a new sort of part of a
different system they have lots of
questions that they have to answer so
that are orient themselves around and so
this is kind of the whole point around
thinking about when you land in a new
place and when engineers join a new
project you want to be able to give them
a travel guide to help them orient now
like all travel guides there's different
types of sort of formats so obviously
you have like your personal travel guide
that you can take with you but you also
have lots of different sort of
electronic or book type travel guides
and we want to explore perhaps the idea
about what makes a really good travel
guide so that people are really prepared
to make the most of their own particular
journey now it's interesting because we
live in very you know very modern
digital areas and yet when we go
traveling you probably think about a
couple of big brands that actually
happen when you think about travel
guides so you probably think about the
Lonely Planet you probably think about
the Rough Guides maybe you are sort of
going onto TripAdvisor to understand
recommendations from people and even use
things like wiki travel and so it's
really interesting because even though
we have so many different types of
applications out there sort of mobile
phones with like internet we still rely
on things like this because there's a
value to it when something is super
foreign to where we are and so when we
actually think about these kind of
travel guides we have to ask why is
there a demand for this still even
though we have Google at the touch of a
sort of button when we're actually
traveling well when we're actually
thinking about software systems one of
the things that definitely happens over
time is that people will sort of move in
and out of teams so the average sort of
tenure for an engineering company is
maybe about two years it's probably even
less on a particular software system and
so we have to actually think about this
kind of constant sort of churn of people
coming and going on particular projects
and we want to make sure that each new
people that sort of join a particular
team are really prepared to understand
what's happened before them so that they
can also contribute really effectively
to the current sort of system now one of
the things as a CTO I think about
scaling organizations and when we
actually think about sort of personal
tour guides you know it's very sort of
personal but it also doesn't necessarily
scale to the number of people so when
you have an intimate sort of personal
tour guide you can scale up to maybe a
group of sort of 15 or 20 people but if
you're thinking about how do you leave
information for people who may join at
different stages where other people may
not be available you also need to rely
on the sort of a written format to make
sure that there's sort of asynchronous
communication as well and not just that
synchronous conversational tone of where
travel guides really come into play I
think one thing that I've recognised
over time as an engineer is that
everyone is very proud about the systems
that you will build yeah we all like
building things seeing it being used
by people and so one other aspect of the
Travel Guide is also thinking about how
you leave a legacy so I think one thing
that I really you know really impressed
by people is that they're so proud of
the systems they build and we want to
have a way of capturing some of the
interesting aspects of what they've
contributed to that isn't necessarily
always represented in code and finally
it's really thinking about what are the
sort of preventing undetected unwanted
detective work so you know where we all
forget things over time we all wonder
why is this part of the codebase strange
and unfamiliar and how did it evolve
that way and at that time there was
probably good reasons for that but often
it gets lost in the passage of time and
we want to think about other ways of
capturing these important decisions that
helps us and our future selves because
we forget things but also helps benefit
other people who may join that project
so you know in a lot of places people
don't have travel guides for software
systems when they do it's maybe a bit
too voluminous but there's a couple of
different alternatives to travel guides
as I see it so one is pretty much
nothing so a lot of people don't
actually write any documentation for the
systems they have they assume people
will join their teams they'll learn
everything absorbed through osmosis and
then maybe after three months they'll
still have questions about what's
happening and people don't really have
much of a sort of support framework
around them there's another thing that
probably resonates with the sort of MDC
conference here which is the idea of
Viking tales right of we gather around a
campfire and we tell you all the stories
of what happened to this system over
time what were the battles that we
fought that we overcame and this is the
legacy that we've left in the sort of
code base this is really wonderful and
this is a really engaging way to get
people to understand the context of
their software system but it does suffer
from a little bit of a problem and this
is the game that's called telephone game
maybe you've played it in school at some
time in this game you actually get a
list of sort of a chain of people one
after the other and you start off by
whispering a sort of message in one
person's ear and the goal of this is for
them to sort of whisper it to the next
person down the chain and then to see at
the end of this chain what is the
message that appears what often happens
is that we hear something and it's not
quite exactly what
we had said and over this telephone game
the message transforms into something
very different and this is one of the
problems with a sort of oratory history
of systems is that the details and
sometimes those important details morph
it's unintentional but it's what we do
as humans about we take things in we
filter things we transform them in our
own sort of mental mindset and then we
express them in our own words it's not
malicious but it definitely happens and
as a result we lose context over time we
end up with grand fables but some basis
may not actually be on truth now I'm a
big fan of agile sofa development I
talked about doing sort of address of
development for 15 years and I have to
admit I think this is a little bit to
blame so you know I think we've gone
really well at sort of thinking about
continuous delivery automated testing
working small Sprint's or iterations but
I think there was one thing on this sort
of manifesto which was kind of missed
out and this is this statement about
working software over comprehensive
documentation now I have the feeling
based on working with lots of different
teams over years is that a lot of people
interpret this as working software over
documentation not over comprehensive
documentation you know the code
expresses everything that we need to say
you don't need anything else why do we
need to write documentation it's a waste
of time we have whiteboard diagrams and
that's enough and what I'm trying to do
is really highlight the points that
there is a certain level of value that
documentation has and we need to think
about what that value is and make sure
that we address those bits that help
other people in the future and help our
future selves as well when we come back
to parts of the system that we haven't
really encountered so hopefully we've
had a thought about maybe in your
context how a travel guide could be
useful for future team members or your
future self the next question I guess is
well you have a travel guide what are
the elements that make sense to put into
this what do we need to prepare
ourselves to make a really good sort of
travel guide and I'll go through
different types of elements that you may
consider they're not necessarily
elements but you may think about why
it's important to capture these details
and make sure they're available in some
format so the first one is really about
the history of the system now what's
really interesting about software is
that we don't build software because we
feel like building software unless it's
your personal project a lot of the time
software is built because they're there
to solve a particular problem we're
there to maybe automate something or
maybe there to help visualize rich sets
of information and so what we want to
think about is what's the context of how
our software is being used who are the
users of this of the software that we
are aiming for for what business value
or purpose is it now you can't really
necessarily go to a single line in your
codebase that explains here is the
purpose of this system and so you want
to think about how do you frame that
context such that when new people come
on board they understand why they're
contributing to the system that they're
working on you want to think about maybe
the story is about the ways that the
system has emerged
so perhaps you started off with very
very basic sort of flat file handling
because it was the simplest lightest way
possible way of working and then you
sort of gradually added layers on of
automation to take into richer and
richer use cases and so often those sort
of phases of a system will sort of
dictate certain parts of the codebase so
when you look at a long-lived codebase
and you look at here are some EJ B's you
know we know what era perhaps that this
software was actually written because
that was kind of the fad of the day and
maybe we look at now microservices and
we say here are the reasons why they're
actually sort of evolved and that's why
we have EJ B's over here and we have
nice restful web services over here
maybe you want to think about what are
the hard lessons learnt right so we
threw this software into production and
then we realized the architecture wasn't
going to scale and so we had to make
some big changes to parts of our sort of
system architecture to make sure that we
could de couple certain parts so that we
could handle more throughput from a user
side and deal with these requests in an
asynchronous manner now these are really
important decisions that you need to
sort of help people understand and it's
very difficult to go to one place in the
codebase that explains why you have
perhaps two different parts of your
system and you need to help people sort
of understand the context behind that
now a really good tool around capturing
these things is something called
architecture decision records so if
you've read Michael Nygard blog here's
the author of release it
he talks about these arcs a decision
records as a really great way of sort of
capturing important decisions so you
might think about what is the situation
that you're actually facing what are the
solutions that you've explored and
perhaps what is the solution that you
ended up picking given pros and cons now
in the sort of Java world where I've
spent a lot of my time you know I think
most people have realized the plethora
of sort of logging frameworks the point
where we have a framework for logging
frameworks to hide us from the
abstraction of all that complexity and
perhaps in parts of your code base you
may have different sets because they've
been evolved at different times and so
you can talk about maybe why the choice
of a library was actually picked and the
choice of maybe moving away from them
from an older library to a new library
as part of architecture decision records
now what's interesting is there are also
tools out there there's a sort of
command line one called ADR tools that
allows you to capture these decisions
and store them against your sort of
source code repository so they are
actually aligned for the our code base
as well where people can actually see
the decisions as they're made and making
sure that there's a sort of written
history of what those significant
decisions are now another thing that
often happens with systems is that we
never have time to make it perfect we
have some form of this sort of code that
we don't like we know that this sort of
area is suboptimal and my experience
with working with new developers they'll
come in and say why is it like this
whose great idea was it to you know
build this pattern in this sort of
format and what's really helpful in this
case is actually talking about this and
being very open about here are areas of
our system that we don't like that we
know need improvement and it's kind of
putting the sort of dirty laundry out to
air is that you know everyone knows that
it's not great but we have plans to
maybe fix it and maybe you can help us
fix it together rather than somebody
sort of get being very critical when
they sort of come in and so helping
people understand maybe parts of the
codebase whichever may be the direction
that you want to have knowing that there
are parts of the codebase that are less
ideal will help people orient around
which direction I should be heading in
and so these are some of the things that
you might want to think about when
you're thinking about the history behind
the system that you're actually working
on now another useful
of tribal guide it's really the things
about facts so when we're actually
thinking about a real city you know we
want to think about maybe how big the
city is what currency they use useful
sort of tips and tricks now in software
systems what's often not so obvious in
sort of code are these key domain
concepts so working in sort of a
payments group you know there are
important things about transactions
transaction codes and the ideas about
debits and credits and and all these
types of exceptional types of
transactional flows now somebody who's
never worked in that domain before comes
in they can read the code and they can
understand these terms but they don't
really understand what the meaning
behind the terms are and so what's often
very useful in a trouble guide is a
little bit of a QuickStart guide to the
domain which you're actually working in
so that people understand the context of
how the code is actually written and so
that's where domain facts can be really
useful another one is really around two
main vocabulary which is thinking about
what are those key words that people
come up again and again and each of your
domains will be very different so when
you're thinking about sort of
advertising they'll probably be things
like price per click and customer
acquisition and sort of funneling things
that will be expressed in the software
that you use and until people actually
know what these key trigger words are
it'll be very hard for them to orient
themselves around the sort of system and
understand the relationship between them
now as much as I really dislike acronyms
I'm also realistic that will never get
rid of them every organization has their
TAS or three-letter acronyms sometimes
two or four letters and it's really
simple to simply have a wiki page or
something that allows you to compose all
these acronyms and people will absorb
these over time and will become part of
their sort of working vocabulary but for
new people it can be really intimidating
when people are constantly talking about
these shortened forms and you can help
accelerate this by making sure that
there's a reference of some sort I've
worked in organizations where slack bots
actually respond to acronyms as well so
you can sort of say you know what is
this TLA and then I'll come back with
the response as part of the help for a
person another thing about useful
information is really thinking about
personas so there's different types of
roles you know
systems that we often have so you'll
often have your sort of public uses but
what's often happening behind the scenes
is you'll also have different types of
users who use different elements so
you'll probably have people who are like
administrators who are super or uber
users who have access to special
functions that no one else has access to
you probably have maybe some operations
people who have a sort of way of dealing
with maybe manual edge cases or
exceptional flows and it's useful for
people to understand and map different
functions of a system to those users and
once again it's one of those concepts
that doesn't really sort of get
expressed easily in a single place
you're a code base but you can help
people understand who these personas are
as to who the users of your system will
actually be and then what's really
useful it's actually an overview of
common usage cases so what's the normal
flow of someone going through a
particular system so if you're building
some sort of website checkout process
it's quite simple to probably give
people an example of the steps that
someone would have to actually check out
and pay and then sort of invoice if
you're thinking about some sort of
reporting flow perhaps you want to
actually think about the stages that
some sort of request would go through
about information collecting to get that
sort of final presentation of that
report and so it's really useful to sort
of give maybe two or three example cases
that allow people to understand what's
the common flow through the system and
that helps people grasp a really good
overview of the whole system as a whole
very rapidly so we've talked about
history why the system exists we've
talked about useful facts things about
the domain the next element is really
about the culture and this is something
that often once again doesn't get
represented in the codebase now every
team I've worked with has its own
distinct culture and it was very
interesting when you have a new person
coming to that team because you often
have perhaps different sets of cultures
coming together and that can be sort of
conflict and so one thing that often
comes up is do you actually have coding
standards and this is like one of those
things where if you don't have codings
and it's probably one of the most
contentious things that happens with
pull requests or code reviews where
people are saying no no well you need to
make sure you have brackets on this line
versus that line you know we won't fully
expanded variable names versus shortened
ones
and it can lead to a lot of wasted time
and so by simply saying here is the
culture of how we appreciate code for
this project people who come in they
might debate that standard but it elites
it's clear to them as to what is
expected of them now one of those other
sides of cultures really the process of
how do you actually do code reviews if
you actually do code reviews so some
people will perhaps prefer a more
asynchronous method of doing pull
requests and commenting things and maybe
not like this sort of synchronous side
of perhaps a physical in person code
review other teams I've worked with
prefer to do away with code reviews
altogether and just do pair programming
so you do continuous code reviews all
the time and then you can commit code at
the end with the sort of names of the
people who are actually working on that
code at the same time so it's important
to help people understand if they're
going to be productive how do they
contribute to the system really
effectively and once again one of those
elements doesn't really happen Express
through the code itself the next one is
maybe a little bit more interesting
which is really once you get beyond
coding patterns you also tend to have
conventions in the code base so as a
system evolves if you're a factoring
very well what you'll find is you'll end
up refactoring to a set of patterns so
there are a set of common problems or
use cases that happen and in your code
base you may have common ways of dealing
with that perhaps you use the command
pattern because you have to deal with
certain types of codes and making sure
that you respond to these codes in
certain ways perhaps you use some sort
of template pattern to make sure that
things are done in a very consistent way
and that steps are always done in sort
of this template mode it's very helpful
when people come in to sort of recognize
you know this is the common problem in
this area the code base and therefore
these are patterns that we use we use
patterns as a way of learning really
quickly and we can help new people come
on board by expressing them I think it's
also kind of telling if you don't have
passions in your code base or
conventions perhaps the team isn't
actually refactoring things well enough
to come up with common ways of solving
these problems so that tells you also
something about your system and the
culture that you have another sort of
common thing is really about this
development process so how do you
actually work with other people in your
business do you have kickoffs with a
Prada
Toner where you sit there and talk about
the story about what's in and out of
that story and you are very good at
actually detailing acceptance criteria
or do you have a development process
where people think okay well we just
write stuff when we throw it into
production and test it against end users
there's no right process but it's
helpful for people to understand when
they come into your team what is
expected of people and how do they
actually work so we've thought about
sort of this culture side that isn't
really dictated I mean it's kind of
something that I think new developers
tend to sit back and observe when they
join a new team and what I'm hoping that
you might think about is being a little
bit more explicit to help people
understand what that culture is now one
of the favorite things I love about
software and software architecture is
this is how you're about maps and I feel
we don't use enough of these ideas in
software so yes the code represents a
lot but if you're going through the
Linux kernel of all 300 million lines of
code that's a lot of code to go through
for you to build up your own mental
model of what that picture looks like
and so this is where you want to think
about what are the maps the system that
you have and I'm talking about sort of
architecture diagrams now there's no one
right way and no one single diagram of
what you can picture and when you're
thinking about a software system there
are different elements to that I'm a big
fan of Simon Browns c-4 model so he
talks about what's the context of the
system so if you treat your system as a
black box what are the external systems
or external people that it interacts
with and then once people understand
that you can sort of explode that box
down into the containers so what are
maybe the micro services deployable
artifacts about how they interact and
then once you sort of get that picture
understood you might explode one
container into components so what are
the key components in that sort of
container for people to actually operate
as well now that's one view which is
kind of your logical perhaps
architecture view of your system but
there are many other perspectives of the
system that makes sense to help people
understand so I'm a big fan of perhaps
sequence diagrams as well so in a lot of
systems there's kind of often a real
critical flow of maybe how things should
work between components and by looking
at a static diagram of just how things
work somebody can't really detail how do
the how do the
components actually work to fulfill a
particular use case so you can actually
overlay sequence on top of a container
diagram as well with errors and the
numbers to help indicate what's the flow
of that but sequence diagrams are useful
because we like to understand how things
work in a sequential fashion I think
flowcharts are also another great way of
actually thinking about how do systems
work particularly when you're dealing
with States and information so when
you're actually dealing with somebody's
you know personal account perhaps there
are ways that that account revolves over
time depending on rules so it might get
suspended under review before somebody
actually does something to reactivate
that account and those kind of logical
views of something in the domain can
then be mapped into each of those sort
of either screens or services that back
each of those steps so people have
another model of looking at the code
base and projecting their own thoughts
into different parts of that code base
so once again these maps are helping new
people orient the final kind of tool
every one up here is really about this
idea about CRC so if any of you come
from XP backgrounds CRC's I'm this idea
about using cards to represent the ideas
of collaborating classes so you talk
about what's the class on a particular
card and on a card you talk about what
its responsibilities and then you talk
about how it collaborates with other
classes and then you form your kind of
group of classes that help you
understand how they relate to each other
so it's a really great way of doing a
design technique of discussing does this
class actually have this responsibility
or should it have this responsibility
and maybe there's some way of a sort of
exploding that out as well and that's
another sort of tool that you can use to
help people explore important parts of
your particular code base so hopefully
you think about the maps that you use
the architecture diagrams the visual
models to help people see different
perspectives or your system the final or
the second final points about your
travel guide is thinking about what are
the sites in your particular travel
guide that you actually want to have now
when you think about sort of a large
system of some sort if you follow a sort
of perrito's principle you have probably
a lot of the system used in only a small
part of the codebase and so this is kind
of things that you actually want to
think about
one of the key areas that somebody
should know when they first join your
application so you might think about
what are the landmarks in your codebase
so what are the parts that are often the
things that people have to touch on a
daily basis so that rules engine over
there no we didn't have to change that
that only really happens maybe once
every sort of six months or something
like that
but you know when you're actually
dealing with the main flow of whatever
business logic you're dealing with
there's a part of the codebase you're
probably dealing with more often that
people really need to know and need to
spend their time coming up to speed with
as a result now there are some areas
that are more important to others so you
can help people understand ok this
administration area it's used by two
people it's not necessarily as important
as some of the user facing features
where most of the traffic is going
through our system and so people can
maybe start to prioritize also where
they spend quality and the time of like
improvements you might think about as
you go through your system with a
sequence diagram what are the most
commonly traveled through parts of your
system and help people get accustomed to
that so one of my most favorite
onboarding tasks is actually to give
somebody a small task that allows them
to expose them to each layer of the sort
of system so they get to understand
everything to do with the user interface
everything to do with sort of business
logic something to do with sort of
persistence and maybe communication out
to another sort of external system and
from that they get to start to picture
how these things all interconnect and
they can be a lot more productive and
once they understand that basic flow you
can give them more complex tasks to
understand other parts of the system
once they have that understanding so
think about what are they worthy things
in your code base that people should
actually know now finally I guess like
every sort of town or new foreign place
we go there for a good reason and this
is really thinking about what are the
fun elements of your system so I think
all engineers have a certain level of
creativity that they like to put in
sometimes they're about Easter eggs
sometimes they're just fun facts about
the system and so think about some of
the things that would be kind of nice
maybe there's some historical reasons
why parts of the system are named after
some sort of pet animal because of
somebody who worked on that three years
ago think about perhaps interesting
areas of the system
so things that are very unusual maybe
algorithmically really complex because
they had to solve a particular
performance problem so these things are
kind of areas that other engineers would
like to know about and it's helpful to
help give people anchors as to where
they might go in the codebase to
navigate themselves around that also
think about where there are places for
innovations and creative solutions so I
think what's really interesting about
really successful open-source projects
is that a lot of them never really
started off as a simple open source
project a lot of these successful tools
are things that have been extracted out
of existing systems because they solve
this common problem and often what
happens over a system over time is that
there'll be something that kind of
stabilizes to solve a particular problem
and you want to maybe extract that out
of a particular system and there's an
innovative solution out of that so think
about these kind of six elements about
what makes up your travel guide you
don't necessarily need to think about
you know making sure that every travel
guide has all of these elements but
think about what makes sense for the
systems that you're building and do just
enough to make sure that people have
some context when they join your
particular software system so we thought
about why we need a travel guide we've
talked about what we need in a travel
guide maybe we need to think about how
do we make the most of our time
preparing this travel guide and where do
you actually start so we'll actually
explore three different elements common
questions is ok so I want to build a
travel guide where do you begin we want
to think about how big is this travel
guide how much effort as engineers I
know we don't like writing documentation
but there's a sort of extreme of what we
talked about of too much and no
documentation and there's some sort of
interesting counterpoint in the middle
and the next thing is really thinking
about a process to keep the
documentation living and up to date as
well so I know that it frustrates
everyone when they open up some sort of
confluence wiki page only to find out
it's all out-of-date and it frustrates
everyone but it happens however there
are still some probably relevant points
that are on there and you need to have
some process to keep it fresh so in
terms of starting point it's a really
good way of thinking about it is asking
the question what's valuable for other
people the hard bit about this is that
we can't answer that we actually have to
our
to other people what would they like to
know about that system a really good way
of actually thinking about this is when
you have new people who are about to
join a system find yourself listening to
what are the questions they keep asking
themselves what will they ask you and
your team so what are the things that
keep popping up all over again and again
and see if you can build a sort of FAQ
structured in the way of some of the
elements that I've kind of taught about
it doesn't necessarily need to be deeper
conflict comprehensive but it'll sort of
stop you from having to repeat yourself
over and over again and it also helps
people read up once you've actually
given people the answer as well so you
can think about it as answering commonly
asked questions the other side is maybe
to put yourself into your picture of if
you left your system and you came back
in two years time what are the things
that you would like to have had when you
come back and you see the many many
lines of code that you all sort of
unfamiliar with and how things have
evolved so help your future self and ask
yourself what you would like to have
when you come back to that system now
when it comes to size I think it's
really hard because there isn't really a
clear number that I can give you instead
I can give you a sort of function or
thinking about how you think about your
investment of documentation than the
size of how much effort you put into now
one of them will be about the history of
this particular application so if it's
been long lived for a long time then you
probably have a lot more context that
you want to capture to help people
understand why that system actually
exists maybe it's thinking about the
sort of population so a system that is
edited by two or three developers means
that the code won't be so big but if you
have a team of say 20 or 30 people
contributing to the codebase you have a
lot more changes happening to that more
rapidly in and growing in a much more
regular fashion that you probably need
more guidance to help align people as
well and so you might actually take that
into account when you think about what
information you want to capture you
probably want to think about the sort of
degree of change so when I think about
software systems there are some systems
that are very stable
nobody really touches them and there are
some systems that are constantly
changing all the time and so for things
that are constantly changing all the
time you probably don't want to invest
too much time as it's changing to sort
of keep that documentation up to date so
you
want to capture it at significant
changes and phases to say okay we've
done this kind of maybe transactional
improvement and you wanted to capture
the improvements in that sort of
architecture or maybe you've worked on
breaking out that monolith into smaller
services and you've succeeded at
breaking out one of the bigger services
out of a big monolith those are really
good trigger points to say here's a good
snapshot to sort of capture changes to
documentation you also probably need to
think about speed of change as well so
you know if you're rapidly changing and
experimenting with a system prototyping
something for end-users and testing a
market you probably don't need to invest
in documentation until you've actually
found a market fit and then you find
that things have actually stabilized as
well so for any of you that have been
working in sort of start-up environments
then you know that you don't really want
to do a lot of documentation very early
because you'll end up sort of rewriting
a lot of very rapidly but once you've
found your sort of end user then you
probably need to start capturing some of
those decisions and maybe explaining why
some parts of the system are really
messy because of the things that you've
tried and finally another function is
really about the domain complexity so if
you have a very complex domain so if you
think about say a medical domain where
there are very complex relationships
between sort of terms and what they mean
to each other then you probably need to
make sure that you invest a little bit
more information capturing that so on
board new people if you're dealing with
maybe you're more of an e-commerce
retail checkout process you probably
don't need to spend so much time on
documentation so the hard bit about this
sort of function is that you probably
have to think and discuss as a team
what's the right fit for the system that
you're actually building and what makes
sense and so you can kind of think about
it not really as a number but you can
kind of think it as a scale of smaller
versus larger and how much effort that
you actually invest is part of that so
we think about the bringing us back to
the analogy of a true travel guide one
of the interesting things is when you
look at the Lonely Planet or the Rough
Guides thinking about something like a
travel guide for London versus Torquay
so we know that London has a very large
population has a very rich rich history
and it's constantly changing all the
time and if you think about Torquay
city by the coast and maybe it doesn't
change as much and so the Travel Guide
is probably going to be a lot larger for
London than it is for Torquay and then
the question is well what information do
you actually need to keep in London
because those things will change over
time and the hard thing about this sort
of stuff is that you won't be able to
capture all the information you want to
because you have to decide what's
important for future travellers and that
will change as things happen now if we
change our Torquay for Great Britain and
so we think about the whole country as a
whole and once again we have to think
about the level of information we have
we don't want to have a bigger and
bigger book of something because nobody
will ever read that travel guide we
actually start to think about what's the
detail that we need to skip that gives
people enough of that grasp of different
areas and gives them a really good
starting point to have future
conversations or more specialised guides
for a particular area of that sort of
system so I really recommend that you
sort of use this analogy to think about
not just writing documentation because
of all the sort of sections that we have
but thinking about what's the right
level of documentation you want to have
relative to other systems that you have
in your sort of organization and keep it
as lightweight as possible so the key
message here is really thinking about
this idea about value over size so
thinking about what will be valuable for
new people and making sure that you test
on other people I like this quote about
writing I would have written a shorter
letter but I did not have the time and
this is very true for our Travel Guide
is that it takes effort to put together
a really succinct travel guide and this
is maybe one of the reasons why a
documentation in sort of engineering
isn't done so well it's because we have
a lot of pressure so sort of write
something and we don't have a lot of
time to sort of edit it and come down to
what is the essential message we want to
sort of transmit so we've written lots
of sort of systems but we know that they
don't really stay stable and I guess
what's interesting is neither do cities
as well so if we think about New York
City what's interesting is that the
Lonely Planet is now up to their 11th
edition and it'll be released sometime
this year and then the last edition was
2016 and this is true about anything
that we capture about anything in the
written form is that as a system will
change we know that that will get out of
date and therefore we need to build
process of actually updating this as
well now in the Lonely Planet's guide we
know that there's enough people who are
going to come and visit the system that
it makes sense to update it all the time
and keep it relevant now here it's about
a two-year gap I'm hoping it's not a
Chia gap when you update your sort of
documentation for your systems but you
have to think about I guess the number
of people coming on board if you have
more people joining it's probably a
really good times actually thinking
about refreshing the documentation to
make it really relevant for the people
that are coming on board before anyone
stops working on a system that's another
good time to think about maybe capturing
an update to reflect what were the
changes to that system that will be a
value to the next people that join when
there's new work to be had and so one of
the things to think about is really this
process of thinking about reviewing what
you have as documentation thinking about
what would be useful for new people
actually generating and then testing it
against a new person so my favorite way
of actually updating documentation is
actually through onboarding new people
so we get people to sort of go through
wiki pages
they'll have other verbal conversations
and then we get them to sort of update
the documentation to make sure it
reflects the current set of
conversations and if you have like a
constant trickle of people in a
particular project then that can
actually work out really well of keeping
that documentation up-to-date now the
key thing here is really coming back to
this idea of purrito principle so the
80/20 rule
so not trying to capture all decisions
but really trying to capture enough of
those valuable things that don't get
expressed in code that give people
enough sort of pointers and indexes to
talk to people or to find out more
information about things and this is
actually one of the reasons I actually
like sort of wiki pages is because
you're not stuck to a sort of linear
format that a book has is that you can
actually think about how do you sort of
jump out to different parts and then you
can sort of relink back and it becomes a
little bit more circular but the key
part is really thinking about what
process do you have in place to make
sure that you review this and I've seen
a couple of different ways that teams
can do this so one can be making sure
that every three months that there's if
you have user stories like a
documentation user story to make sure
that you do some sort of review I've
seen other places where teams will sort
of rotate and they sort of try to learn
about another person's
system and in that process both teams
are encouraged to capture the
information and an update the wiki as
well and so it's a good way of actually
both learning about other systems but
also having a process to review and to
test your travel guide in action so I've
talked about a lot of theoretical type
of ideas and I sort of wanted to give a
couple of examples about well-known sort
of projects out there that I think do
pretty good elements of this travel
guide in practice so the first one is
probably selenium does anyone use
selenium here okay so for those that
don't use it or don't know about it it's
actually quite an old project so sudden
2004 and it's about a web automation
tool so this is really the idea of
really how do you test web pages it's
now being combined with the webdriver
project to allow people to help drive
elements and that's becoming a w3c
standard and it's probably one of the
most widely used web testing tools so if
you've done any sort of web testing this
is probably something that you run into
all the time now it's really interesting
if you go to their website in terms of
going to the documentation and some of
the things that they have are actually
some good elements of what I would
consider good for a travel guide so they
talk about to automate or not to
automate so the context about why
selenium exists so if you've never heard
about selenium do you actually want to
use this thing well go and read about
the history of it and understand why it
actually happens there's also a brief
history of the selenium project and
because of things like combining with
webdriver there's some interesting
architectural elements that don't seem
obvious when you sort of think about how
you would build a web testing tool but
because of the history of how selenium
evolves it kind of makes sense about the
architecture behind the scenes and if
you start to use it some of the elements
that you actually have whose use Eclipse
here hopefully most people have used
some form of it maybe some of you may be
used IntelliJ so it's really widely used
IDE but I guess what's interesting is
that it's not just an IDE but it's a
plug-in architecture for supporting
other things as well so other people
have built products based on the Eclipse
sort of framework and if you've ever
tried to use it it's very confusing like
to say but
the basis for many other products I
guess what's interesting is in order to
really understand eclipses is that you
have to really understand some of the
key concepts they have when they think
about how they Lodi Namek components and
how do you deploy things it's not a very
what I would say intuitive way when you
actually think about things so some of
the key concepts that they have in their
sort of documentation is actually a
whole section based on concepts so
before you start thinking about building
an eclipse plug-in you probably actually
want to read up on the concepts because
it won't be as intuitive as simply
writing something and then finding some
API to call it you have to make sure
that you plot you package your your
plugin properly to make sure that it has
the right sort of information so that it
can be picked up by the framework and
then it can be registered there's all
these concepts that you first have to
really understand before you're going to
be really successful and they know
what's really complex which is why
they've got a whole section trying to
explain some of the concepts there now
eclipse is also really large in
voluminous so depending on which version
of Eclipse and which Edition and the
framework there's a whole bunch of
references there as well so you can sort
of navigate around and then even just
the ID itself is kind of complex so
they've got a whole tip around
navigating the so your user interface as
well who's a user of Firefox not many
it's good for open standards so you're
highly encouraged so it's the
alternative open source browser I think
it's interesting when you trace Firefox
all the way back because they were
really against sort of ie dominating the
web and I think they're also really
contributing to it now as well with
chrome and some of the things that
they're trying to do so big supporter of
Firefox and they're really big focuses
on sort of open standards and shared
open standards and I think what's really
interesting about it is that there's a
very large community around the space so
people who write plug-ins people who
really contribute to this and what's
interesting is their documentation about
how they set up so people want to
contribute to the Firefox platform
because people want to have an open web
so they have a whole section which is
about getting started so a step-by-step
beginners guide to getting involved with
Mozilla and and this is really
interesting right because we want to
have a really successful open source
project and
so that a good way of doing this is by
helping people understand what they need
to have to get going straight away now
one of the interesting things about
Mozilla is that they have a very strict
sort of development process and unless
you actually work with people it's a
very distributed kind of foundation and
they have a whole thing here about
development process overview so if you
think about submitting a patch there's a
process they want you to follow in order
for you to be successful at getting your
patch actually accepted into Firefox as
well and they're trying to help you
understand what that process is as well
there's a whole section on working with
Mozilla source code so you're starting
to understand how they structure certain
parts their source code so you can start
to be productive at actually generating
code and then also build instructions so
if you're actually going to test and
build your system how do you
successfully do this really rapidly now
it doesn't really scale once again
having one person do a webinar and get
people on board with this so they've
really thought about what goes well into
their travel guide for their particular
systems now I've kind of articulated I
guess some of the reasons why you want
to think about a travel guide I hope you
think about why you might actually think
about using a travel guide for your
particular systems we've talked about
the elements what goes into a travel
guide to make it the right value and
we've talked about the process about the
things that you might do to actually
start building evolving and keeping it
up to date now I want to sort of go back
to the agile manifesto and I was a
little bit unfair to the agile sort of
group because you know their heart
wasn't really about getting rid of
documentation altogether it was really
about this underlying thing about
comprehensive documentation so the hard
thing about things where it's about
judgments is that it's very hard to
sometimes work out what's the right
level and it's all about it depends on
your context and nobody can give you a
binary here is the right answer
but I hope at the end of this talk that
I've inspired you a little bit to think
about what you might actually do and
what I hope you think about is helping
others really prepare for the trip to
build your own guide and hopefully help
others enjoy the ride
thank you
we have some time for questions if
anyone has any okay that's good all
questions answered where would be a good
starting point number one two to kick
off this process do you think yes if you
don't have anything in place what I
would actually say is like when you
think about preparing for onboarding a
new person that's a really good time to
actually start doing some of that stuff
so I think what's really interesting is
that you can start building this in a
very lightweight fashion so if you're
actually onboarding somebody if you even
just spend an afternoon in a room with
whiteboards about information you
probably have enough to be able to
capture diagrams and maps about you know
something that's useful to the system
there's also probably something about
when that person is writing notes often
that's a really good sign that's
probably something that you want to
digitize and be able to give people
references for so I'm a big proponent of
doing things iteratively and
incrementally I think also what helps is
if you have somebody like a technical
writer obviously somebody like that has
really good editing skills and maybe
getting them to work with the new person
to digitize and edit it is often a
really good process to start off with
there was a question yeah nations for
tools to use for to create maps or
architectures so for tools for
architecture Simon Brown actually has I
figured what he calls it structure Iser
I think it is that allows you to try to
annotate some of those things I wouldn't
really try to worry about trying to
generate documents from your code
because I think what happens is that you
end up with too much code and too many
diagrams so I actually would prefer
doing whiteboard diagrams and then
simply digitizing them so often things
like Gliffy is very integrated into
something like confluence google draw is
kind of very
cool an OmniGraffle for mac is a really
good sort of diagramming tool so they're
the kind of ones that I would use I
wouldn't worry too much about the tool I
think what's interesting about
diagramming is it's you have to kind of
a line on how you represent concepts and
so that's probably more important which
is making sure that you know when you
draw boxes that everyone understands
what a box means and colors because
those things are often misinterpreted by
different people okay well thank you
very much and I hope you enjoyed the
rest of the conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>