<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Brownfields DevOps in Practice - Damian Brady | Coder Coacher - Coaching Coders</title><meta content="Brownfields DevOps in Practice - Damian Brady - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Brownfields DevOps in Practice - Damian Brady</b></h2><h5 class="post__date">2017-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HQJI_33CWao" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone thank you for this is one of
the
see London's everyone enjoyed London so
far in DC yep
some like tired nods of heads I love the
MVC conferences generally really really
well run but every time I go to these
conferences I hear about all these
amazing new tech stacks and new
processes and new things that you can do
and I know from my history that
sometimes you learn about all this new
stuff and then you go back to your
company and get back into the legacy
code that's 20 years old and do things
exactly the same way because you don't
have the power to change everything into
a do a file new project and that's kind
of what's driven the development of this
talk it's kind of an understanding that
it's great if you're a green fields
developer who can do a file new project
every time you start but that's not the
majority of people so I'm talking about
brownfields we've we've all probably
heard have you heard the term green
fields development that's basically
where you get to choose how you're gonna
do stuff and it's at least several weeks
before you decide that you made a
mistake but brownfields I kind of like
to think of it as software and and
processes and things that if you were to
start them again you know what you would
do differently so it's mature enough
that you're like I know this is bad but
that's the situation we're in at the
moment so the message for today's talk
is really that you can take what you
have as brownfields development and
start moving into a better story for
DevOps and that's what I want to talk
about so I work for a thank you I work
for a company called octopus deploy it
was based in Australia so hence the beer
mm-hmm but I've recently moved to
Toronto and it's much colder but before
working for octopus deploy I was in
consulting and then before that I was in
government organisations and in finance
and things like that so I've seen a bit
of a range of processes definitely some
organizations that are extremely
brownfields stuff so just as a question
um think about the products that you
work on now so the bit of software you
work on assume
you're a developer or a bit of software
that you are involved in if you're not a
developer who if you think about that
codebase who is working on a code base
that is more than a year old okay that's
probably slight majority of the room any
one more than like two years old five
people not putting their hands down how
would you know yes if it's yeah so and
that's the scenario that's the reality
that a lot of people are in so the first
thing I want to say is that um it's okay
I understand I've been there before but
it's really about what you do after that
if you go home and say well all of that
stuff I learned is too hard to implement
here I understand that mentality but by
making small steps forward you can
actually improve your DevOps process so
I'm going to introduce a couple of
individual things that you can do even
if you don't have the power to change
the company that you work for or the
organization all right so first this is
an international conference and DevOps
is in my title so I think I'm legally
obliged to give you my own definition of
DevOps and even if I'm not I'm going to
because every other bastard gets to do
one so this is how I think about DevOps
it's really four things it's working
together to put the right stuff in the
hands of users faster so I split them
amongst four lines you'll notice there's
no products there there's no tools there
it's just this idea of working together
to get the right stuff in the hands of
users yeah on a fast cycle so working
together is kind of the biggest thing
that people get wrong who here has a
department in their company which has
DevOps in the department name like the
DevOps team or the DevOps something
other yep I saw a couple of reluctant
hands the solution to two teams who
don't work together and don't talk to
each other is not a third team in the
middle who also doesn't really talk to
them right you kind of got to get out of
this silo mentality and actually work
together and I'll talk about some ways
to do that even if you're not the guy in
charge of how the team's work
so part of what that those people should
be doing is getting the right stuff and
I'm not just talking about
the highest priority work items on your
backlog that's not necessarily the right
stuff the right stuff also incorporates
things like working software that
doesn't fail tests and software that
actually does what the person expects
rather than what is written down on the
on the sheet and to do that you really
need to measure what's happening in
production as well if you release a
feature which is technically correct but
doesn't really even get used because
it's so broken from the eyes of the user
that's not the right stuff so you're
putting the wrong stuff into production
so we need to focus on the right stuff
this is a big one for me he's getting it
in the hands of the users if you have
beautiful working software on your
development laptop then it's completely
useless all right if it's not in
production it doesn't count we're not
shipping your machine we're shipping
stuff in production so getting it to
production is the only thing that counts
and DevOps is really about doing all of
this safely but faster and if you can do
it faster you get into this nice nice
cycle which we call the like a name this
nice cycle virtuous cycle it is where
you're delivering smaller bits on a
faster cadence which means that there's
less risk every time you deploy because
each thing you deploy is just a small
change but you can do it faster which
means that if you do make a mistake and
it's in production it's much much easier
to push out a fix rather than working
out when you can schedule a backup and
restore and maybe you have to wait till
the next three month window to deploy so
getting into this virtuous cycle to get
things done faster is really important
as well so this definition which I'll
keep referring to is kind of what I'm
thinking about as DevOps so moving
towards this idea in an environment
where there's already a process and
already in architecture and it's just
not as easy as just deploying to
production so assuming that people are
on board the question is how do you
actually do that if the existing systems
there and the architectures bad and the
deployment process is horrible and
they're silos and you have no control
over it so that's what I want to go into
a couple of tips number one or step zero
probably is to us
- a baseline workout where you are right
now in business terms we talk about a
gap analysis so this is where we want to
be and then you have to evaluate where
you are so you know which direction to
go in and the same thing kind of applies
here you need to evaluate what you're
doing right at the moment and the idea
is not to point fingers or judge people
it's really just to work out what
actually happens in your organization so
how do you develop as a team how do
ideas get from somebody saying we need
this feature all the way through to
production and what happens after that
like what happens when it's in
production from a development point of
view that includes things like how do
you actually build your software is it
milton's machine is the build machine
and if he's away we don't deploy because
he does the compilation and then we RDP
onto the servers how do you actually
deploy them to production and it's in -
it's an information-gathering thing as
well so when you do a deployment when
everybody comes in on a Saturday in that
three month block and they come in on a
Saturday in the hack through a
deployment have a scribe they're writing
down exactly what happens not this is
what the document says is going to
happen but actually what happens if
there's something that goes wrong you
need to know about it so that you can
get the direction forward so this is
kind of the initial one it's also useful
to look back on this after you start
making improvements and see you know
whether you've made actual improvements
that have that have led to faster and
better software so once you've done that
as a developer and as a development team
it's a good idea to get your software
into a good State so if somebody now
came to you and said right we need to
start deploying your software ten times
a day that's not feasible for a lot of
people it's just it's just not you can't
just take what's existing there and just
keep pushing it out so you can't do that
but you can get your software slowly
into a better state so that that is
possible in the future so a couple of
things that we can do number one get to
one code base now I mean this in a
couple of respects there was a company I
did some work for where I did some
consulting for them I went
and I asked them what versions of their
software were running at each of their
customers at one bit of software running
the same software in 30 customers and I
was met with genuine laughter because
they didn't really have this idea of the
same software running at the different
customers if that person had a bug then
you get their code and you make that
change and then you redeploy it to them
and then if it's something that applies
to everybody then you make the same
change on everybody else's code base now
whether that's a branch that has
variations in it or actual different
source control which it was the case
with them it's important to try and
bring yourself where back to you one
code base now even if you don't deploy
that across several customers having one
branch is a really good idea especially
for your release candidates so Martin
who was in here before was talking about
short-lived branches and he should be on
master or main or whatever you call your
trunk
whatever you call your main branch as
much as possible and yes branch to do
bigger pieces of work but they should be
short-lived branches and then push back
to the main tree as much as possible so
having one piece of code is really
important for getting deployable
software that's predictable when you
deploy it but to do that you need to
isolate the variations so anything
that's a change between different
implementations whether that's in tests
and staging and production those
variations or whether it's between five
different companies you need to isolate
those changes so that you can do
something about them so as an example
this is kind of similar to code that was
at this company right so they have a
method get' with sales tax and three
different ways of calculating that so if
they're deploying to a new zealand
customer they comment out the UK one and
uncomment the new zealand one and then
to compile and deploy all right I'm sure
that nobody is doing anything like this
here but that's not a great way it's
really hard to verify that you've fixed
everything that you need to fix this is
slightly better now we've got one
variable called country and based on
that the code is in one place right it's
in one location but there's problems
with this as well
if you need to change the way that the
New Zealand tax rate is counted for
example the person who's working on that
code is essentially preventing you from
pushing this out to production until
their work is finished and complete even
if you're not deploying to New Zealand
so that's a consideration as well a
better way of doing it
dependency injection abstracting these
things away it's still in the same code
base but you have a different
implementation for your or your
different things so finding those
variations and isolating them but
keeping it in the same code base is a
good strategy for going forward now you
could still have this problem of you
know if it's in New Zealand or just a
set in the initial ein in the
initialization saying we are in the UK
and then you comment that out and say
we're in New Zealand when you do the
compile you don't want that either so
the next thing you have to do is you
need to externalize any of these
configuration things if there is
something in your code that makes a
decision about what environment you're
in or what customer you're deploying to
or something like that that setting
should be external from your compiled
application now I'm a fan of
configuration files that's just like
JSON or XML or yeah mall or something
like that but you can also put it into
database you could set environment
variables when you do your deployments
but having that configuration external
means that you can more predictably
deploy the software so the idea is that
you set the configuration when you
deploy so if you're pushing the same
software out to staging then you set
your configuration up for staging so the
software knows how to read that and it
knows how to set everything up for their
staging environment you read it at
runtime so you pull that in when the
code is running and work out the code
paths that you need to go down and then
if you are doing dependency injection
you choose that implementation based on
the configuration so as an example you
might have some configuration that sets
the sets of location or you might have a
database that's being used or a
connection string or whatever else but
any variation between
in actual deployments should be
configurable externally from the
binaries and there's a good reason for
this one the good reason is that you
should be aiming to build your
application once and deploying those
same binaries to all of your different
environments and all of your different
customers it's really really common for
people to have a build server where when
they do deployments they will get the
build happening it'll spit out some
binaries and then they do a different
build and recompile again for the
production one and then I'll push that
out now usually that's going to go okay
but there's always the chance that
something has changed between those two
compiles so if you pushed out binaries
to a test and everything works perfectly
and then you recompile for production
those binaries are different binaries
it's different compiled code that you're
now deploying for the first time ever so
by external izing all of these
configuration settings and all of these
variations between your environments it
means that you can deploy the same bit
of code through your environments and to
different customers so you're deploying
the same bits everywhere so you know
what they look like you know that the
ones you've tested are the ones that are
in production and you can test the same
deployment process everywhere as well so
not just does the code work but does the
way I deployed it also work and that's
really important as well to do that you
can't a need a versioning strategy now
this could be entire hour-long talk by
itself so I'm not going to go into it
too much in general people will say you
Simba if you can everyone know it's
ember is a couple of people generally
like in its most basic sense that means
you have a major minor dot patch version
and there's strict rules around when
you're allowed to bump those versions so
if you have a breaking change you've got
a bump of this version number and so on
I think December is great if you do it
but really the only thing I care about
is these every time you compile your
code there's a unique version number and
that version number is higher than the
previous version number
and what this gives you is it gives you
the ability to look at a out of compiled
bit of code which is version one point
two point three for example and just
know that that is newer code and
different code than one point two point
two for example so every time you make a
change and recompile new version number
and be able to place those versions so
that then you can tell which one is the
newest version and because we're on the
same code base that one trunk then you
don't have to worry about versions of
different branches and things like that
you're just on the one code base so I
think both of these versioning
strategies are perfectly acceptable you
can see how they progress and you can
see which ones you are and as long as as
long as there's no duplicates of these
lying around then that's fine but really
I just care about these two things the
last thing I want to say about getting
your software in a good state is that
it's important to measure what's going
on in production and honestly there's
not really a good excuse for not doing
this some of the companies that I've
worked with before the way they find out
there's a problem with the software is
they get a phone call from their
customer or they get vague bug reports
about it's feeling slow now after you
made that last change but you don't know
this until somebody tells you and what
help is it's slower than it was before
not a lot but there's there's countless
frameworks countless free tools things
like that they can just put some metrics
around what's going on in your
application even if you're just spitting
exceptions out to a to a log file and
monitoring how big those log files get
how fast that's something it's something
that lets you tell whether something you
have just deployed has made an
improvement or has introduced something
bad so start doing that as well so
getting to a good state even if you're
not in charge of the company you can
still push towards one code base you can
still start to isolate those changes and
externalize the configuration that does
that work you can build once to play
many so who here has a build server for
their application
okay that's most people which is awesome
that's really good if you don't it's
generally one of the easiest and best
things you can do with your application
rather than right click like right click
compile or f5 or whatever it is that you
do in in whatever language it is rather
than doing that knowing that there's
something building your application and
going to let you know if there's a bug
or if there's a something wrong with it
that's really really important so do
that versioning right and and measure
what's happening in production and not
what's happening on your local machine
necessarily but what happens in
production is really important otherwise
you can't fix it so we're kind of moving
towards getting the software in a you
know good state the reason we do that is
so we want to deploy this software
without a lot of drama without that
Saturday everybody there for 48 hours
eating pizza and you know shorts and
t-shirt which probably doesn't happen
here in jeans and jackets to deploy it
without a lot of fuss like it's not a
big deal to push the production once you
get this stuff right and it shouldn't be
so a couple of couple of things you can
do here number one is try to get to a
stateless deployment so what I mean by a
stateless deployment is basically just
one where you're not relying on the
state of the server or the environment
that you're in
so who here when they do a deployment to
production it's a very special different
thing from all the test deployments and
seeing some nodded heads yeah a couple
of hands ideally your deployment to
production shouldn't really be any
different than the deployment to your
test environment ideally and sometimes
it is because production is this
precious place where you can't update
any patches you can't make any changes
to it so the last time anybody touched
that server was six months ago and I
don't really know how it differs from
staging it's probably it'll close but
there's gonna be stuff though it'll
happen when we deploy to production so
ideally you want to get to a state where
that's not the case we're deploying to
production is just like deploying to any
other environment so as an example this
is a pretty common pattern where you
have your version
on the application and by app version
one I mean that version all of the
framework updates the.net framework
updates the dependencies everything that
you need to run that application and
then when you deploy version 2 you're
deploying the changes over the top so
you might just change the files that
have been modified or update a couple of
things and then change the configuration
here or something like that same with
version 3 ideally what you want to be
able to do is deploy version 2 whether
or not version 1 exists at all now under
the covers that may actually be doing
the same thing as before it might deploy
version 1 and then deploy the version 2
tail patches but you want to be able to
say there's a fresh new machine just
deploy version 2 of the application and
same thing obviously for version 3 now
this is harder than it sounds sometimes
I know it is but part of that first data
gathering thing that we did in step 0
was to work out what actually happens
when we deploy and if you can build
those this is what actually happened
when we deploy into your process then
you can do it next time you do a
deployment you know we thought that we
were just going to copy the files over
and restart iis and everything would be
fine but actually what happened is this
folder was left over and it was locked
and so we had to unlock that if you know
about those things and you can get much
closer to this state you know that that
can be part of your build process now
that's easy for binaries as well
generally just copying the new stuff
over the top of the old stuff well for
the most part work but it's much harder
for for external dependencies things
like databases databases are generally
the hardest part of a deployment process
and automated deployment process there's
a couple of reasons one is that it's
such a single point of failure I mean if
you have two web servers and you upgrade
one and it doesn't work you can just
leave the other one handling or the
traffic while you work out what you did
the database is usually just one
location the other thing is once you
change their schema of the database it's
very difficult to undo
that change often so there's a few ways
that people will do these changes as
well one is migration scripts so every
time you make a change you have a script
that moves from the previous version to
the new one
if you're deploying to a fresh machine
then you run script number one all the
way through to wherever you are now if
you're deploying version two to version
three then you run those scripts so you
can still deploy holistically you can
still to play the whole thing but the
migration script means that you are
always moving forward you're not you
know trying to work these things out on
the fly but there's also other tools
like sequel compares a red gate tool
that's quite good where you can say this
is what the schema should look like
it'll analyze the production database
say these are the changes that you need
to make and then apply them I am
petrified of those ones I mean I trust
those guys it's a smart they're smart
developers at Red Gate but it's a pretty
loose definition of repeatable I think
you can do a deployment to staging and
it goes yeah the differences of this
we're going to apply them and then you
do it to production because all the
differences of these ones and I'm going
to apply them and everything breaks
because you've never tested that before
so I really like migration scripts might
be more effort but I think it's
definitely worth it that doesn't get
over the issue of how do I undo the
change if something goes wrong and to do
that I like the idea of transitional
deployments and that's really just an
acknowledgement that maybe something is
going to go wrong and maybe you have to
back out of it now ideally you should be
able to fix that bug and move forward
but we know that's not always possible
especially if you're starting to move
your existing big application towards
this kind of continuous deployment you
may have to wait a couple of weeks or a
couple of months or something before you
can get a fix out so the idea and I know
Microsoft has started doing this as well
is that you try to make sure that the
version of the database that you've just
deployed is compatible with the previous
version of your code now it seems a
little bit of a weird thing to do but
when you deploy version four of your
application it means you're deploying
version four and a database that works
with version four
but also works with version 3 so if you
think about it you deploy the
application and your database changes at
the same time let's say you deploy
version 4 and some changes to the
database for version 4 and then you
realize that version 4 of your
application actually isn't very good so
you need to pull it back but now your
database is in this state where it's it
should be working with version 4 but
version 4 is definitely not running
anymore
the binaries you just roll them back to
version 3 or install version 3 over the
top if you can set that transition up so
that the version 4 database can still
work with the old version of the
application then you're still you're
still ok so as a more practical example
let's consider like a database table for
customers and somebody a while ago in
their infinite wisdom decided that the
date of birth field should be a string
because I don't know you can assume that
they made a good decision at the time
anyway so you obviously want to change
it to a date column but rather than just
pause that put it in a new date column
and remove that column for version 2
maybe you want to have both running for
a little bit you could even set up
triggers or something like that so that
when you insert a new record with the
new date column it puts a string
representation back in the old date of
birth column so you've got this
transitional period where the old stuff
is still going to work if you need to
roll back to that stuff or roll the
previous version forward it's still
going to work but then you've still got
a way out when you actually think yes
we're we're ok then down the track you
can remove this now that obviously
becomes a process problem as well are
you just going to leave yourself saddled
with all of this technical debt well you
need to be able to build something into
your process that says no go and remove
this in a couple of versions time when
we've proven that it works but having
those transitional deployments means
that it's safer to push out faster
because you don't have to worry about
what will happen if everything goes
wrong you can still just roll back to
the previous version and you're okay
so those are and again that's a tard
that was an easy example but sometimes
the changes that you make are quite
difficult huge schema changes are very
difficult to have a transition period it
can be done it's just more work and
that's why everyone owns so much money
right so deploying with that drama is
all about getting to a stateless
deployment you can just push out an
application if the deployment fails
halfway through it's fine
push it out again because you're not
reliant on the state of that application
at the time the state of that
environment just keep trying until it
works and this is something that happens
with a lot of tools deployment
automation tools like octopus and other
ones where you can do a deployment
something fails halfway through because
there's a file locked or maybe you're
out of disk space so you fix that issue
and then just run the whole thing again
there's no state there's no point where
you're like oh what got copied what got
ran or what got run what scripts have we
applied you can just do the whole thing
again so stateless deployments databases
look at migration scripts and also
compatibility one version back is is
really powerful it means that you can
care a little bit less about pushing out
binaries that you might have to pull if
if everything goes badly so we've kind
of got our software in a better state or
we're starting to get ourselves are in a
better state and we're starting to get
our software in a place where we can
deploy it a little bit more safely and
then we get to this the speed part
they're deploying the right stuff which
we've which we've got here to the end
users so we've got two playable software
and now we want to do it faster and this
is where this virtuous cycle comes in we
want to do it faster so we're deploying
smaller bits and they're less risky
every time we deploy them and if we make
a mistake we can just push out a fix
really quickly so we want to improve the
cycle time so number one obviously is
automation that's that's kind of the
first thing that anybody goes to
automating the process that you're that
you're using to deploy and again this
comes back to a step zero where we now
know what we do with the deployment so
we can start automating that
the reason we want to automate is that
people tend to make mistakes who's heard
of um Knight Capital Group anyone a few
hands
I like seeing almost no hands because
it's a great story so Knight Capital
Group was a software development company
they did they did share trading software
for the New York Stock Exchange
so they take these big trades and then
break them up into smaller pieces and
find people who wanted to trade them so
they were passing through billions of
dollars a day in trades and they decided
they needed a change to the algorithm
that worked out pricing and things like
that so they reused a flag that had been
used several years before that just
wasn't ever set to to the other value
anymore so basically repurposing a flag
they they made the changes and they
tested them extremely thoroughly and
everything worked everything was going
really really well
everything worked perfectly they needed
to test it billions of dollars a day and
so overnight they deployed the new
version to production and then in the
morning the market opened and about 45
minutes later the company had lost 440
million dollars in 45 minutes before
somebody worked out that they probably
just needed to hit the kill switch now
the reason that it broke wasn't that the
software didn't work these changes that
they made worked perfectly but the
person doing the deployment deployed it
to seven out of their eight servers so
the eighth server was running this old
code that hadn't been run in eight years
and reporting incorrect values back so
the company was bankrupt in less than an
hour even worse they were large enough
to be called like a market mover so
there were other smaller companies
responding to the trades that they were
making incorrectly and so they got fine
stupid amounts of money because they
basically put all of these other
companies in danger by by trading
irresponsibly but yeah that company
doesn't really exist in the
for many more they they went bankrupt
not because of the software didn't work
but because somebody made a mistake and
it happens so people aren't good at that
kind of stuff to start doing this
automation as well don't start doing it
as a big bang like we know how complex
some of the software is to deploy that's
why it takes the whole weekend but
there's some bits that you can do a bit
faster maybe
so if step one is copying a gig of
binaries and stuff to each of ten web
servers you can automate that really
easily like you don't have to have
somebody RDP onto all the machines and
drag the files across just automate that
little bottleneck then look for the next
bottleneck and automate that tools like
octopus release management any others
that are there they generally have a
manual step like a manual intervention
step is what's called in octopus and I
think what it's called in param
coincidently okay you don't have to
automate everything in one hit you can
have manual steps listed in the tool of
choice for the things that you think
well I don't know how to automate that
or I'm not going to automate that yet
it's too hard and then that step is just
a pointer to say all right now we need
to go and do this now it has the same
effect as a word document that's
probably incorrect as well but it means
that it's much easier later on to take
that manual step automate it and the
process can continue without you which
is good the ultimate aim of course is to
automate all of the things like automate
everything you can there's another talk
I do where I talk about a pipeline and
that if your pipeline has a human in the
middle like a manual step then it's two
pipelines joined by an idiot so that's
what you should ideally be trying to
avoid just have one pipeline that goes
all the way through
speaking of pipelines this is what
you're trying to really get to so a
pipeline does two things
automation and safe deployments so your
pipeline should really make it as easy
as possible and as hands-off as possible
for your code to get compiled tested and
deployed to an environment now may not
go all the way their production straight
away and in fact until this pipelines
produce all
you probably don't want to do that you
don't want every commit that you make to
hit production probably I certainly
don't so the pipeline is about is about
automation all the way through but it's
also kind of a series of filters it's a
series of stages that give you the
opportunity to prove that this
application is not ready for production
so you build you have this build phase
with your build server which makes sure
that the changes you've made and the
changes other people have made don't
clash does it compile and then do the
test pass unit tests and acceptance
tests and all the other ones integration
tests and and all of those things do
those tests pass or have you broken
something have you regress to bug or
something like that and then to play it
to another environment and try it in a
real you know web server or something
like that rather than your dev machine
or the build machine do the tests still
pass does the UI look the way it does or
if I screwed that up somehow can we talk
to the third parties like can we talk to
the data base can we talk to that web
server where's the network on weird or
something like that and then did the
process that we used to deploy it did
that work or are we missing a step and
then by the time you get to production
if it's passed through all of these
filters you're pretty confident that
it's going to work by the time you get
there ideally and we talk about
retesting red green refactor so
everybody know that one so the idea
being if you see a bug you write a test
to prove the existence of that bug so
the test goes red then you fix the bug
and then you make sure the test goes
green so you're testing the right thing
and then refactor is often just a did I
regress anything else do I need to
change the way the codes are written all
that sort of stuff or red green red
green red red red red damn it revert is
another one so you can do that with your
process as well
if you get something in production that
you don't want in production then you
can add to your pipeline prove that it
stops that thing from getting all the
way to the end and then you know that
you're not going to make that same
mistake again so for example if we have
that issue where the deployment failed
because there was a file lot
then maybe we need another step in our
pipeline to say during the deployment
check that this file isn't locked and if
it is unlock it and then continue or
something along those lines so stop the
same errors from happening again so
ideally by the time you get to the end
of this pipeline just before you get to
production you know that the software is
at a reasonable quality it's passed your
tests it compiles okay it deploys okay
and it's going to work if you want to
move even faster though and I wouldn't
recommend this as like step number one
necessarily but it's a really good thing
to do is to work with feature flags
does anybody have feature flags at the
moment okay
quite a few people so in general a
feature flag is just wrapping some
changes in a flag think of it like an if
statement basically saying if the flags
turned on then do this and these are the
changes that I'm making if the flags
turned off do what you were doing before
that's kind of a basic way of thinking
about it and because we have all of our
configuration external it means that we
don't have to worry about recompiling
the application with our code in it and
then making sure we recompile with the
changes out of it so it'll work as well
we can just flick a switch in
configuration so we do when we deploy a
test we can turn it on test it but then
we deployed it to production and you can
deploy it with the flag turned off and
so the old code will still run so
production what this means is production
has your unfinished or you think it's
finished code running in it which allows
you to test your code in production
which is generally not a good phrase to
use testing in production but it can be
really powerful so Facebook does this a
lot
they Facebook deploys on a daily basis
up to five hundred changes on a daily
basis and they have like hundreds and
thousands of thousands of developers
working on the same codebase at the time
and it's PHP to make it even worse but
they wrap everything they're doing
feature flags and they can they push it
out to production and then the developer
who worked on it can turn that flag on
for themselves and see what happens and
if it's wrong turned off again
and it's in production so you can test
it in the real environment it's
ultimately going to be in but you're not
impacting anybody else of course your
pipeline needs to check that you're not
going to implant impact anybody else as
well
but you can do that test in production
the other thing that lets you do which
is actually really really powerful is
that lets you separate the launch of a
change or a new feature from the
deployment of that change so you could
be pushing stuff out to production all
the time and then you think this is
definitely ready we don't need to work
on this anymore and it's sitting in
production with the flag turned off your
marketing department can then say well
you know it's about to be holiday period
at the end of the year we're going to
release this feature now and they just
flick the thing on and it lights up for
everyone you can do this with
on-premises software as well so it's
very common with web software to do this
kind of stuff but on Prem software as
well you can hide changes behind behind
feature flags and let people download
new versions and update the new versions
of the application and you can either
set it on a date timer once you're
confident that it's going to be ready at
this date just to light up at the time
Apple does this as well like if you've
got I Oh s-sorry OSX updates before just
before an Apple update people decompile
the bits that have been pushed out just
to see what new features are coming in
the new laptops but they push this stuff
out and then at a particular date it
lights up so we undo that with octopus
as well because that's a an application
that you install on a server so we put
code in that's we think probably pretty
ready to go but we want to test it in
real environments so we released builds
with that behind a hidden feature flag
that's off and then maybe some
trustworthy customers we say can you
just go to the configuration file and
add this line in please and you should
see this thing light up and they can
test it for us and if it doesn't work it
doesn't meet their expectations they can
just turn it back off again so you can
do it even if you're not doing web stuff
all right so improving cycle time number
one automation and I should care what
product you use you should use of course
but if you have a product that works for
you or even your own scripts you can
handle all this stuff if you really want
I wouldn't recommend it necessarily but
have some automation process to do the
things that humans about it start
building up that pipeline that automates
the build test deployment to your test
environments things like that so start
doing that and then add to it add the
tests add the acceptance testing add UI
and try and remove people from that
pipeline as much as you can and then
feature flags if you want to move really
fast as well so a little note on the
culture of DevOps so I've heard plenty
of people say that DevOps is not a
process or a product or anything like
that it's a culture change in your
organization and I think there is
definitely value in that statement and
it's pretty much correct but I don't
think it's very helpful for somebody who
is already working on software and then
they need to they need to get their
process better and they need to deploy
faster and safer and things like that I
don't think it's very valuable to say
well you just need to change the culture
has anybody been in an organization
where somebody comes up and says Bob by
the way we have an agile culture now
right yeah exactly
you can't just change the culture of a
company straight away somebody can't
come in and tell you we are now a DevOps
culture it doesn't really work and you
should say also don't change anything
your new title is senior DevOps
architect don't do anything different
though you can't just change the culture
but there are some things that you can
look out for to prevent you going in the
wrong direction and again I want to talk
about silos so yeah if there's two teams
so let's say there's a dev team and a
test team and a DBA team and a and an
ops team right
the developers write their code and they
make their database changes and then
they submit their changes to the DPA s
for approval I've worked in a company
like that and we weren't even allowed to
see production databases we just
submitted our database changes to the
DBAs the scripts and then waited for
their approval how many times do you
think it came back without change
none ever need to justify their jobs so
that's one team but we were throwing
things over the fence and then that was
fine we'd write instructions for the ops
people to deploy and so that would get
thrown over the fence you know so you're
just you're not talking to each other
you're just throwing things over the
wall and usually the solution to a
problem isn't to build a wall there's
some people so yeah try and avoid these
silos as much as possible there
shouldn't be a DevOps team unless that
DevOps team consists of the developers
and the operations people like it should
be the same people doing that work who
are actually talking to each other not a
new department if you're in an
organization where you don't have
control over that scenario though which
is a lot of people working in
brownfields DevOps if you're a developer
who's being told to move the tickets
from this side of the board to that side
of the board you're not going to be able
to convince management not to have silos
there's organizations where people's
jobs seem to rely on them being the only
person who holds this power to modify
the database or to change this server
and you might not have control over that
doing something like establishing a task
force is kind of a nice way of getting
over that communication problem without
having to change the organization if you
can convince your manager that you need
a task force to prevent this thing that
happened the last time we deployed even
better if you can make it sound like it
was their idea then you can overcome
these issues before they happen so the
time when you do these Saturday
deployments and everything goes horribly
wrong the last thing you want to do is
sit back and say right what went wrong
how can we prevent it from happening
next time but really that's the ideal
scenario to say look these things went
wrong maybe we as developers didn't give
you enough information can we establish
a couple of people from each team just
to sit on a regular basis and work
through these issues so that we can give
you better instructions next time or
that we can write better sequel scripts
to give to the DBA team next
tell us what we've done wrong we'll tell
you what you can do to help us and you
actually have this communication
happening even if you can't restructure
the organization the word task force is
actually quite powerful as well people
think oh that's not a restructure it's
just it seems seems modern and you know
change of culture because we're DevOps
now so you can do this do this stuff
without having the power to change the
organization the other thing you need to
really really focus on is fixing stuff
for next time it's really really easy
especially if everything goes wrong to
just fix the stuff as you go yes well
you need to unlock that file fine we'll
do that this time and then as soon as
it's done you wash your hands of it and
you go back and you do your development
what you really really need to get into
your team is the idea that if something
goes wrong you need to prevent that from
going wrong the next time so build that
step into the pipeline now if you
release a bug make sure there's a test
around that thing so you don't release
that bug anymore and this can help the
culture change as well but for the most
part the culture will start to change
once you start being able to deploy
faster
you know the idea of well I need to push
this code that I'm working on out to
production maybe I can just wrap it in a
feature flag and turn it off so I'm not
impacting anybody else these changes
will just start to take place once you
start making these small changes to what
you're doing but yes try and avoid silos
as much as you possibly can
the word task force is powerful
especially if your manager thought of it
fix any problems that occur for next
time so they don't happen again these
three things can kind of push your
organization to a better culture as well
so I just want to go back before we stop
I'm gonna leave a bit a bit bit of time
at the end just so we have time for
questions because I understand
everybody's situation is completely
different and you might have listened to
five of these tips and all that's not
gonna happen there's no way I can make
that change so I want to hear about your
individual scenarios as well if you have
questions but going back to this
definition working together to get the
right stuff in the hands of users faster
so this is really all it's about and I'm
not going to tell you you need to have
this meeting at this time
like in scrum or that you need to have
the this team structure necessarily work
out what works for you but make sure
you're working together as a company
that wants to push the right stuff out
to the users on a faster basis that's
how you get to where you want to go so
we looked at where we bother at all
whether it's a buzzword we can just
ignore and hopefully the ideas behind it
are not something that you should ignore
don't have to call it DevOps if you
don't want to it's gonna be like agile
software development with it's just
software development now like that's the
way that people do the work hopefully
DevOps is going to be well that's how we
do the work soon so we establish a
baseline with our application so we know
what's happening with our process and
then try and make small changes to the
architecture of your application to get
to a better State so your application is
more deployable and that means
externalizing dependencies or the
configuration and things like that so
you can make these changes and deploy
the same bits each time then try to get
better at actually deploying those bits
to the target machines that they need to
go to where it's not a drama to actually
deploy the application and then finally
once you start going down this path you
can start improving that cycle time so
that you're deploying rather than once
every three months you're deploying on a
daily basis or an hourly basis
now one important thing continuous
delivery and continuous deployment as
well continuous delivery is kind of
being able to deploy your application at
any point continuous deployment is when
you do continuous delivery is much more
important if you if you hear about
people saying well we deploy 80 times a
day like I think is it Etsy I think
deploys to production 80 times a day
which is great good for them that's
fantastic but like a doctopus it's an
application that people install on their
machine we don't want to deploy a new
msi 80 times a day but we couldn't it
takes us half an hour to go from a
commit all the way through our pipeline
to get production ready application and
we can click a button and within that
half an hour span it can be on the
servers
blog post up the changesets the github
comments have changed the issues are
closed the binaries are their new
versions are up all that sort of stuff
inside 30 minutes so we could deploy 50
times a day but we don't need to we
don't have to it means that if there's a
bug we can fix that bug in 30 minutes
after we've fixed the code we can push
that bug fix out in 30 minutes so we can
do it but we don't have to and then as
you do all this other stuff you'll end
up seeing this culture shift but there's
things to watch out for silos especially
and making sure you kind of fix the
things that went wrong so they won't go
wrong next time and that will definitely
contribute to the culture so that is all
I had for you we've got time for
questions but thank you all right anyone
have any questions about this yeah how
do you prevent feature flags from all
feature switches or toggles from
floating the code base that kind of
comes back to the process that you you
have your development process ultimately
feature flags are a great way to to
generate technical debt and I gave the
example of Facebook they wrap everything
in a feature flag they have made the
decision as a business that they don't
clean up old flags that are never turned
off anymore that code exists in their
codebase they have hundreds of thousands
of lines of code that never get run in
their codebase but that was their
decision the way their compilation kind
of works is that they can filter that
stuff out and it doesn't impact
performance and things like that but
they had to do a lot of work to get to
that point as a general rule cleaning up
technical debt afterwards just needs to
be built into your development process
so maybe you have a point at which you
say if a flag has been turned on in
production for a month then there is a
little tick a literal ticket that goes
on our backlog to say clean up the
remainder
that code so that it becomes a process
thing rather than a you know technology
implementation thing I think yeah yeah
so yeah the comment was as soon as
there's pressure for features the
process things are really hard and that
is correct as a developer you often
don't have control over you know how you
how you spend your time it's about
moving the ticket from here to here
right convincing the management or your
bosses or whatever that the time that
you spend doing this thing that's not a
new feature is still time well-spent is
a really hard problem sometimes I don't
know whether I should condone this but
sometimes it's better to just do it and
then ask for forgiveness later that old
saying that it's much easier to ask
forgive forgive 'no stand permission
sometimes that can apply just have that
as a process and say no this is a
required process we have that to get on
there for a reason it's it's on it's
also kind of that that's kind of the
reason that i'm not suggesting that you
pack everything up for a month and say
right we're going to do devops now
there's no features for the next month
we are going to do devops that doesn't
work you need to incrementally fix these
things but yeah that that is a hard
problem I'd say if you did if you get
definite pushback and know you are not
working on anything but features maybe
just spend an hour a day doing it anyway
maybe possibly I'd be a terrible boss
a special library I use for feature
flags I have only used my own kind of
hand rolled stuff before or launch
darkly is a service kind of a feature
flag as a service start up out of San
Francisco because that's where startups
come from from like 2015 I think they
started so still pretty new but they
have some pretty cool technology that
will only push the changes out to your
running code so you could have that flag
turned on for a thousand machines and it
runs through that code to say do I turn
this do I run down this code path or
this other one but it will never call
back to the server unless that changes
and then it pushes those changes out so
it's actually a really cool tool pretty
easy to use as well I did a talk on
deploying straight to production last in
DC Oslo and from never having used that
product before to having a working demo
with a couple of feature flags was about
40 minutes libraries fall different
environments and stuff like that but so
that's the one that I've used before but
I've also hand rolled I mean it's an if
statement
it does get complex but yeah that
question of whether you'd store it in
the database or config files or
something like that I mean that's a
third party of third party place to
store that configuration won't Darkly so
that could be your thing or you could
build an admin page that just sets the
database record to on or off it's not a
terribly difficult problem it's just you
need to make sure you get it right yeah
there's a question here
yeah so question was about different
permissions for users so when you're a
developer working on the code you
probably have full admin rights of the
application that's running but then we
need to play it you don't see the same
thing that your customer sees um there's
two kind of ways to handle that I think
feature flags is one where you can just
flick it off again and say oh we didn't
realize that change was going to affect
you that way so let's just turn it off
we'll go back to the drawing board but
probably better is to build that into
your pipeline so I have tests that test
all of these things as a particular role
so building that into your pipeline as
another filter do the test pass as an
admin great but do they also test or do
the test also pass as somebody with
these permissions so there's obviously
going to be a lot more work in doing
that and it's always a balance between
is it worthwhile preventing that error
spending a few hours preventing that
error or is that an error you're willing
to accept and you'll just deal with it
when it comes up that ultimately is kind
of a team management position what do
you spend your time on any other
questions yeah
if you want to see a slightly less
polished task I hope you're coming to
pub confident talk I hope you coming to
popcorn for tonight and yeah that's me
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>