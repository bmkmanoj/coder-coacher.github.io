<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Multi-container applications with .NET Core on Kubernetes - Magnus Stuhr &amp; Ståle Heitmann | Coder Coacher - Coaching Coders</title><meta content="Multi-container applications with .NET Core on Kubernetes - Magnus Stuhr &amp; Ståle Heitmann - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Multi-container applications with .NET Core on Kubernetes - Magnus Stuhr &amp; Ståle Heitmann</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/og_oE5JX8_0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay hello everyone and welcome to our
presentation
our title for today is multi container
applications with dotnet core on
kubernetes
and will show you throughout the
presentation an application developed
for hofland which is a demo application
so Hobson is power and Grid company
located here in Oslo or in greater Oslo
if you want and we'll show this demo
application how it corresponds to the
entire IT infrastructure and
architecture of huxley so this will be
our agenda for today so first stola hair
which is the chief technology officer in
hofland we'll take you through the
background and strategy of hustling and
then we'll further just dig a little bit
deeper into the technical stuff we'll
show you a framework called Luna form
this is something that hustlin has
created developed on their own
it's basically consists of terraform
which which is an open source
infrastructure as code and moonshine
which is also a framework developed for
poplin moonshine encrypts application
secrets and decrypted on the fly in
runtime when you start up your
application will go further into that
later then we'll show you the
development of an application from just
starting to actually from scratch
starting to develop an application with
the creation of infrastructure coding
and stuff like that we'll show you an
angular to clients and we'll show you a
dotnet core REST API service and finally
we'll deploy all of this as a multi
container application on kubernetes so
first just briefly about us so I'm not
consultant working for a consultancy
firm called competence Aaron Oslo I work
mainly as an architect and developer and
if some of you want to reach me
afterwards so you can either come up
here and talk with me or you can give it
more easy way and contact me here if you
and still all the we'll take it from
here yes hello
so this title technology chief I've ever
gotten from Agnes
I'm a regular that I think I'll show
with my boss I'm also a developer and
architect and I'm alone almost only one
that's employed in Absalom
the rest are consultants so we're
looking at least mentioned reflected in
the future we'll hire people so here
yeah okay
I'll say something about the background
just briefly just to say where we are
we're coming from and this is where I
got to my boss which is knit and the
point of this is to tell you that this
business is over 100 years old and for
the first hundred years nothing happened
except at the net stations were
progressively getting out there and then
what they're telling that the next five
years that's starting two years ago more
stuff will happen in this business I
think worldwide and ever before mostly
because of regulation from the
government so the big driver right now
the AMS project which is the bit
automatic meters and have where oh woman
every business in Norway so that's like
the driver for all this technology we
are now talking about the recent history
when it comes to what we are you know
like programming it's like this before
2012 we just bought software
nothing not a single line of code was
ever written in option and that
continued also after 2012 but then they
were we became uh sure customers but
only having virtual machines in the
cloud so the modern world started for us
in the middle of 2014 they wrote our
first line of code on the full dotnet
framework and with a dash of cloud
services or windows services we also
made a decision to try to go micro
service we know about the mood that was
our decision so this has been going on
until
late middle year ago about what does net
score came along which we immediately
and fell in love with started the using
now we're using does make for and those
doctor or in 2006 similarly those doctor
technologies we of course still have
what does now what we become that legacy
code from 2014 and we also have this big
milestone where we established new team
where among this is one of the key
players in the another last year for the
district heating business so now we have
two teams and we try to develop in the
same way and the first full application
container based we released in April
this year and we also after that have
gone from sworn to kubernetes so when
I'm now talking about communities where
just one and a half months in have an
introduction so it's still fairly new on
kubernetes quickly this is very new
problem just this is the anchored all
the way up to the top in our computer
which is very new that we are going to
develop everything that's core business
ourselves or potentially of course the
consultants but we do not control we're
going to have the code in our code
wrapper and otherwise you're going to
buy stuff but way to legal to customize
that that's one of our main pains now
it's all the stuff that's customized and
to us as developers this translates this
when we are going to code we want
continuous integration and continuous
delivery and that's I think the essence
of what we were trying to show you today
is the way we're trying to do continuous
integration and delivery and first that
means that the infrastructure is code it
means that you can deploy and everything
and what will especially focus on
because we made ourselves it's the
secure and house we have negative secret
to say is one of the small but important
things you need in order to get this
going also naming conventions in
structural code resources that's also
thing we did I should have known
timeline because we start with a sure
without a thought everybody did whatever
they wanted we are
subscriptions resource groups and no air
so me and a milder colleague I think we
had this project I went through and
saved hundreds of thousands of crores
per delete and stuff because we didn't
have the naming conventions didn't know
what things were also mentioning since
we have this history over working on a
sure we know these platform as a service
components on Azure and we are already
invested so now when we started doing
containers instead of old-fashioned
cloud services we are doing it state in
a stateless way because that's the
history aware to be frank don't know
that much yet about Satan in directly in
containers but it has given us the
ability to move easily so we switch from
sworn to given it is not a problem we
are also currently running on a Sherpa
some stuff for the utility part but we
in the district heating we're running on
Google cloud platform which is what we
show today so this statelessness made
this very easy to move to the core I
think at the first time I saw it we just
fell in love immediately I think in my
mind must be the future does not I can't
see a and I can't see any way around
that so with the jump straight ahead and
they use it from June I think you near
last year that the first person came
which means that we are cross-platform
we are hard pcs but we build on the next
we run on Linux it also means that we
can leverage what we already know
because we are talking to developers and
there has been some problems I think
it's hearing better we are the main
problem is all the legacy assemblies
everything I don't run yet and open core
so a long period for instance FM tab
which we use a lot there wasn't a lot
before it so we had to write our more
low-level protocol thing and then we had
that running for one month then plug
weekend so still early days but I I'm
betting that this is the future quickly
you'll see this is the most that we have
this decided on this we
are very liberal when it comes to we
have subscriptions we make subscriptions
all the time every application it's a
subscription this is for not dr.
Portillo forever you know storage
queueing over the inertia we make
separate subscriptions and we'll use
resource groups inside the subscriptions
to in order to have the different
versions for the full application so
this is a approach we just learn from
another big year and maybe a probably
the biggest user in Lhasa area they did
this and we if they do it like this
we'll do it like this so that's you just
have to decide on some convention and
the main part area very important is
that it's strictly forbidden to do
anything by hand so everything when we
have this inside subscriptions is
include circulars code and then we have
a playground subscription where you can
try stuff to be prepared that I can be
deleted and you know in the next second
yes and that was the background strategy
/ - thank you okay so now you have maybe
a kind of decent overview of the how the
strategy is what we're trying to achieve
here so now we'll dig more into the
technical stuff so I'll start off by
showing you a demo of this Luna form
framework and how we start from scratch
from okay we have to develop an
application now we start from scratch we
want to create some infrastructure write
some code and we'll take it from there
okay so first a little bit background
about Luna form so it consists as I said
above the terraform and moonshine so
Tara form is this open source
infrastructure as code library you can
contribute yourself it has a lot of
different providers included into the
framework and if you want to read more
you can go visit their web page
moonshine is our own developed framework
in hustling what moonshine does it is
that it takes application secrets and it
encrypts it with the
keep air that you provide it and it
stores it in the implementation we have
at the moment which is a table storage
implementation in usher and then we can
refer to these secrets by an annotation
language that we have created in
moonshine so we never refer directly to
application secrets we refer to this
annotation in our config files for our
applications so when we fire up a
container containing our code then
moonshine will go directly into the
encrypted store and retrieve the values
for us and decrypt it with the keys that
we provide so Luna form is a combination
of this terraform in moonshine
so what luna from does in runtime is
that it runs the terraform apply command
which is a terra forms way of actually
creating the infrastructure that you
have witness code then moonshine takes
over and the output from this run of
infrastructure creation will be
encrypted and stored into moonshine so
all of this terraform code and Luna form
stuff is checked into a known repository
that we suffix with application so for
instance in this case we're going to
create a demo application which we just
called demo so then we'll suffix it with
application so our repository will be
demo application and here we store all
of the stuff needed to create
infrastructure to deploy all our
containers in order to run our
application smoothly so for instance
throughout the demo you'll see terraform
files and kubernetes files we'll get
into that soon so we'll soon just jump
right into a demo and we'll show just a
very small application it's basically a
front-end client where you can write in
your name and click the button and it
will just register how many times a
given name has clicked the button and it
will of course store it down to our API
which further stores it back into
table storage annasher so this is
basically the architecture that you see
so we have this developer sitting in its
local its local hiss or her local
environment and okay so you start from
scratch and you write in terraform code
because you want to test your entire
integration of databases and stuff so
you have to write okay I need a table
storage storage account in Asscher so
you write code for that and when you run
this in Luna form it will create what
you have said terraform to create and
then it will take all the output and
persist it in moonshine as encrypted
values and will now have this down here
this demo application repository where
these terraform files and Luna form
stuff will be located so we'll just jump
right into a demo so before we go on all
of the demos that you'll see today are
recorded videos because then we know
that it will actually work and there's
no bugs or growers take and everything
yeah the first thing okay so we'll just
jump right into this so okay yeah very
nice code here
sorry about that okay so now we're into
the azure portal of hustling so what
you'll see here is the first thing
technical thing we'll start off with is
the subscription this is the the
technical stuff that developers I kind
of take into consideration so here we
have an empty subscription for our demo
application so we have just call this
also demo and you can see here there's
no resource groups yet
so because resource groups are basically
a container for all your resources that
you want to work on so instead of
clicking this create resource button
sorry a great resource group button will
of course create this automatically by
applying terraform so we'll just go
right into our demo
vacation repository which I mentioned
previously this is where all the
infrastructure code and deployment code
will will be written so here we're into
IDE we have this source folder and
terraform folder so at this moment of
time we just want to create a dev
resource group for development because
we want to test our entire integration
so here you can see we have given Luna
from files that we need we have the
terraform files so now we're into the
main terraform file which specifies what
resources will be created so you can see
we want to create a resource group
because that's basically a group for all
our resources if you don't have one we
can't create any resources to work on
and further we'll also create a storage
account which is an account for storage
basically so you can have blob storage
table Storage bunch of different stuff
we'll have a table storage
implementation here too today and we can
also go into this variables file and we
you can see the the text I've
highlighted here is basically a variable
defined in the variables file we won't
go into this file today because it
contains all of our secrets so you won't
see that today so we'll just skip right
into the output file because this is
very important because as I mentioned
previously terraform outputs what you
tell it output so in this case we want
to output all the different stuff we
need for our application to run because
we need it in our config file but we
don't want the actual secrets we want
the encrypted secrets to moonshine so
this is what terraform will output as
plain text so it will just output all of
our secrets right into the console when
we run it the blue uniform will take all
of this and encrypt it into moonshine
for us so we can just go into our
development folder for terraform so
there we'll just make sure that we're in
this folder and we have these files and
now we can run terraform in order to
just show you the output of
the terraform run command usually we
just run Luna forum right away because
Luna forum would take all of the output
and encrypted into moonshine and you'll
never see the plaintext secrets but just
in order to show you how it works we'll
just run the terraform app icon on first
so terraform apply we'll run this one
this will usually take a little bit of
time so I'll just speed up a little bit
okay so now you can see it has created a
storage account here a resource group
here and our storage account name is
here so now you can see it's still
creating our storage account so you can
see how many seconds have elapsed
30 seconds should be done soon okay so
here is the output of terraform so you
have this storage account key which is
basically our plaintext storage account
key which we don't want anyone to know
about
so what Luna firm does is that it takes
this output it encrypts it and it stores
it into moonshine so now we have run
this terraform apartment and we didn't
have any resource groups prior to this
so we'll just go right ahead and refresh
and hopefully we have gotten a new
resource group which we have so we have
now a development resource group in
Azure
for our demo so we can go ahead and
click into this just make sure that with
our storage account was created as well
so we'll just scroll down here okay so
here you can see we have a storage
account postman demo dab which was the
name that we specified in our telephone
files okay so so far so good
so we can go back into here and now we
want to take all these secrets it's
basically just one secret but we want
the other variables as well to refer to
in moonshine because let's say you have
a production storage account in a test
storage account we want to version all
of these secrets or variables if you
want
to a given environment so for if we say
now we've run in the dev environment
then our storage account name is awesome
demo depth if we run for production it's
awesome demo pod so we just want to have
all of these injected into moonshine so
what we do then is that we can go into
our moonshine table storage which is
where our secrets will be encrypted so
this is just a cloud Explorer into a
sure we have this config values table
and we can just refresh it to make sure
that there are no entities area and when
today's cool okay so what we want to do
now is run Luna form and what Luna form
does is that it first run this Tyra form
apply that we have just run here but
they will do it integrated into the Luna
phone framework but now that we have run
it it will just check that okay it has
already been run there are no changes so
it'll just skip that step so now we run
the Luna from command and now it calls
terraform but nothing has happened there
so it won't run it it's back to
terraform and now it has taken all the
application secrets from the output that
you saw last time when we run terraform
apply and now it has taken and the
secrets and encrypted them into
moonshine and now we can refer to them
through this annotation language instead
so in our config files will never know
the actual secrets we'll just know the
annotation to the sequence you can also
see that we have for the dev environment
here because we version on environment
properties so now we can go back into
our moonshine store and we can go in and
refresh so hopefully we have some values
there now and we do so we partition on
application and then we have a component
for the application which in this case
is storage and this storage also have a
version so you can see it's storage with
a suffix dead so that's for the
development environment obviously so we
have also stored this account key as a
property with a property value and our
storage name because names are also
versioned if we want to version them and
in this case we have because our storage
account name was hasn't had a suffix
called that okay so now we have this
encrypted secret or secret sorry into
moonshine which was the output of
terraform the the secrets that perform
output and and these outputs from
terraform also what we specifies we have
full control of that
what Luna forum stores okay so that was
our first demo so I'll just try to
illustrate what I've just been talking
about about these config files so this
is a typically default standard Jason
config file in dotnet core so in this
case we have just referred directly to
our secret in this Jason file which is
stuff that many people do but we don't
want to do it because we if someone gets
our code then we're kind of in bad
weather so what we do in moonshine or
through moonshine is to refer to it in
this way with the moonshine annotation
language and when we refer to it this
way moonshine will take and resolve our
application sequence on the fly when we
start the application so how do we
actually input this complan to our code
well this is the standard way of doing
it in dotnet core you just say adjacent
file to our configuration builder and
then you build it how we do it in
moonshine it's basically just the same
way but with an extension method so we
have just extended the configuration
builder to this so now instead of saying
adjacent file we just say set of
moonshine configuration with our
accounting file and on the fly when we
say build it will resolve all our
secrets decrypted for us and we're good
to go and of course we have to provide
moonshine run time with our encryption
keys and where the actual
encrypted secrets are located
and we'll get to that soon so then we
can start injecting our secrets into our
code so in this case you'll see a person
repository which is a repository over
our table storage account where we will
store person's names and how often they
have clicked the button so now we have
all of these decrypted secrets from
moonshine ready to be injected into our
person repository so we just refer to
them as this and eject them into our
classes so like this and we inject them
like this okay so now we have our
development infrastructure ready to go
it has been created we have a storage
account we can start actually persisting
some data so this is what we had this is
where we left off and this is where we
want to get now so now we want to start
develop a demo service which has its own
repository down here and we want to read
and write to our created table storage
account or storage account if you want
because you can store many different
implementations there so we'll just jump
right into it so now we're into our demo
service which you can see here on the
right and now we're into the actual demo
controller which is our entry point for
our REST API calls that we'll soon get
to so what we have here is that we have
a guest method for getting data which is
basically the names and how many times
the person has clicked the button and we
also have post because we want to take
all the clicks and post them and persist
the actual data into our table storage
and you can see here that we have
injected this I person repository as a
singleton we saw how we resolved the
secrets and injected them into the
person repository which is this class so
here we inject the actual secrets
the storage account for the table
storage is in need of these parameters
storage account key and storage account
name which was the previous slide I
showed you where we inject our secrets
which we don't have any clue voice we
just sell moonshine to decrypt them for
us so we have this right person we have
this delete person just basic repository
operations that will soon refer to in
our code actually we have referred to it
I'll just show you so now we're back
into our app settings JSON file which
was the file that I showed you on the
slide so we have referred to our
moonshine annotation secrets we don't
know what they are we just say to
moonshine this is our secret please get
it for us
then the storage name and of course as
we showed previously we have this demo
application storage tab and the account
key and the name which are encrypted so
and now the kind of magical stuff comes
into play because some of you might now
wonder well how do you know where to get
the values from how doesn't know how to
encrypt it you need to provide something
rights so of course we do so we specify
environment variables in our running
application so moonshine will take these
into consideration and know what to do
with them so when we develop locally we
have this support for moonshine
properties files which are the
environment variable specified in a file
that moonshine recipe recognizes
usually when we deploy the applications
to kubernetes these secrets are actually
specified in turbo Nettie's as secrets
we'll get to that sooner later sorry but
now when we work in our local
environment we can specify it through
this moonshine properties file so we
don't have to go into our system
environment Bibles and change don't we
just in a file and change them we can go
towards several multiple environments in
this case we want to go to the dev
environment so all of this is specified
here so we have the moonshine storage
account key we have the moonshine
account name
what table it is located in and stuff
for that so this is kind of the
configuration for moonshine in runtime
so here are our secrets for encrypting
and decrypting so these were the same
secrets that Luna form use to to encrypt
the the values and store them into the
table storage and it will also use these
to decrypt it on the fly so now we're
into our one detail at file is get
ignored right so it's not check the net
that's very important so we just have
them local so now we can run our demo
service and in document core you just
say dotnet run and the application
started we can go into postman and we
can just test that our API actually
works so we go to the local host API
demo we can get it send a request and we
see that we get no content well
obviously we don't have any data
persisted in the table storage yet so
that's kind of the expected reply so we
can start posting some data so I'll go
ahead and just post the name stola
because i likes to order sandwich so
i'll just go ahead and click send and
okay we get a 200 ok back one click we
can send no we'll just do something
random we go back and we can go into get
again so now we have post one time and
now when we get it we get the expected
value back 200 ok which is good so now
we can just go back and post Staller
some times to
to make sure that it's magic air it
actually works as it should so we click
in five times okay we get it again it
seems okay and now we can go into our
table storage accounts so this was our
storage account that we created in the
acid demo subscription under our
resource group and now we have these
tables ready to go now we can refresh
because we have created our table
persons and we want to that we can just
go in and this was the person's table
name that we specified in our config
file so and it's also the table name
that gets injected into the person
repository which tells it where to store
it so we can go into this one and you
can see now it has persisted the data
that we have sent into our service we
can just go ahead and post again and we
can go back into this one and refresh it
and okay so well as one more click so
the entire integration the service
integration with our database now seems
to work so so far so good so this was
where we left off last time or just now
and now we want to create a client that
will communicate with our service the
service that we just showed in order to
have a kind of better graphical user
interface that the users can interact
with and this will be in its own
repository demo client so we'll just go
back into demo okay so this was where we
left off we had the skate store last six
times so the integration with the
service and the database seems to work
so what we'll do now is we'll just stop
the service from running we don't want
it to run out and we can go into our
client code that we have called the demo
clients this is angular code so this is
basically a client that will communicate
where
our REST API so now we're into the demo
clients in our powershell so what we'll
do now is that will start this client
through the angular CLI and we'll say
that will run with the local environment
and first time is pretty slow so we'll
just skip up a little bit there I see
that the codec is really do you get the
green screen swells in 2000 that just
speed up here so now you can see it's
building stuff it's going to deploy to
this localhost 4200 port so we can soon
start interacting with it 92 percent
okay so now it's good to go we can go
into our low close and hopefully see our
client running
okay so this is basically our graphical
user interface communicating with our
service so we can just try to submit a
name and we'll now running in the local
environment we'll click the button but
of course nothing will happen because we
stop the service previously so we want
to fire it up does not run again okay
now it's back up and we can try to click
the button again will refresh it
worked laughter well okay so it just
took a little bit time before it
actually could communicate their own
service
maybe our local computer was trying to
craft that so we click it again okay so
now it seems to work pretty well we can
click it once more okay so we'll just
leave it at five clicks for myself okay
so now we actually have this client
communicating with our service it seems
to we can refresh and hopefully we have
monitor as well which we do so now the
entire integration of the client to
service and the database seems to be
working pretty fine so now we're kind of
ready to let some users actually start
using the application
so now we'll see how we actually take
this local or development environment
application and ship it to production
which we want to be as patient as
possible which are why we have used
decided to use kubernetes and we'll get
into the details there so slowly we'll
take it from here and talk a little bit
about that yes just a brief overview of
kubernetes or so what is it it's a
container what they call a container
orchestration engine so there are mainly
you can choose between kubernetes or
which is a open source comes from Google
from Google or you have swarm or also
something called maiasaurs and this is
long we're using so when you can run
containers by yourself or you can use
this if you use this it hands the
cluster machines for you and it also
handles this hard state so you say what
you want and it tries to enforce it so
that if you say I want two of these
services and one of the one one goes
down it will start the new one again
runs on all the major cloud platforms
and there's a large community
so whenever communities you are defining
kubernetes objects and absolutely define
your new files and what they are as I
mentioned our desired state look at what
you want running on a cluster what you
want to run and how each application
should behave when it comes to scaling
up grading and fault tolerance and those
kinds of things and there are several
kinds of what we call objects or all
them are defined in the same way and
these are the most basic or important
ones the most basic one is called a pod
so you never refer directly to a
container a pod runs one or more
containers inside of it and the basic a
building book and what it means is that
if you have several containers inside of
one pod they are guaranteed to be
co-located so they're on the same node
same machine and they can easily
communicate with each other by a local
host and other mechanisms so that's a
basic but if you deploy a pod directly
so one thing that's not the side state
that's going to make important it dies
it dies nobody's looking after your
naked bulb so you have to define a
replicator replica set which is if you
define a publisher replica set then it's
a desired state configuration and it
will handle it this is also where you
say well how many copies you want and
then this is higher level concept color
deployment which is what you actually
usually define the deployment that will
would be a combined definition of a
replica set on a pub you can do replicas
so directly you can do pull directly but
the recommended thing is to do a
deployment so that's the one thing you
do and then now you have a container or
several containers running inside of one
or several pods but nobody can contact
them so that's fine for some things if
your reference is just listening to a
cue and doing in the background working
on your finish but normally I will often
you want to communicate with it and then
you have to just define a service
because a pod is a ephemeral it can die
any time should never refer direct is a
pub so if you want to talk to a pub you
have to make a service that with first
Bob yeah so uh service is an abstract
way of talking to your pods and also
it's like an internal node balancer so
if you say I want 10 copies of this pod
and the other service defined for that
deployment then the service will
automatically do a little dancing and
normally the way we do it is that the
service is you can have several kinds of
services are three types the one we're
using is called cluster IP which means
it's just you can just talk to it
internally on the cluster so you have to
be on the cluster in order to talk to
this and then yeah this thing but you
could define if you're on the cloud
provider you couldn't define it as
they're called would from a load bouncer
that automatically makes a Google or
Amazon or a sure load balancer which has
a public IP and you can talk directly to
the service we don't do that I think
most people don't what they do is they
define what's called an ingress ingress
controller and I'm going to show you
later that means you have one load
balancer with one IP address talking to
one container which is a special one and
there you handle everything by code
internally inside also you have a
configuration Maps and secrets which are
more or less the same thing which is for
the whole cluster so this is where we
have all the secrets which among the
showed in that file so that's for
instance for the production cluster I
can load up the secrets and not give in
access we potentially doesn't know
anything can't actually find out what
the secrets are and there are many other
objects these are the most important
ones though i think so i mentioned we
are using this through so there's this
concept called an ingress controller and
when you're at a special kind of
container which i will have no idea you
can write yourself you probably can but
there are three brands do you have nginx
and you have this traffic and the hea
proxy so we through just random process
more or less we chose try
SiC because it seems good all these I
think are roughly equivalent but it's
French software which is open source
that's French so all the documentation
is in French which is refreshing and I
also also have this what I call a
Norwegian letter in the name which we
are the gift suits then that's why we
decided on this yes so we have this one
each controller is set up for the low
volume of Google so we can we can reach
it and then we can do cold do routing
afterwards alright so this was where we
left off in the previous demo so we had
this client the service working together
with a database in our local environment
and we were pretty satisfied and wanted
to ship it to production basically so
what will go how to do now is that we
create an automatic deployment build and
this build will just run our master code
or our tag for the release and it will
run the terraform scripts for production
which will create the production table
storage account in uh sure it will take
the output from terraform these secrets
that we specify terraform to output for
us it will encrypt these secrets and
store them into the moonshine table
storage then we will deploy our
application or multi container
application because we have this client
we have this service that we need to
deploy to Cuba Nettie's on Google Cloud
and finally will show you that the users
can reach this application from the web
and communicate with it so we'll just
jump into our demo again so this is
where we left off
and so stola mention these kubernetes
stuff these objects these kind
principles of kubernetes
and what we'll show you now firstly is
that we're going to build the image the
docker container for the Democrats and
push it to the container registry and
Google Cloud so what we do now is we
push a sorry queue new-build and we want
to run it for our release one tags and
usually this is automatic but now we're
just showing you that will wake you up a
new build ourselves and it will start
packaging building the Democrats and it
will ship it to the container registry
in Google Cloud as a docker container or
docker image if you want so this this
build is running we'll do the same for
the demo service which has a newer minor
release than the client so this is one
point 1.0 know how to accept so it'll
run the same steps but for the.net core
stuff so it will two definite restore
doesn't build they will do doesn't
publish and finally it will push the
image to our project in Google Cloud
which is called this and in Google Cloud
we have this container registry which
are all our packet images ready for
deployments so you can see we have this
demo client image folder and the demo
service image folder which are basically
containing all of the images for for the
demo service and the democrat so here
you can see we have two days ago we had
tested develop and master just to make
sure that stuff works but now we want to
actually deploy it to production with
with a release tag so we have the same
for the dump client at seven days ago so
these builds running in the background
now will soon push these images to our
container registry so you can see here
it's still a building so this usually
takes a little bit of time so we can
maybe fast forward a little bit so
finally it will see we have this pushed
our images to Google Cloud and here is
actually
building the building the image and it
will soon just when the building is
ready will push it to pick obtain
registry which you saw it's pushing now
it's Christian yep so it'll soon finish
okay so now the demo service have built
succeeded which is great everything
seems to be fine okay
we can go into our container registry
for the demo service and the last one
was two days ago a pair and we can
refresh it
and hopefully we have a new image here
now okay so a new image was just now
uploaded for a tag one point one point
zero which is great so the image seems
to be fine we can go ahead back into our
builds and go to the demo client build
and it seems that the build has
succeeded there as well so we can go
back into the container registry for the
demo client and you see the last one was
a week ago and we'll go ahead and
refresh this one
okay so now we have this one point one
zero point zero and it was just uploaded
so everything seems to be in order here
so this is basically what we're trying
to achieve now so now we have pushed the
images up here and we also want it to
deploy the actual images as running
containers in pretty necklace
so we'll just go back into the demo and
Staller will tell you a little bit about
the actual technical kubernetes files as
a result of the individual reporters is
not the you know the end goal you may
emerge to master then you have a image
sub roaming yet right so that's what we
do in the demo application roster we
have the infrastructure as code and we
have what's the topology of the
containers that we're going to run for
this move the container application so
now I have this new folder in there
called kubernetes and here we are
defining deployments and services and
induce controllers so it increases yep
personally so this is a deployment so as
I mentioned this is a combination of a
replica set and the pods so I'm saying
here that if you look from the top the
first thing is here I'm RIF it so that
you see this is filmed later than da
because we have made a new version but
the imaginary was the version one to all
that we just pushed so here we're
referring to the image we just pushed
we're saying that we want one replicas
and down and here we are specifying
environment variables to push into the
container as it started and there you
can of course hard code things but here
we're referring to these configuration
Maps and do have a secret there I think
it is further down our secrets play yep
not so technical there were secrets down
there that I previously loaded up to the
cluster as an entire day so that means
we have separate clusters for
development tests
production some people do namespaces we
don't these separate histories and then
since I want to reach this these this
one pub I have to define a service and
that's here everything by the way in in
the kubernetes its labels and selectors
to label things and then if I want to
service to refer to set the pods I have
a selector that matches those labels so
it's like a soft label Ram that's how
you're typing together I'm defining a
service I'm saying I want to call it
demo service API SVC that means if
you're inside the cluster you can now
say HTTP demo service API SVC and they
will reach that service on port 5000
which is what I'm specifying and it's a
tight cluster IP which means its
internal not reachable from outside but
I want to reduce on the outside so
that's where the final ingress that's
top so we have an ingress which
automatically registered with the
English controller which is this French
software the traffic so what I'm saying
here is if anybody hits us in this case
you can have a lots of rules this case
it's and it's a demo service after the
domain then we fit to the service which
I called demo service API SVC and
there's also this part prefix script
which means it will strip away the demo
service we have because if you just sent
address that to our container it
wouldn't understand because there's no
controller another plaque or called demo
service so we script our way so you know
all those sorts of rules the nice thing
with this that's in your code you
control it you call your service
provider once gets them to set up the
DNS tree or 50 point 94 what the IP
address that you got from Google rusher
and then your finish and the rest is you
and your code so now we're ready to go
so this is so we have the same for the
client this is for the backend service
yeah that's really cool so
we have all of these communities files
specify that we need to deploy it and
you can also see that we have this we
have this depth infrastructure is code
for terraform uniform but we now also
want to have for production so usually
we staged it in a test environment first
but of course we don't have time to do
that today so we'll just ship it right
into production so we have these files
there as well so now we have written all
the stuff for deployment and for
infrastructure is code for production so
we'll go ahead and push this stuff so
we'll just push it straight into the
master branch which is kind of cowboy we
usually do pull request of course and
stuff like that and continuous
integration but we don't have time for
that now so we have specified this
automatic deployment build which starts
with it has a trigger listening to the
master branch so now it has started a
build on a master branch so we can go
ahead and look at this build because we
push the code directly to master so
usually it's a merge into master but now
we pushed it so now it runs this Luna
form step over here for automatic
creation of the production environment
which we need for production it runs the
kubernetes deploy step which is what we
needed for deploying security it's
running the queued CTL commands
yes anybody's familiar so there are
tools out there we might look at them
we're just doing the g-cloud cube CTL
commands directly as we didn't just see
here so here is run the deploy
production script so it has configured
all this different stuff that we need in
communities in our production
environment and so everything seems to
be ok now and I don't know if the film
actually you can actually have bugs and
videos as well it seems ok so I think
it's running now we have to restart it
the whole
yeah sorry what okay we'll try to just
go ahead into here okay so we're back
here yeah so this is where we left off
we saw the kubernetes stuff and we also
run run the the luna forum terraform
stuff so we now should have a resource
group for production as well we had this
the development resource group but now
if we refresh it that shirt has should
have created this production resource
group which it has so now we have a
production environment in Azure as well
and finally it should have deployed it
to our production cluster which we can
reach here so we'll try to communicate
with the Democrat that has just been
deployed and so now we have this
deployed application in the production
cluster so let's just go ahead and test
that it works so we'll just go ahead and
write my name just okay so it seems to
be working we can just I'll just fast
for a little bit because we're a little
late on time I think and we'll just try
to okay so it seems to be working so now
we have shipped the entire application
into production we have automatically
created the infrastructure that we need
and all of this were done by the
automatic deployment bill that just
triggered from our master branch when we
push the code so we can just see that it
works as expected since it's in our
production environment we don't want it
to be broken okay so we can just click
stall a little bit here so it seems to
be working fine so it was pretty pretty
easy to just go from having nothing
starting from scratch creating
infrastructure is code just coding a
very simple service a client and just
shipping it off to production through
kubernetes
I'm detecting all the secrets without
their gravity to see it earth created
the intersection communicate this
equation we don't know what they are so
this is basically where we left off so
this is the entire architecture for what
we just showed you and the summary is
basically this we have we run platform
as a service in Azure where we use
usually have our databases and storage
accounts and application insights
logging and stuff like that and we run
Luna form for automatic infrastructure
creation and application encryption
sorry application secrets encryption and
then we usually use angular for
front-end stuff and we use dotnet core
for backyard services stuff
and finally we deploy all of these as
multi container applications to
kubernetes on Google Cloud so thank you
so much for listening and showing up we
really appreciate it
remote invisible is as open-source by
the way it will keep keep all of you
know that okay so if you want to get in
touch afterwards you can of course come
up and talk to us and ask us questions
and stuff or you can reach us here if
you want so thank you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>