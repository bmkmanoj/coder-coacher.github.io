<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building AI Solutions with Google OR-Tools - Barry Stahl | Coder Coacher - Coaching Coders</title><meta content="Building AI Solutions with Google OR-Tools - Barry Stahl - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building AI Solutions with Google OR-Tools - Barry Stahl</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zZAobExOMB0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you all for coming my name is
Barry
based in Phoenix Arizona and thank you
for inviting me to your little continent
here this is nice it's been a great trip
so far I've been doing solution
development designing and implementing
systems for customers large small and
everything in between for about 30 years
now I don't want to spend too much time
on preliminaries but I do want to give
you some idea of who I am or what I am
and I think this next slide actually
explains that better than I could
actually tell you this is my list of
favorite physicists and favorite
mathematicians and just the fact that I
have that list probably tells you
everything you need to know about me
so I've tweeted this out at one point
please feel free to you know tell me who
I missed who shouldn't be there should
open for discussion and these are the
Giants on whose shoulders we stand so we
will maybe see some appearances by a few
of these as we go through the talk we're
here to talk about artificial
intelligence and so I talk on artificial
intelligence wouldn't be complete
without defining what it means and if
you were here for Barbara's talk
previously or if you know anything about
the space or have heard or read anything
about it you probably realize that there
has been a lot in the space of machine
learning a lot of advancements there and
I think because of all that hype it's
very easy to conflate artificial
intelligence with machine learning and
the fact is artificial intelligence is
much more than just machine learning
machine learning is one fantastic tool
to implement artificial intelligence
solutions but there are other ways and
other types of problems that can be
solved using artificial intelligences so
we're going to talk about some of that
today so what is AI what is artificial
intelligence basically it's a
computational system that behaves
rationally so what does it mean to
behave rationally well rationally to MIT
to behave rationally you need to make
decisions so
we're talking about systems that make
decisions on our behalf and in doing so
they do it trying to make the best
decision that's what a rational decision
is one that attempts to make the best
decision it isn't always going to make
the best decision because we're basing
that on the our best available
understanding of how to solve the
problem that is our model and our best
available understanding of the state of
the problem our data if we use the best
available information in the best
available model and try to make the best
decision we are acting rationally
optionally of course we may also act on
this decision so we may build some
automation into this once we've made a
decision we may act on that decision but
that is an optional piece of it now
artificial intelligence or these kinds
of systems differ from say decision
support systems in that decision support
systems are designed and are very very
good at synthesizing and presenting data
in ways that are that allow the users to
make the decisions we're taking that one
step back and saying now the system will
make the decision so when we're doing
when we're talking about AI models I
find it helpful to categorize it into
three different types of models okay
there are the logical models which are
fairly common those are anything that
can be reduced ultimately to a you know
a collection of conditionals okay so if
ultimately you can reduce it to
conditionals like for example of a rules
engine is a very literal list of
conditionals or object oriented logic a
lot of the things that we've been
building in the past those fall into
logic models we talked about machine
learning probabilistic and learning
models are another type of tool we can
use to build artificial intelligences
and we're not going to be focusing on
that in this talk but those generally
result in a prediction of the best
solution you know a probabilistic based
solution
the type we're going to spend most of
our time on today is the search and
optimization space these are solving
problems based on reducing and searching
efficiently a large set of solutions and
we're going to do several examples of
that today and that's where the Google O
our tools are very very efficient now
one of the things that point out on the
slide is that the one of the big
concerns about probabilistic and
learning models is that they require
these huge data sets they require the
more data you can give them the better
off you are
a search and optimization on the other
hand benefits from having a data set to
validate the model but it doesn't
require it upfront so if you have a
situation where you don't have a lot of
data before hand an optimization you may
want to implement an optimization
solution so what does that mean
optimization what am I talking about
here in a nutshell optimization is
finding the best solution from all of
the possible solutions to a problem by
maximizing the good stuff and minimizing
the bad stuff things that we want we try
to increase things that we don't want
features of the problem maximize profit
minimize costs those kind of things so
that's how we go about solving
optimization problems and the field of
optimization there are lots of ways to
do it but we're going to talk about
optimizations that are based on
constraint programming we're going to
build on top of this so the foundation
of what we're going to talk about today
is called constraint programming that's
dealing with constraints and we'll talk
a lot more about what that means then
we'll build on top of that and go into
linear programming these are also using
constraints and putting linear
objectives on top of that and making
linear constraints and then we'll also
solve some discrete problems where we're
using mixed integer programming so we
use boolean variables to assign discrete
things
assigned discrete portions of the prop
of the problem and we'll see exactly
what that means here in a little while
so constraint based optimizations what
we're going to spend our time on and
that's where the Google Oh our tools
provide an exceptional tool to help us
with that
there are basically two classes of
program two classes of problems that we
can solve with constraint based methods
the first is feasibility problems and
that means we have to find a solution
that works but it doesn't really matter
which one any possible solution will
work
there's also optimization problems and
this is where we find the best solution
that satisfies all those criteria and
we'll see real examples of this where
something might be considered an
optimization or a feasibility problem
but actually is better off as an
optimization problem because it's not
always obvious the difference between
the two and I like to illustrate that by
using this cartoon from the great
Randall Munroe of xkcd who has cue ball
here who says his hobby is embedding
np-complete problems in restaurant
orders and so we have a menu over here
and cue ball says that based on that
menu we'd like to order $15 exactly
fifteen dollars and five cents worth of
appetizers okay fifteen dollars and five
cents well np-complete I'm not going to
go into the details of what np-complete
means but np-complete problems have a
feature that while they can be somewhat
difficult to figure out they're very
very easy to validate so if I were to
tell you that seven bowls of mixed fruit
satisfies the criteria you can easily
multiply 7 by 2 dollars and 15 cents and
say yes that does satisfy the criteria
of fifteen dollars and five cents worth
of appetizers ok
and that would be satisfying the
constraint a constraint satisfaction
problem this would be a solution for it
but if I'm the waiter maybe I want to do
an exceptional job
or if I'm a waiter in the US I actually
want to get big tips I might want to
find a better solution a solution that
satisfies my customer better and there
may be other solutions to this in fact
there are there are two possible
solutions to this problem based on that
menu there are seven bowls of mixed
fruit or one mixed fruit two hot wings
and one sampler plate that solution may
be a better solution to my if you're a
customer you're saying well I can get
seven orders of mixed fruit or one of
this two of that and one on the other
thing that may be better for you as a
customer so if you're a waiter trying to
do a better job for your customer that
may be the better solution so what could
we do well we could throw in some
optimizations there we might say hey
maybe we want to minimize the number of
a nice though the number of any single
item so we're not doing more that we're
not going to have seven of anything
we're gonna have two is the maximum of
any one item in these two possible
solutions or maximize the total number
of distinct items so I'm get the maximum
of the number of different items either
of those two optimizations will lead you
to the second solution and thus the
better tip but there's actually a third
thing we can factor in here and that's
the perspective of the owner of the
restaurant if I'm the owner of the
restaurant I may actually want to factor
something different and I may want to
take I want to do the thing I want to
get you what gives me the most profit
but I also have something else I can do
and that is I can relax one of the
constraints I can give a discount I have
to give you at least fifteen dollars and
five cents worth of value but I can
charge you fifteen dollars and five
cents for anything that would cost other
would otherwise cost more than that
taking it from a equal to problem to a
greater than or equal to problem giving
me more possible solutions all right so
at that point then maybe I say maybe the
best thing is oh what is it five salads
are on sale for three dollars and one
cent instead of three
thirty-five cents if that makes me the
most profit I could do that so we could
have a constraint satisfaction problem
that's just any solution works we can
get add optimizations and we can in fact
sometimes do relaxations and relaxations
are actually going to become very
important when we get into mixed integer
programming so we can offer a discount
and maximize our profit so what's a
constraint you've heard me talk about a
constraint about constraints a number of
times now what does that mean well in
simple terms a constraint is simply a
required condition the problem has to do
this thing it is constrained to this
condition but I'm a programmer and I
like to think of things in terms of
objects and entities and such and to me
a constraint is actually an object that
can do two things it can verify
feasibility and he can prune the search
space now well we'll see a real good
example of pruning the search space
coming up here in just a minute so we'll
come back to that but verify feasibility
what does that mean well basically it
means that we make sure that the it
still satisfies the problem and in fact
that there is a solution that still
satisfies the problem so if it's not
feasible if we we can look at things in
terms of infeasibility
okay so if a solution a possible
solution to our problem does not satisfy
one or more of that construe of the
constraints that solution is infeasible
and if the problem has no solutions that
satisfy the criteria then the problem
itself is infeasible and in order to
solve that problem we might have to
relax some of the constraints so that we
can get a good enough solution does it
make sense any questions so far
all right so quickly types of
constraints the typical type of
constraint is an inequality constraint
you'll see this a lot a particular
variable does not equal value or is less
than or equal to a value or an equation
is less than or equal to value that's
the majority of what of the types of
constraints you're going to see well
also today see integer constraints which
are basically the same thing except
integer variables so you know you don't
have a full range of values available as
well as these special global constraints
these are really really interesting
global constraints they take a more
holistic view of the model and these are
predefined there's about 400 of them out
there now there are resources online
that can show you the deep math involved
in understanding them but the key to
them is that they have to have a
dedicated algorithm for solving the
problems that they do and you know for
solving them and determining the two
things that they can determine right the
feasibility and to prune the search
space those two things have to have
algorithms that will run in polynomial
time so they can't start to expand an
exponential time otherwise we won't be
able to solve our problems in reasonable
amounts of time so the one we're gonna
see today is called it all different
constraint that means the variables that
are specified in the all different
constraint have to take different values
all have to be different they can't be
the same it's a really interesting
research area so if you're interested in
in that kind of math it's the kind of
thing that you might want to check out
all right so that's constraints the
other thing we might need today is an
objective objective is if we have a an
optimization problem we define the
constraints we add an objective to tell
the solution or to tell the computer
what makes a better solution how do we
define what is a better solution so this
is where we tell it maximize the good
stuff minimize the bad stuff okay so we
describe how to make the solution better
with our
and we do so using an objective function
that objective function has to be in
terms of our variables that we are
trying to define okay and we specify it
as the goal relative to equation so we
want to minimize this equation or
maximize this sum or what have you okay
now there can only be one objective per
model but we can combine features of the
problem by creating like a score and you
could do that you can even do things
well I want to make this bigger and I
want to make this smaller by inverting
or neg ating things so you have to
define things in such a way as your
problem knows and can moves in the
direction that you want when that score
increases or decreases that's very
common you'll do that a lot and you'll
spend a lot of effort trying to figure
out how to ideally specify the score
define that objective so you're ready
for an example let's started talking
about constraint programming and of
course this is Rene decart did you know
that maybe this was totally my failing I
didn't realize that the Cartesian
coordinate system was named after Rene
Descartes my latin failure i guess
anyways one of the Giants on whose
shoulders we stand
okay so constraint programming the
canonical example if you will of
constraint programming is Sudoku
hopefully many of you know pseudo ku
for those who don't it's a nine by nine
grid which can be described the solution
to the problems can be described as 27
all different constraints I mentioned
the all different constraint where it's
each of the variables have to take a
different value so if my variable my
variable possible values are 1 through 9
I can describe this Sudoku board as a
tall one all different constraint for
each of the columns one all different
constraint for each of the rows and one
for each of the regions
9 cells 27 all different constraints we
have to solve that problem and we're
given information upfront so we're told
here are some values that we can apply
and we have to solve this puzzle so how
do we do that using constraint
programming
well constraint programming is about
looking at the solution space so we
could think about this grid as each one
of these cells having the nine possible
values right so I've listed in each of
the cells the possible values it can
take and this is a pretty big solution
space when you multiply all those out it
turns out that we're talking about the
order of magnitude of number of possible
solutions is 10 to the 77th now 10 to
the 80th approximately is our best
estimate of the number of atoms in the
universe so this is pretty large in fact
I like to say it's inconceivably large
and I like to say that way because not
only so I get to invoke the Princess
Bride the greatest movie ever made but
also because it truly is it is not
conceivable to the human mind you know
if we try a trillion combinations per
second it still takes 10 to the 57 years
to try them all
I looked at how many you know if I
stacked pennies to the moon how how many
times were to go back and forth to the
moon and it's basically going across the
known universe something like 10 to the
30th times or some ridiculous number
like that there is simply no way for us
to conceive of those solution spaces so
naive solutions brute-force solutions
will not work we cannot just throw
numbers at it and try every possible
combination it will never finish we have
to be smarter than that
so the smarter is constraint programming
in this case we have some information
we're given information we're told that
that second cell there is a value of
four and we can make inferences about
the other cells based on those
constraints or some of the other cells
so by knowing we have a four there we
know that all the remaining cells in
this column and this row and this region
cannot take that value for
so we can eliminate that from the search
space we can prune those values from the
search space magic word there by the way
I put it as a bonus question here um in
this model viewed like this how would we
know if our solution becomes infeasible
how do we know if there are no more
there if our if our problem we cannot
solve our problem based on what we've
tried if none of if one or any of these
cells have no numbers remaining exactly
if there are no values left in any one
of these cells that means we don't have
a solution to our problem we've
eliminated all of the possible values
for that cell somewhere we made a
mistake or the problem is not solvable
yeah so let's keep adding values we have
additional value information it gave us
a bunch of numbers so let's just keep
adding them by adding that second that's
six in there now we have a number of
cells here where there's two values we
only have seven possible values and
we've reduced our search space by four
orders of magnitude about 10,000
possible values were eliminated but of
course we still have a long way to go so
to save time here let's jump ahead to
where all the values have been added in
the proof and the search space pruned as
much as we can there and we're down to
10 to the 21st pretty significant
reduction in search space still a lot of
values remaining but we're not done yet
because those who have done Sudoku
before probably have recognized
something and for those who don't I'll
highlight it here there are four cells
in this grid that only have one possible
value remaining these are fixed points
now they have to take this value
otherwise our solution is infeasible all
right so we can set those values we know
they have to have those values so we can
go to the top nine there and we can add
that in and now reduce our search our
our solution space even further and we
can continue looping through we've now
fixed additional spaces here
and we'd continue this iterative process
of pruning the search space propagating
those constraints and doing some
creating those fixed points doing so is
known as running a fixed point algorithm
so we loop through run our fixed point
algorithm to the end and at the end of
this process for this one we see that
we've have only one possible solution
now constraint satisfaction problems
like this are not always this simple a
lot of times you're going to get to the
point where I haven't completely I've
completed I filled in all the
information I have and I didn't get to
anywhere there's only one left
I maybe got to one where there's a space
where there's two possible values left
what do we do in that circumstance
probably bifurcate the problem right we
can run even in parallel one version of
the problem where it's one value in one
version where it's the other value and
continue and see if either or both of
those solutions produce a value or if
they become infeasible okay so there are
some very interesting search techniques
aside from just running all possible
solutions in parallel because you can it
would be easy to see how you could
branch off into lots of search paths
there so searching is a very interesting
fields as well in this branch of
mathematics so that's constraint
programming let's jump into how we'd use
this to solve a more important problem
something may be dealing with
manufacturing and this is George Danzig
who mathematician creator of the simplex
algorithm that is used to do linear
programming another of those giants so
let's talk about pottery we got Pete who
runs a pottery shop out of his garage so
he only makes two products right now I'm
sure he's gonna expand in the future
because he's looking at his data in a
valuable way but he's asked us to help
him out we he makes two products a small
vase at a large vase
and the small vase takes an ounce of
clay and an ounce of glaze and sells for
$3 and the large vase takes four ounces
of clay and two ounces of glaze and
sells for $9 pizzas pizza asked us to
look at it based on this amount of
revenue 24 ounces of clay art sorry this
amount of inventory 24 ounces of clay 16
ounces of glaze he wants to know how
much of each product can we produce and
how do we make the most revenue from the
materials on hand now we're gonna look
at revenue here to keep it simple profit
may be a better way of looking at it but
let's keep it simple for right now just
look at revenue so right off the bat we
can tell a few things we know that an
ounce of clay and an ounce of glaze is
what it takes to make a small base so we
are constrained by the amount of glaze
that we have in inventory right now so
we can make at most 16 small vases if we
made nothing but but small vases we
could make it most 16 of those right and
the large vases are actually constrained
by the amount of clay because they take
four ounces of clay so we could make at
most six of those so knowing that we've
actually bounded our search space here
right we know you can't make less than
zero vases so we have a bounding
rectangle here at zero zero assuming
that X is the number of small vases and
y is the number of large vases we have
this search space this bounding
rectangle that that holds our search
space so we know we concert' we can
limit our search to within that space
and if we just try all the possibilities
and see which ones cause us to exceed
our amount of inventory we get these 71
feasible points anything over in this
space here uses too much of one or more
of the Inman inventory these are all the
valid values each of these dots
represent a valid route the value but
you notice that zero zero is a valid
value
I don't think Pete's gonna want to make
zero of anything either of his thing you
know he doesn't want to make no
product he wants to produce products so
we don't have a constraint satisfaction
problem here we have an optimization
problem and this works very well when we
only have 71 items we could actually go
through each of these 71 and calculate
the revenue from each one and just hold
the value no and say which one that
gives us the most revenue that works
with only 71 values but what if this was
16 million and this was 6 billion here I
don't think we're going to ever finish
if we try and just check all those
values so we have to be smarter about it
we can't use just a brute force solution
so let's look at these constraints a
little bit differently let's look at
them as equations so if we just
formulate the clay constraint into an
equation so this clay constraint is 1
times the number of small vases because
it takes one ounce of clay to make a
small base plus 4 times the number of
large vases because it takes 4 ounce of
clay to make the large base that has to
be less than or equal to 24 which 24
ounces of clay was our a clay inventory
okay so we've formulated that constraint
in an equation and we can plot that
simply by finding the intercepts doing
basic math and plot that on the graph
and we can do the same thing for the
glaze constraint it's X plus 2 y is less
than or equal to 16 and we get this
interesting shape and if you notice that
if we've just plot those 71 points again
they actually fit everywhere where where
it's underneath both of those
constraints which makes sense we have to
have less than both of those constraints
right so it fits perfectly ok this shape
right here this what is it four-sided
shape here it's called a poly top
spelled with an e at the end for some
reason and there is some magic that
occurs with the poly top and George
Danzig helped proved this the
local minima or Maxima of any equation
formed by these variables by the
variables x and y in this case the local
minima or Maxima will always fall at one
of the vertices of this polytop so I
only have four locations now that I have
to test to see which my best value it
what my Revit maximum revenue should be
and this is true regardless of whether
this is 16 or 16 million or this is 6 or
6 billion I still because the shape is
the same I still only have those 4
points to test now we can really solve
some large problems what about if we
added materials if we added say some dye
for the clay or some gilding for the
adjutant's to finish the edges what
we're doing is we're adding variables
I'm sorry we're adding constraints so we
just make a different poly top and what
about if we add another product what if
we add an ashtray or an urn or something
like that
now we're talking about jumping out into
a into three or more dimensions alright
because we're adding another variable if
we add a an urn say we can pull that out
into the z-axis and now we have a
three-dimensional shape if we add
another product we now have a four
dimensional shape and we can't visualize
it anymore
fortunately the computers are very good
at doing that we have to figure out
where these vertices are regardless of
how many dimensions or how many
variables we have and I don't know the
math that does that I'm not that good at
it but I do know how to use a tool that
will help us do that and in this case
we're going to use the Google Oh our
tools but there are quite a few tools
out there and you can see a list of them
they're called solvers they're on
there's a list of them on Wikipedia
they do the heavy lifting and they're
the things that allow us to bring these
types are two solutions to the types of
problems into our artificial
intelligences there are two that I'm
very familiar with Grobe is a commercial
product that if you're gonna do some
real serious industrial work and you're
depending you know you're putting your
company's fortunes on the line and
you're probably going to want to use a
commercial solution like a Roby
something with support to get started or
to solve a lot of of simpler problems or
less commercial problems the Google of
optimization tools is released under
apache license and has an active support
community out there and I highly
recommend starting with this for most
problems so there's a Google o our tools
like I said it's a suite of tools for
solving these problems and it comes with
a an open source constraint solver so a
tool that we could use to solve
constraint problems will learn
constraint constraint programming like
we did with the Sudoku problem it also
comes with a unified interface for
linear programming and mixed integer
programming and this interface is nice
because you can get the o.r tools built
with any linear programming or mixed
integer programming solvers like Goro B
this just provides the interface for it
and so you can build your code your AI
using this interface starting with one
of the open source optimizers and then
plug in a commercial optimizer later
without having to change any of your
code very powerful feature there and
then it also comes with both a linear
and a mixed integer programming solver
as well as being able to program in
others very very useful for building our
AIS
so how do we go about doing that how do
we solve a linear programming problem in
Google or our tools well the first thing
we have to do is define our decision
variables what we're doing here is we're
building up our model so our decision
variables
the values that are going to be
determined in the case of the pottery
example X and y or X 1 X 2 however you
want to think about it those two values
that we have to solve for we have to
find the values of we have to define our
constraints so we've already seen two
constraints there and those constraints
have to be defined in terms of the
decision variable so we have to build
equations based on those using those
decision variables and then for
optimization problems we can also define
the objective we have to tell the model
here's our equation for our objective
our objective function and whether or
not we're going to minimize or maximize
so here's what it might look like to
create our decision variables so in this
case I've defined XS as the number of
small vases in Excel as the number of
large vases and to program that into the
Google Oh are tools it's just these two
lines of code we use the solvers make
int variable make in var function
defining the lower bound and the upper
bound and max small is the maximum
number of small vases we can make and
then we give it a name that it can use
to describe it to us when it needs to
tell us hey this variable did this it'll
use this name it doesn't have to match
what our variable is at you know in our
code it can it's easier if it does I
think but it doesn't have to we also
don't have to constrain the lower bounds
and the upper bounds of our variables we
could say negative in infinity to
positive infinity it's just good
practice to constrain it whenever as
much as you can whenever you can and
helps the solver out but you could just
say negative infinity to positive
infinity or 0 to positive infinity etc
making sense so far so how do we define
our constraints well let's just look at
that first constraint look at the clay
constraint which as you recall is XS
plus 4 XL is less than our clay supply
there's a little more code involved here
but not that much and this is one place
where the
goro be optimizer I think has a much
cleaner interface for the Google
interface because it has to be more
flexible because it's a generic
interface what they do is they use them
a made constraint method off the solver
to constrain clay to between 0 and the
clay supply and you do have to specify
this this is what's telling it what the
values are constrained to so this is the
less than or equal to 24 here and then
we have to tell it what the equation
looks like and so we do that by setting
the coefficients so we're telling it X s
that variable participates in this
constraint is constraint with a
coefficient of 1 so that's the excess
portion here and Excel participates with
the coefficient of 4 so this is saying
basically this plus for Excel and here's
our less than or equal to the clay
supply and in fact we're in this for
this example we're actually getting
another one for free which we haven't
explicitly specified which is that it
has to be greater than or equal to 0
because negative inventory doesn't make
any sense but we could have specified
negative infinity for here as well if we
chose to okay and we would of course do
the same same exact thing for the glaze
constraint here except the coefficients
instead of being 1 and 4 would be what -
and what was it 1 &amp;amp; 2 cool and then we
set the objective so we define the
variables we've defined the constraints
for our optimization problems we define
the variable the objective and in this
case our objective function is maximized
3 XS + 9 Excel you remember that the
price of the small base is $3 and the
price of the large base is $9 so we want
to maximize the revenue we get out of
that and this code actually looks very
very similar to the defining constraints
we dereference the objective from the
solver there can be only one so all we
have to do is grab that one we set the
coefficient
so three XS plus nine XL and we tell it
we want to maximize at this point we can
tell the solver to go ahead and solve
the problem so we execute the model this
is executing the model right here solver
dot the solve method on the solver is
actually executing the model the next
few lines of code is just checking to
make sure that we got a valid solution
if we didn't in this case I'm just
throwing a an exception
saying hey we didn't find an optimal
solution and then finally we can
retrieve the results now by the way all
of this code is on github the slide at
the end will show you where you can
actually find working versions of all of
these examples for you to go in and play
with and in this case then all I'm doing
is I'm pulling the solution value out
for each of these variables converting
it to an integer and passing it back in
this object so we define the variables
define the constraints set the objective
execute the model and retrieve the
results pretty much everything you're
going to do looks like that cool that's
linear programming in a nutshell so
let's build on top of that linear
programming is really good at solving
linear problems but the world is not a
linear place the world does not always
um you know have these these full range
of values a lot of times things have to
you know things are really more integer
integral I can't sell you one and a half
pots all right
so mixed integer programming is really
good for solving problems where we need
to do discrete would deal with discrete
values for example scheduling and this
is of course Grace Hopper creator of
COBOL among other things really without
her we wouldn't probably be using
machine independent programming
languages
another pioneer another giant in our
field so let's look at scheduling a
conference we're gonna schedule talks
for a very small conference here and so
we have what four time slots three rooms
and ten sessions and we want to figure
out how to schedule these sessions
within those four time slots and three
rooms the first thing I'm going to do is
I'm going to normalize these values so
we're dealing with the IDS of them
rather than we don't care that it's room
125 128 220 or what the actual time
slots are as long as they don't overlap
so we're going to normalize those into
just IDs okay and then we're going to
try and set up a model but we're going
to do this with a two dimensional model
like we did with the linear programming
so if we think of this in terms of each
of these variables here there's twelve
variables here right three rooms four
slots lead these twelve variables that
we could assign sessions to and if we
think about that as each of those
variables holds the ID of the session
that it's that it's assigned to we get a
model that looks like this where our
variables are X sub TR so we have 12
variables 12 decision variables and to
define the constraints for that I've
kind of identified three possible or
three constraints that we need to have
here it's generally going to be more
complicated than that but let's look at
these three constraints each room time
slot combination gonna have no more than
one session well we kind of get that for
free with this model right there's no
variable there's no way to put more than
one value in there each variable can
only hold one value so we're okay with
that one each session must be scheduled
exactly once okay well we can do that
with an all different constraint right
we might have to make a couple of fake
sessions here at the end that have no
value and then say each of those twelve
variables must be all different so we
cannot
one session twice and since there be 12
of them it means every one of them it
for an order for them to be all
different every one of them would have
to be scheduled exactly once okay
so we can define that our constraints
for that here's where we run into
troubles with this kind of model what-if
session 7 &amp;amp; 9 are the same speaker 1
speaker cannot speak at the same time so
how do we describe for this model for
the for the solver how do we describe
that the timeslot for session 7 cannot
be equal to the timeslot for session 9
there's really no way to do that here um
in order to do that we'd have to like
alright find where session 7 is grab the
idea of the slide then compare that to
the idea of the slot for session 9 there
is no find function in an equation you
can't define an equation that says that
does a search there's no way to do it
and there are a lot of constraints like
this that simply cannot be defined in
this type of model where these variables
are integer values instead what we do is
a model with three dimensions or n
dimensions so if we think about this
previous model as n minus 1 because we
have three things room slot and session
and in two dimensions we could think of
this as n dimensions because it's a set
of variables each for room and slot and
so you each each variable has its own
dimension in the problem and so what
we're seeing here is you could think
about this as a sort of a cube where
these tables are stacked one behind each
other okay so this is the set of
variables for session one so that first
table is all about session one and then
behind that is all session two and
behind that all session three so you
have this three dimensional shape which
now contains 120 variables right
ten of those tables for one for each
session and twelve variables for each of
the session and the for each of the room
and timeslot combinations and these
variables only take boolean values
zeroes and ones
now we can describe all of those
constraints so think about that
three-dimensional shape and let's look
at those the constraints again oh so
this is what our variables look like now
so our variable is now X sub T RS so
there's a hundred and twenty of them and
their boolean instead of integer people
they're taking pictures I don't want to
jump ahead too fast all right let's look
at those constraints again each room
time slot combination can have no more
than one session okay so now this one's
a little harder we don't get this for
free anymore but it's still very easily
doable we can sum for each of the room
time and so we're in this case think
about it as taking one of these cells
here and reaching through all ten
sessions you take those ten variables so
for each session that room time slot
combination the sum of those values must
be less than or equal to one we can't
have more than one we can have zero or
one sessions in that room time slot
combination zero or one we can't have
more than one so that sum has to be less
than or equal to one right okay and we
would do that ten times of course we
would do that twelve times one for each
so we would describe that with twelve of
those each session must be scheduled
exactly once
well this one's easier to visualize
because that's each of these tables if
this is the session one table all we
have to do is add up these twelve values
here and expect it to be exactly one if
it's more than one that means we tried
to schedule it twice if it's zero it
means we haven't scheduled it at all so
we can constrain that to
exactly one okay let's go back to our
third one that was that we couldn't do
in the linear model or in the N minus
one model time slot for session 7 does
not equal to time slot for session 9 now
hopefully it's a it's recognizable that
before you go into this before you build
the model you're going to know who your
speakers are so you're going to know
that this session has this speaker this
session has this speaker so these two
have the same speakers you're going to
know which sessions have the same
speaker so you can define session seven
at session nine cannot have the same
timeslot so now we've got to go through
and for each time slot some for each of
those sessions basically we have to sum
for session seven and session nine for
all the rooms we have to say you're
basically taking a timeslot session
seven and adding that sum to the sum for
session 9 so for this timeslot all the
rooms for session seven this timeslot
all the rooms for session nine less than
or equal to one so if they're both in
the same timeslot you're going to get a
two there if neither of them are in that
time so you're going to get a zero and
if only one of them is in that time slot
you're gonna get a one that was a little
complicated I realize it's a little hard
to wrap your brain around that so you
might want to review that kind of thing
later on but that's the kind of thing
you're going to spend a lot of time
doing in these kind of models it's
figuring out ways to describe these
types of constraints it's actually a lot
of fun you're solving a puzzle within
solving your puzzle so that's how we do
the constraints how would we do the
objective well in this case we need to
create a score that improves the
desirability of the solution or what are
some of the things that might improve
the desirability of this solution well
maybe we could
includ tracks and we could reduce the
number of different rooms and attracts
or try and schedule all the tracks in
one you know each track is all in the
same room or reduce the number of
timeslot conflicts between sessions and
attracts so you don't have something in
the same track going on in two places at
once
reduce the no total number of steps
between the sessions of a track now
we're getting interesting reduce the
distance both in time and rooms between
multi-part sessions and in fact maybe
multi-part sessions is another
constraint because if you're doing you
don't want to do part two of a session
before you do part one so we may have to
find a can you know make a constraint
that says part one of that session must
come but earlier in time than part two
and then reducing maybe the number of
different days of speaker speaks or
reducing the number of times in a single
day as speaker speaks those kind of
optimizations we'd have to come up with
an equation for doing that and all of
that is very very doable so here's an
example of one of them maximize the
number of sessions in the same room in a
track where that track is basically
sessions two and four and so what we're
done here is we've actually done the
same kind of sum as we did for the the
speaker constraint picked out for
Session two and session four but then we
multiplied the sums and what happens is
if they're in the same room we're going
to get a one if they're in different
rooms we're going to get a zero and we
want to maximize that as much as we can
so you have all the mathematical
operations at your disposal when you're
working with these kind of models so
what have we done here we've talked
about using artificial intelligence
intelligences or building them in order
to make decisions and we have this
technique the optimization of search
techniques available to us that we can
use to make those kind of decisions that
we can use to build these type of
solutions and these are very efficient
if we're dealing with large solution
spaces so the kinds of problems that we
can solve with them best are those where
there are large solution spaces and also
where we maybe don't have a large corpus
of training data to start off with we're
going to use constraints to prune the
search space linear programming can be
used to optimize linear equations and
mixed integer programming to assign
discrete values to things like
assignment problems you'll run into a
lot of assignment problems here's a
bunch of resources you can contact me
this way these are the code samples this
is where you're going to want to go in
and play if you're interested in dealing
with this you're going to want to go and
grab those repositories there's two of
them there the first one the
optimization repository those are the
three examples that we just went or
three of the examples we just went
through so it's the Sudoku it's the
appetizers example and the pottery the
linear programming for the pottery
example the conference scheduler this is
actually a project my friend Rob
Richardson and I are working on that we
don't spend a lot of time on so when you
look at that repo you won't see a lot of
activity on it but it does have multiple
implementations of solvers to schedule
it so you can see this implementation a
Grobe implementation as well as a sort
of hard-coded naive implementation if
you will to try and solve this cut
problem so there's opportunity there
that's in Rob's github repository I'm on
cognitive inheritance calm that's my
blog and I've written a number of
articles on the space and more will be
coming including some summaries of this
very talk probably broken up into
multiple articles I highly recommend
this course if you're interested in
doing more in the optimization field
this discrete optimization course on
Coursera is tremendous it's actually the
professor is from the University of
Melbourne he's a blast he's also Belgian
so it makes for a very very interesting
he's very excitable - I loved it he was
very passionate about the subject highly
recommended and then these tools at the
bottom are the developer google.com
slash optimization that's where you can
get the Google o our tools and the
documentation for it the documentation
is there it's lacking in some ways and
it's good in others but there are
explainers in there and there is a good
community around it so and they do have
example well they try to have examples
in a c-sharp and sometimes they say
c-sharp when they actually mean C++
which is really interesting there's some
really good information on the Gir OB
website if you're interested in the math
behind a lot of the how the problems are
actually solved they did a fantastic job
of explaining a lot of the details of
how they go about doing the solutions or
finding the solutions and then the list
of optimization software that I
mentioned earlier is there cool so it
looks like we've got about 6 minutes
left are there any questions anything I
can talk to your help
you were going through this scheduling
problem there and you were charged and
like all constraints like the track one
and stuff like that instead of adding
more dimensions to the set of data
matrices themselves
you chose to define them as constraints
focusing on some of the frames that make
sense so you had you know slots birds
right right well if you can reduce the
price so the question was why didn't I
add tracks as a variable within the the
solution for scheduling a conference and
basically comes down to you I wouldn't
necessarily add a variable if I didn't
have to so if I can define it in terms
of variables that already exist I'm
going to do that generally you can so
there's some really interesting things
you can do like sometimes it actually
benefits you to have both types of
models and actually just define
constraints in both ways and you can do
that you can actually have both models
in memory at once you use one as the
primary and then can set constraints on
the other one that basically drive it to
match in terms of that model what the
first model is and then you can send
additional constraints on that model so
that can be really interesting but and
but really complicated at that point it
can get really hard to follow but yeah
if I'd be interested in I hadn't thought
about it in those terms because I
generally will always automatically
default to just defining it in terms of
variables I already have if I can but I
wouldn't mind play maybe I'll play with
that on the on the plane on the way home
see how it works out other questions yes
okay so I can't speak to specifics for
you know NDA reasons but I can tell you
I have an article on cognitive
inheritance see let's go to the AI
so this one AI that can explain why I'm
really talking about Oh interesting
sorry hey so this article is AI that can
explain why and it uses an example of
like of an iterative process so it's
it's sort of a hybrid AI solution where
it mixes a combinatorial solution with
an iterative process so that you get a a
process where you can define you can
hold the state of things so you use this
to when you find you when you reach a
solution to a problem or you can't get a
particular solution that you want you
can record the state of the model at
that moment so you can explain why it
why it doesn't why you can't do what you
wanted to do and in doing that here's an
example of the type of problem that I'm
actually solving with that where it's an
employee assignment problem okay so
employee schedules and you've got these
three pieces you have the legality of it
you know what are you know the legal
rules well behind whether the employer
you know when how often they or how long
the employee can work for versus
employees desired schedules versus what
the company needs you know what the how
you know levels of coverage and such and
how those come together in an in a
solution so that's described a little
more in a little more detail there
that's a very very common problem other
problems you'll see our machine
allocation problems they're they're
referred to as knapsack problems where
you've got a certain amount of space and
certain you're like this machine has
this capacity this machine is this
capacity how can I maximize the you know
capacitor or maximize the revenue or the
profit I get
by utilizing those machines did that
answer the question
gentleman behind you yes
yeah
yeah and that was the part that bugged
me about so you're talking about the
Microsoft saw solver foundation I
believe it's called and the I did play
with that a little bit when it came out
but it actually uses Grobe under the
covers which is the proprietary solution
that I was talking about and ultimately
what put me off of it was I didn't have
something that I could just get two
people for free and a lot of the
software I try to build is I tried to
build open-source I try to build things
like the conference schedule is intended
to be for like code camps and those kind
of small conferences so I try to make it
so that they don't have to pay for
something like that
so I haven't seen indicate any
indication of it falling off I mean
there's not a lot of new commits in the
areas of the project that I'm working on
but as far as I know it's here to stay
it's not anything that they've said
we're deprecating this or we're not
using it they use it in a lot of their a
lot of their tooling
so it is difficult to get information
out of these kinds of models I mean you
have to basically define the model I I
think I think what you're asking me is
is there ways for me to get more
information out of the model to help a
an expert a domain expert make me so we
kind of use this towards more decision
support systems as opposed to artificial
intelligences and certainly you can
build the models in ways that provide
that kind of information to the users
but you have to program it for that I
mean it's most of the time what it's
about and you know you saw this article
here about you know using a hybrid
system to give you more information most
models are basically a fire-and-forget
type a that's you you throw the data at
it it solves the problem and it tells
you what the answer is but you really
have very little information as to why
it got that answer so if you want more
details than that you have to do
something like this some kind of
iterative process where you're
snapshotting the information at points
in time other questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>