<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Feature Branches And Toggles In A Post-GitHub World - Sam Newman | Coder Coacher - Coaching Coders</title><meta content="Feature Branches And Toggles In A Post-GitHub World - Sam Newman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Feature Branches And Toggles In A Post-GitHub World - Sam Newman</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7qTOdbUAqno" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay well thanks for coming along this
is a bit of a dry title I'm hoping the
topic won't be dry some I'm actually
impressed it got people to turn up I
either that we were here for a nice nap
either way I'll try and keep the noise
down the face of how much for coming
along my name is Sam Newman I am an
independent consultant now I have a
company called Sam human associates
because of egocentric and therefore like
naming things after myself so anyway if
you ought to know more about what I do
you can come talk to me later I also
wrote a book a couple years ago called
building micro services which you may or
may not have written read if you like
learning about micro services it might
be the book for you this topic is not
about micro services it is actually
really in some ways about my first sort
of love and passion really which is
helping people get software into
production quickly that was my focus for
many many years and actually that led me
to look into micro service architectures
as a way of making it easier to create
loosely coupled architectures loosely
coupled architectures being something
which are much easier to ship into
production more quickly I want to take
you back in time actually to give you a
bit of a bit of a history lesson really
to explain my journey into the world of
continuous integration and continuous
delivery what we're going to be doing in
this talk is recapping a number of sort
of central tenants around CI and CD
looking into things like feature
branching and feature toggles and
re-examining them in the context of the
emergence of git and github a new types
of development practices that we now
have and and really trying to think okay
do the does the advice that we gave you
know back in 2005 around these sorts of
things we stack up in the new world
based on what we know now and based on
how we develop software now if I will
this destroy does start in at least for
me in 2004 and I just started as a
pimply-faced youth at ThoughtWorks
and I may said okay so of my first day
at work and they said okay you're going
to go to this platform at useful station
and between the fourth and fifth pillar
there will be some people standing
around and they'll look like you're
going to be working with them and you'll
just have to work it out based on what
they look like and I think it spoke
volumes about the lack of diversity in
the team at the time which was very easy
to walk and up
that platform is the exactly what I was
going to working with but nonetheless I
would get on the platform and we travel
all the way up to where the client site
was in a place called Hamel Hempstead if
you've been to hemel hempstead you'll
know very little about it really this is
quite an anonymous place so we get on
the train and train all the way up and
we'd have dreams on the way to him or
about maybe if we just stayed on a few
more stops we could just get off at
Bletchley Park and no one would notice
so wandering gang a look at some enigma
machines as ensuring brahms we never did
it though because we were dedicated
professionals and also because you know
often the train stops at Hema Hazzard
anyway I arrived at a project it was a
very large project that thought the time
was running primary during the
development in the United Kingdom but
also with support from people in Canada
and India as well and it was a project
for one of Europe's largest retailers
and it was sort of a sort of a rescue
project in a way which was this company
had engaged another supplier to create a
brand new electronic point-of-sale
system and that electric point-of-sale
system was late and so they said oh it's
very very late they got with a once
appliance had come in and fix it and so
we turned up and it was I think it was
an 18-month project originally when they
started it and they were 18 months in
and they'll still 18 months away from
delivering and I think everyone could do
the maths and work out that's not going
in the right direction so it was sort of
coming it was all hands to the pump and
we've got to fix stuff because it makes
us happen and it's been going on for
probably about a year or two I think
before I got there and so I arrived in
an interesting juncture in the in a life
cycle of this project if this a week
later had multiple different stores
different branches different types of
chains a different brand underneath the
overall banner so they've been slowly
rolling out this new point-of-sale
system to different stores and
effectively cutting new releases to
represent each store roll out a new set
of features these releases are almost
like a milestone so a collection of
things and so we had most of development
had been done up to this point was being
done on the r3 branch of code and so
this was the kind of new cutting-edge
features we're working on this is like a
a mix of the monolithic server back-end
than
and a swing based front-end she will
give it to the appellant in sales
point-of-sale systems and running in
fact they still run the same
point-of-sale systems to this day and so
the bulk of the organization at this
point the bulk of the delivery
organization was working and making
changes on this sort of our three branch
of code and this is the current release
and they're actually putting out
multiple deployments from that branch it
wasn't like you know they only do one
release so we're actually releasing
fairly frequently from that main branch
of code now as I mentioned this project
initially had started off in a bit of a
hurry as in we need to get something out
and so as is always the case when you
have to make compromises between doing
things the right way and actually you
know actually having software that works
and being used in production you
sometimes have to make a few compromises
and compromises had indeed being made
and around the time of the our three
branch of code when those releases were
getting out the team of getting in a
breathing space I've give you an idea at
this point you had about sixty
developers working across multiple teams
on this project and that you know things
were fairly stable and things were
getting out nicely the the core feature
set was was being used quite widely now
and you thought okay well this is a
great opportunity to sort of clean up a
few things that we've done that we knew
was shortcuts but also we'd learnt a lot
about how to build a system well and we
wanted to make some architectural
changes and also there were things like
you know we had two or three different
ways of achieving a certain goal like
persistence for example it's being done
in multiple different ways and I thought
actually that's we could unify that as
well so what happened was that we the
senior was made to actually have a small
team go and start looking at making
these targeted changes but some of these
changes were going to be quite
disruptive and so they did what we would
traditionally do on this page if this is
part of the software development
lifecycle which is we created a branch
and so that small team went off and
started making these refactorings and
these changes on a separate branch of
code which is called r4 and the idea was
at a certain time when they were ready
r4 would become the brand new release
branch would be the version of the code
that starts running in all these stores
and so changes are still being made by
the bulk of the team which stayed
working on r3 and they were delivering
customer-facing
reaches out to production The Artful
branch of code was a refactoring branch
where new abstractions are being created
new ways of working it was a lovely
lovely lovely clear clean codebase at
this point because I've been selling so
much we factoring and then they said
well okay we think we're a good place
now we think this can now become the
brand new release branch this is should
be now be promoted to being what we
release our code from and of course at
this point we had to do what we always
have to do at this point which is now
merge all the features that have been
worked on in r3 over onto the brand-new
r4 release branch and of course that
went really really well as you can
imagine there were definitely absolutely
no problems whatsoever and it was a
completely painless process and nobody
died actually no one did die but at some
days it was pretty bad so it took a
while to get the code to compile a few
days I think it was but then you had
this whole process of just like the
textual merging of like what that they
renamed things and those things have
moved around that took a long time
carrying out that initial merge and then
we started realizing that even though we
thought we'd done the merges that we'd
introduce a whole load of bugs and
defects we'd introduce regressions and
features we thought have been cleanly
merged over it actually being sort of
regressed and haven't actually been
properly merged at all they weren't
working properly with introduced
brand-new bugs because of just crashes
and functionality and so it was decided
to create a team to target fixes are in
this area hence the creation of the r3
r4 merge bug fix team doesn't just get
your pulse racing when you'd arrive on
site and your first day and you've
learned all this stuff that's amazing
companies great people that work there
and how much awesome technology there
and so it's Martin Fowler's company and
he does loads of great stuff and then
you turn up and say hi Sam you're going
to be working in the r3 r4 merge bug 16
and it does he was did exactly what it
said in the tin I mean my initial
reaction was obvious you yet well thank
you I wasn't at all annoyed I learned a
lot to be fair
hence kind of almost at kick started at
that next phase of my career because I
got to relive through the experiences of
what not to do and deal with the
aftermath of that
I will say that there was a bit of a
postscript many years later I was I
lived in London and many years later I
was woken up in the dead of night my bed
was shaking and it turned out there'd
been an explosion and an oil refinery
next to the site where we'd been working
in Hemel Hempstead luckily no one died
that was even injured amazingly but I do
sort of like to feel that this was sort
of some some sort of deferred explosion
as a result of that merge of code it
would have been much more poetic if it
happened on the day we did the merge so
there's a lot of things that came out of
that experience not just for me but for
many others and the seeds of of the
continuous delivery movement started on
that project
Dave Farley who was the author one of
the authors of the continuous delivery
book in fact was the architect on that
project and of course at this point many
people be saying that that's them when
you're aren't weren't you doing
continuous integration weren't you
actually continually integrating your
code and validating that code works to
get enough how we reduce merge pain so
just a brief recap of what continued
integration is I think actually as it
turns up here who is doing continuous
integration but hands up high I think
most people claim to be doing continuous
integration so I'm going to recap it
those two make sure on the same page
it's really a very simple process and
it's a mechanism by which you make sure
that the code that you've committed
works with a code that's all you there
you integrate that code together you
validate it so you know your work on
your laptop on your desktop machine we
work on laptops back then it was well
that embarrassing moment when the the
retailers offices were burgled and
everybody's laptops are stolen apart
from our laptops and like even burglars
decided not to take Toshiba Tekla
laptops it was sort of the size of small
planets that you'd carry around anyway
so if you're working away on these sort
of Titanic sized laptops that just being
powered and you check your code in and
you know that these dated if it was not
get it was not even subversion back then
it was something a lot worse I won't
name because I think the vendors did
exist and they might get angry so you
check the code in to the source code
repository and in some kind of
continuous integration tool detects that
change so it could be a polling train
too it could be a post commit trigger
and so okay well the kickoff and
integration process and I'm they tell
you whether or not you
integration has worked so starting off
with the basic stuff like does it
compile people do think that's a bit
silly does it compile believe it or not
I spent a good five years helping roll
out continuous integration to many
companies across Europe and that was
often a huge improvement in their
consultative Affairs making sure that
the code actually all compiled together
anyway we've got better now of course we
talk about different test Suites and
those of you at the previous talk would
have learnt they have how far testing
has become has come since then so you
know this is the process of continuous
integration there are some rules about
what continuous integration is this is
where things get interesting and people
get quite cross because they say that's
not continuous integration and actually
this yes it is this is what continuous
integration is all about right you check
your new change and you get it validated
very straightforward something else
checks and some code they get their
change validated validation of the
integration is key compilation running
some tests you have to have a suite that
validates your integration otherwise
you're not doing continuous integration
when the build breaks when you check in
a change that breaks your build it
should be the number one priority the
team to fix that build you want to keep
your builds green normally that means
that the guilty party who checked in the
change has to go and fix it
that's normally the rule which also
leads to Platon to behaviour like nobody
checks in after four o'clock on a Friday
because everybody wants to go home the
brave soul indeed who decide to check in
at four o'clock on a Friday so in the
build breaks it's your job to fix it and
normally what you would do is stop the
line and stop anybody else checking into
that change can be made freely the other
thing and this is where things get kind
of interesting this is the rule the
other rule of continuous integration
that most people forget is that you
check in daily if you take a long time
between integrations and you decide oh
I've been making these changes locally
for days and days and weeks now as an
exercise check it in we have a huge
merge problem you're likely going to
break the build and annoy everybody
continuous integration state extremely
clearly that you check in daily now I'm
not saying that if you don't check in
daily you're a bad person although it
work for you or isn't successful it
that's fine it may well work perfectly
well for you it's not continuous
integration just being very clear so I
want be talking about what continuous
integration is this is what it is right
integrating your changes daily and
validating that they work so we want to
check in frequently because we reduce
the merge pain we reduce the chances of
conflict reduce the chances of problems
we break that most pain up and so of
course when we talk about the r3 r4
merge bug fix team the question I had
was will weren't be checking in together
weren't we integrating our changes
making sure they worked and the answer
was we were kinder were doing what was
quite common which was actually running
ci builds on branches of code so we had
the bulk of the organization who were
working on the r3 code and they had a
build on the r3 branch and they were
checking in their changes and those
changes were being validated and they
were getting feedback that yes their
changes works likewise the r4 team were
checking in their changes on the branch
of code validating that the smv they did
work the issue of course is this
integration was localized to those
branches of code the code wasn't
actually being integrated together what
that meant was that when we decided to
move the functionality from the r3
branch over to the r4 branch to make
that now than live release branch we had
a giant pain the reason ultimately that
this branching this merging wasn't
happening more frequently was because
not only were the cost of branches quite
high and so you have long-lived branches
but also the difficulty in complexity of
merges was quite was quite high and we
fell into this nasty pattern which is
all branches of nasty merging is really
difficult
let's not merge a lot we might as well
bundle up all the pain and defer it
because then future Sam can deal with it
and future Sam did indeed have to deal
with it over many many many months this
idea of integrating once a day which is
very strong in continuous integration
wasn't really what we were doing we were
integrating locally into those local
branches and so we you know we had this
problem now the reason of course that we
were just making these changes on the
ass for code bases of refactoring
straight on to the release branch of
code is because these changes often
require multiple separate steps
you are checking in work that was sort
of half-finished so what we don't want
to do so I'm working on a piece of code
a piece of functionality it's going to
take me several days to complete I don't
want to just leave it lying around on my
laptop which is the option that aren't
certainly reads used to live by where
I'm just going to wait to check my
coding now of course if I wait to check
my coding I'm deferring that integration
effort I'm also running the risk that my
think might happened to my laptop like
it getting stolen
I lose my source codes we want to put it
somewhere safe so I don't kind of wait
to check in my half-finished refactoring
or my introduction of a brand-new piece
of functionality that's only half ready
to go live to my customers and so really
waiting to check something in doesn't
really make sense so let me look at the
other option and effectively what
happened with r4 just in a big way which
is what we're going to do instead is
we're going to make a branch of code
we're going to make our changes locally
on that branch of code making those
changes safely because they're not
actually being going to be released
until we've completed that process and
then once we have completed that process
we then merge that code back into the
release branch or promote the branch or
work on to being released France which
is the technique used at the retailer
this is a classic release branch
mentality so I've got maybe trunk or
whatever my release branch is going to
be called might be called master
depending on your version control tool
of choice and you start working on the
future and so what you do is you you
branch the code you fought the code and
you start making your changes locally
probably a branch named after the
feature so do this work for a few days
and one of your colleagues starts doing
the same thing they make their fork of
the code they start making their changes
locally and when they're finished you
merge your features back in back into
trunk and at this point it's probably
okay right because I've been making my
changes not much is shifted since I took
my feature branch change and I checked
it in I've checked in a few you know
noodle refactorings I've cleaned up some
code I've renamed a few things make it
easier to understand and then my
colleague comes to check they're
changing it's only a whole other stuff
has changed in trunk I've now got to
actually check all of my stuff in and
it's a much more painful process because
I'm now having to deal with that large
Delta of change that comes from the
other
a branch being merged in and this often
leads to nice interesting social
patterns of behavior like you know
you've got a nasty check into you wanna
push that you know is going to make it
really awkward for other people to merge
in but you want to get your change in
first so you have the easier time of it
and you distract people you say oh look
over there you could check in the code
I do remember on one occasion actually
distracting one of my colleagues and
trying to enter their password three
times on their lock screen because when
you did that it actually locked the
laptop because they thought it was being
attacked by some malicious party you had
to go in contact with just admin to get
your machine unlocked and for me and my
pair did that and sort of just lock the
machine for them they couldn't get back
in what we could get are changing right
this is just all to make I like this
it's not great stuff but it kind of what
had us to go to the pub they weren't so
happy about it now of course you can
actually again make these things these
processes a bit easier I mean one of the
things that you can do for example is
you can run CI you can use it tools like
go for example make it very easy for you
to run a CI build on your branches and
you can actually configure these tools
now that when they detect a branch it'll
automatically run the build on them so
at least locally for your feature branch
you're getting validation that your
changes are working you can eat also of
course pull changes from your trunk or
master on to your feature branch to also
make things a bit easier for that final
merge you picked up any other changes
that have been made you can do a bit of
a merge effort every day the issue of
course if it doesn't avoid the problem
like this even if I'm rebasing from
master the other feature branches that
gets checked in ahead of me there's
going to be as large change sitting
there waiting for me once I do that
final call ultimately in this process we
are deferring integrations what we're
doing we're doing local integration on
our own branches but we are deferring
integrating all those things together
now ultimately I think what I learn like
my lessons learnt from the from the
retailer back in 2004 was that a lot of
the pain that comes down to these merge
activities these integration activities
come down to the not the size of the
change and how long it's been since you
lasted your merge there's some sort of
function in there I think I'm working on
which is like you know you almost need a
pain Amish
for your branch that's telling you
although this is getting pretty although
there's been a lot of changes right now
you're approaching danger zone territory
right now you better get your stuff
moves back in otherwise you're going to
be in a lot of trouble so that this not
just the size of the change not to the
Delta between what you've got on what is
on the trunk you're going to merge with
there's also been how long since you
last did emerge as well just because
it's quite hard to understand the
changes that have been made you've lost
context a lot of the time to understand
what the right thing is to do because
ultimately the longer you go between
merges it's less likely your changes
going to be purely textual in nature
you're actually looking at semantic
changes in functionality in the
structure of your code base but you
really need to understand and grow to be
able to carry out an adequate merge and
this is the other problem really that
comes with branches especially branches
that are longer lived refactorings are
very hard to merge so some source code
tools like git can do an okay job
picking for very simple I think my beers
too big as can people still here at the
back okay am i coming out over the mic
the PA okay all right
so merging and managing refactorings on
branches can be quite challenging the
reason is if I do something simple like
a rename I just change the name of a
file change name of a class most modern
self control tools can do a fairly good
job of saying this is probably the same
thing I can pre handle that merge for
you but think of the other kinds of
refactorings you might do not removing
duplication creating brand new
abstractions moving code into new
modules and new packages the more
aggressive your refactoring are the
harder it's going to be to merge well
its lead to is organizations that
practice branches that live for long
periods of time tend to not do much
refactoring because refactoring is
really hard to merge and so you don't do
the refactoring on the feature branches
because it's just going to make your
life more difficult when you come to do
the merge and so the longer the branches
live on your codebase you'll find
merging in refactor that managing the
refactorings are less like to happen
because of the merge pain the other
option
you've got so I'm just avoiding checking
in
rather than maybe making feature
branches if you have to check in your
half-baked changes anyway right this is
it just we just go check it in no we're
not another feature branch the codes not
finished yet but we're checking it in
anyway and it's all going to be fine
which of course makes absolutely no
sense because by definition your changes
are half-baked and they are not finished
yet and they're not fit for purpose so
how can we just check them into the same
branch of code or the same trunk without
causing problems in our release cycle
this is actually effective a technique
called trunk based development and the
mantra behind trunk based development is
that everybody checks in to trunk some
of the main ideas from continuous
delivery so rather than putting on
branches of code we all check in to the
same trunk so it's a very simple
approach in a way I'm checking changes
in every day maybe like once a day at
least it's what I'm looking for like
things with continuous integration and
the idea is is that you're breaking up
your merge pane you're making lots of
very very small tiny merges where needed
when you're putting changes from other
people and you're breaking up that pane
and integrating your code very very
often into the same trunk so integrating
often you're getting very very fast
feedback on the quality of your
integration you're deferring that
integration and that merged plane is
significantly reduced I often think I
don't think a big merge is a sum of a
lot of little merges I think you know
it's actually worse than that I think
the multiplication of a lot of little
merges of course this doesn't really
help explain what we do about
half-finished features you know I'm
halfway through making a change in some
piece of functionality and I can't
clearly release that out to my to my
customers so trunk based development
goes hand-in-hand with what feat what
are called feature toggles or sometimes
called feature Flags what we do with
feature toggles our feature Flags I'll
call them feature toggles for the rest
of this talk is that we hide
half-finished functionality behind these
toggles until we check in the code it's
integrated in the branch but effective
use a toggle to me it's not in a live
code path so it's a very simplistic
example I've got a web page here and I'm
working on some lovely brand-new widget
so I'm working fact on a thing called
the super budget and what I do is I have
a flag in the example in the
configuration file now once my widget is
ready to be released I change the value
in a configuration file and my widget
appears having the ability to toggle
these things off and on means that what
you can do in say your test environment
is turn your toggles on and actually
test the partially implemented
functionality the code itself is
actually live inside your code base you
can still run subcutaneous tests against
that functionality but it's not exposed
to the users in lots of other ways of
specifying toggles you can do it the
configuration flag like this you can do
it with a fire with a flag on the
command line this is how Google do their
flag system and you can also even use
sort of centralized systems to manage
the value of your flags and that might
allow you to toggle those values off and
on so people have been using things like
zookeeper and console to actually store
the value of your Flags allowing your
applications to that having turn things
off and on in production so that's kind
of nice when you've got a public-facing
change and it's a brand new piece of
functionality it's actually quite easy
to get a sense of how you hide a piece
of brand new functionality that's half
implemented a new widget on a page is
actually really easy thing to get your
head around likewise a new page in your
website it's just not something you wire
into your main information architecture
it's not visible to people but what if
it's actually a change in an existing
piece of functionality so there's some
functionality is already there a brand
new implementation of it that changes it
quite fundamentally but you can't get
rid of the old code right now because
it's actually still being used it still
actively being used I mentioned a tool
called OCD earlier and actually got a
great example of how you can make this
work from the deep dark history of go
so go is a comma is a sort of deployable
as a locally deployed CI NCD server it's
been around for many years it started
off as a product called crews are very
early on it's changed a lot as you'd
expect any product to change over many
years six years ago they've made
decision to migrate how they were
handling persistence migrate it from us
a tool called I batted over to using
hibernate the reason for this change was
that I batted requires to the pound
crafted sequel queries that would be
coming hard to maintain and they wanted
to replace their persistent system with
a brand new position system which is
hibernate to allow them to talk
different databases and also support
different databases their clients and so
in the existing system right now that
the hibernate the I batiste persistence
layer was sort of very deeply integrated
in the rest of the product because lots
of things need to cut stuff into a
database and get it back out again and
so we need to sort of start working and
incrementally changing over this
persistence layer the issue of course
though is that that this is a product
that people are using sort of SAS based
product but nonetheless go with shipping
features at brand new versions of go to
their castles every two weeks and in
fact I think now it's everyday so you go
to the website and you could download a
new build every single two weeks this
change was not going to take two week is
going to take probably several months so
you don't want to put it off on a branch
for a month you'll be checking this
changing incrementally so how do you
make that work we are still trying to
cut new builds or software but also have
to work the pattern used here is
something called branch by abstraction
and the idea is that rather than saying
okay I want to check in a different
version of my code on a branch and then
merge that in I'm actually an effective
checking a new implementation of some
piece of code into trunk and hide it
using an abstraction and toggle between
the two different permutations so they
created they started creating
effectively the skeleton of what the new
hibernate persistence was going to be
and then created an abstraction layer
and so you had to move all those calls
from the existing direct calls into the
I batted assistance layer and now
they're talking to that abstraction
layer that abstraction layer then routes
all the traffic through to your existing
I batis layer and what you could do is
you could turn that you could configure
that abstraction with a configuration
value and flick that flag off and on to
switch previewing persisting your
information in I batis to switching over
to hibernate now obviously this hydrate
that didn't work for weeks they were
implementing effectively method by
method going along implementing those
make new methods a users new
participants layer and so they had the
flag you
SiC that on but it was a deep hidden
flag that only has been used by the
development team of the testing and so
as they migrated certain slices of
functionality over to using the new
persistence layer what they could do is
flick that flag on in a test environment
run tests against it make sure that that
stream of functionality works a new
persistence layer but for the public
that flag was fixed off once the
migration had occurred and this was done
over many many months because they were
what they were doing as a sensible thing
with their making an architectural
change like this while still shipping
features now like chipping away at it
every new story they did their chip a
little way a bit a bit a little bit
further away I like this idea I think
Big Bang rewrites are just making small
incremental changes to your software and
so when they're already and they
migrated it over I could get rid of the
old code and also get rid of the flag as
well so some the key thing one of the
big mistakes people use with feature
toggles and feature flags is they keep
them lying around for a long period of
time
when you don't need the flag anymore get
rid of them so this is a nice way it's a
nice alternative to feature branching
rather than having to branch out new
alternative implementations of existing
functionality and then merge them back
in when you're done you effectively
could get create a new abstraction that
allows you to have a new implementation
of that functionality side by side and
when you're ready switch it over
that's branch by abstraction pattern
means you size depth the need for
feature branching so that mentioned with
flags there are some rules use it in as
few places as possible normally one is a
good number of places to use a flagging
and two is getting iffy for me the more
places you use a flag the more
complicated is going to be for you to
reason about what the behavior of that
flag is going to be and do remove those
flags once you're done I did work with
one client who had over 300 flags that
were different in their production
environment in their QA environment and
they had never removed those flags and
it became kind of impossible to
understand which Flags are actually in
active usage it was also impossible to
understand the differences in behavior
between those two versions of code with
monolithic systems you may have a few
more flags than you'd like with a
Microsoft based architecture you'll
probably end up with fewer flags because
often you can control release of
functionality to your customers just by
not shipping it
in the first place it also keeps number
of flags per service down to sort of a
minimum size but with a more distributed
architecture like that you're more
likely going to need some kind of system
to help you manage those flags we'll
talk about that in a moment
there are some nice benefits to creating
these abstractions that allow for
functionality to be toggled off and on
the first is that these same this same
sort of technical capability can get
reused for things like AV testing so
they be testing with the normally doing
is you're diverting a certain part of
your traffic to one version of
functionality and a different set of
your traffic to a different version of
functionality this could allow you to
test different treatments for example so
this would actually be one way of
potentially seeing if the new
implementation of some some piece of
functionality was actually better for
your customers and previously and then
if it was then you could effectively
remove that flag and turn it on for
everybody and also with a bit more work
on top you could also use this sort of
mechanism for something like canary
releasing although that tends to apply a
bit more work but ultimately the
abstraction points around that can help
for things like canary releases if you
want to know more about the ideas behind
trunk based development and branch by
abstraction and feature toggles an old
colleague of mine Paul Hammond and
started putting together a whole lot of
interesting resources over trunk based
development comm and so if you want to
take a look at that that might give you
not a few guys pointers now emerging
from the ruins of the retailer project
which actually went very very well I
must say the client was very happy to
suffer got shipped nonstop fired no one
died but a lot of lessons were learned
and many of those lessons ended up in
the continuous delivery book which the
wisp and Joe started working on in I
think 2007 2008 but was finally
published actually in 2011 and it talked
in that book a lot about reducing the
use of branches limiting long live
branches because it's integration plane
and promoted this idea of trunk based
development as an alternative to feature
branching we've been motivated by the
idea of continually integrating code to
reduce merge plane acts you also be able
to ship functionality more quickly to
your cut to your customers the other
ideas that came out from this book in
2000 there was things like cheating
every check-in as a release candidate
which in many ways is
the sort of main idea in the continuous
delivery book rather than this idea I'm
gonna checking some code and then later
on I'm going to validate whether or not
that codes good enough and then maybe
we'll do some more Terry picks to make
it work and then we'll ship it
now it's sort of shifting things much
more onto the hands of the developers to
say no no you don't get to abdicate
responsibility you have to be confident
that every checking you make could be
released into a production environment
and there's a bunch of stuff in the book
to explain how you do that another idea
that comes out of crock in this book is
about reducing the size of changes and
increasing the frequency of deployment
and this this idea and the reasons
behind this idea I put put out quite
well by John Osborne
he basically his lovely presentation
about metrics in the ops space and then
explains really nicely in two slides why
continuous delivery is such a good idea
the idea is like this if you take a long
time between releases of software you
have more changes more changes build up
and to the Delta between one release and
another larger and therefore you
increase the risk that you're going to
introduce a problem it's more chance
that you're going to screw something up
if you've made a lot more changes and so
if you do check them in and you have
made a mistake and you've broken
something because of the large Delta
you've also got a lot of functionality
to look at understand what it is you've
broken and any ability to fix that
release is made more it's made more
difficult because working out what's
broken is harder so working out what you
can patch or rollback is more
complicated
so the releases themselves are more
fraught you're more likely to break
something if you break something it's
going to be harder to to fix and how are
they to rollback what happens when we
have these long release cycles is we do
things like this we say well you know
this series is quite risky and the last
release we did didn't work out so well
so what we can do this time around is
we're going to be extra specially
careful we're going to be really taking
our time over this next week and get it
right we're going to put a few more
procedures in place a lot more sign-off
to make sure we don't can't possibly
make a mistake and what happens is the
next release takes you even longer to
get out the door because it's new
procedures you put in place to eliminate
the possibility you've made a mistake
and that release of course because it
takes much longer has even more changes
in it and when you release it lo and
behold
look it's broken as well and it's a
whole lot of problems with it so what
we're going to do this time is going to
be different we're definitely going to
get it right this time let's put some
more procedures in place let's put some
more sign-off in place and it's going to
be wonderful and it's going to be
absolutely fine and of course this this
sort of vicious cycle continues a lot of
the work I do about sort of helping
customers ship software more quickly
into a production system comes down to
looking through their release processes
and it's more it's sort of like looking
at organizational scar-tissue right so
there's the procedures that are put in
place because of something bad that
happen about ten years ago that no one
can quite remember and sighing so
there's been the release process where
you seem to like H a pentagram in the
floor with chalk and slaughter a chicken
and say these words I mean does that I
mean is that really necessary well it's
what we've been doing for many years and
it hasn't done us any wrong and it's
like okay great all right breaking out
of this cycle is really hard but
actually something you need to do
because ultimately if you ship software
more quickly and more frequently to your
customers here's what happens each
individual release is smaller in scope
therefore you are less likely to screw
it up and if their problem does occur
it's much easier for you to work out
what it is you broke and it's going to
be much easier for you to roll that
change back or roll it forward by fixing
it it also means your shipping
functionality to your customers more
quickly therefore getting feedback as to
whether not the features actually do
what you want them to do you also have a
release process that you're using more
frequently therefore that release
process is more like to work because
it's being used over and over again and
it's tried and tested so this idea of
decreasing the size and scope of each
release releasing functionality more
quickly to your customers is actually
about reducing the risk of releases it's
actually about being safer there is a
sort of idea that comes up spouted that
you can either go fast and break stuff
or go slow and steady and beat and make
not break stuff and it's absolute
rubbish those organizations that ship
software we quickly do so only because
they have really reliable rigorous
release processes that allow them to
ship software in a safe fashion
releasing more quickly actually can help
you have a more robust release process
you can go fast and safe and this idea
that you have to choose
is absolute rubbish other ideas
integrate often keep those batch changes
small keep those check-in small and ship
your software frequently all these ideas
coming out the continuous delivery book
in many ways what happened in that whole
period of time was we took a lot of the
practices or coming out of enterprise
delivery that were coming out from the
EXPEED movement lots of unit testing
automated testing practices continuous
integration and bringing those but that
those sort of practices had given us
sort of higher quality more certainty
more visibility into the quality of our
software but really you know we weren't
actually necessarily delivering our
software more frequently to our
customers to our users you'd ask people
how often they release their software
back and say 2006 so every six months is
good right how many people here release
their software every month or more
frequently right how many people here
they released their software more what
once a week or more frequently great if
I'd asked that question 10 years ago
people would have thought I was talking
crazy what happened was these ideas came
out that gave us visibility into the
quality of our software but we weren't
quite fixing that last mile problem and
then you had all the dot-com people
coming out shipping software like Flickr
were 15 times a day and these ideas that
have came together and gave us what the
continuous delivery movement is all
about really which was saying okay let's
bring together these practices about
visibility of the quality of our
software buried that together with fast
and frequent delivery and overall
everything gets better so while this
whole thing was happening and we were
automating build pipelines and you know
measuring cycle time and helping people
ship their software more quickly this
little thing called get emerged I guess
actually been around obviously for quite
a while but we should probably
understand a little bit and the number
of people think that get shifts the
equation in terms of how we develop
software we should know remember the
history of why get exists so get exists
because there's a falling out around
licensing for the disputed version
control tool being used by Linus and the
Linux kernel administrators so Linus
decides to write his own and that's what
get is to rewrite other implementation
of a distributed version control tool to
to Linus and how the Linux kernel is
developed and the main goal in creating
get was to allow Linus to merge a patch
in less than three seconds that was it
that was the goal the whole architecture
of get is actually predicated on the
requirements primarily of the Linux
kernel the little kernel is not one
thing it's not one deployable you have
the idea of the next project but
multiple different vendors build their
own kernels and there's lots of ideas
you're moving patches around you're
applying your own patches and this is a
fundamentally different sort of delivery
process than most of us use but most of
us now use git which is a version
control tool designed for a different
way of working there are some lovely
things and get though right firstly
branches are significantly more
lightweight one of the problems with the
the retailer I mentioned the beginning
was that we only had we'd only we
couldn't afford to make lots of branches
and so we had that r4 branch that we
returned a lot of things on we would
have been much better off if we could
have created more short-lived branches
that there's a control tool we're using
branches are very very expensive so
worth remembering the something like
subversion for example when you branch
code that's a copy of the code that's
being stored us a lot of work so
branching is not something you didn't
likely we'd get it's it's really simple
right it's such a lightweight operation
that the creation and management of
branches is much easier to work with you
have other nice things that you have a
full course or false copy of source
history in your local laptop which I was
like where I'm developing on planes and
in trains with poor connectivity and
also we have significantly better
merging of text which has made merging
code easier certainly much better and
get than it was in subversion the key
thing to understand of course is that
git has got quite got better at textual
merging identifying this thing is
probably the same as this thing this is
probably a rename this is probably a
move I can kind of work out that block
where that goes but what it can't merge
semantics it can't understand the intent
behind a changes made by somebody else
and apply that intent on your code there
are no operational transforms yet in our
source control tools like there are for
our sort of document sharing tools there
are people working on things like
this people who are actually building
whole IDs and source control tools that
actually implement the understanding of
intent these systems actually require
you affect you to hook your refactoring
tool into your source control tools you
actually said I've done a refactoring
you actually store the refactoring not
the output that refactoring and that
makes it easier for you to apply those
things on other pieces of code I don't
know anyone here that's using the stuff
yet maybe in the future will have this
and this will make merging branches even
easier because it will operate a lot
more like actually editing collaborative
editing document stats in the moment so
git came out and was starting to be used
by many people and in in a small
community really initially but it
started to pick up the few people were
kind of interested in it but sort of
like interested in an academic way all
distributed version control tools
they've been others around before but
this is a new one I let's give it a bit
of a look or is interesting but most of
us were still using normal traditional
centralized source control tools the
thing that really made github popular
and change the way we think about
software development was github get have
launched in 2008 it took them only a few
short days after their release to expose
something that changed how we think
about open source software delivery and
software delivery in general so I think
their third blog post after they
launched they exposed the pull request
but now git has had a pull request
functionality built into it from the
very very early days github input into
their own type of pull request mechanism
on top which is something that Linus is
tool angry about to this day but he
seems to be angry about an awful lot of
stuff so I can't keep a list and this
functionality I'll app drastically
changed how easy it was for you to
contribute to an open source project
previously if you wanted to make a
change to the open source project what
you have to do is you would have to
either become a committer or you would
have to get that code check it out make
the change locally test that change and
then generate a patch file so thank you
larry wolf or the patch file format you
would then send that patch file Reviva
email to one of the people that had to
commit right to that source code repo
and say here's a change can you make it
can you make it for me into that
committee would then have to merge your
change in or just give you commits right
most of time you have to submit a few
patches to a project before you would be
allowed to actually be part of the core
committee group with the pull request
model you made it very easy just to
create a branch of that code make your
changes locally you send a pull request
to the committee's you can then merge
your pull request in using git itself
significantly lowering the barrier to
entry to making changes and project
after project moved away from using
centralized source control systems moved
away from home source code hosting like
source for example over to github
primarily because of this there's a
bunch of realized visualizations of
source code of the history of source
code from version control systems and it
is a little snippet of a visualization
of the Ruby on Rails codebase and so
it's a graphical representation of the
people who committed to the project and
the commits those people made to see
here a small number of developers and
around this point they actually moved
over to github from source launch and
what you start seeing is a drastic
uptick in the number of committers that
actually coming in and contributing
functionality to the project it wasn't
just a number of committees increased it
was also that none of the volume of
changes that came in increased this has
become this was hugely in hugely
impactful for this project and really
allowed it to kick into high gear and it
is this is an experience that was was
mirrored by project after project in
moving over to the github environment
and it was no surprise that sort of
shortly after they launched many years
after it launches about 2011 the github
actually outstripped both Google code
which is now being shuttered and
SourceForge in terms of that number of
commits it was handling in a number of
projects it was handling that's pretty
meteoric ride and that's just those
three years this is primarily down to
the ability of a pull request in my
opinion that's the real empowering thing
about open source development it makes
it much easier for you to accept
contributions from the outside world
you've drastically lowered the barrier
to entry for making those changes so
this is fantastic
but of course at this point of saying
but San PRS use branches and yes they do
when you make a pull request you are
creating your changes on the branch and
you're asking for someone to pull that
change in
and so the same challenges do occur the
larger the change you're making the
longer you've been working on that
change the bigger effectively the PR is
going to be but if you're a maintainer
of a project and you someone sends you a
huge Delta huge PR so take you a long
time for you to review that change and
make sure it's good enough to be checked
in so we want to keep our PR short just
like want to keep our branches short the
key thing to understand of course as
well as the open source development
isn't about a bunch of full-time people
working nine till five to create some
end-to-end product it's actually about
people who have an hour here and an hour
there and two or three hours in the
weekend to make a change from open
source project they're mostly doing it
out the goodness of their heart you have
also a mix of trusted and untrusted
committers normally the trusted
committers can commit directly and
without needing to do PRS this process
is the development process of an open
source development is fundamentally
different to the development processes
we use in our companies day-in day-out
and so the same challenges around pls
that exist with long live branches if
your long live PR it's going to be a
pain to merge it's going to be expensive
to merge so we take a long time to
review and so people to do what I'm
going to like small tightly defined PR
that allow you to note that
functionality in now of course github
like get allowed us to do some really
interesting things and branches and as
we often do as technologists we think
well this is quite interesting let's
build something really complicated on
top of it and that and then hence we
enter git flow so what get flow does is
get flow as a standard way of working
with branches and a set of tools on top
of git branches to make it easy to sort
of codifies form of working with feature
branches this is a diagram on the simple
diagrams that explains how git flow
works I say explains how git flow works
and I say simple this is sort of
anything but so you've got a master
branch of hotfix branch or release
branch you have a developer branch and
then you have your feature branches
which is where you do most of your work
and there are all kinds of programs
command lines you run to light emerging
features and push it through to the
hotfix branch and and sort of merge it
over to the release branch and you go
back to the master branch and you
disappear outside your own fundament
and then you go home and cry it seems to
me the gifts were actually you get down
to it it's optimized around a
development process where developers
work by themselves for a long period of
time and a feature and then merge that
feature in I don't actually mind too
much if that's what you want to use your
open source projects that mirrors the
way those projects work I don't know
about you but I don't like in adding a
software delivery team that works nine
to five together the idea that some is
going to go off by themselves and work
for a long period of time on a feature
by themselves before merging it in I
have some people that use git flow says
but Sam we check it up we have really
short live branches our features only
last for a day or two if your features
only last for a day or two I've got no
idea why you need git flow you don't
need something that complicated if what
you're going to do is do a little change
a branch and merge it back in you don't
need that sort of stuff and so a number
of the things I've been working with
that have been making use of git flow
what you tend to see is those feature
branches it's almost like those feature
branches are living longer because the
git flow stuff makes things a bit more
painful to check in and the git flow
stuff is there to support these longer
live branches which is sort of enforcing
and encouraging a pretty bad behavior we
come back to this idea we want to check
in frequently I don't want people
working by themselves and features that
take weeks and weeks and months before
merging them in I want to ship my
software quickly and again the open
source world is not your day job your
day job is different I mentioned earlier
that sometimes the toggles and the
features things get it can become quite
more come become complicated to manage
especially when you've got systems that
involve lots of services and you cancel
of jury-rigged your own control
mechanisms to allow you to fit toggles
off and on recently last couple of years
a number of companies actually two
companies have emerged that I'm actually
providing platforms to manage feature
toggles in fact there's going to be a
talk and if I haven't already missed it
by the CEO of launch directly talking
about how to use feature toggles and so
your split by online start if you both
give you sort of SAS based products plus
pace way of managing your flags and so
they can do some fairly interesting
things like split the i/o for example
can even turn flags off and on to
certain user cohorts which can be nice
way of hiding features for
users they can even dgo code-based
toggles as well so you can do rollout of
a feature to certain a country group to
time-tested outs of a way of
implementing a canary effectively I'm a
little bit skeptical about these not not
because I don't think they work more the
for these two works you have to often
rely on somebody's centrally managed
platform and they're often a very
critical part in your execution path if
I can't find out the values of my
toggles in production what happens and
so you do have to understand the failure
mode around these things and it's a very
very good documentation on how these two
two tools work that you can learn from
but I would urge if you're interested in
using these things to manage your
toggles that you look and understand the
architecture and what happens if you
can't talk to a centralized server and
also go to the launch time dart leeteuk
I'm sure it'd be very entertaining more
recently things have been progressing
some people anyone here read this book
the DevOps handbook so times past the
DevOps movement has has been around for
a while now it's maturing we've been
living with with github and the things
it allows us to do we have now version
control tools very widely available TFS
gives us get support enhance for a
number of years we have access a very
powerful version control tool that
actually allows us to you make use of
branches much more lighter weight
branches than we first did back in 2004
and before that I have the world really
change has it shifted this book was
written by a number of people including
Jess Humble who worked on me who wrote
the continuous livery book and it was
really them distilling down their
knowledge and if you know much about the
DevOps movement you'll probably know
every single person who wrote this book
it's harder to think of a more
prestigious set of DevOps authors as
this they make a statement in the book
and they reflect actually on this idea
of trunk based development trunk based
development is likely the most
controversial practice discussed in this
book given some of the conversations
I've been having over the last six
months I certainly agree with that
however the data for the puppet labs
2015 state of DevOps report is clear
trunk based development predicts higher
throughput and better
ability and even higher job satisfaction
and lower rates of burnout so what this
report they're citing so how many people
here have read the state of DevOps
report anyone the rest of you should
it's a short read the 2000 this they
were quoting 2015 version now I should
have recap about the 2017 version is
available
it's the report they put out every year
and what it involves is a statistically
rigorous survey of multiple software
delivery projects and what they're
looking at are what practices are used
by high-performing IT teams and
high-performing IT teams are you know if
you're a hyperlink IT team based on your
throughput so how quickly your delivery
to a cycle time how frequent you ship
software your failure rate and also a
bunch of factors about things like
employee satisfaction looking much more
the human factors and what Nicole Jezz
and Jin Kim have been doing with this
study is trying to understand rather
than relying on our gut feel about all
this practice works for me therefore
University applicable actually trying to
carry out a statistically valid survey
to say look these practices are used by
- wing teams - when teens are more
likely using this practice therefore
these are the sorts of practice that
might be good for you there's a whole
bunch of stuff out there about how the
report put together this is a quote from
the 2016 report we found that having
branches or Forks with very short
lifetimes of less than a day before
being merged into trunk and having less
than three active branches in total are
important aspects of continuous delivery
and all contribute to higher performance
so does merging code into trunk or
master on a daily basis now the report
does not say that if you have longer
live feature branches that you can't be
successful just that the vast majority
of the high-performing teams that they
see through this study over the last
several years are using this or these
sorts of techniques they are merging in
their branches very frequently they're
not letting them live for very long and
ideally they're integrating into brand
into branch
trunk on a daily basis so say are you
saying that branches are all branches
are evil
necessarily no for me it's all about
integration frequency if you're using
branches but integrating very very
frequently I think you're probably going
to be fine
some people's value have frequently
differ I like integrating daily other
people may be you know every two days or
something like that that's kind of okay
the key thing to keep an eye on if you
are going to be making use of branches
and all the evidence we've seen so far
you really want to be making sure you're
checking in frequently if you're finding
you're not able to integrate frequently
because your code is taking longer to
you know work on maybe the features
taking you more time have a look and
think can we actually make this feature
smaller can I break this work up into
smaller chunks or can I use techniques
like feature toggles or branch by
abstraction to hide that half checked in
code to reduce how long I'm keeping
these branches around for I also think
that once you get to the point where you
are having branches that are very
shortly if maybe only living for a day
or two shifting to trunk based
development that drastically simplifies
your use of your source control tools is
something that's quite possible so
keeping your batch size small is going
to keep the size your branches small
integrating often it's going to reduce
your merge plane and make it easier
future ship software to your customers
and shipping often is going to reduce
the pain of your release cycle it's
going to get software out to customers
more quickly it's going to give you data
on whether your software works so really
you know in summary has much changed of
2004 yes a load of stuff and also know
ah it still feels to me that the same
and actually not just a feel anymore we
now have good studies out there to back
this idea up tools like github are
fantastic the processes around things
like pull requests are great when you
have a mix of trusted and untrusted
committers and they can even work inside
organizations where you have that mix of
people but most of us don't work in
those environments most of us are
working with a set of trusted colleagues
on the same project working a
nine-to-five day and so I just
questioned the value of some of these
practices in those kinds of environments
anyway I hope this talk didn't make too
many people angry I'll be annoyed made
no-one angry though but anyway thank you
so much for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>