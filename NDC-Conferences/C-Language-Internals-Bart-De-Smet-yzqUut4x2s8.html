<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C# Language Internals - Bart De Smet | Coder Coacher - Coaching Coders</title><meta content="C# Language Internals - Bart De Smet - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C# Language Internals - Bart De Smet</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yzqUut4x2s8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good afternoon everyone
welcome back to my talk about c-sharp
language internals and Barth I work at
Microsoft in back in the States
currently on the bank team working on
high scale services for event processing
systems and I will talk about that
tomorrow
in my talk about high performance
netcode today we're just gonna take a
look behind the scenes of your favorite
c-sharp language features it's actually
part of some series that I've been doing
for the last maybe three years or so two
three years at various conferences I've
given this this kind of presentation now
the nice thing about it is that the
content is always different this enough
language features to talk about so if
you want to see some more content on
this you can actually go to two places
you can go to channel 9 dot MSDN comm
which is the video website at MSDN there
you can find plenty of videos from
different conferences in the Netherlands
in Belgium and some other places where
I've given a similar talk and there's
also a two-part little site course on
c-sharp language internals which is kind
of the same same content but of course
you know there we have much more time to
go into much more depth so so that's
just to set the scene over here now the
way that this talk actually works is
very simple I don't know what's gonna
come up next I'm just gonna ask you what
you want to see it's divided into three
pieces I have some starters which are
just to warm up then we have some main
courses which are a little bit heavier
and then some you know lighty sorts we
sort of stopped with the mechanism is
quite simple we pick something depending
on what you pick we'll pick our utility
to study that language feature in much
detail we may actually go into il code
to see how it works so fasten your seat
belts we may open when debug to see like
the native generated code for the
language feature or we may actually open
the Rozlyn source code the the source
code of the compiler can actually attach
a debugger to the compiler to step
through some of the compilation process
or sort of point out some interesting
tidbits as we browse the code so let's
get started by well what else do start
weaved in a starter so we could talk a
little bit about today initializers very
simple language
seemingly but you know has some
interesting cogent we could talk a
little bit about events which has some
interesting stuff to do with
synchronization that's all the way back
to C sharp 1.0 we can also go a little
bit more modern with interpolated
strings which we're going to reduce in C
sharp 7 very recently and they also have
some interesting cogeneration so maybe
show of hands how many want to see some
erase stuff mmm ok I'll have to assess
how much that is how many want C events
it's a little bit more I think and
interpolated strings
mylord I think the events will have it
actually yeah okay so we'll do events
for now ok so um I'll talk about very
simple events actually so let me
actually just open some piece of code
here I have sitting handy that's the the
simplest piece of code you could have
actually it's not the simplest we don't
need the using how we do need using
sorry we need using for the action over
there
it's a very simple event over here
public event action a couldn't make it
simple if I don't do static void main
but you know whatever so that's the
simplest kind of event you can have but
there's some interesting tidbits behind
this like events actually are based on
delegates so one thing of course it
everyone likely knows is it doesn't
matter it's an event handler of T or
some other delegate type like I can use
the action delegate type here just works
fine the language doesn't care what what
delegate type you use there but there's
some interesting stuff that needs to
happen behind the scenes to make this
actually work because first of all if
you have events well you can declare
them in two different ways right like I
guess many people know that you can also
take control over the way that event
handlers are added and the way event
handlers are removed by adding an add
and remove clause over here and actually
writing your own code using the value
which is you know the thing that comes
in to the plus equals or minus equals
operation so you could do that and
actually there are many frameworks that
do that like for example window
forums because if you use the default
syntax which you know I had on the
screen just a moment ago not looking
first to that right now if used this
syntax you end up with a field behind
the scenes which holds the delegates
instance that you will use to do the
invocation of whoever is attached to
that event and so if you want to avoid
the cost of those fields you can
actually use add and remove yourself and
build an event manager and in fact if
you browse the source code of Windows
forums you will actually find an event
manager that actually dissolved
registrations of events behind the
scenes and not relying on any fields but
I'm gonna focus on on this particular
guy here now what's interesting about
this is that when at some point I do say
for example a plus equals and then I
should make it static if I want to make
this compile eventually if I do a plus
equals the simplest possible
you know lambda over here for example
something interesting has to happen the
way that those delegates get combined is
of course using the same thing that's
used to do a combination of two
delegates so like if I have action a
over here and I have action B equals
something else these are two different
you know bodies here I can do action C
equals a plus B all right you know you
can actually add two delegates together
and then you end up with a multicast
delegate and so this multicast delegates
the way that this a plus B actually
translates is as follows it simply does
delegate dot combined of a comma B and
then it will cast result over here to
action and assign that to C so when an
event starts out with no event handlers
attached it starts off as no and then
later you know I need two plus equals it
basically does a combined inside the add
method to add those two things together
which is of course a little caveat there
was the caveat that you may actually
have concurrent accesses to the event
plus you know plus equals and minus
equals to add adds and remove event
handlers so there can be some
concurrency there and you could actually
be losing things because this plus is
not atomic as you can see over here if
you would do a plus equals something
let me do instead of this let me do a
plus equals B then you end up with code
that looks like this
which is pretty much the same as in
multi-threaded code writing something
like a plus equals you know three or
something then of course the read from a
and there I to a is not atomic so we
have to do something in order to make
this an atomic operation and so the way
that this works is by using some
interesting code behind the scenes I'm
just gonna remove all of this and let me
actually compile this over here using
the c-sharp compiler I'll do / o + to do
it in an optimized build it says that
the event a is never used I know that
it's just for demo purposes but will
actually use I'll dancing over here to
have a quick peek at what's going on
behind the scenes here and so you see
that we actually have our event here for
some reason events are under choosing an
upside-down triangle we sort of have all
the shapes in Aisle dancin like it
doesn't have any meaning but then you
know if you take a look over here you
see this add and remove handler they
have been generated for us and you see
the add a and remove a if you go in here
you can see this beautiful thing over
here interlock compare exchange typical
way of doing you know concurrent
programming is to do read fields then
you try to update the field provided
that the field hasn't changed from the
original value that you had before so
this thing has actually generated a
while loop that you know infinitely long
you know will sort of try to swap in you
know the thing that you're trying to add
in a concurrency safe manner
in fact in older versions of the
compiler we used to have synchronized
access here just like you have in Java
methods implementation attributes say in
this thing needs to be synchronized
which took a lock on you know the
current instance of the object or on the
type in case it's static static events
and that's not a good thing so like I
believe it's starting from from c-sharp
to point or something this has actually
changed into using interlocked compare
exchange so now let's actually take a
look at the source code on how this
thing actually is implemented because
that's one of the beautiful
you can do nowadays literally a couple
of hours ago I did a get clone of the
Roslin source code how many of you have
actually been to the Roslin github page
yeah did you look in the code a little
bit yeah okay so I just let it get
cloned this morning so it's actually the
latest and greatest version of the
compiler I have sitting here and so I've
opened a solution called compiler sort
SLM I've opened a whole bunch of things
here but in fact you know if you want to
boil it down to the essence it's quite
easy to unload pretty much every tank
this starts off with I believe 56
projects or something and if you open it
also in dodecyl and it's like 150
projects like you don't want to you know
open that whole thing and hit that five
every time you won't try to do something
so just open compilers those SLM and
then just you know unload everything
that's just code and you end up with
eight projects which are the core of
Roslin at the siege of compiler for
example over here and the command-line
compiler and those kind of things and so
what I've done is I've set C Acedo DXE
over here as the startup project and
I've passed in over here I'll just read
it out loud the command line to compile
a file called demo dot C S which sits on
my desktop okay so this demo dot C s
file which we are using for our demos
over here will get compiled as soon as I
hit a five so let me just do controller
five it's a different file than the
event starts yes that I'm showing you
right now we'll go into the event stuff
in just a moment I'm just hitting ctrl
f5 and it's running and you will see a
version of the c-sharp compiler version
4224 might and we sort of shipped you
know c-sharp eight all the way to 41
without you noticing it's just when you
do a local build you end up with version
42 it says developer built over there
and so I'm actually using some new
feature just to prove to you that this
is actually c-sharp not seven but seven
point one already from the master branch
where we have support for a feature
called async main which is not enabled
yet but I will actually just go into the
code to show you how this actually works
I have this little piece of code here
sitting behind behind the scenes that's
the one that I'm compiling I by
attaching the debugger to DC Sheriff
compiler and you see over here async
tasks mean this is a new thing that will
come and see sharp 7.1 you can actually
have async methods for the main method
instead of having to have synchronous
methods that return void torrents you
can also have a sync matters that
Twitter and tasks or tasks event and so
that's that's the piece of code I'm I'm
actually gonna compile I'll also add my
event over here so we can study that in
a little bit more detail so I'll just
have my event action here the same as
the one I had in the other file and so
I'm just gonna step through the compiler
now to sort of give you a sense for you
know the way you can sort of study those
language features and at your own pace
at a later point in time
so for async main I've already set some
bookmark over here just to make it a
little easier to navigate today but so
the way that async main is actually
built is by generating a synthetic entry
point it synthetic entry point that's
actually a synchronous method because
the CLR only supports synchronous entry
points and all that entry point will
actually do is it will generate a
forwarder to your asynchronous method
under needs which will actually call get
awaited or get result on the task
returned from the main method okay so
it's as if you're writing this little
bit of plumbing yourself the reason for
using get get away to get result is
because it's on the wraps exceptions and
like for example getting a task and then
simply doing a deterrent a soft result
well you will get aggregate exception as
opposed to the original exception so it
generates the code using get to you know
get the way to get result and this works
against any anything it doesn't even
have to be a task it can be anything
that starts like so anything that
supports you know you know the gutter
waiter and and get result bad and will
actually work with this okay so I'm just
gonna and you know hit f5 now over here
to now build you know my little demo dot
CS and we'll step to a little bit of
the source code actually I have some
breakpoints that I set up a moment ago
but you see C sharp compiler is spinning
up over here and the first thing that's
interesting to know when you're actually
gonna explore the new language features
is go to this particular file here
message ID dot CS you don't have to
remember that just search for literally
C sharp 7.1 across all of the text files
and there you see feature detection
because the c-sharp compiler can
actually be used to down level you can
actually compile C sharp 6 and 5 &amp;amp; 4 by
specifying a certain flag the slash
length version flag and so this is a new
feature in c-sharp 7.1 but I'm actually
running the compiler with default flags
which means it will still think that
c-sharp 7 is the latest because
everything higher it's kind of
experimental and here you can already
start to see the menu of new things that
are coming in c-sharp 7.1 you see async
main the default literal the default
littell is actually this I can write int
x equals default without doing default
event that's using target typing so you
know if you wanna sign it to an end that
will automatically infer that you mean
you know to write default event over
here that's another feature but so this
is the feature detection stuff and
that's the one that was responsible to
give this error message on the screen
earlier saying async main is not yet
available so let me just you know step
through this a little bit more and do a
little bit of hacking here you see it's
actually calling some helper method over
here to ask whether a feature is enabled
and so where are we coming from we're
actually coming here from some piece of
code that's trying to find the entry
point by using a set of candidates and
in fact if you take a look at the source
code here of the c-sharp compiler you
will actually see that it's using its
own dog food all over the place for
example what you what you have over here
if I go a little bit higher as a local
methods local function you know that was
actually shipped in c-sharp 7 and the
compiler uses that already you also see
here in a very build off tuple types
also a new c-sharp 7.0 feature so you
know it's full off you know all the new
stuff immediately being you
inside the compiler source code and so
what's happening here is that this piece
of code is actually going to all the
candidates to try to find the
synchronous main entry point and now
it's also trying to find an asynchronous
main entry point it has found one but
it's not checking whether it should
allow you to use async main because
that's a new c-sharp seven point one
feature and so it's gonna complain
because it's still configured to use
c-sharp seven but of course you know no
problem here what I can do is I can just
say that the available version is the
required version in the debugger to just
you know bypass this check actually no
so let's just do a little bit of hacking
here I'm just gonna pretend I'm running
c-sharp seven point one and now the
feature will just continue compiling so
if I now hit f5 you see it actually
compiled the whole thing fine
and I'm actually ending up here in
another breakpoint that I've set which
is the async forward that I was pointing
out a little bit ago and so if you just
search and the simplest way to actually
search for this kind of stuff is as
follows you find a new feature you see
the place where you see the first hint
for that new feature in the source code
and then the very next thing you do is
you click over here on the github source
code and then you just double click on
the change list and lo and behold there
it goes that's you know the check in of
the compiler team to add this feature to
c-sharp seven point one so now you can
start to find all the affected files
where you end up you know having any
changes related to this this new
language feature and so what you see
over here is that the body of the
synchronous main method that we're
generating is effectively just
containing a call to get await a get
result with a little bit of decoration
around it suggests a return statement
and just a block you know like you know
curly brace close curly brace and then
inside of it it will just you get a way
to get results for you and then just
return to the color in case it's async
task events it will do pretty much the
same thing it will just return the
result of get result which will contain
the exit code right so now you can start
stopping to all of this and if you like
you know I could just stand here and
just do f10 for like likely the next six
hours
to do line by line to see the il code
being written we're not gonna do that
you know I don't want to bore you to
death
but I'll just show you one more thing
which is the place where that event
stuff was actually happening
actually I didn't have to exit the
debugger for that but fine the event
stuff is sitting over here and the thing
I want to point out by just going to
this event stuff because it's kind of a
trivial language feature but still you
know not everyone knows that it's
actually using some synchronization
stuff under the hood if you actually
start browsing the compiler source code
you end up with a lot of references to
the language specification and also a
lot of historical notes like you know
this used to be this way and you know
Visual Studio 2013 and we changed
because of that and so forth here's a
little bit of information which is
likely easier to read than what we saw
in our old Azzam like that compare
exchange well you can spot that but it's
not that easy to spot the fact that
there's some do loop around that hold
language construct so you see over here
this is the code that this tries to
generate and so now you can start
matching those things up a little bit so
you see what what's really happening
with the events is that we reach the
backing field but of course by the time
we read the backing fields immediately
after that somebody else could be
winning the race over here for checking
in another event handler either by doing
plus equals or minus equals so we have
now to guard against you know doing an
invalid assignment where we overwrite a
change that somebody else has made in
the meantime and so that's what this
code is doing that I was sort of
pointing out a little bit ago but you
see over here we try to do the combine
cast it back to the original delegate
type and then try to do a compare
exchange which is a conditional
assignment based on an old value that
we're at in case that's actually going
to we can just bail out from that loop
and everything is good if that doesn't
work and we'll just retry rereading that
field and sort of continue doing that
and so what you see here is actually
something that's very common to the
c-sharp compiler there's a lot of
complexity of course but in a lot of
cases new language features just
translate to old language features if
you look at that async main but
a couple of files touch to just make
some forward that makes an async main be
called from a synchronous main because
that's all the CLR knows about so it's
just gonna rewrite it as if it were a
human being
writing the code that would do that that
trivial piece of code as well in fact
over here we could have said in c-sharp
1.0 well we will not provide you the
convenience of field backed events you
just have to write this code yourself
and in fact the compiler is doing that
compiler is pretending there exists a
version of c-sharp that does not have
this language feature let me translate
it into something simpler and in fact
all of those rewrite steps
sit in a folder called lowering so if
you go and look over here you will find
a folder deep down here called lowering
and you see a whole bunch of language
features here suggest async methods
these are all based on lowering for each
for example is based on lowering like
some subset of c-sharp doesn't know
better for each loop it only knows about
while loops so we can just compile
things into a simpler set of parameters
so once you get your hands dirty with
this you know this code doesn't look as
complicated as you may think at first
because all this is doing is just
generating you know code that accesses
fields that has while loops inside of it
you can actually find over here this
whole loop construct will sit in here
somewhere as well now there's one more
thing you see over here that we also use
this thing called get well-known member
this is also a beautiful place for you
to go and take a look at the things that
the c-sharp compiler knows about these
are features inside the dotnet framework
that the compiler can talk to for
example for events that needs
interlocked exchange for other things
like string interpolation it will need
single format for example so you will
find all those members over here but you
will also be surprised that in a lot of
places we actually have checks that see
if this member is available because on
certain frameworks we may not have
interlocked compare exchange available
and we need to do some other strategy
instead and so you see over here if we
don't have this will actually go down
this other code part over here where we
will actually generate all
difficult and make the method
synchronized as opposed to using a while
loop ourselves so there's a lot of you
know forking in the codes to sort of
support all the framework versions where
certain members may not be available
okay good so that was kind of you know a
little warm-up we went through the
debugger a little bit you know see how
things kind of work and sort of looked
at a pretty simple relatively simple
language feature okay now let's go for
the main courses I have three on offer
tonight one is display classes display
class I used by lambdas and anonymous
methods and now also by local functions
and c-sharp 7.0 quite interesting new
language feature switch statements have
also grown a lot over the years like now
in c-sharp seven we have pattern
matching support and we also have a
think methods over here which got a
little bit of a revamp in c-sharp six
because now you can await insight catch
and finally blocks so I think they're
all very appetizing that let's just do a
little little vote here how many want to
see display classes okay how many want
to see switch statements okay how many
won't see async methods that's what I
fear it okay I've had this on you know
the main courses all the time and I had
to tell white you know wrote on switch
statements and things for my fetch for
display classes because they never get
eaten so we'll just do async method
instead okay async methods well you
already know where to look because I
mentioned that just a moment ago async
methods are based on lowering so what
that means is that async methods are
just one big piece of deception right
like you know it's as if you're building
a state machine completely yourself that
splits up the matter then does all of
the tacking on your behalf but of course
now that you have the c-sharp source
code available you can now start seeing
how all of this voodoo actually works
okay let's take a look at you know where
this voodoo takes place it's pretty much
all over here in the async rewrite
contains like six or seven files or a
little bit more not too bad but let me
just start by writing a little piece of
code at the common
line and sort of looking at the base you
know functionality and an async method
then done sort of work our way up from
there okay so let me just do a single CS
over here is this actually big enough
for the back or should I
boost it boost it okay I'll boost it 36
good good okay static void main you know
just to be happy
could you static async mean actually
that let's not do that okay
static async task of foo async I think
that's the simplest async method you can
get right like you know they think
matter that doesn't do anything so let's
just start with that one and of course
you know I'll need using system later
because I will likely do some console
right lines and system dot reading tasks
like this okay let me just compile this
guy a single CS let's not bother with
you know well let's actually do an
optimized build why not okay
so I have this it complains about an
async method lacking and your weight and
the whole thing will run synchronously
for demo purposes we don't care okay so
let's just open this guy and I could
actually open it an aisle spy to make it
a little bit more friendly
so we'll just go to see demos and the
see a sink to the eggsy okay and so here
we go I have my foo async and it did a
good job D compiling this thing in fact
I got more keywords than I initially
wrote so that's also good at the bonus I
got a private key work there but I will
actually go to a few options and I'll
spy over here and just disable a sync
matter D compilation to take a look at
what's going on and now we start seeing
something slightly more interesting now
how many of you have looked behind the
scenes of async methods before a few
okay so this is a worthy endeavor you
know to go to it so what's going on here
I'm not going to go to all of the
details but effectively what the
compiler has done is built this
beautiful little
thing here called the Xing state machine
so the async state machine is the thing
that's responsible to proceed your
methods when any of the things that are
awaited inside the body finish it's the
thing that sort of does the bookkeeping
it's kind of you know mimicking an
instruction pointer it knows where it is
in the async method and then if it needs
to go to sleep because it hits in a wait
for some operation that's not yet done
it will just say I can return at a later
point in time here and it will go to
that away table object and just say
please wake me up when you're done okay
and then it will re-enter and the state
machine will actually do a move next now
what you see here in the move next is
that not much is happening because well
there's almost nothing you know in my in
my method but there's still some
non-trivial stuff happening here well
first of all we have an empty you know
try over here well that's not very
useful but let's ignore that for now and
we also have this build a table set
result that's the equivalent to me doing
a return statement
okay let me make this quote a little bit
bigger to sort of show you what this set
resulting is doing so let me just go
here and change it to tasks of int and
then over here do return 42 what we're
going to see now is that the set result
will actually correspond to this return
42 so when I recompile this thing and I
just you know hit a 5 here in aisle Spy
you see over here set result equals
result and result equals 42 well there's
something interesting happening here
already why didn't we do set result 42
here hmm we are doing such result after
doing the result computation inside this
try-catch block that's because we want
all exceptions that are happening during
the execution of the async method to
come out on the task and not escape
somewhere on the tadpole so if I make it
a little bit more interesting once more
and I put in something to divide by and
I do 1 divided by D I could pass in 0
and end up with a division by 0
exception we want that thing to come out
on the task and not on the tadpole
somewhere in case we have beyond a
certain asynchronous execution point so
if I go here now it will be
unclear what that tie catches for that I
catch is sitting there to protect
against anything that made two
exceptions so pretty much all the user
code will be in the tie block that we've
already established everything inside
the catch here is a way to signal the
exception back to the collar to the task
that was returned and the set result at
the bottom corresponds to a return
statements okay now let's try to see
whether if I introduce more return
statements I end up with more set result
calls right so let me just do that as
well if D equals zero then of course you
know from now on in mathematics it shall
be known that dividing by zero returns
1983 okay
beautiful so we are redefining
mathematics that's hit f5 well no
there's not more than one set result
call what's really happening here is
that all my decision logic goes there we
store the result in a variable we do all
of this stuff beautifully inside the
protected region so in case something
blows up we don't blow up ourselves and
then we do set result at the end okay so
far not super interesting because I'm
not awaiting anything like I'm just
using an async method as a expensive way
to return an integer by doing a heap
allocation of a task right not something
you should be doing at home so now let's
actually change this to first of all
let's actually keep it this way and I'll
just do a weight TAS not yield which is
the simplest thing I could be awaiting
here so what's gonna happen now is that
my method now needs to be split into two
different stages the first stage is to
stuff that turns as soon as I call the
method and the second part that runs
here is what happens after the TAS not
yield eventually completes so now the
state machine starts having a purpose in
life it needs to track whenever it wakes
up and I before this does not yield or
after this does not yield okay so now
we'll see the method being split into
pieces so let me go here compile this
thing and go back to that state machine
and then I'll also explain how the state
machine gets kicked off at
later point but now it starts to become
interesting right so what you see here
inside the try catch is the minimal
thing required to effectively do this
pass and resume of the async method so
let's just walk through it step by step
now first of all we have our code
setting here turns out yield in the
middle and the Stars lot yield is
interesting in the sense that it doesn't
even return a task it just returns a
yield away table which implements this
whole awaited pattern meaning it has a
captive waiter and the gutter waiter
happens to have a result type which is
yield to a table dot yield to waiter
just an inert type in sight is yielded a
table so you see over here that there is
some code that emitted get a waiter on
top of that this is the code we had
before compilers are allowed to do go to
you know so don't worry about that
but over here you see it does what you
would get a waiter and now we can do two
things we can either check whether this
thing is already done or whether it's
not done yet
let's assume that it's already done by
the time you do the await everyone knows
that you know if you try to do some
asynchronous programming and you have a
chance to do any kind of overlapping you
should do so right like you know this a
weight doesn't have to be fused to a
task like in the coda right and in the
Bing stack for example there's a lot of
places where we do a whole bunch of
tasks you know task t1 equals something
and then you seven hours later we do in
a wait till on right so chances are that
this t1 will already be done by the time
we hit that a weight point right you
don't have to do a weight of the thought
everywhere like you can store things in
a local and then by the time you await
it it may already be done okay that's a
very relevant case to actually optimize
for and this is this this block over
here so this yield to weight if it's not
completed will do something let's ignore
that but in case we've already done
we'll just fall to two not that point
but will fall to over here so what's
this thing in case we have done we'll do
get result and that get result made to
an exception because it's amazing cans
operation that has just finished and
then we do the rest of the methods okay
so that's kind of what happens when this
whole thing completes
now what happens in case this away table
objects says are not done yet that's the
other case that's what's happening here
so when we call gets a waiter we check
are you done and if it says I'm not done
yet
then we have to do the heavy lifting and
what's the heavy lifting
well the heavy lifting is we need to put
ourselves asleep in such a way that we
can be woken up as soon as that thing
says you need to resume so what are we
gonna do well the first thing that we do
is everything to do with this state
thing what you see here is this num
right which is just a name that I'll Spy
has given this variable in reality it's
not called num in fact it doesn't have
any name in what the compiler limits but
so we read the state which is kind of
the instruction pointer of the state
machine and so the initial time the
state will be set to some value over
here and that causes us to enter this
piece of code and now we come to the
conclusion that you know starting in
this state we need to go to sleep
because we just kicked off this
asynchronous operation that's not done
immediately
so we increment our state to the next
state in the state machine we say when
we want to be woken up we want to be in
state zero what will that do will
reenter this method at some point all
the way from the top and we'll jump to
the else block right because we have F
num not equal zero we'll do this and if
nom equals zero we'll end up over here
so we first set our state to the next
state and then we'll actually go to some
levels of indirection which I won't go
into detail about has to do with
execution context and all that kind of
stuff will actually tell this a waiter
over here you know please attach the
state machine to your body so that by
the time you're done you can actually
kick him in the back and say like wake
up continue where you left off so we're
basically just telling the ax waiter
here's the thing you have to wake up
when you're done that's what this
indirection actually does this away ton
save on complete okay now there's
something else happening here which is
quite interesting if you take a look at
this whole state machine thing notice
this one key word here it's a struct
it's actually stack allocated but of
course at the point that you need to do
asynchronous work the stack frame will
return what will happen the task that
comes out of the async method will be
returned to the caller where it may be
awaited and that may also return to the
caller so like we're basically taking
down our call stack and if this thing is
stack allocated well that memory is no
longer valid so what's happening is that
this whole async state machine gets
passed by reference to this helper
method this await unsafe on completed
and that thing will actually box it to
the heap so in case you end up in the
situation where your whole async method
runs synchronously no heap memory was
killed in the process
okay but as soon as you hit something
async you take the penalty of taking
that whole state machine moving it up to
the heap so it can live longer than the
current call stack and then at a later
point in time we can resume it so async
method start off cheap
once you hit the asynchronous aspect of
them you pay some additional price but
that's surprised that that you're
willing to pay because you know there's
a lot of convenience in doing
asynchronous programming this way okay
so now that's kind of the basics of how
this works let me just make it more
complex now by just adding a couple more
things here let me do a weight TAS not
yield and then do console.writeline one
over here and now I'm just gonna copy
paste this thing a couple of times okay
like this so that you get in a chance to
sort of see the state machine stuff in
practice so I now have five yields and
here I could do all sorts of loop
constructs let's not bother you with
with all kinds of complex loop
structures well just have five you know
task dot yields and I could do other
things here doesn't have to be tossed
off yield I could do tasks from result
one you know I don't know await another
performance crime you know it's a sort
of run of nothing you know whatever
right like you can be awaiting a whole
bunch of things now if I go back here
and I compile this whole thing and I go
back to my state machine over here
well now you start seeing what's really
going on right like
my method has five stages of execution
in the past it didn't look that complex
because there were two stages and we
compile it using if-else but now we have
five stages of execution so we need to
have a big switch statement here so that
we are in state zero we'll do this if
you don't state one we'll do this and
we'll jump to label f9 if you're in case
two we'll do this so for example case
two what case - gonna be well case two
is that thing with the task from results
apparently so if I go here once we're in
case two we'll do the next thing what
needs to happen so you see you know in
case one we need to do two from result
when the from result is done we need to
get the result of this task from result
and need to do the next thing when this
thing is done we need to do another
yield over here I clicked on the wrong
thing but you sort of see like you know
all the parts of your method nicely
split up into pieces it's as if the
compiler just took scissors and it's
cuts to all the await keywords and
splits everything up right okay so let
me just point out one more interesting
complication of all of this
voodoo business right a weight is an
expression at some point it was
considered very early on on the design
should it be a statement or an
expression well you know it being an
expression makes it very flexible
because then it has a value and you can
use it anywhere you expect a value
including an assignments 99% of people
will do int x equals a weight tassel
from result but other people will do
call a method passing in the result of a
waiting something right so I can do
something slightly more evil over here
so let me just get rid of all of this
nonsense to write more nonsense and so
what I will do is let me do console dot
write line off console dot read line
okay and you actually try to outline
this a little bit I'm a little bit OCD
so it needs to be a little bit sexy so
console.writeline of console dot
readline plus let me do another console
dot readline plus and
we actually make this thing associative
this way now it starts to look
completely nonsense but you know over
here a way to ask Todd from result of
hello doesn't mean anything it will just
ask the user to enter two things right
like no I will enter a B and then it
will print a B hello very useful like
you know can likely make it a store app
and charge $0.99 for it we're not gonna
do that and that takes too much time but
so what's happening here is something
quite interesting what's happening is
that before we're gonna figure out that
we have to go to sleep and wake up again
all of this nonsense with a sync state
machines we are merrily executing stuff
we are executing a console headline
asking the user about something then we
do another console dot readline you know
and and then ultimately we do this task
from result and we come to the
conclusion oh we have to go to
sleep so like how do you wake up all of
this calculation that's already
happening what's happening here is that
we have to store all of those
intermediate results so if I take a look
over here that's where you end up with
this beautiful thing called a wrap okay
and this wrap is actually a feature
called stacks building and that's the
implication of having a weight as an
expression it can occur anything in a
complex expression being evaluated so
normally what would happen if you have
something like this is that the code
that we would generate would be
something like simply you know do
console dot readline make a call to
console dot headline make another call
to console dot readline
then load that strength for a hello or
something and then do some add
instructions well you can't do add
instructions with strings you have to
call single concat they would just be
stack based you would just be pushing
one thing on the stack another thing on
the stack another thing on the stack and
then merrily reducing the whole thing by
doing you know operations like add and
subtract and multiply or what have you
we can't do that anymore like we have
stuff sitting on our evaluation stack
and now we have
to go to sleep well what you have to do
at that point is evacuate the whole
furniture all right you know write it
all down on a piece of paper put it
somewhere on the heap on a sticky note
so that when you wake up you can restore
it and so those sticky notes are called
the haps so that's what's happening here
is normally those would just be sitting
in local variables but what happens is
that we have to be prepared at at some
point this thing may have to go to sleep
so we better put it in a position when
we have to go to sleep we won't forget
about it so you see this
console.readline console.readline they
get assigned to rats and then later over
here we are actually restoring all of
this using those apps that you see over
here so you see we are eating those
things back from the fields at a later
point in time and that's something that
you will see a lot for those more
advanced language features is that
things that look like locals or that
look like intermediate results may
actually end up being fields on
something allocated on the heap there's
actually exactly the same thing as with
the closures that I was going to talk
about for like delegates and and lambdas
exactly the same thing something that
looks like a local may end up somewhere
sitting on the heap because it needs to
live longer than you would normally
expect okay and then of course you know
we also generate codes to actually know
how to use apps that's a change that
happened at some point because well if
that async method turns for days and
days and days right and you have some
expensive objects sitting there it will
of course be hooted and not be ready for
garbage collection so we need to also
allow those fields as soon as we are
done with them in certain cases if you
have multiple await sites that have the
same stacks billing requirements that
will actually reuse those are fields so
if there's other places where you need
the same types you know for temporary
state to be stored it will try to to
reuse those airfields as well okay so
that's what's going on with async
methods I'll just show you one more
thing in the compiler source code if you
ever wondered how c-sharp 6.0 that it's
magic to make it possible to await
inside a catch and a finally block let
me actually make this bigger for the
back over there this file does
everything need to be able
to do in a wait inside a catch block and
the wait inside of finally it's not easy
you know there's a lot of stuff that
needs to be taken taken care of and so
here you see like all this case is
nicely documented the C sharp compiler
code is like a hit or miss in some sense
some pieces are very dense and not
really documented other pieces are you
know heavily documented so you know you
just have to be lucky that day and
otherwise you just attach a debugger and
try to figure out what's going on of
course but so over here you see a
weights containing finally blocks
there's a lot of stuff that actually has
to be done because what's really
happening is that inside a finally block
there's a hidden hot potato what do I
mean with a hidden hot potato there may
be an exception sitting somewhere but
it's not even sitting in a variable
because it's the CLR at the runtime that
no switch exception is currently flying
by and that when the finally block is
done that exception needs to come out
again to the caller right so it needs to
sort of keep that state somewhere now
the c-sharp compiler doesn't have an
easy job here because that exception is
not capable inside a finally block so if
you do in a wait inside finally and we
have to put that matter to sleep we sort
of have to find that hidden potato
buried and the count extract it keep it
somewhere so we can retell which one
today sync method resumes so all of this
stuff happens here and what's actually
happening is if you have a tie finally
within a wait inside finally you will
not find any finally block in the
generated il code it will become a
try-catch with a little kind of thing
now the Rito is not a plain Rito it
actually says over here like Joey X but
in reality it's not really using a exits
using an interesting type this guy
called exception dispatch infer how many
of you know exception this pageant for
know if not you may want to know about
it and exception dispatch infer was a
type that was actually introduced in
c-sharp procedure in the dotnet
framework together with c-sharp 5.0 is
this little helper in system runtime
exception services and it's this thing
that allows you to do
a so on an exception after you capture
the exception now you will say what's
the big deal with all of this kind of
stuff can't I just use ditto keyword to
itto the exception well if you Rito an
exception the call stack gets reset okay
so exception this pageant who allows you
to pretend nothing happens like you had
an exception in your hand and you want
to pretend that you never saw it never
Ito
Ritu what you will just retail with as
if you never had anything to do with it
so what's really happening is that the
c-sharp compiler will generate code to
Rito the exception in the most you know
innocent-looking way so that you can't
sort of even tell that it was ever there
and touch the hot potato okay and again
you know this is something that happens
over here if it's available like if you
actually compile this code before it
don't matter a big version that doesn't
have it available then we'll just use a
regular Ito so you can actually
experiment with the app try to run this
thing against different a framework
versions and the call stack of an
exception that's flying by to try
finally may look different depending on
that framework version because in some
cases we don't have the utilities
available to be able to pretend nothing
happens and so that's what we call over
here to better retail okay so that's
what's happening here this file is a
beautiful file to study if you want to
see all the intricacies of how to you
know deal with exceptions inside async
and wait okay well you don't have to
deal with it but like how to compile a
deal so it's okay so that's that's that
one and we just have time for a small
dessert okay mmm well I don't have to
maximize this you can read it I only
have two desserts today on the dessert
cart one is about dynamic that gives us
a chance to potentially crack open win
debug and do some native debugging if
you're still hungry
or we could do something really light
you know like a sorbet which will be the
transparent identifier okay okay the
first one dynamic yes you know that's
the chocolate lava cake and transparent
identifier
okay I sort of influence to Paul over
here I think mm-hmm let's do dynamic you
know and transparent identifies there's
a couple of very good blog post about
that one actually and I did that on a
different talk so if you go to the
videos you will will likely find that
one so dynamic people have a love/hate
relationship with dynamic I do as well
but you know in cases where it's useful
it's useful that sounds like a tautology
but here you go I've just prepared a
very simple piece of code here where I
use static dynamic app taking in to
dynamics and doing a plus B okay so this
can just add two things together using
using dynamic and those two things you
know can be anything that are edible and
it will figure it out at compile time
how to do it now why is this interesting
because in some cases and depends the
kind of code you write right you know if
you're dealing with dynamically typed
objects and so on well this may be a
good choice but also like sometimes in
highly performant stacks like disturb
I'm working on and Bing sometimes we
have to do a lot of late bound stuff
using reflection and so on and then
actually you may want to consider well
if we use dynamic a lot of optimizations
around reflection will be done for us
without us having to do a lot of heavy
stuff because once you start using
dynamic the code here that those a plus
B will learn it will become
progressively better the more things you
feed through it and that all happens
dynamically at runtime the way that
happens is by something called
polymorphic inline cache fully morphic
inline - okay so what's gonna happen is
that the first time we call at with one
and two this dynamic methods will cry
out to his daddy or mommy or whoever the
compiler happens to be that day I will
just say like help I don't know how to
have two integers together and then
c-sharp compiler will come in at one
time like a Superman and say my son
here's how you add a and B together okay
you will cause them to end you will do
an ADD
instruction in IL and you will do that
instruction okay go back to sleep you
know continue doing that but then I will
bother it with a second question
and so this polymorphic in line casual
ready knows like if I get two ends I
know what to do I don't have to bother
the compiler anymore but now I give it
bar and foo and I oh my god like how do
I add two strings together so again it
is the same thing it checks like arduous
to think ends no they're not ends like
oh they're things I don't know about it
will last a compiler to give it a piece
of code that it will compile you know
using the JIT compiler it will become as
fast as if it's statically written code
and so it will now learn well to add to
his things together unity past operands
back to string called the string dot
concat method and - your answer and the
same thing for at the date time you know
and anything that may go to this
polymorphic and line cache so let me
just show you this one you know at one
time now so I'll just turn this with the
optimizer turned on so I'm just
compiling this guy it's called in for
dynamic okay and I'm just gonna run then
over here actually let me run it with
debug it attached how many of you have
used when debug couple okay yeah
so when debug is a native debugger which
comes with the Windows SDK and a bunch
of other SDK so you can definitely find
it it also tends to be forgetful about
font settings I swear that I actually
changed it before I came down here you
don't believe me or not it doesn't
matter
here you go so I've just started this
the right-hand side don't bother with
that that source code so I'll just do G
here to run this thing so it's now
running another debugger okay and I'll
just press Enter well let's not do
percent yet let me break into the
debugger so I will do debug dot break
and now I will load something oh by the
way I'm not supposed to show this but
this is who knows Dave Cutler he's the
guy who built Windows NT kernel and I
had the breakpoint I'm in his assembly
code so like you know paste Lord you
know so let me just close that you know
it's just
in three instruction so there's nothing
secret about that one but I'll just do
load by s.o.s CLR to load something
called Sun of strike that's a debugger
extension native debugger extension for
the CLR and I can now do something like
dump to dump everything on the heap and
I'll do it by type called dynamic
methods that's something I happen to
know and there should be not much on the
heap of that type actually I may
actually get stuck here because it's
trying to download symbols and the Wi-Fi
is not exactly fiber-optic but yeah so
like there's no no objects on the heap
of type dynamic methods so that's good
so let me resume this debugging session
and now press Enter
this is where my code actually cried out
to the compiler to say help I need to
add two integers together how do I do
that okay and so it now did that little
dialogue with the c-sharp compiler at a
long time and it came to the conclusion
that it now knows how to do that and so
you see it actually loaded systems of
dynamic you know and all that kind of
stuff so I will now break this guy again
you know in the debugger and I will
can't get rid of Dave you know he's 76
he still comes to work every day so he
always pops up everywhere but so here
you see we now have two dynamic methods
sitting on the heap and what I will do
is I will take that one which is 112
bytes long I just happen to know that
that's the one I'm looking for you just
poke around to all of these if you want
to reproduce this but you will do dump
il on those things and take a look at
the il code generated in the dynamic
method and what we see over here is
actually code to unbox two arguments to
ends you see over here unbox two n32 all
sorts of things to actually unbox those
two guys
let me also take a look at the other
piece of generated code here and you see
over here which one is this one here you
actually see oops I've kind of lost
myself here in the middle but here this
there you go it has learned how to unbox
two integers and run the add instruction
to get the sum of two integers it didn't
know about it at compile time at the
wrong time the compiler told it that's
how you do it so now let me actually
resume this piece of code and bothered
that polymorphic inline cache by trying
to add two strings together so it's now
adding two strings together it again did
that whole cry out for help thing to the
c-sharp compiler at the runtime and so
when I break into this thing and there
he is again
I will do dump heap and you see there's
more methods that have been generated so
let me actually try to dump the il code
using dump il for one of these new guys
and you see over here the C sharp
compiler at the runtime has told it to
add two strings together
please cast the two operands to system
dot staying then call system dot
stinking cat on those two things and
there's your answer
so now when I call that thing again it's
as if that dynamic method was written by
you at compile time to do type checks if
the two things are inside I'll do it
this way if the two things are strings I
will do it that way you can't get much
faster than that
so like even though dynamic may have you
know a bad name for like you know doing
a lot of heavy stuff at runtime when you
really need it you can't really beat it
all that much by doing your own kind of
you know runtime code generation all
sorts of Voodoo then it's actually a
good thing to use of course don't use it
in a way that you do search and replace
inside all your c-sharp codes and change
all of var to dynamic such that you have
a Java Script experience from now on and
some people have that as a fetish I
don't bit like you could do that don't
do that right like but in cases where
it's actually useful it's actually darn
useful okay and of course I could do G
over here and actually let it learn
about daytime offset as well and it's
actually terminating the process at this
point so I'm not sure whether I can
still I can still find it but so if I
poke in here likely I will find out that
it's now also learned about how to do
the OP underscore addition static method
call to add a date
timespan together because again it cried
out for help for that one but now if I
keep calling this thing with date times
and time spans and strings and strings
and incidents it will be as fast as you
know static code almost it needs to do
some type checks of course but you know
in a dynamic world without type checks
there's not much you can do okay so
that's kind of a whirlwind tour of a
couple of language features and the key
thing to actually take back home is this
beautiful thing right like you know a
couple of years ago and the whole Walden
effort started it's now all available on
github and open source you know just you
know ctrl F gets you a long way and
finding things like you know if you hear
oh they have this new thing called tuple
deconstruction and you know the word
deconstruct and how to spell that one
you can do search all over here in the
code base and you will actually end up
you know and you know finding a whole
bunch of things that have to do with
deconstruction take a look at a change
list you know try to find like a coat
hanger like a little light in the
darkness like oh this looks interesting
that's this new language feature go to
the commit list and you will actually
typically find in the whole commit that
has the whole language feature coming in
as one big pull request into the source
code so a very very nice thing to be
able to to dig into now in the past you
have to sort of reverse engineer
everything okay so with that you know I
thank you for for your attention and
swinging by I will be around you know in
the venue so if you have any questions
please come to me I will also be here
tomorrow for a talk about dotnet
performance I also have an ask me
anything with bill bill walking it over
there tomorrow I believe somewhere
around noon early afternoon yeah yeah
exactly
all right thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>