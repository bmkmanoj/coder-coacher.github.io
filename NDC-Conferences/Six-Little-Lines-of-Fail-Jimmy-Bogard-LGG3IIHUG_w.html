<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Six Little Lines of Fail - Jimmy Bogard | Coder Coacher - Coaching Coders</title><meta content="Six Little Lines of Fail - Jimmy Bogard - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Six Little Lines of Fail - Jimmy Bogard</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LGG3IIHUG_w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is Jimmy you can find me at
Twitter at JB guard the presentation a
pretty much anything I do you can find
on my github github.com /a Bogart and I
blog on Jimmy Bogart comm I also had a
whole bunch of blog posts still sitting
around this site that is sometimes up on
those techies calm most people know me
from some open source libraries of which
I am deeply sorry if you are having to
use them today if you like them then oh
you're welcome thank you for using them
appreciate it
so this is a story
working with my developers about a year
ago or so where I had a developer come
up to me and say this is for an
e-commerce website for the checkout page
of this website
they said Jimmy I I think there's
something wrong with these lines of code
but I don't really know for sure can you
come take a look so I took those look at
those six six very small little lines of
innocuous code and said yes
you got something really wrong on your
hands here a good job for reporting it
out and so let's talk through ways in
which we can fix these six little lines
of code now these are blind to code that
probably anyone here is written I know
I've earned them myself as well it looks
something like this these six little
lines of code
it starts out pretty simple this is for
the the page are the code that whenever
you click checkout it takes your money
and does all sorts of crazy things
behind the scenes it starts out pretty
simple first I'm going to take your card
information and find the customer from
the database right so far so good then
I'm going to take that information from
your customer and the cart and build out
a cart object and build out the order
based on your card details and your
customer information alright so far so
good nothing going wrong here the next
thing we do is we go ahead and post a
payment to this stripe API stripe has a
really nice dotnet so library they just
released actually this week excuse me
alright so there go ahead and and post
that payment to the API via stripe now
once that's successful because it's
always successful of course we go ahead
and then send you a thank-you email to
send grid because that also has a nice
little API and finally there are some
downstream systems and drowns downstream
people we need to notify so we go ahead
and use
rabbitmq to publish the message to the
bus and then finally because everything
is good everything succeeded we go ahead
and show that nice little Thank You page
and around all of this and some kind of
like action filter or something like
that is a transaction that says go ahead
and say the changes once everything is
successful now this set of code assumes
that everything always goes well that
nothing ever fails so what the developer
came to me and said I think something's
wrong because we're assuming that
everything succeeds all the time and we
don't have any code that says what
happens not if something fails but when
something fails and one of the things I
always have in the back of my head when
I'm building distributed systems is
failure is always an option when
building these kind of things we have a
reasonable understanding an idea that
the application that we build is going
to be up and running we hope that the
database is always up right your
databases never go down right no of
course not never but those other systems
that were talking to stripe and syn grid
and RabbitMQ those are the ones we have
a lot less control on a lot less control
over and we can't make those sort of
guarantees it says those different
third-party providers are always going
to be up for me I try to force to make
my systems up as much as possible but we
don't have just unlimited money to make
sure everything's up all the time and in
fact because Google can't even keep
Gmail up 100% of the time if they can do
it then really what hope do we have for
the rest of us like none whatsoever
so I'm building six like this I try to
design them and build them in such a way
- I assume failure is going to happen so
the developer and I sat down and said
okay let's let's walk through these
options like how bad can it get if
something goes wrong here and so we
looked at all the different things that
that six little lines of code touched
and said okay for each line of code what
happens not if something goes wrong but
when something goes wrong so this the
sixth of the lines of code are
represented by this diagram where first
we had that call to the database a
couple calls actually to go ahead and
load up the customer information and
create an order
then we call it a set of third-party
providers and then the last step down
here was to then commit that entire
transaction so let's walk through each
of these steps and say what happens when
that call fails when something goes
wrong there so the first thing that can
go wrong is that first call to the
database where I say go ahead and give
me the customer information and build an
order based on their carts what happens
when that fails well nothing too bad I
mean the customer that's submitting the
order mate see some screen that says
something went wrong please submit your
transaction again which of course no one
ever does right because if it the credit
card in there and I don't trust you to
not charge my card twice but from a
system perspective the transaction rolls
back and then the entire system is
consistent so everything's good all
right so what happens when that's stripe
API call fails when the stripe API call
fails is actually not too bad no money
posts to the stripe API that is I don't
actually take money from the customer
the transaction rolls back because there
is an exception and then the system is
consistent I'm still not too bad the
next one we're saying is where things
really start to go wrong what happens
when syn grid fails that email service
provider has anyone had their email
service provider go down for like a day
yes that has definitely happened to me
and well no asking like hey guys what
happened to your API it's down for a day
oh it's just some some unplanned
maintenance oh thanks I appreciate that
note of heads up there so when this call
fails what's happened we've already
posted the payment to stripe but the
transaction rolls back so we've taken
their money but have no record of doing
so that's probably not a good spot this
is where people start calling you and
complaining and your manager starts
yelling at you like while you're taking
people's money without although maybe
the revenue numbers look good right like
yeah my business is doing well just
everyone hates us so at this point this
system is inconsistent things are messed
up the next one rabbitmq going down now
this is one of those things again that I
don't find the
I have to put a lot of assumptions my
system to say if typically if my if my
message broker goes down usually there's
something really wrong with my system
but these kind of brokers aren't always
able to be deployed and a highly
available a highly available manner
especially RabbitMQ it's actually very
difficult to get it to work correctly
and deployed in that manner and it's
also on the default mode of working
because by default used to like file
install and you assume everything's up
but to actually get it to do this highly
available mode you have to have a lot I
think you have to actually pay for it
it's not even free so what happens if
that goes down this is even worse we've
actually charged the customer via stripe
we've told them about it via email but
the database transaction rolls back
because of the exception so we have no
record of this actually ever happening
again not a great spot maybe have
revenue numbers look great
they probably eventually go down because
hey we're not actually shipping anything
to our customers now the last one this
is where our thing is going to really
really really go wrong what happens when
that final database transaction commit
fails well first of all we may make the
assumption that says okay if we've
already been able to contact the
database big to begin with I mean what's
the likelihood of that transaction
failing at the very end well there's a
lot of things that can go wrong things
like constraint violations those are not
actually evaluate until you commit the
transaction even just a network hiccup
something going wrong or someone pulling
the plug on the server because that
can't happen right like accidentally
turn the server off that happens so it
doesn't even matter like why that could
possibly fail we have to think about
what happens when that fails well we've
already called stripe so we've charged
the customer
we've also notified them via an email to
say hey thank you for your order it'll
be shipped to you soon
and we've also notified downstream
systems to say hey there's an order
that's came in go ahead and do your
processing go ahead and ship it out but
because the transaction rolled back from
the database we have no record of that
any of those kind of things ever
happening except probably log
files that's our last refuse refuge is
something the customer complains they
said they didn't get their order what
went wrong let's go troll through all
the little log files and see what the
heck went wrong and everyone has
Symantec logging here right they're able
to completely reproduce any kind of
production action that's happened right
everyone has that in place all the time
all the time oh yeah everything's
exactly no we don't always have that in
place we can't just reproduce any kind
of customer action on top of that we
don't may not even have all the details
things like the customers credit card
number we probably don't log that right
probably hopefully yes so we have a
situation where all these downstream
things have happened both from the
customer perspective and our own
internal downstream system but the
system is just completely hosed at this
point it doesn't have any knowledge of
these things happening except for an
angry customer and some log files and
maybe even it's just the log files so
this is what I was showing what was
shown to me about a year ago or so said
I had all these things that could
possibly go wrong something looks
something looks fishy but now we have to
decide what do we do based on all these
different failures well the current
choice we had in that system was just
yeah just like whatever let's just
assume that everything's okay and if
something goes wrong then we'll just
like send a sorry email something like
that but for most businesses that I work
with especially ones that actually take
money from customers which i think is
probably the vast majority of businesses
I don't know any ones that don't
actually take money just like throwing
up your hands shirking your shoulders
and saying yeah that's probably not too
good for business that's probably one of
the things you end up on like at Roy
hunts presentation sometime later about
how much you've screwed things up so we
can't just we can't just throw up our
hands and in fact the business probably
doesn't even know that we've done this
we've made this choice maybe we're not
made this choice explicitly but in our
code those six or lines of code means
implicitly that we've just kind of given
up here so going back to our picture in
an ideal world if there were no like
laws of physics or anything like that
we could put this entire operation in a
transaction so they're the entire set of
steps everything on the screen either
succeeds or fails if it's fails then
everything rolls back if it succeeds
then everything goes through and
everyone's happy
but we can't put the entire world in
transaction I know I've tried have
anyone use like the WS transactions the
webservice thing that works swimmingly
didn't it
so in here ever used a distributed
transaction coordinator than ms dtc yeah
yeah your operations people love that I
know it never goes down so we can't just
put everything that we use inside this
one single transaction even if it's
possible that makes the entire operation
go really really slow in fact a lot of
our a lot of our measurements show at
least an order of magnitude if not
several orders of magnitude and
performance drop whenever we try to put
everything that we have inside a single
transaction but we have these third
party AAP eyes that don't support this
kind of transactional behavior nor I
don't think they ever want to so we
can't put everything we have in a
transaction that's just not an option
for us so what we have to do is assume
that any one of those things failed and
then based on that assumption then
decide okay what should we do from there
if we plan for the worst thing that
could possibly happen that it should put
us in a good final end spot now when I'm
looking at evaluating okay we want to do
something based on each of these things
possibly going wrong we have to evaluate
a few options based on what is available
and those different providers to do
based on failures as well as what means
the most sense based in our business
about what we what each failure option
would satisfy their business goals now
luckily I didn't have to come up with
any of this stuff all this failure mode
failure options has already been put out
there and so the ones I was looking at
was a paper from Gregor hope this one is
your coffee shop doesn't use two-phase
commit and it describes what can happen
in a real-world process when things fail
and one of the different options we have
for dealing with that failure this paper
used to be called Starbucks doesn't use
two-phase commit but I think Starbucks
caught on to that and said we don't want
to be in your failure paper so now it's
just your coffee shop doesn't use
two-phase commit now in this paper
describes trying to coordinate
activities between two different
resources and one failing and what to do
when that other resource fails whatever
options to be able to deal with that
failure now the first option we have
when we have two resources we're trying
to coordinate in an activity and the
second one fails is simply to ignore the
other failure and just keep on going now
form a business perspective this might
seem a little weird to say we would just
ignore failure and go on with our lives
but in reality in the real world we do
have this kind of situation come up
quite frequently where we're trying to
coordinate two activities something
fails and we say well maybe the other
thing wasn't that important maybe we can
just keep on doing what we're we're
doing before and highly available
systems ignore is a as a really good
option to look at to make sure that we
can still have high throughput and not
try to put the entire world in a single
coordinated action most business I know
misses that I know don't really like
this option of just ignoring failures so
this may not actually come up in real
life a whole lot in our systems now the
second option we could look at is a
retry when the second action fails we
can just try that second action again
now this can present some problems for
us not every single action is retrial
and for that second action we may not be
able to retry indefinitely we probably
don't want to just keep trying this
action till the end of time so there has
to be some logic about when should we
stop trying to do this other action and
can another action even be retried in
the first place our third option is an
undo so in this case we're not going to
try the second option again we're gonna
have an undo or compensating action for
that for that first thing that happens
this again assumes that the first action
is undoable in the first place
maybe that's not a transaction kind of
thing maybe there's an actual
compensating action we can do something
like I've turned the lights on the
compensating action would be to turn the
lights back off again now the final one
that we have available for us is this
coordinated activity this doesn't
necessarily assume that we have a
transaction available to resources but
what we can do is design a protocol that
says I'll have a multi-step process to
coordinate these two things succeeding
or failing and it'll always involve a
third party coordinator to ensure that
these things happen so the first step in
this in this protocol is to first ask
each resource to prepare a transaction
now if anyone here has ever bought a
home that escrow or mortgage agent is
serving as this coordinator they sit you
down in a room and say okay do you have
that either cashier's check or something
that says I have the deposit for the
house yes you verify you have the
deposit they don't take it from me right
then they just they just they just make
sure that you have it then they go to
the seller and they say okay they have
the deposit is the final price okay with
you you're good to sell and hopefully
they don't back out of it because that
that's happened to me and that's a
horrible feeling but hopefully they say
yes we still want to sell the house for
this amount and the discrete upon date
and now that we have both parties
agreeing that they intend to do this
transaction now we go back to each party
and say okay let's go ahead and commit
this transaction that we're doing so
I'll go ahead and take the money from
the person and I cry a little bit for
all that money I just hand it over and
for the seller side and they go ahead
and sign over that deed and haney the
keys and facilitating all this is this
coordinator that we have this mortgage
agent this escrow agent something like
that now this is not a bulletproof this
is not a bulletproof protocol because on
that second phase of the transaction the
second phase of that commit something
could still get hiccup there so let's
say I took the money from the person
from the from the one buying the house
and I go to ask the seller okay you good
to go and then they have second thoughts
or they just leave the country for
whatever reason I've taken the person's
money and maybe I've even cashed the
check
but hopefully not and the other one is
has failed and is no longer there and so
now I'm end this like still in between
states so I'm even have to have even
more compensating actions to be able to
roll those things back now in systems I
work with that try to choose this option
this option only really works when that
coordinator is very close and highly
available to the things that trying to
coordinate the more I move that
coordinator away from the things that's
trying to coordinate the more likely
that this transaction is going to fail
so when you deploy this kind of
environment you have to put things very
close to each other to make sure that
they succeed most the time now you're
not necessarily forced to do something
like a distributed transaction
coordinator for this kind of operation
as long as I have something that can do
a similar kind of protocol this is a
valid choice for us now I've gotten my
four options for dealing with failure my
master plan here is to take each of
those four options and evaluate it
against each of the steps I had on those
six little lines of code and say for
each of those options one is this option
for failure even a valid choice for us
is it possible and two what does it make
sense in terms of the business
transaction that we're trying to do here
it's still important here that we talk
to the business to say basically these
options what should we do here because
the implications for failure and success
still will be bubbled up all the way to
the business so I have to get them
involved here hopefully not using terms
like distributed transaction coordinator
because there's nothing that makes a a
product owners eyes glazed over more
quickly and then starting to talked
about DTC program protocols at least I
hope you haven't done that so for each
of these external resources examine each
of the possibilities for dealing with
failures and pick the best option based
on the business requirements at hand it
sound good okay so the first step and
our list of resources that could
possibly fail is going to be stripe now
on the database side because we saw that
if that piece failed the transaction
wouldn't rollback and would be good to
go I'll go ahead and say well we could
just use that normal
debates transaction and call it a day
but for the other third-party resources
let's go and see what are those
different options for us so in our code
here just to just to remind you we had
that set of transaction code hitting our
database so we do control and then after
that database stuff then we have this
call to the stripe API so the first
option looking at is to ignore it is
wrap that stripe call in a try-catch and
if something fails just keep going on
and do the next set of steps that
probably doesn't make a lot of sense for
us to just ignore fail payment and then
assume that we can go ahead and ship the
thing to the customer I assume we
actually want to have a business that
can take money from customers and stay
in business over time so just ignoring
what failures and when payments fail is
probably not a good thing for our
business so that's not why I would ever
actually take to the business and say
hey is it okay if we just like don't
take money from customers is that cool I
probably get left out of the room so
that's just thrown out the door
immediately the section second option
for us on stripe is to retry now before
I think about the code implications or
what this at this stripe API even
supports it we do have to think about
what if that if that retry is even
possible in our code so in in the stripe
API basically what I'll do is I'll
Google the name of the resource and then
retries and see what pops up now not
every single operation is retrial in the
case of calling a stripe API if I call
the API twice and a retry it may be the
first one-time doubts but I don't know
if it actually succeeded or failed I
just I was waiting for response and
never actually got it some failures are
very quick some failures are slower and
those solar failures I can't necessarily
make that assumption that it actually
failed on the stripe side so what we
don't want to have happen is to take the
customers money twice because almost
worse than taking their money once and
not telling about it is taking the money
twice and double charging them so if I
want to be able to call
some kind of resource multiple times and
still have it as if it only had that
operation happen once there's a term for
this and it's called item Ponzi item
potency means they can do an operation
multiple times and have the same end
results item potency is not a medical
condition condition it's an actual thing
we can do with our systems so what I'll
do is I just Google resource name and
item potency and what comes up stripe
actually supports idempotent requests
now the way they do this is they have to
have some way of correlating a request
if I make it multiple times
they can't just assume like oh you got
this call from the same provider from
the same endpoint for the same amount
within like five seconds that must be a
duplicate well they don't make that kind
of assumption so what they can do though
is is me have some way of saying based
on me calling your API multiple times
this represents one logical business
transaction and so they have this in the
form of an item potency key I pass to
them some kind of unique identifier that
represents this business transaction and
on their side if they received that
request more than once they'll only
charge that customer for that one
initial call now because just because
stripes supports that doesn't mean way
to start calling it with any kind of
random data we need to make sure that we
pick something in our side for that item
potency key that represents that item
potent action so what represents in our
system the business transaction of
someone trying to place an order well it
could be a cart ID the cart ID
represents that logical business
transaction of me at trying to place an
order so maybe we can just straight-up
use that as our item PO and Sukie or if
we don't have that maybe we just make
something else up but something that
logically represents me clicking that
button and trying to place that order
and hopefully this kind of item potency
key I would want to store along with all
the rest of my business data but that
seems like a logical thing we can do is
say the cart represents me trying to
place an order so I will just pass the
cart ID isn't that as an item
a king now no mercy no picture here do
you have me actually retrying this
operation so we would still need to put
some mechanism to be able to retry this
maybe it's on the client side when I
click the button I would check to see if
the call failed or succeeded and if it
failed I go ahead and just post the API
call again or maybe there's something in
my server side that is detecting
failures and then retrying this
operation whatever it is by me using
stripe API to be able to pass in and I
impose a key I can ensure that if I try
to post this payment twice for the same
cart it will only charge the customer
once so our third option we had ignore
which was not a good thing
retry the third one is undo now undo
doesn't necessarily mean I have a
rollback like database transaction it
could also mean that there's some
compensating action that I do so for
stripe what is a compensating action for
charging a customer refund yes
so for this resource that I'm looking at
whatever might be I I tried to Google
what that compensating action could
possibly be and so in this case stripe
with payments an undo of a payment a
compensating action would be a refund in
stripe thankfully supports refunds
directly out of the box so what was this
look like in our code in our code we put
some kind of trycatch around the entire
payment processing and when something
fails I would check to see if I had a
stripe payment based on that stripe
payment object and if that payment
actually exists then I'll go ahead and
call the straight stripe API to say
refund this payment now in like real
systems they work with I don't I
wouldn't necessarily refund them
directly in this trycatch maybe I do
something like mark the order as needing
a refund and a human goes and looks at
it and says
oh maybe we can actually charge the
customer maybe it's okay for us to
continuous operation but for our
purposes let's just assume that we can
try catch and then undo that action
through the refund API call there's
still a problem here though if you
remember in that for this first supple
set of slides there is a database
transaction around all of this somewhere
down like here or there or maybe over
there somewhere is that action filter
that commits the transaction after those
requests this controller action succeeds
here and so that still has the
possibility of failure so what I'd want
to do is actually pull in that
transactional behavior into this set of
code so that around this entire a P I
call I will have that database
transaction set of code there so that if
the database transaction fails I can
detect that and then go ahead and refund
the customer and rollback my transaction
so far so good
so the question went up here is what
happens if the rollback fails that's a
great question so let's look at the
fourth option coordinate now that is a
that is a valid concern for us to say
what happens when this call fails right
here so we might have some more
compensating actions there maybe we
actually do log it somewhere that is in
a highly available format eventually you
have to get to the point where we tried
as much as we can to capture this
operation that's happening and the
failure modes but you can't ever
guarantee that everything's gonna
succeed all the time I mean I could try
to write the log to disk and the disk it
is full and it isn't write the log so
like eventually it should kind of be
like well we did our level best as long
as we actually went through this process
a thought process of designing it and
not just through our hands I think
that's a valid thing we can do our
fourth option coordinates now we already
said that this these API calls don't
support any kind of transactional
behavior that as I can't put a begin
transaction in transaction and have that
all just work magically
but I may go ahead and dig in some more
to these API calls and say does it
support something like that that's more
maybe not not like a bit like a
transactional kind of behavior but do
they support some kind of two-phase
commit for payments and it turns out
that even the underlying ACH
transactions support this kind of
concept has anyone logged into their
bank account and seen a balance in a
pending balance
well the pending balance is pending
transactions that have not yet cleared
for the day and stripe supports this
concept out of the box it supports it in
the term of this they call it
authorization and capture as a 2-step
payment flow and the general idea is
that I have an initial call to the
stripe API to authorize a charge which
basically is that that mortgage agent
the escrow agent that has taken your
money and put it to the side but not
quite charged yet just like I'm making
sure that you have this money and then
sometime in the future when I when I
actually want to go through the
transaction I capture those charges and
finally it's actually out of your
accounts and give it to the other person
now this one does have business
implications from the previous couple
steps in this case an authorization
actually shows up and your bank account
is this like money that's not quite
there but is there sort of thing so it
want to make sure from the business
perspective they're ok with this we're
not taking the money quite yet so the
customers may go in and look at their
account and see the money is not quite
taken out yet but hopefully the
likelihood of that happening the
authorizations succeeding but the
capture feeling is rather low and this
won't actually ever affect the customer
hopefully but I still need to put that
in front of my clients to make sure it's
ok so what does that look like in our
code more try catches surprise surprise
I would attempt to do all that stripe
transaction but instead of me instead of
me charging their payment immediately
and said I post an authorization to the
payment now assuming that is set of
operation succeeds then I'll have the
second
step and the the auth capture flow which
was to capture their payments and
actually take their money now I said we
had the question of what happens if that
second call fails or the robach fail so
I still would want to have some kind of
logging here to say oops I try to
capture the money but it didn't work but
this is and a little bit better spot
than the previous one the previous one
would take their money but if something
fails refund them this one will still
take their money but not quite take it
all the way so an administrator could
come back in and say let's go ahead and
go to my my transactions that haven't
succeeded and go ahead and capture that
money and I'll let the process and then
keep going but this is this kind of
weird situation where I could authorize
a customer's about accounts and have
that money kind of sitting in limbo so
I'd still have to go back to my business
to say which is the one that makes most
sense for you so those are the four
options in terms of which one we would
actually do we'd have to go to our
business and talk to them which one
makes most sense for us next up is sin
grid sin Grid is an email service
provider that provides a nice API
interface for me to send emails to
customers template eyes them and all
those sort of things as well so option
one ignore this one actually may be
valid do we want our entire business
transaction to fail because I can't
email someone probably not I'm probably
like well we took your money you
probably get an email sometime in the
future but I'm not gonna like not take
your money just because I can't email
you do we really want to tie the uptime
and business ability to conduct business
to a third party email service provider
probably not so ignore could be a valid
option for us and so it'd just be a
simple try catch try to call the stripe
API or the SendGrid API and if SendGrid
fails this log an error but keep on
going oops couldn't email you oh well
still gonna take your money
I still want to log it at least though
so I can let my my overall
administrators know like hey API is down
so probably stop emailing people all the
time and wait for that thing to come
back up option two is to retry so this
is where I'd go again to Google email
service provider SendGrid retry no hits
except for a lot of Stack Overflow posts
asking if it supports it
ok SendGrid idempotency lots of Stack
Overflow questions but no actual answers
basically comes back to sin grid
explicitly decided not to support any
kind of retrial behavior because what
their entire business models defined
through is whenever you call my API I'm
gonna send an email as quickly as
possible
you call me twice that's two emails you
don't want to call me twice don't call
me twice so we don't want to do retry
unless it's ok for has to have duplicate
emails now this is again something go
back to the business to ask and say hey
we can retry this behavior but we can't
guarantee that they only get that one
email is that okay maybe yes maybe no
but I need to have that business tell me
that option three is an undo no matter
how much we try we cannot unsend emails
even though you have like Outlook
Exchange server has that ability like
sometimes like people still read the
email and then gets deleted and you're
like you try to send to everyone didn't
you you actually see see the entire
company so we can't we can't like undo
an email that won't make any sense like
stead of send a follow-up email like I'm
sorry I sent you that other email maybe
that's an option for us is like oops
sorry apologize and and hopefully they
still stick with us as a business fourth
option is to coordinate I have no idea
what this would mean in terms of emails
smtp certainly doesn't support it so
we're just not if we can't this doesn't
exist
we'll just keep going to the next thing
so her final piece is RabbitMQ now it's
important here that I investigate the
actual broker we're using because every
kind of message broker is different in
the functionality they support on top of
that every most message broker is
different in in terms of what they
recommend that you actually do as well
so rabbitmq for example prides itself on
speed and how do they achieve that speed
by lowering the guarantees so RabbitMQ I
could through my options have that more
transactional behavior that means that
everything's going to get a lot slower
so I'll have to make that decision so
the first option what could be to ignore
I try to publish an event to the bus
onto RabbitMQ and maybe if it doesn't
succeed I'll go ahead and mark that
order as hey someone needs to like kick
that message down the road because it
couldn't work here I'm gonna have to go
back to the business and say look
sometimes RabbitMQ our broker can go
down so is it okay if we have an
administrator page that goes through and
finds orders that need to be like poked
to be able to send this message maybe so
maybe not the next option is retry now
this becomes interesting because most
message brokers that I work with don't
really have any concept of a retry a
retry is like send the message again and
so what does it look like in in rabbitmq
well for us if RabbitMQ fails for
whatever reason we can retry us to send
that message but it doesn't necessarily
mean that the first message actually
failed there are cases where I send the
message but I haven't received that
acknowledgement from rabbitmq that
actually sent the message and so I wait
for the acknowledgement and like I
didn't get one so let me go ahead and
try it again but that could still mean
that the first message actually went
through I just didn't wait long enough
for that acknowledgement to come back so
when looking at this option it's not not
just that I'm retrying
rabbitmq it's actually means that I'm
retrying everything that RabbitMQ is
talking to what
down stream brokers as could possibly be
so I'm not even thinking in terms of
does rabbitmq support any kind of
retries I also have to think about what
about downstream consumers can they also
support retries for this kind of
operation and if I can't guarantee
absolutely that they can handle this
kind of retry behavior then probably
this isn't a good option for me if you
want to support this idea of at least
once messaging over here I can send the
message at least one times on this side
but only have it delivered and processed
by each of these consumers on this side
there's a lot more smarts you have to
put in these little arrows that I'll
leave off as an exercise to the reader
smarts
now some brokers do support this out of
the box
they're here using as your service bus
so many hang out to two hands so as your
service bus does support the idea of
retries and the way they handle it is
they'll actually buffer the messages
upfront for like 30 seconds or so and so
if you send the same message twice
within a given amount of time they can
detect that and say okay whoops they
accidentally send me this twice so only
actually delivers to the back end once
but that again costs resources because I
have to store the messages somewhere and
they don't want to store the messages
forever because that's very expensive
right let me look at every single
message sent ever and decide if this
message has been sent before probably
not a thing you want to do in your
systems so I only want to do that for a
given amount of time but what happens if
I try to retry after 31 seconds well
that means duplicate messages in the
back end so option 3 undo okay this is
another weird one what does it mean to
undo a message similar to emails
I can't unsend a message to rabbitmq and
then if I can't unsend a message I would
have some kind of weird compensating
action on the bus like order created of
it second message oops I'm sorry order
not actually created my bad event
probably not a thing we do in our
systems so compensating message probably
not going to work for us
now the final option is coordinates now
some brokers do support a coordination
kind of activity that is I can in a kind
of a two-phase commit distributed
transaction I can do some kind of
transactional baby everybody here and
then on my message broker I'm basically
putting my message but with my finger on
it like I'm gonna put over here I'm not
gonna set it yet and whenever I said
things to see isn't like okay you're
good to go message to go out the door
some messaging transports support this
kind of behavior and missed some cue
does RabbitMQ does not again explicitly
they don't want to support that because
it's a very expensive operation for me
to be like putting my finger that
message but like I'm not gonna send it
yet I could've sent it oh not now can go
that's actually very expensive to do and
a distributed system so if I try to do
that typically I see an order of
magnitude drop and throughput and for my
system I don't want to do that kind of
thing radnik you doesn't support it
anyway so can't even consider it and in
fact I'd say almost all the brokers I
deal with don't support this kind of
distributed transaction coordinator
transaction behavior so I want to take a
step back because we've looked at the
different resources we're talking to all
the different options that we've all the
different failure options and personally
I didn't find any of them to be that
good like none of the none of the
outcomes of any of those different
failure modes I thought that the
business was actually gonna be okay with
like they may be they be up here with
like I guess we have to do that but that
kind of sucks so maybe maybe I should
rethink the entire process and say what
if instead of me coupling all those six
little lines of code together saying
they all succeed or all fail can I avoid
these kind of failure modes but perhaps
just breaking in my process into
multiple steps now in most ecommerce
systems I work with they don't couple
all these things together they don't
couple the creation of the order with
the ability to successfully send an
email with the ability to successfully
charge a customer when actually worked
in a large e-commerce company about ten
years ago or so we would we would be
measured our team was measured on its
ability to have someone start the
checkout process and completed
successfully
in fact our bonuses were tied to that
like literally we get bonus based on
making sure that everyone had started
the checkout process completed it and
anyone that started the checkout process
and like pulled out for whatever reason
my little bonus would go down just a
little bit it was very sad
so most ecommerce systems that use that
you use on a daily basis right whenever
you get to that checkout flow it's a
completely different user experience
than everything else Amazon for example
away go all those like buy Kindle buy
echo buy all this other junk that we're
selling you and collecting all your
information from and saying when you hit
that checkout button it's like all right
things getting real we're gonna take
your money so let's get you on this
train here you even have like a little
progress bar on the tarp that's just
like choo-choo here comes the money
train we're gonna take your money so
when it worked in e-commerce when we
were being measured on our ability to
make sure customers completed the
checkout flow that meant that we turned
off all of our validations like
literally if a cat walked across the
keyboard we would we would still take
your order we turn off any kind of
address verification like oh that's not
an actual valid shipping address don't
care give us your information oops I
transpose numbers and that credit card I
put in don't care just give us your
information Zoo one had that they turned
on and there they're quite they're
front-end ecommerce sites the the Loon
check or lunch egg I don't have an ounce
it where it's like if you transpose your
numbers it's like oh that's not actually
about a valid credit card number there's
some gonna check some and that thing
there's nothing that angers a customer
more than you telling them they don't
know how to type in a credit card number
like I didn't type for that right what
I'm going to check these 16 numbers and
see which one is is that like put my
credit card up to the screen no so we
just turned all that validation off and
said just give me information and at the
end of it if something goes wrong and
back in processing what do we do
we'll call the customer and that's how
we went from like 75% fallouts it's like
99.999% just turn off all the validation
now we have to go back and look at our
process and say what does it mean from a
business perspective to break each of
these individual steps out as a separate
process does that even make sense from a
business perspective that we don't do
this in the context of a button click
but we do it sometimes later now again
this is something we have to go back to
our business to to evaluate these
options and say based on each of these
calls is it okay if I don't do that
right away what if I do that just a
little bit in the future does that make
sense from a strike perspective can I
can I take their money now or can I just
take the money later well that may or
may not be OK for the business the
business may say oh sure yeah you can
you can take their money later or they
may say you know what can you actually
try to take their money now and if it
doesn't work then maybe you will go
we'll have some back-end processing so
we'll do something like trying to post
the payment to the end user but if
something fails then we'll do is just
mark that order as having a payment
failed and then some back-end processing
probably human would go through and find
all the orders that have payment failed
and then go ahead and charge the
customer or cancel the order
perhaps what about SendGrid
is it ok if we send their e send an
email to this person sometime in the
future do we have to send the email
within the context of the button click
is that customer clicking the button and
have their email client over my ok if I
don't get an email within like 0.5
seconds something's wrong probably not
email is an asynchronous messaging
system anyway and we probably don't have
an expectation that within the context
of like clicking the button then we get
that email delivered to us right away so
maybe let's not couple our ability to
take an order from a customer to our
ability to send an email now one
interesting thing we looked at here was
is there some way for me to is there
some way for me to like kind of
automatically send this email in the
future when do I actually want to send
this email is that when the transaction
succeeds maybe but in reality I want to
a your order was successful email when
I've actually successfully processed
their payment only when I've actually
taken their money do I want to tell them
thank you for reorder if I haven't taken
your money I'm not thinking you yet I
gotta give me the money then I'll thank
you and not before well it turns out
that stripe has the ability for us when
things when payments are successful to
do other actions in this case field
webhooks so we could use hashtag server
lists to have a web hook so when stripe
successfully processes a payment they
call some other API call that we make in
our hashtag service world and then then
go ahead and call the stripe API to send
that email successfully now in actuality
we still have to evaluate all the
failure modes of that web hook call like
if my API is down that's receiving the
web hook will stripe retry that
operation I scrolled down here to the
bottom and I didn't see any
documentation about what they do in the
case of failure so if I don't know I
have no idea what their failure modes
are this may not be a good option for us
if I want to I guarantee that email gets
sent the final one is RabbitMQ this
one's gonna be little bit funny and and
our ability to try this operation in the
future so the idea is that if RabbitMQ
is down I send the message to it
sometime in the future but what does
that look like for me to send the
message in the future well it could mean
that instead of me storing the messages
and trying to send the message over here
to RabbitMQ maybe I take those messages
and just store them in my business
database and says okay let me go ahead
and put the messages to be sent over
here and if this call fails then
something is going and putting and
pulling out these unsent messages out of
the database this is actually known as
the auth box pattern in the out box
pattern instead of me immediately
sending these messages to these
downstream providers I instead store the
messages temporarily in my
business database and some other process
is taking those unsent messages and
sending them downstream something like
this don't use this code it says really
bad code but you get the idea code is
pulling those unsent messages taking
these messages out of the database and
then forwarding them on to our bus here
now this introduces more moving parts
right I have to have this code somewhere
probably in a more resilient format than
this that is polling for unsent messages
and fording them on but what this allows
me to do is completely eliminate the the
rabbitmq part of the equation out of my
process so if it goes down
I don't care whatsoever we can just
store the messages temporarily in a
business database and have something
that's kind of cleaning out cutting up
things behind the scenes we're still not
there yet though I took that first step
back I'm gonna take yet another step
back and say okay these are the
different failure modes in that single
context the button click what other
possible options are there for us to
decouple these six lines of code from
each other right now there's still six
lines of code as a couple to each other
I've just temporarily remove some of
them from the processing are there other
ways I can handle this overall business
transaction
so in these kinds of processes I start
to look at can I defer these actions to
sometime in the future one or more of
them in the options I've had hat I've
had now I've kind of taken each
individual one by itself but what I
could do is take a look at do way
instead of me having all of my kind of
check out order processing process
directly in that button click handler
can I take that workflow of processing
an order and just completely remove it
from the front-end code altogether and
have some kind of back in a synchronous
workflow to actually process your order
which is what like 95% of e-commerce
systems do they don't do everything in
the context of a button click they take
the thing you were trying to do and say
right we're going to have some
a back-end processor they will take your
information and actually process your
order so again I have to go back to the
business and say look we had the
possibility of performing this checkout
flow instead of within the context your
button click but to do them offline for
each of these things that we're doing in
the button click can we do these offline
instead and it make that evaluation
again stripe is it okay for us to
process this offline they trade off
being that I don't take the money right
away
but I maximize the number of people they
can make it through the checkout process
minimizing my fall out rates and
maximizing my bonus hopefully right is
it okay for us to process that I'll find
maybe sometimes it's not okay to process
your money offline sometimes there's a
finite resource that I have to make sure
that I charge your money right then
things like airline reservations things
like concert tickets these are things
that there's a certain amount of these
things in existence and so I really want
to make sure I take your money right
then because if I don't that could
potentially mean I oversell and
accidentally have too many people buying
tickets but you guess Airlines still do
as well but so this is something have to
look at the overall business transaction
to say does that even make sense is it
okay for us to do that but for sure the
other two things are okay to do offline
like I don't really care if I email them
right away nor do I really care if I
notify downstream systems right away
RabbitMQ especially I'm already using
asynchronous messaging so I can just
delay that asynchronous messaging just a
little bit more now we have to be able
to kick off this workflow somehow when I
click the button on the page
something has to take that order and
then start to do its processing now in
this case the depending on the platform
are using there could be a lot of
different possibilities for me to handle
this if I manager for example you can
use Azure service bus and service
workers to take that message and do
something if I - self hosted
environments I may be able to use a tool
like hangfire which allows me to do
scheduled jobs
and do some processing if I'm using
something like Python Django I can use
celery if I'm using node I'm probably
using like left pad or something I think
to do stuff I don't know
so in this case I'm using hang fire hang
fire allows me to have scheduled jobs
inside of an asp net application and so
I tell it based on this chrome sorry
this cron format down here that I look
up once and forget immediately and have
it execute on some recurring jobs who
say let me go ahead and take those
messages that say process the order and
then some send them in the future so it
looks something like this now my initial
call to start the order is no longer
going to do any of these things behind
the scenes it is literally just taking
your information storing in a database
and then something behind the scenes is
taking those unprocessed orders and then
doing some kind of workflow magic behind
the scenes to then go to all my
different providers and do stuff so the
last thing I like want to look at is
what should this workflow do how should
i design this workflow there are a lot
of different patterns for these workflow
options behind the scenes about three of
them are documented the rest are just
like make it up as you go so I want to
go through this workflow options say
what makes sense for this kind of
operation the first workflow pattern we
can look at is one known as a routing
slip and a rounding slip we have a
sequence of operations and the sequence
is determined upfront by whatever
initiates the process and as each step
executes successfully it forwards that
process to the next step
that message just they do the next thing
so it looks something like this I'd have
each of these and some kind of back-end
processing with their own message queue
this initial task pushes a message out
to the first step the first step
succeeds forwards the message on to the
next step this one succeeds in a 4-time
that next step and this one succeeds and
then then we're done
so we and the initial calling we'd
actually say the individual steps you
want to send to now this makes sense if
I can have some reasonable set of
guarantees that all these steps are
going to succeed or fail if I have any
kind of alternate processing like what
if this one fails do something else
then this kind of this kind of pattern
doesn't really work that great because
now putting failure alternate logic
inside each of these steps another
option is the saga pattern a saga is a
way for us to have a long-running
business transaction broken up into a
series of smaller transactions and each
of this smaller transaction either
succeeds or fails in the case of a
failure I have a series of undo actions
that rolls back that overall business
transaction into the original state so
the the kind of canonical example we see
out there is going to be booking a
booking a trip when you book a trip
you're going to book a rental car well
maybe not anymore maybe I'm just Boober
I don't know we'll have a hotel and
we'll have a flight and I can't get
everyone on the phone together on a
conference call and be like all right
everybody on the phone we're gonna book
a trip that probably won't go over too
well they probably hang up on you so
instead I break those up into a series
of smaller operations and say first we
have booked the rental car when that
succeeds we're gonna book the hotel when
that's to see if we're gonna book the
flight but if this this transaction
fails there's something wrong with my
fight then I'll go ahead and undo the
previous operations this is only
possible though if I have the ability to
undo previous steps and as we saw what
feels like three hours ago we don't have
the ability to undo all of our
operations so this one I can't just take
this pattern out of the box the final
pattern is the process manager pattern
which basically says well in all of
those out-of-the-box ones works for you
so you just to make it up this is also
known as just like workflow or state
machine this is you're going to design
explicitly what the pattern should look
like and so in this case I have some
kind of central process manager that is
managing these different operations in
the back end everyone here has probably
already built something like this
you have that table with an is processed
flag and something's pulling it and
doing stuff behind the scenes you've
already done something like this the
final a little wrinkle in our system is
to decide how we want to coordinate
these other activities in this case
there are now two more main patterns we
can look at orchestration and
choreography orchestrations means that I
am directing the flow of every single
step and choreography means that I am
pushing an event out and then waiting
for everything to come back and tell me
if it succeeds or fails so in in this
case I have to decide for each one of
these interactions do I want to
orchestrate that operation that is
directed exactly what it should do or do
I just want to throw out a message and
say when everything's done come back and
let me know so I would go back to a
process and say based on the process we
intend to have do we need to orchestrate
that activity to make sure it happens
and know when it succeeds or fails or
can we just choreograph it and just say
let's let the message be free and then
go on with our day based on a process
coupling I can look at stripe as a thing
I want to directly orchestrate I want to
know when stripe succeeds or fails
because only when stripe Sassy's or
fails do we want to do these downstream
operations so let's put some control on
this operation and then these other two
are going to be just sending a message
out the door so our final process would
look like this we have that initial call
to the API to create the order and
stored in the database at this point
though the customer sees - Thank You
page and they're going on with our day
behind the scenes we're going to have a
our back-end task processor that's
looking for unprocessed manages
unprocess orders and kicking off this
back-end process manager the back-end
process manager is going to read the
order information out of the database
make that call to stripe and based on
their call returned from stripe say did
you succeed or fail if that stripe call
failed then may we mark the order as
having needing process to be payment
manually but we
and stop the process and say you know
what if stripe fails don't do any other
is these downstream operations if it
does succeed then we go ahead and just
call these other things now the final
piece I have is I was using RabbitMQ as
a means to notify downstream systems but
it turns out syn grid is another kind of
downstream system I can notify so what I
do is actually piggyback on top of it
that initial publishing of that message
and have send grid just do the exact
same thing now you might ask what do we
actually go with in our real-world
scenario in a real-world scenario we ran
out of time and budget about 60 slides
ago in actual big of e-commerce
companies this is the exact thing that
we do behind the scenes we have just
taking your order information upfront
but having a back-end process actually
do the work in our example we went with
the the refund option trycatch refund
because that's all we had time to do so
the more of the story from all this is
yes it's super easy to build distributed
systems now and that it's possible but
that doesn't mean that failures can't
happen so when you're building systems
that have to talk to each other think
through the possible failure modes and
design the overall interaction based on
what the business needs and also based
on what's actually possible with those
other resources so thank you very much
this has been six lines of fail that got
multiplied into probably 50 lines of
code but that's okay our business is
happy we get to keep her job thank you
very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>