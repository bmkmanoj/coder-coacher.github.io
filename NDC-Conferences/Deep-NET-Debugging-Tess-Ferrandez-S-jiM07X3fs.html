<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Deep .NET Debugging - Tess Ferrandez | Coder Coacher - Coaching Coders</title><meta content="Deep .NET Debugging - Tess Ferrandez - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Deep .NET Debugging - Tess Ferrandez</b></h2><h5 class="post__date">2017-04-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/S-jiM07X3fs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome everyone to an hour of
dotnet debugging this is going to be fun
it's been a long time since since I've
presented but not bugging actually and
but the things that we're going to be
looking at well starts good let's see
okay let's debug that for a moment
since the slideshow um
don't use percent reviews okay oh okay
hey thanks for debugging that for me
whoa okay so we're starting over
welcome to an hour of dotnet debugging
we're going to be debugging those kind
of issues that you can't really
step-by-step debug so essentially
crashes performance issues and memory
leaks and when you can't step-by-step
debug you have to resort to something
else and that something else is
generally either profiling which we'll
be looking at a little bit Andy in the
performance section but also mostly
memory dumps and many of you use memory
dumps okay oh I see so for those of you
who don't know memory dumps come in two
flavors they're either user mode dumps
or kernel mode dumps so user mode dump
is a snapshot of a process at a given
time and everything that it like all the
memory that it addresses as it's kind of
like taking a picture or stopping at a
breakpoint you can see whatever is there
right now but you can't move forward
you can't move backward but you can
investigate traces of what has happened
already and if we look at the memory
dump and we're going to look at it in
window buddy first I'm not actually
going to use window cheat all that much
throughout the presentation but
yes for those cases where you actually
want to go really deep down when the
Vitesse is a great tool so when GG comes
with the debugging tools for Windows or
the drivers SDKs are really pretty much
any windows vista case so you probably
already have it on your machine even if
you've never seen it before and what
we're going to do is we're going to go
ahead and open up the crash dub that I
get earlier and and I put a few commands
here on the right-hand side or left hand
side and can you see them in the back
perfect so this is you so that you can
follow along what I'm going through what
you can see in a memory dump so a memory
dump has a few things when you start up
like it tells you how long the process
has been up how long the system has been
up so in this case the process has been
up for 25 seconds and the system has
been up for 2 2 hours it also tells us
that the memory dump was taking with
something called proc them which is a
tool for gathering them and it tells us
that we through the CLR exception so we
crashed due to an unhandled dotnet
exception and then some things that we
can do are for example tilde star KB
where tilde means thread star means all
so all threads run the command KB which
means show stack so what we're doing
here is we're basically displaying all
the stacks of all the threads in the
process and if you disregard this piece
which is used addresses or some
parameters in this piece on the right
hand side should look pretty familiar to
you if you've ever debate anything in
Visual Studio or any other tool so this
way you can kind of investigate and see
what the process is doing we'll see a
few things that are specific to dotnet
processes like the finalizer thread
which is the thread that goes through
and calls all your destructors so if you
have a class in dotnet but has a
destructor that will get called on that
particular thread
that means that for example since there
is only one and that if you're blocking
the finalized thread you're going to
cause a problem you're going to cause a
memory leak because nothing else can get
released and also if you is it so an
exception in in a destructor it will
crash your process and we have a few
elsewhere so this thread has some weird
function names on it
presentation core something something
not readable and this is because dust a
window which he doesn't understand
dotnet it is the native debugger
this thread actually happened to be the
thread that caused the crash so we're
kind of interested in what went on there
and in order to be able to read dotnet
code you have to load in an extension so
we're going to load in something called
SOS and we do that by calling low load
by SS CLR which means that we're going
to load in the expansion CLR or SOS from
the same place where it found see a
large of yellow which is main dll in in
the.net framework so if we go in and
look at shame used to see the extensions
we have will see that it loads it from
the framework which is important because
it tells you that you will always have
SOS you don't have to download it from
anywhere else as long as you have the
framework installed so we have that
actually now we can run commands like
CLR stack and it will always throw an
exception in this case on the first one
but ignore that and now we'll see
something that looks a lot more than
what we're a lot more like what we're
used to so a dotnet function but next
button onclick calls into view model
like a function called go to another on
a view model and that in turn throws an
argument out of range exceptions so
right now we're already done
investigating this crash essentially we
found out but this particular stack cost
the crashed through a argument range
exception and we'll look at the code and
we're done
but we could do more things so we could
for example run dump that garbage or for
short DSL and that will give us the
objects on the stacks so pretty much
like when you stopped in window G you'll
see all the objects on the stack in this
case we'll see a five argument out of
range exceptions that seems kind of like
a bit excessive but it turns out this is
the same one we can see that because it
has the same address but it shows up in
multiple frames in the stack like
multiple stack frames and therefore it
shows up multiple times on the stack but
we can go ahead and and dub this out
with dump Bob it does that automatically
when you click on it and and it will
show you the the actual object so you
can go ahead and investigate it and find
out what's in it it also tells us a
little bit more about the object like
it's 92 bytes big these 92 bytes is used
for the structure of this this object
not for the member variables and if we
want to know the actual size of the
object itself and all the member
variables we'll run something called
herbs herbs slice and we'll find out
that including the member variables it's
6000 right and then we can go in and
dump out like the message for example
and find out the actual string of the
message so why would you want to write
that for example the herb sighs well
it's useful for if you want to go
through an ace to nest ohms and find out
how much is in cash then you would do
objects lies on the cash object and you
will find everything that's in cash and
so on and sometimes you might want to
know why an audit is not being garbage
collected and in that case you just take
the address of the object and you'll run
a command called GC root and that will
tell you basically the roots of the
object so why is still sticking around
so this particular string is a member
variable of an hour argument at a range
exception
we already knew that and it's part of
like a try/catch on a thread so that is
white sticking around so as long as
that's alive it will be there and when
that's dead then it can garbage
collected and then we can find a few
more things like so these are all things
that you would find in visual studios
you you start it at that exception but
we'll find a few more things like LM
which lists out the modules in the
process so this will list any DLLs or eh
C's in the process and a useful thing
with this is for example if you click on
this which happens to be the name of the
process we can find out the version
numbers of the dll's and stuff like that
so if you get a memory dump of a
customer's machine you'll know what they
are running the same version that you're
running or the partes or what happened
and finally when you're debugging memory
issues you might want to look at the
heat so what's on like all the darknet
Hobbiton in the process so you don't run
for example a heap - GC which will give
you information about here we have three
Meg's of dotnet objects super small but
it was only up for 25 seconds and and
then you can also run things like dub
heap that start and this is kind of
where it gets a little bit very
interesting because now you can
enumerate every single object on the
heap so every single object that's in
the process which means that you can go
in in a processor you don't actually
have to own this process you can be
running for example office take a memory
dump and you can go in and look at every
single string that is in the process
office including if they have API keys
to the distance store in there to to do
API calls be a bit careful if you don't
encrypt your API keys and stuff like
that because you can find out a lot from
memory
if you're interested so this is like a
little bit about what you can find out
sometimes so where did we go so you can
find out threads call stack stack object
modules like the dll's and it sees and
the darknet heap and basically anything
that's in the process so how would you
gather these memorandums well a couple
of different ways and the easiest way is
to just use task manager right click and
choose create user and this is useful if
you have a process that's hanging or a
process that has a memory leak and you
just go in and do this and it's a
perfectly valid memory DOM and the only
few carrots amazed is that if you run a
32-bit process on a 64-bit system it
will gather a 64-bit dump which is a bit
harder to debug and if you if you want
to debug something like a crash the task
manager doesn't allow you to like wait
for a crash to happen and then created
momentum but then you can use Proctor
programs is a free tool from
sysinternals and
the best thing about it is that it's
super lightweight so it's just a small
exe you can take it copied over to your
server and run it there and you don't
have to install it so you don't have to
get permissions to do like to do big
installs or whatever used run it there
and this is actually fairly fast and
even capturing super large domes and the
thing about it is that you can also
configure it to do certain things like
over here you can see - H means that it
will wait for a window to stop
responding and - see you means that it
will wait for the CPU to go up in this
case over 90% or - EU means that it will
wait for the process to crash and then
you have a debug diet which um is both a
crash gather anima analyzer so
something that I worked on for well
quite a long time ago when I got tired
of writing or CLR saggin all these
windbg sessions and I decided that
automation was king and I wanted to
please have machine do it form instead
and I basically automate them myself out
of a job but that's cool but debug diag
is pretty powerful both for capturing
dumps and for analyzing dumps
so for capturing dumps it has like a lot
of nice UI as things for setting up like
gather done but this specific exception
are whenever dispersed counter hits this
value or whatever it might be and it's
also good for native leaks which we
won't talk about here but if you have a
native leak that's good and for
analyzing memory dumps we've seen how
you can do it in window beachy and but
you can also do it in D by diagram we'll
use that a lot it has a lot of analysis
scripts already written you can write
your own analysis scripts if you have a
specific issue that happens over and
over again you just want to verify that
the 104 stubs that comes from your
customer also has the same problem yeah
go ahead and write the script for that
and it will report it will generate
reports like this HTML report telling
you pretty much exactly what's going on
in 80% of the cases and then we have
Visual Studio so Visual Studio is got an
insanely good at reading memory dumps as
well and we'll be looking at how you use
that so we'll start off with a crash
so if you're lucky someone comes in and
says something like this well maybe so
like if someone's or something like this
but and at least if someone gives you an
error message like this you have
something to work with
like you have a repro scenario and you
can probably start figuring out what's
going on but more than often and the
person the app is crashing for is like
my mom who comes in with this message
saying hey Tess the internet ething is
not working anymore they're going okay
so does that mean it's not serving pages
or it's that mean it's just going away
hmm so then you ask
so mom what what were you doing it's
just like I didn't do anything so if she
didn't do it then who did it well for a
crash particularly there are only a few
different things that could happen with
kosta crash
the most common one is unhandled
exceptions so first you have the
exception occurs you have a chance to
put it in a try-catch block if you do
that nothing will happen but then if we
don't do that and you let it just go up
the stack then it will cost it'll be a
second chance exception and it will
crash your process in cases like asp.net
you'll have an unhandled exception
handler that released output like the
white screen of death and/or if you do
it on the finalizer it will still crash
but in WPS or in other processes the
second chance will kill your process and
then you have a few other exceptions
like Stack Overflow out of memory and
safe little execution and an exception
that will never go to second chance and
the reason for that is because if you're
in a stack overflow exception so if you
if you're in a case where you're in a
recursive loop and there is no more
stack space to be had
then you can't really have another
function handle the exception so there's
no way to handle a sec overflow
exception same thing would an out of
memory exception if you're running out
of memory you don't have any memory to
do the handling itself and the execution
engine exception is basically when there
is a bug in the framework somewhere so
something that causes like a native heap
or a.net heap corruption or or something
like that
and finally um um this might come as a
surprise as florists like a class but
and you'll often also see when when you
have what you think is a crash it's
actually like someone trying to recycle
the process due to them is reset or some
recycling mechanism for example in
expert net and so when you go through a
crash this is like I put together is the
one two three of what you do because
it's really that simple
first and you should always do this
check the Event Viewer and then capture
dump on crash and look at the faulting
stack and crashes are extremely simple
in that case because once you've
captured the number in the crash you
will know that whatever cost it was
essentially what caused the crash
whatever triggered the dump it could of
course be that it is for example another
memory exception in which case you would
have to investigate like a memory leak
or something but in most cases it will
be a second chance exception so we're
going to look at that and and we'll have
this app here she's listing out all the
precedents as of right now this will be
old by lunch but um and I got this error
for saying that whenever it's like next
like this it just stops like it exits
and what we're going to do is we're
going to go ahead and and grab a memory
dump using proc dump for this
so we'll do prop dumb - ma ma means mini
dump with all all options which is most
often what we'll want some then dump
with all options is actually a pretty
victim and then we'll say the name of
the of the process so the proceed and
study XE or we can give it to pay
difficult multiple and I call the same
thing and then we say let's wait for an
exception and I hope to start this so
there's something to attach to and now
it's waiting for the crash to occur so
we'll reproduce it again and there we go
so notice how easy it is to gather one
of these domes so we've already seen
this in windbg now if you troubleshoot
it you're going to run to the star KB
you're going to run CLR stack you're
going to look at the dumpster garbage
would be so and so we're going to look
at this instead in debug guides and this
is it lift the same dumb but
pre-prepared um unless debug daya do its
default analysis which is a crash hang
analysis and it will then output this
which is pretty much like without having
to know all those commands you can still
get really useful information like we
had a system argument are the range
exceptional threat zero
now we'll go in and look here here is
the stack again and we can go ahead and
investigate like they go to another
method and actually it also says that it
had some previous stuff net exceptions
as it will list like any exceptions that
are actually in the in the
process that might be useful for further
troubleshooting and here again we have
the argument out of range exception I
wanted to point out here that it also
lists that we have these three
exceptions that I was talking about like
the out of memory exception the stack
overflow and the execution engine
exception I want to point this out
because this does not mean that these
exceptions actually occurred this means
like these are in hair always because
they can't be generated when they
actually occur so they're pre created at
the startup of the process so that needs
to be thrown when needed now there is an
even simpler way to look at this issue
if if you have the symbols lined up with
your source code and the way to do that
is by opening the dump file in a visual
studio inside and it will come up and
will say it was the dotnet exception
here are the modules that you see with
alum by the way and we can go ahead and
click on debug lid managed we can choose
debug would manage tor debug would mixed
if we also want to know the native
stacks but we're going to do debug okay
did I okay let's do this instead I think
I must have recompile or something so
I'm going to open up the actual dumpster
tweeter
because if you have everything lined up
it will actually point you to the exact
place where it failed so I think this is
super cool it also gives you like the
stack it gives you the local variables
so you can go in and inspect them
yes TAS if you were stopped at the
breakpoint and this is even if the dump
was taken on another person's machine as
long as you have the proper symbols that
match up with a code so check the event
for your open we didn't do that and so
if we would have checked the Event
Viewer we would have actually seen this
which means that we wouldn't have had to
debug at all but what's the fun in that
so don't check the Event Viewer
and once you haven't checked the Event
Viewer then capture dump and crash and
look at defaulting stacks let's go on to
performance issues so performance issues
come in the form of like the app is not
responding or a request take too long if
you have a request that takes too long
it's very important before you start
troubleshooting that you actually figure
out what the actual response time should
be so you know when you're done with
your investigations and and then it can
also be something like the CPU is going
haywire so you might notice in in task
manager that the CPU is going bad and
again who did it well we have two kinds
of performance issues low CPU and high
CPU so low CPU are when you're waiting
for an external resource like a database
or a web server or something or if
you're in a deadlock and then high CPU
is if you're in a busy or tight loop
obviously and or if you manage to get
high CPU and GC so something that gets
your high CPU and GC will be for example
allocating a lot of large objects
because if you're allocating a lot of
large objects you'll generate like so
you've trigger a
full garbage collection every time you
you create a large object so that means
that for example if your concatenate in
large strings which are immutable so you
create new strings all the time then
you'll get into a you'll easily get into
a high CPU and GC issue and again how do
you how do you fix these will you
determine if it's high or low CPU this
is more to target your solve and kind of
have an idea of what you're looking for
and then you capture one or more dumps
preferably more because then you can
compare and see did we actually make in
a progress between these like or are we
stuck in the same place or even if it's
a high CPU issue you might want to see
if if you're if you're stuck in like
similar places all the time so we're
going to look at one of these and we'll
have this one so I'm going to click on
this product and it takes about two
seconds for it to stop spinning or 2.8
seconds for it to stop spinning so I
think that is a bit of an issue and I
want to find out what's going on so I'm
going to use this thing called Mettling
which is something I found on github
it's a load tester of sorts and like
basically spin sauce a number of threads
and it makes a few requests so it's a
very cheap and easy load test Erb not
very sophisticated but still it's
perfect for this so while we're doing
that we're also going to look in task
manager to see if it is a high or low
CPU issue and if you can't see this in
the back then basically narrate it for
you so I'm going to run this and the CPU
here is somewhere between zero and two
percent off we're looking at 2 W 3 WP
process so very low CPU issue so we're
waiting on under an external process
probably so we're going to run that one
more time
but this time we're going to grab a
memory dump when this is happening and
we can open this up again we could have
opened up on window BG but we're going
to open it up is that in deep idea three
and run a crash hang analysis to see
what I don't have more files to see
what's going on
and this will now check for a few known
issues that didn't make high CPU issues
and low CPU issues and then it will
report back and say that we have eight
threads sitting in a wait so we're
waiting for something else to happen and
then a few threads sitting in garbage
collection and then it gives us a whole
lot of other useful stuff like it tells
us what the threats were that used up
most of the CPUs so this was a CPU bound
issue you might be looking at what's on
thread 20 in this case it's not so we
see it's been using a minimal amount of
CPU but if it was this was where he
would look for it and it tells us bit
about the threads and then it also gives
us some information about the HTTP
context so what it actually does here is
it is does a dumpy stat or a dumpy empty
or like all the HTTP context and it then
prints it out print out some important
information like how long is this man
running and what is the URL and so on
and what thread is it running on so this
seems like one of the culprits because
it's been running for two seconds still
running and we want to look at thread 28
to see what's going on and here we get
the call stack but we also get
information like eight threads are
running the exact same stack which means
that obviously that is an issue that we
need to investigate but here we get the
calls back again and we see products
controller so we did slash product
that calls into data service get all
products and that's reason sits in a
wait so this time to go in and look at
the code in the mesquite or if we want
to take it one step further we can go in
and open it in window BG so we grabbed
from here and again I can do managed or
mixed I'll do mix just for fun and but
this time it doesn't stop it and show us
the code and the reason for this is
because there was no active thread when
this was taken because we didn't get it
on a crash so we didn't get it on
something that actually triggered um we
just took a dump as if so what we're
going to do then is because we're
interested in looking at the stacks of
all the threats so we'll go in in debug
windows and parallel stacks this is
something that you can use even when
you're normally debugging doesn't hurt
to be from a memory dump and and it will
then tell us that eight threads are
sitting in this and get all product and
sitting in a wait and if I actually
click on this it will take me exactly to
the line that has the issue so very
powerful stuff right and some time so if
it will go back to this first so
determine if it's a high or low CPU
capture one or more dumps look at all
the threads and what they are doing and
basically go from there but sometimes
and you can't capture it closely enough
because it's such a small performance
issue but if you can reap road and test
in that case you can use profiling
instead so we're going to look at one of
those issues and and it's going to be in
the precedent app again see I just want
to make sure that it has shut this down
because otherwise I'm holding on to the
symbols
and so what we're going to do is we're
going to troubleshoot an issue that goes
something like this when I click Next
you see sometimes it kind of stops on
the leg and doesn't move forward for a
little while
so what if figure out what is causing
that delays and the way to do this is to
go into the analyze performance profiler
window in visual studio tests a lot of
different profilers and specifically for
this issue we're going to use the
performance wizard so here we can
actually go in and and like profiles
anything with an profiler running or
installed app that we don't necessarily
need to own it but if we own it and have
these symbols and source we're going to
get a lot better results but we can put
a good profile a spin attached to here
and you don't actually have to launch
them from here so we're going to start
up and you get a few options for how you
want a profile in this case we have a
low CPU profiler a low CPU performance
issue and but you have CPU sampling or
instrumentation for performance issues
so CPU sampling what it does is it goes
in from time to time and slices and to
see what's on the stack what's on the
stack what's on the stack with some
stack and based on that it determines
how much time you're spending on the CPU
the instrumentation one injects like a
call before like every time you make a
call it injects marker
you called it you exited you called it
you exited and that way we can get what
we called elapsed time so not CPU time
but the actual clock time of the of
what's going on so we're going to run
this and and once it launches or we'll
just reproduce the issue a little bit
and then we're going to start profiling
I profile this a number of times you see
and then it tells us something to do
what what did things be the problem is
so let me see because it looks a little
bit different than it used to it gives
me a bit more information than I
actually wanted to let's go in and look
at this in a way so we spend most of our
time in with many pretty much all of our
time in Maine because that's obviously
used to running the passes and out of
that we spend 57% can you see this in
the back a little bit yeah 57% we spend
in next button click and that's actually
the time we're interested in because
that's where the issue happens out of
that time pretty much all of that like
all 57 something is in this go to
another function you can see how my code
down here actually follows the law and
when I click on that out of that we
spend most of our time in this Sutter
for this property and in the race
property changed and Indian bulk and
then we come into something that looks a
little bit weird but if you're doing WPF
for uwp you know that it's like it's a
value converter so you have something in
the view model and then you want to
display it in sam'l to use a converter
so in this case it was I took the
president's party and converted it to a
color display and then most of that time
was spent in get color and then most of
the time was spent in a wait so most of
the time was spent here and now we've
been able to narrow down and find out
the exact sources of this performance
issue in just a matter of minute so use
profiling is you if you have issues that
you don't feel like that are large
enough for you to actually go in and do
a minute and do a dump on okay so the
last type of issue memory leaks
same thing in there you can might see
out of memory exceptions slow response
times due to GC activity if you have a
lot of allocations and such and you
might also see something like the memory
increase in task manager that's usually
the and the most common reason that you
go in and try to troubleshoot a definite
memory leak so you might think that
since we're running with a garbage
collector like the memory should
automatically be garbage collected and
that is true except for it will only
garbage collect whatever you tell it to
garbage collect or rather whatever you
don't tell it to not garbage collect so
a few things that it won't garbage
collect obviously is things that are in
cache or session state if you told it to
cache it or if you told it to keep it in
session state it doesn't doesn't collect
it until it's it's supposed to go out
there or if you have a static or pinned
object or if you block your finalizer
and you could also have issues like
assembly leaks so some constructs and
does not like a regular expression for
the XML serializable use anymore but
those will generate dynamic assemblies
and so be careful and look at we have
like what LM you'll see if you have a
lot of assemblies in there and then it
might be a native leak and in that case
you want to do leak tracking with debug
tags but again pretty simple three-step
process you can capture mini domes
capture multiple dumps and the reason
why I want to capture multiple dumps is
because then you have a better chance of
comparing two dumps and seeing what it
is that you leaked people so one for
example when when you start the process
one when you leaked a little bit and one
when you leaked a little bit more and
then you compare with dump heap stat for
example to see what objects you're
leaking so basically what where the
number is growing the most
and then you use GC root to figure out
why they are still around so again a
fairly simple process enough for native
leaks use leak tracking in debug so in
this case I'm actually going to go in
first with window bitchy or nothing with
window cute would Visual Studio and I'm
going to open up a memory leak
dumpster-dive generating form it's one
point four gigs of addressable memories
of probably around seven or eight
hundred Meg's of actual memory just
using so I'm going to open that up and
there is an option here to debug a
managed memory so what this will do is
it will take a look at the memory dump
and it will look at all the objects
enumerate them would dump it start and
well equivalents and then it will look
at all the routes it will look at all
the statics all the pins or the threads
anything that could be holding on to an
object and it will generate graphs for
for those this is actually something
that you can do when you're step-by-step
debugging too if you're opening at the
DIA in Diagnostics window in the visual
studio there is a take snapshot and you
can take a snapshot of the manage teeth
and you can look at the heap like this
so I'm actually going to go ahead and
insert a mother memory dump that is my
base memory dump so this was the one
that was taken before the memory leak
occurred and then I can go in here and I
can sort by inclusive size so this is by
taking off size for the size including
all the sub object and say okay so it
seems like this news controller so when
someone went to slash News
we're leaking 31,000 of those and that's
taking out a total of like 368 Meg's of
memory so that's definitely an
interesting character
and we can also see that we're leaking
like a similar amount of HTTP context
the response or request so probably
what's going to happen this will sticks
to one leak we're going to fix the other
ones too because they they're kind of
members of one another so to speak so
then the visual studio will give us this
neat little thing which is GC root the
visual version and that tells us that
this news controller like 31,000 of them
is held in like this view data recovery
I don't know what that is but this thing
I do recognize like a cache item removed
callback so what this is is like by now
you start like googling okay cache item
remove callback if you don't recognize
what that is and you'll figure out
what's going on but what is happening
right here is this and I'm cashing
something and then I'm saying when the
cache is removed like when this item is
removed from cache go ahead and call
this function because I want to clean up
some stuff and this function belongs to
the news controller and since we're
using an instance function rather than a
static function this news controller has
to be around as long as that other
object is cached which is why we're
leaking in the news controller so the
answer here would be to use a static
function but what I really wanted to
show is like how you find the route the
routes are kind of irrelevant because
the the issue will always look the same
independently of what the routes are you
can also go in and troubleshoot this in
and debug DAGs
and we'll go ahead and see them Adams
and the league too sometimes you might
want just a little bit more information
than you don't done you don't remember
all the commands and everything so in
that case I always run with debug dag
yes because in
he forgot something then debugged I've
usually always picked something new up
that I can use as a clue it takes a
little bit longer for Dubai dagger to
troubleshoot one of these because it was
so big and I have to click this for
number of times okay so it has different
things that it displays and the like
hang and crash analysis case versus the
memory case so in a memory case it will
tell us how many things are ready for
finalization if you have a lot of these
you might oblige finalizar but it gives
you like a whole set of links to what is
this issue about like how should I be
troubleshooting this most of these links
happen to go to my blog but but mainly
because I wrote this script and there
can be useful information anyways and
then we have information about how big
the darknet heap was in case you missed
that and it does a few other things like
display the AH beeps like the dump path
dumpee results in a more visual way and
it also color Rises you might not be
able to see this in the back but this
news controller is actually purple and
that's because it found that to be a
custom object so something that's not in
system web or in some Microsoft
namespace so that sees there to visually
tell you that this might be something
that you're looking for because it's not
common that custom objects show up this
high in stack or high in the heap and
then shows you the finalizer in this
case the finalizer is not blocked as
he's waiting for a finalizer event and
it will also display like everything
that's in cache so in this case we can
see that we start a whole lot in cache
which is also partly a memory leak but
it gives a lot of useful information and
all of the debug DAGs
grapes have like a table of contents
like like this you can switch back and
forth so um let's see here so capture
multiple Dom's compare to see what
they're leaking and find out why the
objects are still around so with all of
these three issues you see and we can do
this and windbg if we want to really
fine grained control and want to damp
out individual objects or we can do this
in debug diag if we want a quickly see
what do you think it is and in 80% of
the cases it will be fine and if we have
symbols and everything we can go the in
the route of visual studio even with the
heat thing you don't actually have to
have any symbols and anything to for the
heat thing to work and so I'm going to
see and so once you've started doing
this for a long time then you start
getting into wanting to actually
automate things and you start doing this
pretty fast if you start doing a lot of
dump debugging and specifically if you
try to recognize the same issue over and
over and over so I just wanted to tell
you about something that I must come out
recently that's pretty cool and that's
something else CLR MD and so this is the
there's a nougat package that you can
download it's still in like an unstable
version or whatever school it's like if
you got a new guess you have to don't
only install the stable do so but you
can download this and then you can do
things like this and so you can either
load up a crash dump in your process so
you can reiterate over X amount of dumps
that you have stored in like some dump
container and or you can attach to
another process if you want to you can
attach live clip process and you load up
symbols the symbols is essentially what
translates from addresses to functioning
and msel with Microsoft comm it's not
misspelled supposed to be an owl
and slash download slash symbols is
where you get all the Microsoft symbols
from and then you create a runtime and
from here you can get to things like how
many heaps did we have how many threads
did we have and that kind of stuff or
you can go in and iterate over all the
threads and find out what's there an
exception on the thread and if there was
an exception I print out the thread name
number and print out the exception
message name and then print out like all
the stacks or you could do something
like enumerate all the objects under
heat and use dump out your specific
configuration object that might have
some important information that you want
to know if this customer had this
configuration sector or not and in that
case you can do that so there's lots of
stuff that you can do with these that
are not necessarily even dumped
debugging but it's finding out quick
information to know it's a issue that
you're troubleshooting has certain
criteria so it looks like this I hope
this will work now because I always saw
these symbols were kind of off but let's
do this okay so yes in this case I just
brought up that first dump that we're
looking at spawn that one thread had a
argument at the range exception and this
is the stack for it so pretty pretty
easy to use and you can do anything that
you can do pretty much in when the BG
that I showed earlier you can do would
see it RMD too so with that I'm going to
leave like left minute for questions and
then I'll be up out here to add words
yes
is it possible to use on a strike wood
core CLR no because it's not luxurious
and sometimes dry compile wood core
sealer but I was talking to and I'm not
sure if Sasha is here today but I was
talking to Sasha who's and doing a lot
of stuff with the CLR MD for example and
he was saying that a lot of people have
come recompiled SOS and then you can use
it with course healers in that case it
would have to recompile it yourself but
there is no compiled version that comes
with a CR quite yet so the other
question is is Microsoft doing some
tools like windbg for Linux and the
answer is I don't know but again sasha
was talking about that too because he's
been doing a lot on debugging with the
corset and he was saying that you can
get some debugging working like that but
you have to kind of compile everything
yourself which is like back to the old
Linux basement so sorry about that
answer but yes so can I recommend any
good resources for learning this stuff
yes my blog so and I say that I'm kind
of but I'm one of the few people who
have actually delved into writing a lot
of stuff about this
so it's blog stuff msdn.microsoft.com
slash tests you search for my name or go
to my Twitter handle and there is a link
to the blog or if you debug in a thing
with debug diag
you'll get to my blog and I have a lot
of debug labs they're pretty old by this
stage but this will work and they still
show how you do things so they have labs
for pretty much all of these issues and
I'm going to be updating and putting
this plus the demo so I'm going to be
using I'm going to write a blog after
this and
put this on there so thank you for that
question that was perfect and is there a
way to automate a d-bag diet analysis
thing from the command line I do not
know but if you find I'm going to give
you a name Wade musk yeah that MAF CIA
and he's on the internet and he is one
who has actually maintained named d-bag
dag right now and he was the one who
actually worked from beginning he would
know definitely for sure and if he is
it's not if there isn't a way because I
haven't used it like that
I've added cdb and stuff like that but
not do you back diagur self but if there
isn't a way he might be interested in
making sure there's a ways okay thank
you guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>