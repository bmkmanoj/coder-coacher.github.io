<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Live Lambda Calculus - Einar W. Høst &amp; Jonas Winje | Coder Coacher - Coaching Coders</title><meta content="Live Lambda Calculus - Einar W. Høst &amp; Jonas Winje - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Live Lambda Calculus - Einar W. Høst &amp; Jonas Winje</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oaU1aiBuBRE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I think it's just about time to get
started welcome thank you for coming to
this talk on lambda calculus from the
slides I think maybe you get the
impression that this is about obviously
orientation but we're in the sort of
functional tract room so this is going
to be about functional programming and
there will be some sort of real-world
functional F sharp and elixir talks
later on today that you should totally
go and see this is less of a real-world
thing it will be practical in that we
will do a lot of like coding but the
subject matter is sort of less so so
what is this we talked this this is a
talk just clarify this is the talk it's
going to be me I not working at the NRK
the public broadcaster in Norway and
you'll knows yeah I'm you must come come
to us and we will be talking we will be
having sort of a dialogue it's not going
to be the usual monologue that you get
from a conference talk usually and yeah
is that enough for a disclaimer I think
so so I tried to warn people on Twitter
that this is going to be sort of an
unusual talk about an unusual topic but
seeing as you're here you must be the
kind of people who like commercial talks
about unusual topics so that's good we
will be talking about the lambda
calculus and the lambda calculus is a
theoretical model for computation that
was I think you can say discovered by
Alonzo Church in the 30s yeah so it's
quite old yeah and it is what is it it
is a Turing complete formal system yeah
and it has a function abstraction and
function application right and it kind
of executes by having variables and
substituting things so this is this is
at this point quite abstract but we will
I think the main thing
take away is that we have functions we
have functions and myself right so I
think the model of this talk is
everything is a function I mean it
really everything is a function all you
have its function it's all functions yes
so in some other kind of batteries
include the languages you have things
that numbers yeah yeah this is kind of a
thing that you hear all the time about
functional programming but it is so much
math and functional programming we don't
even have numbers okay so if you don't
like math you don't make math in in
lambda calculus and there is no math
it's a rephrase it's going to be massive
it's a good attitude let not increment
numbers and I can't do that much Matt
yeah
so so we sort of if we want to if we
were to the math geeks and wanted to
invent numbers we would sort of have to
use conventions for that right yeah so
if you were at ambria's so yesterday she
mentioned the whitening program matters
paper there's a talk that John use and
Mary even gives that has the same name
based on the paper yeah we stole like
one slide from that stock and this is
kind of how you do numbers number
calculus yeah though it's like Haskell
code I guess you know because there has
two people so the idea is that a number
is sort of in programming you use a
number to do something several times
yeah so if you have a number in like
Java what you want to use it for if like
for I equals zero until I under the I
plus plus Linux right so there is really
no distinction between say like the
number five and the content of doing
something five times yeah they're like
mostly for looping yeah exactly yes
so the way and we're going to get back
to this one day when we have some lambda
calculus to work with but the way we're
going to do numbers later is the number
one is a function that does something 1
times the number 2 is a function that
does something three times and it's very
convenient because if you
under how large a number is you can just
count the apps and then you sort of when
you know which number it is right yeah
so which number is larger to tell us
it's like the larger so you're sort of
the many nests of the number is built
right in so you can just by glancing at
it you could tell which number is bigger
than the other right yeah it's very
intuitive and in some said it's and
abstractions that it's very concrete
because it's it is what it is
nothing apparently
so it's losing the language yeah this is
not that language syntax yes yeah it has
three things
so what once we have variables we have
function abstraction and the function
application so variables are just things
like through an x and y am right the
fact that you use those two you bind
them two functions right okay so they're
usually bound by some parameters right
yes and we have functional destructions
this is like in abstraction right some
axis and on some expression you
introduce a function is a dot instead of
a novel and things like that an
application is like in F sharp or SQL
whatever just put a white space between
a function and argument
right and the with the function
abstraction so the X is sort of the the
one parameter for the function so all
functions have one parameter m and the U
is the function body yeah
so typically get the same things with
like curried functions in order to take
several arguments yeah so not going to
spend a lot of time on the please but
yeah well sort of do to have a working
evaluated for a lambda which we will be
using a tree representation yeah so
every you in this syntax can take like
an expression so it's a recursive data
structure so we can draw it like a tree
yeah so this is a small tree this is a
somewhat larger tree so this expression
corresponds to this tree yeah
and then you haven't sort of bigotry
yeah so like this larger expression
becomes this largest tree yeah and then
we have this same expression but we
write this different impatient effective
fill number expression on right now
instead of those abstract things which
is mostly to get it large enough
I'm not so that the total can live there
yeah okay so now we've seen pretty much
all the language because we've seen the
syntax but we have essays have enough
like build an expression yeah that's
right I guess we wondering like how does
it run and so this is this is sort of
the semantics I think yeah so this is
like how a program executes yeah if you
have something like this I don't this
happens which is which is quite
intuitive so here's a lambda and some
expression so it's a function
application where the function is a
lambda and the argument is whatever yeah
and what to do this notation means that
if substitute a sort of expression for X
in V one right so if there are any X's
in you one you're going to replace those
with YouTube right yeah yeah so you say
that down there I think yeah so we kind
of remove this part we play space X and
this is argument so this goes where the
X was you end up with this okay
so we're not if you have implemented the
toy language yourself you might have
used something like a scope or
environment and then you look up so when
we call a function you can add the
binding and the set of X's to your in
this function and I'm gonna get and
actually look it up in an environment
yeah we're not doing this because we
want to do it more like you would do it
by hand for some reason yeah so when it
gets to function application you do the
substitution then and you get like a new
expression back yeah so then
the X just disappears it's not going yet
another rhythms the XP don't attend to
an environment so that's kind of
different than how you probably would do
it if you made your own Lisp or
something like that and it's not
completely unlike how we learn that
functions work in night school so if FX
equals plus X plus X then F of 2 equals
2 plus 2 yeah because you just replace
the XS with with a number K yeah yeah so
I think that's like the essence so then
lambda calculus know it now you need all
you need to know in some sense yeah and
then they get like then you do that over
and over again until you don't find
anything you can reduce further so this
is story simulating doing it by hand in
some sense yeah she said oh we're going
to automate anyway so you look look for
lambda here with an argument and then
they do the substitution and look for
lambda with the magnet in the result and
then they do the substitution and so if
we just like print the result like every
intermediate result to get something
like this right and we're going to so if
you live coded a lambda calculus
evaluator and had it had it running
it might do something like this yeah so
we want to get something like this back
from my own program yeah
so we're about ready to build the
program so we've done program design
which is kind of rare in the industry so
we want to start with a string parse it
into something like this and then reduce
it and reduce it again and we want to
print the output which we have to kinda
run parts and in order to get yeah we're
going to be going from the tree back to
a string representation yep and we're
going to do this I think using two teams
of developers the one team is going to
me me I'm going to do parsing and you'll
not will be doing the unboxing and the
reduction
so yeah first thing to do is to make it
type yeah
so that is a severe you can make it
tight I don't know how to use Maki can
you see this is this large enough good
it's all dented - this does yeah yep so
we want to have a type for expressions
and like we said it could be a variable
variables like a string I still don't
know how to do the parsing anunnaki it
can be an application which has a
function and an argument or it can be a
lambda which as a parameter string and
some expression that's going to be the
body of the lambda expression yeah right
so now we have this recursive data type
yep and let's say if we want to do the
parsing bit and I can do the parsing bit
so we're going to have to do sort of a
recursive parsing then of the correspond
to each of these things right yeah and
variables are going to be quite easy
because it's going to be some sort of
identifier we can have some arbitrary
rules for what their legal identity it's
probably don't want Y to bassinets into
that main function application or
they're mostly gooey we can we'll work
with that and then we need some way of
parsing the lambdas or the function
abstractions those are going to look
like lambda symbol and then some
identifier and then a dot and then some
arbitrary lambda expression
we're going to need to be able to put
things in between parentheses and this
is because if you have sort of sequence
of lambda expressions you might want to
control through the application order
right yeah so if you look at the three
at the bottom if you don't use
parentheses then the first application
will be like the two leftmost expression
the second will be the filter that
application and we yeah because it's
going to be similar to the reporting
partial application of the curried
function yeah so so it's going to serve
I this if you would like like the second
expression to be applied to the third
expression you would have to use proxy
reading to include parentheses around
here right and yeah that is scroll down
I can scroll at the secret slide and
yeah so to help us do this we will be
using a a useful library called a parsec
which is a partial combinatorial library
yeah and it really does most sort of
work so it's going to be mostly
one-liners for us which is good right
but I'm going to start by creating a
small helper function it's going to call
it a parse and it's going to take some F
parsec parser and a string and apply the
part security string and the reason why
I'm doing this is you have you have a
built in a function that comes from a
parsec called run that's going to return
either a success result or failure
result so that's a good thing but we
want a bad thing instead right yeah I
want because we're doing what coding I
want a bad thing instead yeah we want
some exception and so I'm just going if
I have a failure I'm just going to throw
an exception and also I don't care about
how far I got in parsing the string and
stuff like that so I'm just going to
throw those things away
I just want to successful or the failure
getting's blowing up
so did you yeah I think now we have this
helper function which means we can
actually start doing things using a
parsec so I can do things like a parsec
comes with a bunch of built-in things
being a built in sort of primitive
parsers that they can combine to create
more powerful parses and that's what
we're going to do in this talk so one of
those is going is called lower and what
lower does is it parse is exactly one
lowercase character so if I give it a
string like n DZ it's going to
successfully parse the character and out
of that string now of course if I give
it an uppercase n it's going to complain
because it wasn't a lowercase thing all
right yeah I can easily combine or
compose parsers in a parsec so this is
an F parsec operator that let me try
either a lowercase thing or an uppercase
thing so now hopefully this is going to
be successful and I can through
effusively
create angles powerful Python like a
bunch of those letters yes now I want at
least one of those and now I get a list
of characters back of course if I do
something like this it's not going to
parse the exclamation marks right okay
and now I'm practically done with my
variable parser but let's see yeah I'm
going to need a recursive party for
expressions and this is it's sort of a
little bit of mechanics the thing is I'm
going to need to refer to a parser
before it's completely built so I'm
going to use something called create
parser forwarded to rest it's a this is
kind of machinery we need because we're
dealing with a cursory language yeah and
we also want to kind of build up the
parser as we go so the extra parser will
be kind of mostly to complete the
program we yet yeah so we will be
continuously a sort of overwriting
what's in the ref cell for expression
parts of grass and that's going to sort
of let us yeah
expand let's begin with it will like
partial variables and unelected on the
parts and expression right now so now I
have sort of here's my unit test what I
want to accomplish is I want to be able
to apply the expression parser to the
string foo and get oh this must be a
variable so I'm going to first I'm going
to create a little helper function which
is really parsing just the string itself
and then I'm going to wrap it in this
bar thing afterwards let's see I almost
had it actually I think thank you yeah
you have a list of characters okay I
have a list I have interesting it's good
yeah so I need to apply some function to
transform it from the list of characters
into a string so I'm going to use
another parsec operator it allows me to
sort of transform one kind of parser
into another kind of parser as this
doesn't consume any more entity just
does something that is a result yeah so
I'm actually I can just I think what I'm
going to need to do is I'm going to
create an array there's a little bit
cumbersome actually to create a string
from a list of characters so I'm going
to create an array and then I'm going to
pass that to the string constructor and
then sort of done line in the pen
sorry alright now I had one too many
here I think you know something like
this and now I'm sort of ready to create
my Barber's here so now we just need to
turn a string into a bar and basically
I'm just going to do the same thing once
more which is this right I'm just going
to pass it into the war and now I can I
think 2x parser graph
but it's going to be this one right okay
so now I have my first iteration of the
expression parser which just handles
these bar things and as you can see the
expected output is this and I'm just
sending it to be evaluated and I get
bulled back true so this must have
worked cool all right so a little bit
more complicated but not much is parsing
lambda expressions the function
abstractions it's what this part partial
begins at the eclectic cursor because
the lambda expression holds an
expression as its body yeah so the body
could be an arbitrary expression again
so now it's getting more interesting I
so this is on it start to need kind of
the expert service machinery and so yeah
exactly
so I'm going to actually split it in two
parts because I'm I'm going to parse oh
I'm going to parse this thing first the
lambda and the identifier and then I'm
going to parse the dot and the
expression body so I'm going to create a
helper parser if you will using another
one of a parsecs built-in parsers it
takes the character that you want to
parse and then it creates the parts of
that parses looks for that character
right so this parser is going to accept
exactly the lambda character and nothing
else
yeah in doesn't this expression we need
like the land on the dot yeah that's
nice to have and I'm going to use
another one of our six means of
combination which in this case well now
this foreign name parser is useful again
because I want to parse another string
right and this what this thing does
strange thing with the dot is it
combines the two parsers but you only
keep the result from applying the latter
one
the one hello because it's a doctor's on
the right decide to keep it in right yes
so if I put it over here I would have
kept the lambda right but I want to keep
the variable name instead
and similarly I want to parse the dot
and now you get more interesting because
here's the sort of the recursive thing I
want to parse an arbitrary expression
and now I want to combine these in a way
that gives me both the results not just
one to the right to the one to the left
I can use a function called pipe two
takes three part series applies them and
then gives me a so now you're doing a
function that takes two arguments yeah a
function that takes two arguments one
from the sort of the output of applying
this parser and the output of applying
both of those saccades yeah so both of
those succeed I'm going to get a name in
the body and I can create Alana right
and that's pretty much it now I can
update my expression parser and says
okay it's going to be now either a
lambda expression for a variable
expression right yeah so if I do
something like this I have a more
powerful parsers that is capable of
parsing this also and this one all the
tests are greens get yes they have two
green tests yeah so a little bit this is
from this with the parentheses really
preparation for the application but I'm
going to do it sort of bottom up with
the parentheses first
yeah sure so I'm going to need a
parentheses parser and again if parsec
helps me I think you I think I just
write the code and you'll understand
what it does so I'm going to try that so
let's see
and what does this do so between is a
another half parsec function and it says
I'm gonna apply this parser in between
these two other parsers and I'm going to
keep the result from the thing that's in
between so I don't care about sort of
the output of parsing the open
parentheses okay and they made the
person to succeed yeah okay down right
and this is what it is now for instance
parser getting a little bit cumbersome
to write this let's see I think I'm I'm
sort of done with everything except the
application so I'm going to combine
those C into a single partial which is
everything but the application and I can
update my expression parser to be this
new party and well now I can parse
things that has parentheses around them
like I mean I can I can have a lot of
practices and it's going through some
work nicely which doesn't care about the
processes nice all right
so now now sort of the tricky part which
it turns out not to be so tricky if we
have if you have like a parsec oh yeah
exactly
and if we realize that we sort of need
to think about did I command that back
to the slides
yeah we have like a plan for this yeah
we have a cunning plan for this and for
doing this correctly so we're going to
need to do it sort of left associatively
and parsec knows that sometimes you need
to do things that's to associatively so
really parts like the entire thing
so that we end up with a list of
expressions and then we want to combine
them into tree of applications yeah so
we have a sequence of expressions
one to end expressions and if it is more
than one then you're sort of going to
need to combine them and if it's just
one well which is going to be the result
of yep doing such a function that just
does that first that would be nice yeah
so we have this something that's not an
application and I'm going to combine
that this is going to be the sort of the
most opaque I think code in the
presentation so it's don't worry if it's
a little bit remote what's really going
on here but what this is going to do if
it sees and successfully parse is to not
applications separated by whitespace
then it's going to combine it right so
this parts are here with the pker yeah
you're going to transform the result
into some big function that is going to
combine two applications yes how to
expression to the internal occasion yeah
so I'm going to skip I think this is the
whitespace thing I don't care about the
ESF cars I divide space and get like a
white spaces yeah so that's not terribly
useful we're not going to use the white
space for anything but we will use the
not application that is meant to be
applied
yeah so there's an expression to the
left and an expression to the directory
right space and those are passed in as
an 10a yeah
and you can make an application yes and
I need another parentheses and now I
have my finished up parser and you have
your finished perfect to the market
right now I think pretty much because I
can just well if there is if the
sequence just has one element it's just
going to be then it's not going to be an
application obviously so it's just going
to be the same as applying the not
application parser so I can just say
that my whole expression parser is going
to be this okay it goes already a parser
includes they not a person away yeah
yeah
okay so this I think sort of completes
well let's see if I can actually just
for fun you know I can do something like
this also yeah
now you can obviously see that this now
applies oh this is the application of
yeah so it's obvious to say that three
is tilting the other way from from that
string yeah this is obvious come for a
more complicated example you see this
also you know isn't it also now it must
be correct this was like the large three
expression ways we show down the sides
and this is the total row yeah this is
the three bekata lives yeah and you can
see that it's like several lines so even
in this notation it yeah possibly large
enough okay so this completes the parser
yeah so now we have some other things to
do so we have like another slide so we
do parsing we want to turn it back to a
string which i think is called an
parsing and we have like plans for doing
that it's like to impart but the
opposite so it's undoing all the hard
work that we just did yeah or the hard
works better for suggested I think efn
works so Oh
we've sheet to the currently oh we have
the yes so this this server wasn't
supposed to be in there I was supposed
to write it now so we have a parenthesis
function that adds parentheses around
something yeah and we can test it and it
should get like to smile it back which
is nice
we're going to need that in order to
entice and so basically we have all the
treats yeah
someone hasn't like inaudible this could
be me it's probably because you did all
this so we're going to make recursive
functions that work on this because we
have little person sighs yeah so on
parts and parts and I don't actually
write effort much so I don't know the
same part of languages I not I like to
do things like this so an parse is a
function and we will do like pattern
matching on expression we get in so if
it is variable we will return the name
of the variable so this would be like an
expression to string and you can see by
the magic of I annoyed that it actually
does that oh yes which is nice
and there's the lambdas yes yes a
parameter and some expression right and
then we just gonna keep growing it back
into the face like this to get a lambda
yes and the paramedics call with the
strain we want a dot and then you need
well some arbitrary thing yeah so the X
is like an expression so we call on
parse the cursor and that's one parse
all the rest of it and then we have
applications so it says unpark xml which
is strange i like as the complete
helps me out and when they come to
application we have to like do some
stuff in order to get apparently fits
right we want parentheses around the
lambda X lambda is the function argument
so we have read yes one match if it's
going to be two cases for application
yes we have one that matches if the
function bit is a lambda right and
another ones were whatever and we have
to use our parent function and on par
still under stuff and the eggs like this
you really write f sharp kind of
differently for me yes and this is very
realistic with respect to working in the
industry right so already we have a
tension in the code base I'm going to
change his code he's going to change my
code yeah and we need to like consider
whether or not to add parentheses on the
argument as well so would you say what
arc string is no okay will show up later
right but we just want to add
parentheses around it unless it's just a
single variable right arek string is
George's problem and your George I'm
George in like three minutes for
everything else will just and parse the
function and I don't think you mean that
i does not yes at all
and that's the reason why they have like
an Augustine function because you're
going to do twice
yeah right and and explain it's also a
function and that's also a recursive
function yeah I didn't think you had to
to do that you have to write direct when
it's like in a hand oh no no you don't
have to write the right now I'm just
wondering why you didn't put the arc
string in front of it oh never mind
yeah yeah I just think it's going to
call unpark right yes yeah so it's going
to mutually it's going to be mutually
recursive so variable so spill it a
little bit for anything else we want to
X instead and we want to put parentheses
around the umpires X I don't know a
whenever it's work so right it could be
that Phillip happens it's probably I
think it's a indentation do you have to
do like this I don't live like this I
thought I had to do like this and I have
to try the other way and it's intimate
you know it could be that you have a
sort of give that a wrote everything
wrong I think so control is I'm going to
bed - computer for everything that goes
wrong
yeah oh it is it here yeah area yeah
certain something necessary with the
textbook they can stay
yes so we can unpack
one of those things expressions from
earlier and we can do one of the unit
tests and I guess we're not going to
spend a lot more time on parsing we hope
this works
yeah and I guess I'll like a bunch of
sheets don't I guess I'll just let this
doesn't stay on vector instead yeah so
this completes the unpacking right yeah
so now we all we have left is the
evaluation yes so we want to do like the
reduction evaluation thing and kind of
glue the things together so we get like
a running program yes
so reduction can consist of looking for
something like this which is an
application where the function beta a
lambda and then do substitution on it so
we can remove this on this and keep this
body but every a in the body is going to
bases with poop right so we want the
substitution function and reduce
function so yeah I'm going to call it
subst I'm going to guess that that
substitution yeah and it's a function
and I'm pretty sure I'm allowed to do
this without the types yeah you just
keep if we have the right amount of
parentheses yeah it should be good
so subs is going to take some argument
like foo the thing they are substituting
and some thing will looking for the
parameter 9 and then there's the
occupation we're looking at so if it's a
variable V then if V is the string with
the turned argument is allocated for the
argument I'm sure you want the commas
yeah okay good my
yeah we're going to passing a tuple of
our games right yes and then art else we
to turn the expression untainted and if
it is well even application should be
simple as a function based on an
argument bit we just want to call subst
recursively only a bit so we substance
and subs you know you're sort of calling
recursively down the tree yeah
and rebuilding an application yes should
I be worried about the lines the red
line not yet probably not we were elated
and the left cases if it's a lambda the
if the parameter that is bound by this
lambda the T is equal to the thing we're
looking for
yeah then if that variable occurs within
the lambda expression it's borne by that
P instead of Excel into the teens are
replacing so we can leave it as if yeah
because you're you're sort of shadowing
what you're looking for it but it yeah
all right I need to have like older
arguments on next run
yeah you sure the world
then we can't do anything with it we
just return the same member writing
random symbols and otherwise we need to
do like the same thing as I did in
Lapidus Vicarstown yeah and look for
variable statement so we make a new
lambda in same parameter and it is subs
yes
X I think that's it yeah so the only
place where you're really doing any
substitution is in the first line right
yes so the whole thing is we're looking
for a variable that has the same name
yeah and the rest its machinery in order
to use again I do the variables yeah so
we have a substitution function we're
going to use it in our reduce function
and we want like a result type for
reduction so we're going to call reduce
and look for something to do that the
substitution on if you don't find
anything
the expression is on normal form right
because then you can't really reduce
them any further nothing more to be done
with it so we have kind of finished
evaluation if you do find something we
will return sort of the next expression
that they can do more generally do the
substitution and return the result right
yes so hopefully you wish normal form
but oh yeah it in average normal form we
don't terminate yes and if you don't
terminate to back probably children
complete so that's right it's a big win
so yeah the distance function it takes
an expression the thing we're looking
for is an application where the cylinder
with a primitive and a body
and there's some argument don't need
this and then we return it next thing
right and we substitute the body of the
lambda with the argument and I might be
regretting that I did that's it
substitute a for T in X we substitute a
for the parameter of lambda in the body
of lambda yeah exactly so you want
inside the X you want all the piece to
turn into ace is that right yeah the
others will easy case at least if
variable V it was necessarily unknown
for me you can't really do much with
that no and it doesn't like containing
your expression that we can look into
write the rest of it festers don't be
like going down the tree and look for
stuff so if it's a lambda we have two
you're going to call limb for something
reducible in the X and then we have to
rebuild the lambda if you get is a real
nice record yes yep so we're going to
decide max videos X weight and if it's a
normal phone the whole thing is a normal
phone yep
it is not known for form then we have
some some some reduced expression some
next step of computation yeah and that's
going to replace the body of the lambda
expression itself
yeah so we do lambda T and the next
expression yeah other is going to be
next all right so if you can see so want
to carry on this next as well yes and
the kind of most cumbersome bit because
you'll because you need to lift in the
function part yes and then in the
argument party right
so we look at the function try to reduce
that if you cannot we'll do the other
part first I guess so if we get an exit
to an exit function because then you're
sort of done yeah we'll stop looking for
more stuff to really see on one bit of
reduction each step then we have an
application with the next function and
the elderly men to actually argue and
again I need to do like next if it is on
normal form when then we have to look at
the argument bit right yes so we do
match the use a with and then it's going
to be kind of similar yeah so next the
next argument and we get an exit back
the function and the new argument and if
that is unknown upon my swells on the
other everything's normal
right because you are nowhere yeah that
makes a just look looked all the way
down to the variables which I can little
the leaf nodes yes and we didn't find
anything to reduce okay good so now we
have the reduced function yeah so it
means we're almost done I think yes so I
hopeful this works we're going to test
it after we do like a tiny bit of
assembly yes we're going to put
everything together in if you don't put
most of it together so we can try like
the test run and then do the Republic I
guess yes so what we're going to do is
we want to read some stuff parse the
stuff and evaluate the partial stuff and
write all the imported results on every
every step of having dollar for each
next right you're going to be a non
parce so you can see what's going on yep
so let's start with this is function
that might run forever so this we call
it around a vowel with some expression X
so this is an already passed expression
okay so this is the career
representation yeah and we're going to
get reduce the X and if it is on normal
form
when we're done we don't get to run like
a unit value yes and if it has some next
expression then we're going to have to
write whatever that is really like if
it's system I think you can do prints
that's probably oh yeah
this is very enterprising they were
doing like the this is not net
interrupts yen we reelect aside
effectively bits an array so we can use
second
so we want to
unpark beautiful to God yep and write
that and call the run of all recursively
yeah
so so what was the test expression
called I should like a pecs yeah that's
the expression yeah
so you can do like a test run on at
except yeah yeah so we get yes you can
see down there this is hopefully the
same thing that was on the slide right
it's it's possible you can like go back
so if you can just memorize what lambda
I lambda villain ABA and so it looks
kind of similar yeah it has more or less
the same shape so it must be correct
yeah okay so we want to make a cat Apple
and I think that takes input from like a
standard in and then parses it which is
also going to be recursive because it
might sound forever and will be call it
triple I guess yeah
and now we do like parse and then it's a
parser system console.readline yep is it
like this I think so yes and well we can
just do run eval on the result yeah
since you did the kind of solid sections
instead of doing subtypes it's just
going to borrow quickly but do something
wrong yes that's good yep and then we
call this you can do like
this isn't a unit thing yeah
so if everything works now we can start
your Apple and I don't know the lambda
thing doesn't work' oh yeah
in this day it works there so you can
sort of yeah so there's a hooker bitch
very type expressions in this windowsill
and copy paste them into the ripple but
if you're able to do things like lambda
X lambda is like this so what would be
the expected output from that bar I
guess yeah because the foo is bound to X
to X but there is no X so yes don't you
get lost clearly have a working lambda
calculus evaluative so ya know it's a
very useful language language I don't
care what it does other than doing
reductions right and and we were
thinking a little bit about this about
Turing completeness and in some sense I
think we arrived at Turing completeness
is about giving you a bunch of rope and
the ability to form a loop and hang
yourself in and then suddenly your
program can hang yeah which is nice this
is this is as much power as you can hope
for and if some1 Kenna it implies that
things might run forever and never stop
yeah and other narrative is like a
definition of what is effectively
computable so every algorithm should be
possible to implement any algorithm in a
Turing complete language right so they
kind of formal that notion is that if
you can do these useful things like
addition and also you can screw things
up and run forever then it's probably
doing completed yeah and I think maybe
to illustrate that sometimes you hear
people talk about well it's Turing
complete and things like well what
f-sharp do that c-sharp cannot do and
stuff like that and to sort of
illustrate that this is this is stupid
question to ask we're going to try to
make a little bit of math to show the
distinction between what we call the two
and completeness on the Turing
convenience because some languages are
more practical for doing some things
than other languages yeah oh they're all
actually torture complete or whatever
you want to call it and just lightly
stroking breaking creating some numbers
we might need those are amongst the most
useful ones I think yeah so like I
mentioned earlier we're going to get
them more number is a function that does
something as many times as the number
you don't think one is useful number not
not for our purposes so you just create
as much math as he needs yeah it's not
me like we could try to create all the
numbers but there's a lot of them yeah
so we're skipping some huh this is a
very pragmatic approach
so I decided having only two is like bad
because it's hard to tell if you're
doing addition or multiplication yeah
it's nice I like two and three right so
just to be clear what we're trying to
accomplish here is that yes of in order
to prove that it's a useful language
we're going to divide like to get links
or numbers and see if we can do addition
on them so we want some function that's
can take this as an argument and this is
the other argument and return something
that we like able to pretend is number
five yeah there will be a lambda X
lambda X Don five FS and the next yeah
so it should produce the same result as
if we just wrote five using this
convention yeah right so it should take
like two arguments all right already we
have all of you lambdas so the first the
a and the B those are going to be the
numbers these are correct yeah and then
we're going to need to create an even
number so the first lambda option like
saying yeah I guess all numbers started
lambda X lambda X right and now we have
an F that we want to apply the right
amount sometimes the best all numbers do
right yes
a number like a s then a the number a
will apply as a a number of times to
something right so you sort of have the
looping built into the number and n let
it do like so what we're trying to do is
apply the F be x to x and then apply the
F a times to the result yep that's
perfectly clear you know this is we
claim the function that there's addition
on these numbers right yeah so so if you
can now copy all of these things
together so we won't like the two number
we need to add some extra parentheses
and the three number another is going to
be a bit of calculation in down there
the sort of the proof will be the final
line right if you can count the F and we
have five F then we have indication that
this is sound approach doesn't project
great at the moment
oh did I mess up with some so do you
have like unmatched parentheses or
to have something that is not Oh No
we need to start to the plugin because
I'm going to do up
it kind of runs forever at least yeah
that's like sauce enough oh this is all
good yeah so this is kind of the great
payoff at the end where essence million
everyone understands that lambda caucus
is a useful language yeah should we try
to get sort of candy like should we
treat if you publish it see if we can
see are you better than me three things
I'm not sure
let's see should we take one of these
other things and just sort of buy all of
it yeah that's one when do the garbage
campaign and run everything in this
fight right so we're going to try again
now or yeah we'll see if you have time
to do another try we can see if the oh
no it is like you have your it on my
number scope I think it's probably it's
either high drop first down I guess all
right at the end of the pile and we are
go hero beyond all my sheets yes so
where does commence we're still in so if
you will so let's see it if each number
works
so nothing works
oh right I think that kind of sums up
the talk done yeah I'm not sure in
together like a plan C not sure if we
have a plan C so now we have a record we
can start it up low and don't say it
were pretty much out of time
yes we can get it running the good thing
is that you can do long the caucus by
hand so you can kind of tell that this
prints the rest yourself right and one
thing you could do if you're secure all
writing this down
you could go to maybe I can actually
show it if I'm online you probably
shouldn't go online see
that's probably sleeping as well well
this is a hyper media driven lambda
calculus evaluator in a sure it's
written in suave you can put things in
there alright so we have a fancy so you
can just copy everything in there we
should be able to see it running that's
incredibly useful to have like running
in the cold yeah so now you can sort of
it gives you next links whenever it can
to continue working and now we have a
great five apps
yeah and we already have like the nine
five for it so everything works perfect
yeah we are also time this thing runs
forever yeah so this is Zoey's character
in context thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>