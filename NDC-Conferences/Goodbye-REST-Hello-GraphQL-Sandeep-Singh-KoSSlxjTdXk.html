<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Goodbye REST; Hello GraphQL - Sandeep Singh | Coder Coacher - Coaching Coders</title><meta content="Goodbye REST; Hello GraphQL - Sandeep Singh - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Goodbye REST; Hello GraphQL - Sandeep Singh</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KoSSlxjTdXk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right hello everyone in this session I
want to look at something called gradual
my name is Sandeep and I'm a software
consultant based out of England just
before we get into this session has
anyone heard of graph QL before come to
this talk that's pretty good anyone
using it in production ok maybe not so
good
ok awesome so it gives me a point now
where we can go this talk so let's have
a look at the agenda this is what I want
to cover today so the first thing I want
to look at is the considerations and
challenges that we have when we create a
px today don't have a look at what
gradual is what is not and what aims to
solve then we'll take a deeper look into
what graph drill
it's called concepts and principles and
then it's going to be a demo where we'll
build a graph QL server as well as hook
up to a single page application it can
give you a real world example of how you
could use it then finally I want to go
through some considerations around when
to use graph QL and some of the not so
good things about crack cool right so
there's various technologies that
facilitate server to client
communication here's a list of some of
them that you might have been seen
before or used press soap RPC and/or
data and dispose of the ones that you
haven't put on but the whole point in
this talk is we're going to compare how
rest is the graph QL now it's got to
give a bit of a disclaimer this is not
going to be a talk about saying rest is
poor and graphic URL is the best thing
since sliced bread it's not to be like
that I'm going to try to give you an
informative and unbiased opinion about
the goods and Bad's of both technologies
does want to say that first right so
that's going to quickly recap on some of
the core concepts of rest so rest is an
architectural style it's a pad it's not
a framework or a library space songs
concept of resources and we name our
resources using nouns so for example for
API patients and paste it to their
resource and because we use
over HTTP we have these HTTP verbs and
operations which allow us to mutate our
resources so we can basically manipulate
we can get called delete post and one of
the most important things about rest is
which is argued quite a lot is a
hypermedia constraint and the hypermedia
constraint is ultimately about having
links your resource representation that
provide links to other related resources
it's kinda like transitioning from state
to state so for example if we had the
api patients and point forward slash
with an ID say one in that
representation we get back now response
we might have links which are hit press
to things like medications allergies and
very other things related to a patient
so this is what I mean by resting this
is what we mean roughly by a rest
throughout this talk so it's just a
little bit of context right so what we
build if you guys today there's various
things that we have to think about some
challenges and some considerations one
of them it's around efficiency how
efficient is our data retrieval how many
requests do we make to a server to get
all of our data requirements back next
is around predictability do we get the
response from the server that we expect
and there's an interesting topic around
versioning those things one of these
things that has kind of had various
implementations and ways of doing it
some are more correct nor more
restaurants or not so how we doing
versioning how we evolve in our API are
we using things like version numbers in
the URI or sending stuff in D headers
then this things around caching how
utilizing network caching have you got
cash on the app server do attacks on the
client there's various things around
security tooling platforms and
documentation so now I'll have a look at
an example don't wanna do is I want to
walk through this example which is a
very simple view it's a single patient
view for a patient in a medical system
so it's composed of three parts
so there's a summary which kind gives
your name their birth and identifiers
and basic information like them then we
have medications
medications its patients on there we
have allergies so things that the
patient is allergic to so I want to do
is on a walk through this example and
see how it affected it for this and some
of the challenges we face we're going to
fix it if we're using rest so the first
thing is if I was to request the patient
to a point I would technically get back
if I were implanted hypermedia
concentrate correctly I would get linked
to other resources and these will be
medications and allergies and that's
great
but I have to go off and fetch the data
again it doesn't come back in the first
request which is not good if you're
trying to build efficient and perform an
API that can work with multiple clients
and especially over mobile so this is
called under fetching as it's common
terminology especially when you get good
at the hypermedia concentrated ever
restful api under fetching becomes a lot
more common so there's a few ways you
can fix this so one way potentially
would be we could put an e cludes on our
URL
it's a query parameter and include these
in our first request now this
technically is a little bit annoying
kind of breaks wrist because you've
added state to our URI well for this
purpose it works it solves a problem and
we can get the data back that we need
but it is a problem with it and that
problem is something called over
fetching now we've got the information
that we need back but we've got way too
much information than we need if we
think back to our example there's not
that much information on the screen
really there's only a couple of
properties for the patient summary but
yet if we have a look at the Jason in
the bottom right that's only part of the
responses to come back and the three
dots at the bottom mean there's a lot
more information so we have this concept
of over fetching data and getting more
debt than we actually need and again
this is not great for mobile networks
ultimately the smaller the payload of a
HTTP the better especially if you want
to build a fishing API so we can solve
this in a few ways we could technically
add a field query prior to a URI and
then we can dictate which feels we want
to bring back now there's no real
standard way of doing this there's no
real good convention about it there's
various tools that you can use but when
you're
multiple objects and nested associations
and lots of properties your your eyes
going to get quite big and ultimately
how do you handle it for other resource
types this is just for the patients that
were interested in but what about other
endpoints that we have it's kind of hard
to maintain and sit overhead so
something that we could do and I'll hold
my hand up and I've done many times
create an ad hoc endpoint and this is
not the most ideal thing but what allows
us to do is we can get only the data we
need back in a single request but we've
kind of limited now the scope of this
endpoint that we've created because this
is just for that specific view now if we
had another client so our initial
application was a desktop application or
web application now we've got a mobile
application how we're going to handle
the fact that they have a slightly
different need for the way they ask for
data do we create another ad hoc
endpoint could do it's not ideal there's
an overhead in actually additionally
adding you are is a maintenance or could
we create a separate API altogether now
Netflix do this but next 16 because I
have a very big team and they have a lot
of money behind them ultimately and they
can afford to do these sorts of things
this is not always the case with smaller
companies so building api's today it's
kind of difficult as we've seen there's
quite a few challenges that we need to
that kind of phases and we can't I need
to overcome those so how does graphic UL
fit into this equation that's a good
question so gradual is a query language
it's hot and this is a fundamental
difference between what grass glow and
rest is rest is an architectural style
and it's a way that we can build api's
but this is a query language it's a
fundamental difference of two different
things but what graphical are allowed
you to do has a building type system so
with this type system you can define
type save queries where you only request
the data that you want in the share
performer and your response will mimic
them and that all happens in one single
Network request between the client and
the graphical server so let's have a
look so on the left is basically how we
define a type
cool so we have a patient type and tank
so how we describe the dater in our
application our API and that's what we
want to kind of expose next we have a
query is what a query looks like in
graphically and it's basically asking
for a patient with an identifier of
identifier that's provided and we want
this name property back and if we look
at the response response fought back
adjacent and it's kind of in the same
shape as we asked for it many
differences some commas so that's what
technically graticule is if this query
languages allows to specify queries in
any shape and format which are exposed
by a basically a data object and we can
do that in a single request
so grassville is a specification under
standard it is created by Facebook I
think in Bali 2011 and they've been
using it ever since and they open
sourced it back in 2015 it's high-rise
film in the sense that it's a graph and
you have objects and nested associations
gradual kind of gives the power to the
clients ultimately clients specify their
daily needs and it's strongly typed each
graph your server has an application
specific type system we saw one of the
types in the last example now we'll talk
about what graphical isn't because it's
quite a lot of misconception around for
it is and what isn't
it's not about graph databases even
though it's got QL in extending it's not
about graph databases all it doesn't
care where your transport protocol
leader is we can use that with HTTP and
we tend to use it over HTTP rates
agnostics it's in the spec it doesn't
care about your data storage you could
use any data storage opposite since you
want it can use a no sequel debt versus
sequel database it's all backed by
albick record and we'll see in the
example a little bit later how that
makes sense more and it's not limited to
JavaScript Facebook's implementation is
a Java Script and that's what I'm going
to demonstrate today but there's
reference implementations in pretty much
all major languages now and some are
very very very polished like sangria
which is Skylar's version has a lot of
extra features but
the dark version of the Java version
Python this goal is rust there's various
implementations
it's just suspect at the end of the day
so now we can to know what graphical is
kind of how it had works roughly what
problems does it help us solve now if we
think back to our example one of the
main problems we had was around
efficiency this concept of under
fetching and over fetching graph QL can
avoid this because we scripture the day
are in a way that we bring back all the
relevant data we need in the scripture
and shape that we want so this is the
same query that we would have got in the
rest of world but this is what it looks
like in gradual so we have a patient and
we have some field which is like ID
first name third and bit birth then we
have some nested objects like
medications analogies but this is all
brought back in single question and we
can write the query on the left to give
us the shape of the data that we like
and it becomes really powerful when you
have multiple clients so if you had a
mobile application or you had a desktop
or a web application they can all
requested it in the shape and form that
you need you don't have to on the
backend develop any extra work to do
this whereas it a rest world you might
have to go see the back engage and say
okay can I have some more in my
resources for patients can you add a few
more fields the Long's exposed in graph
collecting query however they feel see
fit and there's a another fundamental
difference where the graph clearly have
one endpoint its bulbs last usually
graph QL it's the only important you
really have where st have multiple
endpoints for all your resources with
the graph clearly add objects to your
graphs and then expose them by off what
the single endpoint it's a fundamental
difference in the way the work
ultimately and comes to maintenance and
developments well in the developer
experience is a little bit different and
we'll see more about that in a bit
so what about versioning and it's quite
funny this actually because if you go
onto the marketing website of graph QL
it's really really nice it's very
polished but it says you don't really
need to version and that's technically a
bit of a life because you still have to
version but versioning with a graphical
it forces you to think about backwards
compatibility compatibility and forward
versioning strategies and it kind of
follows this principle what rests
technically should follow its evolution
and so what I mean by evolution is we're
supposed to really evolve our api's we
can add new fields over time and then we
can deprecated fields we don't use then
we can monitor the usage of these
deprecated fields and then remove them
when we see fit and graphically Isle has
two really cool features that help us
with us
one of them is a deprecated property so
there's some types that's going to kind
of roll across the screen this image
basically you can see into the director
and so it's deprecated what that
actually means is for all old clients
which are consuming the same point they
are able to still query that and get the
data back they need but any new clients
will come on they will not see that in
any documentation or any of the
intellisense because it's deprecated so
that's a really nice way that you can to
handle this for you and the second part
of grass URL conversion feature is that
because you send a query over the wire
you kinda know the share from the
structure and the fields that people
care about and what they're using so you
can easily monitor field usage and then
you can say okay you've been using this
field for like the last six months we're
going to get rid of it now you might
want to look at using this other one so
to track field usage compared to from a
retrospective where you just get this
whole chunk of JSON back and you don't
know what fields are actually using it's
kind of a lot nicer and easier to deal
with so that's kind of handled how it
handles versioning so introspection now
this is probably one of my favorite
things about craft cool what graph kill
means but introspection it's kind of
like reflection for your API so with
graph QL you can actually query the
schema types and the fields and you can
see what operations you can actually do
on this request to a lend point without
actually having to do anything other
than query the actual schema and this
really lends itself to kinda like
building tools so for instance if you
could query the whole of a schema you
could get intellisense and autocomplete
because you know what fields are
available
you know operations are available so
telephones kinda comes for free you can
do things like cogeneration because you
know the types and we've defined a type
say with that patient type you could
generate cold off the back of that by
just clearing the scheme and saying okay
I know the types of string I know what
name is and I can kind of ultra generate
classes in any language that you can see
fit so it's pretty cool for cogeneration
it also gives you this concept of
documentation now again the marketing
kind of field says that it's free
documentation and this is a
documentation need for your OPI it's
kind of a lie again it gives you this
ultra documentation about your types and
your schemas and your operations but it
doesn't take away from the point that
you need documentation for your API
because the consumers at the end of this
is great for developers that consumes
every our API might need more
information things that aren't blatant
like around great limits and some of the
complexities around your API and how to
use it but this is a tool called
graphical and this comes with every
graph QL server and basically this is
built on introspection so this example
will keep playing around in a loop but
ultimately if you have a look at some of
it like there's intelligence telling is
that is the first thing as we now go
look at the documentation we can have a
look at what's on that type and then
have a look at the surname and we can
have that in and within query so this is
what we mean by auto documentation it
gives you this types and these kind of
like query operations when I first saw
this this kind of what made me really
think about graphical because it's not
many of the tools allow you to have
introspection the same sort of way when
I first saw it as kind of like damn that
is super cool at least some people
laughed if everyone seen Friday they
they'll get that reference so now we've
kind of seen how it works for is what
problems aims to solve for us how does
it fit in the technical stack it says
some people say it's a one tool mapping
of a bit of your database now
technically that's not wrong you could
use it as that but that's really not use
case
crash girl sits generally between a
transport protocol and the business
logic as you can see I've got rest by
gradual it's not a replacement for rest
it can work side by side rest you can
not use rest if you want anymore but
it's not really a replacement it's an
alternative for building a POS and the
two important parts about this diagram
is the authentication and authorization
these are not concerns handle by
graticule now you'll see blog posts
about people saying I can do
authentication graphic will and that's
fine but generally the best practice not
to do that should happen further
upstream if you use to anything net like
the ID server you have an open ID
connect middleware you kind of handle
most of that information they need to
pass down the relevant pieces of
information to graticule
because it is a global kind of context
object which we'll have a look at most
and get that information back again
further down to the authorization and
what we mean by authorization is what
can they use to do what fields can the
see and again that kind of lives with
your business logic is specific to your
domain it doesn't really need to be in
graphical and ultimately if it was in
graphical and you had a business logic
in your REST API as well and you're
trying to share this logic and you might
have discrepancies between them so
generally kind of it sits as a kind of a
thin wrapper of your API that's the way
I see Quester land that's where I see
used in many places and I can see
persistence is at the bottom persistence
it doesn't really matter like I said
early it's backed by AB record and that
will make more sense when we go through
the demo the ultimately persistence is
just part of your business logic
whatever you choose to use so now I want
to do a quick comparison between
graphical and rest now this comparison
is not which one's better or which one's
worse and it's not we'll get some logs
tick boxes in which box it's ultimately
to define and illustrate the differences
between the two technologies so if we
have a think about the conceptual model
rest is based on this abstract concept
of resources graph girls ultimately a
graph of objects and nested associations
related operations what I mean by
related operations is if you is to add
endpoint to a REST API you kinda know
because we use HTTP verbs in a standard
way what you're going to get when you do
a get or post or a pull with graticule
when you add an object to our graph or
you add attack to the schema there's no
real way that you could kind of guess
that you'd have to look by introspection
to see what kind of like what can we do
with that type come we insert delete you
can query it so that's a fundamental
difference between the two so
introspection which I talked about
previously graph QL is built on
inspection ultimately rest didn't really
have a standard way of doing this you
can kind of things like tools like
swagger for your rest api our open api
might have some features around this but
there's no real standard way of doing
this and it's not really mentioned in
the constraints either for rest so data
typing so graph QL has a type system and
it's strongly typed in terms of inputs
and outputs rest is weak in that sense
and it's loosely covered and
disconnected between the client and the
server and then real-time so what I mean
by real time is push-based api's rest
really doesn't have a way to deal with
push birthday P X is stateless and you
generally wouldn't use rest to the
Critical based API anyway but graph QL
has something called subscriptions which
allow you to curate these stateful
subscriptions like push notification
style patterns in your application
that's technically not really in the RFC
spec yet it's been flowed in and out but
it's supported by some of the external
libraries but it's not supported in the
one that I'm going to demonstrate with
the Facebook's graph QL implementation
well not yet it's supposed to come
probably the next month or so but it's
not here yet so now we've got
understanding of what graphical is where
does what does it do kind of a look at
some of the core concepts of what
graphical is and a little bit more depth
so I've broken it into three different
areas
so the first in the tax system the type
system generally defines all our objects
that we can query on in our API then we
have operations graphically our logic
query data also allows you mutate there
we can do inserts deletes and routes
sorry and writes and also it has
descriptions and then the schema is a
kind of the glue that holds all this
stuff together
it's kinda like the entry point into
your graph of how you can query the STEM
fields on what when you do through these
fields what happens and what response do
you get back in terms of the type so
types are on the right we have a
medication type and a patient type and
we call these object types and most of
your graphical API implementation will
generally be around object types so
we've got some properties or they're
called in the graphical world fields
which are like ID identifiers first name
and surname and this is we have these
back-to-back scalar types so your
integers strings balloons and floats and
you can create your own scalar types so
the extensions for that the tax system
supports enums so if you've used enums
in any major language it's technically
the same supports lists so as you can
see medications field and the
medications is basically donated by an
array so the square brackets around it
there's actually an exclamation mark on
the identifier next to the string as
want to point out that means it's non
nillable and also type support is
concept of interfaces so interfaces are
just like you used in c-sharp or Java
it's allows you to share common fields
between types and unions are kind of
like interfaces but they don't share any
common functionality in terms of fields
so the resolve function now technically
this is where all the magic happens
so only less we see is how you implement
the actual type in JavaScript using the
Facebook implementation so we have an
object type which has a name of patient
and description and we have some fields
I'm going to name field but the most
important thing about this is that all
the fields in our type have a resolved
function and the result function is
where we call arbitrary code to actually
resolve that field
so for instance name is just returning a
hard-coded string tongue stud but in the
real world example you might have this
mapping to another object you could call
your business logic could call an
existing rest api you could pretty much
do anything that you want in a normal
it's a normal function so anything you
can think of returning static there it
can do that and then here generally
where the magic happens are gradual what
happens if you extend a query it's
ultimately gets executed and it goes
through and recursively looks at all the
fields and looks at all the results on
shion's and then it basically execute
each is also function in power so this
is where kind of our logic lives so
operations so we've talked about love
about query just want to kind of go
through another example with queries so
queries allow us to retrieve death so
this is graphical and I've got an
example of the query so we to create a
query we use the keyword query and then
we have a name which is optional we
don't have to have the name we can pass
arguments to queries and the brackets
between the ID and the closing bracket
is basically called a selection set and
inside of selection set of the fields
that we care about and then we've got
medications which is a nested object so
that's generally how we're going to
write queries in that side kind of
script refused going to call it from an
external source like postman I'll make a
HTTP request
over to your graph to your server so
mutations so graphical is not only about
reads a lot of apologies for reads only
and it's very good at that but you can
actually mutate a cancer delete and
remove but mutations are kind of like
it's like a bolt on I always see them as
they're not they don't feel as natural
as queries but the kind of an RPC style
in terms of their naming so grow a
mutation hit with the mutation keyword
and then give it a mutation a name and
again that's optional but you can see
the input now is actually an object and
this is a special thing about mutations
you can feed in a complex object which
is different to the type you're
returning so it's a concept called an
input object so if you are debt
restructuring in a different way than
you return it it allows you to have this
clear separation between the two
mutations always have to return some
Lefter return type so in this scenario
telling the patient we just add to the
system and that's useful for when you
could doing any further pre-processing
so the schema so as I said previously
the scheme is kinda like the entry
points into the graph and it's basically
how we can see which fields we can query
on and what they return so this is how
you define a query it's already schema
so it has three properties this query
mutation subscription queries are
mandatory in any graphical schema you
have to have a query mutation
subscriptions and now you don't have to
implement them staged extras ultimately
so what we have here is your aquarium
with object tab and if we look at the
fields which is the most important bit
we have this patient and the patient is
what we're actually going to query on so
if you think back to what was in the
previous example who is quitting on
patient and the arguments was the NHS
number the HS number just a unique
identifier for people in the UK who are
in hospitals and you get it when you a
child but you see the result function
here is actually calling a database and
getting a patient if you look at the
type is the patient type we've created
earlier so ultimately what's is what's
going to happen is if I search for
patient and passion and his number and
pick the field of the patient that
resolved function is going to get cold
and that's what God who makes a deck
with called I could make an API call but
in this instance it basically goes and
gets a patient information so we've kind
of had a look at all of the core
concepts and what graphical isn't and
what not now on kind of jump into a demo
and kind of go a little bit deeper with
it and kind of show you how to create
like a graph you'll if you have some
scratch so first thing you want to do is
we have there's two parts to this
there's a single page application which
I'll show you now so we have this very
simple angular application it's built
with asp.net cores its host and it's
using angular to a type script I think
and it's web pack is going to be doing
all the bundling and kind of the all
refreshing you'll see hot module
replacement it's called so we have this
whole screen and we have some patients
this is kinda like the demo that we saw
right to start and with our mock-up well
have the list of patients and then we
can drill down to these patients to
kinda see a patient summary and then we
have our graph QL server which currently
is a simple web server and this is just
basically an old case web server so
Express server but it runs on not yet so
the first thing we want to do is I'll
have a show you around the structure so
the client is just basically very simple
of a client app and inside app we have a
bunch of components and there's nothing
really particularly special about this
then if we have a look at the server the
server is our graphic QL endpoint so we
have the server GS file which is kind of
like our entry point and we have this
schema folder we're kind of broken
things up into mutations queries and
types and we have this schema tiers we
have kind of a debt-based context which
is comparative and I'll just show you
the database that we're going to use so
the database is a null sequel a sorry a
sequel like one I can actually zoom any
further into this because this
supplication doesn't Columbia to do it
and so there's two tables patient and
patient medication ultimately it's a
very small base so if we go back the
first thing I want to do have a look at
the server that's wrong file
so basically this is a very simple
expressive I've imported all the things
that we're going to use because I didn't
want to download and kind of install the
packages because that's kind of a waste
of time it's not really what I want to
show you so currently as you can see any
quest that comes in is just going to
turn simple web server
I've actually installed the Express
graph QL which is our basically our
middleware and the reference
implementation for graticule
in JavaScript and it's written by
Facebook so the first thing we want to
do is we want to add our graphical
endpoint so we feed in the schema which
is currently empty but we've set
graphical to true and graphical was what
I was saying before was this tool that
used built on introspection and you've
probably seen in some of the examples so
the next thing we want to do is want to
kind of define the type because
currently that this graphical servers
useless and it'll just throw an error
because nothing in the schema so we want
to firstly find out kind of a structure
and our system is around patient sorry
medical it's a medical API so it's
around patients
and medications analogy so if we have a
look into our patient we can add a
patient type in so basically I've
imported all the types I'm going to use
of the strings integers boolean slopes
lace enums and object types and all we
have done here is define our object type
and this is basically very
run-of-the-mill object that we've got
some fields IV first name surname their
birth and then chest number so that
gives us our describes the idea but how
can we actually query that what we want
to get back when we want to return this
type so what we're going to do then is
we're going to actually add in the
resolve function so I've imported a
patient and this is basically gives to
that patient type and we are basically
added some description which we'll see
in the graphical document editor and
then hazily the most important is this
resolved function so this is all from so
currently I'm just returning some
arbitrary day it is basically just with
object so now if we implement our schema
so all I've done is say okay when we
search these fields patient then we're
going to basically go back to our
patient query we prayed and it's of a
patient type and this is what happens in
resolve it so I've got node monitoring
in the background so it's kind of like
rebuilding server all the time and when
I change the file or save a file so
technically if we go back to here and
have a look we should see the graticule
endpoint we'll get rid of this and we
have a look in our documentation we have
this root query tab which we prayed a
patient have a patient type and now if
we use to write the query against this
patient we can see we get a tell isense
have to be the NHS Cambrian but I can
put in anything because I'm not using
that in the backend currently let's type
in first-name we should see the static
date that we get back so this is a test
patient now this that's basically it
that's graphed well summed up in the tea
in terms of its query language and how
to set up regress to your server
everything else now is just flexing and
embellishing the book the kind of
structure that we've made but ultimately
- you have a schema for your entry point
you say how you're going to resolve this
and that's generally just rinse and
repeat that's the kind of pattern that's
used so next what I want to do is I want
to add actually in an enum because
patient we need to know gender so if I
go to types for it this separately we
have this graph QL enum type and
basically this value and value 1 2 &amp;amp; 3
what it generally means is it's just
mapping in the database it might vary
several one two or three is my kind of
indicator sort of enum type so what we
can do then is we're going to port it
into this file so we can actually use it
as a type and then we can add this to
our loops so we've added the gender in
and use our gender enum now if we go
back let's refresh this if we look at
here should see now we have gender if I
was to put gender in it's hard-coded to
one so we'll see male so now we've kind
of enriched our data model a little bit
more what I'm going to do now a little
bit further and we're actually going to
connect now to a database and actually
show you something a little bit more
meaningful than other than an arbitrary
code back resolve function so the first
thing we need to do is go to the server
and I've create this kind of like
concept of a dbcontext I've used to
entry framework or anything I can Oh
aroma I've kind of just mopped my old
version of it and what i'm doing here is
passing in this sequel like library
which is basically how we communicate
with the sequel like database that we
have so inside ivv context the currently
empty so what I need to do is I will
need to add in the query so this is how
a query to get a patient it's very
simple it's just a simple D we get
patent DHS number and just return back
certain set of bills so now we actually
need to return change our result
function but before we can do that we
have to add some boilerplate coding
because we currently don't know about
this DB context anywhere so we have to
kind of pass it around or pass it to
graph QL to pass on to our result field
so what I've done here is is a DB
context the parameter and this context
obviously the special object it's a
global object that you can pass
information to every time you run a
query you can pass the state of your
environment at that point to this object
so you can have things like
authentication viewers and things like
that so you can read about their
permissions and so on and so forth some
spies on the DB context every time we do
this so now what we need to do is just
quickly bootstrap the application
because we're using sequel lights all
we're doing is opening a database
connection once a application runs we're
kind of setting a trace on the queries
they're coming sorry that we're
executing any errors and then if it's
all good we kind of launch application
clear so now the kind of implant
involves things we have to change our
resolve function so currently we have
this arbitrary code returns back an
object now we'll actually want to call
that database method it's ultimately
passed this context through and it wants
dbcontext get patient get a chest number
so now if we go back and I was to
refresh this
try query it comes back as no it is now
actually calling DuBose we're not using
that test data files to go to steal an
ID and put this in its place then we
have basically a connection now to the
database and that's how you can pass
information around so now we've got the
basics and we've got our connection to
the database established I want to do is
add in the medications which is kind of
like what we've seen before we first
have to add in a tight so our medication
types this is basically got a couple of
fields on and then we have to have a way
of how we're going to query this from
the database so it's just a simple view
and get back all the medications by
patient ID and it sets expose this as
our data structure we actually need to
add this type on to our patient it's
actually a nested Association so we'll
import that scroll down
so now we have these medications and
interesting that we're resolving these
on this type not resolved into patient
query because you can resolve fields at
any level as we see every field has a
result function so now as it's actually
worked and I go back hours to fresh this
fires two types of medications now we
have a nested Association I can type in
sir the name of the medication if we
close this we've kind of got now our
association so that's kind of how you
build up your kind of data source or the
date that you want to expose to the
server territory to the end client who's
consuming your graphical endpoint so now
we can look to queries I want to look at
mutations so I've already created an ad
mutation file so the first thing I want
to do is to actually add in the input
type that we care about so as I
discussed previously you can have a
separate graphical input object type
usually you see the object type in the
info object type is a complex type that
you can use with capacity mutations I
didn't have to marry up with your
patient type so basically I'll edit that
and what's gonna happen here is this is
how we're going to query
I also added a mutation in it's going to
return the patient type and the result
forms is going to actually add this
patient this patient when we add it
which to return back the one we've
inserted because our arguments input
takes into patient input type above so
if I was to change the database context
to actually have a real implementation
so if i can format this
kind of did something but basically
we're inserting patient and we're
returning the patient back we just
inserted so now we need to add that to
our schema currently the schema doesn't
know anything about mutations it only
knows about queries so anything if it's
like an entry point so as you can see
now we've got this add mutation which is
imported and similar to have the root
query tap we have our root mutation type
and when we search for add patient it's
going to run the mutation that we've
actually just created so now if we go
back as refresh this to remove it at
mutation I can do add patient and you'll
see now this is actually a complex type
of had a first name I have to fill all
this in what surname
so actually this is interesting so I've
just filled these in now and it's still
got red squiggles under it this is what
I was referring to himself a validation
it basically says the first name surname
test it says it's an HS field which we
need to supply and it's expected cuz
it's not knowable so if I supply this
one two three four and now I can change
the first name because we have to have
return time excuse that we have that so
let's just show it's not smoke and
mirrors and at the bottom we've got a
nine fluency test test too so that's the
only how you handle mutations so we've
kind of nearly come to the conclusion
without graphical end point but we have
one last query that we need to run if we
think back to our application then we
have this patients list we currently
have another query to kind of give us
that information back they're all there
but because we've defined the type I'm
doing a lot of boilerplate
it's fairly easy to add in so the first
thing we do is just add a query of how
we get this information from the
database so all we have here is get all
patients and basically it's a DB all
I'll return everything now if we come
across have a look at our queries we can
add a query to actually handle this
so what we're saying is when we type all
patients in our query we want a list of
the patient types which we've already
defined and then willing to call our
database context so if we go back and we
refresh this
700
interesting right so as you've seen this
is highlight something you can add
associations and you can add types in
keynote stereo stuff but he ultimately
still has to define in the schema
because I didn't I don't actually add
this into the schema the schema has no
way currently all it cares about its
patients in the root query type I've
defined everything else but I haven't
added it actually to the schema so
that's why when I Skyped me I didn't see
all patients and see anything so what we
have to do we have to add this into the
schema and now it's exposed to basically
our consumers our API so now for us to
do this and all patients we can see all
the patients certainly first name and
then I can do said to get the
medications illa name of them and that's
kind of fulfilled everything that we
need to do for our UI but there's one
problem
here and some of you might have noticed
that you might not if I just bring up
the console I'm actually log in the
sequel queries and if you look what's
happened is it runs one query to get all
the patients but then it runs each
resolve function individually for its
medications that's not good my baby is
really small so it looks fast and quick
in the real world you'll get punished
for that unfortunately and get away with
it here but it's not really performant
way of doing it so there's something
called data loader and a lot allows to
back up basically a bunch of IDs and run
all those IDs in one request instead of
adding them individually and running
them against each resolve so I'm going
to do is we're going to fix this so it's
fairly trivial to fix so the first thing
I need to do is I need to add in load S
which is a utility library because I'm
going to do a group by and I'm not going
to write that myself
and so what we need to do is because our
query it's by ID I need to change it to
kind of and any aura need so what we've
got here is I've changes query so it'll
take in like a comma separated listener
and all the scope queries it's going to
group by some fields or the patient ID
and marry up the patient's medications
with the correct patient if it doesn't
have any medications it will create an
empty array so that's pretty much a
query interpret done but we need to
change the service slightly which says
data loaders
we've run her request so basically when
we make a query request it's going to
come in to the same point and we're
going to create this new loader every
time we do it and it's called pressure
medications and it's going to state log
is going to execute our get patient
medications that's ultimately what it's
going to do and that's the query that
we've kind of changing that date with
context as you can see in the context
objects delivering further down we
actually now passing these loaders
through so capacity is loaded through to
any resolve function now that we need to
do clog available so that's kind of the
boiler plate done so in the patient
query instead of sorry in the type for
the patient instead of resolving them
individually we can these our loader and
called a load function and basically
it's going to batch up all the patient
IDs so now for us to go back where you
run this query still works so what the
same data but now if we have a look at
our query oops I wouldn't have to now we
don't have the same I think just nine
before and you can see it's got it's
actually got an incident with all the
IDS so this is one of the kind of things
that when one of the considerations a
little bit further on around has to be
careful about optimizing queries because
you can't get burned quite easily with
the simple resolve functions are
available because it they executed all
the time so as you saw if you had nested
lists and you didn't have a loader you
would basically execute that every time
that you're calling is parent so you've
got M plus one problem
but that's generally our in point
created we could do mutations we've
looked at schemas we looked at types we
looked at queries now how do we actually
hook that changing this event value
other than postman so in our client I'm
actually using a graphic UL client
called Apollo client to kind of handle
the calls for me so I actually imported
over and it's basically this library
called Apollo angular so what article II
does it gives you a lot of stuff around
batching and caching to adapt employment
himself and so if I was to change this
so what we're doing now is we have
basically a query to our Paulo client we
stuck to our query which is passing in
the query that we've seen in the
graphical and basically get the object
back and we're going to assign it to one
of our patients it's just the basically
attacked that it's grade so now
technically this actually does work and
I go back you should see it
automatically populate with some
patients so that's basically made a call
to our graphical endpoint and we've got
the date that we need him there's no
objection there's no under fetching
literally specified all the information
that we want so now if we click through
because we defined all the descriptor
for a patient we can actually fill this
patient story quite easily so if we come
across and have a look at our component
for patient summary
all I'm doing again is I'm taking the ID
from the URL and I'm structuring this
query passing the ID for the NHS number
and I'm getting back all information of
the medications and basically assigning
it to our patient object so I pass the
medications down actually make the call
for it in its parent I pass it down to
patient medications component so
basically it's using the inter input tab
which basically passed it from its
parent so I've got to uncomment some
markup now if we go back technically we
should see that we've got basically
summary and we've got medication just to
prove it actually does work we can click
on any of these and this is actually all
cash now because we're using something
like an Apollo client it caches the data
and it's very clever things that you can
do attaching the batches and where you
an ID but that's ultimately the demo so
we've seen all the core concepts in
action kind of at a deep dive how great
query paddling mutations what schema was
- typed and kind of seen how we can use
it with a real world application now
bear in mind the application is very
very simple but the actual
implementation is kind of we will be
kind of what you do anywhere it's just
the basics now have a look at some of
the considerations of graph QL because
graph QL is not a silver bullet
as you've seen previously with the
performance issue there's other issues
that you need to be aware of if you want
to use graph tool so first ones around
caching with a graphic you can only
cache in two places the application
server which is your SQL endpoint or the
client and you're hoping the client
caches but that's not mandatory you
can't use network caching anymore like
you could do is rest if you guys because
what you haven't seen is when we're
actually making requests to our
graphical endpoint we're posting the
body to our graphical endpoint I request
a no longer idempotent we tack cache it
we can't use network Ashi
it's not a get request or anything so we
kind of have two options here we have to
implement a cache in a back-end which
were between our business logic and
persistence which would weekends like
read through proxy so we check that
first and then we would have this not
then we'd go get from the database but
on the client we create something called
a normalized cash and the normalized
cash is created by the Apollo client and
it's acquitted by relay which is another
library but if you want to roll your own
ultimately what the normalized cash does
is instead of saving the response that
we get back as is it flattens the
structure of it it normalizes it into a
collection of rows and it gives each row
unique ID so then you don't have data
duplication of the same patient in the
cache and so on and so forth and you
have this single solve the truth so
that's what I mean by an online cache
and if you use something like Apollo
client I'll relay that's something you
want to look into because they kind of
give you that for free otherwise you're
going to have to write that and I've
seen I think support if I wrote their
own version of it in Python to kind of
help with some of this stuff those do
McGrath ql but you have to kind of roll
your own so another consideration is
around form that's what we saw it has to
be careful of your queries and mutations
and how to optimize these things because
ultimately as you saw with the drinking
problem n plus 1 and unlike with the
rest API where we have this URI and we
have endpoint it's much easy to track
down where our poor queries are you can
kind of look at the endpoint trace it
through and say ok see the queries run
because these fields resolve us all
running parallel and you can have
resolvers nested within resolvers
tracing the query is a little bit more
difficult you have to plan your debt
structure up front so you can see wound
solutions for this is loaders and
loaders exist in pretty much all
languages now it's not typical of just
the JavaScript world I've seen a net one
I've seen a Java one so security
basically that secures dogs cause
anything that you don't want to be
public ultimately that's the premise of
it but because we have this endpoint
where people can query in any shape and
form and it can do nested queries and so
on it kind of opens us up to a world of
malicious queries so there's a couple of
ways to handle this a very simple ways
to use timeouts if the query takes too
long and you know roughly how long your
query takes you can kill it and said to
talk to anything else and return an
error back or more in depth ways without
hitting the database would be because we
know the query instructor that sent to
the graticule server we can do some
analysis and query depth analysis
basically we kinda look at the query and
see if we've got medication
yes it twice we can't do that and we can
return in a validation layer so it's
much further up in the execution chain
and that's a little bit more involved
but it's generally more bangle then
error handling if you used to rest api's
you can't release HP status codes with
graph drill it does it gives you back a
200 for an error because gradual errors
are actually inside the resolve function
and it's a property that it gives you
back the response will be error so if we
quickly look at our graph QL server you
see exactly what I mean so if I have to
type some rubbish you get errors back a
lot of times you'll get that back into
200 there's scenarios where you might
get it back as a 400 but you can't rely
on status codes anymore so what you have
to do is inside the resolve functions
you can throw a graticule error and then
you kind of just structure your error in
a certain format and you display it
using that so they have to check the
inner response object you can't rely on
stairs clubs anymore so when do you want
to use graticule
and this is probably the ultimate
question that I asked why is it and this
comes down to like any other technology
you kind of have to have a specific use
case for it if you have a really high
queryable API that has a lot of
different clients have different data
structures and they want to kind of have
it all in a single endpoint it works
well with them but if you've got a REST
API which folders good practices it's
not case of just jumping and moving from
one to the other you kind of have to
find the middle ground and I could
anything like I have to test it and see
if it's going to work with your business
and your data structure so now it's got
some resources so these resources are
generally the graphic your website is
really really useful in terms of its
marketing spiel but the documentation
behind it in specs really cool awesome
graphic well just a link a set of links
Apollo client is what we kind of inflate
the client with and then I've got an
application let's look at but the most
important one is if anyone's interested
in play with graphical and doesn't want
a standard for server the bottom one is
printed by Facebook it's a Star Wars API
and it basically gives you graphical
and you can kind of do some queries and
I can put a front end on it you can do
pretty much whatever you want with it
and it's definitely works you don't want
to get involved in curriculum so that's
basically it
thanks very much for your time have you
any questions just come up Natalie yes
right so there's a couple of ways to
handle this there's something called
sequel join monster which will take your
query and it will basically right in
sequel so if you specify the only cons
you're interested in you'll do select
say first name and surname you will get
the whole object back so there's ways to
handle this but ultimately for my naive
example yes I returned the whole dataset
but you generally have to kind of limit
that based off the query that you have
either using a tool like sequel join
monster as will propose Chris or you
can't have to roll your own but yeah
generally you kind of you've moved over
fetching in that sense that your basic
moves adjust to the server so yes yeah
okay so sequel join monster literally
this name will allow you to but it is a
less John and everything that it thinks
is a nested object I'll try and Mario
pids but yes Maya is a very simple
example I had a view that wraps
everything up so it's white as a single
statement paging well paging for graph
Club doesn't exist this is another
caveat unfortunately you don't get
paging like with older you get paging
you don't get with graphic Y so you see
I passing arguments you basically
passing like say top five and you handle
let yourself on the other end the
recommender using slicing but you have
to write all the logic yourself it's in
their best practices as well the dull
they don't have anything built into the
support paging now this is really
baseball actually do do paging but they
have not open sourced their paging
aspect of it so you have to manually how
you wanna do paging if I have to be and
say we've been to argument saying skip
and take 10 then you basically have to
manually pass it to your arbitrary card
at the back to handle it and you handle
that yourself there's nothing graph
field says okay all you do paging let's
help yep now unfortunately there's no
yep yes so so Thomas Cook the flight
company use graph QL as an aggregator of
their server list stuff so they have
graph QL and like lambdas as well but a
general scenario that you'll see is if
you have a lot of micro services and if
you I get with it sits in front you can
put graphical in front of that have your
den scripture call all the API endpoint
t1 and basically the client is only
caring about the graphical
implementation but at the back edge is
resolving each sold separately that's
used in a lot of places in aggregate you
technically don't have to have an FBI
gateway yi so you can bypass that a new
result function call your lambda
function separately if you want I'll
call your REST API where information
lives and just return the single
endpoint so you don't have to have the
area gateway some people put the API
going but the rings around authorization
clear don't to handle it so they do that
much further layer but yeah that's a an
aggregator is a very valid use case of
it and it's quite a few companies which
have not come to the kind of like table
said they're using it but in the
background I know people have using it
like like Thomas cooks a good example
they use it you're all free to go then
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>