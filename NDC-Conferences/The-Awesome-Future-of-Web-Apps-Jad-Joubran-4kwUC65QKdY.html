<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The (Awesome) Future of Web Apps - Jad Joubran | Coder Coacher - Coaching Coders</title><meta content="The (Awesome) Future of Web Apps - Jad Joubran - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The (Awesome) Future of Web Apps - Jad Joubran</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4kwUC65QKdY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everyone thanks for joining
the stock
we're going to talk about the awesome
future of web apps and my name is Jorge
Braun I'm a full-stack teacher and
technical consultant so we're going to
talk about the awesome future of web
apps and this although this is not a
progressive Web Apps talk this involves
a little bit of progressive Web Apps so
I'm gonna start by having the refresher
for progressive web apps making sure
we're all on the same page and then I'm
gonna talk about modern best practices
for web apps and finally I'm going to
conclude with upcoming Web API so let's
start with the PWA refresher
has anyone built any PWA lately okay
great so I think progressive web apps
are an ongoing solution for to solve the
pain points for the mobile web for the
web and especially the mobile one
because the mobile web is very slow and
we aim to solve these problems we aim to
make it faster more engaging with
progressive web apps so your users can
add the PWA to their home screen by
clicking on the overflow menu and Add to
Home screen
and once they do that you have they'll
have an icon on the home screen and if
they click on it they will have an
immersive experience all of this is
possible because of the web app manifest
which is which is a JSON file where you
define key value pairs for the browser
to understand more about your
progressive web app and the most
important keyword of these is display
stand alone which hides the browser UI
and allows you to have this immersive
experience another key aspect of
progressive web apps is serviceworker
traditionally if you have a page it
sends a request that goes to the network
and then you get back the response but
once you have a serviceworker installed
this acts like a proxy and intercepts
every request that goes from your web
page to the Internet this allows us to
do a lot of powerful things things that
we would never thought we'll be able to
do on the web before because we can
intercept new intercept Network requests
we can make our apps work offline they
can receive push notifications and you
can also do a background sync so how do
we register a serviceworker first of all
you want to make sure there's support
for it and then you use the register
method on navigated or serviceworker and
this is a promise so you can make sure
if it's worth or if there was any error
now how do you write the serviceworker
code there are multiple ways you could
use google chrome sw-precache which is a
node module that generates serviceworker
code based on a configuration file so
you could say for example I want to make
as part of my pre cache index dot HTML
and all the images and image folder pre
cached so these are the assets that will
be available to your users as soon as
the serviceworker
is installed and then you simply run
this script pass in the configuration
file and you will have the serviceworker
javascript file so after doing that
after installing the serviceworker
we'll be able to have this kind of model
we have a serviceworker that intercepts
the network request and we can decide to
completely bypass the network because we
have those resources in the cache
and what this allows us to do instead of
going to the network and waiting for
these requests we can consistently and
reliably serve them from the cache and
that's a great win because for those
important resources even if we don't
have internet even we're if we're on a
flaky internet connection we can always
consistently serve them to the user and
then the other part of this is using
sw-toolbox which gives us dynamic
caching strategies so you can decide if
you're talking with an API let's say
you're talking with your own API you
could use you could choose to use one of
the following three strategies
the first one is cache first which means
as soon as something is in the cache I
will keep on using it from the cache
completely bypassing the network another
one is network first which means let's
go to the network let's try to get it
from the network in case it fails we'll
just revert back to the cache so this is
like a fallback mechanism to the cache
and the third one is fastest we'll race
both the network and the cache and most
probably the network is gonna resolve
further the cache is going to resolve
first and by the time the request from
the network resolves we're going to
update the cache for the next time we
use it so let's like let's get up
something from the cache and let's keep
an updated copy in the cache as well
that's coming from the network so and we
typically use both sw-precache and
sw-toolbox together in the same
configuration file by passing a runtime
runtime caching object so you could say
for this pattern whenever I go to the
API slash countries I'm gonna use the
cash first handler and if you're doing
service workers lately there's a new new
library called work box there's nothing
wrong with sw-toolbox or sw-precache
they're being used in production a lot
but there's just a new mer library
called a stub called word box which
combines both sw-toolbox and sw-precache
you could use whichever one you'd like
this one is more modular that's the only
thing that that's different it focuses
more on modularity
what about browser support well I have
to actually have good news so you know
it's stripped on Chrome Firefox Oprah
Samsung Internet and by the way if you
have an Android and you have Samsung
internet if you add an add an app to the
home screen from Samsung internet and
from Chrome you cannot tell the
difference that's the nice thing about
web standards and edge is in support in
development it's been a couple of months
already and Safari the great news is in
development for approximately two weeks
now so that's amazing news so all we
know for Safari right now is that
they're working on the serviceworker
spec so there's also a fallback you can
do for now right now for now for iOS you
could add some proprietary meta tags
like the mobile web app title this is
similar to the manifest title and you
could also do the full screen experience
but I would say make sure to try this
before because if you make your app
fullscreen and you don't test on iOS
there's a high possibility your users
will be stuck there forever because they
don't have a back button so you have to
make sure to test also some users have
reported performance issues it doesn't
always happen so if you want to use
those two just make sure to try it and
this allows you to override the theme
color so that was the PWA refresher if
you've got any questions about
progressive web apps I can answer them
towards the end now let's talk more
about modern best practices and in those
best practices you may see me talk
sometimes about progressive web apps
don't forget because progressive web
apps are indeed the future of the web
even if you don't use them there they
will they are pushing towards best
practices so you can you can extract a
lot of best practices from progressive
web apps so the first modern best
practice is to use the theme color and
the theme color allows you and in Chrome
or in the browser to theme the URL bar
to change the theme and to do that this
is completely independent from the
manifesto JSON if you want to do that
you have to have a meta tag called theme
color which lets you over
the theme color now if you had if you
had a progressive web app I would use
the same value here as the one that I
would have in the manifesto Jason the
next important piece is to optimize the
first paint the problem with the web is
most users are used to click a link and
then see a white screen for five seconds
and then see the logo and then wait for
10 seconds so we want to solve this we
want to optimize the first paint we want
to have something on the screen in less
than 300 milliseconds and to do that in
2017 I'll recommend that you inline the
most important piece of your CSS in the
head so try to go through your CSS there
are automated ways like critical CSS
node module or you could also do it
manually and get the most important
chunk of CSS and inline it in the head
it shouldn't exceed probably 100 or 150
kilobytes and then for the rest of your
CSS we want to load it in a way that
doesn't block and this was a common
challenge but there's a new way to do it
in 2017 so if you wanna is synchronously
load the rest of the CSS without
blocking you want to preload it and to
preload it you use link rel preload has
anybody used it yeah so use link rel
preload specify the CSS file you have to
say that this is a style so a style and
then once it loads you change the
relationship from preload to stylesheet
it's that easy
the only problem is right now it works
on blink based browsers so on Chrome and
opera it's coming soon on Firefox and I
think on Safari as well but for now you
if you want to use it everywhere you
have to have a load CSS script and
polyfill which is tiny so you could also
include it in the head
and for JavaScript you probably want to
use a sink or defer it depends if you've
got multiple scripts you can use defer
to make sure they have all the same
executing order or if you've got only
one script you could use then async and
this will make sure your scripts will
not block the page the page rendering
and when you don't block the page
rendering you'll have something on the
screen as soon as possible another
pattern that we typically use on the web
is called the app shell has anybody used
the app shell maybe a lot of you use the
app shell but sometimes name is not that
common it's just the minimal HTML CSS
and sometimes the JavaScript that you
need to power the user interface so
let's take an example if you open a
native app like Facebook you will see
you will see the app shell immediately
you'll see the navbar you will see maybe
some like you'll see the sidebar and
maybe the container here but you won't
see any content so this is the app so
this is the most important piece of HTML
CSS and JavaScript that powers the user
interface and then once you have the
content the content will just populate
in the view dynamically the reason why
we do the options because the app shell
is static and you can serve this in less
than 300 milliseconds so you serve the
app shell and once you query your API to
get the content you just put them inside
the app shop so how can we do the app
shell on the web it's actually very easy
you can merge this idea with the critic
with the critical CSS and the head if
you want to do this app shell for
example you just inline the CSS for it
in the head because this CSS is blocking
and this is the first piece of code that
the browser is gonna see to make sure
this is prioritized for rendering and
you're not wasting bandwidth you're not
wasting time to go to the network to get
this so and I want to show you here it's
not a magical CSS that you can do an
option in less than 50 lines of CSS but
what I also want you to focus on as well
is the app shell is about critical code
prioritization you thought that the
go back here you thought that this piece
of hTML is the most important one so you
prioritized it you also did the same for
CSS but I also want you to think about
JavaScript because sometimes you've got
like a burger menu that you can see on
top of the fold but if you click on it
it doesn't do anything that's because
the bit of JavaScript for this for this
element was not prioritized you had to
wait maybe 20 seconds or 30 seconds for
this JavaScript to run so make sure to
always think about prioritizing critical
HTML CSS and also JavaScript the next
tip is serviceworker is progressive web
app dependent it's only for service
workers but it will also help you
understand how the browser renders the
page so it's important to delay
serviceworker registration let me show
you why on the first visit when user
first comes to your website you don't
have a serviceworker installed there's
no way you can have a serviceworker
installing your page because this is the
first visit so we can only do a couple
of things to make it fast
we can rely on optimizing first paint
which we talked about we can also rely
on having an app shell to have something
on the screen as fast as possible for
subsequent requests if if there's if
there's browser support for
serviceworker then you will have a
serviceworker running on your page so
you can you can show the content as fast
as possible
so let me show you what happens if you
do early registration so if you use the
snippet of code that I used in the
beginning
so if navigator thought if serviceworker
navigator and then you immediately
register you see we're wasting CPU and
bandwidth to register the serviceworker
which is delaying the first paint which
is delaying the first time experience
for the user so instead of focusing all
the resources all the CPU on serving all
the TSS the index of HTML and the opto
JavaScript
we're actually wasting resources to
install a serviceworker and this will
delay this will make it slower for the
page so what I recommend instead is to
only register the serviceworker once the
page has loaded
so you could simply change it to add an
event listener unload and once your page
is loaded you can then register the
service worker and you can clearly see
the difference here this is how we're
prioritizing the first paint we're
prioritizing the first experience and
then after everything has loaded we then
request to install the service worker
and the background when there's idle
time so that's very important but of
course most of us are using frameworks
and if you do this approach you're
probably going to slow down your
framework because your framework is
running on load so if you have a
framework make sure to run the service
worker only after your framework has
fully booted debugging is also a very
important aspect because we all develop
Web Apps but we need to know what's
what's going on if they're slow if
they're not if they're if they're
considered progressive Web Apps if we
have performance issues or maybe
security issues and the beginnings
become very important and we have
amazing tools actually and in chrome dev
tools if you go to the new application
tab you can inspect the manifest this
allows you to make sure you have all the
required properties without really
having to use your phone every single
time you change a manifest that's nice
to make sure the logo is working or the
theme color background color etc you can
also inspect service workers there's
there are a lot of features here you can
see which Service Worker file is
installed you can also force update it
you can send a test push notification
this is amazing I don't think this is
possible on native apps I'm not sure but
this makes it very convenient to work
with push notifications you can also
send a test sync event you can also
completely bypass serviceworker if
you're working locally and you can also
trigger the offline state because we
want to work more with offline because
this is not a rare scenario this is not
an edge case offline happens a lot and
the best tool the best one the best tool
available right now to
to audit your web apps is called
lighthouse has anybody used it before
this is this is seriously one of the
best apps it's it's a Chrome extension
first of all that lets that gives you
progressive web apps performance
accessibility and best practice metrics
for your app so you just run it and
there give you a score and
recommendations what you need to fix
what you need to work on so this is like
having the smartest person that works in
a browser but just right next to you and
it's also available as a node module so
you can if you're doing continuous
deployment continuous integration you
can also have performance regressions by
using the node module and as of the
recent version of Chrome it's amazing to
see that lighthouse is now available as
part of dev tools so you don't need to
install the Chrome extension you can
just right click inspect element go to
audits and perform an audit even if
you're not building progressive web apps
I recommend that you use lighthouse
because the performance accessibility
and best practice metrics are amazing so
now let's talk about home screen
considerations assuming you built a
progressive web app or even if you don't
but if you have an icon on the home
screen your users expect it to be fast
most users don't even know there's a
term called progressive web apps they
don't even care but if they have
something on the home screen they
expected to have native like performance
we talked at the first problem which is
we don't want them to wait on a wide
screen because it looks like a web page
and the next one for performance is we
don't want to have a slow experience or
we don't want to have something on the
screen that we can't interact with and
there's a common question that I see on
the internet like can I make my website
as a PWA it's like you pass in your
website through a generator that makes
it PWA technically yes you can but
please don't because if you have like
two megabytes of JavaScript and you make
it as a progressive web app it will
still be slow that's a problem so only
try to make progressive web app by
improving your performance and sometimes
unfortunately it means if you're using
old frameworks they have to start from
scratch
big players already did this Twitter
already did this and they have now an
amazing PWA it's just mobile dota 2 calm
I completely uninstalled the native app
and I'm using the PWA it's been about
six months they started from scratch and
started improving performance gradually
so we talked about the app shell and
what comes after the app shell is the
first meaningful paint when you start
seeing something useful on the screen
and then afterwards you've got the ready
for interaction and this is the most
important one sometime a lot of times
you have content on the screen but
javascript is still loading or is still
parsing so you cannot interact with it
and this is a real trace that I took
from my MacBook Pro but with five times
CPU throttling so simulating a high-end
mobile device or you could say low-end
and it takes eight point twenty five
seconds just parsing the JavaScript file
so it could take a lot to parse
javascript file so what can we do about
it first of all I recommend that you use
a source map Explorer or a similar web
pack plugin this is not based on apart
but this allows you to see what kind of
JavaScript you're shipping and you're
most likely shipping things that you
don't want you may be shipping an entire
lodash library whereas you only need a
couple of functions you may be shipping
some testing tools by mistake you may be
shipping two versions of the same
libraries and there's no way for you to
know about this other than going through
source map Explorer or equivalent tools
another important thing to do is to do
use code splitting I cannot stress how
this is important because let's say
theoretically you're not using any
framework at all so you're building
using whatever technology there's no
overhead at all zero eventually after a
couple of months your JavaScript is
gonna reach one megabyte and once you
reach one megabyte there's no way for
this to run fast on mobile there's
absolutely no way even if you using
serviceworker so what you have what you
should do instead you should be only
shipping the JavaScript that you need
for every single page so if I go to the
index of HTML you should
only ship the common bundle the part of
the JavaScript that's used in your
entire app and only the JavaScript
that's responsible to serve the
index.html
you could improve things and preload the
other parts of JavaScript but the
blocking scripts the most important ones
should be only for the index.html
there's no point in serving for example
moment J s or maybe internationalization
or the code that powers the settings the
JavaScript if I'm visiting the home page
that's how we should think about it and
that's the only way to scale our
JavaScript performance there's also an
awesome chrome dev tools feature called
live code coverage has anybody used it
yeah it's amazing you just go to a
website start recording interact with it
and it will show you in real time the
amount of JavaScript that you're using
in green the amount of JavaScript you're
not using in red and if you go to any
any non any website that is not
optimized for mobile like any website
that use jQuery or big libraries you
will see like as 80% of javascript not
being used and or if you're shipping an
entire after js4 for your entire website
without code splitting you will see this
a lot you can also use this for CSS and
if you click on a script you will see
exactly which lines are being used and
exactly which which lines are not being
used it doesn't mean you have to strive
for 90% it's probably too hard to
achieve but if you have like 6040 and
you have a small number of JavaScript
file then this is a good I've been also
doing a bit of research I'm not the only
one who have done this but you can check
out pro metal I noticed that a lot of
websites have been loading polyfills all
the time and especially for fetch fetch
now works on all browsers except a
couple of versions back for Safari so it
doesn't make sense to always load the
polyfill even if the polyfill is not
running
you're still loading about eight
kilobytes of JavaScript so I've done
some research about conditional polyfill
loading and that's how you can use it
you can call the promo fill method and
then give it a test is fetch supported
in window or you could use it for inter
action observer for example and if it's
not supported you can give it a polyfill
you can give it your own polyfill so the
path to the polyfill and then this is a
promise once you resolve it it
guarantees that you have access to fetch
so you kind of delay all the fetch
requests until fetch is loaded or is
available in the browser so the benefit
of this instead of blocking all your up
that is until the fetch polyfill is
loaded and sometimes it's not needed
your entire JavaScript continues on
running but only the fetch dependent
code will be delayed only if necessary
so let me show you how it works in the
browser this is a screen this is a
screen shot from a browser with fetch
support we've got the index.html which
loads the app to JavaScript and then
immediately we fetch the users but in
browsers without browser support without
fetch support this is the index which
holds the app the JavaScript and then
has to go block has to block and load
the fetch polyfill before it's able to
load the users so I think this is a good
approach especially for fetch because
more than 90% of your users have fetch
natively in the browser already
so all of this is me talking about the
mob the mobile web sorry the mobile web
from scratch but most of you are using
JavaScript frameworks and libraries so
I've written a couple of things that you
should look for when looking for a new
framework if you want to choose a
framework so first of all you have to
make sure the framework has a smaller
bundle size because if you start with a
big bundle size you can't do anything
anymore so if you start with like 200
kilobytes or 300 kilobytes of necessary
JavaScript jQuery JavaScript you cannot
do anything anymore about performance
another thing is the ability to code
split because if you cannot code split
in a couple of months you will end up
with a big javascript file a third thing
I think it's very important especially
nowadays is platform leverage and one
example of platform leverage there's no
need to ship a jQuery AJAX like library
or an AJAX like library because we have
fetch there's no need to ship javascript
versions of web api that we now have in
the browser the only thing you should do
is probably conditional polyfill loading
in case they were not available and
there's a framework that does
conditional polyfill loading which is
polymer 2 I'm going to talk about it
later on so in case you're using react
you could use the create react app which
generates I think a PWA for you and even
if you're not building a PWA were more
interested in the performance benefits
you could disable the web app manifest
you could disable the serviceworker
although you should probably shouldn't
should not disable it but you will have
an optimized boilerplate already has
anybody used react with a peek pre act
as a 3 kilobyte alternative to react and
I think this makes it extremely
interesting for progressive web apps
especially uber and lyft are building
progressive web apps with react because
the overhead for the framework itself is
only about let's say 4.5 kilobytes once
you include the router and once you
include a compatibility layer and even
though I wasn't a reactive L appear I
suddenly became very interested in it
because I can develop single page apps
with just a tiny tiny overhead and I
think this is a may
you could also using pre-act command
line you can also generate a PWA out of
the box if you're using view you can
also edit a new app with the PWA
boilerplate as well if you're using
angular that's to say angular versions 2
or above there's the mobile toolkit
which is being worked I think it's for
version 5 but it's currently disabled so
this doesn't work just yet it should
probably work on version 5 right now
what you can do is you can build for
production with ahead of time
compilation and then this doesn't exist
as well you could write it to yourself
this is an NPM script where you could
possibly run sw-precache and sw-toolbox
and all the things that I talked about
in the beginning and if you're using
polymer 2 you can just polymer in it and
then use the starter kit which gives you
progressive web apps and also the purple
pattern the purple pattern is about code
splitting and also at the same time the
same time pre-loading other JavaScript
files that you may need in the next view
and what's interesting about polymer is
that it's only 11 kilobyte on Chrome and
Safari
that's because web components are native
on Chrome and Safari if use on 4f use it
on Firefox you need to load a bigger
polyfill use it on at an explorer and
even bigger polyfill so that's again
conditional polyfill loading that that
makes polymer amazing because most users
are on mobile either Chrome or Safari so
for those users you do not need to ship
more than 11 kilobyte for the framework
itself
alright now let's talk about some
upcoming Web API is that make the web
even more interesting so first one is
passive event listeners has anybody used
it this one is it's very easy but
typically I want you to know that if you
if you add a touch event to your page
you're just making it slower and it's
not your fault this is the way this is
the way events work in the browser the
reason why it's slow is because it's
cancelable you can cancel it so let me
show you why so let's say your user
touches something on the page this is
going to go to the compositor thread
which is then gonna trigger the touch
move and then we call the on touch move
event that you provided so this is the
callback function that you provided and
let's say this is going to take about 50
milliseconds after this runs the
compositor thread is finally gonna
commit it to the GPU so it takes about
60 milliseconds from the user touch to
the commit to the GPU and during this
entire time scrolling is blocked so why
can't the browser just immediately
commit it to the GPU because you can
cancel the event because you could roll
sorry because you could run event or
prevent default so here and the touch
move you can decide not to commit it to
the GPU by running event dot prevent
default so that's why the browser has to
go through all of this before it
connects it to the GPU so that's not
your fault that's a problem that's a
design problem and the way to solve it
and in all browsers it's probably coming
soon to other browsers as well is by
just specifying the third argument as
JSON object passive true and that's a
way to tell the browser
this is a passive event listener I'm not
gonna call passive event not going to
call event dot prevent default and this
allows the browser to short-circuit the
entire thing and directly commit it to
the GPU now of course if you call event
prevent default it's simply going to be
ignored so let me show you how dramatic
it is on the Left you'll see an
unmodified web site and on the right you
see how fast becomes
so I don't know if you noticed though
it's been a while we haven't had slow
scrolling on Chrome on mobile the reason
behind it is chrome 56 started making
most touch events passive by default but
I still want you to know about passive
event listeners because you want to make
fast experiences for Safari Firefox and
other browsers so it's good to use it
even though chrome is doing it by
default and this is only the case for
touch events and wheel events so don't
use passive events if you have a click
handler or update or anything else
another Web API it's very important
because it allows us to defer
non-essential work so this is called
request either callback and you can give
it a call back and this callback allows
you to run small pieces of work when the
browser is idle and this typically
happens right before the visual sync on
the browser right before the browser's
gonna draw a screen on the page and the
browser is only going to give you small
chunks of work because you want to make
sure you don't exceed those because you
want to still have frames that run every
16 milliseconds or every 60 frames per
second so this works on Chrome Firefox
and opera at the moment my favorite one
is called intersection observer has
anybody used it intersection observer is
supported on these three platforms right
now it's a way but Firefox support is
coming very soon it's a way to ask the
browser about a visibility of a certain
element and this allows us to do a lot
of things so this is the element I want
to know how much how much of it is
visible and you also get an intersection
ratio so here's how it works you define
a new intersection observer and you get
back entries in my scenario I only have
let's say one div so I'm only interested
in the first entry and then you get a
property is intersecting which is either
true or false
and then you could know if this element
is visible or not you could also do more
advanced things you can also get the
intersection ratio and then finally
using this intersection observer you
have to observe an element on the page
so you may think this is not a big deal
but this allows us to do a lot of things
on the web one use case of this is
infinite scrolling you could do it in a
much more performant way you could also
lazy load images so if you go on tumblr
for example if you scroll down a little
bit the entire page is extremely slow
that's because they probably load all
the images all the videos ahead of time
or immediately whereas if you can lazy
load some of the videos you can only
load them more once they're in the
viewport and maybe hide them later on
once they're outside the viewport also
ad libraries later on will be able to do
advertisement visibility in a much more
performant way so this is something that
our libraries will be using hopefully
when you have better browser support you
can also do more advanced things like if
you have a video that's playing you can
have a mute button that only shows up
once the video is outside the viewport
and then hide it once it's inside the
viewport
you just have to note that this is not
suitable for scroll dependent animations
I never tried to do parallax I don't
think you should do parallax anyway but
this is only for things that are not
really scroll dependent or like low
latency extremely low latency another
interesting feature is background sync
there are two sub features in this one
the first one already works on Chrome
it's been a couple of months already and
this one allows you to send something to
the network and if there's there isn't
any internet then it waits for
connectivity and it employs an
exponential back-off so it's first gonna
start four wait for one second then two
second and then it grows exponentially
so if you're building a chart
application you could let your users
send a message close your app close
Chrome and once they have internet your
message will be sent but the only
downside is that it only works on Chrome
at the moment there's also another
feature of it which is called periodic
sync which is which doesn't work
anywhere because it's currently being
expect so this might change a lot this
allows you to pull some information from
the internet say every five minutes
and you don't have to specify these two
but you could be more specific you could
say only do this on Wi-Fi so avoid
training and only so I mean avoid
cellular and only do this when the phone
is plugged avoid training
there's also CSS containment and I think
this is a great win especially for web
components with when used with web
components because typically if you
change the width of an element or the
left property then the browser has to do
layout for the entire page and in some
scenarios that this could take as long
as 60 milliseconds whereas if you
specify contain layout for an element or
for a web component then you would
contain the entire layout to that
element so the browser does not have to
go to the root it will only do the
layout for this particular element and
this basically makes reflow much faster
on your page another very interesting
feature is called the payment request
API this is not a payment provider this
is only a payment model the a native
payment model that uses the the
autocomplete for the user's credit cards
and addresses so if you're using
Braintree PayPal you could still use
them and configure it it's just a super
fast way to buy something on the
internet you click on a button it
already has your address credit card you
click pay this allows you to do like pay
you can also do like buy one item rather
than having to add to card create an
account etc I could do like a quick buy
workflow this works on edge on all
platforms even on desktop and it works
on Chrome on Android right now and it's
coming on desktop for Chrome 61 all
platforms
I think Linux Mac and Windows as well
there's also the web share API which
doesn't work anywhere at the moment it
used to work on Chrome I'll tell you why
and it's a way to trigger the native
sharing model a native sharing window
from from the browser by just calling
navigator dot share you give it a title
attacks
the URL and it's gonna open the native
share and you could choose I want to
share this - what's up or to Facebook or
to Twitter has anybody heard about
origin trials okay so let me tell you
more about it previously we have used to
have - WebKit - - Moz - etc all of these
vendor prefixes which kind of roam the
web the reason why those features
existed because the feature wasn't
stable enough but then all of us started
using it to a point where you have had
Internet Explorer had to accept WebKit
properties or as web pages would break
and this was a big problem
so origin trials allow us to do
experimentation on the web but in a safe
way so the web share API used to work
for about six months but you had to
specifically sign up for it and you had
to put a meta tag in the head and this
feature was not always available so in
that way you as a web developer you had
to always check we've done a navigator
share method is available before using
it so there's no way later on if the
spec change that the browser will say oh
we really have to keep that old version
because there are so many websites using
it so it's a way to do safe
experimentation plus the feature will
automatically self-destruct once it
reaches a certain threshold of users so
say if more than 0.5% of the users in
the entire world are using it then the
feature will automatically self-destruct
and that's a good guarantee imagine that
Facebook rolls out web share and then
you have like 30% of the entire world
using it and then the browser's say oh
we have to keep this old version so this
was being experimented for about six
months and I heard there was some very
very good feedback so hopefully you
should see it soon in in browsers
there's also improved add to homescreen
this feature is specific for progressive
web apps and Chrome for Android but this
is how the improved outer home screen
flow will look like once you add to
homescreen I'm using Chrome Beta here
with a couple of flags enabled it will
take a while because it's in beta
but once this is installed you will see
now the real difference you have the
homescreen icon but that's not really an
icon anymore because you could uninstall
it you can find it in the app drawer you
can search for it you can inspect it so
this is a real app it's using web apks
so this is the future of web apps the
future of progressive web apps where you
will have once you add the progressive
web app it becomes a real app on your
screen so you can have it you can remove
it from the home screen you can keep it
in the app store inspect it see how much
battery it's using and this is very
amazing merci very awesome but it
doesn't work right now it's only on
Chrome Beta with the improved autumn
homescreen flag enabled we also started
to see pwace on desktop the first one
was Chrome OS you get an app to shelf
just like you get out to home screen and
if you add to shelf you will get the
chrome the chrome website but without
the chrome UI just like you would do on
Android but you will have the same on
Chrome OS Windows 10 is also working on
the same with edge and the Windows Store
they announced at the build conference
that they started indexing progressive
web apps so the Windows Store will have
progressive web apps there as well so
you can search for them you can also
install them and if you install them
they will be super fast because you're
typically just installing an index.html
it's not like you're strolling 30
megabytes or for an app how many of you
have heard about what assembly ok a lot
so web assembly that's the way that's a
cross-browser low-level language it's
supported on all browsers some of them
are behind the flag but the minimum
viable product it is out there already
some websites are using it this is an
example of a web assembly it's very tiny
this is a sample method that just adds
two integers at the moment so let me
show you how you can use it it's it's a
bit clumsy to use it I'm using
async/await functions but later on this
will become much easier especially what
part what part just received funding in
order to
make loading webassembly as easy as
importing so once you do all of this
once you look fetch the file converted
to an array buffer create a module
instantiated etc if you console.log what
you get back you'll get back a native
add to method in your browser and this
allows you to run native code and near
native performance it's going to become
better and better as we go forward from
your javascript file and what this
basically means why this is amazing this
is your web app or your progressive web
app and this is what the assembly now
there's a bridge between them so we can
do things that we never thought were
possible on the web like image and video
editing already figma which is a sketch
like or Photoshop like editor is using
web assembly on the web for their image
editing software you can also do image
recognition encryption a lot of things
will become possible because for
assembly so I hope I got you excited
about the future of the web I have a
call to action for you if you go to
speedtest.net right now they would
probably tell you thank you for coming
to our website but we don't know how to
build a good website so please download
our app and that and I don't think it
makes sense a lot you may have to do
this in some scenarios but in most
scenarios you don't have to do this it
doesn't make sense to download 30
megabytes on Android and probably 200
megabytes on iOS to do a speed test you
probably on the go
megabytes cost a lot of money and you
don't want to keep storage space for an
app because you just want to run a speed
test also the same for reddit if you go
to read it they will bug you 30 times
like download the app download the app
they even have an option where you can
disable it I don't know why they
complicated a lot we can do amazing
experiences on the web already so make
sure to benefit from this so make sure
to build your first modern web app or
PWA so if you're already working on a
legacy app start a side project and
start by getting rid of your entire
business logic and birth something from
scratch when you build it from scratch
you will understand how then modern web
work
and I think it's very important and then
after you've built something from
scratch you could then integrate your
your but your business model or business
logic and then later on if you wanna use
a framework you could start from scratch
again using this framework but with
better knowledge or better understanding
of the underlying platform also make
sure to always have your phone next to
you if you have an Android make sure to
plug it and use Chrome if you have an
iOS make sure to use Safari
they have dev tools and plug it in
because what takes a fraction of a
second on your on your MacBook could
take up to five seconds on a real mobile
device so you want to always make sure
to test on a real mobile device and when
you're not on mobile make sure to use
throttling features so I typically go
down to regular 3G in the new Chrome
these are slow 3G and fast 3G also make
sure to use CPU throttling five times or
two times CPU throttling and check out
these amazing pwace first of all you can
go to twitter.com and you will see their
progressive web app it's probably less
than one megabyte or say one megabyte
tops on Android it's about 40 Meg's on
an iOS I think it's 150 Meg's so it's me
it's amazing the difference of sizes and
just because we're doing we're using
different technologies also uber has
released a progressive web app that's
using pre-act code splitting as well and
pre loading and this is amazing because
they have like 40 40 different
JavaScript files but they only load them
once they need it you can also check out
we go which is built in polymer polymer
or polymer 2 and Flipkart which is built
and react I've used Google web
fundamentals a lot and Mozilla developer
network throughout my talk if you want
to get more insights about progressive
web apps and modern web api's make sure
to check them out and you can find my
slides online on this talk and my udemy
course on how to become better developer
on this link I hope you enjoyed this
talk we have 13 more minutes for
questions thank you
yes we have a mic
well first of all thank you so much for
the wonderful talk now I just have a two
quick questions so first question is
about like with server technologies the
real challenge in the client-side is how
quickly technologies change and you
summed it really well like it started
off with basic HTML apps back in the day
and it didn't move to things like web
frameworks like react and angular and
now it's moving towards web components
and also towards bwa so isn't this a
challenge for big companies how they
continuously evolve their products and
what do you think can be done to sort of
like better improve that experience and
the only other question I have is you
focused a lot on pwace and while PWS are
really good for mobile applications but
they start son did it say 75% of users
Internet users in the States United
States are still desktop users so do you
think a PWA app works well for desktop
devices just two questions okay so the
first question was how can we what big
what can big companies do about the fact
that what changes a lot okay so I think
I would use the example for Twitter
because Twitter had a horrible web app
which was using jQuery and a lot of
jQuery plugins just take like 20 seconds
to load and then they built and you want
from scratch and then you want from
scratch they built was actually very
slow as well but then they started
improving it step by step I think
there's one thing that really helps you
with this which is focusing on only one
business metric like for uber it's about
only requesting a ride if you're doing
too many things then it becomes very
tough I don't think anybody has built a
pw8 that does so many things right now
and I don't think it's good for UX
anyway so maybe just focusing on one
important aspect just like uber focuses
on getting you a ride in less than 200
kilobytes of JavaScript it's very
important
well depends you don't always have to do
PWA but the reason why I talked about
them because they always push towards
best practices you could take maybe only
the best practices that make sense for
for this enterprise company and for the
second question it was what was it about
desktop yes yes sorry it's like if you
are using the PWA because like you said
angle is gonna introduce PWA support and
ng5 and the reactor is already doing it
let's just say like light like with my
company we are target audiences and
enterprise audience so if we choose to
PW enable it do you think we're gonna
get any benefit I think you already
answered it it's best practices is it
I'll tell you something to you have you
ever used Google and box Google inbox
which is the new version of its already
using service workers and that's why
it's amazing if you're on the plane you
could read previous images you could add
reminders and this makes it all ready
yeah even under stop so I think there's
a lot of benefits for it as well
sure any other questions all right then
you can find me after the talk if you've
got more questions thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>