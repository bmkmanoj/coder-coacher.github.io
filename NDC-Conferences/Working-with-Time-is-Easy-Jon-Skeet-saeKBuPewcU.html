<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Working with Time is Easy   Jon Skeet | Coder Coacher - Coaching Coders</title><meta content="Working with Time is Easy   Jon Skeet - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Working with Time is Easy   Jon Skeet</b></h2><h5 class="post__date">2017-03-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/saeKBuPewcU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning folks I was
saying it's a far from die
crowd this morning worse than even
previous sessions where everyone else
okay I'm ignoring that for the moment
right welcome to working with time is
easy I have been interested in dating
time stuff for about seven years
something like that and I work in Google
currently in the Google cloud platform
net team go and see the booth do code
labs and things but a long time ago I
used to work on Google mobile sync which
was thinking calendar entries and
contacts and emails with over the
Exchange ActiveSync protocol which was
quite odd because at the time most of
our customers were using iPhones so we
had an Apple product using a Microsoft
protocol to talk to Google servers um
but this involved learning more about
calendars partly because of things that
were interesting in the active sync
protocol and it awful time zone
representation
partly because all kinds of clients did
the wrong kinds of things with time
zones and partly because just trying to
work out how to change from one
representation of events or recurrent
events etc to another was extremely
challenging certainly when I didn't have
the background that hopefully I'm going
to give you today so the my underlying
premise is that your code is broken
because it almost certainly is when it
comes to dates and planes we seem to
have a sort of blind spot in the
industry that either you don't know it's
difficult so you don't know as a problem
and you just go along with systems
eight-time and and you know everything's
supposed to be fine or you know that
it's difficult but you assume it's so
difficult that you'll never ever get the
right answer so you'll just be contempt
with being occasionally wrong and my
thesis is that neither of these is true
you can get it right there are things
you can do
in terms of the libraries you use etc
that will make it easier to get right
but you don't have to if you can think
in the right mental models you can use
broken api's and usually sometimes with
quite a bit of effort if you're doing
something relatively to Tareq's but you
can get to the right answer so there are
some slides with bullet points and some
more entertaining slides with pictures
just sometimes bullet points where it's
the easiest way to get things across
there will be almost no code in this
talk I've got c-sharp pad I don't know
how many of you how many of you have
used c-sharp pad before it's very handy
so this is this is just the browser and
this works on mobile it doesn't work
quite as well some reason backspacing
seems to do things twice or something
but this is just a c-sharp pad using
Rosling behind the scenes to get sort of
intellisense and things if the Internet
is working come on okay but it lets you
run bits of code very simply and
conveniently it has note of time sort of
built into it as one of the dependencies
that's just available so I will use that
every so often sort of simpler than
starting Visual Studio but none of this
is meant to be dotnet specific or
definitely not no design specific I know
that the chances of you all going out
and starting to use no time and you know
using.net if you weren't using dotnet
before just so that you could use no
time the chances of that are pretty slim
so the idea is I'm going to give you a
toolkit of concepts but you can then
apply in different ways I will refer to
those concepts with the names we use in
node of time because it's the easiest
way of me keeping consistent and I
should have mentioned if you haven't
heard of it before
no the time is the date and time API
I've written or mostly I've written for
net loosely based on joda-time to start
with but removing some of the what I
consider design flaws of joda-time if
you've not heard of joda-time before
that was a
based date and time API it's got quite a
long history now it has been mostly
superseded by Java time in Java rate the
advice from the joda-time
authors who are also the Javadoc time
authors is to use Java duck time if you
can and I'll come on some
recommendations right at the end so
we're going to talk through the concepts
and then give some advice on how to use
them talk about some of the ways of not
using things including well-worn advice
that goes around the net and isn't
necessarily a good idea and I'll have
some recommendations at the end and it
omits the whole thing and there's a load
of trivia one of the things I have most
enjoyed about Satan plain work is my
word there are weird things that you
wouldn't expect and so I've got a whole
whole sheet of them or sets of sheets of
them this is all just on the no design
website so if you want more details on
any of these things just go to the no
design website in the user guides
there's a trivia page because it's fun I
will not be talking about relativity or
late seconds because for the vast vast
majority of users they do not matter
and when I say users I mean developers
business applications almost never need
to know about leap seconds and almost no
one needs to know about relativity yeah
it makes a difference if you're doing
GPS and things both of those make a
difference for GPS but we're not going
to talk about them I'm also not going to
talk about the different timelines you
ut0 versus UTC versus tii etc partly
because I would get them wrong and
partly because that's a good indication
that you don't need to know about them
if you're doing something that is very
very high precision and you need to make
sure that you're using things that go
against the right the exact right
timeline then you'll probably know
you're in that situation and be able to
deal with it so be aware that it's a
possibility but I won't be going into it
okay so there's a lot of pain I've said
already either P
we'll find time painful or they don't
know that they're finding time painful
and they're just being hurt without
knowing it and just out of interest how
many of you do get confused by Dayton
plane things I've yeah good I'm assuming
that most of you would otherwise you
wouldn't be here um how many of you
would say the principle problem is time
zones oh okay only about half and so
that I can give you the best experience
for the next fifty five minutes out what
else do you find problematic with time
things daylight savings like so that
sort of time zones but even within one
time zone it's a problem okay so
daylight savings and time zones in
general anything else that you would
definitely like me to hit obviously ask
questions anytime and certainly when
we're coming into antipatterns and
recommendations there if you've got
specific how do you know what should I
do in this situation do feel free to ask
even if it sounds like it's specific to
you chances are it'll affect someone
else because yeah almost all
applications need to deal with dates and
claims in some form localization okay
that's yeah that's definitely a good one
and I should warn you now I'm not for
localization expert I have a few
recommendations but for very intricate
localization things find a real
localization expert plan going backwards
yes things about clocks that might not
be what you expect yep
okay I shall cover that later on okay
let's get started
so I'm trying to work out from concepts
from the sort of most primitive ones to
most complicated ones it's not the same
as from the most useful to the least
useful or most esoteric so these
concepts can be applied everywhere but
won't necessarily be exposed everywhere
one of the problems with date and time
API is it seems that certainly in the
past almost all platforms have come with
a awful date and time API to start with
and Java is probably the best example
because Java util date was so dire that
half of it was deprecated in Java one
point
and they introduced the almost equally
dire java.util calendar at the same time
it's a terrible terrible API and very
very badly named because you I think
most of us know what a date is and
that's not the same as a point in time
which is what Java util VAP represents
how many of you are see like language
developers so you're developing in
c-sharp or Java or C++ or whatever yeah
how many of your only JavaScript
developers okay so you're all used to
there being integer types and possibly
you know signed versus unsigned integer
types and in two types of different
lengths and then floating-point types
float double decimal if you're in
c-sharp and these all being useful for
different purposes and you might get
annoyed when you go to JavaScript and
there's only one number type yeah okay
it's exactly the same with date and time
there are different concepts and it's
really useful if they're represented in
different ways and I believe that
historically part of the problem is that
language designers for some reason think
they're also good API designers and they
cotton on to date and climbers that's
where I'm going to make my mark and the
the things you try to do in language
design are try to reduce the number of
concepts as far as you possibly can
that's a good thing whereas in API
design if you've got two things that are
even reasonably subtly different it's
worth having them as separate types
because you're representing the meaning
is your data more accurately okay so
first up sorry is a list of the concepts
that we'll be covering any one
application probably won't need all is I
got ten here ten or eleven this looks a
daunting list and I make no apology for
that but if you've got all of these
things you can probably do almost
anything you want all you need to do is
absorb them so today my slides aren't
online but I'm sure I will put them up
somewhere and the no time user guide has
a set of concepts which sort of go into
this in a bit more detail okay so an
instant incline that is simply an
instant in time that everyone in the
world would agree because they have one
fixed epoch so we might use the UNIX
epoch we might use the UUID epoch which
was the Gregorian calendar changeover in
1582 or whenever it was we might use the
BCL Epoque of the 1st of january
midnight on in year 1 AD or bt is very
air seee and it doesn't really matter
you have a fixed starting point and then
it's an elapsed number of seconds or
milliseconds or nanoseconds or whatever
it is doesn't matter if I say it doesn't
matter how you measure it doesn't matter
what units you use it's just an elapsed
time and so long as we're all using the
same kind of clock and we ignore lete
seconds and things and then everyone in
the world can agree that now is a
particular number and that's all it is
you cannot say this is 9 o'clock because
that's a sort of localized thing for one
thing time zones get in the way you
cannot say it's January the 19th because
that's an artificial concept around
calendar systems which I'll come on
through later so those are all sort of
more human concerns instants are what
machine's dealing ok if you have a time
stamp if you want to record when
something happened this is what you use
a duration this is elapsed time and
that's meant to be that these two
durations are equal so while that's a
duration and that's the duration those
are just equal things and I'm sorry that
I know they're just all horizontal lines
but two durations doesn't matter when
they happen they have no information
about when they happened they're just
something
like 10 milliseconds or a hundred hours
or even two standard days where you say
right it's convenient to think of a
standard day as 24 hours we know that
because of they like saving time changes
days aren't always 24 hours long but the
idea of a standard day is just
convenient I will create something that
will expire in this many number of 24
hours a month and a year those are not
durations partly because their calendar
system specific and partly because they
vary in in duration a month could be 28
days 29 days 30 days 31 days different
numbers in in different calendar systems
and the days the lengths of those days
may vary as well so do not think of
durations in terms of months etc the
timeline I've got here is of instance
again so s1 e 1 start 1 and end 1 s 2
and e 2 these are all instance so one
thing you can do if you're given a pair
of instance is work out the elapsed time
between them okay next up something very
similar an interval so an interval is
sort of like a duration in that you take
a start an endpoint but instead of just
being an amount of time it has anchors
so here we have two intervals which are
of the same duration it's fine to say
what is the duration of an interval but
you can't ask a duration when it started
because it's lost that information okay
so here are two durations which might
both be 10 seconds long but one started
before the epoch one started after the
epoch everything clear so far no
calendars no time zones just machine
time ok now we come to calendars so a
calendar system is a way of breaking up
I'll call it local time so imagine that
we all lived in one timezone
but no daylight saving time or whatever
it's still convenient to break up time
in two days and months and years so this
is in the Gregorian calendar and as it
happens I've represented Monday is the
first day of the week just because
that's what the windows calendar was
doing and that was the easiest way of
making sure I got numbers right but this
is a way of breaking time in two years
months days doesn't really have much to
do with time of day until you get to
really esoteric things that I don't
think anything models properly where a
day is meant to start at dusk or
whatever let's just ignore that because
we're not going to write code that deals
with it if you have to you have my
sympathies and don't try to use my
software ah so this is a calendar system
and now the next concept is fairly
obvious a date a date is associated with
a calendar system and it is basically a
year month day in a particular current
system so this is January 2017 sorry
January the 19th 2017 in the Gregorian
calendar system and if we're dealing
with a timezone loss world then we can
translate dates between one calendar
system and another so you can easily ask
yourself okay well suppose we talk to
someone only using the Julian calendar
system I can convert any date in my
calendar to a date in their calendar
assuming that their calendar had started
and if some calendars have specific
start and end points so in some ways
we're not dealing with a timeline at all
we are just dealing with a sequence of
days so you could almost think of it as
as if there's some kind of epochs that
is day zero and each calendar system
Maps add a number from the epoch
a year month day all still with me it's
vital that if at any point I lose you
you tell me a so that I can get better
at doing this and be so that you're not
confused for the rest of the talk okay
right
do not feel silly by being the one to
put your hand up because they'll be or
please shout out because I a very wide
room there will be other people thinking
the same thing okay so we have a date
next thing that is fairly simple is a
time of day so it's now ident
sort of predict roughly what time I
would get to this slide so it's now here
nine eighteen in the morning no date no
calendar system at least in my mental
model because I don't like thinking
about times that depend on the current
system and no time zone
it's just yo it's what my watch shows if
I sort of cover up the bit that tries to
show the date and is wrong fairly simple
gets confusing when you have to talk
about 2400 I haven't put that as a
gotcha yet and remind me to if I don't
mention it later and then we have a date
and time it's literally and you can see
this in the Noda time source code I've
got a local date and a local time bang
them together you get local date time so
this have effectively add a number in a
particular calendar system and a time
within that day so you could think of it
as a double representing here the number
of days since the since the day epoch
and the calendar system it's a date and
a time and a calendar no time thing
well time zones we had to get there
eventually
a time zone is most accurately its
associated with a region so it's a set
of places that will all be forever you
know within our current viewpoint
assuming there are more political
changes and things they all have the
same local time at any one instant
so everyone watches assuming they're all
synched and in the right timezone will
show the same thing and it's basically a
function that goes from time as a sort
of an instant to the local time and here
we have something that's sort of
centered at the origin probably which
suggests it's probably Europe London or
something similar but other other time
zones might be slightly offset from the
origin but basically given any one
instant any one x-value here you can
find the y-value which is the time it
will say on your watch and so if we have
I can't remember what it is for 2017 say
it's March 3rd that we go into daylight
saving time in the UK that will say well
at 0 59 the next minute becomes 2
o'clock so we skip in autumn we go from
we go 158 159 one o'clock so we go back
down the reason it's useful to think
about this graph is mapping from any
instant in time to a local time is
absolutely unambitious for any x value
there is exactly one y value you know
you come along in exile you go up you
will find one point on the line the
reverse is not true if you take a local
time and try to find the instant at
which it occurred most of the time
you're almost all the time you will find
exactly one thing so if I want to find
when this local time is I can come along
from the y axis and I hit one point on
the line sometimes you will find zero
points if you start here so I can
control the points properly and come
across ah I miss there's nothing
sometimes
it's ambiguous there are two points I've
only ever seen time zones where a
certain local time can happen twice
I really really hope that no one ever
has a time zone where it goes back and
then it goes back to hours and hour
later and things but this is one of the
vital things to understand because at
this point you should be saying to
yourself if I'm ever converting from
local time to an instant I need to
understand that and work out what I want
to do make a decision I should mention
UTC at this point UTC is sort of the
base time zone that everything else is
done as reference to and it's sort of
not the time zone at all so a different
way of representing this graph would be
to show it as just the offset and it
would be horizontal for almost all the
time then there'd be a gap and it would
be a bit higher and then it would go
along until they like same time changes
again and then go down and be a bit
lower so we're currently at a UTC offset
of zero in British summer time we're at
a unit at UTC offset of one okay it's
just the time the difference between UTC
and anything else it's very rarely
useful to think about the difference
between one time zone and another as an
offset and it's what we do mentally if
you're in Paris and you want to know
what time it is in Mountain View in
California you take away nine hours
unless you're in the two weeks area that
either end of the same time where either
we've changed and they haven't or
they've changed and we haven't but in
code you should pretty much always be
thinking about UTC offset
gaps here because of daylight saving
time transitions those are not the only
reasons that time zone change like a
change offset
there are very complicated rules and
sometimes even your standard time can
change so typically we talk about a sort
of base UTC offset as standard time and
then daylight saving time where the
offset is tempura tempura Lee changed
there have been some cases where you go
on to permanent daylight saving time
which is sort of equivalent to changing
your Thunder time but it's depending on
what situation you're in different
people at different countries have
decided different things
the reason UTC isn't strictly a time
zone is it isn't defined for a
particular region I mentioned this is
highly political and it's about
geography so the set of places that
observe Europe London time depending on
whether you want to go from sort of 1970
or not might include Channel Islands or
not but it is it's a set of places and
UTC doesn't have any places but anyone
can decide to sort of think of
themselves as being in UTC it's
convenient to think of it as a time zone
but if someone says it's a lot of time
zone they're being pedantically correct
but not practically useful okay we will
come back to time zones of it but in
particular a date and time in a time
zone is a zone date plane now what I
haven't shown here is all the
information that is required for at
least to know design zone date/time can
anyone think why based on what I've
shown here
so well it's showing the date and where
I am so from that information I could
work out that I'm in GMT I'll talk more
about the GMT BSP names later on so I
sort of there but in this this
particular example actually gives me all
the information I need when might it not
that's okay we'll assume that we have
all the time zones available this would
be problematic if it showed October the
20th whatever it is at 1:30 in the
morning because we wouldn't know we
could have two pictures both showing the
exact same thing that represented
different instants in time because of
the ambiguity I talked about before it
could be the first time that 1:30 in the
morning happened or the second time that
1:30 in the morning happened so secretly
in no time at least if there are two
different ways you can represent this
internally you can represent it as an
instant plus a time zone plus a calendar
system that unambiguously
and efficiently represents all the
information you need what we actually do
because it's more efficient in a
different way is keep a local date time
a date time zone and the effective
offset at that time so that we know
whether it's the first one or the second
one potentially I could just keep a
boolean saying whether or not it was in
daylight saving time but it's much more
convenient to just retain the offset as
well so imagine there's a hidden plus
zero zero there okay next concept is one
that nearly didn't make it into node a
time I think we added it's about two
weeks before the first release which is
an offset date time
quite similar to date time offset in.net
but this fit in with the naming
convention a bit better so this is a
date and time so local date time so it's
got a calendar system and it's got an
offset this is not a time zone despite
what ISO 8601 says so this is an ISO
8601 textual representation of a time
that hasn't started yet so this will be
9:00 in the morning in Mountain View or
Seattle as there on an offset of minus 8
so the offset here is how much you need
to add to UTC to get to the local time
you'll see some POSIX offsets which are
the other way round please try to and
not ignore them as much as possible and
apologies for the confusion some people
were not thinking properly when thinking
about this so you think of sort of UTC
as in some ways a base case and then you
add the offset to get and the local
phone it doesn't mean you need to
reverse it if you want to get from what
you see here to UTC you need to add
eight hours so at 1700 UTC it will be Oh
nine hundred in the offset minus eight
so I said this isn't timezone and if you
take one thing away from this talk it's
do not confuse the two things the reason
it's important is I know what time that
is I know what instant in time is
represented there I don't know what the
local time will be so I'm assuming this
this was actually observed by someone in
a particular place I don't know what
time it will be one minute later because
the person is in a time zone they're not
in an offset and the offset could change
for them one minute later it won't
because nothing has a transition
halfway through a minute anymore but you
know I certainly don't know what time it
we 24 hours later you can do arithmetic
with offset date/time and say well
what's the offset date time with the
same offset 24 hours later but that
won't be what's on someone's watch if
they're in a particular time zone so
there are good things and bad things
about this I do like the fact that it
unambiguously represents an instant in
time with the implicit if you're using
ISO 8601 it's implicitly in the
Gregorian calendar
but it does lose information okay and
final I think concept is a period so I
talked about duration earlier on and
that you couldn't represent a month a
period is for precisely this sort of
thing and as you might be able to tell
from this this is imagine January 30th
2017 and you add a month depending on
what rules you put in you might get to
see brie 28 there are different sets of
rules that would get you to March first
instead importantly calendrical
arithmetic doesn't obey any of the
normal rules of arithmetic so you would
think that if you added a month and took
a month away you would get back to what
you started with well no it doesn't
matter whether you use these are the
rules that no time will obey but
something else might take you to March
first but if you take one months away
from March first you get to febri the
first and if you take one month away
from February 28 do you get to January
the 28th neither of those is the same as
January 30th you get more complicated
situations where suppose we had January
the 27th and we want to add three days
and a month or a month and three days
well how can we do that in node acclaim
I've documented the rules for
predictability which is we do it one
step at a time with them the highest
units first so a month from three days
would be a de month then add three days
and that will give different results
from adding three days and then adding a
month if you want to do the latter then
you could construct two periods and say
give me a let's let's actually show some
code for a change so let's do let's
create a Oh sessions expired just reload
and and shrink it slightly there we go
so using no time so if we have a new
local date time and one thing I will
while we're here strongly advised is
that any time you're constructing things
don't put either month year day sorry
months a year or day month year as
constructor parameters or whatever use
year month day hour minute second
nanosecond whatever it is always go from
highest units to lowest units it's much
less confusing that way end one is start
plus period from months one
so let's first I think I've got the
right example that will show difference
here so if we change the bracketing here
and that's all that we need to do which
is slightly worrying
okay if we now run that trap let's try
let's try the 2017 said yes
no they're still the same sorry
yes so from from days I've just said
it'll do the same do it that's order
anyway and for months okay so now it's
only a difference impacting but in the
okay I'm just confused now oh thank you
well let's let's work out okay let's not
run it this time let's work out what it
should do and then we can check this is
good validation so the first endpoint
we're adding a period of our months and
three days so it will add one month and
get to January the it to February the
27th and then add three days which we'll
get to 28 for a second March the second
and two should be first adding three
days so we'll get to January 30th and
then adding a month so we should get to
February 28 yes wow it worked finally
apologies for the us-centric state
format here that must be either the
culture that this machine the server is
running in we'll talk about that in a
bit right okay so you can see how period
arithmetic is strange and it gets
stranger in different calendar systems
so I happen to choose it's unfortunate
that our month that contains the leap
day is also the shortest month so it's
the easiest to give an example like this
but it's also where the example could
change depending on the year so we would
get to February 29th if I'd started in
2016 instead of 2017 but you know we we
need to deal with leap year
for a single day in the Hebrew calendar
system they have a whole leap month so
some years have 12 months and some years
have 13 months and the Hebrew tongue
system is complicated to say the least
there are various bits of no time codes
that I don't really understand and half
of the Hebrew calendar stuff is exactly
that and it's basically translated from
some Lisp I think into more readable C
sharp but the way that things are
predicted and tweaked so that you never
end up on a certain with a certain
festival starting on the Sabbath or
ending on the Sabbath or whatever it is
but you end up with a weird situation
where there is a month called a dar or a
dar and I don't know how you pronounce
it necessarily if you do please come and
talk to me afterwards because I keep
mentioning it I really should find out
and so in non leap years there's just a
dar in leap years there's add r1 and a
dar - just for fun there are also two
ways of numbering the months
there's the scriptural way of numbering
them or the sort of civil way of
numbering them and each of them has
problems in that in one numbering system
you change the Year halfway through the
month so you end up with sort of I know
month five in year 2000 and then month
six in year 2001 and then you go back
here month twelve in 2001 month one in
2001 that's a pretty crazy way of
numbering things yes the other way that
it could be crazy is that sometimes
depend if you have a DA in the middle of
the Year numbers-wise then one of the
months that comes after a dar of which I
can't remember the names right now with
sometimes v month nine and sometimes be
months 10 and that's also kind of crazy
it gets crazier still when you think
about birthdays so suppose Matt and I
Matt sitting down there we're roughly
the same age on me I think
so suppose in the Hebrew calendar system
we were born in a leap year I might be
born on the 20th of Adar one and match
might be born on the 10th of Adar - so
he's born after me
I'm older than him yeah except when it
comes to a non-leap year when both of
their dolls get smashed into a doll
Matt celebrates his birthday on the 10th
of Adar ten days before I submit my
birthday on the 20th of Adar so you
can't tell who's older by asking how
many years old they are that's really
confusing um okay that's first bit of
trivia I can't believe we've come that
long without without more trivia
okay so period arithmetic is kind of
crazy those are all the concepts you
need to think about and you probably
won't need to think about all of them
but that set should be enough to keep
you going okay can we all agree that all
of those are reasonably sensible you can
you they make sense in themselves they
seem fairly comprehensive if we're not
doing these seconds and things and for
the most part they they represent what
you need to represent in code there are
some notable things that they don't
represent so I've shown a local date and
that tells you if you're recording when
someone was born you could record their
birth date but a birthday is not a local
date so during the 19th is my birthday
that is not a local date June the 19th
1910 six is a date so you may need to
think about a month and day of month
representation and in fact in noted time
too we have annual date for that very
purpose and then you need to bear in
mind that some times it won't happen so
if you have February 29th but not valid
in some years
and likewise you can have expiry days at
our year month without a day I don't
think it's useful have year and day
although you might have year and day of
year but all of these are fairly easy
abstractions that if your domain needs
them I would encourage you to create a
representation for that rather than just
say oh I'll use a local date and ignore
the year part or something like that but
we'll encourage you to do the wrong
thing that's precisely the problem that
system date time has it's always a date
date end time there's no date and no
time properties which is why the fact
that date time dot time of day returns a
time span or a time span is duration as
we described it earlier on and a time of
day is not a duration it sounds like it
should be the elapsed time since
midnight but it might not be because
there might have been daylight saving
transition so 11 that at 11 o'clock in
the morning we might have had 12 hours
elapsed since midnight or we might have
had 10 hours elapsed since midnight or
usually 11 um let's talk a little bit
about midnight how would any of you
define midnight sorry 0 0 okay any other
definitions sorry 24 yeah so you know
basically when the clock says a certain
thing that's one way of defining
midnight another way of defining
midnight is when one day becomes another
those are different definitions because
of another bit of trivia one of the
first things that really caught me out
doing calendar think one of the nice
things about working with Google working
at Google is you get a lot of users and
they will be from diverse time zones and
regions and things so I had quite a few
Brazilian users and I came in one day
and found a huge number of exceptions in
our logs and for various recurrent
events in fact they were all day event
so I thought that final representin all
day
venters starting at midnight and going
to the next midnight that doesn't work
terribly well if midnight doesn't happen
which it doesn't in Brazil sometimes
Brazil decides that where we change our
our time zone goes forward from 1:00
till 2:00
local time and back from two to one
local thing I think the u.s. does two to
three and three back to two are not
entirely sure but Brazil goes not to one
I think one to zero so you're if you're
looking at your 24-hour clock it will go
23:58 23:59 Oh 100 so if you're trying
to say what is the start of a day in a
particular time zone for a particular
date and that is precisely what you need
to ask and that's what no design has and
at start of day in a particular time
zone representation don't assume that
midnight will exist but again it
depending on how you define midnight if
you define midnight as when it switches
to a different day then midnight
definitely does it does exist it's just
that zero zero doesn't exist okay so
more broad sort of how to use these
things I've talked about arithmetic
being weird for I think that as
calendrical arithmetic is the sort of
period stuff with months and days and
years timeline arithmetic is dead easy
so this is where you've got instant and
you can add durations and subtract
durations and in no time we say you
can't add a period to an instant because
that would assume a calendar system you
can't add a duration to a local date
time because you don't know what time
zone changes there could be in the
particular time zones that this would be
in a local date climate remember doesn't
have a time zone but logically it's
going to be in some time zone you just
don't know it know which one it is
arguably you could allow
both period and condor automatic on a
zone date/time but then you'd have to
think certainly for calendrical
arithmetic what happens if I add one day
two zero one thirty one thirty in the
morning and it ends up being skipped or
ambiguous so we say well you have to
find the local date/time do all your
kalindra color automatic and then
convert back into a zone date/time and
tell us what you want to do if it
skipped for ambiguous the philosophy
that I have for nota time is broader
than just note of time and it's the
philosopher philosophy I recommend for
all of this regardless of what platform
you're on think okay I know that's kind
of crazy concept someone suggesting that
you actually think there is no
one-size-fits-all you need to be aware
of the decisions you need to make and in
no design we say well you've got to make
the decision are you going to use an
offset date time zone date time etc once
you've made that decision we shall make
it as easy as possible for you to
express that decision in code but we're
not going to assume that we can just
make that decision for you so this sort
of leads into the second bullet points
I've got here of choosing what store so
people often ask what should I save in a
database to represent X where X might be
a calendar appointment or a timestamp or
something entirely a credit card expiry
date or a date of birth or whatever and
the answer sounds kind of Pat but you
store the information you have do not
store information that you don't have
and don't decide not to store
information that you do have case closed
it's important so if you have been given
if you are told by a user I want this
event to happen at nine o'clock in the
morning in the Europe Paris time zone on
a particular date in 2020
then store that
do not convert it to UTC and store the
instant it's not too bad if it's in the
past but it's a bad idea if it's in the
future any ideas why what do you mean
diet by time zone change right so there
are two kinds of time zone changes that
people think about there's the the ones
that happen all the time in terms of
offset changes really so I'm in one time
zone which is the Europe London time
though I'm not in GMT I'm not in VSP
those are things I observe at different
points in time but I am in the Europe
London time zone currently I could
predict the instance at which 9 a.m. on
2020 January the 3rd will occur and
between now and then there will be
various offset changes as we go into an
out of VSD however given how interesting
political decisions seem to be at the
moment I'm not going to predict anything
about what's actually going to happen in
2020 by then we could have decided to
adopt u.s. time one of the u.s. time
zones we could be a new state within the
u.s. who knows I'm sure that that's not
a pleasant thought either really aha so
the rules themselves can change if I
have locked into an instant in time then
I may be at the wrong local time by the
time 2020 comes along what's also
possible is that you were given an
unambiguous time so suppose someone had
said I want my meeting start at 2:30 in
the morning currently that's never
ambiguous in the UK by the time we get
there it might be
so it gets confusing sometimes you may
have someone who actually says well I'm
trying to represent an instant in time
but I will give it to you in the form of
when it will happen locally and a time
zone if that's what their true meaning
is and you should know this in your
domain then sure store the instant
because that may be what they're
actually sort of locking into and they
don't care what local time it will
actually be even if there are time zone
changes if they're coordinating
something around the world then maybe
that is what they want to do and they'll
want to see the data change if they if
they view the event at a later date and
the time zone rules have changed then
maybe it will and they won't see those
changes but basically store what you are
given if you are given a date do not
store it as a date and time because it
isn't a date and time it's a date and
that will encourage you to think of the
right operations that you can do with
that date you can't be halfway through a
date just a date you don't know whether
if someone said I saw Matt on January
the 18th that doesn't say whether I saw
him in the morning or in the afternoon
so don't make that information up so a
conversion of a local time to UTC is
looting information a conversion of as
the time zone to an offset is also
losing information because the rules can
change so it'll be at a different offset
and it would certainly lose the
information of well what if I want the
event to last an hour and a half or I
want the time an hour and a half later
which aren't necessarily the same thing
because of how you might do the
arithmetic I've mentioned before
conversions between local date time and
zone date time you need to think of the
three cases almost always it will be
unambiguous and that's great you just
need to work out what you want to do if
it's not so you could reject the input
if someone gives you a date and time
that doesn't exist in the time zone
they're in
in it becomes slightly interesting they
could give you one that isn't currently
valid but will be by the time it occurs
you may want to decide to ignore that
problem and but you should at least
think about it you could decide to just
skip to an hour later or an hour before
so think about and if someone says 1:30
in the morning I will and and that hour
has been skipped I'll think that what
they meant to is sort of an hour after
12:30 in the morning so that that
becomes 2:30 that's fine or you may say
well the closest I could get is 1
o'clock or 2 o'clock 2 o'clock being a
better one because one o'clock doesn't
exist either
here you could do 12 59 59 there and if
it's ambiguous do you want the first
occurrence or the second occurrence you
should think about these things and you
should test them I've got down here a
little bit later on testability and I
know I'm starting to run out of time so
I will go fairly quickly now calendars
and cultures we've seen an example of
this already in a teashop pad where I
just printed out a local date time and
it printed out something in Gregorian
calendar but in the US state format so
textual representations and calendars
are not quite the same thing but they're
definitely related and certainly if
you're using date/time so date/time in
net is always Gregorian you can
construct it by saying well I'll give
you this date from the Hebrew calendar
and then you ask for the year that for
the date that you've just given and it
will give you the Gregorian year but
then if you print the value in a
particular culture it will convert it
into the default calendar for that
culture which is most obvious in Saudi
Arabia basically so some Arabic states
which use one of the many Islamic
calendars you'll find that that happens
so if you're logging things not only do
you ideally want to use a sixth
date format so we come here again and
only to refresh so no time so if I'm in
fact no let's let's use date point time
stamp equals 8 time UTC now never use
date time now unless you're really going
to display it to the user on the same
system and you're definitely wanting
their current pointing okay for almost
all cases anywhere you are on a server
UTC now um you might expect that writing
event happened at timestamp
why why why why mm DD T hh:mm:ss point s
FS we'll just go to in a second you
might think that's fine that's going to
be yo always nicely iso 8601 if you're
in the saudi arabian culture then that
would print a completely different year
month day okay so always use the
invariant culture which is easy with
interpolated strings let's see whether
using static system dot formats full
string yes it does have it good we can
just do in variant that and and now it
will always use the invariant culture so
even if you're running on a machine
which is set to the saudi arabian
culture it will still show you that in
your log which you definitely definitely
definitely want you do not want your log
format to be affected by the system time
zone or the system culture
right so that's calendars cultures and
texture representations testability
clocks as dependencies mostly I use
date/time UT female that is untestable
code unless I'm not even sure whether
there is crazy mocking things that let
you change static properties and stuff
in dotnet if there are don't don't use
them use dependency injection if you
wanted to get something from a database
you would have a dependency on that
database of some form yes if you want to
use a clock a clock is a dependency it's
a service that provides you the current
time in no time we have AI clock an
interface and there is a single sensor
implementation system clock so you can
use system clock table instance for your
production code in your test code you
use a fake clock that you can set to
well when you're asked the current time
tell me it's this instant in time and I
won't go into
so clocks should give you back an
instant in time you'll often want to
then convert that into local time it's
slightly painful in Oda time one
slightly better in no time to where we
have a zoned clock which is just the
time zone and the clock together so you
can say well what's the current date in
my time zone what's the current local
time in my time zone etc and finally be
aware that rules will change I haven't
talked about different databases of
playing zones the two that you probably
need to care about are the windows time
zone database if you're using windows
and Ayana which is what the rest of the
world uses I would strongly encourage
you if you ever have any
interoperability with anything non
Windows to use the Ayana time zones so
Europe slash London is the time zone
we're in at the moment in Windows I
think that would probably come as
British Standard Time or something like
that
if you're using Windows and you see a
zone with an identifier that contains
standard time don't be fooled it doesn't
mean it's always Standard Time so
you could have Western Europe standard
time but still observes daylight saving
time it's a mad naming scheme but try to
avoid the windows claim zones entirely
and certainly if you're using dotnet
core on Linux you will be using the iron
plain zones they are governed by Ayana
there are regular updates so last year
there were 10 sets of rules changes
sometimes they can happen with very
little warning so Egypt changed the
rules with 3 days notice and a lot of
confusion I won't go into that but if
you look at code of matcom matt johnson
has a great series of posts or a great
long post about the confusion around the
egypt flame zone change so keep your
software up to date i think the windows
timezone updates are happening more
often they used to it used to update the
database once every six months so if
you're in egypt and if the the last
update had just happened you could be
sitting on the wrong clock for nearly
six months right and you'll find that
you know android and iOS and all kinds
of things operating system updates tend
to happen relatively rarely with notice
time and with various other timezone
libraries you can set the pace yourself
you can say right well i'm doing a
maintenance upgrade I will now knowingly
change my database set of rules
suppose you had stored the local time in
the database as we were saying before
about for an event it's entirely
reasonable to also have a sort of
transient column in your database that
is the current mapping of that local
date and time in sorry zone date time to
a UTC instant because that makes it much
easier to do querying and then when you
know that there's been some time zone
rule changes you can recompute that
column for all of your records it's
great just remember that's not the
golden beta that's not a source of truth
it's a convenience so keep up with
claims own rule changes hopefully I've
covered most of this in before already
rather so don't just store UTC unless
UTC is what you have
so everyone not everyone but you will
widely see people just recommending for
UTC and you don't need to worry about
time zones ever that's complete garbage
you need to think and once you think
coming to the right answer isn't usually
too hard
servers never rely on their time zones
never use time zone abbreviations at
least for pausing if you absolutely have
to for output it's fine services like
the GMT BST who knows what BSC stands
for well that's one of the two things it
means it also means British Standard
Time which was also UTC plus one between
1969 and 1972 when we didn't have
daylight saving time but we did have
Standard time at UTC plus one so if
anyone tells you that the UNIX epoch is
when it was midnight in Greenwich in
1970 no it was 1:00 in the morning in
Greenwich in 1970 that was the UNIX
epoch because we were on UTC plus one
not the UTC existed back then okay um do
not roll out so and time zone
abbreviations are also horribly
ambiguous there are umpteen different
cets and CSPs and so just don't do it
and ask a user for their time zone
instead if at all possible do not roll
your own Dayton plain library by all
means have small abstractions like you
know the Year month for a credit card
expiry or something that that then
piggybacked onto an existing library and
don't do your own only someone really
really into self-harm would would write
their own date and time library I don't
know why um just don't it you will get
it wrong and don't assume if you're
doing a local to zone date/time
conversion don't just assume that it's
ambiguous so it won't be ambiguous just
because currently no one is scheduling
any courses for 1:30 in the morning
doesn't mean it'll never happen yeah
assuming that something will never
happen it's just always a bad idea in
software right yes okay finally
recommendations get the best I'm not
saying you to change your platform but
use the best tool for the job on your
platform currently in JavaScript there's
moment J s there are some others as well
but I think maybe J s is one of the most
popular ones eventually there will be a
new JavaScript date API ACMA committee
39 is working on it and they're thinking
hard and trying to consider whether or
not to include Mars time and we're
saying no don't it'll be far too
confusing and so JavaScript should get
better but find the best library for
your platform maybe there's some other
net library that you think is even
better than no design that's fine just
use something of an make time for
goodness sake and think and document
what you're thinking about before you
write code write lots and lots of tests
and find out when plans own rules are
changing and I'm now out of time come
and chat to me afterwards so that I can
clear clear the laptop for anyone else
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>