<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C++17, part 1: The Language Features - Nicolai Josuttis | Coder Coacher - Coaching Coders</title><meta content="C++17, part 1: The Language Features - Nicolai Josuttis - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C++17, part 1: The Language Features - Nicolai Josuttis</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WDGP5pO1TyM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Nikolai Azotus I want to talk
about sea path of 17 on reason I talk
about it oh I think it's a little bit of
a feedback loop if you lower the audio a
little bit just to be here thank you so
that's before we start I'm curious who
thinks he under he/she on the ETA and
he's the underworld hi out there who
thinks that you have understand
understood everything in C++ nobody okay
who has a recent clue about C++ okay let
me do it phrase of question differently
whose programming in C++ oh they they
raise all the hands so that it okay that
says something and I'm in the same
position the only advantage I have I'm
standardizing see that's what I'm hoping
to standard I see pass us for 20 years
now and I think I have you might have
seen my books can you reduce it a little
bit I think it's long enough okay thank
you so you might have seen my books and
what else should I say about me I'm
self-employed and maybe I'm one of the
few application developers in the
community but that's probably not a fair
statement but to some extent our problem
we have right now is that we are far too
many experts experienced C++ programmers
and sometimes we we are surprised how
people use our stuff and how a few
things they know and so I want to try to
present you C++ 17 here and we start
with its to talks the first talk is
about the language features and then
after the the lunch arm there will be a
talk about the library features and I
will focus not on the details but on the
ideas
and how to use the idea so application
programmers view that's it okay let me
tell you a little bit about C++ as a
general version and simples of 17 as a
general version after C++ 11 we went to
a three-year schedule so every three
years we want to have a new standard out
and it's a time box approach that means
whatever fits in see before 17 is ready
to be delivered we ship it which by the
way cost some reaction because a lot of
things were expected in C++ 17 that
didn't make it so I think so some people
are really asking is certainly the
sequel for 17 worth it but as you will
see I would I would say this is a medium
new release and the medium means that we
got a lot of lot of minor features which
you have problems to talk about in a
whole day and so this is definitely more
than three buses 14 and as I said I
would cover the most important things of
it so first of all let me also talk
about support the good news is that C++
17 will be supported or is supported
already in major compilers so GCC C / AG
+ + 7.1 is released
four weeks ago I think they support all
core features and many of the library
features we have claimed for which
supports most of the core features are
even earlier version support some of
them and Visual Studio 17 also supports
some of the language features but they
will have updates this year supporting
most of all of the features so at the
end of people 417 I think three major
compilers will more less support signals
are 17 completely and that's good news
so that you can use it
um yeah let me skip that so let's start
with the language features in one
feature of the other the first feature I
want to introduce is structural bindings
you see here an example the idea is that
instead of in initializing one object
which has multiple elements you can
initialize multiple objects which
represent the elements so you see here
that I have a structure taking an
integer and a double and if I assign
this structure to an auto u v then use
and V we are representing the members of
Destruction what is behind the scenes
here the reality is that this
declaration creates a new object so you
copy
ms2 a new object and U and V are just
names for I and B so the elements in the
new object so and all routes follow from
them that so there's a hidden object but
you can't access directly but you can
access all the elements in this object
and that works for structures so
especially if functional returns of
structure you can directly assign these
return to members of the structure to
different names and it's an error if the
number of elements or members doesn't
fit you can return an array and can
assign the array elements to names to a
new object which is a name with a name
and then you can also use it for any
object that has a get interface which
this was introduced with tupple and
which for example also applies to STD
array so if you have an LCD array of
forints
returned by a function you can directly
assign it to the names ijk and L which
is you return
you area it's a copy and then ijk and L
are names for the four elements in the
array you can also use this with tuples
so then you even have an heterogeneous
result heterogeneous assigning to a B
and C a character flow than an SC D
string that helps in a in a surprising
amount of of code here's a simple
example if you have a map of string and
double and you want to iterate over it
as you probably know if you iterate you
iterate over a pair and the element of
the pair are named first and second but
this way here you can do things
differently you can declare a cons out
arrest this time so that we don't create
a new copy but that we just have a new
object with this which is a reference of
the element and then directly say that
key and well represent the two elements
in the pair so instead of using first
and second you can directly use key and
value value which makes the code far
more readable and the same is of course
tool if you want to for example iterate
over the elements and modify the values
in the map so next feature we were so
surprisingly happy with the new for loop
the range base for loop that we decided
to extend the other control structures
we have so now we have initializations
for s and switch so if in switch no
longer only take a condition they
optionally take taken initialization and
here you see some examples that work
with that if you have a track like s is
as successful or not you can directly
transfer this to one struct one
statement by saying if status s equals
check and s not equal success and the S
you initialize here is available until
the end of an optional s
statement on which you can for example
use if you have a lock guard so if you
initialize a lock guard and do some
checks you can do that now in one
statement and you don't need additional
curly braces because at the end of this
statement the lock is gone by the way
don't forget to give this lock got a
name if you don't give it a name it's a
temporary object and the temporary
objects goes away after initialization
so that's not what you want so don't
forget this name again and the same is
available for switch statements so one
of the things I'm trying to check is how
what happens if we combine different
features I introduced here so here's a
example if we combine the new feature of
the new if statement and the structured
bindings you can improve code like this
a lot
so guess you want to insert the new
element in a map the element has a
string in the value then you might know
that the return value is a pair where
the second part signals whether it's
successful and the first part is then
explaining why it wasn't successful so
getting you get the details of an
element that was already there so this
is the code usually were right then or
you might even worse like something like
using red dot first arrow first and
nobody connects understand that at least
naively and not knowing the exact
details of the interface that way we can
do it easily we can say well let's first
initialize our a structured binding of
toss and Dany by the return value of
insert and in the same if statement
check whether done was successful
whether it was done and if not let's
initialize a temporary element with the
first element there
with a position so that we have key and
value and then we print out key and
again this reads a lot more a lot better
than before new feature in line if you
program in C++ and a lot of times you
are wondering why why I have to use just
the CPP file to define a global object
anything else can could be in a header
file and but the rule is if you have a
global or static object to initialize it
it has to be initialized in just one
translation unit and therefore you need
one additional CPP file that's gone you
can now completely specify libraries in
header files including all the global
and Static objects in of the library and
the key the trick is to use the keyword
in line so here's an example if you have
defined your own monitor class and you
want to declare a global monitor
object-- just you can do everything in
the header just declare the object
object to be inline and then all the
different translation units can include
this header file and that's it and if
they use proc monitor of the global
object it's the same object in each and
every translation unit so that's that
William that will help to write
libraries just as edified a lot
next thing we extended the idea what is
an aggregate and C++ 17 so now we have
the ability that aggregates can have
public based classes which initially I
think was driven by the idea that for
example you might have a C++ class
extending a see structure and that's a
typical application where you have that
here you have another example you you
declare a structure be deriving from
string and compare
oh well this was possible before but the
new thing is that this is an aggregate
and that means you can use aggregate
initialization here so you can have list
initialization with the curly braces and
you can have nice that list
initialization for the members for the
classes where you derive from so we
initialize here the string of the base
class we derived ephraim and pass the
second in the second initially
initialization as we pass two elements
to the complex which by the way is still
template ID and then the third element
is the initialization of the members so
you can then use the usual way there's
nothing new to deal with it aggregate
and we have a new type trait checking
whether something is an aggregate not
only for those reasons but all but also
for some other reasons because there are
sometimes special rules for aggregates
and if you want to write generic code if
aggregate is helpful next thing we have
now mandatory return value optimization
and copy elation if you have a PR value
which small s can be translated if you
have temporary so that has an
interesting consequence you now can
create a class that's not allowed to get
copied and not to move so it you can't
do anything with it
after you create an object you can't
pass its value to another object by
copying or moving it but this is no
longer true you can now still return it
as a temporary object or if your
function creates an object of this class
because now return value optimization is
mandatory now no copy and no move
constructor is needed and so this works
and the same applies to assignments so
if I then assign this return value to
another object this build works so we
now require this that this optimization
happens and therefore we no longer
require in these scenarios to have any
copy or moose support at all and the
same is true if you pass an object as a
parameter from a temporary so if I
create a new object or I return it from
fool which we define the bus I can
directly pass it to another function and
that's still allowed although no copying
is possible of course it's not possible
if you have an L values own object
already and it should be copied that no
longer 2 s it's not possible to pass an
SD d move of X here of course we
extended the users of context per
everywhere and one example is lambda
lambda are now implicitly cons expert if
they can so here's a lambda taking
square taking the square of a value it's
a generic lambda so taking any type and
returning its square and you can do the
following now you can say I want to
initialize an array of pins with the
crew squared where your 5 and what 5 can
come from anywhere
where you compute the value at compile
time because this lambda by definition
implicitly is not now comes exponent can
be used in context by expression which
means it can be used by the compiler at
compile time you can signal that you
want to have this at compile time to
double check whether it's possible to
use it at compile time so if you there
place context press the compiler will
complain if you do something that's not
possible at compile time for example if
I have a static object inside squared
then this is not allowed to be of this
is not available at compile time and so
this is not allowed to be used in
compile time context so this will be a
compile time error then just the
Declaration of the lambda will
compile-time error we have some small
things are new new attributes and new
route for attribute a for example no
discards and maybe unused and fall
through some of the things some people
already had at lint for example fall
through work case for skate case
statements without the break and notice
card may warn if you if you are not
using the return value and this is a
well at least strange well I should say
it's more than just range it's usually
programming error so usually notice card
we would place where a function returns
the value you explicitly have to free
and then no discard is now in
requirement that the compiler complaints
if you don't use the to return value we
have new places where we now can use
attributes for example we can for
individual values of enumeration says
these are deprecated and we have also a
using declaration which is in general
allows that attributes can have a
general statement so that you don't have
to qualify all the things you want to
use in in an attribute butcher's there's
no nothing useful for that in under
standard attribute but if you have your
own define attribute this might be
helpful and another small fix if you
have snippet namespace you can now write
them as one statement everybody who does
that knows that this is some improvement
we introduced with C path of 14 we
introduced the ability for 10 or 11 I'm
not sure actually we introduced the
ability to align data I think it was 11
so you could say a lime as and that
means that in for example in a structure
you can ensure that your integer in the
structure is aligned on a on a for bite
a dress for battle and a dress also this
was used and respected if you created
objects on the stack but not on the heat
and this is a solution now for the heap
so with the problem was that this means
that we need new new new operators
because now as you can implement new
yourself you have my might have in the
digital argument telling you the
requirement regarding alignment of this
object so this is will extend the
existing new interface if only one of
them provided it will be used by default
in all cases so there your code is still
backward compatible and finally as a
feature arm has include so we have in
practice this problem that in a
preprocessor we want to include
something but we don't know whether it's
available and so we can now program to
try out by the program different header
files here you see the example if we
have any optional then we include
optional otherwise if we have
experimental optional then we include
experimental optional otherwise we do
something else which might help to deal
with the fact that environments have
different states of new features or
libraries of versions ok so far for the
for the coffee church without templates
oh no two others I have sorry I come
back two more and what just wanted to
say so we have now utf-8 character
little booth you can define them but
it's not a trick to extend C++ code to
support fully utf-8 code characters it's
just supported for those characters who
are representable with the single code
unit and we have hex hex also now
supported as a prefix for floating-point
literals so you can do
the things you see here in red with some
roots behind that if you know that it's
already supported as output by the sed
hex load armed money for later and it's
also coming from c99 so this is now
possible if you're in the science area
you might meet that so as promised that
were the language features without
templates now we come to template and as
we all know there's a hidden hidden
statement that C++ is the generic
language I think in when you look in the
standard probably 99% of the standard
features are templates and so we support
a lot of things and of course this
support growth now with C++ 17 in a
couple of interesting directions so
let's talk about them in the second half
of this talk the first thing is we have
a compile time is now that means at
compile time we can say whether we want
to have this compile or not and whether
only the first half of the second half
of the then part of the else part is
some used in your program and whether
that corresponding code is generated
that doesn't mean that the non generated
code the so-called discarded statement
is not checked in anyway the roots apply
as was templates in general so in
general if a template is not used still
some checks are done with that so we
call this the definition face-to-face
checks of dealing with templates instead
of the instantiation phase where we know
how to how the template parameters are
substituted by concrete types so the
first phase also applies here so that
means some if we have code here that
checks FS CD integral if a party is an
integral type
then we recursively call ourselves up
with one less or so so then the else
part
even if P is interval is still
considered and then it depends on the
usual template root so as here dig
undeclared is depending on the template
parameter it will not check whether
undeclared is available because it
depends on the template parameter but if
you have a declaration
that's not dependent on the template
parameter then you will get an error if
this is a problem by the way I should
say that this to face compilation or
two-phase translation transformation of
templates it's not supported in all
compiler which lets to do doesn't
support it yet or they now support it
with the next update of Visual Studio 17
and a couple of code might break because
of that because suddenly the else part
is not just declared or in in old
template the template is not ignored
code is not ignored no longer ignored
some checks are done especially for
everything that's not depending on the
template so that will change with Luther
Studio 17 it's already in the other
compilers and that also applies here so
everything is checked except the things
that depend on the template parameter so
a common error and surprise will be if
you have a static assertion saying now
when I come to here I signal
assert false so compile compilation will
build fail was a message like no
integral this will always assert always
independent from whether T is an
integral value or not that's by the way
we also happen now if if you recompile
code with the new bridge we'll see does
the 17 feature because in general in
template this is a rule and so if you
use the static I surf you
have to reform make a template dependent
again so you have to reformulate the
assertion that to check whether it's not
integral and then it will work as
expected okay
you can even use its context per in
functions that are non templates then
all the rules apply which I just
introduced except those were code
depends on template types so it just
means that we have the checks for
whether the code is valid whether it has
a correct syntax and for each and every
function called it's it's it's checked
whether it's available even if it's part
of the discarded statement so even if
numeric limits on your platform are not
signed if you haven't declared
undeclared this will fair and again if
you have an assertion with false this
will always assert so it follows the
same rules as before but we don't have
any template depending parameter so
having said that these were just from
borning so this is incredible helpful
feature it will it will resolve a couple
of places where we just overloaded
different template functions audit class
template partial ization special partial
ization plus because of reward is having
to have different code compiled and now
we can do it in inner function
internally if it doesn't affect the
outer interface of the function you can
do for example this this is old C++ so
it was a very attic template saying I
want to print the element C passed
element and it could be one or more
element so I pass the first argument and
then an unlimited number of very attic
number of additional arguments the trick
was I printed out the first argument and
then I called myself again for the
remaining argument so what I called me
recklessly myself always printing the
first
and then calling myself for the
remaining elements and if you try that
with Justin if because you can check for
the number of remaining elements this
didn't work because there was this was
not a compile time if this was a run
time it and so the code the compiler try
to compile here was to say well even if
I have no remaining arguments so if the
if statement here results or yells false
I still generate code that print without
any argument should be called and it
says no print that ends this recursion
it this couldn't work or the compiler
rejected to compile it so this for
example now can be changed into if cons
extra and now things work as expected by
the way there's a funny story behind
that the feature is called Express but
it's written is context well it has some
historic reasons and there's also the
idea of explaining it some by saying
well this is the context perversion of
the if statement you can read it that
way but you if you write it the other
way around so we have some confusion but
it's not the first time we have
confusion in C++ and C so if you have if
you want to recursively deal with some
arguments very attic arguments there's
even more there's a so called fault
expression and the fold expression is an
implicit recursion just in one statement
so if you have a very otic number of
values of type T and you want to add all
these arguments instead of doing the
trick I just choke you so recursively
adding just the next element and then
call myself again I can use the full
expression and it's parentheses dot dot
dot and operator then a parameter pick
and then parentheses so this is a host
the whole expression you you have to use
the parentheses here and this expands to
to apply the sum operator to all the
elements or if you have some
additional initialization like in the
second example this applies that that
you add all these elements to zero and
that way you can do a lot of incredible
things and simplify your very attic
template handling
yeah as you will see so here's one
example we can use the fault expression
for almost each and every binary
operator so a for example this is a this
is using this for the member pointer so
for the member pointer operator so guess
you have a node type and inside the node
so it's four three eight four binary
tree and the elements in the node refer
to the left and right child of a tree
and there are convenience names like
left and right which represent these
left and right data members and then on
the bottom you initialize your root with
a new node and then you assign to the
left at the left side of the root and
you note and then to the right side of
the left side of your root and you note
then you can call traverse and well it's
easily readable to traverse from root
left/right and return the corresponding
element and the trick is that traverse
now is not no longer a recursive
statement it's just the fold expression
following all the paths with the arrow
star operator so some cool things are
possible here and fold expressions also
work for types or for expressions that
use pipes so here's a very condensed way
to check whether all my elements in this
template are homogeneous there are other
ways to do that but this is just one way
to do it and that means if I pass an L
and an element of type t1 and then
additional element of type TN with
different types
this return statement checks whether
this type t1 is the same as all the
other types and how is it work because
if I pass 43 so an integer and then
minus one another integer and then a
string constant and then another pointer
then this expanse to it calling is same
for the first elements of 43 with all
the type of the 43 with all the other
elements so that way we can are yeah we
can very condensed check whether things
have the same time I think you've got an
idea of this feature how can we use it
our print examples we just introduced
where I told you compile time if can be
now even be better improved you can say
I want to print all the arguments I no
longer need recursion I just use a fold
expression so saying when I want to
print 7.5 hello and an STD string wealth
I use a fold operator to write out all
these elements one after the other to
see out I can do that the only problem
is no spaces are between so I need some
tricks so I need an ad space a playa
here which can be part of the fold
expression so if I have a helper
template taking just taking an object
and and introducing the output operator
for it with an additional space I can
now use this at space argument or helper
template to use it in a fold expression
to print out all the paths elements with
the space edit and of course you can't
emphasize what you want to add there
after the argument so you can could use
something different or a parameter for
that
look please look at the read ad space
statement look very carefully because we
can all go to the next statement arm
which is it's not necessarily anymore
required
to pass tempted to define template
parameters when you create an object of
a template class we call this class
template argument deduction so whenever
we have functions template parameters
are derived from the passed arguments so
the question was why can't this work for
class template and the answer is it can
now so in the past when we created a
complex of integers which is not always
supported by the way but which is in
principle possible then you had to write
complex of in and then we with the
various for initialization but now we
can skip the end with c++ 17 because the
fact that this complex is instantiated
for in is derived from the fact that we
pass two ends here and if we pass two
doubles or floating-point values this
will be a complex of double of course
and that works with both with it with
the old initialization way with with
parentheses and with a new way using the
curly braces complex is defined as
taking one argument T so you see it on
top template type name T so the compiler
has to be able to deduce this T and if
there is contradicting information it
says if there would be a type ii type
conversion required this will not work
as it would not work for functions so if
you pass v as an integer and 3.3 as a
floating point value this will not
compile and here's another example also
very helpful if you have used lock
guards already
it was always nasty because if you had a
mutex and to initialize the locker
because luck guard was a class you again
had to write lock guard of STD mutex
which is now using this feature no
longer necessary
this is not a very trivial language
features we have a couple of interesting
things to discuss here the first and
folks the first thing is sometimes some
deductions are not possible or do
strange things
excuse me and one feature we have for
this is we can we can formulate
deduction guides so that we say instead
of the compiler here is our guide how to
derive the class template parameters
from the initial values so here's an
example I could I could if I if I'm
allowed to or if we would do that in the
library I could formulate to say if I
initialize a complex of two different
types for example an integer and
floating-point literal then here's a
rule please initialize a complex of the
common type of t1 and t2 common type is
a type trait we have in the library
which automatically finds the common
type of two types according to language
rules or you can also provide some rules
yourself so the ad from a language rule
there if you for example add an integer
with a double the resulting type is a
double so the common type of these two
types is a double so we will initialize
here a complex of double and it will
suddenly work unfortunately we have we
don't have that in the library so that's
not supported and you are not allowed to
support that because user-defined
deduction guides must be defined in the
same context as the original class so
it's the classes defined in namespace
STD also the deduction guys has to be
defined there which they are not allowed
to do but it works I didn't tell you
that so okay but we have some deduction
guides in the library some simple some
interesting here's a first simple
example if we introduce a container like
a vector
to inter inter iterators so what should
be the element type of the vector we can
derive it from the iterator it's a type
it's a value type of the iterator trait
of this iterator
so we're there we can find the element
type so that and that's the
corresponding deduction guy we say when
we initialize a vector by a type named
iterator because that's a semantic we
have here then we try to for this type
to find the iterator trades and having
them the Vario type and that's the type
the vector code would should get so that
means if I have a set of flows and I
initialize my vector with begin and end
of this set then you no longer have to
write vector of flow because according
to this deduction guide this will be
deduced automatically by the compiler
and this is inbuilt in the our library
here's another inbuilt deduction guide
it brings together a couple of features
are introduced already this will look at
the at the bottom first maybe this will
be used that if you initialize an STD
array a by three integers that the array
is an array of three integers so it will
deduce two things type integer and the
value 3 because in STD error is a fixed
size array and how does it work see the
code there we have a deduction guide
taking one type and additional types and
then we say by a trick which is used in
the library a lot that we only support
this deduction guide if type T is the
same as a type u and all the other type
u we have because this is a fold
expression we use there this fold
expression again like is homogeneous we
had before checks whether all the types
are homogeneous
and enable if says if this is not the
case this whole deduction guide is not
available and can't eat to any trouble
and so if the types are the same then we
initialize the element the array by the
type T enable if T then if it's valid
yes to type T and then the second
argument of the error is one plus the
remaining argument because the first
argument for for the teeth the remaining
arguments number is U so in this case
size of dot of U is 2 and 1 plus 2 is 3
so this deduction guide works this is
also inbuilt in the library yeah
deduction cards don't have to be
template ID as you had it here it's also
definitely possible to say I have a
guide that if for typed as a template
type as if I pass a string literal
please did use s to be instantiated for
FC D string
so now if I create an S without
declaring the argument of the template
parameter in any case S will be a CD
string will be deduce if I pass and
string literal and that also helps if
you deal with aggregates for example if
you have an aggregate like like here
there are a couple of language rules
that allow more or less only one the
initialization which is the second one
here but I can say I have a deducting
guide and now I have more implicit waste
even to a tool to define or deduce the
type of an aggregate without specifying
it so here it is now possible to pass a
string directly and to use that for this
string i want to instantiate this
aggregate that the type T is STD string
I skipped the other examples here okay
one more I'm using declarations can now
combine multiple elements so instead of
having three statements in using days a
base B and base e we can now have that
in one statement and this was a side
effect of the fact that we wanted to be
able also to apply very attic templates
here so we want to have very addict
template support in using declarations
this is a complete example maybe let me
look at the time well maybe we have a
little bit time fix turned on there I
explain it I have here customer type and
I have two functional objects one
creating an equality operation for the
of the customer and the other creating a
hash function for the customer and if I
want to create a combined function
object having both the operator to
create a hash function and the equal
function I can derive from both phases
look there over loader is the rice from
a very a big number of base classes and
for each and every base class we use so
we we derive the upper the function call
operator so that we have it available
there but this is a if you use that you
are probably already in the in the world
of the of the tricky template
programming gurus but it's possible
finally for template we can declare now
a template an on type template to take
out all the way even deco type also as
possible which has some strange it
consequences so that template also
saying I'm not declaring what the non
type parameter n is it can be an integer
it can be a character depending on what
I pass here and this can't be used to
extend the the ability of templates
though so you still can't pass a double
here because
it's not allowed to instantiate a
template not site template parameter by
a double type yeah but it works skip
that so we have another thing we
improved over all the different
super-sized versions the support to
write templates for springleaf roads
when we introduced C++ Oh 3 or 98 the
first version we standardized there was
only possible by a trick to say it was
only possible to say I want to
instantiate a template by a string
literal so because if string little now
becomes part of the of the template
class and the trick was you needed an
external string with external linkage so
which is globally visible throughout the
programs therefore you had to declare an
expand Khan's character hello and then
you could use it as parameter
constrictor
arkasha constant what character style is
the general way to write it in a
template with C++ 11 we we reduce this
feature and we said it's also possible
if you have internal linkage internal
linkage means it's not globally
available but it's available in my
translation unit so without the x10 but
it still had to be global now our static
to some extent so now by definition
business has internal language and now
with C++ 17 we have no requirement for
any linkage at all so that means that
you now can declare a local static
string and pass it to a template so that
helps a lot because now you can directly
see that this template is template fide
for the string hello world directly in
these two places them and remember we
have Auto now we can do that with Auto
so I can now declare
template taking at an object of type T
which can be an integer can be a
character but can also be a spring
literal if I pass a static constant
declared directly before which might
also help or serve some meat often
needed is this thing for example if you
have some logging and you want to
initialize the template by some
information spring representing the area
you are logging here so one at time ten
minutes left so now we come on the very
attic part of this talk the next thing
is just a few core fixes and
improvements we improved a lot we fixed
a lot here's the first thing that I
think the most important thing look at
this statement we have a string and I
want to replace some things in the
string I want to read I want to remove
the first four characters then I want to
remove the characters even and I want to
remove the characters don't all know
even is replaced by only this is by the
way an example be honest - so peasant
C++ programming languages see there and
and it turned out it's wrong it's
undefined behavior because the order of
evaluation is undefined here what might
happen is the following we first find
the index of even and the index of don't
then we remove we remove the first four
characters and then we apply to replace
the index of the previous position of
even by the by only which of course then
replaces different characters by
language rules this could happen this
was undefined behavior so we fix that
and by the way another example that
typically typically people make wrong if
I print out the result of a function f G
and H people usually assume that F is
called before G
that's not correct it might happen that
G is called before s so if there are
some side effects between s and G this
is also undefined behavior and we fix
that it's by the way because it does
more or less the same thing as the
example above calling the dot operator
and the order of in the if you pass
something to the dot operator the order
is not defined so we have now a defined
evaluation order for some operands so
dot arrow then all the ampersand equal
operators that plus equals 9s ego's star
equals etc the index operator and the
output the i/o operators and the order
when we have an order of a function call
we don't specify an order now that the
for the arguments a B and C they are
evaluated in that order but we specify
that F so the part before the argument
is evaluated before we evaluate the
arguments so that's specified now and
that solves the problem of us and
finally we had also had a very strange
rule in the language look at this code
and look at the statement the the second
and the third statement a bass and ended
in the top area a2 and a3 I think almost
everybody of you would sing without
having deeper knowledge that a 2 has
type int but that's not correct
according to the language rules we have
in C verses 11 and 14 this a 2 was
initialized as an initializer list of it
and the second took two ends so we fix
that because it did definitely violate
the expectation of programmers and now
with C / 417 this will be an inter x2 on
the bottom is definitely an int now and
if you pass multiple elements there then
this is an error now only if you use an
equal sign so if you use copy
initialization you still have the old
behavior this by the way again means
that we have different behavior
depending on whether we use copy
initialization for the equal sign or not
so there are direct initialization which
doesn't use the equal sign so there
might be a fundamental difference here
yeah but it's definitely an improvement
and finally for static assert it's no
longer required we have a second
argument then providing the string that
should be printed so the compiler has to
find out or how to print in the
corresponding error message in the
language of the compiler we have 30
minutes left so let's talk about why
utility just for the experts who are
here we have changed a feature called
uncor expected and we have replaced it
by uncaught excuse me
uncaught exception and we have replaced
by uncaught exception floor and instead
of saying we are now dealing with an
exception you can check this use this to
find out how many nasty exceptions do we
have right now are we are we in I don't
know in them in a nested third level of
a throw statement also and here you see
which problem this solved guess you have
a Class C so the class here which bonus
if everything is fine commit something
and if not roll back
so transaction safe class and now you
also have a class D and the following
problem happens you create a C and D and
then you throw well then the destructor
gets caught of D the destructor of D
cleans up and for cleaning up there use
again an object of type C so there has
the interesting behavior if you ask them
that are we and are we in an environment
of uncaught exceptions yes because we
are
we are implementing behavior in a
destructor and but still using C is fine
and so we do the following code you see
here we create a C and even another C in
a try-catch block and then we throw
again which is possible but we catch
that because of this practice should
never throw and that means that we now
can find out that C 2 should roll back
why C 1 should commit and that that
helps with the uncaught exceptions
counter within the destructor you can
find out that the number of uncaught
exceptions has raised after the
constructor and that you can use to find
out whether you should roll back or
commit okay so what was not voted in C++
a lot and a lot of really new new core
features I will I will tell a little bit
about that in the next talk in the
afternoon when I talk about the library
but as you see here modules concept
rates curves in reflection was not part
of of C+ or 17s these were the big
things we were expecting and also some
small things we were expecting we are
not adopted so nevertheless I think you
saw already a couple of new features
that help to deal with a day to day
programming and we have the same in the
library which I will explain after lunch
so tell you about the new library
features so I would say that C++ 17 is a
significant improvement it's not a
revolution the revolution would probably
be c plus 20 let's cross singer nothing
let's cross fingers here no not cross
what is the English word for it fingers
crossed so okay I think it's fingers
crosses when you lie no that's something
different
Duffman you know what I mean so let's
hope that in C++ 20 we will have this
revolution and then a lot of things will
change but we have a lot of fixes that
will help in day to day programming the
good news is compiler support is there
try out GCC or G + +7 their online
compilers you can try to even out online
and clang 4 or Visual Studio 17 with the
updates that are coming this year so
they're also already pre candidates that
they do a lot of it and I can also
announce here as an advertisement there
will be books covering this issue I'm
involved into two books the first one is
I plan to write - a book about
programming with c++ 17 there's a
website you can find details and that's
not exactly sure whether it will make it
but what we definitely can promise is
there will be a C++ template 2nd edition
so after all these years I think after
15 years having C++ templates first
edition we now will have a second
edition and it will cover C++ 11 14 and
17 and by the way the book will have 800
pages just describing tempted features
in C++ and it's necessary to have them
so this will be out in September when
CCPD Kong in the US will happen and we
are still looking forward seeds for
seekers was 20 that's it thank you very
much I hope this was interesting and I
think we have time for one question
anybody want to question something I
want to ask something
okay then enjoy I'm I'm around here and
what I can say is at 140 there's a
second part of this talk talking about
the library features than you in C++ 17
thank you very much and enjoy the
conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>