<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cross Platform Mobile with XAML and MVVM - Nigel Sampson | Coder Coacher - Coaching Coders</title><meta content="Cross Platform Mobile with XAML and MVVM - Nigel Sampson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cross Platform Mobile with XAML and MVVM - Nigel Sampson</b></h2><h5 class="post__date">2016-10-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/x266Vy4tfT0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so let's just sit the scene of it
you know we've got a mobile ecosystem
now that's primarily to operating
systems with a third in your life
whether you talking about mobile desktop
etc and these days as developers we're
typically never asked to build an app
for one of these right we're going to be
if we're in the consumer space it's
because we want to better reach
mass-market we want to hit as many of
our customers as possible so we're
primarily going to be in at least two of
these stores if we're an enterprise
you know if it's kind of an atmosphere
where it's device mandated from up on
high then you may just get one but these
days bring your own devices coming along
more and more and you may want like an
enterprise app that hits at least a
couple of these and when we talk about
mobile it's not these days just releve
to the phone it's about tablets you know
it's about TVs and even these days stuff
like hololens right you know all these
SDKs Android iOS and Windows they all
work across multiple more of these form
factors so it's not even these days
about mobile it's it's usually about
apps and how can we get the best
investment from our code and then cross
more of the more and more these
platforms and form factors so we're
going to talk about a bit of an intro to
xamarin make sure we're all kind of on
the same page about what xamarin is not
a not a deep dive just because that's a
whole talk by itself
a bit of a foundational stuff around how
we can share code across platforms and
the different ways benefits and
disadvantages of each approach how we
can do cross-platform
model view viewmodel approach to even
get better code reuse and then
potentially some more advanced patterns
if we've got some time
it's my name's Nigel Sampson I'm an
engineer at push Bay we're a payments
company in Auckland New Zealand and
Seattle as well the project lead on
calibre Micra which is a cross-platform
mvvm framework but I'm gonna try keep
this talks at a framework agnostic for
the most part animal Sony MEP on Windows
platform death
that's my github and my Twitter so if he
wants to reach out later on go
for it let's look about xamarin sarin at
its bare bare kind of middle is a tool
so you can build native iOS and Android
apps using all of their AP is in c-sharp
with native performance so what that
means and this is really important is
you're not building write once run
everywhere you're building a native iOS
app or a native Android app using a
c-sharp so you get stuff like this at
the top there is the Objective C to set
the background of a button when it's
selected right it you can tell it's
Objective C there's lots of square
brackets below is the same thing using
xamarin then the same thing in c-sharp
looks pretty similar which is quite cool
well I think what I think is really
awesome about this is that you don't
have to when you're looking at trying to
solve a problem you know you run into an
issue oh I don't know how to do in-app
purchases or receive push notifications
you don't have to do that how do I do
push notifications on iOS in xamarin
because chances are that's going to get
you like to search results if you can
just say how do I do push notifications
in iOS you can get thousands of push
results and if you've got enough sort of
mental nouse to convert that to that
then you're away and when it's Android
and this is Java it's almost identical
which is fantastic but it's C sharp and
C sharp is awesome yeah we have
async/await
which most other languages still don't
have we have link which Java rate has
got and is just now coming to Android
and we had it what six seven years ago
now you know it gets pretty cool visual
studio and resharper I counted every
shopper so c-sharp awesome so we've now
got sort of an idea about xamarin we use
in c-sharp to build cut to build apps
across multiple platforms this is our
traditional approach you know we have
three or more silos we're saying we're
gonna build an iOS UI in Android UI or
windows UI and then three
platforms this means when we have to
solve a problem we have to solve it
three times in three different languages
if we have a bug
we may have to solve it three times or
we may only have a bug in one miss code
etc but was Ameren it's now c-sharp
we're still building our UIs separately
for each but we can share code across
all of them you know we can share our
application services we can share our
business logic we can share the code
that talks to the shared cloud below it
right so we instantly get I'd say around
about 7080 percent code Reeves at this
point you know where all that stuff is
now shared across all three and it's
it's great we're still writing three
separate you eyes though it's important
to remember so how do we share this code
we've got three different approaches the
first one portable class libraries SiC
one shared projects and then shared
files I've kind of listed them as in
this order because it's my preference my
kind of priority order I try and use
portable class libraries if that doesn't
work shared projects if not shared files
so let's take a look at what that looks
like so I've got Visual Studio
here I've got two projects that aren't
really basically blank file new projects
top one there is an android project no
one below it is Windows 10 so right now
they're not doing anything they're
completely separate I've got no shared
code between them but they are all
c-sharp you can see yeah you know this
is Android so we dealing with activities
and windows we've got our Zemel pages so
if ice to say new project in search for
a portable quickly find a portable class
library in c-sharp let's call this one
port
okay so the first thing that comes up is
it pops up a dialog which is which
framework so I'm a target for this
portable class library well obviously I
want Windows 10 and I want Android now
what this means is it's gonna give me a
library where I can only write code that
is common to both Windows 10 and xamarin
Android I literally cannot write code
that's not possible for both I usually
also pick Windows 4.6 or one of the dock
near frameworks because means I can test
really easily using the built-in image
test you notice at the bottom there it's
going to say well if you pick those ones
I can also give you Zimmer and iOS
Windows 8.1 Windows 4.5 one for free
because they also share that common
subset click OK
and I couldn't you solution what about
switchback you project
pick that portable again
okay so now I have a portable class
library it's basically like the
producers of DLL just like you'd expect
from any other class library but in here
I can only type or only create code
that's shared by iOS or Android and
Windows any basically everything else I
checked already cannot write wrong code
just fantastic so if I jump in here and
if I say yeah you can see these Android
iOS namespaces they are just not there
so this is great this this means that
this code is automatically platform in
specific it means I can run it
everywhere I've checked it and I can't
accidentally introduce dependencies on
those platforms that you know shouldn't
be there this is my favorite approach
because of this right it helps you
basically by letting you not do the
wrong thing you can obviously always
later on come in here jump down to
properties and change your targets
change exactly what you want to target
if you if you need to after that what
are the problems with this well you
can't write platform-specific code in
here and that could be a problem if you
writing code you've got say a service in
here that needs to work depending on the
GPS position then you can't call out and
get the GPS position from the phone or
the mobile device because you can't call
that code but what you can do is create
an interface in your shared code that
then is implemented by something in your
portable library or you start your
platform code that implements that
interface and you can inject it and have
basically good dependency management at
that point using ioc container it I like
this because it means that your you're
still ensuring that your platform code
is still platform in specific and it's
testable so I think it's great too so
not too many downsides for me personally
others kind of see that having to create
dependencies and interfaces as a bit of
kind of ceremony and don't really like
that
and if you're creating a lot of code
that's platform it's depending a lot on
platform stuff and you're creating a
lots and lots of interfaces then you
might not want to go over this approach
so the next one shared projects so a new
project pick shared the shared is
different it came out the distrito 2013
I think it was and what's really weird
about it is that it doesn't have an
output right if you build this project
the shared project won't build anything
just kind of weird until you realize
what it's kind of doing so if I add a
new class to here straight one and what
I'll what you can then do is add
references to it as you normally would
in your other projects except it's under
shared projects not projects just to
kind of fool you a bit so I'm now
referencing this shared project from the
Android and the Windows one what this
means is when I hit build or build my
solution the best way I think about it
is at least is this class filed
everything that's in that shared project
is going to copied and pasted into each
of the projects that reference it and
compiled it's literally a copy-paste
operation almost so why is that
interesting it means I can do something
like using Android
I think I need to build first
yeah
I can actually reference Android code or
Windows code in my shared project I
build this right now it's gonna blow up
blow up the reason is is that this this
file has been copied and pasted into the
windows code and the Android code and
the Android app namespace doesn't exist
in Windows so what do I do
you know I can do if you don't have
compiler directive setup for Android so
if not Windows uwp do some stuff that
works we can out build across multiple
platforms so if I have to work with
platform code I can just if differ and
it animal way this is kind of good if
you want you've just got a little bit of
code that's working the platforms and
you can just if diff bits and pieces but
if you're doing long complicated things
this can get really messy especially if
you're dealing over multiple platforms
and maybe multiple different device in
eum's so if imagine if you had code that
was specific to iOS Android Windows
maybe some stuff that was working on TVs
versus hololens you know you maybe have
seven or eight different platform
definitions you can kind of end up in
like an if diff hell which isn't
particularly pleasant but sometimes this
is the best approach these are really
it's a bit of a ruler just kind of war
between shared projects and portable
class libraries personally I prefer
portable class libraries but some people
preferred shared libraries it's for me
it's mostly about PCOS enforcing the
rules and you can always go back to the
tried and trusted approach of an
existing file and just share files share
files between projects that registry has
supported since time and material one
thing that has been good since I think
2015 is if you are using shared projects
or shared files is this third drop-down
up here which is shows you basically
which projects this files in and you can
switch context between them as you can
see here that this is now grayed out
because obviously I'm in the uwp project
and if I switch it back and it's
re-enabled so that's how we share code
across different share code across
multiple different platforms but well I
think we're leaving when we do this we
have a shared UI we have a sorry a
separate UI and then a shared
application services we're kind of
living money on the table here this
stuff in the UI that is shared across
multiple platforms right our behavior
and our state of our view is the same on
each one it's just ultimately the view
itself that's different
so this is where mvvm comes in now it's
it's about seven or eight years old now
it kind of came out with Microsoft and
WPF but it's realistically it's older
than that and if you've ever read Madden
fellows enterprise architectures books
it's basically the same it's
presentation model so it's quite an old
pattern
but it's kind of ripping revamped a bit
so this is what we talked about this is
where we get a shared stuff we really
want more than that now if we can pull
out the behavior and the state of our
view into something else to a view model
that can be shared it becomes easier to
test because it's in a PCL it's
hopefully in a PCL of something that's
separate means we don't need to try and
do an automated UI test we can easily
test this stuff and therefore it becomes
easy to maintain right we can get
automated testing we don't have
regressions on this and then therefore
easy to evolve so this is kind of what
it looks like we have our view that
hasn't changed we extracted State and
behavior out of that into a view model
behind this is it our sort of ubiquitous
model that's kind of everything else in
your application and we can now unit
test that stuff pretty easily in between
here is the kind of the what I call the
galue we have user interaction coming
from the view into the view model things
like button clicks scrolling may push
events from the view to the view model
and then this view state shifts between
them typically with some sort of binding
framework so as text boxes change they
push stake from the view into the view
model
when the view model may reach up the
model to get maybe get things from the
cloud when that comes down their view
model state changes and the view changes
to reflect that so as I said this kind
of came out of WPF and there's a more
stuff and the reason is that the zoom or
frameworks have a lot of built in things
to support this sort of pattern you know
with data context and binding and
commands it's really easy to do that
that middle layer that that glue that
sits in here it's very easy in Zen or
frameworks but you don't need it to do
mvvm right you can do this now without
it it can just sometimes be a bit easier
so let's take a look at what this looks
like so I have a solution here I've been
playing with a lot with VST s lately as
a potential build solution for calibre
micro have a quick app just demo it here
so lets me log into bsts within a user
account and a token I get the projects
that are in my build a my sort of my
DSPs project I can see the last 20
builds or so what the status was when
they happened and I can cue when you
build it's happening really quickly
because I didn't think it's gonna work
and it's all been stubbed out but the
codes in there if you want to see it
later on now we'll look at the first
part that login view model so if you've
looked at login like mvvm before you'll
probably see quite a this quite sort of
similar pattern I have an accountant
token properties the foreign property
change notifications to tell the view
that hey I've changed you should update
yourself but I'm also firing a change
notification for a property called can
login which you can look down here and
that's simply computed as is the account
not empty is the password not empty yep
you can log in and we have our login
method down here chicken credentials
chicken authentication service is it
valid if
sweet if it's velcroed intial store them
and then navigate out to to the next
page we can test this really easily so
I'm using X unit here so I can quickly
test can login with various different
pieces of data and verify that can login
changes to what I expect I can use
mocking and sort of integration bit on
that integration but sort of state based
testing to verify that when my view
model is activated that we get
credentials out of the credential
manager and then I can verify that when
there's a successful authentication that
we never get into the next project this
is all possible because this few model
is in a portable class library that's
not bound to a UI layer it means I can
do all this testing without having to
try and spin up a simulator or the
emulator I can test it independently of
user interface which is quite cool but
you'll notice there's a lot of ceremony
in here few models can be quite thin in
terms of their state and behavior
because they typically pass things on
from the UI through the view model onto
something else but there's a lot of
ceremony we can see here about these
property change notifications it's which
means we need automatic backing fields
and so on but there's a few tools to
make this a lot easier
the first one is c-sharp 6
c-sharp 6 is fantastic for this so I can
do something like using static systems
string and therefore my string dot is
not really just becomes is another empty
I can use expression bodied properties
so my long complicated get login just
becomes a one-liner
and I'm using a tool called faux d dot
property changed so this is an il
rewriter so basically what it does is
that compile-time pushes property change
notifications into here for me I don't
need to write them myself
and because I've marked up can login
with depends on accountant token when
accountant token change they also push
notifications for can logon so my view
model becomes that half the size and
it's much easier to kind of reason about
and it's the same basically
functionality is identical to this one
here it's just got a lot less ceremony
stuff you don't need you don't care
about so how does this look in the UI
layer
well we this is the Windows 10 version
we have our UI layer I'm using caliban's
kind of sort of magic binding so what's
happening here is I've got a text box
named account caliban's gonna
automatically go all right
I should 2-way buy into that to the
account on the view model same with
token and then it's gonna look at my
password there my sir my button realize
that six named login so when I click
that it should call the login method my
view model and it's also going to notice
that because we have a property called
can login that when it fires when that's
false the button should be disabled so
right now everything's all set up if I
click my account log in is disabled when
I click buttons in here the account is
updated can login is updated my button
is Joe I think so this is awesome a
little simple binding between the two
and it's this is why I talk about sort
of sam'l being better for this in effect
that this is a lot more out of the box
but all the other platforms can still be
done pretty easily
so if you want to look at 30 property
change and I highly recommend you do
that's the URL I love that are you were
off the talks that are on so you can
always come get these URLs letter
there's a lot of great in Vivian
frameworks out there freshman VM it's
written by Michael redlund who's here at
the conference you've got to catch them
it's a really good xamarin forms focused
one mvvm light has been around for a
long time by Laurent Beyond and it's
kind of the granddaddy of all of these
and it's a great one as well
in vvm Crosse is one that's really
focused on xamarin prism by Brian
lagunas who's also here in the
conference is one that kind of came out
of Microsoft in WPF and has moved on to
xamarin as well and reactive UI who's
also some guys here like britain
forester from github who you can catch
as well is a more reactive extensions
focused in the vm framework and
therefore if you if you're doing really
kind of big and complicated view models
so it's quite a good one
and of course calibre micro i've got a
plug as well so this is what we end up
with we end up with a three separate
user interfaces store we've now got
shared view models in a PCL that we can
test independently of a user interface
we can share them across all of them but
we still kind of have this middle layer
of platform-specific code which is
things like push notifications Maps bits
and pieces around stuff you can't share
across all platforms but isn't user
interface itself the other thing is also
what is the view in all of these
platforms a lot of people get kind of
confused by this
the reason is Apple call their their
views of view controllers which i think
is a bit of a misnomer the view
controller and storyboards in the iOS
are the view name vvm they're not the
lot of you controller and sense that
they are heavily tied user interface you
can't instantiate a UI controller and
test it independently of it
being inside a simulator so therefore in
vvm to parents it's the view same for
Android activities layouts etc these are
all the view if you can't work with them
outside of the device then it's the view
and for Windows it's the same on the
page class so what we end up with is a
bit of Gulu we need some glue between
different platform between the view and
the view model for each of these
different platforms now this is a great
library
it's called bind it's really really
simple you can download it's about a 1 C
C sharp file you can include in your
project or you can get it from Newgate
which I'll show you now that glue is
what you need to do bindings sort of
sort of things you don't need any if you
don't want that to pull in a framework
then you can do-it-yourself manual kind
of binding between the view and view
model is perfectly okay it can be a bit
more work but it depends on the view and
it depends on the view model so when we
have platform-specific code or we have
dependencies on specific features for me
the best way we treat them is just
another dependency right we do our view
models depend on things like our
application services to go get stuff
from the cloud or from a database
these can just depend up do the same
thing and depend on platform features
fire interfaces which means we keep them
testable markable we can do stuff a lot
more automated I mean a great example is
this code the code in these demos was
previously talking to the bsts api to
our HTTP when i got got here and
realized how shocking the internet was
we you know quickly mock out write some
offline services that do the same thing
the view models don't have to change and
it's the same sort of thing with the
platform specific features as Emran have
helped with this there's a lot of
plugins you know there's a lot of stuff
we're all going to want to use we're all
going to want to check is the network
available we're going to want to check
what's the battery level or what
location why
you know and having to write our own
abstractions there interfaces and
dependencies it's kind of a waste of
time so this URL is a fantastic one for
sort of a lot of that shared code so
let's take a look at what all this looks
like so I've got my core project which
is portable and has out has our few
models so keep-keep sort of focused on
this login view model now when I looked
up here we look at its interface here
it's depending on the credentials
service so this is me saying I want to
store credentials somewhere but that's
really going to be a platform specific
feature each mobile platform is a
different way of storing local data so
in my services I have my interface I
credentials service ID CD get
credentials store credentials night I
think particularly complicated but
there's no implementation in my portable
class library I can't I can't write one
they're shorter than potentially if I
wanted one saving to the cloud
I could but I want the storing locally
for a you know safe password so if I
open up my android project under
services we have a preference credential
service which basically uses the Android
reference manager just all tokens to
implement this interface on iOS we have
pretty much the same thing except it's
in what they call you in this user
defaults so this is a way basically
we've abstracted our storing of
credentials into an interface part put
the interface into the view model and
then implement that later on we've got
other ones here for implementing
dialogues as well so what does this look
like on other platforms then the windows
because that's the more interesting ones
in my regard so if we look at
Android here look at the login activity
so this is essentially the glute what
was kind of Auto a magic and there's a
mall one with Caliban you know we're
doing this ourselves so the first thing
we do is finding our sort of four
important controls we're looking for our
text box accountant token looking for a
login button and we're looking for the
message text within basically saying on
click call login you know we're wiring
this up manually and then we're creating
four bindings using that bind framework
basically two-way bind between account
text and the model account and that's
that's pretty much it we're not we're
not doing too much here so it's not as
easy as sort of the Zemel stuff but it's
not tedious it's not you know thousands
of lines of code if we look at our
projects activity which is that projects
list it's it's a lot simpler we couldn't
we've got a projects adapter which is
basically the way that Android does
bindings to list views it leverages
properly changed on the view model and
it will also it's got a bit of
convention stuff in this so it'll look
for like if on the view side it'll look
for if you say you bind into the text
property on the text box it'll look for
stuff like is there a text changed event
and therefore try and wire that up to
get binding the other way as well I
think it also defaults to things like
somewhere in here there's a list of
looks it looks for things like editing
today didn't value changed on our oh s
so it's got some built-ins stuff for
like sort of hunting down appropriate
events in the UI layer to get their
binding of hey the text box changed push
it back to the view model and then
obviously on the other end it's looking
at not affair property changed
it's a projects adapter has basically
built on top of bound adapter which is
sort of a utility class for me which
works off base adapter
which is that sort of out of the Android
box SDK this doesn't do much beyond
saying I have an observable collection
if that collection changed tell Android
that stuff changed the important part
here is in this UI we've got basically a
simple text box all we're doing in our
projects adapter is inflating a out of
the box template simplest item to and
then sitting the properties on it and by
that view model so this is very manual
binding but it's not overly tedious and
once it's done it's kind of done you
don't really need to change it so this
is the glue that sits between the view
and the new model it's not overly
complicated and some mvvm frameworks
have larger binding frameworks built in
or you can use ones that are kind of out
of the box sort of independent like that
bind you'll notice here I'm also
attaching to that list item click and
passing it on to a few Model View
project now let's jump back
so we still got three separate user
interfaces and some people don't like
that
yeah want I want to write one I wanted
to run everywhere and I still don't
think Java was a problem in this but we
can always abstract that you're right
and some people do some people create
their own little UI abstraction layers
of the top of all three of these
platforms it can get really complicated
but some people do it
and xamarin have seven forms it's a
great example of this and then you end
up with something like this if shared
views if shared view models if shared
application services but you've always
still got a little bit of platform code
because you have to do something like
that to get to things like the GPS and
storage and all that so let's take a
look at designer in forms and view
models so I'm going to keep using the
same view models we've already got but I
now have in here for new projects the
important one here is forms core now
this is a PCL this is platform
independent and it depends on xamarin
forms which is also a PCL thankfully I
can help I can declare my views and here
as is mo the important thing to remember
here this is not the sam'l you may have
learnt already
this is xamarin forms mo it's different
and when I get together talking to
someone team it's intentionally
different it's not supposed to make you
think it's Zemel you know for maybe WPF
things like what you call textbox I call
the entry here
Steckle out its stack panel button is I
guess always button because there's no
better name for that but the layout
system is different in its independent
but it's something that's shared across
all different platforms and the beauty
about Simran forms is like just like the
or frameworks it has a binding system
built-in so we can in here bind the text
box text of this entry to the account
two ways it goes back and forth we're
binding one way to the feedback and
we're also attaching the log in this is
calibre and obviously attaching the
login method to that button now this
means we've got pretty good shared
libraries so if we quickly look at this
on through flames and zamarons doing the
work here to when it sees button or
entry render that in an appropriate
native control for that platform now
what this looks like
can be a bit different but we can fire
this up here we get our same sort of
behavior and then windows 10 it looks
like what they've done is not do as much
work on the render as here on Windows 10
so this one tends to look a bit uglier
but so these two UI is they're coming
off the same bit of zamel right we're
sharing them over all these platforms
the iOS ones there if you want to look
at it in your own time but and only want
to invoke the demo gods and have a Mac
here as well
we now got the same Zemel in a portable
class library it's referencing a view
model that's in a portable class library
all this stuff is platform in specific
it can be tested outside of these
emulators which is great and it means I
can start to implement because they've
abstracted things like dialogues and
navigation and user interface means I
can actually start what were previously
platform specific implementations of
interfaces and now shared ones so in my
portable class library I have this
action sheet dialog service implement
side dialogue and this was previously
have them
ended on android iOS and windows I can
now share it across all three but some
of them I might still need to go back
and look in our forms host here we still
have our preference credential service
we can't get away from that we always
still need that platform way of storing
code or storing stuff locally but that's
this is literally the most of the code
in there if we look in our host activity
here so this is the majority of the code
in the Android host for this app
basically initialize Emma in forms load
the application we're done we look in
the the Zemel for the windows 10 host
load the application
I all the work has been done in that
portable class library so we've now got
shared user interface across multiple
platforms in a testable way which is
good
Michael riddlin did talk earlier today
on sort of what's new ins our own forms
if you haven't seen it go see the
recording later on it's a good one he
can go more he goes more into deep about
what you kind of do with xamarin forms
in terms of user interface but I just
want to get across the point here is
that xamarin forms has a built in MV it
in BPM support and you can leverage that
to kind of build a lot more stuff shared
across all your platforms so let's look
at some more advanced ideas alright once
we've got this idea of what do models
can do for us let's see what we can how
far we can take this so we're all kind
of used to sharing our views right in
Zemun we used to call it user controls
and Razer it's Razer templates and so on
that if we have a large complicated
review we pinch you want to break that
down to smaller parts because because
those smaller parts can be reused across
multiple pages or sometimes we have a
view that has multiple sort of areas
that are orthogonal to each other no we
don't want a view model that's got it
represents the entire screen because
sometimes that screen may have very very
different sections to each other and
then that view model becomes sort of
fails and the whole single
responsibility so just as we compose our
views together of multiple parts of user
interface I feel we should do that with
our view models as well right we should
build them up not just have one view
model representing the screen but view
models presenting different areas so
I've got a master details app I'll kind
of talk to you show soon but this this
pattern you'll see in things like
Outlook or any kind of master details
app right we have our shell that's our
entire screen probably of a menu on the
left here which is our accounts then we
have our master details section now if
you had one model that tried to
represent all of this it's going to be
doing a lot more it's going
in accounts it's gonna be trying to pass
messages around it's gonna be working
out user interfaces in terms of which
few to show where and so on
I think it would get really messy and
you would you'd lose a lot in reuse so
we can actually maybe we can break it
down like I have in this diagram into
multiple view models and get more work
out done out of it
but when you do something like that
these view model slides to talk to each
other and this is where something like
of Integra Gator comes in xamarin forms
has something built-in called messenger
and almost all mvvm frameworks you have
a look at will have some sort of event
aggregation message bus messaging system
built in and that's a way that view
models that shouldn't know about each
other but need to talk kind of talk
through a third party so in this regard
and that kind of a demo we haven't seen
yet a view model our menu when something
is selected needs to push of into the
event aggregator which can then pass on
to the the master page to say hey
they've changed their account going
potentially get the new emails or the
new issues or whatever's the entity in
question and the thing is the issues
doesn't need to know about the menu
right one on the Left should never know
about the menu it just needs to know
that hey someone's selected a new
account I should update what I show
because it might not just be the menu
that does this it might be that they can
go up to you know the log out for
instance when they log out the account
has changed you want to potentially push
an event on to say hey look at the
current account has changed the issues
should reflect that so this way you have
you don't want your issues then all
right I could listen to menus a good
listen to the logout screen I would
listen to all these other places if you
just listen to one place you mean to
aggregator we can get that all done
quite nicely no they do one go to mark
Simmons talk about two things ago so he
talked about functional architecture
which is basically onion architecture is
another way of talking about it which is
the idea of having at the core of your
app a piece of
your domain model is as functional code
as pure functions as a mutable data and
that's fantastic go see this talk better
describes it but we always need
something to inject in there for state
right we always need ways to talk to the
database or to local systems or the
cloud which is naturally not pure not
functional and this leads to another
speech like with hanging architecture a
functional core and parrot of shell
where you have a kind of an imperative
wrapper around your functional core of
domain and then that can do the things
to talk to the database and all your
other work this lends itself to MVM
ridiculously well because that func
imperative shell is the view model you
can talk to your functional domain say
oh and his example he was talking about
user restaurant reservations yeah the
user has clicked the reserved seat
button that can talk to the functional
shell their functional shell can then
you know say hey you need to go at the
database the view model would think
think about the database and do the work
so other than mark Siemens talk there's
some great other ones by Gary Boone had
this tool called boundaries which also
discusses how your functional core
imperative shell and one called
immutable architecture which is another
fantastic talk on this so I highly
recommend both of those let's see what
this looks like in question
so let me show you the demo this is
actually was talking to github but so I
did not make it
Nate specific internet specific so I had
my menu here I can pick my envy
empirical question and then I have my
list of issues which I can select and
see a bit more about as follows that
basically the pattern of that diagram I
talked about so let's take a look at it
what it looks like in code
the first one is a shell a shell doesn't
actually do much all right a shell
should basically sit up what what we
want to see on screen we want some
issues and we want to see menu you know
what does here is basically new them up
passing some data on including that of
Integra Gator and uses and caliber and
stuff to say basically hey when I get
activated
you should activate which is basically
just some lifecycle work what is the
view look like for that really for the
most part pretty simple just some of us
there we go so we're using as ml split
view in this regard but I have a content
control which is using some Caliburn
stuff to say Barnett to the menu
it's what Kellerman's doing here is
saying all right you're binding a menu
view model to me I should go find the
menu view instantiate that menu view
stick it in here we're doing the same
thing down here with issues finally for
the issues view model being bound here
look for the issues view instantiate
that put that into that content control
now I'm composing my view based off the
view model so I'm composing my view
model multiple different sections that
are now independent of each other or
they depend on is the event aggregator
and our viewers composed off that you
know a view doesn't care that there is a
menu or what goes into that menu or what
goes into those issues all it cares
about is that I have two blue minerals
and that's how they should look in
relation to each other which is
basically in a split view so let's look
at our issues view model so this issues
view model inherits from something in
kalamoon could conduct a issue that's
very issue view model collection one
active which basically means that this
issue this view model is responsible for
a collection of char litems and one of
them will be active at one time
on initialize it listens to the event
aggregator non deactivate it and
subscribes the important part here is
when that event aggregator message comes
in which I'll go into a little bit more
detail clear the items get the new ones
from github add them to the current
range and activate active item basically
select the first one so that's where we
get that hole when we first come in the
first issue is item is selected the view
for this again is really simple we have
a list view being down two items should
expect has it up tab to mate which we'll
get into and the NYX NYX Twitter's
Compton control and that's it so this
this few doesn't care about what it's
displaying it doesn't care that how an
issue should look in the menu it doesn't
care about how an issue should look in
and its detail whether it's master all
it cares about is that it's a master
details view so again we're using
content controls and using the view
model to say basically bind to the
current item find me the view for this
few model put it in here but I'm giving
a bit of extra context my view your
context is master view in my views under
issue I had master view which is my
title and content basically how many
comments in my details view I have the
title and body so what that means is
that this is where our detail comes and
this is where our platform-specific
store not even platform-specific our
stuff that specific tasks application
comes in so here we have a ListView they
didn't care what was in it and our
content control that didn't care what
was in it but because we're putting
issue of you models with different
contexts and it can work out what if you
should go where and we're composing our
view based on her view model which has
been composed up so naturally as well
and what's also happening is this is
Kellerman's managing lifecycle so when i
select something here
that's updating the active item the
active item in the view model determines
what goes into sorry what's been shown
in that content control so as the list
view selection updates the view model
that selection then updates the content
control I know where we go in quickly
jumping back to that menu view model all
this is doing is on initialize it's
loading up some stuff from github adding
it to the menu then it's publishing on
the event aggregator a repository
selected message basically say hey the
first repository is slickered so this is
sort of a default behavior but when we
actually click something in the menu
we're calling select repository and that
just pushes on to the event aggregator a
new repository select message which is
handled by our issues view model and we
can tell that because it implements I
handle repositories looking at message
so this is how that wiring comes in when
we click on the menu it pushes a message
on to the view model I'm sorry I'm
deviant aggregator event aggregator
pushes it into the issues view model
there's then rebonds the UI reminds the
view model on the UI updates yep so to
wrap up with something like xamarin we
can now write c-sharp across multiple
platforms it's still platform specific
receive shop but because it's c-sharp we
can have access to things like bubble
class libraries shared libraries shared
files and so we can now reuse most of
our code across all of them once we do
that we can then start to extract State
and behavior from our views into things
like view models which can now be tested
independently of each other when we do
that and we remove things like Sam our
own forms we can then share more reviews
we get to sort of 80 90 % code reuse
which is fantastic and then once we've
done that we can start to do some more
advanced
around composing ugly models of Integra
Gatien and the like so the code for all
of this is at this URL as well as some
other talks and I'll post the slides up
there as well any questions sorry yep so
xamarin forms having a built-in mvvm
framework a basic one of some sort what
would be the advantages of moving to one
of those other ones that you mentioned
so the question is do I need to repeat
the question with a mark like that
zimmern forms so it doesn't really have
a built-in mvvm framework it more has
like sam'l has support for one in the
sense that it has a binding framework in
there it has things like commands it
actually it does a bit more than sales
ml because it has things like dependency
injection and AB Integra Gatien built-in
but it doesn't have things like class
implements I know if I probably changed
or sort of a base view model you're
always gonna have to build a bit more on
top of that but it's it's certainly it's
sort of half wave I guess it's getting
you almost there to building your own
EMV VM framework but you'd always need
to build a bit yourself there's not
quite all there in the box if you want
to you can there's nothing stopping you
it just depends that you may already
have some existing code bases that use
some of those other ones you can now
start to use everywhere
yeah
so all the ones I mentioned work in
xamarin forms some of them like fresh
Aben vm are more focused on their own
forms than anything else because it's a
newer one whereas some of the other ones
like a medium light reactive UI Caliburn
all kind of came out of the WPF days and
so they moved to xamarin forms and
xamarin as well which means they've got
walk sense of support and across all the
platforms but if you just throw in some
of them informs isn't like fresh meat
fresh convenient works just as well yeah
it's always basically there's Semoran
University which is the out-of-the-box
training that they provide and pro side
I'd say the best best to besides just
sort of playing around by yourself so
the one that I'm using diction Primack
I'm using for all these demos is the one
that comes out of the box with calibre
which is just so it's called simple
container but there's nothing in these
demos that's tied to that I can quickly
show it look
so basically here you can see I'm
creating a new container I'm registering
my view models and registering the
services with their interfaces and down
here is kind of the wiring between
Caliburn and that container there is
nothing stopping you using anything you
want and the other ones as long as it's
essentially a portable class library
because if it doesn't have a PCL then
you can't use it from a PC either so you
want something that supports all those
platforms but most there's nothing
nothing kind of platform specific about
a ioc container so it should most of
them will work almost everywhere so it's
kind of pick your favorite really pick
the one you used to sway to do it
so the telluric controls themselves I
haven't used specifically but they're
essentially just native controls so I
wouldn't expect them any worries and
using them I mean they're kind of it's
almost orthogonal to mvvm essentially
you've got your view you have UV model
what are you using the view is up to you
it shouldn't change what's in the view
model or how that might change the glue
that you work to get between that view
and view model but for the most part it
should we still be the same yes
excellent thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>