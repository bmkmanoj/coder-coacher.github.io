<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C++17:  The Language Features - Nicolai Josuttis | Coder Coacher - Coaching Coders</title><meta content="C++17:  The Language Features - Nicolai Josuttis - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C++17:  The Language Features - Nicolai Josuttis</b></h2><h5 class="post__date">2017-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pEzV32yRu4U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yeah my name is Nikolay Azotus I'm
couple of city suspects
years now doing super specialization and
I learn and voluntario about c++ sleeper
cell 17
so we have established c plus or 17 and
i want to tell you what it's all about
yes c purposes just one the next step of
a couple of seasons of learnings we had
in the past we started with C versus
nineteen eight I was already involved
there and then we had just the back six
in 2003 and then where was the big step
of modern C++ how we call it with C++ 11
and with some fixes and some enhancement
but only small enhancement in C++ 14 and
now C / 17 is around the corner which to
some extent was announced as the next
major version but it turned out it's not
a next major version it's probably what
I would call a medium version now so
something between the innovation of C
plus 14 and C++ 11 the status is that we
count V so it's not done yet we are not
done yet the status is that we look with
a draft for national body feedback so
that formerly some countries can say
this should change and then otherwise I
have a problem with this new standard
and we want to fix all these commands we
started to fix them already in in autumn
and want to fix them again in February
in Kona Hawaii so there we should finish
the semester seventies done it if ssing
cents goes fine unfortunately I can't be
there
so the SEO history it turned out that we
now have this three-year schedule of C++
and that means that we are also think
about trying out new things before we
standardize them so one thing that
happened in the past
we have so-called TSS technical
specifications for a couple of topics
and as you can see here in dark green
only a few of them went into C++ 17 most
of them went not which to some extent
surprised some people including the
father of fitness of 17 who said we are
too slow but on the other hand we are
doing now standardization with about a
hundred people in the world and we as a
hundred people have to have some
consensus about the next step and you
see well yes it's like in politics
sometimes you have to find ya it's
sometimes tricky to have condenses even
about the direction so there might be
although although there are a couple of
new things there might be some
disappointment in the community about
what's coming well I think it's good
enough to update some books and that's
good for me at least so let's see is
there support already yes while the
standard is not is not out yet we
already have support for a couple of
features most of the features I can even
say the best support you have when you
try a GCC or D plus plus there is the
base is a version set o at work and this
seven dot over them will have support
for C plus 17 most if not all of it
where they account be working on that
it's still in development but the goal
is to have support for C++ 70 in there
and if you want to try it out just in
case you you don't know there are a
couple of online compilers available so
if you want to try out C++ 11 feature a
C++ 17 series also other features try
for example rent box which is a compiler
that overnight please gives you then the
newest version of the GCC and also of
the clang compiler there here for
example it's a head of some 7.0 and I
can try out here
what compiles here of a couple of new
features you might be able to read here
or not that become too
all these examples later so as I said
most of the things I can test I could
test already with that so I have some
application programming experience with
superstar 17 although it's not finalized
and that's good we still find some
issues especially when we bring together
different features because in
combination of some surprising behavior
sometimes comes as we had in the past so
what was not voted in C++ 17 the biggest
things that are not there and a lot of
people as I said are waiting for them
that's modules concepts ranges
co-routines reflection overloading
operator dot default comparison
operators uniform course in text or a
library such as boost SEO which we for
example now have in 80s and in the
detail standard what but it will not
make it into C++ 17 most of it for what
the reason was we are not we are not
convinced that this is mature enough for
both for language features or library
features if they didn't come in this
might surprise to some people for
example for concepts a lot of discussion
is already there about the past 10 years
but yes it's not done yet so I was that
that was probably the most thing I was
surprised about yeah for anything else
there might be good reasons or not some
of them I'm happy that they are not
already there because I myself think
they are not well done or surprising
behavior so yeah that's the way it is
unfortunately every opinion is different
in the Senate committee why isn't it
working now
some interesting Windows program took my
focus
you
so one small part before we jump into
details and generally change that C++ a
lesson should be on top of c11 instead
of c99 so we still have to go to support
C functionality from the C library but
it will switch to c11 and with some
minor fixes but in general we should
support all the data from there so let's
talk in this first talk about the
language features and then after the
break in the next talk I talked about
the library features knowing that there
sometimes it's a little bit difficult to
know is it a library or language feature
because we have language support in the
library let's see how it works out so
the first thing here is structured
bindings structured bindings is
something you see here which means you
can declare an object that in fact
declares multiple objects so it
initializes a variable U and V by what
is returned by function foo and you can
use to initialize U and V by a structure
by some class that has a gap support
like couple or by written by arrays or
return arrays here you see we have a
structure internally in the stack life
and integer and a double so you will be
deduced to be an integer we will be
deduced to be a double and they will get
the corresponding values what is
returned here from foo same here if the
function returns a couple of character
float and string a B and C will have the
corresponding types character float and
string and will have the corresponding
values depending on what the value was
which was returned from G and also I can
direct the initializes with an array
here an array of 47 and 11 so that means
x and y integers initialized by these
various let's just makes it some things
more convenient you can still have the
usual qualifiers you can say I want to
have the reference I want to have the
Const value of this but you have to use
Auto if you have a reference of course
that means that you have access to what
was returned from the function is it was
returned by reference and yeah so you
can change it if there still is it's
still valid to modify it some
interesting consequences this asks for
example this is a nice example a matter
of string and double what we can write
now is this we iterate over this map by
saying well I I want to iterate over the
element the elements are key value pairs
so I want to have them by reference and
that means instead of having the strange
pair where we use first and second and
nobody can understand that then unless
they know about C++ I can read this
perfectly if key is greater than 20 I
double the value and I can use this loop
now to iterate over the elements and for
the same reason I can now use the auto
f4 key and value and print key and
baryons is definitely more readable code
than using our first and second in my
opinion
he is doing and greater than 20 yeah yes
there was a hidden secret here yeah no
you're right
I changed the slides but not completely
yeah thank you
so yes of course the first thing should
be a so yeah with the usual route you
have for autograph extending temporaries
account autograph extending 10% usual
woods apply next thing um we were so
successful with the extension of the for
loop to becoming a range bass follow
that we thought oh that's a cool set to
go so let's do something else
and one thing we extend it now was if
and switch so that we can now besides
the condition in front we can have an
initialization that means if you have
something like this this probably the
typical example you have an
initialization of something which you
want to check then and which you still
need them because if you don't need it
then you can do it in one expression but
if you still need it then you have to do
something like this you can now write it
as this you can say initialization is
status s is the result of check and then
I check whether s is not equal success
and I use this as with the scope that
the assets only valid inside the scope
of this expression that also helps for
lock guards for example if lock guards
you read lock guards to do something
like I want to have a vector and if it's
not empty I print front
I now can write this as follows to
saying I initialize the lock gut and
then I do a check and then I do
something with thee with a vector that's
also possible and it's also possible for
a switch statement so if I have an
initialization and then switch over the
result I can now do the initialization
inside the switch statement and I'm in
the scope of this switch statement
okay yeah
so the question is if I initialize it
just a temporary will it survive
yeah actually I'm not sure about the
route that I didn't try that out there
must be some correlation and I will
think about it so I have no answer yet
Thanks
yeah but here's something also bringing
two of these features together just to
show you what happens if I knew if I use
structured bindings and then the the
initialization is so if I have something
like I have on a insert into a
collection of value of 42 the return
value is the pair where the first
element refers to the element if it was
exerted and the second element tells you
whether this was successful or not so
you have to write this strange code
saying well if it was not successful I
can tell you we i we already have there
another element and that's this who can
read that so we can do it now better we
can say if initialize with auto with
sector finding a position and done from
insert why we are not done or if we are
not done then we initialize key and
value from what position refers to and
then we can use the key and that's
probably better readable code than
before good something different because
I could one valid name of these
variables are just an underscore yeah
but some people love that
I am getting a little bit nervous when I
see where I ever file it like that but
it's possible yes you can say Const Auto
rev key comma underscore if you don't
care you could but you could also use
the underscore if you care but that's
your problem then oh yeah yeah and any
new features is as a new ability to
obscure behavior by I don't know
encryption mobile server
argumented action for class templates we
have now the ability that we don't
necessarily have to specify template
arguments they can be reduced by the
constructor like template arguments can
be deduced by parameters when I have
function templates now we have that in
classes so do you see here usually if I
have a class B with two types and I say
I want to have an object of this type I
can say I have to say please instantiate
this for two strings with or without the
initialization now I can skip the types
if it if the types can be deduced from
the parameters like and function
templates so I can write here D 2 is
high work the types by the way are the
first type is and three characters and
the second is six characters and here we
have it's an int and it's a double and
by the way I have I think no I'm this is
also not correct because this is using
the argument by value this will decay so
these two types will be charged as if
they would the argument would be defined
by reference then this would be the two
types of T 1 and T 2 it's again it's the
same rules as for function templates but
now for class templates you don't have
to specify the types if they can be
deduced it's an of course an error if
they can't be deduced so you can't write
that and you can use it for simple
things like this you can say complex now
it does not need an int here
as a complex number is initialized by 5
and 3 both are integers so this will
deduce a complex of int it will not work
according to
class complex if the types differ
because complex requires that both
arguments are the same and as for
function templates if the deduction
gives the contradiction and there's no
automatic type conversion then this is
an error
the rule is either you specify all or
none
you can't partially specify this class
template deduction argument so here I
specify all of them well there's a
special behavior if I as a default type
then you don't have specialists like
that one but if I say something like I
don't specialize anything but here I
special I hire a past one and here I
passed two and that's fine but if I here
say I pass two arguments but I
specialize only one this is an error so
we can only specify all that have no
default where you'll or none so anything
else is an error that's by the way
something to help you because here
consider this if we could sparsely
specify things a couple partially
specified for in taking two ends then we
would not take this as an error we would
say yeah we would say this is a table by
to end but yeah so this seems seemed not
to be useful and therefore we said no we
either all or nothing
- that we can't do the following now we
can't say I want to have a set of ends
and my sorting criteria wrong is passed
as argument because it's this has a
specific type which is the second
parameter I still have to specify the
second parameter we we are thinking
about placing something here like comma
question mark or something like that so
that we can say it's our intention that
we have two to ten
parameters but that we still want to
have only the second one to be deduced
but that's not in C + 417 that's
something that might come later another
interesting thing is that sometimes
deduction doesn't work or gives you
surprising behavior so one thing here is
pair I no longer need for a pair to
specify what is the type of the first
and the second element of the pair I can
do it that way however this will not
compile and the reason is that it's not
allowed to copy or initialize array
parameters and this is an array so I
still need make pair because this decays
and make payable decay to a contra star
here and so sometimes the convenient
functions functions are still there
another good example shared pointer you
can say I want to skip to initialize a
shared point of end by a new in I want
to skip this in because I can deduce
this from the constructor but this is an
error and it will probably remain to be
an error why is it an error because in
class shared pointer we have a template
parameter T that's this one but the
constructor takes a different template
parameter because the construction
happens with another template parameter
to have to support automatic type
conversion and there is no rule to
convert this Y into this T so therefore
this will not work we can deduce this Y
but we can't abuse this T now there is
something interesting something
interesting you can specify roots for
that which is called so-called deduction
guides you can specify how I want to use
this mechanism to
use types and I can say for example the
following if I initialize a shared
pointer by a y star and Y is a template
parameter then please did use that chat
pointer of Y is used so the Y is used st
in shared pointer I can do that so
that's a deduction guide and if that if
you define that then this is fine and
will work we are currently discussing
whether we want to have that and it will
probably not be the case in C++ 17
because then we can initialize such a
shared pointer by a new integer array
because internal areas are also in stuff
and that will though may be causing more
interesting problems in your programs so
there will be some surprises in the
future about this in general oh yeah
here's the example in general we will
have that these deduction guys are at
work and we are still working on them
and for example one if he is one example
if you have a vector you initialize it
by two iterators you want to deduce the
element type from the iterators but you
have to say that i want to then have a
vector which uses the iterator tripes
traits Vario type as element type so
that's that will be that will probably
be in the standard for all the
containers and some of them also
yeah and you can also do it yourself you
can have something like if I have a
struct F and it it doesn't have to be a
template the deduction guy you can say
if I have a s for a string literal or
chakhan star please did use s to use as
a as a template parameter to be string
and then this will automatically happen
if you then initialize s by a spring
little it will be an S string that's
possible
you have to do it in the same scope
where you define the type so if you want
to extend behavior of the standard
library you have to define these
deduction guides in this namespace SCD
which is officially not allowed but
possible so you have to do it in the
same context where the original data
type is different good
very attic templates we introduced in
C++ 11 very attic template which means
we have here parameter take a list of
parameters and we can use them to do
something with them one thing we can do
now which we couldn't do before to say
we wanna we want to have this recursion
and not the point is we take arguments
the first argument is handled
differently it's printed out and the
other remaining arguments are printed
are passed to print again so that way
one argument off of the other we print
all the elements but we need an end
criterion because somewhere the
recursion has to end and the problem is
we could write the end caterham here
because we had no if at compile time
saying we want to hear only use this
call if the number of elements is 0 is
not 0 of course so now we have that we
have a compile time if statement the
name of under which it was proposed both
expert if it was changed into its
context but the term is still the name
is still context raised but the syntax
is is cons expert and that means here
there must be a compile time expression
if this a compile time expression is
true and only then this will be are used
in the template to generate code
otherwise this is ignored and you can
have an adze part the same way we call
that a discarded statement then here
you
okay let's cool by the way that will
change a lot of template code and we
have even more for these variadic
templates we have now so called fold
expressions instead of using all these
recursions to process one argument after
the other we can say let's combine all
these arguments with one Operator for
example by saying dot dot dot plus s and
s is a list of arguments of different
types that comes here any length we can
say we want to sum up all the elements
here so this will expand to s1 plus s2
plus s3 as one two three are the
different elements of this parameter
which is a very a deck template
parameter so representing different
values so this will expand - this is
left binding and with the dot dot at the
end it's right binding and we can have
an initialization so you can do
something like this I want a
initializing have my see out and I want
to print all the elements I pass here to
see out I can write it that way
unfortunately not easily with some white
space in between so that's that's a
problem here that we have no syntax for
that yet you have to do some tricks with
some I don't know factors also to do
that okay another thing template auto of
course Auto more and more Auto we have
now we can say we have a template a non
type tender so a template for an integer
or longer forever where we are not
defining inner hand which type it is so
we can say we instantiate this s by 42
or by a character and then the type will
depend on that I didn't have a slide
just at the moment I present this of
course now with class template argument
deduction we could again now say let's
deduce this
from the constructor I have to try it
out at least so but that's something
yeah I could try out later it this is no
magic to to allow something that was not
allowed before so we can't still in
instantiate this for double as we can't
declare a template for a double n that's
still not possible you can partly
specialize it so you can say this is a
general guideline but for integers I
have special implementation or for
pointers I have a special implementation
and you can do some interesting street
tricks you can for example say Auto dot
or dot here then you have a value list a
template parameter are lists of values
of different types and if you want to
have this list homogenious you say my
first template parameter is auto so it's
deduced from the argument and all the
other arguments have to have the same
type so it's deco type of this type you
will find out what this will be used for
in practice I'm pretty sure something
else this is really something nice who
of you doesn't have the problem saying I
only need this C++ file this this
compilation unit just to clear one
global object because a global object
according to the one definition rule or
the hour rule has to be in one
translation unit but not in everything
so you can't declare it in your header
file you need a CPP file for that that's
gone you can say by placing inline here
you have an inline static object and
that means the standard not guarantees
that this object is exists once in your
program is visible in all the files that
include this header file and doesn't
need outside a definition so you can
include this and include this here and
both can access energy
and they have it you have it once in
your program and you can do it for a
couple of places you can for example do
something like this you have a class
money tour sorry a single thing you have
a class and you want to have this
monitor once in your program just in
your head as I write in line monitor I
create my global money tour and that's
enough
all your translation units want to use
this monitor includes the code the
peasant matter how much translation
units you have you will have this once
and it will be shared by all the
different translation units you are just
cooking looking very straight and the
other thing is that every context breh
implies in line which was by the way the
fact already before so that's nothing
new but the funny thing is that we can
now in C++ say this context / implies in
life so this still makes sense but
that's nothing new you could wrote write
that before in C++ 11 yeah yeah that's
nothing new but but now we we see this
expression under a different rule saying
this is an inline definition of the back
string okay I'm pretty sure it has been
considered in the context of modules but
I have no clue about the outcome because
I'm happy I understood all the features
that made it into C++ 17 I still not
take an expert in modules sorry
so I can't answer that question another
rule we have now aggregates that can
derive from other aggregates I mean this
has been possible before
you could define a structure deriving
form a structure for example a C
structure that's nothing new but what is
new is that this is still an aggregate
so aggregate rules apply and that might
be some special language rules apply and
there's a specific new way to
initialize this completely so you can
now write something like this I declare
a variable d1 of this type and I have 42
which shows the Shadley pass through the
base class to initialize the base class
and then comma 1 to initialize the
derived class and if you don't want to
initialize the base class you use empty
armed curly braces this is now an error
just initializing v3 with the empty
curly braces it's now an error I expect
this will still compile for some why
because this might break existing
programs but according to the language
this is now a change and should make it
easier to deal with yeah as you say some
extensions to existing types to
initialize the object because without
that we always had the need to provide a
corresponding constructor here that then
passes the arguments to the base class
and that's no longer necessary yeah then
something else
Sean and me were talking yesterday
already privately on the on a trip with
about we now have a change in the routes
about optimisation of return values you
know we have two things in C++ we have
return values that have a name like this
X and we return values that don't have a
name and there's a rule that some
optimization happens so that not
necessarily a copy constructor is called
here the return value optimization of
the names return value optimization and
in C++ 17 this optimization is no longer
optional it's mandatory it's required
and that has an interesting effect that
there is no longer the need to have a
copy or move constructor to support that
so even if you are not allowed to copy
or move your objects this is
no valid code which will change from
what we have right now so you can say
something like this I have a class X I
delete my copy constructor I delete my
move constructor but I can still return
a temporary object here of this type and
it will compile and you can also assign
it to another object yeah so this will
change the some things I'm also sure you
attribute C++ defines a couple of you
attributes of formal annotations and
these are all things I think that people
who know lint and C know already so
something like no discard that means we
want to have no we want to have a
warning if we throw away the return
value of something and one good example
is acing those people of you who know
async async has a problem it starts an
asynchronous task and as in Cronus yeah
functionality but it blocks in the
destructor for the end of that so if you
don't use the return value this means
this is a synchronous call of this
function and that that's a contradiction
in itself so we now say a thing should
be s be marked at the compilers warned
explicitly about if you if you don't use
the return value of async and there
might be other examples where we think
about changing things but existing
practice is an interesting issue here -
whether we really want to enable it or
not so some people thought about
operator new saying no discard or
something like that so but let's see
whether this will work out this is a
language feature where we are still not
you
we still don't know where to apply it in
the library that's a general problem we
have we are making car language changes
until the end and the library people
have to follow that so it's not like an
ordinary project management yet to say
let's let's stop developing the
framework and then work on the
application of the framework it's
unfortunately a little bit different
here so I have no clue what happens in
the last week of C++ analyzation with
the question where should be the apply
notice card in the language in the
library another thing is that you can
intentionally say yes I assigned the
return value to Y but I didn't use it so
that's also an attribute you have now
and fall through is for switch cases
where you're intentionally fall through
in another case and if you have even if
you have between the two case some
statements
some small things needs that namespaces
you don't have to spell them out that
way you can now spell them out that way
if you want to use them you can now say
in static assertions that the message
here is no longer mandatory you don't
have to write a message you can just say
this is the assertion that should be
checked by the compiler and if it's a
little of the compiler too has a good
message about that the funny thing is
that the compiler then has to care about
internationalization so here we have to
care and yeah so that's one thing in
lambdas we can now capture star this
this means if you have a lambda lambda
can exist inside member functions so if
you are if you have an object of Class C
and inside your member function you
calling a lambda then you have this and
usually what happens if you pass this
either by reference or by value in
general or by passing the name you will
pass a pointer and that means you refer
to the original object now guess what
your start is a new thread and in the
new thread you are working on the
original object without copying this
object and to be able to be safe there
you can say now star this I'm honest I
want to have that when I call the lambda
that it uses a copy of the object where
I call this lambda for
new on delete now support arm alignment
in memory we had alignment introduced
for four stack objects so we had a line
of a line as keywords introduced but
they were not used in allocated memory
and memory allocation on the heat and
that's that has some interesting
consequences because it means that if
you call if you define your operator new
operator you might take into account the
alignment of the objects I don't know
the details already but there will be
new operators new and deletes etc which
have additional arguments for alignment
of your data so that you can use this
argument to fulfill when you when you
allocate the memory on the heap that you
fully fulfill the requirement that it
should be aligned according to some
value on on the heap then so this will
also be there
yeah the question is what happens we'll
see with the existing implementations
yeah so the default is that an operator
should choose one of these two which
means in backward compatibility you only
have this one and then this should be
used with the existing behavior so of
course this feature has to be backward
countable compatible otherwise we put
have would be in big trouble
yeah you can now you have no new
preprocessor statement which asked for
whether a header file exists or can be
found according to the part of edify so
you can write something like this if I
find the header file optional then I do
something if I find the experimental
optional line then I do something else
and otherwise I do something different
this way I have in my program some way
to find out whether a feature which is
in some header files is supported or not
and I don't have to use some other
techniques we have and then we have a
couple of minor things I think I don't
have time to to go through a lot of them
one interesting thing is expression
evaluation order we are starting to
define now for operators the order of
evaluation we had it in the past only
for boolean operators so that we said
end on our operation shall be evaluates
from left to right but anything else we
said it's up to the compiler to decide
whether they evaluate first the right
operand or the left operand this is
going to change intentionally I don't
have a slide about that because I don't
want to have that you write code that
depends on that so and we still fight a
little bit about it some compiler
writers are not very happy about this
thing so yeah so be in ramadi remember
C++ 17 is not done yet so there might
happen something in the last meeting and
it's getting very word that this might
not be the last meeting the next meeting
for about six or seventeen okay maybe
maybe I tell you two or three things a
based on the time I have left one
interesting thing is this one this is
uncaught exceptions uncaught exceptions
with an S at the end we have already
under standard uncaught exception
without an S at the end which returns a
boolean value and it tells you whether
you are in a face handling an exception
and then you can react accordingly the
problem is and you could use that code
to say well oh when I when I'm handling
an exception
I should not commit my transaction I
should roll it back something like that
unfortunately it could happen that while
you are handling an exception you start
some code where it's perfectly valid to
fulfill the transaction and that was not
possible with the old interface which is
now possible with the new interface
where we can say I can ask for the
number of uncaught exceptions I have
here and can be a number of zero one two
or more and I when I keep it in my
constructor I can check it against that
in the destructor and again and then I
can decide whether I want to commit or
rollback I give you an example here this
is a little bit tricky to code so I have
here I have this class C C's has to
decide whether to commit or rollback the
code I have here a class D and E Class E
so what happens is the following I
create a C objects so the C object
nothing with D and E is involved
remember now when I declared this object
I was not in the context of handling an
exception good then I create a D now
when I create Adi Adi is yep that's the
an ordinary constructor and then I now I
throw an exception so what happens now
is because we throw an exception we have
to call the destructors in the other
order so the destructor for D and here
you see the interesting thing
destructive because of funky called
clean up the cleanup funky creates a C
now what we have we are in the context
of handing districts so and except
but it's it's not we are not rolling
back we are using why we handle this
with this exception we have just created
this object see so we have now in the
constructor we see that this C was
created why we are in one uncaught
exception and we create now an object e
and inside a try-catch class we create
another C and another e and now we say
throw an exception so why we are
handling an exception we are get another
exception here which is okay as long as
we catch it and handle it so now now the
interesting things happens now we say we
call the destructor for e the destructor
for e uses a C again
so they create a C and now the C knows
that when I get created I was in the
context of two unhandled exceptions now
the destructor finds out nothing happens
between construction and destruction so
I can commit whatever was at a store C
so this was fine code now when I then
call the destructor of the outer C so
this was here now with this C I find I
am a context of to uncork instructions
but exceptions but when I close in the
construction I had one uncaught
exception so I'm now in a rollback mode
for this C and that means I call
rollback so that that's the way you can
you can now program and do the right
thing or to the better thing to decide
whether this is due to a rollback over
this it's just why we are handling
exceptions just the destruction code
destructor call okay we can skip the
rest some other minor things here for
example some relaxations that we say if
I have an enumeration
and I want to initialize this
enumeration by a by a ordinary value
whether it's in on class on ordinary
enum usually that's not allowed but now
we allow it if we use curly braces but
only then so that means that it becomes
easier to say something like I won't use
enum to define my own integral type
which has the same values like an
unsigned char and I can initialize it by
42 well it's it's just a support to make
this more convenient because in the past
you had to use a static cast here we
have four new utf-8 character literals
we don't have utf-8 support we only have
the literals and the literals are only
valid when they are valid in the the
normal as a normal character and then we
also are still thinking about no except
no except if discussed to become part of
the type so that you say for example
something like this I have here a P at a
pointer to P to a pointer to a function
that gets no argument and returns
nothing but it's not signaled to be no
except so it's a function pointer that
might refer to a function that might
throw an exception and in the past
currently I can assign this pointer to a
reference referring to a function not
allowing to throw an exception and this
should be fixed by by this type that by
by making no except part of the type
which does of course not mean you can
overload no functions
for no accept and not know except like
you can't do it for different return
types this is still under discussion
because it turned out over the last two
or three months a lot of people found a
lot of interesting problems that fall
out from this so this is also not clear
whether it will come so what else
we have a huge number of bug fixes I
will show you one as an example we for
example one one small well not bug fixes
but making it consistent for example the
deprecated attribute can now apply to
enumeration in namespaces we removed
some stuff so we we no longer have
operator plus plus for bool and - - of
course also not try grave paragraphs are
not supported the keyboard register is
no longer supported also it's still a
reserved keyword so we also clean some
things up in the language here's one
example that is for example fixed as a
back author let's see as an interesting
behavior we have already if you write
this look here
well let's start here Auto X is inertia
lies by the integer 42 everybody of you
would read accessing in the good news is
it is correct access it used to be an
end but the interesting thing happens if
we use the modern form of initialization
the curly braces I put that that most of
you would say oh axis and initialized by
42 but according to the standard X is an
initializer list having one element
named 42 the funny thing is compilers
also already make it correct and if you
have this Auto X 1 comma 2 what is this
in your opinion
and we clarified for example things like
this it's interesting how we clarify
that we say now a direct initialization
with curly braces it's not an
initializer this when you use auto here
so this initialize an integer if you
have a comma here that's an error now
but if you use the copy initialization
so the assignment operator here then
this on the Left will be initialize
honest initialize a list of one element
of multiple elements so that I'm not
sure whether this is not more surprising
than before but because I'm personally
I'm a friend of of reducing the
difference between initialization
without and with the equal sign but I'm
not a car guy I'm just an application
programmer but now you know the rules
and by the way these rules are already
implemented in the compilers because too
many people were too confused by what is
happening here things like this we fix
which Mike to some extent even break
existing programs but yeah so yeah let's
that's progress so that's it for the
moment
that's only the language features that
only the language features I had time
for or I have understood enough to
present them there's more definitely as
I said after a break I will come to the
library features and I think we have
time next for three minutes or so for
some questions
I don't guarantee that I'm able to
answer them yeah structured binding
just about circle - yeah so the question
is can I use cine to restrict which
structure bindings are allowed or
I see no reason that the swinish should
not work here and the way I usually
handle this is I don't guarantee I want
to try it out at least in two compilers
or find the corresponding wording but I
see no reason not to allow it here
because to some extent we don't we don't
want to introduce you a really new
feature so it should be something like
Auto
uke and Auto V are initialized here and
all the other rules should apply as
before so I would imagine that you can
spin out things here are the template
constructor destruction okay okay
yeah so here's again the question could
be used in a to disable this deduction I
would also assume that yeah because the
trick of a sign is make it not compile
and whenever template code does not
compile it's not the an error
it's just ignored and I see no reason
that this would not apply here
you
so say it again so we yeah we have yeah
we that's right so we could use Finny
instead of the deduction guides I mean
to some extent deduction guides a
convenient way to to 3d out everything
here but it's not only that I mean yeah
where are they I can't speak and move at
the same time so here they are
yeah so and I I would expect to some
extent that both is possible spinning
out and use deduction guide to do the
right thing
certainly the deduction guys as a more
intuitive interface I mean I I hate
funny I have to say I would really
prefer to have Sweeney as a language
feature instead of a template act using
using template trick nobody can
understand what happens there unless
people I don't know have smart minds
also so if we just would say something
like requires yeah yeah I mean that's
more or less that's more or less saying
I want to have concepts yeah and now
with concepts we could we could skip a
lot of fini unfortunately we can't skip
it now yeah yeah
okay one last question so the question
is can be used equals delete yeah I see
no reason that it should not go up mine
you can you can apply equal to delete
everywhere yeah but I will try it out
and later so just using even a deduction
guide with equal to it oh no I'm not
sure about that I don't think that
specified yeah but yeah mmm probably not
memory no I I have no clue you see so
let's find out
yeah
so you are saying a call
Bangkok's temporaries initialized in in
the in the essence which destroyed I be
careful with that
so no because because I think all these
which are in a very early stage so I
don't think this is a proof for anything
and even this might still be under
consideration as a consequence of what
we standardized here so I would not say
that this is a proof that this is the
case I personally would be a little bit
surprised if the chain if the woods
would this was there because in the S
state mental I consider to be very
dangerous to say that it doesn't extend
the lifetime until the end of the if
statement personally and it would be at
least inconsistent to the existing rules
we will we have to find it out okay
that's it thank you very much if you
want in 20 minutes or 15 minutes we talk
about the library thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>