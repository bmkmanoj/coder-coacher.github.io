<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>​.NET Data Security : Hope is not a Strategy - NDC Security 2018 | Coder Coacher - Coaching Coders</title><meta content="​.NET Data Security : Hope is not a Strategy - NDC Security 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>​.NET Data Security : Hope is not a Strategy - NDC Security 2018</b></h2><h5 class="post__date">2018-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HfXC3MSk9dY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I kept my name's I'm Steven ha and
welcome to my talk
data security hope it's not a strategy
so it's little bits about me so most of
my time you spent these days doing work
for polar sites so I've produced 12
courses that are published now and I've
got 13 throughout soon and we also do a
lot traveling around doing training
around took cryptography training in.net
is one of the courses I'm running it in
a minute and I've also run a workshop
for the last two days here doing that
subject and I've also been doing some
work with a payments company in the UK
called ladder pain I'm also one offer so
I write a lot of books I've got free out
at the moment on various different
software development subjects and I've
got loads more coming out so that's the
hard sale done so we're going to cover
quite a lot of ground quite quickly
today when we talk about cryptography
and nets so I want to show you some
other resources that you can refer to
afterwards if it's a subject that
interests you so I've got a course on
Pluralsight called craps practical
cryptography not nets which kind of
talks about what we're going through
today but it goes through a lot slower
and works for a lot more examples
another course it people may find
interesting is one of them here with
Lars quince which is all about how to
use Azure key vault in Microsoft Azure
which you might find interesting
also the github address there and I've
got all the source code for that course
so even if you're not a promise top
subscriber I've open sourced all the
code so feel free to go in and take it
because it kind of follows what we're
talking about today and also have a copy
of these slides available on github as
well if you want to grab them okay so
why are we here so I go around doing
this talk because I believe that
everyone as developers has a
responsibility to their company to help
protect their data Sue's everyone the
developer in this room hey my choice for
you you all don't have developers whew
that's good
typically a lot of companies take a very
blase approach to security and data
security and you know they keep their
fingers crossed and hope it's not gonna
happen to them and they literally do
think that hope is not a strategy I've
worked with lots of companies are taking
this approach and it is wrong some to
projector ok
protectors gonna play nicely today is it
so yes Oh a lot of them going the idea
that hope is not a strategy and
certainly in my experience when I've
worked on a lot of projects this is
generally what seems to happen a lot of
the call security stuff that we want to
put in to protect data normally gets
pushed in the back of the project
because people only care about features
and don't necessarily think of security
as a feature so what this talk isn't so
we're not going to go deep down into the
underlying algorithms like AES and DES
we're not going to look at how they work
internally because an hour wouldn't be
long enough to do that and we're not
going to talk about cryptanalysis you
know the art and science of breaking
codes that's not what this talks about
so what this talk is about these people
like me and you who sit there every day
for our organizations writing code and
delivering code into production so what
if I started delivering this talk it was
very much centered around the what we
now classes the traditional dotnet
framework
I mean dotnet core first came along all
the way up to doc net core 1.1 and doc
nest and at one point six most of the
crypto libraries in the framework went
available to us so we couldn't really
use dotnet core which is a bit the
problem but last August Microsoft very
kindly released dotnet Core 2 and don't
know standard - which now includes the
majority of the api's that we want to
talk about today which also in the.net
framework so you can now have some
cross-platform ability with our code so
whilst today we're going to be mostly
looking at the Microsoft api's and how
they work at sort of higher level the
actual broad concepts of what we discuss
in the Kearney Universal so if you're a
ruby program or a Java programmer the
actual concept of what we're talking
about is transferable chess we're
looking at one particular set of api's
the actual idea of what we're talking
about is kind of universal so this is
what we're going to cover so we gonna
start off by looking at random numbers
because it's not kind of the core
principle of our cryptography so have
good random numbers we're then going to
take a quick look at hashing and hash
message authentication codes we're then
going to talk a bit about secure
password storage then we're going to
talk about symmetric encryption is in
particular and we're going to talk about
asymmetric encryption and RSA in
particular and then we're going to talk
a bit about digital signatures
once we've done that we're gonna combine
some of these things together to do
what's called hybrid encryption so what
is cryptography is probably silly
question to ask you a security event but
cryptography is generally regarded about
protecting information and we do that by
encryption and to do encryption we have
to use encryption keys with a be
asymmetric or symmetric keys and the
result of the encryption process is
commonly referred to as ciphertext and
the arts have breaking the ciphertext to
recover the plaintext is known as crypt
analysis but it's kind of more to
cryptography than just encryption so
cryptography kind of splits down into
four main pillars so we have
confidentiality and this is what we
traditionally think of when it comes to
cryptography we have integrity which is
about making sure that something hasn't
changed or broken when it's in transit
we have authentication which is about
proven whether someone's actually
allowed to do an operation or not and
then we have non repudiation which is
proven that you were the person that
sent the message it's a bit like having
some one witness signing a contract it's
a good way of thinking about it we're
gonna cover all four of those in this
talk so cryptography is used everywhere
sure everyone in this room knows that we
were NDC security I mean you cannot
literally you cannot wake up in the
morning without some kind of
cryptography happening as soon as you
turn your phone on your TV your computer
you do online shopping you know take
your money out of a cash machine there's
a cryptographic handshake between the
ATM and the bank the newer crypto
currencies which are very popular at the
moment and even modern voting machines
and some of the new block chain based
voting machines are all based around
cryptography okay so it starts off by
looking at random numbers so random
numbers are absolutely pivotal to
everything we do when it comes to
cryptography you know whether we're
using dotnet Ruby Java a good set of
random numbers he's very important for
it to be a generate so the one thing you
don't want to use is systems at random
so systems at random is great for doing
you know simulated the ice roads or
generating lottery numbers but it's
deterministic so if you pass the same
seed into the random function you'll get
the same numbers out so for cryptography
it's completely useless and it's also
not typesafe so one we should be using
there's a lot better to use is the RNG
crypto service provider class which
lives in system dot security lock
cryptography and factory it's very easy
to use everything can probably
everything can donate it's very easy to
use which is great so we have a method
here generate random number and we pass
in a length which is a length in bytes
we initialize your ng crypto service
provider we create a new byte array our
desired length we call get bites on the
mundum number generator objects and we
return the result so what we get back is
a byte array your random data so the
next thing I'll quickly look up then is
hashing so hashing can most commonly be
for self as being like a digital
fingerprint for a piece of data so you
pass some data in you hash it and you
get this kind of unique ID fingerprint
or piece of data out the other side
mihashi should have four core principles
behind it or four core tenants so one it
should be easy to compute so if I've got
a file of string you know a piece of
data in a database it should be easy to
compute the hash it should also be
infeasible to generate a specific hash
you shouldn't be able to start off with
a hash and say what data do I need to
generate that hash you shouldn't be able
to go in that what go in that direction
if you're being feasible to modify a
message without changing the hash so if
you have a big long string that you're
to create a hash of and you then go and
change one character you'd expect the
entire hash message to be completely
different not just a little bit and it
sure technically being feasible to find
two identical hashes uses what's
referred to as a hash collision so one
of the principles of a good hashing
functions you don't want to have hash
collisions
now hashing is a one-way operation and
I've compared it to encryption on there
which is a two-way operation so with
encryption you use a key to encrypt and
decrypt your data so you go both ways
but in hashing you only go one way we
should only be able to go one way so
there's various different hashing
algorithms available to us in the top
net framework so one of them is md5 and
this produces a 16 byte hash value and
it was designed by ron rivest in 1991
but there's a problem found with it
initially in 1996 where they found hash
collision resistant vulnerability
so if you're creating new software you
don't really want to be using md5 but I
included in the talk because if you're
working with lots of legacy systems i po
used to work for a bank when we had is
400 mainframes running our core banking
platform is quite often we'd have to do
md5 integrity checks against data coming
back from that because that's what that
platform used so he's still useful to
know about it for legacy purposes next
up we have the secure hash family so the
first one is sha-1 and that produces a
160 bits hash value then we have char
two which commonly returns 256 bits and
512 bit hashes and then there's a new
one called char free which currently
isn't in the.net framework I'm not sure
when it's come in but this was designed
specifically to be a hashing function
which didn't have any involvement by the
National Security Agency in the US
whereas all the other ones had
involvement at the NSA so in this day
and age that makes people a bit nervous
so a new variety was was found for a
competition so if we look at how to use
sha-256 they've all got very similar
interfaces so once you know how to use
one you know how to use them all but
it's very easy to use so we use a method
here called compute hash sha-256
we pass in a byte array which is an
array of the data that we want to hash
so if it's a string you'll need to
encode that into a byte array first we
call the static method create on the
char 256 object then we call compute
hash by passing in our data and then we
return we receive the hash data back out
as a byte array there sure
so the next one want to look at is
authenticated hashing which kind of
builds on the concept of hashing and the
key difference with an authenticated
hash is as well as passing in a message
we also pass in an encryption key or a
key so in this case we could use a 32
bytes key that we pass in and what this
means is if anyone on a receiving end of
a system wants to recalculate the same
hash they have to be in possession of
that key to recalculate the hash if they
have a different key then they'll get a
completely different hash off the back
of it it's a good way of
now it's authenticate or prove who it
was that a sense of hash so not only
does it give you integrity checking like
you do with normal hashing functions it
gives you authenticating as well now H
max in.net could be based on md5 and the
char family the examples making a
lookout will be based on sha-256 and the
strength of the hashing is a dependant
on the lemon for the key so photo to you
by its 256 bits is probably a good
minimum to use these days the most
common attack against this type of
hashing is a brute-force attack which
we'll look at in a moment so again very
easy to use so we have a little sample
method here we pass in a byte array of
the data that we want to hash and we
pass in a byte array which represents
our key that could be 32 bytes we then
construct the H Mac char 256 objects
whilst passing in the key and then we
simply call compute hash passing in the
data we want hash and then we receive a
byte array back out the other side okay
so now I want to talk a bit about secure
password storage so if we like it or not
passwords are still one of the most
common ways which people have lost 8
themselves on systems because they are
generally easy for her for our users to
remember and hashing is one of the most
common ways of doing that's
traditionally so has anyone works on a
system way you've just created and
stored a hash of a password sha-256 hash
it's ok to admit it I've done it as well
there's two common attacks you can do
against here so you can do a brute force
attack you just keep on trying lots of
combinations and to manage to crack the
password or you can use a dictionary
attack and these dictionaries typically
are gigabytes in size and used towards
our hash Katz to automate the password
in the workshop the other day we did a
hash cap demone and all of us running it
managed to warm the room up quite nicely
as our machines nearly melted so there's
a good example of how to break them here
so this is a website called crack
station dotnet and it just makes for a
good example so you pass in sha-256 hash
up there type in the CAPTCHA hit crack
hashes it's worked out there it's a
sha-256 hash and the power
to secret 69 that's just so kind of a
trivial example that shows you how easy
it is so story in hashes on their own is
probably not a great way of storing
passwords so the next best thing
so that is storing what's called a
salted password and what this is is your
pence and data onto the end of the
password before you hash it so again
that could be a 32 byte random number
that we generated with our ng crypto
service provider and once you've
concatenate two those two together you
just hash it as normal so is anyone do
this in their current systems it's a few
more people you know I've done that as
well and no Jeremy that's pretty good if
you've got a 32 by a 256 bits a piece of
entropy on the end of the password
that's going to be quite difficult to
break but who knows what's gonna happen
in you know 2 3 4 or 5 years or more
it's always like hash queues GPUs for
breaking passwords and they're only
getting faster every year so what might
be secure today might not be secure in a
few years time so what I want to do is
you want to stop Moore's Law and the
evolution of graphics cards and towards
our hash cap being a problem so the next
best thing we can use is what's called
password-based key derivation function
or pbkdf2 for its fun name I think it's
actually this is very similar to what
we've just done so have our password we
want to hash we have a salt that we pass
in so again that could be fair to two
bytes of entropy that we generated but
then we have this number of iterations
and what this is it's a number of times
which that hashing function is going to
get run internally to generate our
password and the reason we do this is we
want to algorithmically slow down the
hashing process so instead of hash cap
being able to do you know billions of
combinations per second you might be
able to reduce it down to say 10
combinations per second so in.net
again this is very easy to do you have a
very nice method in the framework called
RFC - 898 derive bias does what it says
on the tin so we have our hash password
method that we've written we have a byte
array of the data we want to hash we
have a byte array of our salt and then
we pass in a number of iteration
and then we just pass those into RFC two
eight nine eight derive bias call get by
its twenty because it uses sha-1 in town
meeting any returns twenty bytes
let me return the result as a by two
right I did some time in tests on this
so on the Left column we have the number
of iterations and then we have a time in
milliseconds on the right and then I've
correlated that on to a graph as you can
see there's a linear correlation between
time and the number of seconds so for a
hundred iterations he took two
milliseconds all the way up to five
hundred thousand iterations which took
around seven seconds
so the reason I show this is if you're
going to incorporate something like this
into your systems you need to think
about the trade-off in performance so
what is an acceptable level of time to
wait for a password to be hashed so if
you're having assist a person
authenticate onto a system is having
them wait two seconds once you've topped
their password acceptable it might be to
your company or it might not
so you have to think about the
trade-offs in time as everyone familiar
before if this company here so they bash
themselves as a dating agency aimed at
people that want to have affairs so they
had a massive data breach a few years
ago is it for the joy one in here's how
to get haven't they it was a it was
quite a big deal so they had lots of
their data stolen and their source code
stolen and I know the hackers wanted to
go over after the passwords so they
looked at how the passwords are being
stored and there would be these insane
called bcrypt
which is very similar to our
password-based key derivation function
so actually what they were doing was
quite good they're doing iterated
hashing to slow down the hashing process
that's quite cool but then what they
also found when they did the when they
went through the source code is that
some unwitting software engineer heard
of C try to optimize the logon
performance of their system so once you
successfully logged on it was story in
md5 tokens locally of the password to
speed up the process then once they
found this out by looking at the source
code obviously they then managed to go
off and recover a vast majority the
password file so there's a really good
article on Ars Technica about it at that
link there it makes further fascinating
reading okay let's move on to encryption
so we'll start off with a symmetric
encryption so what this involves then is
you have a piece of data you encrypt it
with an encryption key and then you
decrypt it using the same key that's why
it's symmetric there's a problem with
symmetric encryption and that is that
sharing keys is hard so if I generate a
photo to buy encryption key and I want
to send one of you some data how do I
get that key to you you know do I email
it probably not a good idea
stick it on text file on the server
somewhere again not a good idea probably
don't wanna stick it in a database so
unless you're actually physically in the
room of me and I hand you a key with it
on its papi not gonna be very good so
again just to illustrate the point it
was saying before so hashing is a
one-way process an encryption is a
two-way process so we using that same
key to recover our information so
symmetric encryption works by splitting
and your data down into blocks and then
they put it in crypts are several blocks
at the time does lots of swapping
operations internally so on computers
things are KS actually very efficient to
run and in net we have free options
which are quite common to you so we have
DES which is the original data
encryption standard we have Triple DES
and then we have the AES crypto service
provider and they all inherit from a
common base class which is symmetric
algorithm so once you know how to use
one the interfaces between all three are
actually pretty much the same again I
mentioned des and Triple DES on here not
because you'd want to use them for a
brand new system but if you are
integrating with old legacy systems and
the chances are you might have to
decrypt something that has been
encrypted with DES or triple dose so AES
stands for the advanced encryption
standard and it became a standard by the
National Institutes of Standards and
Technology back in 2001 and as you
vented by our two mathematicians Jane
Damon and Vincent Ryman and it was based
on their original cipher which is called
Orion dollar cipher and that Ryan Dell
cipher was what one the
competition and became the standard so
we have a choice of free keys we can use
with AES we have 128 bits 192 and 256
bits whenever I use it other ways just
gone straight to 256 bits as well as
passing in the key we have what's called
an initialization vector so for some of
the encryption modes in AES you have to
pass in an additional 16 bytes which it
uses to encrypt the first block the
initialization vector doesn't have to be
kept secret you can send it along with
the encrypted message and we also pass
in the plaintext that's the data that we
want to encrypt so it could be you know
a string a byte array of file that's
been serialized they run that for us
with a key and then we get our cipher
text back out the other side now in
dotnet we have a choice of two versions
of this that we can use so we have aes
managed and aes crypto service provider
but fundamentally they're both doing the
same thing but IES managed is a native
dotnet implementation where as a crypto
service provider uses the underlying
windows crypto platform now even though
IES manages a native implementation it's
not certified by Phipps it hasn't got
the FIPS 1 million - 2 certification
whereas aes crypto service provider has
and what that means is if it's certified
if i golden crypts on in canet and then
pass that data off to a system that's
written in java for example if there is
implementation is also fit certified i'm
going to have a good level of
compatibility between the two that
doesn't mean that i es managed doesn't
work it just it just means it isn't
paddlin certified it's an example of
using AES so if we want to encrypt some
data we have our encrypt method and we
pass in a byte array of the data we want
to encrypt a byte array of our key so 32
bytes in this case and our
initialization vector which again is 16
bytes so we create the AES crypto
service provider objects we assign the
key in the initialization vector and
then we create a memory stream and
equipped toaster
because IES is stream-based internet and
over here we have something called a es
crate encryptor which we set so you
write the data into the stream you flush
it convert it back to an array and then
you have your data encrypted let's go
they have weights very similar they
looks almost the same except the only
difference is instead of crate encryptor
we pass in create decrypter into the
crypto stream you know we pass our key
and our initialization vector as we did
before passing the encrypted data and
then that stream will decrypt our data
for us so that's symmetric encryption
want to look at now quickly is a
symmetric encryption so all most common
ones which you can use is RSA which is
what we're going to look at today in our
example and this uses a concept of
public and private keys so instead of
having it's just a single key for
encrypting and decrypting our data like
we did prevail yes with asymmetric
encryption we have two keys and those
keys on a map contact those two keys are
mathematically linked and I'll show you
an example of what that means in a
moment so RSA was developed by RSA data
security incorporated in the States by
free guys Rivest Shamir and Adleman so
RSA is an acronym of their names and the
way that RSA works is there's no
efficient way to factor very large prime
numbers so if you have a huge prime
number it's very hard to work out what
the two primes are that you multiply
together to make that results in prime
and that's kind of how the what the
security is based on with RSA so these
prime numbers are huge are thousands of
digits long so 2048 bit cases the
current recommended minimum length but
you can go up to 4096 bit Keys as well
and there's a thousand and 24 bits but
you really don't use that anymore
okay so if we look at what makes up the
key so I was talking about
multiplications of primes so if I say to
you you know what is 23 times 17 those
are two prime numbers then the answer is
391 you can work that out very easily
either in your head or on a calculator
but if I was to say what prime numbers
do you need to multiply together to make
five thousand nine hundred and
sixty-three does anyone know he wasn't
in my workshop so it's harder to do
isn't it so now if you imagine instead
of four digits that's like hundreds of
thousands of digits long that's a very
tough problem for a computer to solve
and that's where the security of RSA
comes in to detrol answer is 67 times 89
so if you think about this in terms of
keys so our public key is the result in
prime so the five thousand nine hundred
and sixty-three and our private key is
67 times eighty nine order two number 67
and 89 and it's more stuff that goes
into the keys than that but the basic
premise is around these prime numbers so
the way RSA works is if I want to send
some data to one of you now you have
your own key pair you have your own
public and private key the private key
is private you keep that safe you don't
know anyone else know it but your public
key you can let anyone else know it's
you can put it on your website you can
email it to people you can hand it to
someone so if I want to send you some
data I encrypt the data using your
public key and then you decrypt it using
your private key because only you know
that then if you wanted to send
something back to me you get my public
key encrypts it with that public key
send me the data then I decrypt it with
my private key so if we look in net
about how you can generate the keys so
we have a class called RSA crypto
service provider
and we pass in the key length into the
constructor and then we can just call
export parameters with false to give us
our public key and export parameters
true to give us our private key so in
this example here I'm just storing them
as two local memory variables but in the
RSA implementation you can export those
to an XML file if you so want it to or
you can store it in the windows crypto
service container okay so to encryption
data move our encrypt method and we pass
in our data again as a byte array and
then we constructs the crypto service
provider objects again passing in the
length of the key we want we import our
public key and then we just call RSA dot
encrypt passing in that data and then
again we get a bite away back out the
other side to decrypt is fairly similar
so we pass in our data as a byte array
construct the object import the private
key this time because we're decrypting
the information then call RSA decrypt
and then we get the original plaintext
back out the other side though there is
a limitation pravara say so you can
encrypt more than the size of the key
length so if you've got 2048 bit key you
can't encrypt more data than that key
which is among the limitations because
it's based on what closer reference but
modulus arithmetic so one thing you
might be thinking is well if I've got a
very large piece of data I could chop it
up into chunks and then crypt those
individually which you can do there's
nothing stopping you from doing that but
it's very inefficient and very slow so
we'll look at some techniques for what
wants to do instead in a moment or a bit
later okay so the last primitive that we
had on our list is digital signatures so
digital signatures are used for being
able to sign some data so that you can
prove your fantasy of that data
our digital signature has free
components to it so we have key
generation we have a signing algorithm
and then we have a signature
verification method and the way it works
is if you have a large piece of data say
other than our file you generate a hash
or a hash mark of that data and then you
create a digital signature of that hash
it's entirely in.net our digital
signature is based on RSI so we have the
same kilo inflammations so we don't
create the signature of the data itself
we create a signature of a hash of that
data
does anyone used websites at DocuSign or
anything similar before it's one person
okay so it's a good analogy of what
digital signature is about so DocuSign
is a service where you can upload an
actual contract so like a job contract
for example you write your name and
various bits on the contract and then it
will create a hash of that data and
digitally sign that contract it's kind
of like an equivalent to having someone
witness you signing that document so if
later on you ever in court and you
wanted to you're trying to deny that you
have a signed that contract or you wants
to deny that you put certain data in
that contract you can't deny it because
it's been signed with your keys so if we
look at my amazing piece of artwork to
try to describe this so we have Bob he
wants to send a digital signature so
what he does is use his private key to
sign his hash so remember back to RSI
when we encrypt abusing our puppies our
public key but in this case the sender
is using his private key to sign the
message because only he can sign it with
his key so he sends out over the
Internet
down to Alice at the bottom there and
she uses Bob's public key to verify the
signature so that means that she's
she'll get a response back saying where
if it was indeed Bob's private key which
signed that piece of data so again very
straightforward to use so to generate
our key pair for a digital signature
it's exactly the same as what we did for
RSA so we construct the RSA crypto
service provider class telling that what
key lone free wants and then we just
exports our public and private key so in
this example game restoring it there's
just two member variables to sign some
data we have to use this really nicely
worded class down here called the RSA
pkcs
signature formatter just rolls off the
tongue doesn't it
so we have our sign data method and we
pass in a byte array of our hash of the
data that we want to sign again remember
we can't sign the entire document we're
signing the hash of it we import our
private key because to sign the data we
have to use our private key we construct
the RSA pkcs1 signature formatter
we tell it what hashing algorithm we're
using so in our case sha-256 and then we
call create signature and then that
returns us a byte array of that digital
signature so then to verify of what we
have or to verify that digital signature
we pass in the hash of the data that
we've that we want to sign the original
hash we pass in the bytes way of the
digital signature that was created
construct the RSA objects import the
public key this time because remember we
need to use a public key to verify the
signature and this time we create the
RSA pkcs1 signature D formatter
obviously and then we set the hash
algorithm to char 256 and then we just
call verify signature passing in the
hash of the data and the original
signature that was generated if it's
valid you get a fault you get true
returned if it's invalid you get false
returned so if it's false and you don't
trust the hash of that data or the
signature okay so we've gone very
quickly through some of the primitives
that we've got in dotnet so if we do a
quick recap so we talked about the idea
of confidentiality and to do that we use
AES and RSA because there are encryption
protocols or encryption primitives for
integrity that the ability for us to
detect if something's changed over time
or not we looked at various different
hashing algorithms but we've been using
mostly char 256 for fence occasion
that's where we want to be able to prove
that it was someone that she generated
that hash by using a key we used a hash
Mac and we use - are 256 variants in our
example and therefore non-repudiation
which is where I want people to be out
to deny having science and data or
signed a contract we've just looked at
digital signatures those are some of our
base primitives that are available to us
in dotnet so what I want to look at now
is how we can combine some of those
together to do what's called hybrid
encryption okay so we mentioned before
that RSA has some limits on the amount
of data that you can encrypt in one go
and we also want the flexibility in the
speed and efficiency of AES but the
problem we have with that is the
exchanging a key between two people it's
very hard so what we're gonna look at
first of all is how you could combine
RSA and AES together so that we can get
the benefits of both so in our example
here we have an aes session key that we
generated that's a 32 byte key we
generate our initialization vector which
is 16 bytes and then we encrypt our data
using that session key an initialization
vector just exactly what we've looked at
earlier but then what we do is we use
our recipients public key and we encrypt
that session key
so we're encrypting that IES key we
sends that encrypted data and the
encrypted key over to our recipients
first of all they have to recover that
AES key so they decrypt it with RSA
using their private key and once you've
recovered that encryption key they can
then use a es to decrypt the data so for
is thinking of it as stuff that we store
in a database or a packet of data this
is what it like so we have our RSA
encrypted session key we have our AES
initialization vector it doesn't have to
be encrypted it can go in the crew and
we have the AES encrypted data so as fun
through that there's another example so
who got Alice again generates her key
she generates her initialization vector
16 bytes she encrypts her data with AES
then she uses Bob's public key an RSA to
encrypt that AES key
and then she sends out all over to Bob
so he can read it so when he receives
that data
he uses his private key to decrypt that
AES key so he's recovered the key and
then using that recovered key and
initialization vector which he's just
been sent
he uses AES to decrypt the message so he
gets a message meet me at noon blow the
clock tower where a red rose in your
button grace no he wants to send a
message back to Alice so he generates a
new key because you never reuse keys you
always generate brand new ones so he
generates a new session key first two
bytes he generates a new initialization
vector which is 16 bytes then he's an
aes encrypted message and then using
Alice's public key he encrypts that AES
key saved that key is now encrypted and
then he sends a message back over to
Alice so then she uses her private key
this time to recover that session key
they move that session key and her
initialization vector she uses a a es to
decrypt the message and she says I will
meet you I'll be wearing a blue blue
hats and red boots
she's very fashionable so if you think
about what we've done there then so we
said we had a problem with AES where
it's very difficult to send or share
keys between people but is he's quite a
fast and efficient because it's very
algorithmic in how it works but then
we've got a es which has keys that are
split so makes it very easy for us to
then use RSA to encrypt our other key
which is hard to send so we're actually
getting the benefit of both those
protocols together so let's build on
that a bit more and add integrity to it
so this diagram virtually identical to
what we had before so you know we have
our session key we encrypt our data with
that session key I mean quit the session
key of the recipients public key and
then I take a hash Mac of the ciphertext
and the initialization vector combined
and because I'm doing a hash Mac I need
to give it a key so I use the session
key which I still have an unencrypted
copy of
so that gets sent over to the recipient
they use RSA to recover the private key
using that so they use RSA to recover
their AES key using their private key
once they've recovered that key they
regenerate the hash mark of the
ciphertext an initialization vector
because they've now got the key to
passing to the hash Mac if the hash is
matched and they can trust that the data
has made it to them without being
changed so they can then go and decrypt
the data using AES and they get the
message back if that hash mark is
different so on that sensor then they'd
just disregard the message because
something's changed so you don't trust
it so if you think about the data that's
been sent again so we have the RSA
encrypted session key the initialization
vector the encrypted data and we also
sends the hash mark of the encrypted
data this is four bits that we are
sending so let's extend that a bit
further so we've added integrity and
authentication because to calculate the
hash they need to use the key but they
need to go to recover that key so that
gives us offense equation as well as
integrity so that's now as normal PDA
ssin so again very similar to what we
had before we generate our session key
we generate the initialization vector
encrypts our data for that session key
and then we encrypt that session key
with the recipients public key that's
exactly the same then again we calculate
the hash mark of the ciphertext an
initialization vector using that session
key that we generated that's exactly the
same as what we've just looked at a
minute ago but then the extra step is we
create a digital signature of that hash
Mac using our private key so we've
encrypted the key using the recipients
public key because that's the encryption
process of RSA but to create the digital
signature I've used my private key so
that means n on the other side when the
when they receive that data they first
have to recover that AES key using their
private key in our RSA they then
recalculates the hash man
because they've now recovered that case
they can we calculate the hash if the
hashes match great we trust the data
that's been sent if it doesn't match we
disregard the message because it's been
tampered with or changed in transit but
now because we have that hash we can
then use the original sender's public
key to verify the digital signature so
if that comes back is true we know it
was actually Alice that sent the message
and not some other person so again if we
look at the amount of data that we're
sending there
so we have the RSA encrypted session key
every initialization vector the
encrypted data with AES with our H Mac
with the encrypted data and if our
digital signature now if you're writing
a system that does this I mean you could
either you know you'd be transferring
that around in the database you could
see realize a lot that stuff to JSON or
XML when you're actually sending it
between different people because all the
data in there is encrypted okay
so let's recap what we've done because
we've covered a lot of stuff very
quickly there so we started off by
looking at random numbers because
they're absolutely pivotal to everything
we want to do you need good quality
random numbers for symmetric encryption
keys and for our hash message
authentication codes we've looked at
various Tiff's in hashing o H Mike
algorithms but the one we focused on
which are 256 for the purpose of our
example we took a look at password
storage so we looked at various
different methods of doing that one we
didn't cover his obviously storing
passwords in the clear but there wasn't
really any point including that one in
the slides because we all know that's
bad but then we looked at hashing
hashing of passwords so again that's
been quite a common technique that's
been used for many years but they're
very easy to break by brute force or
dictionary attacks using tools that hash
count so to make that slightly better we
then looked at doing salted hashes where
you add additional entropy onto the
password before you hash the password so
that could be a 32 byte random number
that we generated a random number
generator again this is better I mean
probably vast majority of systems out
there these days probably still use so
passwords but the problem is tolls our
hash count on very part of very fast pcs
with high-end graphics cards in there
can test billions of combinations a
second so whilst they might be secure
now
they might not be secure in say 2 or 5
years so then we looked at how we can
algorithmically slow down the hashing
process for passwords and for that we
looked at password based Kido
password-based key derivation functions
and we use an object called RFC 9 8 - 8
derive bytes which is a very easy one to
miss in a dotnet framework because it
doesn't really make much sense unless
you know what it is beforehand so from
then we took a look at symmetric
encryption so we discussed briefly about
des Triple DES and AES but the one we
wanted to focus on for new code is AES
and AES is what's called a block cipher
and it's a symmetric block cipher so use
the same key to encrypt and decrypt but
then we discussed at the actual problem
of AES is that actually transferring
those keys between people is very
difficult to do securely so then we
looked at asymmetric encryption and we
looked at RSA in our example so RSA has
pros and it has cons so it is a very
secure encryption algorithm but it is
quite slow because it's more
mathematical in how it works it's all
based around modulus arithmetic as
opposed to something more algorithmic
like a yes but there are limits with RSA
so you can't encrypt data is longer than
yet real key size so that's a particular
downside and it's quite a slope so after
that we took a very quick look at
digital signatures and we looked at
classes like the RSA pkcs1 signature for
matter and D for matter classes which
are brilliantly named objects and what
digital signatures give us is the
ability to do non repudiation of data so
if someone digitally signed something
with their private key they can't then
go and deny having to sign that data
down the line and digital signatures are
actually valid in courts well they
certainly are in the UK so if there's a
contract dispute and you've used
something like DocuSign you can actually
use the fact that that document has been
digitally signed as evidence in court
has ever disputes so once we looked at
our primitives we then looked at
combining some of those together to do
what's called hybrid encryption so what
we ended up with was a mechanism where
we can use RSA to encrypt our symmetric
in a symmetric encryption keys so that
gets us past the problem of securely
moving those keys around and then we
built on that by adding some additional
integrity using hash Mac sha-256 hash
mark which also uses that encryption
keys that we generated so that gave us
some integrity and authentication when
we send that message between two people
and then to finish that off we use
digital signatures to digitally sign the
data that we're sending so that the
receiver knows that it definitely came
from a specific sender there's quite a
lot in one go after lunch hope
everyone's managed to follow through so
what next so if it is something that
interests you then I have got a plural
site course on this it's nearly 4 hours
long which goes through a lot slower and
has lots of worked examples so treat
this talkers you know the art of the
possible if it's something that you're
interested in then that course will
probably useful for you does everyone
here use plural sites Oh brilliant fair
few of you so that's on there so you can
just go and watch it if you want to take
things a bit further I mean we did this
in the workshop the other day where we
used the azure key volt which is a way
of securely storing encryption keys in
Asia it uses hardware security modules
behind the scenes to store those keys so
this course walks you through how to do
that so instead of locally storing RSA
keys in certificates or whatnot you can
just store them in a vertex e2 key vault
if you want to play around vault a
source code for everything we've talked
about today
I've got worked examples of a whole lot
there it's all under the MIT license so
you can just take it and do what you
want with it if it breaks it's not my
fault
but examples go through each of the
primitives how they work with different
tests and then it works through the
hybrid encryption example so you can
just use the code that's there for doing
the - encryption so you don't have to
think about it too much you can just use
important thing is understanding how it
works these slides won't get hub on my
repository in the conference talks repo
so if you want to grab the slides at all
there's a version of them there and
there's some books here which are very
useful so these are all books I've
personally enjoyed reading if
cryptography saying you are interested
in then I recommend these the code book
by Simon Singh is kind of a standard
novel sized book it talks about the
history of cryptography from sort of
ancient times where it's all done on
paper right away through to modern
digital encryption techniques the book
in the middle every day cryptography
there's actually a new edition out of it
now it's got a white cover it was
released toward the end of last year
which often but not ready yet the new
one but the first half of the book talks
about how a lot of these algorithms work
internally so because it's quite a lot
of detail but it's not overly
mathematical it's quite easy to follow
through and then the second half of the
book talks about some different
practical applications so like how TLS
works like the handshake on TLS however
cash machines do they I'm handshake
between you know the ATM in the bank
because it goes through lots of
practical real-world examples and then
the book we have at the end there is
applied cryptography and this is the
book where back in the nineties the NSA
tried to ban it because back then
cryptography was classed more as like
ammunition or a weapon so there's very
strict export regulations on
cryptography but this book goes into a
lot of detail about how a lot of the
older algorithms are built it doesn't
include AES kitten before that but if
you want a really good mathematical
explanation of how a lot of these
different algorithms work then that book
is ideal to look at so that's it thank
you very much
you got 10 minutes or so back in your
diary to go get some coffee so thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>