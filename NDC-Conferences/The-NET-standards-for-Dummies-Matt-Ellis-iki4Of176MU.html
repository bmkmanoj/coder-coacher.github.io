<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The .NET standards for Dummies - Matt Ellis | Coder Coacher - Coaching Coders</title><meta content="The .NET standards for Dummies - Matt Ellis - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>The .NET standards for Dummies - Matt Ellis</b></h2><h5 class="post__date">2017-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iki4Of176MU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay one thanks for coming and hello my
name is Matt today going to talk about
standard which is something which is
fairly new fairly recent has come out of
the work with the the.net core then
everybody come across Dinah standard yet
we just kind of heard about it need to
know a bit more okay this stuff will go
straight into its what is the dotnet
standard it's a specification which
defines a defines a version set of API
is that a guaranteed to be implemented
by a.net platform so it'll tell you what
api's are available what you can target
and where you can run if you have a
library that targets the standard it
runs on all supporting platforms and
that's basically it you know so it's a
nice easy thing in and of itself it's a
nice easy concept that's pretty much all
there is to it
except there's always a bit more which
you can go into and have a look at so
I'm you know we'll have a look really
serene of what api's are included how
does versioning work what about a
compatibility with existing frameworks
existing platforms how does it relate to
dotnet core and portable class libraries
and then also have a look at how does it
work I always like to take a go like a
level down to see what something is
actually doing there and it gets a
better understanding then of how
something works and what it's doing and
then also going to have a look at dotnet
standard 2.0 the latest version that
they're working on right now which has
big changes and which is probably the
reason you've heard about darknet
standard this is all about adding all
the extra api is back into the dotnet
core which got removed so we're going to
kind of back up a little bit first and
we'll start with what problem we're
trying to solve here what is it that the
dotnet standard is trying to fix and
basically if we look at dotnet we kind
of tend to think dotnet framework maybe
darknet core as well but there's much
more to the darknet than that you know
of course it got done at framework
dotnet core you've got lots of other
frameworks as well you know donek
compact frame worked on a micro
framework even you've got Silverlight
Windows Phones
you've got mono with xamarin and unity
as well and or even Xbox so dotnet is
more than just our net framework more
than just darknet core and all of these
implementations are different as well so
some of them started as Forks so you had
done a framework donut compact framework
was forked off for that all for
different reasons as well you get a
smaller footprints
run in a more a constrained space doc
net micro framework again smaller
footprint running a
Australian space Silverlight smaller
footprint running in a constrained space
but also cross-platform so that's nice
Windows Store Windows Phone the same
things here mono is different in that
it's a completely different
implementation completely separate
to.net framework it's not a fork at all
but what it all means really is that
they are different implementations the
different implementations over time that
have evolved over time as well and so
there are differences as
incompatibilities between the frameworks
so the reason that they were their fault
in the first place they get a smaller
footprint to get a smaller set of
libraries means that different api's
have been cut out different API have
been included and so those differences
between the two so it all brings down to
one big question how do you share
libraries and code across the different
implementations and that's what the
ballot stand is going to do it defines
the API is that are available on all of
those platforms if you target a spec you
can run on the supporting platforms but
isn't that just portable class libraries
great question glad you asked it thank
you the answer is of course yes but also
know so libraries plural class libraries
do solve the same problem the whole
point of them is to target multiple
platforms to run on multiple platforms
but and they do it in a slightly
different way they target profiles
rather than frameworks so instead of
saying I'm going to run on dotnet
framework 3.5 they're going to run on
profiles profiles 721 486 and these
profiles are api subsets they are the
common api's that are available on all
of those versions of the frameworks that
you are targeting the different
frameworks you're targeting
frequently this is this is seen as a
lowest common denominator but it's
really kind of more accurate so it's an
intersection of the API is it's not
really just the least things that are
there but is everything that you can use
rather than just release things and so
it kind of solves the same problem but
portable class libraries have their own
problems so you know first of all they
are really a little bit weird and arcane
that the whole thing is based on profile
numbers and these profile numbers are
effectively random you don't you can't
assign any particular value to these
numbers they're just the next profile
along you can't reason about them you
can't say when weather
new version of something is profile 236
the next version of profile 48 or
whatever there's no relation there's no
version and it's all a bit weird the
tooling can hide a lot of this for you
so visual Studios got you know dialog
boxes with check boxes and dropdowns
which tells you what target what
frameworks you're targeting what
versions you're targeting and it can
work it all out for you but other than
that it's all just a bit odd and tricky
to work with the big problem however is
that they're not scalable when you add
in a new API when you add in a new
version of a framework or even you want
to add in a new framework itself like
net core then you have to have a new
profile and if you've got a new profiles
new profile number you have to recompile
retarget repackage reduce redeploy stuff
and so that doesn't help especially with
something like darknet core new platform
comes along you want to use existing
code and reshare existing libraries but
you have to rebuild everything to do so
and so that doesn't work with dotnet
core so Dino standard kind of flips the
whole model instead of portable class
libraries you can kind of consider them
a pull model really they find the common
ground between them all gather all
together and say here's a profile you
can target star next and it is more of a
push it defines the state that the
specification it defines the api's that
are available and it says these api's
will be available you target this
specification and the platform will
implement it and so again libraries
target a standard they run on supporting
platforms but the key thing is they run
on new platforms as well if the new
platform comes along as long as it
supports the standard as long as it's
implements for standard then the the API
is and the libraries will just work
hopefully so darn expand is a
specification what does that mean you
know we kind of have a look at the why
now let's have a look at the what so
firstly it's not a Word document it's
not a really dry sort of hard
specification like that with a list of
api's that have to be implemented it's a
binary specification it's a set of
reference assemblies which you compile
against you build against that and those
the api's that are available to you this
is then distributed in a new get package
with its own versions listed
a net standard library package and then
within the package there are new
versions target framework monikers so
you know the lib folder you get with net
46 net 25 xamarin mono and so on we've
got a new one now it is next standard
and that's version with one point zero
one point whatever all the way up to 2.0
which is the new one so tight frameworks
just as a reminder so yeah so the toka
frame with monikers these folders in the
lip folders the key thing with target
framework monikers is that you depend on
a new get package but it's not the
version of the package that you're
interested in you've interested in the
target framework moniker itself so you
can have different versions within the
package based on the target framework
that you're targeting so you can pull in
a particular version of a package and
it's whatever framework that your
project is targeting that decides what
assembly gets referenced it's also
useful to think of target frameworks as
a platform this is a good way of sort of
getting to grips with the the idea of
the.net standard itself so donut
framework don't net cause they're
concrete platforms your apps run on
those you know those of implementations
they're they're built
they're concrete that's what you run on
the doníts standard you can consider
that to be an abstract platform your
code can't run on it so you can't if
there isn't actual implementation for it
but it's the definition of a platform
your concrete platforms can then
implement it it's like an interface as
it were so again libraries targets they
can start they can target the next
standard as an abstract platform and
that means they get to run on all of
these platforms but they can also of
course target a concrete platform and
this way they can get platform specific
API s so if you're running on dotnet
core you can have a library which
targets directly dotnet core and it can
make use of api's that are available
only and our net core and then your app
your app never targets the the.net
standard it always targets a concrete
platform because it's always going to
run on a concrete platform it's a nice
analogy of way of thinking about it as
well you can if you think about HTML
you've got HTML 3/4 whatever and you
write HTML which fits to that standard
because you're all good developers and
but then when you run that on Chrome
you're not running HTML 3 you're not
running HTML 4 you're just running paste
amount in chrome and it's exactly the
same with the dotnet standard you you
target a particular version of it and
you just run it on a platform
don't take this analogy too far because
it's HTML and it's scary but that's a
nice way of kind of looking at it and
thinking about it does anybody have any
questions right now by the way if you
have any questions please feel free and
jump in and dive good ok versioning them
so I've mentioned the new get packages
versions and the target framework
monikers themselves are versioned and so
how does versioning work with the dotnet
standard the first thing is that the
dotnet standard is an additive
versioning system so you only ever add
api's into the darknet standard it
defines the set of api's you're going to
use and they'll only ever be added to
them nothing gets removed so the
standard is kind of immutable and we get
to add in assemblies we can add in types
we could add in type members but nothing
gets removed out of it this has the nice
property of meaning that all versions
are super sets of previous versions so
if you have a platform that implements
1.6 of the standard you also know that
it's got all the api's from 1.5 all the
api's from 1.4 and so on and so forth
that also means that a new newer
platform if it targets a newer version
of a standard it can consume anything
that targets in the earlier version so
you've got that sort of backwards
compatibility thing built in from that
because everything's a superset another
good question
glad you asked how if it's such a
brand-new thing that we don't really
know so much about it
how have we got so many versions
you
I don't use the darknet standard you
have to have another assembly to go with
it but this is probably okay because
they're all out of support anyway so
full four point five and four five one
or even out to support their own
supports this time last year and so you
should be on four five two or four six
and so on what else can we say about
this if you have a look at the the
platforms down the bottom tier Windows
8.1 that's the last one that supports
the standard one point two doesn't
support anything else so if you have a
2.0 clap a library you won't be able to
consume it on Windows 8.1 and/or all
Windows Phone Silverlight so anybody
really upset just checking what else we
got yes oh yeah windows 10 apps Windows
10 supports 1.4 and before it the 2.0
will be supported in the next version of
the Windows 10 platform there so I
realize this is a big kind of
complicated thing there so does anyone
have any questions yes yep so the
question there was if you can only add
ap is is the risk of the platform
getting bloated if you can't remove it
if you can't clean up your code and
answer is yes absolutely so I'll talk
more about that when you get to the
dollar standard 2.0 stuff so as well
leave it out but yes the definitely is a
risk there and you have to manage how
you add things in basically and so
there's a process for that anybody else
have any questions about these the
versioning here that we've got hockey
dokie right so given all that the
question becomes what version of the.net
standard should I use and it becomes a
trade-off because the higher version
that you targets you'll have more API is
available to you because it's more
supersets but the less platforms you'll
have to run it on so if we have a look
at where are we for well if we want to
target 1.3 or above we have to be
running on dotnet framework 4.6 if we
are targeting 2.0 with the extended API
set that's available we'll only be able
to run on
six-one and that can narrow down your
your targets of what you want to
implement um so yeah so a higher version
you'll get more api's but fewer
platforms a lower version will give you
more of a reach but it'll have then less
API there to go for so it's it's a
trade-off and the idea is you just
target the lowest version you cap
because then if you can if you can run a
lower version you'll get the broader
reach so what API is our included this
is a this is a useful one so we have a
link here let's hope my Wi-Fi is working
yeah very good so it's all on github
that the standard is on github and
there's some very nice Docs and very
useful documentation here with another
sort of another run-through of the the
subversion matrix that's going on there
and also some some advice also some
mapping between some of the portable
class library profiles but the thing I
wanna show you really is along the top
here these versions of the.net platform
are our links and it will take you to
useful information useful information
about that particular version so this
will tell you what's in the darknet
standard 1.2 it tells you what platforms
are supported and what versions of those
frameworks are supported for that for
that for that standard and also a kind
of high-level overview of what's new
what api's are in that particular you
know by namespace and so on
two useful links we got here though are
api's and then a diff with the previous
version the API is is all of the API is
that ring the standard which is killed
my Safari beatable so that's that's a
big list and then easier to manage is is
the diff and this this shows you then
what api's have been added so it's
reasonably small set in this example we
can click on overview to go back to the
page know to go back to that page and so
we can see you know if we go up to 1.6
again you know a set of api's has been
added and if we go and look at 2.0 which
is the new extended api set we'll see
that there's now actually they're adding
a ton of new api s-- so there's a whole
load of things and i'm not even going to
try and load to diff for that one
now where'd I put my that okay so that's
a really useful site there to see what
api's are available what you can target
and you know if you want to just have a
look at it a slightly better way of
doing it slightly more automated way of
doing it is by using the portability
analyzer which Microsoft have produced
it's a really useful tool there's a
command line version limit API port and
then there's a plugin to visual studio
itself and it will give you a nice sort
of report of what API is you're using
and whether they're available on a
particular target framework it's not
just for the.net standard either so you
can tell it to analyze your code and say
you know it does this work on dialect
standard one Oh does it work on dinette
standard 1.6 or does it work on dotnet
framework 4.5 and it'll run through and
it'll tell you what's there and it will
say you know whether these api's are
available or not it can even give you
recommended changes so if it's saying
that something it needs to move then you
can reuse this which is a useful way of
working with it so this is now answering
the question of how do we work with with
something which is purely additive and
how does that that work this kind of
works post 2.0 so they know what they're
doing with 2.0 there's that kind of like
a line in the sand this is - to fix the
issues with api's that were removed from
dotnet core and to make bring net core
back up to parity and make it easier to
work with porting between dotnet core
and our net framework so there's an own
set of work for 2.0 but what happens
after and that's this is the process
they've got set up there's a review
board and that consists of the.net team
xamarin and unity the project's open
source so I'm sure if you have comments
and things and raising issues that would
be Bo
you know address and absolutely fine but
it makes sense for these three to be the
board members because they are the
people who implement implement platforms
so they have the most - they're the most
impacted by this the idea really is that
not everything will be added so the one
to try and keep the standard small
because it does need to be implemented
everywhere and if it's going to be
implemented on small devices then a
smaller API is good so there's going to
try and keep keep things out of the
standards basically we want to work with
like out-of-band packages so things like
the way what's it called system
collection is immutable
that's an out-of-band package they're
going to do more like that and try and
work like that especially if the
assembly itself is purely il it's got no
runtime concerns and also if it's based
on the darknet standard already it makes
sense just to ship it as an out-of-band
package for things that do make it in
there's going to be a set of criteria
which have to be which have to be met
before it gets in firstly it has to be a
ubiquitous API it has to be used
everywhere if it's going to be in the
standard which goes everywhere the API
has to be useful everywhere as well so
it's no good putting something which is
a Windows display framework kind of
thing if it's not going to run on
Windows the API needs to be mature as
well because it's going to be in the API
forever it's going to be in the standard
forever so if they want something which
is stabled mature and it's doing the job
is supposed to be doing and finally the
other one is things with runtime
considerations where the runtime needs
to get involved not necessarily the
platform not not talking about platform
specific things but runtime like CLR
stuff and sim D support is a good
example of this this is where the gist
they would need to recognize certain
types and recompile the machine code to
take advantage of processes do vector
maths in a more efficient manner that's
a good example of something which would
fit in the standard because then the
runtime has to implement that
differently does that answer the
question by the way about how to do it
right let's have a look at packaging
them
okay so I've already said that it comes
in a new get package this is the next
standard library package there's kind of
three different versions let's have a
quick look where are we that's why I
think I'm in the wrong place so as
everyone seen NuGet package manager buy
the package Explorer it's a really
useful little tool for no I don't want
an update it's a really useful tool for
examining your examining packages it can
down the search for them downloads them
and show us what what's inside and stuff
so net standard library is the is the
package which defines the dotnet
standard and there's a couple of
versions a couple of preview versions
but really we've got one six zero and
one six one so we haven't got any of the
previous versions there and this is one
trying to say the the version of the
package is not as important as what's
inside the package so if we load that up
first thing you'll notice on the
right-hand sides that there's no live
folder there's no libs folder or
anything there's no dll's in this
package it's a it's a meta package about
meta package I means that it now has a
whole bunch of dependencies on other
packages and those get pulled in and
that's what defines the standard
so on the left here we have dependencies
on dotnet standard this is so for the
target framework of dotnet standard
version 1.0 all of these packages gets
pulled in and we can sort of follows out
there we can see what dll's and the
assemblies were referenced there we've
got a similar set for 1.1 another set
for 1.2 except for 1.3 and so if your
project targets these particular
versions then that particular set of
references will be included but what's
interesting is that despite the fact
we're up to 1.6 and running up to a 2.0
is we've only got a target framework
there for 1.0 2 all the way to 1.3
there's nothing for 1.4 1.5 1.6 and
that's because the package dependencies
define what other packages get pulled in
and 1.4 1.5 1.6 didn't add any new
assemblies and so there's no change to
the number of assemblies that will get
referenced what has changed is the
actual packages that are being used
let's have a look at system run time and
so if we pull this one in we get to see
that there is a lib folder and the ref
folder so the lib folder kind of has
some dll's in there for us and the rest
folder also has it as well and we can
see here now we've got a different
versions for 1.0 1.2 to 1.5 not
everything because not everything it
didn't change in all of those versions
and so normal fullback rules take take
account now okay so yes that kind of
covers everything we've got there so the
new I don't think I'll show you the
framework one because yeah yeah so yeah
I didn't point out really for those are
the new framework monikers their net
standard and it's 1.0 1.2 and everything
interestingly it moves away from the net
45 and it puts a decimal point in there
I'm not sure why okay yeah the target
framework decides what you do and also
fine-grained package versions right then
dönitz down at 2.0 so this is the fun
stuff this is the new stuff the
interesting stuff and all the changes
that are going on
first thing says it's work in progress
it's not finished yet it's going to be
shipping with Visual Studio 2017 and the
big thing that it does is it gives us
loads more AP is as you see on the well
we can we can see right there all of
those API is now are being added back in
so that's lots definitely definitely why
I class loads more
it also consolidates sort of reference
assemblies as well so whereas that
package we just saw had a load of
dependencies on other packages and other
dll's
is now going to change we're going to
have one DLL next standard DLL the idea
is this is that the the standard itself
is monolithic so why is it split up into
lots of different assemblies just have
one assembly that describes everything
similarly we're going to get rid of
though those packs dependencies but
important things say is that it's got
the same goals is it nothing is changing
with their despite bigger people and
changes in how its works and everything
it still intends to do the same thing it
still intended to share code across
everywhere and in fact it's possibly
more so because this is one of the
quotes on the docs for version 2.0 they
saying 100% source and binary
compatibility for classic dotnet
framework xamarin assemblies and also
existing portable class libraries
important points to the important thing
to point out here is a hundred percent
source and binary compatibility doesn't
mean that all api's are going to be
available it means it can have a hundred
percent source and binary compatibility
across platforms so this means you going
to be able to use it on all the
platforms and it will always be
available so kind of what was wrong with
the version one series why why do we
need such a big upheaval and a change to
2.0 and the simple answer is they're
just not enough libraries targeting the
dotnet standard or portable class
libraries so the majority of NuGet
packages a dotnet framework packages and
and that means that with a new platform
like dotnet core it's very hard to
consume those because it's just too
different so that the stats that were
released was when they sort of announced
the darkness standard was that there are
about 45,000 NuGet packages targeting
the dotnet framework
don''t framework verses four and a half
thousand targeting portable class
libraries versus 1,800 which implemented
the dotnet standard so there's a huge
amount of code there which platforms
like dotnet core and other new platforms
that come along you notice of other mono
Bills of the xamarin and unity platforms
won't be able to take advantage of that
code the other issue is that is tightly
coupled the dotnet core so the dotnet
standard was built from the darknet core
because it was a requirement for dotnet
core but that means that right now with
the 1.0 say well one point series it
can't evolve in the.net core separately
if you add an API into dark net core
it'll kind of get into to the standard
and secondly just not enough api's so
dotnet core refactored a whole bunch of
API is a refactor the libraries and it
moves things
it changed the shape of certain api's so
not just removing things but change the
shape of them as well so reflection
change and other things got removed and
I like the quo here they said they've
kind of cleaned it up there but the
cleanup went a little bit overboard
and they did change things really quite
drastically when all that kind of means
that porting applications to darknet
core was harder than it needed to be and
it was it was kind of tricky so they're
going to add in all these api's back
again and instead of adding absolutely
everything from the dotnet framework
they're going to be doing implementing
pulling in an intersection of the.net
framework and mono and xamarin stuff the
rationale behind this is that the idea
for dialect standard is to work across
platforms and mono and xamarin have
already been very successful at working
cross-platform and so if the api's are
in mono and xamarin then they are
probably the api's that we wanted to use
so it's gonna be an intersection of what
that on a framework has what mono has
and work from it from their platform
specific API is going to be excluded for
the most part so it doesn't make sense
for dominant framework to pull in WPF or
with Windows forms because obviously
that's not going to work on all
platforms and so for the most part
platform specific stuff is excluded but
some api's are going to be pulled in and
they are going to be used and some of
them are going to work in different ways
so sometimes we they're going to be
emulated and so things like the registry
for example okay yep faces being pulled
in the audience there we we don't
necessarily want the whole of the
registry there but sometimes it's really
useful for saving application settings
and there will be existing code out
there which is doing that for
application settings and so if you
emulate it you know mono already
emulates it with any files for example
then that could be very useful for an
application point of view but then if
you want to use it for something to look
at system settings then it'll at runtime
it'll probably fail similarly things
like app domains so app domain various
platforms like dotnet core don't support
creating app domains but the api's are
still going to be there because various
other things do and require it
but at runtime they will throw they will
table throw exceptions so I was going to
be in the darknet standard 2.0 all of
these things basically as a high-level
overview of the files of the api's are
going to be in there it's not just these
citizen just the changes this is kind of
everything so you know for example
threads thread pull tasks and everything
a lot of that was already in dotnet core
and already in the Garnett standard but
it adds back things like the binary
format of for serialization as we've got
compatibility with previous code there
XPath annex link as well and total exam
and again if you go back to the github
page for the docs day you get to so you
can kill your browser and look at all of
the api's right so another somewhat
controversial chains are doing is
changing the way the API is a reference
the API set is defined by putting
everything into one library so if we
have another look at I've closed that
one already
so if we have another look at our next
standard library of 1 zeros series then
we see we've got a lot of different
assemblies being pulled in we're pulling
in lots of different packages and
there's a lot of api's going on there a
lot of assembly is going on not not
right now so that's going to change now
and the API is going to be defined by
next standard DLL by single API single a
single assembly because the
specification is monolithic you have to
have everything you can't mix and match
you have the whole API set there so why
have reference assemblies as
fine-grained and small just have them as
a single one but this has implications
then on packaging on implementation and
also on backwards compatibility the
existing assemblies which reference
the.net standard are expecting to have
all these fine grained assemblies around
and now they're going to be they'll have
they'll have gone it's also going to
split with the.net core as I say
previously built from the dotnet core
source code now has its own repository
on github and the dotnet slash standard
you can see all the API is defined there
so they're all defined as c-sharp files
and it builds in compiles and you can
raise issues against it you can talk to
that the project maintainer is there and
by splitting out now it means that
dotnet course simply implements the
standard it's no longer a special case
whereas before it was driving the
standard the other thing is that dotnet
core is also deprecating the
fine-grained packages that it had
because dotnet core needs to implement
the whole standard as well then it also
makes no sense to have all of the
libraries as separate libraries but this
was also one of the selling points of
darknet core was that you could have a
pay-for-play you could deploy just the
assemblies that were you using so this
is now going to have implications on
deployment was that if you've got the
platform package which includes
everything then it's much more of a
heavyweight platform and the this talk
of tooling to help this as well so post
builds you can do trimming and it'll
just include just the dependencies you
have and you can deploy that but right
now it's just going to be the whole
platform
what would be interesting would be to
know who was already deploying dotnet
core applications as standalone
applications trimmed down and who is
deploying it as a platform application
as well so whether it's going to cause
much of a trouble there you have any
questions where we are so far right very
good right so I want to have a look at
how it works so how all the how we can
sort of fix everything up and make
everything work so that the differences
between platforms work okay and the
differences between versions also work
so there's two ways of this works
firstly reference assemblies and
secondly type forwarding reference
assemblies are dead easy they're just
the assemblies that you pass into the
compiler and that defines the API if you
try and use an API that isn't in that
assembly you'll get a compiler error so
that's how we define our API set it's a
reference assembly the compiler is not
interested in the implementation of any
assembly reference and so reference
assemblies themselves they use empty
types though so they have methods which
have no implementation they don't return
anything and they're just void messes so
if we have a look a really big file noti
you saw where I'm so big but we'll we'll
do that so
that's not a good example let's have a
look at where all my classes so here's
an example this is one of our reference
assemblies here and you can see that all
of the methods then are just empty if we
have a look at another one there there's
there's nothing going on
things are just there they're throwing
there like even throwing a proper
exception there are empty types because
the compiler is just not interested in
the implementation so the implementation
assembly is then which do provide the
implementation these get resolved at
runtime these are implemented on your
system they're installed as your system
and these contained after implementation
so you must contain at least the
reference types and members that you've
got in your code but they can obviously
contain more a pis and so they can have
you know just because you're not
referencing something doesn't mean it's
not allowed to be in there and this is
how a platform can support the super
sets of versions and it can support a
later version if you have a look on your
system you've got the Microsoft net
folder for dotnet framework these are
all your implementation assemblies you
have a look at those in the decompile
you'd see the actual code and what is it
all doing if you fired up the compiler
and you use those as a reference
you wouldn't be targeting a particular
version of the framework you're
targeting the version of the framework
you have installed and so you wouldn't
be able to manage the api's that are
available to you as a visual studio and
msbuild they use references assemblies
and they've been doing it for absolutely
ages and they use that to target the
particular framework you run so you've
got the drop-down inside Visual Studio
that's telling Visual Studio msbuild to
use that particular folder so we can
have a look at that we pop back to here
and so we've got program files reference
assemblies and the dotnet framework in
fact if we go back here there's a whole
bunch of them you know from version 3.5
through to version 462 and if you have a
look in here there's a whole load of
assemblies that are going on there I
could drag one into it where are we look
there so let's drag one in and again if
we look to the type in here
something that isn't an exception then
again that's got implementation typical
the one I pick at random isn't the
reference assembly at all it's got an
implementation where you can pretend
that's empty that would have been a
whole lot better
don't pick things of random in future
so assuming oh yeah I want to stay in
Windows there's like because Visual
Studio uses reference assemblies from
that folder whereas if we go back to new
gap and we have a look at our one of our
assemblies here system collections for
example and we open that what you can
see is we've got our Lib folder as you'd
expect with with implementation
delousing there we've also got a ref
folder so new get actually knows how to
ship reference assemblies as well it's
got a ref folder and particular targets
frameworks as well and then the DLL
there and that DLL would be an empty
reference assembly as well right so when
you do make a reference on something and
you embed a reference into a type on
there the compiler actually embeds the
embeds that reference as an assembly
qualified name so it's not just the
names based system threading timer
it also embeds in the assembly name and
there's as well systems are threading it
also embeds the version and many public
key information as well and the runtime
uses this when it's resolving all the
all the types it looks for system
threading dll and make sure it's loaded
and it uses that one of the things that
is important with the CLR is that when
you're comparing types the assembly name
is taken into into consideration so if I
had system threading DLL which contains
system threading timer that is a
different type to system dot foo DLL
system threading timer and so they're
not equivalent and this is this then
causes problems with platform
implementation differences so this is a
good example down here system dot
objects on the.net framework that's
implemented in ms core Lib but in
portable class libraries and in dotnet
core
that's implemented in system run time we
need to try and unify that because just
as it stands right now those types are
not the same and so if you've got
systems or objects which isn't the same
then that's going to cause you massive
problems so this gets fixed by type
forwarding then won't come across type
forwarding at all before yeah time
forwarding is a nice mechanism within
the CLR which is an assembly level
attribute which simply redirects them
type to another assembly so we've got
this type forwarded to we give it
another type name and it is then when
the CLR tries to load that particular
type it sees the attribute says oh okay
I need to look in another assembly and
it goes and resolves it from there one
thing that type forwarding can do is it
can't rename anything everything has to
be in the same namespace it can just
move things into a different assembly it
redirects at runtime but also it
redirects at compile time so it can fix
up references at compile time as well so
the compiler will also follow these
attributes so what it allows us to
allows us to reference to type in one
assembly but implemented it in another
this is useful for platform differences
issues such as system the object being
objects being implemented in different
assemblies but also for refactoring the
platform for how net core for example
could split things out into different
assemblies how does this affect the
dotnet standard well the API is defined
in these references in reference
assemblies which are included in the
package and one point the one state
version one series libraries they
reference types in system dot something
dot dll so the whole bunch of systems
thinking DLL and then when that gets
resolved at runtime each platform can
then put in type forwarding to actually
put it to the real implementation so we
can have different implementations on
different platforms so we get some more
interesting question what can reference
what so this is now more about the
compatibility how do things and what is
it that you can reference between things
if we look at the dotnet standard one
you get this kind of pattern here so
across the top now we've got our
application frameworks so we got
Donna framework net core xamarin
zamarons very similar to dart net
framework as it happens they can then
reference a net standard library built
with the.net standard one so a donna
standard assembly and then don't let the
standard assembly itself can reference
another don't know standard library or a
portable class library I will quickly
walk through how this works because
there is differences with the type
systems here so when you are compiling
your library your dotnet standard one
assembly the reference is there they are
all talking to system thing DLL when
you're referencing a third party dot
next and at libraries they're also
referencing system thing DLL so no
compile errors that's all good that just
works portable class library also
references system that whatever DLL and
so no compile errors and that's works
portable class libraries possibly have
more API in the.net standard one and so
there's also another package you can use
there you can bring in Microsoft net
core portable compatibility to add in
those extra ap is when you're then
building your app at the top level
firstly you need to sort of add a
reference to your new assembly and there
are changes to new get to make that work
so it new get understands the mapping
between the platforms and the doníts
standard library so it's it knows that
net 4.6 if you are targeting down at 4.6
you can include anything which targets
next standard 1.3 and below when you're
compiling dotnet cornet core everything
references system dot whatever DLL and
so no compile errors so everything's
great with that so we've now got us like
a full stack of everything being
referenced but Donna framework and
xamarin they don't have system got
whatever dot dll's they have things
living in ms core lip and so we need to
fix that up and the system actually
gives forwarding reference assemblies
which fix up those those changes so if
we go back and have a look at Mary there
in our references assemblies folder up
here four four six two if we go up to
the top there is a facades folder
and this now gives us the API set from
dotnet call from dotnet standards one
point whatever and these are just type
forwarding assemblies and these will
forward straight to m/s call it and so
that fixes things up it means that we've
got no compile errors and we can then
reference from the net framework to
dotnet standard to a third-party darknet
standard or a portable class library a
runtime we're still going to have
references to system but whatever DLL
that's fine for dotnet core because that
everything just matches one-to-one again
for the desktop frameworks those runtime
facades are in place and they're they're
also installed into the microsoft.net
folder and that just redirects
everything as well
Doni standard 2.0 has the same sort of
idea it allows you to reference donek
standard library and portable class
libraries but it's also adding in
support for dotnet framework libraries
as well and we'll kind of quickly walk
through that too to change the net
standard dll changes a bunch of things
as well and makes things a bit trickier
so when you build your library in the
middle there all of your types of
referenced as being part of next
standard DLL when you reference another
dotnet standard library assembly if it's
net to sorry Dino standard to
everything's fine because it's all next
down to deal out everything just works
so no compile errors but if you're
looking at a one point of series
libraries there everything's reference
to system DLL and that won't works I
would give you compile errors so what
happens is the next standard library
includes a whole bunch of system facades
there which then type forward to next
standard so we've got things pointing
again to move things around and do that
and a compile time it'll fix of those
references and fix up your compile
errors the same is true for portable
class libraries they're expecting system
dot whatever and so they get pulled
through and redirected your additional
package is no longer necessary now
because the new api's have been added
and then we get to download framework
which is all different again because now
we've got the references in there of
talking to ms call it
rather than system dot whatever DLL and
here again we see that the dotnet
standard library so I've got the package
for the dotnet standard library - as you
can see it's still working progress
because it's one point seven but that
includes next standard DLL here which
has got our whole API set in there and
then it's got a whole bunch of system
the allows to type forward it's also got
MS core Lib as well in fact if we have a
look at that I've got the NuGet package
open here if we have a look in next
standard we see there's a whole load of
namespaces and a whole bunch of types in
there but then if we go to say system
console we see there are no types going
on in there but there are a bunch of
type forward attributes so we the NuGet
package will automatically forward away
for us for that it also provides MS core
Lib which doesn't have any
implementation and if we open that we
then get even more type forwards as well
so if anything is referencing MS collip
we've got the type forwards here which
will point to net standard so it's going
to point everything to next standard for
us and unify all those types so when you
combine your application again donek
core is ships with a next standard dll
so everything works and everything's
fine so that's good so that can be net
cord 2.0 but we could have a transient
reference to Emma's call it and so that
could cause us problems so what happens
here is we've got a package with C the
net core app package includes the net
standard library package which includes
the MS core lips facade which for is
everything - net standard which gets for
it's the real implementation so it's
changing everything along and it gets
repointed to the right thing and then
also we kind of have to do the reverse
then for the desktop frameworks so then
we have the desktop frameworks which
have a reference to Emma score live
sorry it's got references to next
standard and they need to be forwarded
to Emma's call it this isn't yet
implemented so we don't have this yet
but there will be a Florida in place for
that there's also going to be transient
references here so the the football
class library have references to system
whatever and
dart net framework so yeah the donut
framework one there has references to
Emma's core lib those are already
implemented by the system so
everything's fine there it just works
and at runtime the next standard DLL is
forwarded simply to the actual
implementation for dotnet core and on
the desktop again we need a forwarder
from net standard DLL 2ms call it and
that is yet that's still part of these
the work which is in progress so that
boils down to DA net standard one can
reference a dotnet standard one assembly
or a portable class library dotnet
standard two can reference a dotnet
standard assembly version one or version
two it can also reference portable class
libraries and it more importantly can
reference dotnet framework assemblies as
well so that means we can make use of
all the dotnet framework assemblies and
packages that are available on NuGet for
us the other important thing is that
NuGet knows the mapping between these
things in those the mapping between the
platforms and the dotnet standard
versions so when you are implementing a
platform and you're working with it and
you want to consume something new get
knows which version you can consume and
it also allows them the referencing
between the dotnet framework libraries
and from no standard platforms okay so
that kind of brings it to the end that
kind of covers everything really and so
to recap the dotnet standard it's a
specification which lists all the
available API is across the platforms
it's a replacement for portable class
libraries it changes the model it makes
it so the portable class libraries are
more extensible and you can add new
platforms in there and the other big
thing really is that 2.0 is adding back
all these API s so it's going to make
porting your code a whole lot easier
because you should just be able to
consume both you know so donek standard
platforms to be able to consume dotnet
framework assemblies and vice-versa
dotnet framework stuff will be able to
consume dotnet standard stuff so a
couple of useful links just to finish
off then the dotnet standard is actually
on github as I said under the dotnet
repo Dante slash standard there's some
really useful documentation in there
that that's where the links to the
version information is is on
and also emo Landreth from the is a
project program manager on the net team
he's got a number of very very useful
videos which explains this stuff as well
and they're well worth a watch and then
if you want to have a play with it
yourself even though it's still in
progress it's still currently called dot
next down at one point seven you can get
it off of my gate in the dotnet core
repo there is called next standard
library - although that will probably
unified as progress goes on so that's
going to be finished I don't know if
anybody has any questions right now
hello yes where we've got a microphone
sorry so we can record it I have a
question about refereeing interesting
portable class libraries if it gets any
easier before they understand that one
of the problems it could be that if you
say I have a library that I want to
reference to other libraries but they
are incompatible profiles yeah that's
the problem can I then repackage my
library to use dotnet standard will it
be possible then for to reference these
to other portable class libraries even
though they have incompatible profiles
I'm not possibly not because of the
incompatible profiles so there if we go
back to the links for dotnet standard
where is it
there so there is a mapping of the
profiles which are available down here
so we can't consume all portable class
libraries but there's a subset of them
which you can consume and these profiles
here are what you can consume and what
version of the donek standard it maps to
so as long as those mapped to a version
under standard you should be able to
take them yes but if it's incompatible
right now then the likelihood is that
they won't map to something there and in
which case it won't it won't be able to
do it however if it's your library you
could repackage it to be a dotnet
standard library in which case then you
know you can work around whatever API
difference is the work and then you
could consume it from different places
again mm-hmm thank you okay thanks any
other questions
nope ok I think we're done and oh we
have one question over there sorry hi
so the only promise of dotnet core
particularly for web apps that you can
put everything in a bin folder and not
care about the rest of the machine and
only ship the parts you want
so how's I going to play with this big
monolithic dll's anyone come across it
yet and found that their deploys ten
times the size or I think he's too early
to say about that
so it is going to it is changing the
deployment model so right now everything
is going to have a tonic core is going
to have a platform package which
includes everything but which means that
you can't do this smaller model and
smaller deployment but is that there are
talk this talk of tools which will then
you know after you've done your build
trim everything down so you've got a
smaller deployment model but right now
everything is still going to be this big
big thing but I'm also because when it's
not done it's it's hard to say what the
sizes of all of that as well so it might
be that it's still reasonable a
reasonable size rather than millions of
gigs right so that those tools are going
to be very non-trivial because as soon
as you do some reflection or IOC you
could be loading stuff which you very
hard to work out by inspecting the code
what's being referenced yes yeah mono
already has a some tooling in place for
for similar similar kinds of thing which
does does that kind of thing but yes
reflection can cause your problems and
you have to then provide extra inputs to
say I also want these these assemblies
as well and you know maybe it'll just be
that it'll work with the.net standard
libraries and themselves so it can trim
down the platform but it won't trim down
any of your any of your code or your
third-party references you know it's not
yet defined but of course it's you the
current position now with a monolithic
package is the same as when you do an
SDK based platform install so where you
install dotnet onto the the whatever it
is the container that you're you're
running in and then you've just
installed just Europe you're just your
application and there's the dependencies
there as part of the platform
okay right well thank you very much for
coming then okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>