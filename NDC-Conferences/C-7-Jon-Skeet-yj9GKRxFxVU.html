<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C# 7 - Jon Skeet | Coder Coacher - Coaching Coders</title><meta content="C# 7 - Jon Skeet - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C# 7 - Jon Skeet</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yj9GKRxFxVU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it is 4/20 exactly and the room goes
mostly quiet sorry
excellent and at this point in a day at
a conference I usually ask people to
stand up and jump up and down but if I
remember rightly if we do that here it
will sound like you're machine-gunning
me to death because of the way these
seats work so instead I don't need to
get up have any of you seen the musical
return to the Forbidden Planet no ok
it's Shakespeare's forgotten rock and
roll masterpiece slash sci-fi it's the
tempest set in outer space and at one
point they have to reverse the polarity
and the polarity reversal procedure goes
like this everyone has to put their
hands on the head go like this and then
go oh okay that was a rehearsal yeah
we're going to get properly now okay
this is just so you've got some energy
because there's a lot of code to follow
and I tend to talk very quickly when I
have far more material than time which
is the case okay so ready and push
harder push harder and oh right okay I
have fooled you into revealing that you
are capable of making noise and I was at
Kathleen's talk earlier on which was
fantastic but there were no questions
pretty much no questions um you will all
do better if any of you starts asking
questions okay
are any of my regular hecklers here
what's the question so the the t-shirt
says code like a girl and this was a
t-shirt that was recommended to me by
someone on Twitter after they'd seen me
wearing a he fishy t-shirt basically I
am phenomenally keen on diversity in
tech I was very pleased to see the MDC
speaker list this year was you know
getting better and better and I'm
frankly still disappointed in the
attendee ratios I think we can do a lot
of a lot better and the more diverse our
tech community is the better the ideas
will be do you want to work with the
best tools the best libraries the best
ideas that you possibly can of course
you do
that won't happen if half the world
isn't in
room and then you've got other forms of
discrimination as well so this is to
give the message that hate code like a
girl because there's nothing wrong with
that okay cool
that may be the earliest thing to a talk
I've ever received applause all right
okay so it sounds like I don't have any
particularly regular hecklers and if I
could ask you to reverse heckle as it
were if any of you are in Damon Edwards
and David Fowler's talked earlier on
they blame Barry dorans when something
went wrong
I thought this was a thoroughly good
model to follow so any problems I have
if it doesn't compile blame Barry Doran
sees blow-dart on Twitter he won't mind
at all okay I promise um right more
seriously the worse I present this the
better it is for me in a way because I'm
currently writing the fourth edition of
c-sharp in-depth and please buy the book
basically it will go into everything I'm
going into in a lot more detail I'm
nearly finished on the C sharp seven
features and it's sort of 110 pages just
of C chart features I cannot read 110
pages worth of book out loud in an hour
so clearly there's more in the book than
in this talk but it's kind of the same
general picture and yeah there's
discount code if you use the discount
code CTW NBC also 17 it's 40% of all
Manning books or you could buy many
copies of my book okay
right how many of you already have
Visual Studio 2017 installed this is
very good for years I think I gave talks
on async for three years in a row at NBC
and the first year it was kind of
reasonable that no one had played with
it yet
but by the second I want to play with it
and by the third year sort of half the
people have played with it and so at
least you can all use C top seven all
right you can't necessarily use all the
features if you're targeting all the
versions of the framework and don't want
to include extra dependencies I will try
to remember to bring in
to explain extra dependencies as they
come up how many of you are actively
knowingly using c-sharp 7 features
already far fewer ok so you have the
tools but not the knowledge this is
probably the ideal situation for me to
hopefully give you some knowledge this
is what we're going to talk about today
we probably won't talk about all of it
because there's huge amounts I will
point out two things in fact I'll
reorder things two things that you
probably don't care about oh yeah
whoever's doing screen could you yeah
I'm definitely I'm down here this will
be a really really difficult talk
without anything on monitor um
dum dum dum okay there we go right so
yeah so this makes more sense so if you
if you didn't catch it earlier below
dart is the person to blame okay but if
it's if it's good then it's all me okay
right so this is what we'll be talking
about I'm going to mention these now
because I probably won't have claimed
later on ref local and referee turn are
things that will let you do more
performant code particularly if you're
working with large structs I don't
particularly expect to ever use it other
than for talks like this if you're a
unity dev or someone dealing with large
mutable threats because it's for some
reason suitable in the codebase you're
working on and you want to deal with
them efficiently then that's for you
good luck and customizing return types
you kind of don't need to know about the
language feature here because the
asp.net core has team has built the one
custom async return type you will need
which is value task of T and the cool
stuff is that you can define your own
something task of key food tasks of T
and write factories and things but
basically you can have an async method
that returns value tasks of T and value
tasks is a value type as you'd expect
it's really efficient if most of the
time the task will already have been
completed
okay I could probably spend if I you
know researched it properly I could
probably spend the whole talk talking
about custom async return plates instead
almost no one will need to know the
language details so we'll concentrate on
this section let's start with tuples
tuples are a way of composing values
where you can't be bothered to write
your own pipe basically you know
previously if you want to have something
composing an x value and the y value
you've kind of declared your own point
class or point struct or whatever you
could have used system couple and but
that sucks it sucks because a it's a
class so you know you just want these
things that live together to live
together in a simple way and you know if
it's just a pair events do you really
want to create an object that's going to
have more overhead than the pair events
and probably even the reference assuming
a 64-bit CLR is the same size as the
pair events would be wouldn't it be nice
just to have a pair of int well tuples
let you do that um I'll give some sort
of guidance later on but basically they
are to do with smashing together things
with no encapsulation at all and that's
both a good thing and a bad thing who
can tell me the sort of golden rules of
value types anyone please shout out so
copy by value is sort of what happens
there was a guideline over there it in
you to for mutable mutable seaton no no
you'll never write a mutable value type
they're always immutable because mutable
value types are evil and likewise you
know when you've got fields do you make
your fields private or public you use
properties to encapsulate your fields or
just expose the fields to the world
protect it is
no just private always private you never
have public fields you never have
mutable value types unless your value
tupple okay so um the language feature
of tuples revolves around a CLR type
called system value tuple which is in a
nougat package called system value tuple
and version four point three point zero
four whatever is in goodness those what
happened to 1.0 etc it's mutable it has
public fields but it's okay I'll explain
to you later why it's okay let's have a
look at some tuples
so tuples as well as being value types
so better than system couple and they
have language support language syntax
support otherwise I wouldn't be talking
about them so let's have a look top of
construction that's at Apple a couple of
imps as I was saying without before so
it has two fields item one and item two
and so this would print out one and two
and this this code is if I wrote it like
that equivalent to this this is the
c-sharp compiler just converting this
topple literal into a call to a
constructor but don't forget this is
still a value double value type so it's
still sitting on the stack if I put that
back to long and make that to L it's
still okay and I will say I could do an
int long topple one equals one two you
might be expecting that to construct a
couple of int int if that were the type
of the the literal and then convert it
somehow to a tuple of int long but the
compiler smarter than that it says well
you've got a top of literal you're
trying to convert it to an int long
supple I will just do the right thing
for you so the compiler does nice things
too
be efficient okay these are nasty old
like system couple forms it becomes
significantly nicer when you give tupple
elements names so here we have a couple
literal where we have a and B so here we
name couple elements in the same way as
we name arguments within a tuple literal
so remember a couple literal is like an
integer literal or like a string literal
it's what you can do to sort of hard
code I'm building a couple now likewise
you can define a tuple type if you don't
want to use var you can give names
within the tupple type so sort of as if
it's like a parameter list so if you
think if that looks like an argument
list this looks like a parameter list
and it's it's slightly ashamed that we
can't actually call methods passing a
tuple that corresponds to the argument
list it would be a nice sort of duality
but we got so we have tuples have
elements they have fields of item one
item two item three etc up to seven
there are eight value couple generic
overloads as it were and we've got this
idea of a tuple type and that can have
named parameters link elements as well a
and B don't actually exist they are an
idea in the mind of the compiler and of
you what they mean is there like Java
generics if any of you have used Java
generics you should know that an
ArrayList of string at execution time is
just an ArrayList well likewise a tuple
of int and long is just sorry a couple
of long a int B is just couple of long
int at execution time okay that's the
only way things to work because we have
one set of tuples types if I were to do
one
the alternatives the couple types is use
anonymous types that has the benefits of
you get names which you don't with
system dot double but it has the
downside of oh then it's it's on the
heat it's a whole object and you can't
pass it between methods and things I'll
show you
using methods in a minute so I could
have done var a non equals nu a equals 1
B equals 2 and that's fine but that
creates a whole new type an internal
type that the compiler is constructing
for us and that doesn't happen with
tuples every tuple you need is already
in the system value couple DLL and it's
generic and you'll get different generic
instantiations as it were but that's a
slightly different matter but that does
mean that these these names can't exist
at execution time the compiler converts
anytime that I use a here well not on
the in long sight if I use couple dot a
couple for dot a if I look at this with
il Gotham it will be using item 1 ok so
it's just compiler magic but it's really
useful compiler magic and it's useful
because it's fairly obvious what what
happens within a single method but what
about if I call so if I call a method
that returns a tuple let's do some and
let's do minimax so as an example of
where you might want to do this we're
going to have some integers values 1 2 5
10 minus 3 what
and I can get them in easily yeah I can
do in main equals values men in Mexicans
values Max and that's fine but that's
evaluated its run over that sequence
twice and that's not good
wouldn't it be nicer if I could do int
min in max min max ienumerable int these
can be generic of course values and I'm
going to do for each it's racer equals
values that gets a numerator and if we
don't have any will throw an exception
we throw a proper exception normally but
otherwise we're going to start with
let's call it something in equals
iterator current and temp max equals
iterator current I started on this for
there's a reason why names are good but
I'm kind of going to be evolving this
example to show a bunch of things so
listen for everything not just the names
a good and we can do while it's rated
move next and took min equals math dot
min it's like to maxify and it's rated
current and some min equals no
it just screws everything up when it
doesn't type what I'm saying
blame Barry right and then after that I
can return and earlier when we used a
couple literal we always have one two
and they were constant values they don't
have to be constants it's fine you can
do to mean something ax okay and then
let's print out instead of having these
two method calls will have farm in max
equals min max did I call it min and Max
no values okay how about we make it
static so I can actually call it and
then we can you console dot write line
min min max dot what have I got
I've got min I I don't have to remember
whether item 1 is the minimum or item 2
because imagine if this were somewhere
else entirely it would be confusing so
names are so so important and we'll see
in a minute just how important the
language team believes them to be let's
just prove that this works or find the
bug that we can blame both it blowed up
for what did I call it min and Max right
minimum of minus 3 and maximum of 10
apologies to those near the back if
that's hard to read and would take too
long to fix so yeah a min of minus 3 in
a max of 10 looks kind of good right so
so far we've proved that the names here
are also available here this is a really
good thing and at this point we've
already blown past what you can do with
anonymous types because you can't return
an anonymous type from a method because
how would you declare it you put the
name and it's anonymous it doesn't have
a name it's kind of the problem so this
is why this exists really now what if we
done
fact that sort of imagine that you've
got lots of lines of code you know
you're meant to return it up all but you
know you've got loads of stuff right
well you can put the tupple names in the
literal as well so max isn't max mean is
2 min and suddenly the compiler at least
gives you a little warning saying well
it's actually saying I'm ignoring it
you're allowed to do that but by the way
you're giving a different couple element
name to the one that I'm about to return
so this is one of those things that it's
a warning you almost certainly want to
take note of and it goes away if you use
the right values the right names so this
is a really good way when you're using
tuples and you can do this to make sure
that you never return the wrong thing
however I said that tuples are mutable
value types so why don't we just you
know why have we got two variables here
let's have one variable that's a bag of
variables how about we have var min max
equals min iterator current max iterator
current and now we can say instead of
having two assignments we can have a
single assignment that says our new
value is math dot min of min max dot min
and it's rated current you know what
let's have a little local current equals
iterator current
and the second element is math max min
max max current I'm going to undo in a
sec because I want to demonstrate
something different and now we can just
return min max okay so I said I was
going to use the fact that these are
mutable value types I've now failed to
do so what I should have done is go via
a set a second step which you know we
can make it the the third step that's
fine we can just mutate a bit of we're
changing both of the variables within
this couple so it kind of I prefer
changing the whole thing in one step but
these are all basically equivalent so
this is a good way of saying we had two
variables and this is how I want you to
be thinking about tuples we had two
variables but they're related to each
other we haven't really got
encapsulation but we're sort of
pretending that we have temporarily
we're associating them together we could
easily have some other tuples
representing other things we might have
some and count those kind of belong
together
and you know we could smush them into
one couple of four things or two tuples
of two it's fine they are bags of
variables while they're variable so the
min max variable is a bag of variables
the value we're returning is a bag of
values so think of a tuple as a bag with
stuff in and when I think about
variables in general
I think of them as like pieces of paper
a piece of paper with a value and a name
and a type and a topple is like having
two of those pieces of paper and instead
of each of them having their own
separate type sorry separate piece of
paper we're sort of joining the pieces
together
say this as a whole is one thing that's
got an overall name and each bit of it
can also have names but they're optional
even though they are optional I would
personally recommend that you almost
always use them if you find yourself
using item 1 and item 2 then think about
would your code not be clearer to read
if you did have names there are some
other interesting things let's let's
talk a little bit more about names and
plates I've mentioned that their system
value tupple and the way to think about
the various types is that there are
language types and there are CLR types
and the language types are different
types but they there's an identity
conversion between different couple
types that only differ by element names
or where there's an element-wise
implicit conversion so there's a let me
show it's really easy to get this very
slightly wrong and I really don't want
to so we can have an implicit conversion
from any tuple type to another tuple
type where there's an element-wise
implicit conversion so there's in this
case I'm showing from couple literals
but it could be if I created a whole
couple so if I have far in stuff all
equals 10 - ok let's even make it
clearer long long long double equals in
purple okay this is an implicit
conversion because there's an implicit
conversion from int along and from this
input this long and it can be a
user-defined implicit conversion as well
so for example we can go from a pair of
names that are strings to a pair of
namespaces that are x namespace because
there's an implicit conversion from
string to x namespace
so that's an implicit conversion but it
does say I'm taking these values and
making a new bag of values okay there's
also an identity conversion and identity
conversions are not new they're they've
existed for various things around
covariance and also between dynamic and
object so just as you could have a
dictionary of object dynamic foo equals
new dictionary dynamic object okay you
don't want to but you could
fingers crossed
yes that's fine you could do this
between two tuple types two language
tuple types where the element types are
the same but the names can be different
and the way to remember this is an
identity conversion is one that the CLR
has no idea about so when I do this as
far as the CLR is concerned it will
create a dictionary of object to object
because dynamic doesn't exist in the CLR
s mind so an identity conversion is one
where if you ask at runtime you can't
tell the difference and that's where the
fact that there is only system value
tupple and it doesn't know whether you
originally had element names or not
that's why there's an identity
conversion so anywhere in the language
that requires an identity conversion
we'll see it however there's this one
weird anomaly which I think was probably
a good idea and would have been an even
better idea if they've thought of it
like 15 years ago which is in terms of
overrides so the names are preserved for
well we saw calling a method you could
be calling a method in a different
assembly and the names would still come
across because they're preserved in
attributes and I'm not going to go into
the details of how the attributes work
but basically that works for return
values and for
mutters you even though a value of
system values Apple doesn't have the
names at execution time the metadata in
the class still knows what it was meant
to be and the compiler insists that if
you're overriding something you don't
start changing names so even though I
can do tuples tupple original and tupple
override okay that's okay even though it
can screw up our if you if you specify
argument names it can screw things up
I'm allowed to do that what I can't do
is this so the error message is couple
names and override derived foo int a and
B cannot change couple element names
when overriding inherited member so this
is this is kind of weird this is c-sharp
being stricter about something that is
sort of a figment of our imagination
than it is with stuff that's rather more
concrete and available via normal
reflection and that the CLR knows about
okay in the interest of time because Wow
halfway I would like to move off couples
does anybody have any questions about
tuples before I do yes
will the name give the right name in
reflection no so if you were to get
topple over I'd as a parameter sorry
Adam the member info parameter info and
asked for its type it will give you
system value supple if you ask for the
attributes applied to that parameter
info you will find something that is
couple element names or something like
that so you can reconstruct it via
reflection but you would have to be
doing so yourself and it gets hairy when
there are more than eight parameters
that ah right so can I get so you're
saying could I do
let's a couple fields and no right so if
I do here t1 get type get field X that
will say note that doesn't exist item 1
and item 2 will exist but X does not
because it's the same t1 get type equals
t2 get tight there they are the exact
same type which is system value tupple
int int okay so there's no way that they
could have different things and they
could have built it that way and you
have horrible type aliasing between
assemblies and all kinds of nasty stuff
and it would be much more expensive in
terms of loading so many more types this
is a definite pros and cons thing
maybe if tuples have been seen to be
important
way way ago maybe the CLR could have its
own knowledge of them and have some sort
of lightweight kind of just-in-time
thing but no and that's why it's it's
really important to understand this is
what the language knows about and what
I'll see when I'm writing source code
and this is what's available an
execution claim and in particular that's
one of the nice things I think about
named pipes if I'm just wanting to do
some Diagnostics I will stick in a named
type dump it out to the console and it
comes up with property name equals
property value and that's lovely value
couple does have it does equals it does
structural comparison it does override
to string
it can only give you item1 item2 in fact
it doesn't bother showing item1 item2 it
just puts the values in a
comma-separated list there was one other
thing I was going to give which was some
guidance around using tuples which is
don't put them in your public API yet
okay then you certainly I'm still
figuring out where it makes sense to use
them and my guess is other people will
be too they offer no encapsulation at
all so if you create a class to
represent this thing I'm returning to
you you can add extra properties to that
class later on if you return if you say
you're returning a tuple that's exactly
what you're returning and people will be
able to mutate stuff and it destroys a
bunch of encapsulation things it's
really a shorthand for I can't be
bothered to encapsulate this that's a
good thing because for the effort of
encapsulating something and writing
tests and it goes on and is time that
you could be spent doing something else
but you don't want to pay the price for
not doing it by exposing it publicly so
I would personally say keep it internal
for the moment you know within one class
if you decide later on to encapsulate
stuff as a class then that's going to be
easy within a whole assembly it's going
to be slightly trickier but but still
feasible but if your code has escaped to
other people then it's going to be much
much harder okay let's talk about
deconstruction so so far I've shown you
composing a bag of variables or a bag of
values what about if we want to
deconstruct stuff instead let's start
off by deconstructing what we have first
constructed so if we look at couple
deconstruction here we have a method
that returns a couple okay it doesn't
matter what our return statement was I'm
just creating a tuple previously let me
just show you know deconstruction
our couple equals create couple with
deconstruction we are declaring three
different variables in one go okay it
really is equivalent to this code here
where we get the tupple and then we
deconstruct the a the B and the C you
don't have to do it as far like that you
can do int a int B and let's go that's
going to be a string but let's make B
along and it just says well I had a
couple with an int in I can convert into
long that's fine no problem what you
can't currently do but I think they may
be planning it for c-sharp 7.2 is
something like that and do partially I
want to assign things and partially I
want to declare new values what you can
do if I remember rightly and I really
hope I do let's not bother giving
anything values to start with but you
can do I don't want to declare any
variables I just want to do assignments
yes/no squiggles so you know maybe
you've got a B and C from other things
or maybe you've got default values or
whatever it is you can assign to all
three of them in one go
and that's tupple deconstruction and
that has built in language support but
that's not the end of deconstruction
they're unhappy with how one
deconstructs tuples I haven't gone into
details of exactly when you would want
to I will let you figure that out for
yourself because yeah there's a lot of
features to go through but everyone
happy with the idea of we took something
that was about the simplest way of
composing things that you can have which
is a tupple and we extracted from it
either three new variables or three new
values for existing variables everyone
happy okay we can go from that to
deconstructing and
other things so let's have a look at
this D constructible class so here we've
got three properties and to deconstruct
methods
okay so deconstruct becomes a special
name it's not a keyword or even a
contextual keyword it's a special name
in the same way that gets a numerator
and get away Terr
are if you have a deconstruct method
that is void and only has out for
amateurs and is accessible and is non
generic for complicated reasons then you
can use it for deconstruction so if I
create a deconstruct a ball I can give
it a message and an X these are just
regular properties I can deconstruct
that to carried a message
this is assigning to existing variables
here we've got new variables and notes
how I can deconstruct two different ways
I've got to deconstruct methods and I
can use overload resolution or rather
the compiler can use overload resolution
to just say hey I'll allow get some
extra some new variables and that's just
regular and deconstructors so a regular
overload resolution you may be wondering
why these are out parameters rather than
why doesn't the deconstruct method just
return a tuple well imagine if we wanted
to do this
suppose we had suppose it was called
topple deconstruct we could do public
tuples deconstruct int X in the string
message and let's just return X message
and sorry bomb this looks really weird
the first thing you you look at it okay
because it looks like I've got the
parameter list at the wrong place which
is what I know I was falling into the
trap myself this is not a parameter list
this is a return type doesn't it look
like a return type no it looks like a
parameter list that's a tupple return
type if I just done it as int string it
might have looked more like a return
type but then it would have been kind of
harder to use but if I now try to do int
X string message exception error couple
deconstruct anyone see what the problem
is going to be Palin overload on return
type I heard it was that you yeah yeah
so you can't do that you're not allowed
to overload just by return type whereas
if you've got out parameters it's all
good
I would just like to point out because I
keep on thinking oh I wonder if I can
know that's a stupid idea you can't do
if I've got D constructible D equals
let's just copy this
if you do VAR d 2 equals B and think I
would like to be construct and have D 2
XV 2 dot no this is just a regular
assignment this isn't going to do
deconstruction every so often I think
our template just use our no it clearly
just isn't going to work because that
would be a regular assignment okay so
this is doing exactly the same thing as
before with tuples but in this case with
our own custom classes what if we wanted
to do it with somebody else's classes
now I'm a date-time geek so naturally
when I start thinking examples take time
immediately comes to mind but I think
it's kind of reasonable that we may well
want to deconstruct a date type of some
description and we'll use systems or
bake time for the moment in reality of
course all of you would use no time
right but if you if you have to use
system take time for some reason
wouldn't it be nice if you could just
say I just want to get the Year month
and day out and that's clearly the order
in which it should deconstruct and we
can because I mentioned that deconstruct
was a special name like get away tur and
that's exactly the same Jo I have
actually given that my example is for no
time but let's make it date/time and
it'll all just compile and we can just
use today equals date time today
darn it
yep no I need date/time there ah
function key was locked down
that explains lots of things right I
feel dirty
I need a shower use no dirt okay okay
and never used a time dot state anyway
you can see the names that I've given
here aren't the same names as I've got
in here but the fact that I think if I
hover over now it's not showing me but
we're deconstructing into a year month
and day and I'm doing this just by
having a deconstruct method as if I
created it on the type itself but it's
an extension method and this is goodness
there is one downside of deconstruction
which I still don't fully understand and
can you see any tuples here in this code
nope
there are none if you try to compile
this code in a new project that doesn't
have a reference assistant al you tupple
the compiler will complain at you you
have to have a reference for system
value couple if you're not using tuples
anywhere it will happily emit an
assembly that doesn't refer to system
value tupple but as a compiler
implementation detail you need to have a
reference to it I filed the bug
apparently it was deliberate I'm not the
only one who finds this annoying so
fingers crossed it might get fixed right
so that's deconstruction I'm just trying
to think of the suitable order yeah I
think I know where we'll go next does
anyone have any more questions on
deconstruction nope
okay let's talk about out parameters I
seem to have a load of unsaved code
let's just save everything hope sorry
question yeah sure
ah yes sorry well done thank you if you
want to deconstruct things and you don't
really care about all the beats so for a
start sometimes you should think is the
construction appropriate here but
there's what's called a disk our
variable of underscore and it has to be
exactly underscore I think
let's try underscore ohno ohno knows
that they'll have a red squiggly so
underscore has become a special name
which means I don't care I'm explicitly
not caring so here I'm not allowed to do
this let's make it slightly clearer if I
do X X and X X again that doesn't work
because that is declaring two variables
called X X and that's not allowed
whereas I can have as many things as I
like out of interest does it stop me
from being really stupid okay if you say
I do not care about anything
I am deconstructing just for the heck of
it now maybe I want the side effects of
calling deconstruct because I want to
see whether it will throw an exception
oh I can't now right I know it really
does have a squiggle sorry and do the
squiggles get bigger they do yeah so you
can just about see there is a squiggle
under there it's in the error list it's
fine so yeah at this point it's not
declaring a variable and you can
possibly see that the underscore itself
is in blue which means sort of keyword E
and if you're currently a purchaser a
customer of c-sharp in depth and the the
chapter on deconstruction I think
doesn't refer to this because there was
a lot of is this happening isn't this
happening and it was only when I watched
the build video with mAb saugus --n and
Dustin Campbell that I found out it was
back in again and had actually made the
cut I had tried something similar I
can't remember with what construct it
wasn't working for me I think you can't
do
VAR x equals can you do it with tuples 5
5 10 can you deconstruct apples like
that yeah that's ok there was there was
some way in which it wouldn't work and I
happen to hit that and thought that
discards had gone entirely okay so and
the way that deconstruction is actually
implemented and the reason that generics
don't work with it is because it uses
another feature called out parameters or
out variables and if like me you have
always been really annoyed at having to
declare a variable so that you could
then use it in a call to say date/time
duck fry pals fear not it is now okay
you can declare out variables in line so
this is how we used to call in try pass
and this is how we can do it now okay
now one of the one of the reasons that
this used to be annoying was generally
if in dr. Parrs
failed you don't want value one still in
scope it's going to have the default
value we're kind of not interested
anymore so there was some discussion
about should the out variable declared
here only be sort of inside the scope of
the if itself for various reasons that
basically I think dropped out as soon as
they try to use this feature it doesn't
it still has the same scope as before so
we could use value to you know all the
way down here and that's fine it will be
definitely assigned let me show you an
example where things might not be
definitely assigned so if and if not try
pars
five let's call it out in live one for
live coding and in try cars six out int
live - okay within here we can I don't
care about the order we can use both
five one and live - out here we can
still do live to equal 10 so the
variable still exists and is in scope
but if we try just printing live -
instead we can't because it's not
definitely assigned I'm hoping everyone
is familiar with what definite
assignment means it's basically can you
read the local variable has the compiler
checked that every way that you could
get through to here will have assigned a
value and that's exactly what's wrong
here live one that's fine we've
definitely called in dot tripe ours so
live one is definitely assigned but we
might not have called the second tripe
ours in which case live two won't have
been initialized within here we know
that we will only get to the body of
this statement if both of these
conditions are true and evaluating that
second condition does initialize life -
therefore life - is definitely assigned
okay yes
indeed because and there we go so now
live - is not definitely assigned of
course if you do live - equals ten yeah
pointless but it is a regular variable
so you can assign to it afterwards and
but it won't rules of definite
assignment they do the right thing just
be aware that the scope of live one is
the whole thing okay let's move on how
long have I got
ten minutes oh my word there's no way we
can do pattern matching and local
functions in ten minutes
right quickest demonstration of pattern
matching
ever so going from out variables being
introduced with you're calling a method
with an out parameter you can declare
the variable right in the method call a
similar sort of pattern is this so this
is sort of broadly like if X is int int
I equals int X so you can use this for
anywhere that you were previously using
as and saying all if it's not no I'll do
this you can use is as well is with a
variable so this this is a pattern and
again this declares I I believe so I is
again unassigned here because it won't
be assigned anything if X isn't an
integer but it does have it is still in
scope so we can do I equal 10 for
example that's one example of a pattern
patterns are a new feature in c-sharp
seven which hasn't yet come to full
fruition it haven't yet blossomed
it is a sapling with some interesting
shoots as it were there are two places
you can use pattern
one is with if expertise expressions and
they don't have to be in if I hope I
believe you can do bull was an int I
equals x is int foo yes but at this
point it's kind of pointless because I
can't use foo because it's not
definitely assigned I can see whether
the pattern maps or not so but my point
is it's not specific to if you could
certainly do while X isn't food and but
it's part of the is construct the other
place you can use these is in switch
cases and in switch case we have this
additional idea of a win guard clause so
the kinds of patterns that exist so
there are two places you can use them
I'll go into a little bit more detail
about switch case in a minute so you can
use them for each expressions and you
can use them for switch case and I
suspect that maybe the only places
you'll be able to use them for a little
bit but that's the idea of those are
places you can use any pattern so far
there are three kinds of pattern one is
the type matching pattern that we've
seen this in Thai that's a pattern that
matches if they the candidate whatever
we want to call it the test value is an
int and it declares a variable called I
the second kind of pattern is a constant
pattern that just says is it equal to a
constant okay it also has to match the
right the right type so that can be
object X is five it will only work if X
isn't in 32 of five if you pass a box
long this will print false or other it
won't print yes X is five and the third
type of pattern that I haven't shown
here
X is VAR v nope bar V V is V that's a
pattern that always matches and it
declares a new variable of that type
sorry of it declares a new variable
which is implicitly defined to be the
same type as X so in this case it's just
object and you may be wondering why I
bother having a pattern that introduces
another variable that looks exactly the
same as our previous arrabal well we
might not have had a variable because we
might have been doing if some
complicated method or we could be
switching on some complicated method and
in an if statement it's pointless okay
I'm going to kill this example again in
a switch case it can be important
because you can then use the variable
where maybe you wouldn't have had a
variable before or we could do case var
oh when Oh get type is value type for
example so we've got a guard clause here
so this is the second place you can use
pattern matching is within switch case
statements now there are two ways you
can think to yourself about how switch
statements work and both will work for
you it's fine use whichever you find
better one is I've got a switch case
statement that's only got constants it's
an old-school
switch statement and I've got new style
new school switch statements which have
patterns in and they're entirely
different kind of switch statements that
works as a model or you can say every
switch statement ever has patterns
if I only had so if I had
static void old school index switch X
and case three and then something and
then case ten yeah this looks exactly
the same as the previous thing 3 is a
pattern it's a constant pattern that
only matches the value 3 so every
previous switch statement is a pattern
switch statement so if that's an easier
model for you to think about then fine
it is worth being aware that suddenly
order matters in switch statements it
hasn't usually previously methods
barring weird scoping things but here
they're tested in order so the compiler
will do some optimizations if you have
multiple constants and it can do so it
can do some optimizations in the same
way that you see however otherwise it
will look one at Simon site well is the
value of Phi X 5 no okay let's see
whether it's an odd number okay it
wasn't odd is it still an integer yes it
is therefore I will return something
otherwise keep going down so it's very
much like an if else if else if else
however you should be thinking to
yourself this feels more like all those
F sharp talks that I went to and swore
afterwards that I was about to learn F
sharp and nearly got as far as buying
the book and then I remembered all the
previous times that I bought the book
and never actually read it
yeah you've all all been there all seen
those the person matching an F sharp and
thought that's really beautiful I should
really get round to learning that
sometime well this is C sharps sort of
way of getting a little bit into that I
expect currently switches still a
statement
you can't implement a whole method by
saying well here's a bunch of cases that
might come and it's definitely the way
to start thinking about it is well I can
react to a number of different
situations I will make each of those
situations a case pattern that works
really really well ok
am I already over time no I have three
minutes to show you local functions very
very quickly
let me just see the agenda make sure
there isn't anything more okay numeric
literals you can use binary you can use
underscores within numeric literals
right that was that feature done throw
expressions in certain places and I
won't say exactly where because I'd have
to remember it you can use throw as if
it's an expression instead of a
statement so for example in the null
conditional sorry the null coalescing
operator you can say well either return
value or throw an exception in the
regular conditional ternary operator
it's the conditional operator damn it
happens to be turning then you can say
well if we get as far as the bottom tor
an exception and there's another case
that I can't remember offhand I think
but yeah oh you could just throw an
exception anyway
now my new way of doing I want to write
a method that unimplemented is to use an
expression body member and just throw an
extra an ex throw an exception you
couldn't do this in c-sharp six because
it wasn't an expression and strangely
enough an expression body member has to
have a body that is an expression now
it's an expression
pray write local functions I've only got
five examples this I'm sure it won't
take more than two minutes and you can
write methods within methods okay it's
as simple as that
so here we have a fifth method that
calls itself so you couldn't do this
just with a delegate called fib because
then well you could you declare it and
assign a null value to it then assign a
lambda expression which could call fib
and that would be horrible this is a
method it can call itself and you can so
that's that's the other equivalent let's
see whether we have something that
captures a variable no that's just a an
example right here we go and like lambda
expressions local methods can capture
state from the surrounding context so
they can act as closures however they're
really interesting if you had
this sorry no it's a bear that if you
implemented this as a lambda expression
so suppose I have action increment and
prints I equals nothing goes to stuff
kill the local method okay in order to
implement that the compiler would
generate a new class and in the main
method it would create an instance of
that class and that class would have a
field called I in it and it would do all
kinds of stuff and the reason is by the
time it's created a delegate from it
that delegate could still live after the
main method has finished however think
about when I've got just a local method
unless I capture that that method
somehow and I can do that like this
methyl group conversion there is no way
that this method is going to increment
it sorry is going to be executed using
that I variable after main has completed
or imagine it's not a main method but
something that can be called several
times each time you call the method you
get a new variable and you know that
there will be no way that that method
will like the the nested method will
execute and need to use that same
variable by the time it's finished so it
can do it all on the stack this time it
will still generate a new type but it
will be a struct a mutable struct again
and it will generate a magic rest
generated struct struct
yes Estie let's call it and it will do
st dot I plus plus and st dot i and then
it will do generated struct st equal new
generate disrupt not that this exists at
the moment that you know the compiler
generate it st dot i equals 10 and then
it do rest st okay what's the cool thing
about that everything's still on the
stack that has not generated a single
new object and because the struct only
has the same number of fields as we had
local variables in scope it's only taken
the same amount of space on the stack as
it would have done before it's very cool
final thing to note on local functions
of i mean two minutes over already is
you can refer to local variables that
are deeply nested within a method but
your local method then has to be deeply
nested as well so this is declaring a
method within a for loop now obviously
that's not actually going to create a
new object for the method on each
iteration it will create some things on
each iteration but at that point it's
okay to refer to this j variable that's
new I can't do this out here
because Jay doesn't exist that will
intersect there we go give me an error
so you can only refer to variables when
they're in scope you can only refer to
them if the call is right I can refer to
them here because Jay has been declared
it has to be after the declaration for
no particularly obvious reason but even
though Jay is not definitely assigned at
the start of the method by the time we
actually call the local method it is
definitely assigned so that's okay and
the compiler makes sure that everything
works right and that is all I have time
for I don't want to make you late for
your next sessions as you can spot
there's a lot in c-sharp 7 the general
theme where is the C sharp 5 worth of
our async C top 4 words all about
dynamic feature up through is all linked
and things C sharp 7 a bit like C sharp
6 was will kind of make the world a bit
better we will make your code easier to
read we will give you tool sets for
expressing yourself more clearly this is
no bad thing great idea huge ideas are
good but a lot of little improvements
that let you express yourself better and
more clearly and more concisely are also
good too much more detail in C Sharman
that's a book there's loads of detail in
blog posts as well and so there's plenty
of room to experiment I hope if nothing
else all of you who stuck your hand up
saying I've got Visual Studio 2017 but
I'm not knowingly using C sharp 7
hopefully you will all go back to your
hotel room tonight and start just
playing
you will learn far far more by playing
than you can possibly do by listening to
me I'm don't eat thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>