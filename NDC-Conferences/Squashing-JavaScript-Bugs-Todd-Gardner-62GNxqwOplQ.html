<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Squashing JavaScript Bugs - Todd Gardner | Coder Coacher - Coaching Coders</title><meta content="Squashing JavaScript Bugs - Todd Gardner - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Squashing JavaScript Bugs - Todd Gardner</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/62GNxqwOplQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Todd and this is squashing
JavaScript bugs so where everybody wants
to be right how many of you hate
JavaScript secretly way down but you
just have to use it I know I feel yeah
all right so this session is squashing
javascript bugs and what we're gonna do
together is we're gonna debug several
several bugs in an app live here
together we're gonna use the real tools
that are available to you today for free
that you can download and play with at
firm like there's lots of great sessions
here at the conference I firmly believe
in the rule of two feet so that means if
you are not getting anything out of the
session there's so many other great
things happening feel free to stand up
and go to one of the other sessions I
promise I will only be minorly offended
if you do it but I still want you to do
it okay so before we get started
debugging we gotta I have to show you
the app that I have that has some bugs
in it so how many of you use Twitter
yeah I use Twitter a lot and Twitter is
great but Twitter has a couple of really
big problems and they're perfectly
illustrated by this comic there are just
so many people who are wrong on Twitter
and it's our job to go and correct them
no matter what our personal sacrifices
might be and I think this is that the
big problem with Twitter as a business
and as a network and I think I have an
opportunity to fix it so I created this
little thing that I call get Rancher and
I want to show it to you today are you
ready you wants to get ranter this is
get ranter and it looks kind of like
Twitter so like up in the upper left I
have I have a picture of my profile
picture this is an older picture of me
back when I had more hair on the top of
my head and a little bit less on the
bottom and I've been ranting since 2015
and i Brants about all kinds of things
about like Silicon Valley stuff and
Donald Trump and crazy things like CSS
and all that sort of thing and I have
these awesome advertisements that are
totally targeted at me I'm gonna make so
much money like based on where I go on
the internet like it targets all these
things that I
like bacon and Hasselhoff and bears and
Crocodile Dundee and it's just it's so
spot-on but get rancher leaves off the
most irritating part of Twitter other
people because we've get ranter it's all
about you
only you can rant on your profile only
you can see your rants on your profile
and no get rancher user can interact
with any other get ranch or user so
that's brilliant you can scream into the
void and there will be no consequence
for your actions
I think there'd be so much on on Twitter
that would be better for that so
obviously get rancher
we're still kind of a stealthy startup
so like don't go telling everybody about
it but if you ever want to like play
with it and like get an idea of what
kind of things are in get Rancher you
can pick it up on github here I'll put
these online later
alright so clearly this is going to be
Silicon Valley's new hotness like next
year this is gonna be everywhere if any
of you are VC's I'll take term sheets at
the door on the end this thing is gonna
blow up but the big problem here is that
get ranter was written with JavaScript
and so javascript is going to have some
bugs in it and so that's what we're
gonna do today we're going to
collaboratively go through a couple of
bugs that different people have reported
to me on using get ranter and and work
through them together we're gonna to do
that we're gonna need some help from
another little thing that I work on
called track jeaious which is a
javascript error monitoring service it
helps me know when my end-users run into
run into bugs through trucks yes which
I've been doing for four years I've
helped fix 50 billion bugs for all kinds
of big companies all over the world
that's enough about that moving on to
the knot to the actual interesting part
here's our first bug now this is a bug
that my QA team has reported to me so
use a user using using get ranter they
couldn't delete one of their rants out
of the timeline and so I have a delete
button but there's no like apparently
it's not working
so here's a big scary bug let's
wash it together so here we have get
rancher this is my user account now my
I'm a dev like I write this and so my
dev account like your dev accounts on
your system it's probably full of all
kinds of weird unusual data like you've
been doing one-off testing you have
sample data you've been messing with
your stuff and so it's not really
representative of a real user so one of
the best recommendations I can offer for
debugging JavaScript or any other app is
to have a way to impersonate real users
with real user data it gets you a better
picture of of how a real user account is
structured so I'm going to impersonate
one of my real users I'm gonna switch
that out here and so now now I'm going
to impersonate a real a real get rancher
user and so now I can try and debug this
issue using a much more targeted and
representative sample and as on the side
here um you can really tell that my
advertisement targeting is going to make
me a fortune
like how spot-on are these ads they like
this is gonna be ridiculous anyway that
aside let's say let's try and recreate
our bug they're our QA team identified
for us so our QA team said that a user
couldn't delete something out of their
timeline so let's say Donald here wants
to delete this this rant here where he
called into question the ethics of a
federal judge
maybe he says aside he didn't want that
on the internet anymore and so he goes
to delete that at rant and it doesn't
work the page reloads but nothing is
actually happening so let's start
digging in to figure out what's going
wrong if I open up so I'm running chrome
here just the latest chrome web browser
if I open up my developer tools from
chrome excuse me and and try and execute
this this process here where I delete
something even Chrome developer tools
doesn't tell me anything it's like the
whole page is kind of flashes
and reloads and goes away and so the
first thing I need to do is figure out
like was even going on so I'm going to
configure chrome dev tools to persist
the log or preserve the log what this is
gonna allow it to do is it's going to be
able to tell me the things that have
happened on previous sessions even
though the page is clearing I can
maintain that the log is going to exist
after that so if I try this again
and I delete this statement notice that
the actual flow that's happening is my
application initializes by printing out
this console message I feel a ramped
coming on and then we we trigger an
error or an error is occurs this cannot
read property destroy of undefined and
immediately after that we navigate to a
new page and so it's that navigation
event that's causing out our page to
flash so how do we how do we identify
that well so rather than looking at the
error we can trace the user interaction
to try and understand what is the bits
of JavaScript that might be running that
responds to those user interactions and
so I'm going to use the elements panel
here of chrome dev tools which allows us
to explore the HTML markup of a page I
imagine many of you have used this it's
very useful when you're like styling a
page you're trying to put together
elements but it also has some really
powerful tools for identifying
JavaScript so I'm going to grab the
little selector tool and what this lets
me do is it lets me mouse over all these
different elements and identify them in
the markup and I want to look for the
button here's our button you can see on
the Left we have the button it's a class
got some stuff on it you've probably
seen this screen as you've done CSS work
one of the one of the things that a lot
of people have not seen though is that
there's this event listener tab and what
event listeners lets us do is it lets us
see all of the bits of JavaScript the
care about this bit of markup tell me
all of the bits of JavaScript that are
listening for events here and there's a
ton of JavaScript listening for events
look there's a JavaScript looking for
blur click error pop state submit
unhandled rejection there's JavaScript
listen to
all of these things on your page on this
element right now and so going back to
our bug our bug is that when the user
clicks delete it doesn't do anything it
just reloads and so the event that I
think we want to trace here is the click
and so now I can see all the different
bits of of JavaScript that are listening
for this event know there's three bits
here there's this thing called rant
ListView which I recognize as part of my
code and then I have these two other
things which is just like a third party
script or a utility library like the
like jQuery or angular knockout or
whatever you might be using one of the
things you'll often run into building
JavaScript apps is that you'll be
relying on libraries that abstract a lot
of this interaction for you like if
you're using jQuery you probably don't
often interact with elements directly
you interact with jQuery proxies of
elements or angular proxies of elements
or react proxies of elements what the
this chrome thing lets us do is it has
this checkbox that knows how to look
through those frameworks and understand
what are the actual bits of your code
that are really doing the listening if I
don't turn that on I don't see any of my
code here I just see my frameworks but
if I activate this I'm able to look
through it and see the actual bits of my
code that I likely care about so I can
navigate from here and take a look at
its the rant ListView here's the bit of
code the chrome identified as listening
to the element is this big enough for
everybody to see can you see in the back
can you see the code right here good so
here we see a jQuery style event
listener we're saying hey we have some
elements and we're gonna use the jQuery
esque syntax of on click so we're gonna
listen for a click event and that
function is going to do some stuff this
is what's called an event delegation
pattern where you might listen to an
event at a higher level element than
what you actually care about and then
you filter events to see whether or not
it matches so in this case we're seeing
hey tell me when anything gets clicked
on and if the thing that got clicked on
event that target
if it looks like jst eat in the CSS
class or style syntax then we want to
delete so this ranch presumably but if
we go back and take a look at the
elements in question back on our events
panel here we see that it does indeed
have the class J s delete but where is
this button in the context of the
overall page this is a button inside of
a form what happens when you click on a
button inside of a form if you didn't
have any JavaScript it submits right the
button is treated as a submit the form
submits the form doesn't have any
decoration so the default would be to
just do a get back on the current page
and it would reload so even though we
have JavaScript trying to grab a hold of
this element we haven't stopped the
browsers native behavior from continuing
so what we need to do is we need to tell
the browser to not do its native
behavior before we finish our
interception so here I'm going to just
edit this file if you're not like that
might have been magic I can just open
this Chrome thing just edit it check it
out just event dot prevent defaults is
what I want to do an event that prevent
default allows us to stop the browser
from doing that default piece of piece
of behavior but I just edited this file
just straight up inline well what this
allows us to do is a tool in in chrome
called workspaces workspaces allows me
to add the JavaScript source code that
I'm hosting here on my machine and
connect it to the how its presented
through a web server and so I have a the
actual source code of get Rancher here
locally and so by linking these two
things up I'm able to make these
modifications I'm not gonna walk through
that right now but the term is chrome
workspaces and there's really detailed
documentation on how to connect those so
I added event.preventdefault
and so that should stop that that reload
part of our bug so with that in place
let's reload the page and see if we can
still what the state of our bug is now
so we've reloaded and let's have let's
have our user Donald try and delete
something out of his timeline again
unless it didn't work at all hope it
didn't save my changes I have to file
system resource prevent default good all
right so now when we try and delete
something out of our timeline here
notice we still have the error we
haven't actually fixed the root error
but what we have fixed is that it is no
longer reloading the page and so now I'm
able to actually see the error without
having to do this pesky preserve log and
see what's happening in previous
sessions so if I turn that back off I'm
now getting this error all right so
let's now try to address this so here is
an error the Chrome has detected that we
have this globally unhandled air and
it's padded into the console and the
error is cannot read property destroy of
undefined and so if we break that down
what that means is that we have some
some object where we think that there is
a property destroy on that object and we
think that object is a thing we think
it's it's it's some real thing that we
can interact with but in reality it's
undefined so if we look at where this is
pointing to us we get we get a whole
stack trace of what was executing at the
time but one of the things that is
really remarkable about Chrome and it's
on by default now you used to have to
know where the magic check box was to
turn it on is that the stack traces that
they give you now include these
asynchronous boundaries how many people
have ever looked at async stack traces
in chrome anybody alright so so much
JavaScript that we all write isn't about
writing code that's going to execute now
it's about giving code to the browser to
execute later when something happens and
what I mean by that is we set up code to
respond to user acts
we write code to say hey when the user
clicks on this button do something or
when the remote server comes back with
our network request process it like this
or after this timer expires do this so
much of the code isn't about synchronous
operations it's about asynchronous
operations and up until recently it was
really hard to understand how did that
actually apply to our code because a
normal stack trace in JavaScript would
have told us that hey something blew up
on rant ListView J s line 34 and that's
all we really know we have some other
goo code some some stuff from our
third-party wrappers but nothing else
we don't really know any context about
how did we get to rant ListView J s line
34 how do I trace that back to the entry
point of my application and what the
async stack traces let us do is trace
those asynchronous boundaries back it
tells us that we landed on rant ListView
J s line 34 through a call to set
timeout and set timeout was called from
line 33 which was called from line 22
and so it's able to trace it farther
back into the code to understand its
entry points if we interact with this
and go back to rant lists UJ s line 22
we see here is that same call that we
manipulated earlier this call to on
delete so if we take a look at the
actual line of the error we fall into
that function on delete that was getting
called and an on delete we call a set
timeout obviou presumably there's some
reason that that exists and then we do
two things we do this stop model dot
destroy and this dot remove now what
those do isn't necessarily important but
for whatever reason we're trying to call
destroy on something that ends up being
undefined so we think we have this
object called model but in reality it's
it's not there some of you might have
already spotted what this error is
because it is the most common error in
JavaScript land and this is a
misunderstanding of what the value of
this is
going to be we've lost our context when
we've passed this function in to set
time out we think the value of this is
this is is whatever this rant listview
object is that we're working with but in
reality we've passed this function to
the browser to execute later and when
later arrives it doesn't know what this
should be anymore
and so this ends up being something else
we can attach a break point to actually
understand what the value of this would
be here's another new thing that landed
in the latest chrome check this out
you've probably seen that you can add
breakpoints to code and all that sort of
stuff just like any other IDE but now it
can evaluate each expression
independently and you can put
breakpoints within a given line how
awesome is that I can put a breakpoint
only when we try and like identify
destroy and not when we try and identify
this dot model that's pretty cool anyway
so we're gonna put that breakpoint in
place and let's try and execute our our
process here again and here we land on
our code and we can see what do we think
this these values are if we just mouse
over our values that's going to give us
a pop-up of what they are this is window
and window probably doesn't have a thing
on it called model so when we're trying
to call destroy we're trying to call
destroy on an object that ends up being
undefined so there's a bunch of
different ways we could fix this the
problem here is that we lost the context
of this so the simplest most highly
compatible way of fixing this would be
to save what you want the value of this
to be into your own into your own
variable which depending on which
JavaScript book you probably read first
you would either call that variable that
equals this or you might call it self
doesn't really matter which one you pick
they do the same thing so then when you
have that value saved you can then
reference it farther down the closure
where you have more control over the
lifetime of those variables so with that
in place
we try and delete something again and it
works great there's no errors now that
is a highly compatible old way of doing
it but we all want to be new cool super
hip JavaScript developers using the
latest technologies right and so instead
of doing it this way there's a couple of
other ways we could solve this problem
the first is that in most browsers ie 10
and newer we have this concept called
dot bind on functions and using dot bind
we can glue what we want the value of
this to be when it runs later so I can
glue the value of this from the outer
scope into what I want the value of this
to be in the inner scope this particular
call to adopt bind this will execute
before set timeout is called I'm
declaring a new function I'm binding its
value to this so that when set timeout
calls the value of this is still what it
used to be let's just prove that that
works and I can delete America is great
again now there's one other way we can
do this this even cooler new or even
hipper than then bind this and that is
rather than using bind we can use a
different kind of function so rather
than declaring a function literal here
and just using the keyword function I
can use a fat arrow function and what
these arrow functions let me do is it
lets me have a shortcut syntax for
defining of the function and they have a
series of constraints the first
constraint is that the value of this is
automatically and irrevocably bound to
the value of this of the outer scope you
cannot manipulate the value of this but
it's probably what you want it to be
anyway the second constraint is that it
doesn't have an arguments property which
is one of the fancy questions in the
JavaScript quiz that we have up at our
booth so with this in place which would
only work in edge I think in Chrome's we
can do
time out with a fat arrow function and
we can still delete these things all day
long so long as we run it in a new cool
modern browser okay so with this in
place I believe we have fixed our first
bug Donald can come in here and he can
delete statements out of his time line
all day long and they are gone forever
BAM we squashed this bug this was a
logical bug and it had two steps in it
first we were using javascript to take
over a normal or a default piece of
behavior from the browser that of
clicking a button inside of a form and
we were trying to intercept that
behavior and do something else with it
but we weren't actually stopping the
browser from doing its native behavior
the second thing is the most common
JavaScript bug that you shouldn't feel
bad when you make because I make it all
the time too is that we lost what our
functional context is we misunderstand
what the value of this would be at
runtime and we looked at Keystone users
which is something I highly recommend
you build into your designs looking at
the Dom inspector as a way to trace code
based on what elements the users are
interacting with and playing with async
call stacks so here's our second bug and
our second bug came in from a user and a
user had this problem where I have this
cool feature and get ranter where a user
can come in and they can type in a long
rant they can really get up you know up
all angry about whatever is happening in
their life and they can type a lot of
text and then if they're not quite ready
that you know they want a wordsmith a
little bit more they can come back to
get Rancher later and I'll remember what
they had written in like a draft phase
but the problem is here that the rant
text still gets remembered as a draft
even if they delete it which led to some
embarrassing situations I imagine so
let's see if we can recreate and squash
this bug so here let's continue using
our Keystone user and let's type
something that we're gonna try and
delete let's cite let's try and get into
the head of our users and type something
that is obviously untrue and scandalous
something like
in DC Sydney is the worst conference
ever fake News CNN sucks and then let's
say you know what that's that's probably
not true let's delete that and pretend
it never happened
but when Donald comes back later and
reloads the page there it is again
it's still remembered in that draft
phase and pops right back up again so in
order to figure out what's going on here
let's use the same kind of techniques
that we used for the last one we're
gonna use the element inspector and look
at that text area to see what are the
bits of JavaScript that care about that
so we can trace the interaction that way
so if we look at this text area and we
look at the event listeners that are
listening to it we see a blur a click
and error a key up a pop state cement an
unhandled rejection based on what this
bug is this bug is based on is a
interaction with text I think the most
likely candidate here is that we want to
take a look at KeyUp which would be bits
of JavaScript that are reacting every
time the user hits a key and so we have
one bit of code that I recognize here
this add rant view j/s and so if we go
into that we can see what is our code
here that is actually running can't zoom
it any farther so here we have a
function called on change an on change
it's taking an event so the event of a
key up and when that key up comes in
we're trying to create a text variable
which is probably trying to pull the
value off of that form field now
JavaScript and browsers can really suck
sometimes sometimes things that we
expect to be there like an event target
aren't always there sometimes a browser
might not reveal that and so here we
have a bit of shortcut JavaScript code
that you might have interacted with or
used at some point where I'm saying hey
I want to get something off of event
target but
vente target isn't there I don't want to
blow up with an error like unable to
read value on proper or a property value
on undefined
I want to guarantee that event dot
target is a thing so event that target
is a thing or I want to create an empty
object so that I can pull a value on it
off of it without necessarily having the
whole thing blow up
so if text then is a thing if I have
some piece of valid text I don't have
undefined or null or some other garbage
then I want to put it in local storage
local storage is one of a handful of
ways we have in the browser to persist
data in the browser itself without
sending it to a server you can interact
with those values that you might have
put in local storage through the
application tab of chrome dev tools the
application tab lists all of these
different ways you can store data local
storage session storage index DB web
sequel and cookies and you can interact
with it so here in my local storage I
see that I have this particular value
this this heinous rant that we have in
our in our draft state in this key next
rant and I can see nd Sydney is the
worst conference ever and I could go in
here and I could manipulate that if I so
chose so let's um let's play with this a
little bit let's see this in action so
I'm gonna add a breakpoint here on line
13 and and as I interact with this it's
going to go in here and so will drop in
here we'll say hey we have a vent and we
have a vent target event that target is
a is a truth eval you and it's a it's a
thing and so we're able to pull value
off of it and so as we step through the
value of text will be that value and it
passes that condition and we get set in
local storage but so what's going to
happen here if we clear out the value of
that text area if we clear out the value
of that text area what will text be
it's going to be an empty string right
we're going to if we zero this out if we
zero this out I got to do this without
actually triggering a key up which I
never can I can't actually even do it if
we trigger this without it or if we
trigger this with an empty string or
with by clearing it out the value of
text is going to be empty string what
happens when we put empty string into a
condition it's false this is a problem
of truthy and falsy values all objects
all things in JavaScript can be coerced
down into a boolean value into either
true or false there's a handful of
values that will become false these are
called the false e values they include
hold on this is my quiz false which is
the one I always forget false becomes
false empty string becomes false
undefined null not a number zero and one
obscure one called document dot all
which is neither here nor there I'm just
showing off document dot all is
available in older browsers and some
like a way of checking to see if it's an
old crappy browser to see a document dot
all is a thing all right so text is this
condition here if we pop an empty string
into it it's going to evaluate to false
which means we won't execute it and
local storage never gets updated so this
condition is meant to you know prevent
invalid values like undefined from
creeping into our our storage we don't
want to actually ever store undefined
because then we'd get the word undefined
showing up in our text area but we're
being a little too zealous or we're
being too vague about this here we're
preventing undefined but we're also
preventing the valid value empty string
and so rather than naively just checking
to see if text is truthy or false e
let's see if type
is a string if the type of text is any
string we probably want to save it but
if it's not a string if it's undefined
if it's null if it's zero if it's some
other garbage that's creeped in there
somehow
then we don't want to save it and so
with that in place we can come back in
here and we can delete this this heinous
rant and when we reload the page it is
still gone and if we just double check
our application tab we see that next
rant contains the value of empty string
as well so this was another logical bug
this particular bug had to do with
truthy or false e values you often will
run into truthy and falsy nests
sometimes by design oftentimes on
accident when you put objects into
conditionals or into and or statements
and what the objects that you pump into
them will be transformed into those
truth here false e values whether or not
you plan to it or not what we looked at
was the application Explorer which lets
you interact with those sort of things
and a little bit with braking execution
and how hard it can be sometimes here's
our third bug this bug came in from our
monitoring so as you build software
there's a couple of different places you
can catch bugs hopefully you can catch
it during development where you're like
you're actively developing it and you're
like oh that's not right and you fix it
and you don't even ever think of it as a
buck you just fixed it in line if you
can't catch it there hopefully you have
somebody who is testing your stuff might
be a QA team it might be your buddy next
to you it might be your boss who knows
what it is but somebody else is looking
at you're at the end result to see if it
works that's the next best place to
catch a bug the worst place to catch a
bug is when your users find it and they
have to call and complain to you or rant
about you on Twitter about how awful
your site is because for every user who
spends the time to do that you probably
have 10 or 20 or a hundred who just
wrote you off and went to a competitor
or spent the day screwing around on
Facebook so in order to prevent that you
can monitor stuff by understand
when your production environment
actually encounters bugs you can solve
them cheaper because you don't have to
wait for your users to tell you and so
get ranter use as a monitoring tool and
so it we're seeing that our our
application is reporting lots of 500 bad
requests specifically where we've
recorded 237 times that we've had a 400
bad request to Slatter - post / api /
rants and we even know a little bit more
we know that there's a couple of
different actions that take place
immediately before this so we see that a
user comes in and they enter zero
characters into the text area rant and
then they click on the submit button and
then right after that we have an ajax
problem where we get a 400 bad request
to api rants so let's see if we can
recreate that that's a that's a good
story to tell so let's take a look at
this bug and try and kill it so here
we're still here using Donald and what
we're gonna do is we're gonna try and
recreate this bug using the same steps
so here I'm going to come in and
interact with this text area and I'm
going to enter 0 characters done and now
I'm going to hit on the submit button
I'm going to hit rant and what chrome
has told me is that we had a post to
slash API slash rants and it came back
with a HTTP code of 400 it's commonly
considered for any HP code 400 or
greater to be considered an error chrome
will consider it an error and solo mini
monitoring tools so we can use this
errors shown here in the in the console
to even understand more about it we can
pop this down and we can even see the
actual lines of code that we're
executing that leads to this call to be
made so we can see where in my
application is making this call and so I
see a bunch of goo code that I don't
necessarily care about I see some
infrastructure code tracker and jQuery
and backbone and blah blah blah what I
care about is that I have a little bit
of code here that I recognize from an ad
rant view J s line 27 now I can also
find out a bunch of em for
about this request from the network tab
the network tab shows all of the
different requests that are made about
for your application scripts and
documents and images and CSS and dynamic
stuff and everything is in here this
page becomes far more valuable when you
turn on the filter which is this little
filter icon right here which lets you
find the requests that you're probably
looking for I can trace through and try
and find that same thing that we're
talking about by just typing in the
partial URL slash
API slash rants and here it'll show me
all the different requests made to that
you'll even highlight this one here that
we thought was a failure and we can go
in and we can see all kinds of
information about it
what kind of the request and response
headers that went through what was sent
up to the server all of that I can even
see here that what was sent to the
server is here at the bottom this
request payload where we sent a object
literal that has a property text with
empty string which I think actually
makes sense based on what we did we
entered 0 characters and submitted it so
it sent 0 characters but our API is
pretty good about error messaging and so
it returns something to us as well it
said hey you cannot send me empty text
our API was smart enough to do its own
validation and say this is an invalid
request and I'm not going to take it and
it spat it back to us with a good enough
message that we can react to it so let's
go back to our code and see if we can
find a way to handle this so back in our
console where we have this whole
traceability of what was our code that
was running at the time I'm gonna go in
here and to add rant view jeaious line
27 and see this is the last line of my
code that was running before an ajax
event started somewhere in the
infrastructure bowels of my app the
action of this dot collection dot create
will issue an ajax request so if i trace
back on what's going on in this function
here we have another event response
called on submit an on submit takes an
event and we prevent its default
behavior
and then we build that object literal
that rant object with one property
called text that we just pull off of the
forum and then we do things with it we
trigger an analytics event we create it
in a collection and then we zero it back
out but what we haven't addressed here
is that what if the rant text value is
invalid what happens if we're not
allowed to send that because the server
has already told us that it cannot be
empty so what I think that we want to do
is we want to wrap these actions in a
condition that we only want to do these
things if it's valid how do we know it's
valid well we need to know that rant dot
text is not empty so first we probably
want to know that it's a truth eval you
any truth eval you but we also want to
know it's a string because we can't we
should probably send up numbers or
undefined type so that sort of thing
either so I want to know that rant dot
text is a thing it is a truth eval you
and the type of rant dot text is a
string I think if both of those things
are true we are okay to send this value
up so if we save this and try and send
again
so I'm clicking and we're not getting
any for hundreds anymore but the problem
here is is that this is a really crappy
user experience based on my air
monitoring I know that 230 some people
have done this and they didn't see any
interaction and I recorded errors now
I'm not recording errors anymore but
it's still a crappy user interaction the
user is still trying to do something and
our app is preventing it and we're not
telling them why so should probably do
some client-side error messaging of some
kind now we could write that in our
JavaScript here where we were playing
with before an else condition that would
show an error message or whatever or we
can just rely on the browser's itself to
do it so this is a pretty standard form
that's just doing a submit action so
what we can do is we could just
manipulate the form itself to add our
own validation rules so here's the form
on our HTML form specifically here is
the text area in here's the text area in
question so we have this text area named
rant and here's where where the user
puts stuff in and now I know that this
this particular value has some
constraints specifically that it is
required most text controls have or all
the text areas are all the all the form
controls have the required attribute and
there's more complicated attributes that
are available in news newer browsers
this is going to let you add like
regular expression validation or certain
other kinds of formats so that you can
add form validation directly to your
apps without writing all of that
complicated messy error messaging code
that ends up being far harder than we
ever expect it to be when we embark on
that phase of projects and so with that
in place when we try and do this now
Chrome itself will tell us error
messaging that that this is required now
it's probably not the best user
experience in the world it doesn't
integrate with the look and feel of get
ranter I should probably make some sort
of other ranting joke in response to it
but it's good enough for now and it was
really fast to implement
so here was a date above which is very
common in most web applications you were
sooner or later you are going to be
gathering data from a server or pushing
data to a server and you're gonna need
to do data validation your API should
always validate data regardless of what
the clients do because that is the
actual source of truth of your systems
and people can exploit your api's and
send garbage data through other ways
than your UI so your API is always
should protect it but your clients I
should probably protect it as well so
that you provide a good user experience
and good indications back to your users
on what you expect from them as part of
this we looked at the network inspector
we looked at response previews and we
played more with the JavaScript debugger
this is my favorite one here is a bug
that our developers have found now our
developers spend all day every day and
get ranter they're playing with it
they're developing on it they're renting
their own things in it and what they
found is after they've been using get
ranter for a couple hours
fans on their laptops just start
screaming and they can't like the
browser tabs start crashing and then
they look at the memory utilization of
their PC and like Chrome that chrome tab
is taking up 16 gigs of memory to render
their rant time lines and so that sounds
a lot like a memory bug a memory leak
and so let's see if we can diagnose
whether there's some memory leaks in get
ranter let's see if we can crush this
bug so here and get rancher there are or
here in chrome there's a couple of
different tools that have been falling a
lot recently
to understand where is our application
using memory how many of you thought hey
this is JavaScript in the web I don't
have to worry about memory management
that's stupid yeah I thought that too
and then I wrote but I wrote JavaScript
apps that had tons of memory leaks in it
because I didn't think I had to deal
with any of it you do it's a big deal so
much of the wet like how many of you
have been to a website that you were now
reasonably confident has some crazy
memory leaks
yeah so here's some ways that we can
figure it out
the first tool that I like to use is now
here under the memory tab it used to be
called something else I don't remember
what used to be called but it was very
cryptic I think it was like profiling or
something like that which didn't give
you any good name about what it actually
did so I'm very happy that now they call
it memory and so in here what this lets
us do is it lets us take different
snapshots about what's going on in our
application what we want specifically we
want to do is this last option here this
record allocation timeline this even
tells you exactly what it's for use this
profile type to isolate memory leaks
what this is going to do is it's going
to tell us whether or not our app has a
memory leak it's not so good at telling
us where the memory leak is but so let's
run it and see what we get here so I'm
just going to hit record and I'm gonna
let this run for a little while so it
starts recording what is the action
happening in the background of my
application and what this looks like is
we have a timeline of activity happening
you see the current time moving across
is this gray bar and occasionally you
see a pop up of another bar shoot up now
that bar is our application requesting
memory from the operating system it's
saying hey I need some new memory in
fact it's asking for about a hundred K
of memory every 10 seconds or so now the
other thing you'll see is that the bar
drops from being entirely blue to maybe
half blue what that means is that the
gray part has been returned to the
operating system we said all right we're
done with this memory garbage collector
you can grab it and destroy it but if
it's still blue that means we're still
holding on to the memory we still have
something in our app that's pointing to
it and so the garbage collector can't do
it and so we can see this pattern
emerging of every 10 seconds we grab
100k more of memory but we never
completely free the previous fact we're
holding on to between 50 and 80 K every
10 seconds over and over and over again
and that will eventually start adding up
to real amounts of memory and cause all
kinds of problems if we stop this
allocation we can see a whole bunch of
information about what it actually
captured that doesn't mean anything at
all to me if you understand very low
level stuff about about the JavaScript
garbage collector you can go in here and
you can say here's the actual closures
and arrays and stuff that was amassing
these bits of memory but it's very hard
to navigate through this and understand
what these objects actually are so that
you understand how to fix this
fortunately there's another option we
have what this kind of memory profile
tells us is that there is a memory leak
we're continuing to allocate memory but
it's not so good at telling us where it
is
so and understand where it is we can use
a different tool here under performance
now what performance lets us do is it
lets us profile different kinds of
things over time like memory utilization
what are the actual bits of our code
that are allocating memory and so I'm
gonna run this here as well and I'm
gonna see if I can identify that same
pattern that we are seeing in our memory
allocation what I was what we were
seeing before is that about every 10
seconds we would see something happen
that would grab a bunch of memory and
then it would let go of some of it but
it would never really let go of all of
it and so I want to let this run for at
least like 30 35 seconds so that we get
you know a good you know representative
sample of the same kind of data so
hopefully I can talk for another few
seconds until that hits about 35 and
then I'm going to stop it okay so I'm
gonna pop this out and show this full
screen because there's a lot of data
here this is this is a kind of
intimidating screen and that's okay for
you to be a little intimidated by the
screen there's a lot of data here but it
shows you a bunch of really cool data
I'm going to show you how to walk
through this so there's a couple of
different charts here that are good at
different things here at the top we have
a time line and this time line is for
the entire timing that we were
according and it shows us a bunch of
different stats that might be
interesting for your apps so for example
the top is your frames per second if
you're building like a graphically
intensive animations games other
visualizations you might care about
frames per second because if that starts
getting too low you'll get a choppy
feeling in your application you'll see
CPU utilization network traffic heap
size that sort of thing in this we're
gonna skip over the second one because
that I'll become more interesting here
in a second here we have a simplistic
view just a line chart that shows
different kinds of things and their
utilization in your app so here in blue
we see the j/s heap size in green the
number of nodes in our document so how
many HTML nodes exists in gold the
number of listeners and the reason those
are important and they're on this chart
is that nodes and listeners are a
primary cause of memory utilization the
more nodes you have and the more
listeners you have the more places
you've added to your app that are going
to retain memory every time you create a
new node and you have a pointer to it
that node continues to exist in browser
memory regardless of whether or not it's
visible so if we look at this we can
kind of see the same pattern that we are
seeing in in the allocation timeline so
up here we see a big decrease so there
was some sort of garbage collection
event where some some things got cleared
out but we see a similar pattern where
we see an increase in the number in the
J's heap the number of nodes and the
number of listeners here and then again
here and then again here and so that
same pattern will get reflected here and
so I want to zoom in on these
and so this is what's really cool about
this is where this page becomes a lot
more valuable so up here on the timeline
all of these charts are late and so as I
start zooming in on one of these things
everything else gets bigger and I can
focus more on what's actually happening
here now many years ago I used to play a
lot of video games particularly a lot of
first-person shooter video games did
anybody else anybody else do that
spent ridiculously too much time doing
that but one of the most common things
in those kind of video games were the
controls specifically the WASD keys on
the keyboard
for like moving around and this uses the
same controls which makes it super fun
so as we start wanting to like explore
this I can use W to zoom in and s to
zoom out and I can strafe left and I can
strafe right and I can just make a big
game of it and it's a lot more fun and
so what I want to do is I want to start
zooming in on this big increase to see
if I can understand more about what's
happening and so as I keep zooming in
what we'll start seeing is that line
chart isn't one increase it's lots and
lots of little increases happening in
rapid order and the other thing you
might notice is that that middle chart
that we skipped over that looked boring
and it didn't have anything in it now
that we start zooming in this has actual
information about what was the
JavaScript that was actually executing
during this particular time and look at
the scale that we're at we're like
really zoomed in we're at you know two
millisecond timings right here and so as
we continue to zoom in we'll see more
and more detail about what was happening
at this time and we can start
understanding what was the JavaScript
doing when our memory footprint
increased so I can see that around the
time of this memory increase we were
finishing an xhr load which means a
network request was finishing a network
request to slash API slash ads and we
can look down through here and figure
out here's all the different pieces of
our code that were actually involved in
this executing and a lot of this I don't
really recognize this doesn't look like
my code it looks like infrastructure
code but I have a function here called
render I've I write render functions
that that could be interesting and so
you can select the different things here
and on the the very bottom frame of this
which is frankly kind of hard to see
because I'm pretty
zoomed in on the UI right now
down here in the summary once I've
selected one of those functions I get a
bunch of metrics about it
so here I have my render function my
render function took 1.6 milliseconds to
execute and here's where it is it's an
add list view J s I think this is
related to the increase this is one
piece of my code those executing at the
time of a memory increase increase so I
think that's a strong indication that
this is one of the sources of my memory
leaks so we can pop in and use this as a
good starting place if I have a strong
piece of evidence that in this bit of
code there is a memory leak so let's
kind of walk through it so up on line 33
I see an interval getting started an
interval that executes every 10 seconds
evidence 1 we have something repeating
every 10 seconds every 10 seconds we do
this this call to collection dot fetch
and somewhere along the lines our render
function gets executed as part of that
now this render function is doing a few
things it looks like we have an HTML
element because we're calling dot inner
HTML on it and dot inner HTML is just
zeroing it out saying hey whatever was
in your HTML before it's empty string
now let's move on and then we loop over
something and render some new stuff so
we call this other function called
render add and render add creates a
thing that does something and then
sticks it into the HTML so we call
element dot prepend which is a way that
you can add new markup to an HTML
element so let's add a breakpoint here
and see if we can actually walk through
some of this and understand what's
happening so within the next 10 seconds
if our Theory's right we should break
and we can see all right what is this
dot L if we look at this dot l dot inner
HTML now here's what's in it right now
so we have div div class add add link
who's com slash gold
bathroom slash images slash add gold
bathroom sounds like one of our ads for
mr. Donald Trump so if we keep stepping
through here so it looks like we're
taking our advertisement container and
we're zeroing it out so then we'll go
through here and we'll do something
we'll render a bunch of new ads and as
we step through this we're going to
render a new ad so if we just take a
look at executing that not meant to do
any good if we will render a new ad and
then we're going to take that
advertisement presumably that we created
as a view and we're gonna stick it in
this thing called children what's in
children now is an array with 243 things
in it
there's 243 advertisement views in here
that as we look through we could see
each one of them has a whole bit of
advertising markup and an image link to
each of them and I'm holding onto all of
these because I have a pointer to all of
them here in this children array so even
though my my application here only shows
I got to stop my breakpoint here even
though my application here only shows
three advertisements I'm holding on to
memory for hundreds of advertisements
because I'm not getting rid of my old
pointers even though I've removed them
from the Dom I still have a pointer to
it and so this browser right now has
like 200 pictures of topless Putin
wandering around in it just waiting for
you to click on it and it's so sad that
nobody will ever click on it because
they're not visible anymore and so we
need to to stop that like here here we
have this leak of we're creating new ads
every 10 seconds and we're never getting
rid of the old ones and so right here on
line 39 where we are zeroing out the old
age
tml we can probably zero out the old
children too we probably don't need to
retain them anymore so right here after
it the children object is just an array
and so what is the what do you think is
the best way to like release all of the
things in the in an array a common way
to do it just be to say hey this dot
children is an empty array but that's
not the coolest way to do it the coolest
way to do it so I imagine many of you
know that you can figure out what the
length of an array is by calling the
property dot length you've built a for
loop you say hey I'm gonna loop over
this array for all of the things in it
and get the length what you might not
know is that length is settable as an I
can say this thought children dot length
is zero and it will drop everything in
the array because why wouldn't you it's
JavaScript so if we go back here we see
that before I execute this the length of
the array is 258 things and as we step
through here now the length of the array
is zero things which is the most
efficient way of actually zeroing out
array even though it's really weird to
read that we are setting the length of
an array all right so with that in place
hopefully we fixed this memory link the
only way to really tell if you fixed it
though is to go back into your memory
and run another profile so one of the
cool things about this memory profiling
tool that we talked about earlier is
that these memory profiles are
independent of the browser itself as an
I can take this snapshot and I could
save it off and put it in my file system
somewhere if you're building a big app
you could once an iteration once a
release once a court or whatever take a
memory snapshot of important workflows
in your app and save them in your
repository so that you have ideas of
when are bits of your application when
are they increasing the memory footprint
and you can get a better idea of when do
memory leaks actually creep into your
application what I'm gonna do right now
is I'm just going to run another
snapshot and see if we've made it better
which hopefully it starts going
I'm probably at a breakpoint somewhere
no there we go
I'm gonna start that over so now we're
going to run this again now we didn't
change the fundamental structure of our
application dance we didn't change the
fundamental structure of our application
so what we should still see is about
every 10 seconds a new memory allocation
happens where we render a new set of ads
but hopefully what is going to happen
here which I'm really hoping it happens
here hopefully what happens here is that
the amount of memory that we retain
subsequently starts dropping
considerably so what we can see here is
that we're still retaining some of this
blue memory it's not always going to
retain in the exact same patterns but
what we are seeing here is the amount of
memory that is actually being kept is
considerably lower than how it used to
be
we're only retaining about 10k of memory
every 10 seconds so there's probably
still a memory leak somewhere in here
and we should probably keep digging into
it to find the rest of it but we've made
a lot of progress into how how how much
impact it's going to have so this was a
memory bug and specifically it was a
memory bug caused by unreleased objects
we had bits of HTML Dom that we had
created as part of rendering our ads and
those bits of HTML consume a fair amount
of memory regardless of whether or not
they are visible so if you're building
an application that renders HTML renders
new content on the client and changes
what it is if you're creating new stuff
you're responsible for making sure it
goes away completely when you're done
with it otherwise you're just collecting
more and more markup in a page and never
really getting rid of it so we looked at
the memory profiler and the performance
timeline so I think I'm getting pretty
close on time so we got one more bug I
want to show you quickly so this is our
last bug we
is a bug that I imagine many many of you
have had reported to you over time and
this is a bug that hey sometimes my
application is slow which sucks but we
can figure out whether or not an
application is slow using some of the
things we've already looked at so we're
gonna look at the performance management
or the performance tab again but this
time rather than profiling the memory
we're just gonna take a overall look and
maybe even take a look at some
screenshots what I want to do here is
rather than profiling the page during
its operation I just want to see what
the page does at the beginning of its
load time and so I can do this this
reload button and what's going to do is
it's going to take a snapshot of my page
during its initial load and what this
captured is what are all the different
things that happen during during a load
phase during a initial page view of my
application now this isn't very long my
page loaded in like two seconds which
doesn't seem like it's that long like
what my users are complaining about a
two-second page time like what do you
want out of me like it's fine but I'm
running on a big fancy laptop on a good
network and a lot of my users are
probably going to have crappy networks
so we can simulate some of that by going
into the network and saying you know
what I want to pretend to be a user way
out in the middle of nowhere in
Australia where I don't have any
connectivity at all or really bad slowed
3G connections and so I can tell chrome
to pretend to be a crappy browser with a
bad network connection instead and so
now if I reload this with a network
throttle in place I can see this is how
long my page is going to take for real
users on certain bad networks which
takes considerably longer in fact using
some of these tools here I can see that
here's what my users would actually see
here's what my users actually see during
the low time so at one second they see a
blank page at two seconds they still see
a blank page
at three seconds they see a little bit
of my chrome at four seconds they still
haven't seen anything interesting at
five seconds they see the title of my
page at six seconds still nothing more
at eight seconds nothing at nine seconds
nothing at ten seconds nothing at 11
seconds their rant show up at 12 seconds
we start showing some advertising Chrome
and then this thing ends before we've
even shown all of the pictures so 12
seconds in them that we still haven't
loaded images and so using these tools
we can actually step-by-step go through
and say what are all of the different
things that are happening during these
page executions and I actually care
about that I care about these
I mean so what we can do is we can look
at this and we can see what are the
individual Network requests that are
taking the longest as part of building
building up this application and I don't
know where that went
so what this paint what this is telling
us is that our page on bad networks is
taking a really really long time and we
can look and see all the different
things that are happening that might
cause that and so if we look at what
those things are we can time out all the
different calls that are being there
taking place in order to build the page
and which are the ones that are the big
tents in the in the totem pole here and
so if we look at these individual times
we can say hey at the beginning of our
page here's all the different calls
being made and how long they're taking
and so we got some real long ones we
have look at all these different things
we're pulling in a CSS file and then a
whole bunch of individual bits of
JavaScript are all coming in like we're
not bundling the JavaScript together
we're not minifying it we're not doing
anything to actually reduce that and so
there's a ton of performance
improvements we can use what the
performance page can use when you do
this is it'll show you that the big
things in your application they're
causing the worst performance lags and
so you can focus on the biggest wins to
improve the performance of your page
there's a whole much more that we could
talk about with that but unfortunately
I'm running out of time so this was a
performance bug what I want to show you
is that all of the stuff that we talked
about today is actually available in a
full day workshop form with like 10 more
bugs relying on you to help me like
debug them together you can find this
out on a service called front-end
masters which is like an online training
head log for front-end stuff there's a
ton of other great catalogs out there of
course is my course is called debugging
juror squashing JavaScript bugs we used
a little service that I build called
Trek jeaious as part of a little bit of
stuff I talked earlier about monitoring
and knowing you know it's a less
expensive way of finding out when you
let bugs creep into production truck JS
tells you all kinds of awesome stuff
about how bugs came into your sis
what were all the events in the changes
that would have led to it for example
our bug about the 400 truck Jess can
tell you things like hey this happens
when the user enters zero characters and
types and pushes a button that's the
sort of information that we can provide
if you want to play with that that's out
at trackjs.com
or we have a lounge upstairs where you
can come talk to me and I'll do a full
demo for you and this was squashing
JavaScript bugs I hope it was fun I hope
you've learned a few things about chrome
and fixing things and how to approach
bugs and I'd be happy to chat with you
more afterwards otherwise enjoy lunch
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>