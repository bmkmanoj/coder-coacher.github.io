<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ASP.NET Core Deep(er) Dive - Damian Edwards | Coder Coacher - Coaching Coders</title><meta content="ASP.NET Core Deep(er) Dive - Damian Edwards - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ASP.NET Core Deep(er) Dive - Damian Edwards</b></h2><h5 class="post__date">2016-08-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NSjYQmu1u_k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">still got some people trickling in so
I'll give
ten seconds we'll watch them run nine
eight seven six man on the door is
itching to close by the looks of it all
right welcome everybody I am back in
Australia for a very brief amount of
time to come and talk to you good folks
about a swing at core anyone here who
was in the workshop the last two days a
couple of hands good I had a good fun
teaching a spinet core introduction
workshop last two days we've been doing
that at the various NDC conferences we
did it a couple more places in the US as
well but today we're gonna go down just
another layer deeper so it's called a
scenic or deep dive my name is Damien
Edwards my twitter handle is at Damien
Edwards if you want to ask me questions
I'll talk to me in the future or berate
me or whatever it is for today's deeper
dive what I decided to do was often when
we do an overview of a spinet call we
kind of run through a very high-level
sort of overview of all the various
subsystems that we introduced an
ethernet cord because there's a lot of
new api we kind of reinvented a lot of
the basic primitives in configuration
and logging and dependency injection and
startup code and middleware and then in
routing and MVC on top of that and then
razor has a whole bunch of new stuff so
today I wanted to kind of go to the next
level down rather than picking one thing
and diving really really deep which can
be great for a geek out but perhaps not
as potentially useful to you in your day
to day jobs today what I'm going to try
and do is I picked sort of five or six
areas that I would choose to go to one
one or two layers deep in them perhaps
you've seen in the past to help you get
a better understanding of how it works
or in some cases to show you some API
that perhaps you hadn't come across yet
you hadn't seen this talk about yet or
maybe you saw it in the template you
didn't really understand how it worked
or maybe it's in the templating you
haven't even noticed it's there so
without further ado whoo I've only got
about you know 57 minutes now so let's
see if we can't dive through as much of
these as possible I'm gonna try and
leave a little time at the end for
questions too hopefully we'll see how
long I ramble for but there will be a
mark at the end so we can
do some questions at the end so the
first thing I want to talk about is
dotnet core ASP net core donate
framework portable app standalone apps
these are terms you might have heard
before some of them maybe not all of
them and how these things compare to
each other so if I do a new ASP net
application and I'll choose but if I go
back to the previous screen the first
thing you'll note is when I choose a new
a spinet core application from visual
studio there's a couple of templates
here that look very very similar and you
have to kind of squint and look a few
times to see the difference so I've got
a spoon 8 core web application for
dotnet core and then I've got a spoon 8
core web application for dotnet
framework so one of the big things of a
Smet core is that it will work on dotnet
call or dotnet framework okay it works
on the core CLR with core effects which
is what gives you cross plats and gives
you side-by-side frameworks and the
ability to deploy the framework inside
the application but it also works on the
dotnet framework that you know and love
in fact we've released a new version of
it this morning donate four point six
point two hit the wire this morning with
a few new features but Dante framework
has done the framework right it installs
in Windows you can only have one version
machine at a time cetera cetera but it
has a lot more API in every DLL that
you've ever used in net will pretty much
load on dotnet framework as opposed to
dot that call so what is the difference
here well let's start out with dotnet
core because even if we choose dotnet
core a couple of things there are a
couple of differences even just within
the scope of dotnet core itself let's
just we'll forget about done there
framework for a minute we'll come back
to that in a very short period of time
so when I run one of these applications
we will wait for my vs to restore
packages I was told the internet was
really good in him
I'm gonna run this application and we'll
start process explorer know it is there
don't lie to me
I'll just do it manually okay so we'll
pin this over here in this over here so
my Aspen air core application is running
and over here on the left hand side if I
scroll all the way down when I run from
Visual Studio we're gonna see a whole
bunch of stuff going on so here's dev
MXC goes through this thing called well
we don't care about that where I really
care about is dotnet XE so here it is
here's dotnet but XE running that's not
the instance I particularly care about
though I'm gonna find there it is the
one with ice express underneath it oh
it's jumping around don't you there so
Debbie empty XE which is what I just
launched this instance of dotnet XE is
if I hover over it you can see the
command-line arguments it's saying
project model - server okay so that's a
special instance of net XE that drives
the intellisense via dotnet project so
that's not the one we're interested in
right now what I'm interested is this
one all the way down here this is the
one actually running my application you
can see the arguments being passed to
here include a dll name which is the
name of my application but above that
we'll see a couple of other executables
that were launched before it so I can
see is Express because I'm running on
ice Express at the moment that's
expressed then launches this special
thing called the vs is XE launcher which
we'll talk about in just a minute and
then finally it launches net dot XE
pointing at my assembly now if you've
ever used this from the command line you
will know that there's a command called
net run right and so I can do the same
thing rather than doing it from vs I
could go to this location on disk
wherever it might be
I can bring up in your console window in
just this lovely long path right here
and I should be able to write dotnet run
maximize that so we can see it oh and it
fails probably because I still have the
process running so it can't build it so
exit that let's do it again okay so what
did dotnet run do as opposed to what vs
was doing well dotnet run checks the
source of my project in this case a
bunch of C
files it decides that it has to compile
it because it can't find some some
outputs in this case all it's changed is
the previous compilation and then it
goes off and starts dotnet XE for me
which is the host of net core and points
it at my application well where did it
compile to now none of this is
particularly different to where you
might have done it in the past but given
the history that we went through with a
spinet 5 and then a spinet core and D
and X and then to.net core a lot of this
stuff did change along the way so if you
haven't looked in the past or perhaps
you looked in the beta NR C one time
frame and you haven't looked since some
of this may be new to you so this is
very similar to how things used to work
now ok so inside my project underneath
the bin folder I have debug I have a
folder now for this thing called net
core app 100 which I'll talk about in
just a minute and then inside this
folder here's my actual DLL so yes when
you dotnet run you're still compiling
the application it does it for you
behind the scenes it's not magically
using Rozlyn to do things in memory like
we try to do in D and X it actually
ended up causing a bunch of problems and
so we're back to sort of doing things
the traditional way but the dotnet run
command takes care of figuring out
whether you need to recompile before you
go off and run the application again ok
so you still get that nice experience if
you're at the command line of make it
changed on that run then go off and run
the application if necessary but where's
the rest of dotnet so I mean you can see
here the only thing in my output folder
is my application right if I was to do
this in an MVC 5 application there'd be
a whole bunch more dll's in here
specifically there'd be all the dll's
from the NuGet packages that are
referenced and I can see some heads
nodding going yeah I kind of expected to
see a lot more things in here well
that's because the dotnet XE the dotnet
core host has the ability to load
assemblies from your new gate location
ok so when you're doing development like
this you don't have to copy all those
binaries from the new gate location into
the output location and all that
information is is stored inside these
special JSON files so I if I open this
Jason follow up these are JSON files
that are read essentially by the CLR
host ok they're read by the native code
that boots the.net core C
and then tells it which assemblies to
load and so inside here you can see
already right here's a bunch of stuff
down here about dependent dependencies
on my application and if I search for
DLL you can see my DLL which is all good
and well but you can see we're starting
to see other dll's in here net standard
1.3 microsoft face banette called or
anti forgery so these are the dll's from
my new gate location which are being
loaded by dotnet core when i run my
application now this is just during
development though this is just my bin
folder okay this is not what happens
when I publish my application what
happens when I publish my application so
if I go back to the command line and I
publish this app and it doesn't like oh
that's interesting apparently I haven't
installed bear on this machine and we'll
all wait while NPM runs at least it has
this nice ASCII our progress bar now
while it's doing that I'm gonna change
my font settings here see if I can't fit
everything on the one screen at the same
time it's a little bit better and I'm
gonna get impatient here so I might have
to go back to vs and let it do it for me
let's have a look come on come on come
on come on on two three okay let's see
if we can do this the old-fashioned way
to the disk please and I will go to this
folder that's perfectly fine I am going
to choose net core app because it's the
only one I'm compiling for and I'm gonna
go ahead and hit publish
we'll see if vs beats my command line
and if I can cause some type of race
condition now where is command lines
winning command lines win command line
one no that's pretty sad isn't it
alright so I published my application
now let's go and have a look at the
published output so by default because I
didn't give it a publish location it
shoves it in a subfolder of the bin
folder called publish and if we look
inside this folder we're going to see
quite a lot more fun
else than I saw before when I compiled
the application okay so the difference
between dotnet build or you know
building a visual studio or dotnet run
which calls don't have build for you and
don't know publish is that publish is
creating this isn't fully standalone yet
this is what we call a portable dotnet
core application this is one that I can
take the publish output move it to
another machine that has the dotnet core
SDK or the.net core runtime installed I
have to have done it XE on that machine
and then I can run it okay because it
has all of its new get dependencies
copied in to its bin folder it's quite a
lot bigger as you can possibly imagine
now there are some other interesting
files in here too there's this refs
folder there's anyone seen this and they
publish output and wonder what this was
yeah so this is to allow MVC to do
runtime discovery and compilation for
you so think about how MVC works right
you compile your controllers and your
c-sharp code up front and then you build
your application you publish it and then
when your application starts MVC has to
go right I need to find controllers and
in order to find constructive
controllers in a spinet core what it
does it says load me all the assemblies
that are in the application and find all
the types that reference MVC and then of
those types find the ones that look like
controllers now in order to do that type
of stuff at runtime you need to maintain
a bunch of the information that you had
at compile time
okay remembers two distinct phases here
compiling and then what happens at
runtime
secondly MVC has razor and razor CS HTML
files get compiled on the server they
don't get compiled when you do ctrl
shift B in Visual Studio or dotnet build
they get compiled when your application
starts and for razor to have access to
the same api's or your views have access
to the same API is that your c-sharp
code does we need all those same
reference assemblies those same API is
available when we invoke the compiler
when the server starts so that's what
this rest folder does and that is
controlled by this new property that you
may have seen in project Jason if I go
to the build options section down here
this preserve compilation context that's
what that does that preserves all the
information to do with
your application into the output of the
application so you can do more
compilation when your application starts
okay you can do raiser compilation now
incidentally for those wondering where
razor precompilation went we're working
on it right now it's going to ship in
1.1 ok and the advantage of that is you
don't have to pay the cost of compiling
your views when the application starts
which means your application starts up
that little bit quicker ok so this
application is portable that's what I
call it a dotnet called portable
application well how does that work
exactly
I am seeing a bunch of stuff from new
get in here Microsoft HP net core
Microsoft extensions I am not seeing
very many system dot dll's in fact I'm
only seeing what 8 or 9 of them here so
where are the rest of those dll's where
is the framework where's dotnet core
well it's not in my application yet it's
over on my hard drive in Program Files
slash net so over in Program Files slash
net there's net XE that's what I've been
running at the command-line that's what
Visual Studio is launching it's a very
small native application how big is it I
think it's only like 200 400 K or
something like that
124 km or than I thought ok and then the
actual runtime is in this special folder
called shared I don't know why it's
called shared it's called shared because
it gets shared amongst multiple apps I
guess so this might be a string that
you're familiar with will show you where
that is in a minute Microsoft net
quarter app inside there we have
versions so here already is one of the
big differences between dotnet framework
and the dotnet core framework because
this is kind of like a mini dotnet
framework right is that I can have very
easily have multiple versions of them
side-by-side if we think about where
dotnet framework is on your machine
where's the dotnet framework anyone know
Windows microsoft.net right framework
framework 64 these are the only
side-by-side versions I have right and
that represents 15 years of releases and
so they're not really that side by side
because when did this one come out 2010
so we haven't had a side-by-side release
since 2010 ok so that's a really big
difference obviously between how dotnet
core works
and how dotnet framework works and then
inside this dotnet core framework now I
have a bunch of dll's okay
there's no gak there's no other location
this is where the dotnet core framework
is and you can see in here and some
pretty telltale signs
I saw a Miss call lib flash by there it
is okay but we also have some other
things in here look at this there's
libuv okay that's the native library
that a spoon Air Corps uses specifically
the Kestrel server in order to do
cross-platform asynchronous IO and
networking so we have things beyond just
the typical dotnet stuff inside this
shared folder and why is that
interesting well if I can look at the
size of this folder this is 17 megabytes
okay and this is platform-specific this
isn't just managed code there's native
code in here as well this is dotnet core
for Windows specifically for Windows 10
x64 okay because once you get out of the
world of managed programming you have to
start thinking about what processor
architecture am I on what operating
system are my on and it's not as simple
as I am I on linux
for example now that we support
cross-platform if you're on Ubuntu
Ubuntu 14 is different to a bun to 16
okay you can't just take something that
was compiled from 1 to 14 and run it on
a bun to 16 it might work but a lot of
the time it doesn't they treated as
distinct platforms Windows is fairly
unique in its ability to say I have
something that was compiled for Windows
95 now just run it on Windows 10 ok it's
actually pretty amazing that they make
that work in the Linux world that's
typically not how things work so I have
this nice copy of the dotnet core
portable shared stuff on my machine
which is what enables my application to
have a lot less stuff in its output ok
now you can still get the benefit of
side by side versions you can see I have
both rc2 and the final 100 here I mean
101 comes out on 102 and 1.1 and 1.2 I
can have those side by side in here and
applications can choose which version of
the.net core runtime they want to use
well how do they do that if I come back
to my application and I scroll up here
you will see this entry Microsoft net
chord app type is platform ok this is a
new instruction to new get essentially
and to the dotnet core tool chain this
says this is a special package that
represents a little dotnet core
framework ok the thing i just showed you
on my hard drive by declaring it as type
platform when I publish it please don't
put it in my output folder because
there's 70 megabytes of crap in here ok
I don't want this in my output folder
I'm gonna just assume that it's already
on the server where I'm going to deploy
to now having said that if I do want to
take the entire runtime with me because
that was one of the features alright we
had that in Dean X and we have that
donek or how would I go about doing that
well that's what we call a standalone
application and I will apologize up
front this experience isn't that great
right now but I'm gonna show you how to
do it so first of all you have to say I
don't want this to be a platform anymore
just treat it like any other NuGet
package this is a meta package actually
contains references to many dozens of
other packages and includes not just
managed code includes all the native
code that's required to make this work
so if I have native code I have to tell
new get and I have to tell the dotnet
called toolchain what native platforms
do I support otherwise it's not going to
know which native implementations to
pull into my application and we do that
using the runtimes section of the
project Jason now anyone done uwp
development one hand goes up in a room
of many people no comment
so I have to tell I have to tell the
tool chain what versions of anything I'm
gonna run ok this is required so that it
can figure out where those native
implementations are going to go because
libuv on wind 10 is different to libya V
on Mac OS X so I'm running on win 10 x64
so I'm just gonna say win 10 X 64 right
now when I do that
I can now start publishing with the
application together now I've changed my
project Jason so it's doing a restore
here my lock file is gonna be a little
bit different if I come up and I do a
publish again we will see I can do this
from the command line or I can do it
from vs I'm gonna go back here and
change some things so in my setting
note now that I can choose run time so I
only have one so it's not particularly
interesting but before it said any
because I didn't supply one and just
soon that the output type was gonna be
portable okay which means that well this
app will run on any app on any run time
it's a portable app okay I can put it
anywhere that dotnet chorus installed
and it's going to go and run now it's
actually saying it's only going to work
on wind 10 x64 so if I publish it this
time and I should have done the little
race from the vs again should and from
the command line because I know it's
quicker runs a mr. ploy is the last step
okay so that published if I go to the
output you can see this or you can see
already this is looking quite a lot
bigger and I'm gonna do this over here
because I really don't want to look at
it in visual studio so I have quite a
lot more files than I did last time
including MS Kolob so you can see I have
the entire runtime and incidentally I'm
gonna need some way to launch this
application as well so what happens is
part of this process is that it builds
you and executable right you know when
you run your application you type dotnet
run or dotnet assembly name when you
publish the entire runtime with you it
copies net the XE in to your output
folder and renames it to web application
25 that's just not net XE okay it's
nothing else they just rename it for you
alright so now in theory I have an
output folder I can just hit enter on
that and it's running my application on
port 5,000 okay this is a fully
standalone application it has its own
version of.net what's the impact of that
well this isn't too bad it wasn't the
full 70 mega I ended up with about 53
Meg okay so as I said the experience
isn't as great as it could be and one
thing that we're looking to do in the
future is to make this as simple as
saying something like dotnet publish - -
standalone and then it would just do
everything I did just then like editing
my project JSON file changing that core
app - blah blah blah blah blah and it
would just be a publish concern rather
than an app concern where you have to
actually change your application files
okay well what about full framework well
full framework is very similar actually
if you build for full
framework obviously it's portable
because that's what framework apps are
they run on botnet framework that's
inside your windows folder and you get
an X in the output because when you run
for on full framework you're just
building a console application okay
everything for a spinet core is always
self hosted you're always running inside
a console application so that's pretty
straightforward
all right let's have a quick look at how
the reload wall development works so
people may have noticed I'm going to
create a new app because goodness knows
what I've done to this one now I'm going
to create a new application here and
we'll make this nice and simple we'll do
one of these we'll do an empty
application we'll come out here one of
the features that people really liked in
DNX in a snit 5 before we renamed it was
the ability to once the application was
running from vs just make a code change
and go back to the browser and reload
right we used to talk about in-memory
compilation the dirty truth is we didn't
the fact that was in memory had nothing
to do with that feature ok that's just
as how we chose to implement that
feature the truth is that feature still
works if I run this empty a spinet core
application which currently says hello
world I put that over on the right-hand
side of the screen ok so we can see that
here I can zoom in a bit I can come over
to visual studio right now I can change
this to hello Sydney and I'm just going
to save it right I can come back over to
the browser and hit f5 and a couple
seconds will go by and it will say hello
Sydney so that feature still works ok
even though we move to dotnet quois just
sort of works a different way and it's
not quite as fast as it used to be
unfortunately now I load it to how this
works a little bit previously when I
opened proc explorer before you might
have noticed that if I find the right
instance of dev and flexi which is down
here is Express isn't launching dotnet
or XE directly it's actually launching
this thing the vs i-i-i-i've real
trouble showing this kaksi name vs is XC
launcher.exe this is a little shim
executable that sits between ir s--
Express and your application or dotnet
XE and this is the thing that we use to
coordinate oh you changed your code I
need to
compile the application okay so that's
great but what if I don't want to use is
Express because we support running on
any server right in vs I can come up to
the drop-down box in my launch window
and drop this down and say just launched
web application 26 directly I just
launched it as a console application now
if I hit control f5 I'm gonna get a
console window and you're gonna see it's
starting on port 5,000 which is our
default port for kestrel and now it's
running on port 5,000 but if I go and
change this back to hello world and I
try and hit f5 nothing's gonna change
okay because that capability is unique
to the vs is Express launcher so what do
you do if you want to use a command line
focused approach and still get their
capability well we have a tool called
dotnet Watchers anyone use dotnet watch
no.1 1/2 1/2 ok this is worthwhile
showing them so I can come to my project
JSON file and I can pull in this tool so
Microsoft in fact I think I can just
type watcher see if the intellisense is
going to work for me today
come on saves me a bunch of typing if
you can ok we'll do it the hard way dot
net dot watch dot the one and what do
you do when you need to figure out where
something is and you can't remember and
your intelligence isn't working you go
to user profile you go to the new gap
folder and go to packages and you type
watch yeah there it is Microsoft's net
watch of tools that was correct okay and
then I do wonder Oh - OH - preview - -
final because the tools are still in
preview and this is considered one of
the tools I have to force a restore here
because of a bug unfortunately in the
current tooling whereby if you edit the
project Jason and just changed the tool
section Visual Studio doesn't recognize
that as a need to refresh new game so I
have to do that manually ok so now I
have this dotnet watcher if I go down in
back into the console here let me first
show you how would run this from the
console so I'm going to paste this in
here so now I'm inside that I can do
dotnet run that's
effectively what dotnet what Visual
Studio was doing for me and again I have
to kill is Express you love how it shows
in the middle of the screen very helpful
okay so there's not net run running and
I have address already in use because I
still have the console window opening as
well ah web development there we go so
that's running fine but I now have this
dotnet watch tool available to me as
well
okay so dotnet watch says hey yeah
Buchanan oh you can you can run this
application using dotnet watch now so
I'm gonna say dotnet watch run and now
the application is running just like it
was before I should be able to go to the
browser and hit f5 and sure enough it's
working HelloWorld because I changed it
before in the demo so if I want to go
ahead now and change that code I could
do that so come over here change that
code back to I'm gonna pin this to the
right so you can see the console kind of
react alright so I'm going to say hello
Sydney and save it and you can see on
the left hand side it detects says
things about I detected your code
changed I restarted the application for
you so if I go back to the application
hit f5 now you can see that that's
updated so how would I go about me this
is nice if you're working from the
command line and usually someone like PS
Co but I'm working in Visual Studio so
how do I hope those two things together
well I come back to my application let
me I kill that one over there one of the
new features we have in the web project
system is a thing called launch profile
so I'm going to go to the project
properties and I'm going to go to the
debug tab and you can see here we have
profiles we have the two that were
created for me automatically is Express
and web application 26 but you can
create your own and there's a bunch of
settings you can set in the profile this
is where we store what URL to launch on
if you want to set specific environment
variables or change the working
directory you can do that so I'm going
to create a new profile called dotnet
watch and this lives with the
application okay this is not global this
actually gets saved to a launch setting
such JSON file in your project and that
would get checked in generally and then
everyone in your team would be able to
take advantage of these settings so I'm
gonna say I want to launch dotnet so I'm
gonna say Program Files slash net slash
net XE and I have to pass in watch and
run which is what I typed at the command
and that should be it now I could add
some environment variables to I am
running in development here so I
probably want to copy those environment
variables that I had from the other one
to set development so it's a Hayes
Bennett core environment said that to
development okay which is what you get
by default for the other ones and now if
I go up and hit control f5 to launch
without debugging on.net watch it's
gonna launch down there watch for me
here it is I'm running from the console
rather than through ice Express and the
exact same thing should work so if I go
to hello Sydney hello Sydney works I
come over here change it back to hello
world if I look at my console I can see
stuff is recompiling which is nice come
back to the browser and hello world is
changing okay so here's how you can get
that same side of development workflow
if you're not using ice express for any
particular reason whether you're from
the command line or whether you're doing
it in Visual Studio okay Oh
loading PC else who has portable class
libraries okay well a few hands who
references portable class libraries when
you get even if they're not building
them okay a few more hands go okay is
everyone here just like doing dotnet
framework and nothing else that I never
used PC else how many people don't
really know if we're even referencing a
PC L there we go okay so with the advent
of dotnet core and dotnet standard there
is unfortunately
have you ever seen that xkd comic where
they talk about the way to fix the for
the problem of 14 standards is to create
a new standard then you end up with 15
standards we're kind of in that
situation right now there are many many
different PCL profiles we have we've
invented a new platform called dotnet
core which is now a new PC l profile but
because of the way ptl's work it's
actually a proliferation of new profiles
because of the combinatory factors and
so in an effort to solve that we've
invented this thing called dotnet
standard which is probably easy to think
of as just the next generation of PC L
so if I am running on dotnet core
because I want to run on Linux or I want
to get some of the other benefits
adopted core but I need to load
assemblies that were compiled before
dotnet core was out or compiled not for
dotnet standard but for some PCL
portable
Paul how do I go about doing that well
if I was just to try that I might find
myself in a little bit of trouble so I
know for a fact that there is the Google
NuGet package for talking to YouTube
which I use is this one over here Google
dot P is that YouTube version 3 I'm
gonna try and load that into this
project that I just created this project
is using dotnet core ok and I know it's
using net core because under frameworks
it's using that net core app one ot FM
or target framework moniker
it's just a fancy name for saying this
is the name of the framework I want to
write I want to run on ok new get uses
that TFM to decide which DLL outside of
the NuGet packages that i reference up
here to load into my application and if
there isn't a dll that matches that TFM
or match as a TF m that is compatible
with this TF m there's a whole hierarchy
of compatibility here then you'll get an
error which i should get right now so if
I go ahead and try and restore this says
it's completed well let's have a look
yeah wouldn't it be funny if they'd
actually fix it and this won't fail
which I wouldn't be surprised if they
had let's have a look I'm expecting this
to fail and it's not failing which is
surprising I wonder if this is one of
the ones that would give me a runtime
error let's have a look what happens if
I try and call one of these API so look
you should be client factory let's
create a new one of these
I'm gonna see if this fails
my god they fixed it that makes my demo
not work at all that's unfortunate I am
gonna go and get to the bottom of this
so how would I figure this out well I'm
gonna go back to the source of truth on
my machine and the Godin ooh get I'm
gonna find this package here it is here
I'm using this version here here's the
lib folder ah look at this this is
interesting so it looks as though oh
hang on a second hmm the templates are
already set up to make this work so if I
look at what's going on in this new get
package it has two Portable profiles
listed in its lib folder some big long
strings alright I don't know how humans
are supposed to understand what all
these mean you cannot just build these
by hand okay don't look at this and
think oh I can just put together for
random versions of.net and it will work
it does not work that way these all map
to concrete profiles that are stored
away on your hard drive in a magic
location and if you try and just build a
string here using what you think you
want to run on it generally won't do
what you think it's going to do now
the templates are actually set up by
default and this is the fact that I
forgot to override this problem so down
here under frameworks under my TFM they
have this import statement and it says I
want you to go and import these other
two T FM's so if I was to remove that
one and then I was to run restore again
which is doing for me automatically now
I get a failure okay and if I look at
the error list apart from the fact I
have a compilation further you can see
NuGet package restore failed for one or
more packages please see the details in
the output window so okay and it's even
been nice enough to underline that in
project JSON for me and it says the
Google API ah-da-da-da-da does not
support framework net core at version v1
so nougat has said I went inside the Lib
folder I looked at those Tea FM's
they don't match the Tea FM's that
you're using in your project so I can't
restore this package for you if I do go
to the output window
you will see a little bit more
information down here so it says this
package here is not compatible with net
core at and then it says these are the
things that it says it's compatible with
so if you run into this error when
you're trying to get your dot or your a
spinet core application to run on dotnet
core and it's some dependency and new
gap is saying that it doesn't support
net core app this is your next step okay
your next step is to go well these ones
work so let me try and pick this TFM and
go back to my imports section and add
that this is an escape hatch this is you
telling the tool chain ignore the errors
just go and load this assembly anyway
there's no guarantee it's going to work
all right
it might work it might not but at least
this will get new get to restore for you
and then you can actually try and get
the assembly to load into your
application now I know for a fact that
certain numbers of these PC ELLs are all
these profile names are compatible with
net core app we did the work to make
them sort of map and so most of the time
this should just work for you other
times you'll have to go to an extra step
to get the runtime of this application
to work and I want to point that out for
you in case you hit this maybe you won't
remember everything I'm doing here but
you'll remember one of these names and
you'll be able to search for it so there
is a package that the dotnet team have
released called Microsoft net core dot
portable dot compatibility and what this
magic package does is do a whole bunch
of fancy assembly redirects and type
fording in order to make different
versions of PCL z' from our long sordid
history of dotnet work against newer pcs
and newer versions of the.net framework
or things like dotnet core okay and so
if you find yourself in a situation
where you pull in a package and then
when you try to compile you get object
is not equal to object or system runtime
it's like equal to system runtime or
something like that
okay who's seen those type of errors
before I can see some nodding yeah this
package may fix this for you okay
so this package may help you
use packages that are on nougat that
haven't yet been updated for dotnet core
or dotnet standard but do have PC ELLs
inside that nougat package okay now
there is some documentation on how to
use this up on the dotnet core Doc's
site okay so if you do run into this
situation explore this and see if it
will fix it for you I know for the
Google API stuff it does fix it the
Google API is haven't been updated to
explicitly support don't its standard
but you can get them to work by using a
combination of imports to get around the
nougat block and the net core portable
compatibility to get round the dotnet
core runtime block okay oh configuration
binding in reload there's one of my
favorite things I don't think we talked
about enough let me go over to a while
doing him we'll do a new application I
want to show you something that's set up
by default inside our templates so
people know we have a new configuration
system that we built as part of a spinet
core it's under Microsoft that
extensions dock configuration it's not
tied to a spinner core in any way it's
not tied to dotnet core it's just a
library okay you can use Microsoft that
extensions dock configuration in any
dotnet core application it's compiled
against net standard 1.3 I think so tool
even work on older versions of.net
framework okay and it's essentially a
way to do pluggable config from various
sources so where you'll see this the
most is in our templates at the
beginning and the constructor of your
startup we have these API calls here we
build a configuration builder we add
sources I add a JSON file AB setting so
Jason set some flags I add environment
variables so that I've got stuff coming
from the environment as well and then I
call configuration builder build I can
also add from what we call user secrets
which is the ability to store config
values in your user profile as a
developer so that you don't accidentally
check them into source control which is
generally a bad idea
and if you choose identity auth while
you build your app you lost you have
that in the template as well one of the
little things that you may not know
about this is this flag here the
configuration system supports live
reload ok so while the application is
running you can get triggers given to
you when any of the config sauce
that you've plugged in have changed
assuming that convict sauce supports
alerting you that there's a change now
for things that are file based like
adjacent file we can use a file watcher
to be told when the underlying file has
changed right which is why I reload on
true is there and then if I look at the
configuration object after this after I
called build you can see a zoom in here
there's a couple of methods to do with
reload I can force a reload at any time
which will force the configuration
object to reevaluate reevaluate
any of the sources that you've plugged
in or you can get a reload token that
will trip whenever one of the underlying
sources says that there are changes that
should be reloaded okay so how is this
useful well let's do a really really
naive example of this so we can see this
in action so I know that app settings
that Jason has been marked as reload on
change true so let me use configuration
app since that Jason to flow something
to the app and we can see it change
while the application is running so that
I don't have to recompile one of the
disadvantages by the way the reason why
this is interesting is that the config
system a net and a speii net previously
which was all based on the web.com fig
file what happens when you change about
the config file reboots your application
right that one of those things just the
application goes away and you get a new
one so this is kind of nice that we can
support this so I'm gonna add I'm gonna
add my eye configuration route into the
DI container so I can get it from the
rest of my application I'm gonna pass it
in here like so
oh look it's already typed as that so PS
was nice not the time I don't need to do
that then I'm going to go to my view and
I'm just gonna really cheat here rather
than try and flow this through a
controller or anything I'm going to
violate all types of solar principles
and go straight into my view and just
inject that directly into my view like
so and I'll say I want that from the DI
container please that's going to be in a
different namespace so I'll say using
Microsoft arts extensions dot
configuration okay and then I will echo
out to the page
configuration and will get some value
and we'll call it index message okay so
let me go and add that message off all
that that property so there it is index
message hello from app settings Jason so
what we want to see is that while the
application is running I can change this
file and I actually see that change come
up all right so I've added that if I hit
control f5 it's going to start the
application wow that's really zoomed in
there's hello from app settings okay so
if I come over here and I say changed
come back here and hit f5 it says it's
changed now you might be going sure
Damien but didn't you just spend like
ten minutes showing us before that when
you change code and visual studio it
automatically doesn't okay so I won't do
that then so let's first of all JSON
files aren't included in what we check
track for changing cuz it's not part of
the compilation input but just so you I
can really prove the point I'll edit it
in a different editor yeah so I'll come
over here let's edit let's open this
thing in vs code
all right so wipe in that folder and
then I'll open my app settings JSON file
will pin this over here I find my
browser I will change this from yes code
I'll save that if i refresh the page
then it's change from vs code to ok so
the configuration system in a spinet
core supports this concept of live
reload which is kind of nice now we
actually use this in the templates by
default which you may not be aware of if
I go back thank you visual studio that
was helpful if we go back and look down
here in the configure method when I
build the logger factory so this is the
thing in a spinet core that lets you log
from your application do tracing okay
this is the new logging system that we
built it honors a lot of the same
principles that we have used in our DI
system and in our config system
I can add providers or sinks and we can
plug in third-party providers like Sarah
log and in log in those type of things
as well when I'm adding the console
provider which is one of the ones that
we ship you can pass in a config section
and what is that useful for well you can
use config too in the case of logging to
configure different aspects of the
logging so if I look at the app settings
file and look at this logging section
you can see the under log level I have
this map of string to log level like a
string that maps to the log level enum
and how is this used well this is used
to change how much your application logs
when it's running now to really see this
you have to or by default anyway it's
easier just to drop down and launch the
application directly rather than
launching it through ice express so that
you can see these log messages come out
to the console so here they are here's
my log messages coming out to the
console which is kind of nice I've got
some stuff that happens add up the
applications start up and then every
time I make a request you'll see that I
get a bunch of speed from the
application tell me about what's going
on now we have a bunch of the stuff in a
spinet core and dotnet call logs through
these interfaces by default if you have
entity framework in the application
you'll see your database queries show up
in this log which is kind of nice but
you can see at the verbosity level on
the left hand side i've currently seeing
mostly info messages obviously is any
good tracing a logger system supports
you can dial these up or down and that's
what this file is doing here so it's
saying for anything that starts with
system or anything that starts with
Microsoft set the verbosity level to
information or higher and then for
everything else set it to debug which is
like really really high you see lots and
lots and lots of messages with debug if
I don't want to see so many infamous so
many messages I could change this to
warning for example and I'll change this
one to warning and then without
restarting the application so there it
is there
if I hit f5 note I'm not getting
anything now because I turned off pretty
much all the tracing that was in my
application by dialing it down to
warning I can come back here and go to
trace which is a ridiculous amount of
information and if I hit a 5 then oh my
god it Scrolls down you know 5 pages for
every single request so
that's in the templates by default if
you haven't seen that already so we're
taking advantage of that live reload
config stuff it's being hooked up
through the logging system and you can
do a very similar thing in any of your
common code or common sub systems that
you use in your applications to react to
changes in real time if you want to
store your config in a system other than
the file obviously you could write your
own confi provider maybe store it in a
database or something like that and then
if your database can push changes when
things happen you would you could also
you know take advantage of their config
reloading in a custom configure Vidor as
well which is kind of nice ok what else
that I want to show all routing the
middleware so I'm assuming most people
here are using MVC ok has anyone ever
wanted something quote-unquote lighter
than MVC for a similar very for a small
application ok but they wanted routing
maybe you just want like you want to be
able to do a very basic dispatch and you
want to be able to grab you know
segments of the URL get all the nice
route patterns and those type of things
but you don't want the full ceremony of
MVC well there's another little thing
that we haven't talked about a lot in a
spinet core which is what we call route
2 middleware so I'm going to come down
here in my application and then we'll
get myself similar room zoom in a bit so
I can save ah well I'll just do it in
line I can say use router and I'm gonna
say new route builder control dot my way
to glory and I can say dot map zoom in a
bit so you can sees intellisense as it
comes up I can say map get and I can say
when happy route matches I want you to
go ahead and run this middle way context
dot response dot mm-hmm right line you
need to pull in that extension method
control dot I just trusted it's doing
the right thing I can't see it but you
know so yes surely it's not doing
anything wrong and hello from happy
route okay how many a million there we
go and I'll say dot build to build my
route table
and there we go so now I have a router
and this is asking for the app because
it needs to be able to resolve services
what doesn't it like do does not contain
a duty to a question I get the template
right I still like it handler okay I
don't trust you not contain a definition
for response that's because I'm calling
the wrong overload my mouse keeps
sliding down the lectern which makes it
really fun when I'm trying to get it to
show me intelligence okay I will see if
I can force this
I think it's having trouble some trouble
with the inference of my lambda let's
see if I can get it to call the right
overload and that's right not right line
and it's right I think of course because
everything is a sink okay so this see
and now after I did all that incredibly
helpful visual studio so I can tell you
what that was
see now it works visual studio I don't
know whether it's c-sharp I don't even
see sharp I think it's actually a
visuals video if you have an error
inside you're acing lambda like I did
there I was calling white line instead
of write a sink the method overloading
logic for the thing that you're passing
the lambda to it just goes to hell and
so he kept just trying to pick the first
one its stead of the one that actually
matches and then it's sent me down that
one minute happy path of thinking I was
typing the wrong thing alright so this
is the smallest middleware that you can
have right it's just a delegate that's
in line takes the eight the context and
then you can write directly out so what
I'm doing here is I'm using the route
the routing system to put a router in
the middle of the pipeline and then use
that router to dispatch off to a
middleware delegate so this is really
really lightweight right let me run this
and I should be able to hit happy route
along I don't have any build errors and
of course is being used by another
process because I have like a billion
windows open let's try that there we go
so there and if I go to my happy route
okay there's hello from happy route down
there but this is routing this isn't
just like dispatch based on path all
right I can actually do more stuff in
here so then I can do I want to capture
an ID but it has to be an int and it may
not be supported now we'll just do idea
I'm just on temp to demo God's too much
and then I can get that route
information out just like I would be
able to in MVC or something like that by
using some extension methods and h2b
context and now I can say context get
route value for ID all right and maybe I
can say hello from happy route ID is
blah okay so now if I go back and again
I don't have to recompile because it's
doing all that for me happy route Shh
don't match maybe it will no there we go
it's happy round I don't think that
picked up my change
now of course and the same thing oh it's
just easier to use ice express sometimes
because I didn't go through the work of
setting up dotnet watch okay so let me
go back to happy route which doesn't
match now because I added a route
constraint right I said slash ID and has
to be integer so now let's go and do one
two three and there's hello from happy
route ideas one two three
so that's full routing routing is
actually the middleware not MVC okay MVC
is a route handler that plugs into
routing and routing sits in the pipeline
as the middleware so if you want to
build a really lightweight framework
that isn't MVC then you can use routing
and get all the benefits of routing then
do whatever your own dispatching is now
you probably don't want to have in line
lambdas or maybe you do maybe you've
only got like two things you can also
rather than doing it this way I could
have another route down here
I say dot map get and I can call the
other overload so I can say
happy map and then I can take in an
application builder and build a subtree
of my HTTP pipeline and there I can use
normal Whittle with middleware i can use
type ii middleware so I can get di to
inject stuff in because our di container
is hooked up to the middleware pipeline
and will activate middleware for you
so if I go to the other overload the one
that takes action of my application
builder now I can basically build a sub
that hangs off this route that makes
sense
so then I could do a application build
and this is where I do have to qualify
them app like so and then in here and I
won't do app because I've already used
that word I'll use map and then here I
have a new pipeline so I could have MVC
hanging off my custom router inside the
main one where MVC is you know what I
mean like you can like host the same
thing multiple times because this is
just you know use static files for
example I can put static files inside
here but would only apply if I routed by
my happy map route okay so if you want
to build a super lightweight API
framework on net core using that I will
pimp it on Twitter for you cuz I'd love
to see more people use the built-in
router it's super lightweight and has a
lot of nice features all right that was
my last demo so I have five minutes for
questions if anyone has it I have a
question up the back it was a micro
friend that was going to be running
around or you can just yell it out and
I'll repeat it reveals no no pity bees
or anything like that so so the question
was how does symbol loading work because
I noticed in the output folder there
were no PD bees like that one there
references oh for so we don't ship pdbs
with references we never have like we
don't ship them in the NuGet packages
right so generally what happens is if
you want to do step through debugging on
stuff that we ship you configure your
symbol servers in Visual Studio to look
at the Microsoft public symbol servers
but we haven't published symbols are
thinking line numbers
crash dumps in production I see but into
our code base or into your Microsoft
code base into the Microsoft code base
yes yeah we haven't shipped symbols for
the.net core stuff yet so as part of the
work to make dotnet call wrong cosplay
we had to build a new pdb type because
the PT B's that we use today are windows
PE B's so now we have a new type called
Portable pdbs and you might have seen
that in the views VIU's code you'll see
that in the dotnet year that comes out
there and we're still working through
the process of figuring out how to do
those type of things that said you can
get line numbers and things on Linux
with crash jumps with a bunch of scripts
that the dotnet team has made available
but I don't know where they are top of
my head but you should be able to find
information that won't get them so our
hand over here do I see your hand
there's one right here there's two here
um there was some news that project or
Jason would be discarded and you would
be rebuilding - yep can you comment on
that yes I mean the official source for
all that stuff the question was about
project Jason and it being discarded and
all the rest of it if you go to the
dotnet team blog that's where all the
details about that are being kept up to
date as we as we build it the short
story is we are dotnet the doctor the
project Jason and the dotnet called
Project model was a unique thing that we
came out of what we did in DNX
it doesn't use msbuild so we've got a
lot of advantages we bought a lot of new
things but it doesn't interact or play
well with the vast community of stuff
that already exists for dotnet including
aspects of Visual Studio and so in the
next version of the tooling which will
hopefully drop by the end of the year
we're moving back to using msbuild under
covers but we're adding features to
msbuild enter the c-sharp project system
that we use so that all the benefits
that we got out of the project decent
model most of them will come over into
this new system so you won't have to
list the files in the project you'll be
able to edit the project file while the
project is loaded in Visual Studio you
know we try and get intellisense when
you get packages etc etc etc so that's
really the short story of it there are
some more details in some of the blog
posts on here with a read of the
official message along that and the team
is working hard on that
move right now the goal is to have that
be an automatic step so once that thing
is released you'll open your project in
Visual Studio it'll automatically
convert it for you or if using the
command line there'll be a command in
the.net CLR to convert the project for
you to the cs progr as well question
here two questions first one is is there
any functional difference in running a
speed up net core on top of dotnet core
versus the full framework okay like C I
don't have a case to run into potable on
Linux and other things can I continue
that yep
what is the difference between like a
spark or moniker and the.net standard
okay so the first question was either
what are the functional differences
between running a spinet core and dotnet
core done there framework so the benefit
you get for Dante framework is here
forever it's going to ship in Windows
forever and if you need down there
framework you should absolutely used on
there framework the big benefit you get
our cosplay which you just said that you
don't really need and two is the side by
side capability so the ability for you
to be able to have different versions of
the dotnet core framework which was that
folder I showed you microsoft.net core
app have different versions of that on
the machine at the same time so that you
could have different apps using
different versions of.net very very
easily the extension of that is that you
can also bundle net core inside your
application if you want to have the
absolute most sort of stand-alone
isolated version of your application
possible how is Microsoft going to do
security betting with this model great
question said how is Microsoft kind of
do security patching if now there's
random versions of.net so the dotnet XE
host has a servicing mechanism built
into it and so there is actually a
location on disk in a different place
away from where the shared runtime is
installed that the.net host knows how to
look into to see if there are new
versions
new versions of the assemblies that
you're about to load that may have been
delivered by a some patching mechanism
so on Windows we can use that mechanism
to do force pushes just like we do today
with critical updates and then for other
platforms or investigating ways that we
would enable system administrators to
patch a machine so that say you're using
some vulnerable version of MVC or
something 1.03 and we've done a release
of 1.4 and if we've considered it
critical enough that we've we've made a
machine wide patch available for it
you'd be able to run a command that
would patch that on your machine okay so
the important part is the mechanism is
already in place it shipped in one oh we
hopefully won't have any need to use it
for a while yet
but we will be able to do force push on
Windows if we have to and what was the
second question yeah the difference
between dotnet core app moniker and the
dead standard library oh so the short
answer to that is the net core app
moniker represents the dotnet XE sort of
hosting model that's an application
model like it's a dotnet core console
app right and the net core app moniker
is relates to the Microsoft net core app
folder on your hard drive essentially
those things are all wrapped up in one
little app model net standard is the
moniker that's used to write dotnet code
that runs on any net platform and the
version that you use is what will
dictate how many different platforms can
use it okay so one really is for library
or thing and one is for building dotnet
core apps
okay so my time is up if you have any
more questions for me hit me on Twitter
I have to disappear now to prepare for
my next talk but now I'm going to talk
about kestrel which I'm Galloway but
thank you very much for coming along I
hope you're in using an enduring HP net
core and if you have any other questions
other than you want to put on Twitter
feel free to log them on github as well
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>