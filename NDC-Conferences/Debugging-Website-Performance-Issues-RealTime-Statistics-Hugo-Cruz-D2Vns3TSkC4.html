<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Debugging, Website Performance Issues &amp; Real-Time Statistics - Hugo Cruz | Coder Coacher - Coaching Coders</title><meta content="Debugging, Website Performance Issues &amp; Real-Time Statistics - Hugo Cruz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Debugging, Website Performance Issues &amp; Real-Time Statistics - Hugo Cruz</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/D2Vns3TSkC4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome so while doing the slides I was
looking at the title and I thought it
was a bit too long so I thought of
actually changing it a bit so today I'm
going to talk about debugging while
having performance in mind and while
doing it using real time statistics so
I'm will I'm a Portuguese developer very
novel I work for a company called
varnish software
well I'm have the title of project
manager for those who don't know why new
software is the company behind the
open-source reverses it's HTTP proxy
furnish cache can you raise your hands
if you're very varnish before okay good
great so when we talk about web
performance most of us think about speed
it's the first thing that the mature
majority of us has it comes to mind and
then we have several things in this
place you have a be test engine can help
you monitoring scalability we have
architecture we have all these buzzwords
but in the end of the day it all is cost
cost for our users phosphorus that time
our servers etc so today I'm going to
approach the web performance bar into
like debugging kind of approach so this
is probably familiar to to you most of
you this is the dev tools of chrome and
this is basically the network tab where
you can see the calls for the backends
so if your front-end developer you
probably use these a lot so you see the
different call the time it takes for
each of the requests to go to the
backend and here you have a flame chart
which is basically the call to the call
stack in JavaScript so these are that
this is typically where is develop ER as
a problem in their web application it
goes through and of course you feel more
of the dev ops citizen main guy you go
into logging your server and you check
the logs here
this is just a Apache log simple Solaris
siege script running and then this is
just an example of that but I want you
to diverge a bit from the debugging to
tell a small story and then come back
and of course with that becomes a
solution so this is a rotary printing
machine and before it was invented
typically people would assemble small
letters or words or sentences the sheet
of paper against a sheet of paper with
ink and then print it was a very long
and tedious process and when this
printer was invented a cylinder with the
momentum allowed it to print copies very
very fast and save a lot of time so
varnish cache is a bit a retiree printer
for the web it gives its there's copies
of your content really fast without
going to the back end so typically you
have something like this
your clients doing requests and then
your servers doing responses varnish is
pretty good at two things it's pretty
good at allowing you to solve technical
problems like you have resource
starvation etc and also it's pretty good
at speed varnish sits between your
client or your servers and then here you
can see that actually then straight down
the backend requests back in response
etc and the logic goes inside that small
box there so now I'm going to explain a
bit how the process works so when you
request comes varnish fetches the
content that's requested from the
backends it then makes a copy in memory
and serves that same content to your
clients requests to your clients the
next time is based on the same premise
varnish reserves that content from
memory
into the client avoiding calls to the
backend of course it needs to be with
the same premise but this is a very
simple approach you can do much more
than this so now I'm going to talk about
financial configuration language which
allows you to configure this logic in
your voyage server this is a state
machine of the varnish language so not
I'm not going to go through all the
detail it's quite complex but it's just
to have overview how many things are
going on inside of orange server and all
these cause they're all these routines
are built-in subroutines and the glyph
thing in this is that in each of these
subroutines there are objects that we
can manipulate and change so let's say
HTTP headers you can pretty much do
anything you want inside these routines
and there are routines dedicated to the
front end and to the back end or I mean
to the client side into the backend side
sir so now going back to the logging the
varnish log works in a bit different
than other servers or web servers so the
varnish log is in memory it's pretty
much 80 megabytes and in every structure
of the Ring buffer so it uses a shared
memory log and by this we avoid writing
to file and it's quite fast and I mean
in files you have problems where you
it's pretty hard to to write to the file
in terms of the logic and then sequence
and then IO etc so there's and most
importantly it's enabled by default so
when you have a problem in your website
typically you go back and oh now I need
to enable some logging or extra logging
to figure out what's going on in varnish
that logging is always happening so you
don't need to go back and figuring out
like try to replicate the problem it's
already there
so this is an example of varnish look on
the left you have the varnish log more
to the client side and in the right more
into the backend but in fact this is a
full stream of data up there and request
you have an ID so that ID allows us to
group the full request from the client
request back-end and coming back in a
full log where you can see pretty much
what's what's happening and this is
happening like it's very fast it is
happen in real time of course if you
have a lot of data because you have the
structure of a ring buffer after a while
it gets erased but still 80 megabytes
it's a lot of a lot of data and all of
this is queryable so you can query
pretty much everything that's there
these objects you can query and extract
them and here is something that we have
also which is reads also from the shared
memory log which is a varnish on TSI but
here is more like a patchy kind of
approach still configurable you can
still configure what what's there but
it's more of a traditional logging
so while our initially why I use varnish
it's it's really fast it's it's used by
I checked yesterday like 2.5 million
websites in the world typically big
websites you can change your
configuration on the fly so you don't
need to restart it you just need to
change your VCL and apply the
configuration and the way the logging
works don't doesn't slow down the core
functionality so that's that's from our
point of view is very interesting and
because everything that's HTTP goes
through varnish you can do a lot of it
so now I want to talk about how we at
find software use the power of varnish
log to build something something else
like we call it varnish custom
statistics which is a in-memory database
that processes varnish log and creates
time series so this is the architecture
of VCs varnish custom statistics so you
have your varnish servers and then the
share memory and then you have this
language which we call the probe the
probe then reached on the shared memory
log and sends the data to the VCS 2-0 m2
then VCS dissolve the aggregation in
time series and exposes the JSON API
basically this VCS probe reached from
the shared memory log to this v CL based
keys that we write in the VCL that
configuration language and then it sends
it to the VCS server so I'm going to
give some examples in how to use it so
for instance this is a typical routine
like a VC L receive is the first routine
that's kept triggered when the request
comes and here just checking the user
agent HTTP header and doing a regular
expression matching with Mozilla and
then we set a key that we we call user
agents and then for module and then we
do some other things and we could even
do more crazy things with the regular
expressions if you have a crazy user
agent that you want to track etc this is
a just a simple example and the output
would be something like this this is
actually a time series like buckets of
data and you can actually choose how
much how much data that bucket have like
10 seconds 30 seconds etc and by default
you get all these counters and the
interesting bit here for instance is the
time for time to first byte miss and hit
is very important because you can figure
out
our fast we are delivering the first
bite to your client also if you notice
here we have the HTTP codes like let's
say in the 400 range you have in this
example there were 82 83 requests that
go to 400 so this is interesting in
terms of debugging so you could if in
real time check that there's something
wrong and you can take action here for
example it's the top 400 range
errors that's the tenth for the top 10
and then for the last five buckets in
this case my example was running buckets
of 30 seconds so this is independently
of the key that we're using so times the
time series are really a good way of
getting this data if all happens in real
time let's say around one second so it's
not real real time but almost there so
we like to sit to college real time and
because of the power of the
configuration varnish it's real flexible
so this is a was more simple example but
now I'm going to give you a more how to
use this because I mean this is nice it
works fast etc but there is no real
value in it so we can do a lot of things
with it
I've I'm covering some examples but we
could do like a be testing so we can
measure the performance in real time of
different contents and then decide what
to to publish we can track conversion
rates on online publications which so
for instance write articles more in
subject incidences engage a subject so
you get your editorial team to write
more content so that subject and also
for instance couting users per video
stream we have people using it for
checking what's the most popular segment
in the video etc things like that
so for a/b testing for instance
would use VCL like this first up there
you see further yeah so here we will
just clean these custom HTTP adder that
we create we real create down here and
then for every single request that the
URL matches foo we randomly create these
a or B we set the header to either A or
B and then to the clients we if there is
this a B group set it we created cookie
that lasts for 60 seconds with the name
of the group the next step is actually
to check for that cookie and if the
cookie is not set to the previous logic
but if the cookie is set just make sure
you set it in your header and then here
we create a key that loves that Heather
so what what this line is actually doing
is inserting that key in varnish log so
the varnish log I just showed there's a
stream of data that's constantly going
and then we just add a key with a header
and then when we query it we are able to
group it and actually figure out what's
going on in real time and here as well I
can I use the cookie to create a unique
session ID so I can even count how many
different sessions I'm having another
example is something that online
publications use
so this graph on the bottom of the
x-axis the the now moment is right to
the right
so the so imagine that this is like the
last 30 minutes in blue there is the
front from Earth sorry front page clicks
per second so how many clicks we're
having in the front page of a
publication in green a specific article
is measured but here is the amount of
heat that are coming from the front page
to that article so this allows you to
measure the performance of actually an
Arctic
and then if the front page is doing a
good job actually moving people around
the content another example keeping the
also the refer in mind in terms of where
the traffic is coming from this is for a
given article you can see that different
sources of traffic are here displayed
and here we use multiple time series to
create different lines or different
areas and then we can see for instance
that here the same view is there and
then after the front page after a while
the front page is linking the article
you can see that social networks start
sharing it so this is always through the
it's measuring the referral for a given
article and the traffic sources this is
done by the simple HTTP header that the
referer header that actually has the
information of the of where the traffic
came from of course you can track
anything HTTP this is just a simple
example so a running example that's
running on my machine right now so I
have a machine and I am seeing traffic
on to varnish cache servers and here you
can see for instance as a UI that I've
run on top of that JSON API and it's
simple here is checking the refer header
and I'm just simulating traffic that
comes from different sources Twitter
Instagram and Facebook and I can see for
instance that which one is the slowest
by default like I have all these metrics
that were in that timestamp response and
I can see for instance that Instagram is
the slowest of course here is order of
magnitude is not very relevant this is
just an example and then out of the box
I get all of these details I found 15
time series and I can see how many cache
hits cache misses and then the bandwidth
it was consumed the number of times it
has happened here sorry the response
time here and the number of times it's
this one so hits misses along the
along the time this is actually
interesting because you can then also
see the surveyors top requested for
instance here you can see the top
requested and actually I'm just checking
the the refer key but actually I could
reset it and see everything and then I
have created the structure of folders
but this is basically the flattened
structure and I have two hosts and then
I can see all my keys here that I'm
inserting and I can see pretty much yeah
so now the slowest for instance and I
can see okay
my slowest is this swirl but again
because everything is happening my local
machine the the magnitudes the the time
difference are not not that relevance I
can even see the size and I can see
what's the biggest object that is coming
out from my web server and if I'm
maintaining like my web server I want I
need to tackle that so this is just a
implementation on top of that JSON API
so this one actually the is live right
now so this is not VD running on my
laptop this is actually coming from
videos or the node
Norwegian newspaper and what this
represents is the popularity of the
given article clicks in their front page
right now so this is in real time so the
bigger the square the more audience has
and this has a 10 second bucket and it's
updating every 10 seconds so what VG
doesn't hold it was they integrated VCS
with their CMS and they fetch the
corresponding image for the article that
they see it's much more popular at this
time so if I click here actually I can
go and open directly the the article so
things like this article is really
popular right now yeah so my my takeaway
on this is if you have
some kind of issue if you need to figure
out what's wrong with your web
application varnish cache is a good
option to just check it and while using
it you then get out of the box you get
the speed and we have built this on top
of the varnish log but you could also do
it I mean it's it's just a user that
it's just some feature we created but
it's out there it's open source so I
invite you to try yeah so I just my goal
here was to show the flexibility of
logging and actually how logging in
real-time in a structure way it's very
very powerful so yeah so if you have
questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>