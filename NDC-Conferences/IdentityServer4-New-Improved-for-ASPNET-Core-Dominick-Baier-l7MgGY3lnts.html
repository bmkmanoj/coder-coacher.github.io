<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>IdentityServer4: New &amp; Improved for ASP.NET Core - Dominick Baier | Coder Coacher - Coaching Coders</title><meta content="IdentityServer4: New &amp; Improved for ASP.NET Core - Dominick Baier - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>IdentityServer4: New &amp; Improved for ASP.NET Core - Dominick Baier</b></h2><h5 class="post__date">2017-05-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/l7MgGY3lnts" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello thank you
who's been using identity server in the
past okay
version three are working for free for a
couple of people okay why are you here
[Laughter]
so this talk is mostly useful for people
you know that that have been using free
and now want to go to for and to see
like what's the Delta between the
versions but obviously if you haven't
used it at all you use the you know
you'll still get something out of it by
me trying to write code on this lovely
table here so you know we we created
identity server free oh well I don't
know two and a half three years ago to
to solve the problem right so it's not
like like it didn't happen because we
wanted to sell something it happened
because we wanted to solve a problem and
the problem was that basically none of
the commercial offerings identity
offerings are really good enough for
today's scenarios yeah so they might be
okay if you're starting on a complete
cream-filled scenario and if you are
adapting your business to how their
stuff works but if you are want to do
your death the way you want to do it and
just have a framework that works the way
you want it or if you're you know having
more complicated scenarios like my
creation and all these things then you
know customers just came to me and said
like we evaluated all of these products
and they don't work for us there so
that's what why Brock and I started
writing this framework for identity so
yeah it's it's it's not a server that
comes with an install XE and you just
walk through a wizard and then you're
done because that's what all the others
do yeah you get a framework it's for
developers identity server is only
useful if you're willing to write code
against it okay so that was our
intention tech back in you know actually
did the very first version was in 2009
but the whole framework thing started I
guess three years ago or so where we
actually hit a brick wall as well with
our like all in the box solution style
which realized wow there are so many
other scenarios out there which you
can't cover with a turnkey style
solution ma'am
so you know many people use a dental of
three it was built on top of katana yeah
which was the predecessor to a spinet
core katana had a couple of issues
mostly lack of features that we actually
needed yeah things like the eye and
logging and actually a UI framework and
and so on
so we had to work around all of these
things we are not proud that we wrote
our own few engine believe me nobody
wants to do that yeah and that we had to
implement our own anti fitori cookies
and protection and all these things so
but yeah that's the way it was and you
know people were happy and for the most
part with that now when the Holy Spirit
coughing started Microsoft the eighth
canet team came to us and said like you
know what we have these or
authorizations of a middle way of thing
and and we gave a lot of vocal feedback
that this is not really good what
they're doing yeah and they knew that
and it said yeah yeah yeah you are right
yeah I mean we should stay with our core
competence and just build the web
framework and let's security to the
professionals s-silly once said to me so
they said okay you know what for a third
core we're going to focus on just
consuming tokens right so we're going to
build all the middleware that you can
connect your MVC applications to a token
service to consume the tokens we're
going to build a middleware for your
chasing for your Web API to consume
tokens but we are not going to build
anything that will produce tokens so
they said like are you guys willing to
fill that gap with identities of tossing
it to a student core and by the time you
know I was young and I needed the money
I said yeah let's do that sounds good
yeah and then there was this whole long
period of a spinet core you know having
trauma every day and
you know nightly builds our seas which
were pre-alpha status and rtems which
were our seas and yeah keeping up with
that was was tough right so a year later
I have gray hair I didn't have that a
year before and and and we finally
release that yeah so in the end we are
happy with the end result but it was a
long road and that was mostly the.net
Coral Road which was long way and we and
we had to basically you know keep up
with that so what what is talk really is
about is what what has changed in
between three and four which is also
about what is new in a spirit core which
allowed us to make these changes so we
deleted a lot of code and that's a good
thing yeah why because that code was
moved into the base framework so the
first thing that is actually new is we
have a website finally you know the cool
IO website for you know the cool open
source project that is basically your
starting point into everything identical
for related yeah so you can get to the
github repo from here we have
documentation now well we had it before
but I think it's better than the one
behaviour before we do training on a
regular basis I just did do the training
yesterday and the day before what
they're just more for example in Oslo
again people were underwear that we are
actually doing consulting so you know
just if you asking yourselves writing
open-source software doesn't pay the
bills right because it's for many people
open source means free software right so
we are actually doing consulting most of
the time to be having the luxury of
doing open source on the side ma'am what
is actually new is we have production
support for you know like SLA so many
people said like yeah we would like to
use our identity server but our admins
are nervous
they want to have a you know production
support plan where they can call someone
if something goes wrong and we have that
now above for the states and for Europe
okay let's go to the source code
so here's our organization in case you
haven't seen it it's basically now it's
all about identity server we have four
and free free is still being maintained
right so we're not abandoning it
completely we still do bug fixes if we
think there's there's a really important
feature missing we're gonna back port
that but obviously being just a two-man
team right and a couple of contributors
we cannot do full feature work on both
versions so all of our investments are
going into for right now now we think
four is the best token service we've
ever written
we added many nice features some some of
them I'll show you and yeah I would
recommend everyone who now makes a
decision to do three or four just use
for now we are we are happy with that so
in fact a very common scenario we have
is that people have an existing identity
for free and then started writing
applications using HP nerdcore and MVC
core with free which is totally fine
right I mean it's just a protocol
implementation and it doesn't matter
which framework you're using but now
since four is done they wanna get rid of
the katana stuff and move even identify
were to to HDNet core so that is kind of
like the scenario I'm uncovering here so
we have an we have two little we're we
have an API we have a client which
simulates like a server to serve our
style communication and we have an MVC
client and they are all working with
without any server free so my plan is
now to just my create that configuration
from three to four and just leave the
applications unchanged right and just
prove that this is how it works
okay so just just to see what we have
here
yeah so we have an API host you know
using MVC so let's run that and this
this API house is just echoing back the
claims of the user we have a console
client so what is the console klein
doing again the console client should
simulate a server to server style
communication so you know it
it goes to the discovery endpoint it
finds out where the token endpoint is
and then it requests a token from the
token endpoint and once this is done it
will call an API okay pretty simple so
when I run that it doesn't it works
right we have a token we call the API
the API just echoes back to claims all
is good and here's our identity server
running in the background we have an MVC
client yeah again pretty standard NBC
NBC core right we have the open that you
connect middleware from Microsoft so you
know you point to you point to your
foreign team you pass in a client ID and
the secret you select your scopes and so
on and so forth yeah so when I run that
and click the secure link it will
trigger the authentication handshake we
end up on an identity here we support
both local logins and something you know
external Google in that case but could
be anything else
so I'm logging in I'm logged in to my
website and I can call now an API on
behalf of the currently logged on user
okay so that's the their scenario so
let's have a look at at how that how
that looks like okay so in in
additive-free
you use the katana hosting api's either
in IAS or in or in self oh so basically
you configured the base address you call
Bev app don't start past in your startup
class and then this thing start running
one little interesting detail here is a
katana didn't have build in logging
right so there was no logging
infrastructure in katana so as a library
developer you had a hard time what are
you doing right I mean you don't want to
use I don't know log for net or n log or
Siri log or whatever and then force
everyone else that uses your library to
use the same locking library now so we
using
a library which is an abstraction
over-logging right because the world
needs more abstractions and that that is
called lip-lock from a guy called Damien
Hickey and he does some very tricky
things like basically he gives you a
general purpose logging API and at
runtime he pokes around in your app
domain to find out which locking
framework is being used and then we'll
figure out oh they using fury lock so
now let's just dynamically invoke theory
lock locking on the fly right and if you
will use n lock key with n log and lock
for night and so on the for ya
many people were confused by this level
of magic like how do I configure login
with identity server that you don't just
just do it yeah it'll work automatically
ma'am and that was a really good
solution and it worked quite well so
basically what that means is that we
free you you configure locking at a
hosting level and then it was being
picked up the startup class in katana
you know looks looks like this typically
you have an configuration method with an
if' builder then then is the next thing
we needed to do because because it
wasn't built into katana was dependency
injection right so we needed a way to
give you a configurable wear container
where you could put in your own services
so you could modify the behavior of
identity server so again not nothing was
built into katana so we pick the
favorites the I container by the time
which was Autofac and then build our own
abstraction around it which is called
the identity server service factory
right and yet the purpose of that was
that you could plug in your own custom
implementation for example like where
are your clients toward where are your
scope stored and where are your users
stored right and then this would
internally be turned into an auto set
container and that would hang off the
katana pipeline and then the other thing
that was
the prevalent style in katana is that
now you had the middle way and the
middle way I had like an options object
yeah and or the options object
configured every aspect of of that
middleware ma'am so you know here's your
site name your signing certificate then
you pass in the factory which is the DI
container and then whatever other
configuration things you have to do okay
so that that was the style in katana and
now let's see how that style has changed
for a spinet core so in a spinet core
let's start by adding the new get
package identity server for you know we
have this nice project JSON file which
will be gone in two weeks so it's enjoy
it while it's there because other
because then you're going to continue
starting to think in terms of icon
groups and property groups in XML files
okay so once we have that you see now of
all first of all the locking yeah we are
still using Siri lock as our preferred
Locker but this time it's different in
in a single chord S is that the startup
class has dependency injection even into
starter plus itself so when they when
they knew of the startup class which is
actually done by this piece of code here
the web host builder which you pass in
the type that implements your your
startup code they call the constructor
and I think you already get like 14
dependencies like did the local factory
the hosting environment so you can know
if you are in def or you know staging or
whatever and a typical pattern is
actually not the parent edit that is use
for Microsoft but my preferred pattern
is that you set up all the logging in
the constructor yeah and then it's it's
available from very very early okay same
idea we're new up Siri log but this time
we just say on the logger factory edge
theory log and then we are using the
built-in locking facilities of a screen
core so what else do we need to do to
enable the first scenario is we need to
add the identity server
we're okay you see that there there are
no options anymore because that is not
how it typically works anymore in HP net
core the idea is that if you want to
configure middleware you're typically
using the DI container to provide the
right services for that middleware so we
have a thing called a poop services dot
add identity server which now puts up
all of our dependencies into the I okay
now we need need to do a little bit more
here so that the very first thing we
probably should do is we should
configure key material to sign the
tokens that gets produced by identify
and again this is all done by wiring up
a service into the AI that has the key
material right so we have this new thing
called add signing credential and you
can see now we can use raw as a keys
here we can you can pass in any signing
credential type from from the from the
identity model library you can pass in
an x.509 certificate or you can pass in
just the name of the search that lives
in your certificate store okay another
thing that we added because of feedback
is you know people said like yeah in my
company I am not allowed to create my
own x.509 certificate so I have to wait
for the admin to to give me one blah
blah blah and he's very slow or he said
you know busy with other really
important things like reading ad groups
or something yeah so we have this new
thing called at temporary signing
credential and what this does is at
startup time we just create a random RSA
key pair so you have something to work
with
right and you know and then when you
have the real key material from whoever
approves that you can just switch back
to the normal at signing credential yeah
I don't use that in production you won't
have fun with that yeah yeah okay so now
let's have a look at a configuration
that we had in in an identity of free so
let's go back to our config file here so
one thing we we needed to
define in in identify three where
so-called scopes
okay so scopes are the other resources
in your system that that clients want to
access right so whenever I explained the
term scope to someone I said you know a
scope is like a resource yeah recent
there are two types of scopes yeah one
are more like the identity related
scopes like first name last name and
there are the API scopes
yeah like API is you want to call and
most people typically understood what a
client is and what the user is what
scopes they struggled with yeah and the
more and more I started explaining that
I realized I always say a scope is like
a resource so we fought you know what
let's just rename that class to resource
an identical for now and you don't have
to you you know explain it anymore so
you see we had two types of scopes one
was called an identity scope one was
called an API is a resource scope and
one of them model and API one modeled
more like identity data so what we now
have in in for our two classes identity
resource and API resource just to make
it really clear what you are modeling
here now so let's do this let's add a
class called config and do a public
static a new mirabile api resource get
api's
okay new API resource and you know in
the in the easiest sense yeah you say
like okay I have an API it's called I
don't know whatever yeah API one yeah or
my calendar API yeah that's all you need
to do sorry not this one but this one
yeah to just register an API with a
dentist's over and now we can reason
about this API and you can assign
clients to this API who is allowed to
talk to the API and so on but there are
more options here if this API will ever
be used on a Content screen you can give
it a display name you know my cool API
number one and just most of the free
most common things if you want to define
that whenever a client asks for an API
number one the token should contain
these claims about the user you can just
put the claim types you know maybe maybe
you need like I don't know the the
location of the user yeah I mean
actually we could do that so that is an
you know an important thing for your API
and that's that's how you can model that
okay there are more options oh yeah and
what what is that under the covers and
that it basically creates an API with
exactly one scope and the name of the
API and the scope are the same okay if
you have more more more complex things
like you want to create an API but you
want to subdivide that into multiple
scopes like maybe a read scope and the
right scope or read-only or something
like that you know you could do
something like start with this you know
give this a name API note that's the
complex API yeah
it has a display name you know complex
API
it has user claims right so you could
set like whenever you ask for this API
put these claims into the token but not
what you can also do is you can have a
list of scopes here
like this and then say new scope you
know complex complex API read or full
full access for example yeah and then
could have user claims here so what what
that means is let's say you're just
calling you you can't call the complex
API you will get a standard claim if
you're calling the full access Cove you
get in addition the claims that you
define per scope yeah so you can model
pretty complex things here now so we
think that that's that's an improvement
over the old approach where everything
was just a scope and we you know by by
being limited to object orientation we
had to share the properties between the
scope types that you know didn't really
belong to each other okay so that's how
you model a TI's now the next thing
we're going to model our clients so
actually clients haven't changed that
much but let's just go to here and just
copy that over
like this so client is still a client it
has a client ID it has a client display
name right
it still has a client secret we we
change that internally a little bit to
make that nicer so you can now use this
oops
this style of setting up that in memory
same here API one I'll probably call it
API line to be compatible with the
client so the what what have you changed
here as you can see the flow doesn't
exist anymore yeah so flow flow is a
term from the spec and it describes how
a client talks to a token service to get
tokens and they were like you know that
ever there's a client credential flow
which is for for server to server style
but that of the hybrid flow and the
implicit flow and and so on
and when we implemented a madessa were
in the first place we we we were aware
that certain flows are incompatible okay
so for example if you would configure
recline to use both implicit flow and
authorization code flow and
authorization code flow is the more
secure one because it demands a
back-channel command authenticated
back-channel communication then a
malicious user could just down create
from code flow down to implicit flow
just by changing a parameter in the
protocol right so that wouldn't make
sense to allow both flows for the same
client because you are not getting what
you're expecting you're getting okay so
we've before you know played safe and
only allow one flow per client now but
then this and then we learned by you
know just just by by by using that in
practice that there are indeed certain
situations where multiple flows are
useful may I like for example let's say
you want to do interactive using
implicit flow but have a back channel
server the server style with client good
answer
this kind of forced you to write to
register to clients in the past yeah
bitch you know wasn't that nice so in
the new style we went back to the
original term in the spec called the
current type you see it's plural now so
we saw this with report multiple grant
types we have a grant types class which
models the most common combinations
right like code and clang credential or
hybrid and clang credentials and if you
want to be completely free form you can
use the list one and just pass in the
current types yourself but we're still
doing validation at at creation time so
to make sure that you are not using the
vulnerable combinations okay so let's do
client good initial fill tool I think
that's it yeah so maybe we have a client
that that is allowed to talk to API
ma'am it has a secret and we have set up
the API resource okay so now how do we
wire that up basically again by putting
them into the DI container we still have
multiple versions of that we have an
in-memory ad in memory API resources
where you just used you know the class
you've just written you could use a
entity framework based thing or you
could write up your own eye resource
store that loads that stuff from
arbitrary locations so we do add in
memory clients as well same thing you
know we have we have so many different
customers that you know like to do it
differently so we have a couple of
people that that preferred the CI style
where when they change something someone
does a pull request internally someone
review reviews it it merges it and then
it gets redeployed other people like to
you know use databases so that's up to
you you just wire up the right services
here okay so that looks like it could
work let's have a look
okay so here's our our host you know
using console logging to see what's
going on and the first the first end
point you want to check is the well
known and point right that's the that's
the configuration of the token service
it's the meta data if you like and that
is all being handled by the identities
of a middleware right so we are handling
the protocol end point and now you can
see we have a we have a token service
that is named like this here are the
URLs of all the the protocol endpoints
here are the two scopes we support API
and offline access here's the one claim
we supported that is all sourced by the
definitions you made with your resources
okay and the most important thing here
is that's where you can get to the
public key that can be used by clients
or by api's to validate the tokens that
we emit right that's the public key that
belongs to the private key that I
configured in mine in my startup cool so
let's see the API should probably be
restarted let's let's kill the API host
so it has a chance to refresh its
configuration No ok yes our API so
here's our console client let's run that
and here we are ok so yeah in other
words you don't have to change anything
in your client applications because on
the wire it's the same protocol we
actually have a have a test project in
our repo that has all that all the
different combinations of you know
running identical free and for having
api's on katana having API on HDNet core
and just calling them in all
permutations just to make sure that you
know they they are crossed version
compatible so to speak em so that's
working fine a couple of things about
the client where is it
here so we got feedback from a couple of
people so again in in version 3 we we
demanded that every client has a secret
right so you know as a security guy it
didn't make sense to me to start with
that why shouldn't we have a secret for
a client if that is supported by the
spec right but again after doing lots of
work with different customers it turns
out there are situations where secrets
don't make any sense for example for
publicly deployed clients right so
something that you deploy from the App
Store to an iPhone why would you need a
secret there yeah and I always said like
yeah you know what then don't treat it
as a secret College secret right but
there were internal you know penetration
tests and stuff and they said like yeah
you are using a secret here you
shouldn't use a secret even if even even
if it's not secret
so we forced people kind of to introduce
secrets even if they didn't you know
didn't need it too so yeah that's gone
ok so we removed that so in in our in
our config here if you want to and if
it's a so-called public client you know
you can say require a client secret
false and then the secret is gone ok
another thing we got feedback on is
especially for server to server style
communication is when you are requesting
the token we demanded in version free to
pass in the api's you want to talk to
you at the scopes yeah API one API two
API free whatever ma'am now when you
have many scopes and many clients and so
on
and especially for package you know like
data center style communication they
said like why do we need to pass in
those API is explicitly I can't you just
give me a token for all the api's the
client has access to otherwise every
time we are adding an API we need to
change the client code when you change
configuration blah blah blah so in other
word if I remove that now then you will
get whatever is configured in the
allowed scopes list okay again something
to make it a little bit easier
especially for bigger bigger
environments so good let's go to the MBC
style client where is that is the
configuration so here's our MBC climb so
let's just copy this guy as well copy
that over here so you see it's almost
almost the same right again flow became
allowed crammed types and there's a
grant types but hybrid hybrid flow means
the the first leg is done wire the
browser to get the identity token in the
code and then the client does a
back-channel communication to exchange
the code with the actual access token so
that's the hybrid flow that that's the
recommended flow for browser-based
clients if the application is
server-side we introduced something
called so what we've seen is that many
people didn't use the hybrid flow in in
the past because they either you know I
mean that's like a later chapter in the
spec and maybe they didn't read the spec
until that point but the hybrid flow is
the most secure one for web applications
because as I said you are not exchanging
the actual access token Y at the browser
right I mean what's the point of you you
need to X talk on the server to talk to
an API which is also on the server but
you are transporting your access token
once across the world you know back in
down to the Hecht Wi-Fi in Starbucks
yeah and up again to to your server so
we introduced this thing called allow
access tokens by a browser may also jump
to and that defaulted to fault
unfortunately because it would have been
a breaking change in in free
now this defaults to sorry this is this
default to true before and now it is
false - false so in other words if you
are trying to
- implicit flow here and you want to
transport the access token by the
browser you will get an exception by
default saying hey you are trying to
send an access token by the browser but
you haven't opted into that feature
because you know it's dangerous a little
bit at least yeah so that that is gone
now because that's our default value so
here are our redirect you arise we have
we still have a client secret here
already allowed scopes so that's all
fine so what we now need is disguise
open ID and profile they are now in our
new configuration system they are
identity resources here and not API
resources so let's create a method
called get identity resources yet
identity resources return so open idea
is a standard scope from from the open
ID spec so we can just do new identity
oh that should be attentive resolve new
identity resource s dot open ID and the
profile is a custom one plus to a new
identity resource give it a name profile
so whenever somebody asks for profile we
can return I don't know whatever we want
give the display name profile data and
we can return let's say a given name and
a family name the name and location
again okay so that's how you define your
own identity of resources
and then we just wire them up in our
startup class so we say add in memory I
add in memory identity resources
conflicts get identity resources ok so
as I said logically the scopes haven't
changed but we try to split it up into
two distinct things identity and api's
and that is the main reason as I said
was because that's how you model right
is when you're drawing your like like
when you're on the drawing board and
draw your system you have the api's
right and you have your your your
identity and these are two distinct
things that's why we thought it makes
more sense to separate them into two
distinct classes okay so now we have
defined get identity resources we have
defined the MVC client now now we need
two things
use us obviously and a UI okay so the UI
is probably the biggest thing that has
changed between three and four so we you
know I said in the beginning the reason
why why we wrote our own few engine and
fourth you guys to use it is because by
the time there was no M UI framework
that was running outside of identify is
right dddd only thing was MVC really at
least full-featured our design goal was
to not be tied to I is because we have
many customers that just want to run
that in an NT service right so yeah so
that was what we had to do ma'am and we
weren't happy with that now in a spinet
core right we have MVC proper which runs
out of the vias if you want to about
know it always runs outside of I is
there or there are other alternatives
soon I'm pretty sure ma'am so okay so
let's why the UI arm so we're going to
use MVC for that
so let's add MBC Microsoft Microsoft dot
asp net core dot MVC 1.1.1 and we need
static files one point 1.0 so now you
have a couple of options how to get your
UI in here now one very common scenario
is here that you started with an
application that had all the login stuff
built in and you now want to write the
second application and you want to share
the login pages between the two by
putting them into identity server so you
just copy your existing login page out
and put it into a dentist server that's
one way to start the idea the other one
is to start from scratch obviously the
third one is you can even just use one
of the default MVC template so if you
want to get started with MVC login pages
using asp.net identity you free then
just use that template in Visual Studio
and you can add us to that template and
it works as well or we have a think of a
like a starter kit for you yeah
so they used to be a thing called new
get content packages where you just
basically pulled in and you get and it
spit out static files into your project
that that's gone that feature in you get
or not not back again already I don't
know it's gone right now so what we did
is we have this repo called identical
for QuickStart UI and what this contains
is just the UI part that you need for
for for an identical right it's a login
page it's a logout page it's a Content
page done ok so what you can do is you
can just go here download download that
and put it into your into your project
so with this little script here hello
we can just copy that down so let's do
this demo is Delta demo before so 3
sauce identity server for host right
so we can copy that in here and this
pulls down the the content of the github
repo and copies it into your into your
directory okay so what do we get when we
do that well we get an account
controller now which has a login page
here's your login page we have a couple
of services that our UI related so the
most important one is the identity
server interaction service so when
you're writing your own UI you probably
still want to know what's going on right
now in what are the details of the
current authentication requests like
who's the client you know which
parameters did you send in for that
that's all you get from from this new
service here and basically how our logic
works is the client goes to the
authorized endpoint which is handled by
the middleware where and when the user
is not authenticated we just redirect -
by default - slash account slash login
that's that's configurable but that's
the default value and that's where you
trade in MVC worlds you typically have
your login page right and then it
arrives here and we give you a return
URL yeah just like you would with cookie
authentication always you know in the
old days with form space of indication
and this return URL points back to the
authorized endpoint so we can continue
with the flow and now you are in full
control of you know you can do whatever
you want right you can start an
arbitrary complex login workflow maybe
register the user you know do your
two-factor or whatever when you are done
with whatever you need to do to make the
login happen yeah you sign in the user
just using the normal age peanut
Quorra authentication manager API you
make sure that return URL hasn't been
tampered with here and then you return
and then you redirect back to us and we
continue with the protocol stuff okay so
we think that is the best way of doing
that yeah we handle the protocol stuff
you handle the UI and you go back to us
when you're done make sense because to
be fair the UI is always the thing you
will you will always change right I mean
you typically don't want to use our
login pages there okay
so that'sthat's this thing the next
thing is where do we get users from and
we had a class we had a class in
identifiy called in memory user
yeah and in memory user store and we
thought it's pretty clear that this is
only useful for development scenarios
now but then you start getting issues on
github saying huh how do I load my
sequel server users into your in memory
user store and for like mm maybe maybe
that's not the best way of doing it so
we saw so we removed the in memory users
altogether but then we realized for for
for doing demos like this it's handy to
have something like that yeah
then we put it into a different assembly
then we put it into the QuickStart UI
and finally we brought it back and now
renamed it to test user I hope that's
clear now yeah it's it's not for
production okay so what what the test
user gives you basically is a way you
know to just have a couple of users in
your system you can give them arbitrary
claims here you can give you a password
so you can you know play around with the
token service ma'am okay so how do we
wire up that um you say add in hold on
add test users that's what it's called
yeah
and that class is called test users dot
users okay and again which is putting
them into the eye
so the the login the login page can now
use it cool
let's one at again and let's see if our
MVC client is now working as expected
okay so we go to secure ooh oh I know
what so here we obviously have to add
first of all at MVC now because they're
using MVC right so we do services but
add MVC and here we do apt or do static
files and apt or use MVC with default
route okay
good and I want NDC client secure okay
yes blocking page so we have Bob and Bob
content page and we are back okay so now
I'm not sure if my API is still running
we'll see ya when that works as well now
so the only thing that's missing now
from our little migration project is the
external login right so we used to have
Google logins before and that that's not
there yet so let's have a look how that
worked in in free here in our startup so
basically what is what you need to do in
free is you had to give us a callback
method that wires up the external
middleware like Google you know ad FS
Facebook whatever and since we are like
building the pipeline we had to inject
these middlewares in the right at the
right point in the pipeline so basically
we said you know here's a callback we
call that at the right point in time to
wire up the middleware okay
so that's not needed anymore in in for
we can just pretty much copy that to our
startup class like
it's now called Google options I think
let's see if how good intelligence is
here come on go green yeah I think it
kind of did cream so this is now called
sign in authentication scheme in eight
minute core and this is gone what we
also need is a cookie middleware to you
know store the temporary outcome of the
of the Google authentication so let's
add that as well okay Jason we have
cookies already here
no it's been a core cookie
authentication what we do after use
cookie authentication new cookie
authentication options we give this a
thing detecting a name of indication
scheme that's called now just to be able
to work with our default UI we have we
have a constant what what what the name
of this middleware should be and it's
called identities constants dot external
authentication scheme and we won't do
automatic authenticated false and
automatic challenges false as well so
and then here we say sign-in scheme is
now I dentists of constants dot external
authentication scheme okay so that's
that's how you might create that and
that that is not even identity of a
specific it's just a spirit core ma'am
so now the way this works is we have 10
more minutes that's good the way this
works is on our account controller you
see on the login page what we're
actually doing is we're building a few
model so when we go here you see that
now we are calling on this interaction
service we call the get authorization
contact
method which returns you an
authorization request so now in your UI
you have all the details that you need
to know about the current authentication
request as you see the client ID is
there and display mode and blah blah
blah and if you want to pass custom
parameters from the client to the server
we give them to you in this parameters
collection okay so you can pass in your
custom stuff as well and ultimately what
this this is building is a few model for
the login page which looks like this
yeah a do we allow local logins and
that's the the the left side of the
screen with name and password right and
if you have that do you want to have the
check box with the remember me but check
box here and do we have external provide
us now that that's how the few model
looks like for the login page and then
what we can do is you see on the a
spirit core of Education manager that
there's a method called get
authentication schemes and that returns
now all of the externally registered
providers like Google and Facebook and
hrad and so on that's how we can
automatically fill the view model that
gives you like you know log in with
Google log in with whatever buttons on
the on the screen and if you see the
actual view it gets pretty clear how
that works so when we go to the login
view you see we have to log in few model
here so if we allow local login we
render the name and password box if we
allow to remember me beer
you know model that and if we have
external providers then for each
provider we have rendering a little
button so it's not black magic it's just
a spinet cool so let's see if that works
for the last demo I guess is run the
server again
and one declined again
can you see now we have to the Google
login as well okay and now I'm locked in
you know with Google and my data is
coming from Google now so we have a
little bit more time for the may be the
very last thing I want to talk about is
a very common request we had with with
identity 7-3 was you know a scenario
where you had a mixture of internal
users using Active Directory and
external users using a password or
Google or what's the area and believe it
or not it was very very hard in Kitana
and asp.net to support both windows
authentication and something else in the
same host now so our solution to that
was we wrote a little mini STS yeah that
you hosted in a different application
that was set up for windows
authentication and then all of and at
the top of this mini thing was to
authenticate the user using Windows and
then return a token back to us so we you
know we could give you the Windows
integrated authentication experience now
this has changed a lot actually in in a
spirit core so you know that in a spirit
core you are not tied to iis anymore so
when you are on Mac or whatever you
don't have i ASO is is an optional
component but in the windows world
windows authentication for web
applications is implemented by I is okay
so yes this little thing here that they
give you in the standard templates
called use iis integration and what is
tough actually I don't like that it's so
much magic but that's the way implement
is what it does is it actually wires up
middleware yeah so you would think you
can only wire up middleware in the
configure method no that's wrong there's
a start-up filter something you can
implement that allows you to hook into
the configuration process as well and
that's what this thing is doing and one
of the things that this use is
integration middle a call is doing is it
wires up a Windows authentication
middleware okay so you can now
explicitly do a challenge on
windows authentication middleware and
trigger windows authentication
explicitly from within your host even if
your host is using cookies as the main
authentication method okay that's pretty
cool how do we need to get it to work
you see I'm running self-hosted now so
we have to switch to I is for obvious
reasons right let's see how this is
configured so it should run on localhost
5,000 so you need to enable windows
authentication here right and if I now
run that again I'm running in I is now
so I have this windows authentication
middleware and if I'm now starting my
client what I should see I hope III
never prep this but you know let's see
what happens
yeah give you okay I'm gonna now click
this guy I'm logged in with my binos
account ok and you know what what
actually many people do is this on the
on the login page yeah they do this they
do would check like if there does the IP
address of the client machine is in the
intranet lets directly switch to the
call the external login method and pass
in Windows as the provider and then for
your internal users they get directly
Windows integrated authentication for
the external users they will get the
screen with the buttons how they want to
authenticate now so yeah we are pretty
happy how this worked out because
nothing of that needs to be an identity
server feature anymore right because
HTML car has all these pretty pretty
good actually authentication API so we
don't need to reinvent the wheel here we
just give you full control how you want
to interact with us any questions for
that we have four minutes here
yep thank you mm-hmm well so that for
the thing is this um let me show you
that wrestle I start up so when you are
configuring identity server here you can
pass in an options object here like this
like this and you can do authentication
options or non authentication options
dot authentication dot sign login what
is it called authentication scheme I
know it oh sorry
interaction options it's called user
interaction dot login URL okay so this
is basically the reader that the URL we
redirect you to whenever we need to show
a login page okay and that it could be
anything right it's up to you that the
only the only thing you need to do you
know that that could point to some
things like slash hashtag you know like
some routing angular whatever the only
thing you need to do when you are done
with your login UI you have to call a
controller in the in the server-side
application that sets the cookie right
and when the cookie is set you direct
back to do to the return URL that we
give you and that's it all right yeah
any other questions yes
no because they are actually mandatory
by the protocol right but what you
rather I would do is you would in in the
client middle where you know the the
opmod reconnect middleware has these
events thing here so you can say events
equals you know new open ID connect
events like this and then there's an
there is an on token received event and
then what you what you get here is on e
dot ticket taught principal baby the on
token received event runs after the
token has been validated but before they
hand over the control to the cookie
middleware - sighs - to issue the cookie
so what you can do is you can just take
the principal take the claims you want
throw away the others and just let it
throw flu and then and then then you
only get the claims you really care
about and you have the same option with
the baby is but in fact the baby is it's
not that terrible but here you want to
save space in the cookie problem yeah so
that that that would be that data
brochure there were other questions
some people erased and no good then we
on time thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>