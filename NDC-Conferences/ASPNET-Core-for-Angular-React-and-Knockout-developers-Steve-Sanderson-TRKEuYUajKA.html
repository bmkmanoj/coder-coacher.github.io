<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ASP.NET Core for Angular, React, and Knockout developers - Steve Sanderson | Coder Coacher - Coaching Coders</title><meta content="ASP.NET Core for Angular, React, and Knockout developers - Steve Sanderson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>ASP.NET Core for Angular, React, and Knockout developers - Steve Sanderson</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TRKEuYUajKA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">you can have me yes you can excellent
okay great Wow good to see all you
people here today so I want to start
with a little convention that I usually
have at the start of these kinds of
talks I just want to know what kind of
technology choices that you people in
the audience are making how many of you
can you put your hands up are using some
kind of single page application
technology today angular react view okay
like 80 on 90 maybe percent people okay
that's quite reasonable that's why
you're here in this talk okay and so
specifically how many of you are using
angular that's fire sixty percent maybe
how many using react probably the other
30% pretty much anyone here use knockout
yeah okay about 20% of people excellent
okay brilliant
so I mean quickly introduce myself my
name is Steve and I work at Microsoft
and I'm on the asp net team and one of
the main focuses of my job is that I
meant to make asp net core a really good
platform for people who want to build
single page applications or other use
other client-side technologies so I
spent a lot of time focusing on that
partly developing technology that you
can use and partly just trying to sort
of investigate the problem and make sure
that you know we're doing the right
stuff and that we're listening to you
all and you know getting the right
features in the product now were any of
you here last year and came to a very
similar talk that I did with a similar
title yeah all right a good sort of 10%
of people were here similar talk last
year okay so for you people the first 15
minutes or so of this talk is going to
seem very familiar okay because I do
have to start with some of the core
concepts so I'm sorry you're gonna see a
bit of the same stuff but after the
first 10 or 15 minutes we'll be moving
on to some totally new stuff or things
that we've been focusing on over the
last year so this plenty of stuff in
there for you too okay
right then so what's what's the point of
all this well the point of all this is
that there are a lot so far it's been at
core developers out there who want to
work with these single page application
technologies now in this room it's maybe
80 to 90% of people but you're a bit of
a sort of self selecting group so you
don't completely represent averages we
think on average it's probably more like
50 60 percent of people
who use asp net core also using one of
these technologies of them which is
great people are generally pretty happy
about that but this tends to be a lot of
other stuff that you need to know at the
same time for example there's a whole
bunch of different languages that are
JavaScript or variations on JavaScript
or things that compile to JavaScript
that you need to know that's a whole
load of concepts there's also many
different ways of doing styling that are
in the mainstream today more concepts
for you there as for actually making
these things run in the browser for
compiling that sass into CSS or that
type script into JavaScript there are
various different build and bundling
tools out there and you may be using any
number of those then there's various
application architectures that are
starting to catch on in front-end
development you might not have even
heard of these that's absolutely fine
weren't really be talking about it today
but you know there's more concepts that
are out there that many people are
talking about
and finally there's loads of different
testing tools and technologies that
people are using so there's just loads
and loads of stuff going on so many
concepts that you are supposed to know
and that raises this question of well do
you really love that I mean is that
actually a great experience for you or
is it actually a bit bit of a pain
really trying to make sense of all that
stuff and when we talk to people they
generally say to us you know any
individual one of these technologies is
great on its own but the entire mass of
all of this stuff together is a lot of
stuff for people to deal with so we say
what can we do how can we help with that
and one of the most common things that
people want us to do is to streamline
this process of making your project
people ask us can you just put it all in
the box can you make it really nice so
that when I want to start my project
it's just there for me so that is a
major thing that I've been focusing on
over the last year and I'll be talking
to you about some project templates in
this talk that'll be the first sort of
20 minutes or so at this talk so we've
got project templates for the top six
single page application frameworks that
are out there at the moment and the idea
with these is to give you a really
streamlined and productive start when
you want to build a new client-side
application with ASP know core to
actually get these and use them you have
been able to do this using the
line with dotnet new for about 12 months
now but the cool thing that has changed
recently with the launch of dotnet core
2.0 SDK the top three of those templates
and now in the box with Visual Studio as
well so you don't have to install
anything special you just go file new
MVS and you get your projects right
there now that's good some of you I'm
sure in the audience are thinking well
that's all very well but I don't really
want to use your project templates I
want to build my own cool thing from
scratch and do all kinds of remarkable
and advanced things so yeah we've tried
to allow for that use case as well
that's quite important as we've designed
this stuff we've made sure it's very
straightforward to be able to get at the
internal technologies there so
everything that the project templates
used to accomplish the magic that I'll
show you exists in the form of a bunch
of new get and NPM packages which you
can use in a standalone way if you're
building your own custom kind of project
structure all right right then so how
are we going to spend the next 55
minutes of our lives we are going to
look at a few different things I want to
start by focusing on this most common
scenario of simply trying to get
productive building your own single page
application with a few different
technologies then after that I want to
move on to focus on web pack a little
bit web pack is quite important to a lot
of the stuff that I'll be talking to you
about and a lot of people either don't
really know what it is or they've got
misconceptions or they find it
intimidating or something and I want to
try and break that down a little bit and
make sure that you really know what this
web pack thing is all about and how you
can customize it and extend it in your
own kinds of ways and then finally for
the more advanced people in the audience
I want to look at one of the underlying
technologies and show you some funky
things that we can do with that but
we'll get to that in due course okay so
what topics do we have for this first
section building your single page
application well we will start not
surprisingly with getting started so
let's say that you want to create for
yourself a new single page application
with asp net core as the server-side
technology well like i just said you can
use Visual Studio to do that now as of
the.net core 2.0 SDK so if you're on
Windows
using the s then this is quite nice but
it's not the only way of doing it anyway
let's create a new project or I'll
pretend I'm going to I'm going to create
a new asp net core web application I'll
hit OK and then you will see that the
list of project templates now well it
used to be like this you used to have
these three boring black and white ones
but now if you are using 2.0 you get
these beautiful exciting colorful ones
which give you some single page
application goodness as well okay so
obviously we could build it make a new
project like that but people who are not
on Windows are not using vs are not left
out you can also do the same thing with
the command line so if you are on the
command line and you run net new then
that's going to list all these many many
project templates but that's too many to
make sense off so I'm going to just list
the single page application ones and we
will see that we are we have three built
in to the SDK like that by default
without having to install anything
special okay so that's three that's good
but there are a few more as well that
we're releasing out-of-band and that is
in a separate package that you can
install and the way to install the extra
project templates is the same that it's
been for a little bit we can say a
dotnet new I want to install let's say
Microsoft or ASP net cord or spar
templates and then you have to say which
version of it you want and um you would
do : : star which is this utterly crazy
syntax to mean the latest version that
there is okay and that would install it
if you had an internet connection which
I am not relying on so I I'm going to
install it from a local file that I've
already got but it's exactly the same
effect and now if I run dotnet news bar
again you'll see that we've got more
templates now we've also got a really uh
knockout and view in addition to those
other ones very good let's have a go a
creating one the showi I'm going to
create a view j/s application right now
so let's make a new site and I'll call
it my super app I like that sort of name
and we'll go into that directory and
then I will run dotnet new view and that
will create a project for us okay so
it's just restoring a little bit of
dotnet packages it's also
tells you that you have to run npm
install that's a unfortunate limitation
of the.net new command-line tool at the
moment we can't make that automated so
it tells you where there's massive
capital letters do remember to do that
if you're doing inside Visual Studio it
does do that for you automatically okay
so what has that done it's added a load
of files onto disk it's a bit difficult
to make sense of it like this so let's
switch into an IDE I'm going to go over
here I've already got a view application
which I created in exactly the same way
and here it is in vs code okay
what I've got now then well if you are
familiar with asp net MVC then you will
recognize most of this stuff we've got
loads of typical MVC stuff like we've
got controllers here we've got views and
that sort of thing and the main thing
that's different is that we've also got
this client app directory and this is
where all the View j/s applications
stuff is various different components
alright so let me just start that in a
browser so you can see what the running
application looks like before we see the
code in there and when that comes up we
should see that it's a pretty
predictable looking single page
application kind of design it's got
bootstrap that implements the layout
there it's got this navigation sidebar
here that does client-side navigation
and it's got some example components
here such as this one that's going to
fetch some data from the server and
render it in a table and also this
counter component which just counts how
many times you click on a button alright
so as you can see from this sort of
design the expected use case would be
for something like a dashboard or an
internet management site or that sort of
thing but of course you can change that
in whatever your way is just whatever
way you want that's just a default
layout now how does the code for this
counter component work well if you are
familiar with view j/s you will find
this very unsurprising it's written in
typescript so we are importing the view
libraries up at the top there and then
we've got a class to represent that
counter component we're using this
special annotation that view supplies
there to tell view that this is a
component that can be rendered in the UI
and it's got this current count property
that tracks how many times you've
counted and an increment count method
that will do exactly what the names
gests and then in terms of the rendered
HTML for that well here's the template
that produces that rendered HTML it uses
view syntax as you would expect to
display the current count value and it's
got a button that when you click it it's
going to increment the count okay for it
he straight forwards and predictable
stuff there okay so that is getting
started in the most basic kind of way
with either vs or with the.net new
command line right now what I want to
focus on for the next sort of 15 to 20
minutes is some of the features that are
in these project templates because you
might well be thinking what is the point
of this anyway because I could have just
created my own new MVC application then
I could have put view into it or angular
whatever I wanted why would I need to
use a special template
well the answer to that is that if you
want to have a modern and productive and
streamlined development experience and
you want your application to perform
really well in production there's quite
a lot of stuff that you have to do and
set up to make that work well and that's
what the template is providing for you
it's providing quite a lot of features
that give you a good dev experience and
ensure your application performs well in
production so those are the features
that I'm going to show you now and the
first one of these features is a feature
that we get from web pack and it's
called hot module replacement okay let
me just quickly show you what that means
then so let's just look at this code and
think for a second about how that's
going to get executed inside the browser
well we've got a typescript file
obviously the browser doesn't understand
typescript natively and we've got this
series of little viuda HTML files or all
separate little files again this is not
a concept that the browser understands
natively so for this thing to run
obviously the application has to be
built in some way it has to be compiled
and structured into something that the
browser can understand and so there's a
compilation process and if we left that
and didn't do anything else to help then
every single time you made a change to
your application code you would have to
then remember to manually compile it and
then reload in the browser and that is a
real waste of your time you could be
doing better stuff than thinking about
boring menial tasks like that and that's
what the hot module replacement feature
deals with it simply watches for any
change
that you make to your code and it
immediately recompiles your application
and it pushes the changed application
into the browser straight away without
even having to reload the page for
example let's say I change this file
here I'll change it to super counter and
then when I press control s here you see
that the browser is immediately updated
in the background and it's not just HTML
stuff I can change I can also change
code let's say I want to change this
current count so instead of going up in
ones it's going to go up in tens instead
then when I come over here and I click
this button you can see that it is going
up in tens and it's only takes a
fraction of a second for the completion
to go through because we keep a running
instance of web pack in the background
that is able to do a very fast
incremental build whenever it sees an
individual module change and like I said
it doesn't even have to reload the page
inside the browser which partly is good
because it makes it faster but also it's
good because it means that if you're
doing something else like you've got a
form that's half filled in or you've got
a debugging session in process or
something like that we don't have to
lose any of that State we can just push
the updated code straight into the
browser without having to refresh
anything okay so that is the hot module
replacement feature now next I'm going
to move on to show you a bunch of
performance specific features but before
I do that I want to switch over away
from this view project to an angular
project instead so we've seen view and
we've been editing it using vs code and
now want to do an angular project in
Visual Studio the reason for that is a
couple of these features I'm going to
show you a specific to the angular
template so that's kind of important and
the other reason for that is just for
the sake of variety you know we've seen
it in vs code let's see that the
experience is just the same in vs and
that everything works the same in both
of them alright this is the angular
project template and as you can see it
looks and behaves exactly the same as
the view one and the project layout is
again the same as we had before we've
got your usual MVC stuff and we've got
client app and then all the angular
related junk in there very good okay
first of these performance centric
features that I want to show to you is a
physical pre-rendering or server-side
pre-rendering to give it
more elaborate name and the idea with
that is that we can take your angular
components or your react components and
normally they only run on the client
their client-side code they run on the
client that's what you'd expect but
wouldn't it be cool if we could also run
them on the server if the server could
execute your angular in your a cube
react components then we could send the
pre-rendered HTML for the user interface
down to the browser and it could be
displayed before even has to fetch and
run any JavaScript now as for how that's
beneficial it's all about performance
it's about well perceived performance at
least it gets your user interface into
the users face very quickly much faster
than you would do otherwise so to
demonstrate that I'm going to show you
how long this thing takes to load
normally now when you create an angular
application by default we have
server-side pre-rendering turned on for
you automatically in order for me to be
able to demonstrate what effect that has
I've turned it off in this application
just so that you can see what happens if
you don't have it on and then I'll show
you what difference it makes when I do
turn it on so I'm in the angular
application now and I'm gonna hit reload
and I'm gonna keep doing that a few
times and you'll see every time I do hit
reload we get this word loading that
appears in the top corner and it takes
about one second or something to come up
and you might think well that's fine
that's not a big deal it takes one
second I think my users can afford to
wait one second for this thing to load
but in the real world it's probably
gonna take quite a lot longer than that
because in the real world people are not
loading your website from localhost
they're loading it over the Internet
possibly over a mobile connection and
also many of them are probably not using
very fast laptops they might be using a
slow mobile device as well so in the
real world it might take a lot longer to
load and to try and get a sense of that
let's throttle the browser down to 3G
network speed and I'm going to take the
CPU down by a factor of 10 just so that
we can see what effect that has as well
now how long does this take to load now
in a more real-world kind of condition
I'm gonna start it now and and we're
waiting oh we've got the way to loading
that's good but we are still waiting
that's still waiting and I am hoping
that it does finish soon
quite soon okay there we go finally it
came up alright that took about ten
seconds and that is quite a realistic
estimate of how long this sort of thing
is going to take or it would do if you
didn't have server-side pre-rendering
and you shipped it in development mode
like this thing is running right now so
ten seconds is obviously much too long
what can we do to make this thing load
faster well this is where server-side
pre-rendering comes in as one of the
first features and I'm going to turn
that on for us right now so I'm going to
actually I'm going to turn off the
throttling for one second I'll explain
why in a minute
and then I'm going to go to the place
where we control this this is index CS
HTML which is the res of you that the
that is hosting the entire angular
application it's all getting put into
this app element there and if we want
server-side pre-rendering on which we do
have by default when you create your
project we would have this ASP now I
want you to pre render this module
called main - server and what's inside
there it's a bit of bootstrapping code
that knows how to run your angular
application on the server so I'll hit
save on that and I come back and reload
and I'm just waiting for the application
to restart there and now it has
restarted let's get a sense of how fast
it runs when I throttle it in exactly
the same way as before I'm going to go
back to a blank page and I'm gonna start
it loading now and we'll see how long it
comes how long it takes to come up this
time and it's there in about two and a
half maybe three seconds I'm not sure
but it's certainly much much faster than
it was before now in the background
we're still loading the JavaScript and
running it which is not going to be any
faster than it was before but the user
saw your user interface much much
quicker so they are going to have a much
better perceived experience there and
that is the the real benefit of
server-side pre-rendering that feature
is available in the angular template and
also in the react with redux template
and it also gives rise to some other
performance benefits as well and the
next performance benefit I can show you
is a very new thing called HTTP priming
which we've just put in in the last
month or so and this is to do with
reducing the number of network which
Quest's that the browser needs to make
to show that I'm going to switch on to
this fetch data page fetch data works by
making HTTP requests to the server to
get a list of these weather forecasts
and then renders it and we can see those
requests if I reload here and we'll have
a look in the browser Network tab and
you can see that there are two xhr or
Ajax requests whatever you want to call
them we can own or this web pack one
that's just a development time feature
the one that I'm interested in now is
this one that's requesting API slash
sample data slash weather forecasts and
that is returning this JSON data with
all of the weather forecasts in it okay
so that is how this data is showing up
and it's a very common pattern when you
build a single page application but your
application first loads so your initial
UI comes up in a blank state and then
immediately it starts making some
network requests to the server to get
some data that it then wants to render
which makes total sense but it's not
very efficient because if you think
about it
we just did server-side pre-rendering
okay so when this was rendering on the
server it already collected all the data
that it needed and then he sent that
down in the form of HTML so when we run
on the client why should we be fetching
the same data again a second time that
seems kind of wasteful couldn't we use
the server-side pre-rendering in some
way to capture all the data that's
needed for the initial page load and
then somehow bundled that up so that the
client-side code could use it without
having to make extra Network requests
well that's what HTTP priming is going
to do for us and to enable that we just
have to configure that on a per request
basis by loading the data using a
different API and that works like this
this here is the source code for the
fetch data component I know it looks
like quite a lot of code but it's not
too bad we've got this interface here
that defines the structure of the
weather forecast data object we've got
loads of angular related boilerplate
that we can ignore up there and then
we've got this property forecast which
is the array of weather forecast objects
and then in the component constructor
we're using angular's HTTP library to
make a get request to this URL and then
we're using that as the resulting data
that we
bleh okay now if we want to use HTTP
priming then instead of using angular's
HTTP library directly we can use HTTP
with state transfer now what that is is
a very very simple wrapper around
angular's HTTP library so it's
compatible in every way with everything
that angular HTTP does
it's just layering on a small extra
feature which is that when it runs on
the server it captures the content
transfers that to the client and then
what when first loads on the client it
can reuse the same data without having
to refactor so I'm going to use that now
as the HTTP library that I'm making the
call through and I'll save that come
back over here and then I'm going to hit
reload again and we should see in the
list of network requests we've gone down
we were doing seven requests before
we've now gone down to doing six
requests and you can see that there is
no more requests to the weather forecast
endpoint on the server because we've
been able to pick up that data
automatically and if you wondering how
that state is actually transferred to
the client well you can just look at the
HTML source and you will see that after
all the pre-rendered content here down
at the very bottom we've got this big
blob of hard to read stuff which
provides information about the initial
page load and it's telling the
client-side code when you make your
first request to this URL here is a
response that you can use in place of
what the server would have returned to
you okay there are various ways you can
then control whether that data is reused
if the user never gets around and comes
back or whether you want it to fetch new
content or whatever you can control that
in various ways but there we go that's
the basics of HTTP priming okay now next
feature ahead of time compilation and
publishing what on earth is all that
well you can probably guess what the
publishing stuff is about this
application that I'm running right now
is running in development mode which is
not designed for runtime performance
it's designed for convenience for you as
a developer and the runtime performance
is not awesome so for one thing the
application is kind of massive if I do a
reload here we can see that the whole
application there is 1.1 megabytes which
is kind of
for a web page right but what is in
there then is things like the source
maps for all your application source
code which is pretty big and also all of
the code is not even minified so it's so
you know way bigger than you would want
in production also if you were to
measure the amount of CPU time that it
takes to startup which I'm not going to
but I have done it comes out on this
laptop anyway to take about 0.5 of a
second of just pure CPU time in order to
parse all the initial code and render
that initial UI ok so that's not great
what could we do to make that faster
well let's think about what the
application is doing when it starts up
what is this code running what are the
expensive parts of it one of the
expensive parts of it is to do with the
templates that we're rendering now I
just want to show you what form these
templates are when they get to the
browser so to do that I'm going to copy
a bit of a string from here and I'm
going to go to the sources tab and I'm
going to search for that string and we
will find it here in one of the compiled
JavaScript bundles and let's have a look
let's make this a bit bigger no that's
not okay so you can see if your eyesight
is adequate that this is how the
template shows up as far as the browser
is concerned it's a big string and
inside that string are all the angular
directives that are needed to make that
the template actually do something
useful
ok now that might seem reasonable
obviously the client-side code needs to
have access to that Templer and it needs
to know what all the directives are and
such in it but what's not really great
is the fact that it's arriving in the
form of this string because in order for
you to execute that it has to compile it
into something that can be executed or
at least has to parse it into some sort
of structure that it can do something
meaningful with and it does in fact go
through a sort of compilation process
there and that's a very CPU intensive
business that it's doing and also it
comes with the drawback that because
this string can't be statically analyzed
during compilation we've no idea which
API is that you might be invoking from
it so there's no possible way that we
could strip out any code that you're not
using because you might be using
anything we can't interpret that string
in any meaningful way so we just have to
and the entire application down and then
the browser has to do this client-side
compilation process so this is a problem
that ahead of time compilation fixes
instead of sending the template to the
browser as a string it's going to
compile it at Build time and then will
send it in a different format okay
now if you want to build your
application for production you can do so
in a couple of ways one of the ways you
could do it is using Visual Studio you
can go to its publish UI like that and
follow through one of these wizards and
that will do it for you the other way
you can do it is on the command line so
you can run let's see my angular app you
can run dart snare to publish
configuration release like that and
that's also going to produce a
production build of your application but
it takes about two minutes so I'm not
going to wait for that I've already got
a published version of this application
running locally on my machine and I can
bring that out for you it's on port 80
like that so when that runs it will come
up and it will look exactly the same as
before but this is now in production
mode so how is it different well let's
compare the size remember it is 1.1
megabytes before it's now gone down to
410 kilobytes ok so it's still a
substantial application but it's a major
improvement the main gains there come
from the fact that we're not shipping
source Maps and it's all fully minified
and the way you'd expect but also the
templates are now pre compiled and if we
want to see what effect that has let's
do the same thing I did before let's
find how this looks as far as the
browser is concerned at runtime so I'm
going to search first string one more
time and we find it here now this is
kind of hard to make any sense of
because what we've got now is the
templates been split up into all kinds
of strings and API calls and such so you
can see that that line of text here is
now a JavaScript string and it's mixed
in with all this crazy-looking code
which represents the actual compiled
template that angular can just run
immediately on the client without going
through any sort of parsing or
compilation process okay so that's good
but how much difference does this stuff
make well I've tried to measure it a
little bit first we'll start with the
effects on the page size as I just
showed you when you are running a
development mobile
you've got this roughly one point one
megabyte application that if you do a
production build but without ahead of
time compilation you just do the
minification stuff then it will drop
down to about half of that about 500
kilobytes and when you enable the ahead
of time compilation it can get a bit
smaller still so it takes about another
20% off and the main reason for that is
a feature called tree shaking which is
that because these templates are now
compiled it can be fully statically
analyzed by web pack and that's going to
take some of the code out any parts of
the angular libraries that you're not
calling can be just stripped out now I
know that 20% might not seem like a big
difference but of the original 500
kilobytes not all of it was angular in
the first place
so we're stripping out a bigger chunk of
angular then that looks like but also in
the real world you are going to invoke
quite a large portion of angular surface
area so you shouldn't expect it to
remove you know like a hundred percent
of it you're gonna still have all the
code that you invoke okay so that might
not seem super amazingly impressive but
it's better when we look at it from a
startup CPI CPU time point of view it
does take on my laptop at least about
half a second to run through the
application startup process in terms of
CPU time consumed if we do a production
build on that but without äôt then it
drops down a bit it drops down to about
400 milliseconds and that is basically
because the minified code is smaller so
there's less work for the browser to do
in terms of parsing gear it's it doesn't
make a big difference but it does strip
off a little bit however when we turn
ahead of time compilation on then it
drops down quite a lot more dramatically
drop down so about half of the original
time and that's what you should expect
right because we're removing a major
part of the application startup process
we're removing all the template
compilations so it should get a lot
faster and it does and that is a
valuable feature so that is ahead of
time compilation and publishing now
ahead of time completion is an angular
specific feature if you're using react
you might think hmmm I wonder if I could
do the same there and the answer is you
already are doing because react doesn't
have a concept of templates of strings
everything in react is already code so
there's no meaning to this feature in
the first place in react world but it is
valuable if you're doing an angular
template okay debugging yes that's
another thing that we all love doing
right let me just show you very very
quickly how that's going to work I have
got my application running here there
are a couple of different ways that you
can use a debugger with your application
the most obvious one is that you can use
the one that's built into your browser
so let's say I want to debug this
counter thing here I'm going to open
counter counter component and what am i
doing that's the one counter component
yes now as you can see we've got all the
source maps set up so that we can see
the original types it's type script code
in the browser you're not seeing the
compiled code you'll see in your type
script and then you can set a breakpoint
on that and then that breakpoint is
going to here and you can inspect your
application and step and everything all
in terms of the type script source code
so that's good
but one thing that people often tell us
is I don't want to do the debugging in
the browser I want to do it in the IDE
I wrote my code in the IDE why can't I
do it there - well the good news is that
you can that's very straightforward for
you anyway because this feature is set
up by default in the templates so if you
are in vs you set a breakpoint and then
you start up your application with a
debugger by pressing f5 then it will
launch a special instance of Chrome
which is configured to listen for
debugger connections and then when you
do the right thing you will hit your
breakpoints and again you can inspect
your application directly from vs and
that all works in exactly with it the
way that you would want getting all this
stuff to work together is a little bit
tricky to set up but that's the whole
point of these templates we've figured
out the details for you and made sure
that it just works out of the box right
last thing another one of everyone's
favorite tasks is tests how many of you
write automated tests for your
client-side UI code well guys more than
I want to thought that's like a quarter
of people no I'm sorry what is that
ah yes yes yes so many of the starting
points for applications do include tests
these days so that is definitely going
to to contribute to that ok that's great
good job and also other people good job
because you're probably making a
pragmatic business decision as well
and we're not judging anyone okay so if
you want to write tests then there are
obviously the many different testing
technologies many different ways you can
set it up and we have got one such
system set up for you out of the box
here as well and if you want to do that
then you can go to your command line and
you can run NPM test that is going to
start up an instance of karma which many
of you will have heard of it's the most
commonly used testing system for angular
applications and the way that works is
that it launches a real browser and it
runs your angular components or your
other angular services or whatever
inside that real browser we're not
seeing the UI because so it doesn't we
don't need to see the UI it's pushing
the tests into the browser over a
WebSocket connection executing them
there and then getting the results out
very quickly so we can see that it ran
our tests and it's executed to off two
of them and they're both passed you're
probably thinking what two tests did it
actually run I don't remember writing
two tests well let me show you we've got
two tests set up and by default just as
an example and they are tests for the
counter component and they are written
with chai the assertion framework and
karma that actually runs the tests there
and what it does in this case is we've
got a set of specifications for the
counter component and what it does is
before each of the tests is going to
create an instance of that counter
component and then do two specifications
the first one it should display a title
and the way that works is we will do a
little query over the Dom to find the h1
elements that's been rendered by that
template by that component and then we
will check that the text in that equals
a particular value that makes sense and
the other one is verifying that the
count feature actually works and the
count goes up when you click the button
and that works by finding the text
element that is displaying this count
and checking that the initial value is
zero and then it finds the increment
button it does a click on that increment
button it waits for angular to do all
its funky stuff in the background and
update or everything in the UI and then
it checks that the updated text content
in that element is now 1 which is nice
ok now another thing that karma does
which is pretty cool it's kind of
similar to the
webpack hot module replacement feature
is that it's watching you always
watching you waiting until you do
something and then as soon as it sees
that you've changed your code it jumps
into life and it's gonna run all your
tests again immediately which is quite
nice if you want to do your testing in a
sort of test first kind of way if you
want to do like test-driven development
let me show you a little example of that
so we want to add a new feature to our
application we've already got this
increment button on our counter need to
restart that okay so we've already got
the increment feature on our application
let's say that we want to also implement
a decrement feature because who knows
maybe you incremented the counter too
far and then you need to undo your
terrible mistake and go back to a lower
number okay so I can increment an hour
what to decrement as well but I want to
do this in a test first kind of way so
I'm going to start by writing some tests
okay let's say that we also want to test
also test decrement now like any high
quality developer the way that we're
going to write some tests is by copying
an existing test pasting it and then
making a very small or the smallest
modification we can get away with so
we're going to change this to a
decrement button and we're going to say
we expect it to have a CSS class of Dec
and we'll find that and then we're going
to click on this decrement button we'll
wait for our angular to do its stuff and
then we will check that the count goes
back down from 1 to zero
I haven't saved that yet and before I do
save it let me just rearrange my windows
slightly so that we can see what's going
on in karma world as well let's make
this go down to the bottom of the screen
ok so we can now hit save in vs and when
we do hit save you'll see that karma
jumps in and it says right you did
something I ran your tests again we
executed two of two but oh no one of
them failed now and you think ok why did
my test fail and you look through the
list of errors and you see cannot read
property click of null which makes sense
because we are trying to click this
decrement button and that button does
not exist so that's not going to work
let's go and add the decrement button to
our view to our template that so I'm
going to copy again the increment button
I'm going to change its class to Dec and
we will invoke them
called decrement counter and will change
the text on it to decrement and I'll hit
save one more time and we'll see the
test run again and oh dear it still
failed why did it fail well if we check
the errors we'll find out it's because
this method decrement counter does not
exist so we will go into our code and
yet again do more copy paste and we will
change this to decrement counter and we
will make that count go down by one now
I hit save again and this time array
executed to of to success so we've done
a new feature and we proved it with
tests ok and in fact in the background
hot module replacement has been watching
us all this time and updating stuff in
the background so without even reloading
we've already got our new decrement
button and we know it's going to work
right we've got a test that proves that
tests don't lie so we knew that was
going to work but I'm just checking it
manually to be sure ok right that is
tests and that is all the functionality
that I want to show you in these project
templates but now I want to talk a
little bit about web pack because web
pack is really central to a lot of the
functionality that I've been showing you
today but quite a few people are not
totally sure it more shows of hands
please how many people are using webpack
in somewhere today oh that's good that's
60% now ok that's probably like more
than doubling of the proportion over the
last year so excellent ok now what I'm
going to show you now is a bit of the
web pack for anyone who's not familiar
with web pack I want to walk you through
what this thing is actually doing and
how it differs from a different
client-side build system like grunt or
gulp because web pack is often thought
of as being in that family with grunt
and gulp but it is not it is a different
kind of thing it's fundamentally trying
to do stuff in a totally different way
and I think it's important that you
understand what that is and based on
that understanding we will then be able
to look at extending that build system
to do something useful for us ok to
understand what web pack is doing I
think we shall start by looking at the
web pack configuration file so I'm gonna
open up that right now and the first
thing you will think if you've never
seen that sort of thing before is oh my
goodness this is
hideous what on earth is all that stuff
we've got 84 lines of just mysterious
garbage and I don't know what any of
that stuff is well that would be a very
reasonable thing to think the first time
you see this Web configs are never
elegant but they are very powerful and
in order to understand it I want you to
just remember three key concepts all
right I'm gonna walk you through it in a
minute but the three concepts that you
need to burn into your brain are number
one that your web.config has an entry
point in this case the webpack entry
point is a file called boot browser dot
TS I'll explain what that is used for in
a minute but that's fact one fact number
two is that we've got some rules and
each one of those rules tells web packed
what to do with a particular type of
file and finally fact three we've got
some plugins and as for what they do
I'll tell you in a minute okay three
facts we've got an entry point we've got
rules and we've got plugins what does
all that do for us then okay this is
what web pack is doing when it runs it
starts with your entry point which in
our case was a typescript file and web
pack itself does not have any native
understanding of typescript so in order
to use it we used to use a typescript
loader which is something that you can
get from NPM now you can have loaders
for all kinds of different files in web
pack and they do two main things the
first thing they do is not surprisingly
they deal with compiling that file in
some way or put converting it into
whatever sort of output format that
particular loader wants to produce so in
the typescript loader case obviously
it's going to do the types go
compilation and produce JavaScript so
that's the first thing it does the
second thing it does is it explains to
web pack how to detect the dependencies
on other files so that web pack can know
that this typescript file for example
might reference another type script file
so the typescript loader tells web pack
about that dependency and then maybe
you're on the time script file
references some more typescript files
and their reference and some more and
you end up with this big dependency
graph of typescript stuff but that's not
all because your typescript files mind
also representing reference something
else like a JavaScript file and that's
what we've been doing all along so far
when we reference angular for example
angular is shipped as a NPM package
which contains JavaScript files and
that's what these types could file
our referencing and these they will be
loaded by the JavaScript loader which
tells webpack how to detect more
dependencies for example two more
JavaScript files which could even be in
separate NPM packages so again you could
have a chain of dependencies that runs
through a set of third-party NPM
packages and webpack knows how to find
all of that but it's not just code it
might seem surprising but you could even
have a dependency from a typescript file
on something like an HTML file for
example if you have got an angular
component which references an HTML file
as one of its templates and again web
pack does not understand that natively
but you've got a loader that tells web
pack what to do with that and how to
detect the fact that maybe it depends on
a CSS file which could be loaded with
the CSS loader maybe it depends on
another CSS file through an import
statement and maybe the other CSS file
references an image or more images and
there are various different ways that
you can tell web pack to load and do
useful things with images depending on
exactly how you want them to be bundled
and output and if you are totally mad
you could even go further and create
your own completely custom type of file
and as long as you implement a
corresponding loader for it that tells
web pack how to detect those
dependencies and what sort of output
format you want then all of that stuff
is going to work as well so this is one
of the core differences between web pack
and something like a grunt or gulp is
that it's not just processing all the
files in the directory
it specifically understands all of the
dependencies among your files and that
allows it to do some pretty cool stuff
so what does it do with this big graph
of information about all the structure
of your project well it takes all that
and it makes it available to all of your
plugins and the plugins can process that
graph of information in whatever they
want and for example they might do stuff
like they might say well after the thing
has been compiled I'm going to transform
the code if it looks like JavaScript I'm
going to minify it or maybe they're
going to change the structure of the
graph all together so that they inject
things like ladies lazy load and Lady
lawyer don't know what that would be but
lazy loading and that would mean that
when the user goes to a different part
of your application than a certain
bundle could be loaded on demand so
plugins can do whatever they want and
after they finish doing their stuff then
pack can emit the resulting files to
disk according to however you have
configured that okay that's reasonable I
know it doesn't explain the config
syntax but you at least understand
conceptually what web pack is trying to
do with your stuff okay so that's
conceptually what web pack is doing and
now you know that it's not completely
crazy to imagine that you could even
edit that web pack config yourself in
order to change the build pipeline and
do something new let me give you a
little example of that let's imagine
that you have implemented this counter
feature and you've got your in command
and you've got your decrement and you're
very very proud of it indeed and you
call a meeting with your board of
directors and you say look at this
awesome feature that I've implemented
it's gonna be huge customers are gonna
love it
and they say yes it's brilliant we love
it - we're gonna do a massive ad
campaign we're gonna make billions from
this counter think but there's just one
little problem
the little problem is we don't really
like the graphic design of it very much
it looks like it's been designed by a
developer we're not really into that
sort of thing we need to make this thing
look funky so we're gonna go and hire
the most expensive graphic designer we
can and they are gonna give you an
amazing design that you're gonna plug in
and so this graphic designer comes along
and they look at it and they say hey
I've made this amazing design for you
it's gonna be awesome people are gonna
love it I'll send you the design it's a
SAS file and you think oh yes SAS I've
heard about that's what's that thing
that's like some sort of styling thing
isn't it yeah I'll pretend I know what
that is and they'll send you the SAS
file and you'll go right what I'm gonna
do with this thing now I need to somehow
get this sass file to work inside my
angular application so let's add a suss
file in here I'm gonna add a new item
and I'm gonna call it styles dot SAS
right and then I'm going to put in this
amazing design that we've got a great
expense and it's gonna be work like this
I'm going to define a variable called my
call and that's gonna take the file
being read and then I'm gonna say all
the elements are gonna have color my col
okay that's my design it's going to be
great people are gonna love it all right
but how are we going to make this work
how we're going to make it apply to the
counter well we'll go into the counter
code and if you know angular then you'll
know that the way to apply a style is to
use this style URLs thing here and so
I'm going to say the styles that we're
applying to this component here are
Styles sass all right now
I haven't save that yeah but when I do
hit save and go back to the browser
we'll see the hot module replacement
kicks in and it says ah no this is not
gonna work you're trying to load a sus
file and I don't know what that is you
may need an appropriate loader to handle
this file type okay so our list of rules
does not include sass and web pack does
not know what to do with that so you
think all right somehow I need to make
web pack understand sass how do I do
that and obviously the way you're going
to do that is you're gonna go to google
and you're gonna type in web pack sass
like that and what Google is going to
tell you is that you need to install the
sass loader and so you will go to the
command line or use some IDE or
something like that and you will type in
MPM install save sass loader and that's
going to fetch and make the sass loader
available to anything that wants it in
your application and then you can go to
your web pack config and you can go to
the list of rules and you can say okay
I'm doing something that looks quite
similar to CSS so let's start by copying
that and we will make a slight
modification for sass and it's going to
do all the same stuff that we do for CSS
except I'm also going to chain an extra
loader on to a course SAS loader now web
pack loaders can be chained as I've just
hinted each web pack loader is only
responsible for one thing the SAS loader
is only responsible for converting sass
syntax into CSS so once you've got it in
the form of CSS you would then want to
push it through the CSS loader so that
web pack can detect the dependencies on
all the CSS files or other sass files
and then finally in this case we're also
pushing it through this strange thing
called two string load up
that's an angular specific thing because
angular when it gets your Styles it does
not want them in the form of a file it
wants them in the form of a big string
and that's what the two string loader is
just going to convert that into a big
string for use in the application
alright so I'll save that and I'm going
to restart my application to pick up the
updated web pack config and this time
hopefully instead of getting the you may
need an appropriate oh that
okay I'll save that let's just restart
that one more time this time instead of
getting the error about you may need an
appropriate loader hopefully our Styles
will actually be applied so I go to
counter and we can see it's worked it's
great it's all turned red and and that's
gonna be great
the other cool thing about web pack and
the way these features work is that they
all compose together very nicely so even
though sass doesn't know anything about
hot module reloading I can use the two
things together so if I go to make a
small change to my sass file let's say I
change it from red to green then when I
press save
then in the browser I will see it
changes to green straightaway and it's
not just green it even works with other
colors too like a purple for example
just as an example all right so we've
got sass added into our application and
that worked very nicely okay that's
extending our build system right oh now
I want to move on to the final part of
the talk where we go behind the scenes a
little bit and think about how the stuff
actually is working internally and what
you could do if you wanted to use some
of this infrastructure to do some cool
and advanced stuff on your own and this
is where we bring up the concept of node
services so various points during this
talk I have been using features that
rely on being able to execute JavaScript
on the server for example the
server-side pre-rendering your
components are obviously JavaScript
things well they might start as tyo
script but it's JavaScript at runtime
and so to run that on the server we need
to be executing JavaScript on the server
similarly web pack itself is all made of
JavaScript so in order to be able to
doing that stuff and wires peanut into
web pack pipeline it's been very useful
to be able to run JavaScript on the
server side too but how can we run
JavaScript on the server when we've got
a dotnet back-end well that's where node
services come in and in fact the
application architecture looks a little
bit like this you've got your
application that's been generated by one
of these templates or that you've made
yourself and that is relying on a nougat
package called spar services that
provides a set of features that are
useful for building any sort of single
page application with whatever
technology you want so that
implements such things as the ability to
do server-side pre-rendering the ability
to integrate with various bits of web
pack stuff and also the ability to
integrate a server-side routing config
with a client-side one I didn't talk
about that because it's just far too
boring but you can just have a happy
feeling and knowing that that feature
exists even though I'm not going to show
it to you all right now how does this
work how is sparse services going to be
able to run JavaScript on the server
well this depends on yet another new get
package called node services that
doesn't know or care about single page
applications all that cares about is the
ability to run JavaScript on the server
and as for how that works you can
probably guess from the name it works by
using node.js so node services knows how
to create a hidden instance of node.js
whenever it needs to and it knows how to
do very fast remote procedure calls into
it how to structure all the requests and
get the responses back out it knows how
to do all kinds of fiddly annoying stuff
like dealing with errors that might
occur it knows how to do process
lifetime management so if stuff crashes
and knows how to bring it back up that
kind of stuff that you don't want to
deal with it just encapsulate all that
so you can simply use JavaScript
directly in the middle of your asp net
application on the server if you want to
okay but why would you want to do that
we've I've given you some examples of
why it's useful for doing server-side
pre-rendering and webpack but are there
any other scenarios when you would ever
want to use javascript well you might
think no I do not want to use JavaScript
because I've got c-sharp and that's a
perfectly competent language why would I
want to complicate my life by
introducing JavaScript as well well the
answer to that is npm npm node package
manager is the largest collection of
open source packages in the world there
are millions well not literally there
are a very large number of packages that
implement everything you've ever thought
of everything even thought of a fact
implemented in 15 different ways and you
can have fun picking out which one of
those is still going to be maintained in
one year okay
assuming that you're able to do that you
will be able to use whatever NPM
packages you want in your application
and I want to give you an example of
that now so I'm going to switch over to
another application this will be our
final demo application this is not a
single page application this just just a
regular bog-standard it's that
expression by the way over here
bog-standard
yeah okay good good right it's a
bog-standard asp net application not a
single page application and I
to implement a bit of funky stuff to do
with image recognition all right this is
the problem I want to solve I want to be
able to implement a feature where users
can identify things because people have
got lots of objects in their life right
and they don't know what many of these
objects are so wouldn't be cool if they
could hold the object up to their webcam
and then the computer would just say
here's what that thing is for example
they could hold up maybe their hand and
we can click on what is this and it will
say ah it's not implemented yet okay so
the client-side code has sent that
picture to the server and the client is
expecting the server to respond with
some JSON describing the object but the
server is not responding with JSON yet
it's responding with this silly string
here okay so I want to put an
implementation of this in place but to
make it a little easier for us to see
what's going on I've also got this test
page here and that just allows me to
select a predefined image and then
upload it in the same way and we can see
directly what this response from the
server is which in this case is that
little string so why is the server
responding with that string and not with
a useful JSON object well if we look at
the code it will all become clear this
is the embassy action that we're running
in this case we're passing the image to
the server as a base64 encoded string
and we're supposed to return JSON but
we're not we're just returning this
string here okay so I want to put in an
actual implementation of this now and
I'm sure it won't come as a surprise to
you to hear that in order to do this
image recognition I want to use some
neural network deep learning type of
thing and if you want to do that well
there are a few neuron that word library
is available for asp net core but not
very many it's still kind of early days
there whereas in NPM there are dozens of
the things not just loads of neural
network libraries but also even things
like pre train models that you can use
for stuff like image recognition so
that's what I want to do right now I
want to invoke an NPM module so in order
to do that and need to be invoking
JavaScript to invoke JavaScript the way
I can do it using node services works
like this first I'm going to say from
the list of services that are registered
I want to get an instance of I node
services okay and then when I've got
that I can invoke some JavaScript
and yet I can say no services please
invoke and it's going to be able to
invoke some javascript code and in fact
what I want to do is this I'm gonna say
alright the node services I want you to
invoke asynchronously some JavaScript
that's in a file called recognized dot J
s and I'm gonna pass you the image is
this base64 encoded string and you
should return the result to me as a JSON
string object and then instead of
returning this message I'm gonna return
that result back to the client now this
is all asynchronous I mean waiting it
here in order to make this compile I
also have to mark the method as async
and so it returns a task of I action
result great alright so I'll save that
and then we will go and try that shall
we
I'll go back to the browser and I'm
going to go and I'm going to upload the
same image one more time and we'll see
does it run some JavaScript for us when
the application starts back up and the
answer to that is no it does not because
error cannot find module bla bla bla bla
bla cannot find recognize Jas okay that
makes sense we've told it to invoke
recognized ojs but there is no such file
so let's create that right now add a new
item which will be a JavaScript file
called recognize EAS okay and then I can
start putting some JavaScript code in
there and initially what I'm going to do
is just return a hello world kind of
message so I'm exporting this function
here and it's going to construct a
message using javascript code and then
it's going to invoke this callback to
send that back to asp net and i'm saying
there's no error here's the result it's
just this message so I'll hit save on
that and I'll go back and I'm going to
send this one more time and this time
hopefully we will actually invoke some
JavaScript now okay that's good so we
can now call JavaScript directly from
the middle of our c-sharp code and it
works nicely the fastest robust great so
since we can now run arbitrary
JavaScript in a real node environment we
can use arbitrary NPM packages to
implement whatever functionality we want
and in this specific case I want to use
something called caress j/s Kerris is a
fairly respected neural network in deep
learning library and in
I want to use it with a pre trained
model called squeeze net squeeze net is
trained in order to do object
recognition so I can take that and I can
say right Kerris I want you to predict
what is in this image that I've supplied
by means of this base64 string and
assuming that succeeds then I'm gonna
send a call back with a JSON
representation of the result saying what
is in the image and if there's an area
then we're going to pass that arrow back
to SP now as well alright so let's try
this I'll go back and I'm going to send
this image one more time so I'm gonna
send this image of the beer and we'll
start that and it takes a moment for the
application to come up but when it does
hopefully we'll get some actual results
back and we can see that with a 92
percent probability this was a beer
glass also with a 2 percent probability
was eggnog whatever that is I don't know
but anyway that's cool that now seems to
actually work so let's try this shall we
let's try it with the webcam so I'm
going to go okay what sort of objects
could I recognize well let's try one of
these let's see if we can recognize
something like that so I'm gonna hit can
you identify that and we will say that
it is oh it's a remote control or maybe
a cellular telephone okay so that did
actually work which is nice now I could
really use a service like this okay
there are many scenarios in my life
where I could use this for example
whenever I go to software conferences I
keep finding these very very strange
things in the hotel rooms in the
bathrooms specifically and I do not know
what they are or why they keep putting
them there or why I'm supposed to want
it so finally I might be able to get an
answer to this question ok what is this
things that I keep finding it is a
toilet tissue ok that doesn't really
answer my questions but at least I've
got a word for it now I can follow up
with someone else and find out what
those and finally let's try recognizing
me shall we so Karis is trained on lots
of pictures of objects and pictures of
animals but not on pictures of humans so
if I track and try to recognize myself
let's see what it thinks I am I
so does it look like I'm wearing a
shower cap I mean I find that quite
offensive to be honest with you all
right
anyway so what's the point of all that
it's not specifically because I think
the image recognition is a particularly
important scenario or that you know
that's something that you necessarily
should do the point of it is that you
can use arbitrary third-party NPM
modules in the middle of your SP no
application using node services and that
creates a lot of opportunities for you
to do all kinds of cool new stuff all
right so that is all we are going to
have time for in this talk to summarize
for you we started off we spent the
first third of the talk talking about
project templates or rather the in the
box streamlined experience and all the
features that are available for that how
you can create that using either dotnet
new command line or Visual Studio and
then we got into some web back stuff how
you can configure that then we looked at
the internals of how this stuff works
how you can use the underlying packages
like spar services and node services and
I hope that is useful to you in some way
so if you want to learn more you can go
to this github repo that's where you'll
find all the code for everything I've
shown you today that is all the project
templates are in there all of the
implementation of node services and spar
services and stuff is in there so you
can go and have a look at that and you
can post some issues and start telling
us how you feel about it and how you're
getting on with that and yeah so that's
all we have time for
please remember to evaluate this session
as you walk out of the door that's very
useful to everyone and enjoy the rest of
your conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>