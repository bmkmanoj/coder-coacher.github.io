<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building real-time API's with GraphQL - Sandeep Singh | Coder Coacher - Coaching Coders</title><meta content="Building real-time API's with GraphQL - Sandeep Singh - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building real-time API's with GraphQL - Sandeep Singh</b></h2><h5 class="post__date">2018-02-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8brpq7DdFIs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right morning everyone how we all doing
you ready for the second day of NBC
right
my name is Sandeep and today we're gonna
have a look at building real-time api's
with the graph QL before we have a look
at what we're gonna cover today and the
agenda so one a quick couple of
questions just kind of get a gauge of
where we are in the room has anyone not
heard of Bradfield before coming to this
conference one it's pretty good too bad
okay so is anyone using it or how to
play around with it
anyone use it in production wow that's
pretty good
it's impressive usually it's not happen
so let's have a look at the agenda so
this talk is essentially split into two
so the first half we can have a look at
what graph QL is what problems it solves
how to build a graph QL server and then
look at some of the core concepts and
the second half will kind of look at the
real-time aspect of graph QL and how
subscriptions fits into the landscape
when you're building these real-time API
guys so let's start with the ultimate
question what is graph QL well
essentially graph QL is call is a query
language for your API it gets confused a
lot with being a database language
because the QL and people think it's
like sequels but it's actually not it's
actually query language for api's so
what do we mean by a query language
we're api's well here's an example so
with the buzzkill you essentially
describe your data which is basically
your API to me and you do this via the
type system that's built into graph girl
and then you can query graph QL to ask
for a specific set of data so in the
middle we have a query and we're going
for some patient information its name
and there's an identifier with some
arbitrary string and at the right is the
response and the most important thing
about this example ultimately is is that
the query matches the same shape as a
response and this all happens in one
single network request from client to
server and that's essentially what graph
QL is its call
so graph QL is built on a spec and it's
a standard so it's not limited to
JavaScript the demos that I'm going to
do are in JavaScript but there's sangria
which is a Scala framework which is a
very popular one which with one of the
first actual implementations there's one
in net there's one in jabbers willing
pretty much every language we can think
of a graph girls hierarchical in the
sense that you have an object graph and
the nested associations with them its
client driven in the sense the client
dictates the shape of the query and
basically that's what they get back in
their response so they're kind it's kind
of like client driven development a lot
of the stuff is moved from the server
down to the claim and graph girl comes
with a type system so a strongly typed
and each graph QL server has its own
specific application specific type
system so why does graph QL exist it's a
good question because there's various
other technologies when you build an API
is this all there is rest there's
multiple different ones so if we think
about one we're building api's today and
we think about all the challenges we
face because now there's a lot of mobile
devices with multiple platforms and
everything needs to be efficient and
work on lower bandwidth networks
ultimately so we have things like
efficiency is along the lines of how
much data we actually go back how many
requests it take to get out of data then
we've got things around prick'd ability
do we expect the data back in the same
shape is it what we actually asked for
then we are versioning and if you think
about versioning there's various
different ways when do versioning
ultimately if you can need to stick to
evolution but you'll see stuff in the
headers and you'll see stuff against the
URI
there's caching how'd we do caching what
is it using the network layer do we have
network caching you all or we using the
application server to do our caching for
us and then we've got things that aren't
secured to link documentation and
various other things
now you can see this quite a big list
and this is not really all of it and
these are the kinds of things that we
have to think about when we're building
api's so let's have a look at an example
do we have any Game of Thrones fans
who've I've got to be honest I've
already just started binge watching a so
you probably
all ahead of me on this one but this is
an example of a screen where we have
three components so in the middle we
have like a character's love information
so it's Jon Snow and it's got this
gender and this culture and there's born
and then we have and allegiances and
then we have the books that they've
actually appeared in so it seems to have
all three components here so
interestingly enough does anyone know
about this API I have ice ice ax fire
it's basically a great sir it's a REST
API that tells you everything about Game
of Thrones so there's three end points
there's books characters and houses so
if we think back to our example for our
character information and we'll use John
snows as our character so here's our URL
and this is a day that's actually
returned if we have a look at the
payload in itself there's a lot of data
there and if you think back to our
screen we don't really have that much
data so this is this is the concept that
we call over fetching and it's when
we're getting too much data from the
server and we only this small part of it
and this is not really good if you want
to build efficient api's because a lot
this stuff will just got waste and it's
gonna cost people's bandwidth either way
so there's other characters but
interestingly enough we have the books
that appear in and the allegiances so if
we have a look the allegiance is is
actually another URL that we have to go
to gets information we don't actually
know what this information actually
looks like we know that this is how we
get to it but we don't have an example
said it to contain the book's title
author and so on and this is a concept
that we call under fetching it's where
we don't get enough information that we
need and then we have to make subsequent
requests to the server to go back now
this is very common if you use in the
hypermedia constraint of rest the bear
you get implementing that the more this
happens because you deal with state
transitions more often so if we think
back we've got three potentially calls
that we've got to make for our data and
we've got books and then we've got the
houses so that's not exactly the best
kind of user experience it could it's
gotta go over make multiple calls so
there's ways to solve this so if we
think about the URL we could do an
includes so depending on which framework
you use or if you roll your own or you
have me to concentrate you can have
something called data inclusion or I
could say okay give me the books as well
as the leader says now that that kind of
my spelling is terrible but that kind of
gets around this problem but at the same
point you still have problem of over
fetching and you can add some you can
add fields in you can have spatial field
sets which allows you to do this so
there's another Mexican so you can use
but there's no real standard there's
various ways you can do this how this
siren there's probably a few other ones
if you've made a REST API before with
hypermedia constraint implemented so
it's kind of like it's a bit difficult
so if we think about this and how we
could actually change it and how is how
would this work from a graph girl's
perspective well actually if I say API
there's actually a graphically old
version so this is not graph QL this is
called graphical so this is an ID that
sits next to your endpoint and it comes
with all implementations and it's
basically allows to run queries against
your graph to your server and on the
right we have some documentation which
is basically all the types that arm
system which we kind of briefly
mentioned at the start and we have this
is how we can query stuff so if we now
think back to how we wanted to get our
data character five eight threes John
snows ID actually makes a little bit
bigger and we can see we can actually
have these nested objects on the left
for their leaders connection the book
connection and we can get all this
information in one request but secondly
we can get only the information that we
need so for our supreme you don't have
to over fetch and we don't under further
so this is a good example of something
to api's exist the both public there
open source you can we can view in your
own time if you're interested so yes
this is kind of leaked highlights the
fact of what graphic yoli's so if I run
this query just want to point out
something interesting that happens
of the network just increase this as
well is it everyone see the bottom was
it bit too small I can make it bigger so
if you look at the bottom this actually
our graphical works just a little bit of
context is that actually posts to your
graph to your server so this is side by
side and can see that it is in the
actual body in the pair Lord we have the
query which is what we're interested in
and then we have some variables
I just want to give you that just for a
little bit of context cuz we're gonna
see that more in action later
so now so graph QL solves ultimately the
efficiency issue that we have it helps a
lot with them so you can think of
Brockville as this translation layer
that sits in front of your business
logic or your services behind and it's
in single point of truth so you don't
have multiple endpoints and if you're an
extended you can add objects to your
graph and that's how you go forward with
it and so each the difference now that
each channels so we've got mobile
desktop they can get they dated their
need in their shape and however they
feel fit there's no custom endpoint I
don't have to include anything on the
queries there's nothing I have to do
extra the developer and now as you can
see you can actually solve these in rest
I'm not saying you car but the finger
with graphed well it's an opinionated
set of packages which does this for you
so it kind of wraps a lot of this logic
up so if you're interested then that's
one of the use cases of it so what about
versioning so how to talk too much about
versioning in terms of gradual because
graphical doesn't really it says inside
one of the best practices is not to
version your API so what allows you to
do is it allows you to run it forces you
to follow the evolution and what we mean
by that is over time we will add new
fields to our API and they will
deprecated old fields and then once
these deprecated all fields are no
longer in use we can remove them and so
ultimately we're not going to break our
contract or our queries that people are
running against the API so there's a
special directive this is called so this
is a type and we have this deprecated
directive and what this actually means
is is that new clients will actually see
this in terms of when they query so
the intelligence of graphical they will
actually see this but existing clients
will so the power of having this
attribute or directory that's called is
that you can monitor usage of the
queries so the query comes in and you
can inspect the actual payload that
comes in of what the query is and you
can say ok they keep using this
deprecated fields and you know which
clients using it because you know which
kind is calling it so all the time it
comes very easy to manage and this is
one of the real plus points about having
something like this is kind of baked in
so that's what how it helps with version
II so what about the tooling and
developer experience because ultimately
as developers the developer experience
is very important we don't want tools
that either slow us down or make us do
extra work and we can achieve it with
other technology in a simpler manner so
graph curl is built on something called
introspection so if you think back to
the graphical editor that we solved the
ID that is built because of
introspection so because of
introspection you can build tools and
what we mean by introspection is if the
dining-table developers who've heard
reflection it's essentially like
reflection of your types and can
understand the whole schema so you can
query everything the whole structure
what operations you can do what queries
easier what types out what types of the
fields are the strings are the boolean
so on and so forth so this is really
really good for building tools so I saw
a graphical was built like that but you
also get things like autocomplete and
you can validate a compile time because
you know what the schema is so one of
the important things is code generation
because you can query the schema imagine
you have a you're using the c-sharp
implementation you could query your
graphical endpoint and generate types
off the back of this you can generate
c-sharp classes because you know all the
types and what the fields are it's
saying we can do with typescript so
there's actually a code generation
package that is available it's in the
resource at the end if anyone's
interested I can talk you through that
there's one for various different
languages and also we briefly saw the
documentation and you get documentation
for free but there's a caveat to this
documentation ultimately if
documentation is good for developers it
loves to inspect the types and so on and
so forth but doesn't take away the fact
about proper documentation for your API
it's often confused too that it says it
gives you this documentation which is
fine but it doesn't tell you in this
documentation you not going to put
things about rate limits
and what is the usage of these APRs and
explanations about how to do off my
authorization and authentication and so
on and so forth
so this is really good for developers
money can add descriptions to your
actual types but it doesn't take away
the fact that you need proper
implementation so now we've got an
understanding of what graph Google
actually is and what kind of aims to
solve then I just want to look at some
of the core concepts before we build
actual graphic real server so I've
actually broken these down into three
different areas so we have a type system
and we have a schema and we have a query
language so the type system is the way
we define our domain it's essentially we
can define these types in this schema
definition language is what it's
actually called and if we the first part
is a type is that's how we donate and
then we give a name and as you can see
there's various fields in this type and
they all have a value in sense of their
fields have a type so do you have ID the
special field which is essentially like
your primary key and you have string and
then medications is one that I've put in
myself and any a boolean and you can
make your own scale are types as well so
it's not limited just to the ones that
are already built in and there's various
if he's in JavaScript and various
packages in NPM for like dates and extra
one because it doesn't give you a date
one at books
so if our type system defines our data
model a schema then defines how we can
query our graph as ultimately what the
schema is it's a specific entry point
into the word that we can query and if
you look at the top we have a query and
it says basically we have a patient and
we've passed it a variable say have ID
and it's an integer and it's going to
return type patient and then we have
this schema property which says
basically it has to well as 3 root
values but mandatory one is query so any
graphical server that you build has to
have a query as its root type but
there's other ones such as mutation
subscriptions but they're optional but
the actual query is mandatory so what
the scheme actually gives you it gives
you a contract between your client and
your server ultimately exposes the
capabilities of your API and that's
essentially what a schema does so we've
got a type system where we define our
actual structure of our Dale and how we
model it and what schema I've said how
can we actually query this data what we
actually do with API so where do you
actually get any data route of this so
how how does that magical piece come to
play so there's something called
resolvers and resolvers each field on
one of the types has a resolver and
resolve it at just basically wait and
run arbitrary code has three parameters
there's the object which is a parent
object and there's some arguments which
we'll see what they're used for on the
same with a context object are going to
end the demo a little bit more detail
but ultimately this is where you
actually say okay go to my database go
to my API go do any mapping that you
want this is essentially the core of it
so that's how essentially graph your
works you have you type and then you can
resolve each type and then you have a
scheme which says okay this is how we
can actually query in what operations
that we can do so the query language as
a whole is the core of what graphical is
so there's three operation types one is
queries which we've seen which we can
send the query and return some data back
mutations allow us to write data but all
we always have to have return type when
you write mutation so it reads data as
well and then subscriptions is when
we're gonna see a little bit later on
which allows you to build these
real-time event driven systems there's
some other key features about the query
language which are pretty cool you can
have aliases so you can run multiple
nested queries in one query block so for
example with our John Snow in the
graphical we're just actually for John
Stoll but actually if we alias that and
they'd search for another packed with a
different ID you can run all that in one
request and it comes basically in the
same chef that you asked for which is
really good and this fragments and
fragments will see in the demo as well
ultimately what fragments allow you to
do if you have an application where
you're building a bunch of components
and you'll have a lot of queries which
is similar and a lot of equity to have
similar fields in them like say a
patient has name and you're referencing
that in many places fragments allow you
to snap that bit of logic out and share
it across there basically all queries so
you get sort of a duplication so it's
really useful for that so now we've got
a night being like an example of the
core concepts let's actually dive into
building something useful so for some
context I'm just going to
increase the font on this one but I'll
go through so the context that we're
actually going to build is an electronic
patient record system so we're gonna
have a patient view which has some
information about the patients and some
summary information and some information
about the medications that they're on
and some information around their
current encounter and then we're gonna
have a like a list view that shows
patients on a specific ward and they see
this is the database structure for it
I've already pre-loaded it with some
data so let's get started
so this is a structure of our
application I'll make it a little bit
bigger so there's a client
it's an angular client this is it's just
I think it's using angular for from what
I remember and an application we have
various components I'm using Apollo
client which we will talk about a
clients for graphical API is a little
bit shortly and then we have our server
which is basically a graphical server so
this kind of structure you have like a
server file which loads and stateÃ¶ api
and then you have your graph QL schema
which is currently empty and we have
separated our resolvers so it's
basically easy to manage so as we go
through this I'll explain more about the
structure of this because having built
quite a lot of API so a graph QL I found
this sort of pattern and this sort of
structure very easy to kind of work with
and it allows you to unit test stuff and
if you're working in a fairly big team
it's easy to manage so the first thing
that we want to do is I've installed all
the packages already because of flaky
internet connections usually served on
up front
so I've imported all the basically
dependencies this graph QL graphical
Express so the first thing that we want
to do is basically make it run so all
we're doing here is we're just saying
when we get to the for such graphical or
graph QL and point we pass in our schema
and that's that's really about it and
then we're setting the endpoint up for
graphical and so if you do four slash
graphical that's what you're going to
get with that ID so the first thing that
we want to do is actually add in our
schema so we're gonna use a schema
definition language if you've seen
online
there's various ways to ultimately two
ways that you can do this there's an
object type version and the screen
schema definition language by default if
you can use a schema definition language
because one it's very readable and it's
very easy to snap out into smaller
components and secondly it was designed
initially by Greta by the initial
reference implementation designed object
graph types that you saw in JavaScript
just to get the project out ultimately
but the schema definition language is I
would advise you to if you can use that
this I have about any differences in
either of them and using both and
there's no real limitations so what we
have here is we have a type and then we
have an ID in patient IDs got some
fields on here
it supports enums so I've got an enum
here and to add comments you just put a
hash and I'll come in the documentation
and we've got one query here which says
basically get the patient past an
identifier the exclamation mark stands
for is mandatory and the return type is
a patient and this is just what we're
passing to our schema so now we've
defined our type and a schema
all we've got left to do is add in the
resolver so how we gonna get this data
so this is the interesting bit so as you
can see hopefully this makes it a little
bigger as you can see all I've got here
is a plain JavaScript object I'm not
calling the API I'm not calling the
database I'm not doing anything
like I say beacon different arbitrary
code in here this is all resolved as are
so this three Frommer's is an object
which is a parent object and we'll see
that one is we have nested associations
arguments is we'll pass in the Agnes of
the query so we said a patient ID I'll
pass that and I'll be a property on that
and then we have this context of it
which is a special object which is
passed every time we make a request so
if you want to pass in something like
the viewer or the authentication token
or things like that that's where you
store that information and that's passed
on every request so ultimately all we
have here is just basically a plain
object so we've done everything apart
from actually map these resolvers so
when you use this schema definition
language you have to
provide the implementation so if we step
back and go into this schema so there's
a tool called graphical tools and it
basically makes your schema for you in
this make executable schema so we
passing the schema which we defined
which was the graph QL file and we
passing the resolvers and the resolvers
we have defined for patient and this is
a resolver map we call so this literally
maps to your query so you can see it's
got the same name patient so actually
what does it when it's actually running
makes executable it basically matches
our name and because with enums
generally you can have either
strings of value or even have in those
numbers you can put them on the route
type of your resolver because they're
not actually in your they're not
assigned to a query or anything so
that's how that will reference that so
in our database it might be 0 it might
be 1 and that's what the field we expect
so if we run that and then go back
so here's our API and if we make a basic
call now we can see we get back the data
which is just basically hard-coded and
ultimately that's all graph QL is that's
if you understand that you've pretty
much crushed all of or is is pretty much
rinse and repeat it's very similar for
mutations it's very similar for adding
in like a database or a back-end which
we're going to do now but this is a core
principle this this is a very simple way
to stand up an API so if you're
interested in building stuff in like for
rapid development it's really really
quick to stand up like a fake end point
so this is definitely a real neat so
next let's make it a little bit more
meaningful actually read from the
database so ways a sequel like in
supplication so the first thing we're
going to do is add in just a query so
all we're doing is reading from the
database and we're passing in the ID
these are just some helper methods at
the top which will see used a little bit
later so that's how a database and
ultimately resolved oh should be kept
small and if you don't really directly I
don't think talk to the database in the
sense he should have passed a context to
it you should have an intermediary so a
good way is having models and they kind
of these models act as your kind of
controller between it like your mediator
so impatient now we can add basically
all adding disease is a new class and
it's got some information how you can
constructor a patient and it's got a
static method on we're getting by ID so
now what we need to do we need to
actually update our resolver to call
this
so as you can see we're passing actually
in on the context now so it's context uh
patient don't get by end up get by
identifiable so if we go back to our
server we actually have to pass that in
in our schema for every request and
we'll see that so what we're doing here
on every request it will pass this
context object in and we're just
basically creating the object and
passing in our model for patient so now
if we go back to our application if I
just quickly set up the database so all
we're doing here is we're just opening
the connection to our sequel Lite
database and then start the application
and so if we go back now if I run this
just actually see this chain just query
slightly so that's the first record in
the database John - no and that's
essentially how you you can work with
databases it's fairly simple it's very
trivial if now if you wanted to in your
model change the actual static method
that we call to get the patient you
could call an API at that point you
could just have static data you can
pretty much do anything it's literally
as long as the data's returned as in the
ship they expects it then generally
that's all you have to do so what about
next to dissociations because for this
example we have basically just a patient
field but we don't have anything that's
related to the patient so a patient in
our system will have medications and it
will have an admission as well because
they're an impression so if we go back
the first thing that we will do is we'll
add
nope wrong file
so all we've done here is now we have
two new fields on our patient
what is medications and there's a new
type for medication which has some
proper person fields on it and then we
have an admission which has some more
fields on it and the square brackets
essentially mean that this is a list and
we have an argument that were passing
they were going to limit this to not get
all the information which we can pass in
we can get one two three
or we get ten depending on what we want
so now we defined our type let's
actually do what I said I was going to
do add a query to getting set of
information out of the database so now
all I've done is basically add a way
that we're going to read out of the
database to get the patient admission
and the medications and what I'm
actually going to do is I'm going to add
a new model in for the medication and
this is how we return it this is the
method we're going to use I'll do the
same for admission and now if we go back
to our resolvers we need to resolve
these so let's remove this
so we've added in two more resolvers
we've got one for medications and one
for admission and basically these are on
the context and this is how we get them
but we have to still provide to our
resolve a map for now so this is this is
where some magic happens and it's
interesting to know what happens
actually here so previously we had our
query and our query matches our schema
and says what patient but as you can see
there is a patient and it's called
medications and admission so the way
this resolver mapper works is because on
our patient schema we had medications
and admissions as fields to access those
fields when it actually resolving or to
find out what the types are then we have
to map them so ultimately this is going
to when it runs in the actual scheme
it'll be patient medications so that's
why I have an object that says patient
and their medications an admission in
the names match and that's how it kind
of works out which of your types to
resolve it's pretty clever but it seems
like a little bit of magic but once you
Garrett it makes a lot of sense so now
we've added that and we've just Altima
tada one more thing to do we have to
pass our new models into the context so
we get access to him so fulfill that and
now go back we clear this now if we run
this query you can see that we have some
medications for a patient and we have an
admission as well and that's how you
work with nested associations so I'm
passing in a limit of 5 so just to test
it it actually works I'll pass in word
and you can see it'll just limit that so
that's how you can do things like if you
want to limit like the number of
information that's brought back you can
do paging that's how you pass in
variables and that's how you structure
it so we've got this API now but what
would this look like from a UI
perspective and how do we hook a graph
QL API to a basically a UI so if we go
back to our code base
firstly just to save a little bit of
time we're going to switch branches
let's die again
so all I've done here is to switch to a
more up-to-date branch and because we've
seen how queries are done I've actually
added in a Ward query now to show us
they're like a ward view so if we go
back to our schema we actually have a
new war type and we have a new way to
get this ward basically passing the ward
code and then if we just look at our is
over we now have a way to get ward here
and then this we've get this is how we
do the mapping of the patient's so if we
just double check that all works and
then we reward you so now we can
actually have a look at the UI so this
is just a very simple angular
application it's using Apollo client so
a little bit about clients the first
thing about clients is if you using
graphic world dot roll-your-own the
problems that you're going to solve have
already been solved there's a palo on
this relay or the two big ones if you're
interested in react and you're going
down that pathway you should definitely
look into relay it might be part of your
actual project in might work well but
generally apollo client works with react
or what's an angular works with all of
them it's not specific and to basically
get an iOS version as well but clients
as a whole allow you to query graph QL
API is in a very simple way they can be
convenience methods to query mutate and
do things that subscriptions but also
one of the problems with graphic QL is
its caching so instead of solving the
caching yourself the client does a lot
of this discussion for you it basically
gives you a normalized cache which is
essentially if you had a few query the
patient five times it along will be
stored in this store once it's just a
flattened structure of the day of and
I'll show you that in the UI because
there's a prom plug-in called Apollo the
second part of a but that shows you the
store and it shows you the cache that's
very useful when you're debugging and
really want to run queries in the
browser so that's a little bit about
client so all we're doing this client is
we're pointing it to our graphical
endpoint and we're basically adding a
network interface and we're just going
to inject this into our constructors
where we're going to use it so before we
do that
let's have a look at some of the queries
so graph QL tag is just a way of writing
a query gives you an abstract syntax
tree and we're going to pass this to
actually our method to query so
interestingly enough we was talking
about fragments so here's an example of
a fragment so I've defined fragment with
patient the first name surname birthday
identifying gender and because we're
using this information in various places
I can use a spread operator to basically
expand and basically choose these fields
because on the ward view we have a list
of patients and their information and on
the patient summary we'll have the same
sort of information so instead of
duplication you can use fragments to do
it they're very useful for this sort of
stuff and let's have a look at this
actually from a UI perspective and see
if it's running so in our board view we
should have a way to query so all it's
doing is the pollak line is passed in
we're using a watch query and the ward
query is what I just showed you and the
variables is taking the ID from the URL
and it's passing this in as a ward code
and then once we get some information
we'll get the ward and we'll get the
ward patients back so now if I go back
to the UI and see so we've made one
query there here to get the actual
patients on a ward and we click through
we can see this a little bit of
information about a patient but the
interesting part is about our saying
about this plugging is that if you have
a look here in Apollo you can actually
run queries and if you look at what's
actually in this store the stores is a
cache of what we've actually made a
query about so this is a very useful set
of tools that you can use forward
especially when you're doing development
and debugging so you can run queries
it's just what queries that you actually
run
there's no mutation to determine run
only but it gives you this inline
graphical editor that you can query
instead of having your own one up and
running so it's definitely useful if
you're debugging because it saves a lot
of time when you look in what the state
of the stories so let's go back to our
application so we've seen that we've now
got a UI and we have a no decent
understanding of what
queries are so let's have a look at what
mutations are so in our system an
example mutation would be we want a
discharge of patient and they want to be
basically off a ward and queries and
mutations are very similar in that sense
they'll have a resolve function think
about mutations are that you will always
return to back and this could be a
simple value for an integer or it could
be a complex type so let's have a look
at this in our schema we need to define
what this is gonna look like so all we
have here is important so the difference
the main difference between queries and
mutations are is that we can pass this
input object in which is like a complex
type instead of having single variables
and this is useful when you you can add
other fields with other complex types
that you've created yourself and it's a
really neat way of passing all the
information basically on one property
and what we do is we're returning this
payload called discharge patient payload
and it's essentially just a lot of
information about the patient below so
something that you might want to
consider when you're doing this is is
not directly returning the patient
information to straightaway in the sense
that assigning a mutation to the patient
because if you put a class or type in
this case like payload in you can add
custom properties on like if there's any
errors and if you think about how you're
going to evolve your API over time it's
very easy to work with the structure
like that because you can do additions
easily if you fix it to the patient type
then you're kind of stuck with it you
can't pass any extra information at a
point so it's just a little bit of
hindsight it's kinda having to look at
it and having a separate object always
return now in this scenario for our
payload we could have a field which is a
patient we could return the patient type
in that and we can have a user errors
field and various other ones but I would
always try to structure it without
returning the same type as the normal
query does and ultimately don't return
just a single value like in horrible
and all some people recommend it but
again you you're in that same scenario
that if you do that you are fixed for
that overtime once you change that
you're going to break someone's
implementation and the whole point is
graph QL it's supposed to evolve we
don't want to kind of snap people's
implementation for their country using
in the wild and start having different
versions so we've added our mutation
into our schema so let's just add our
database query in how we're going to
return this so all we've got is a query
that runs and it deletes it from the
table and then I return just the
important usually when you return a
value you probably best off reading from
the DB at this point I've just read from
the basically the day that's past thing
because it's just it's a simple way of
doing it but ultimately you want to
double check if you seen actually the
database so now if I did that what we
need to do is go to our patient and we
can add a convenience method that allows
us to discharge and I will need to
resolve of how we're going to do this so
again it follows a similar pattern on
the context it's on a patient and it's a
method called discharge and we're
passing in the input and that's the
input that we feed in about the
information the patient that's getting
discharged so once we've done that we've
got to add that to our schema so we can
add that to our schema here
so you can see now we have a mutation
and we have a discharged patient which
then that marries up to the same naming
convention that is in the actual schema
graph cool so now in theory if we go
back to our application so don't annoy
us on that ward so let's go back to our
editor and let's just actually brush
this and let's discharge so this is how
we basically write it there's an input
type and it's just an object and we feed
in various of the the fields that were
interested in and then we're going to
return the encountering patient ID so
that is that so if we go back to our UI
if we refresh Johnson or is no longer
there anymore it's detached so
essentially that's mutations they're
very similar as you can see the queries
are pretty easy to set up but there's
one problem but I don't know if anyone's
noticed here is that this is one of the
caveats for graph QL is if you implant
in a very naive way with your
associations your queries are pretty
horrible and you'll hit the database
multiple times so for example I'm going
to clear this out of here in this
console do you want to do that I want to
clear it so we've run this again now if
we go back to our UI and if I have to
request this page again don't snows back
because it don't really Davis rebuild
every time so but have a look at this
query that keeps running so I have one
query to get the patient information and
then I've one query to get the ward but
how many times do I call the same query
over and over again for each patient and
that's because we have a nested
Association and one of the big problems
is if you don't think about how you're
going to design your system up front
your nested associations will run very
very slow because you don't know how
people are gonna use your API and this
is one of the things that people say
about is graph Koken improve the
performance of your system if anything
I'll make it slower than your REST API
our only API they put them because
generally you have a thing
TenPoint and that'll do some data return
to fixed dataset but because you can
query in any kind of way that your you
exposed via your API if you don't care
about your associations you will get
many n +1 queries and many too many
queries all the time so you have to be
really cautious with this but there is
something that you can do to solve this
and it's called data loader and data
loader is a concept which exists in most
graphical implementations the one I'm
gonna use the JavaScript form but the
idea is that in a specific event loop it
will keep track of all the IDS that you
make and I'll batch all those IDs in
toward and then you can run one query
instead of running multiple so how this
works on principle is this query is
basically going off the patient ID so if
I could have an array of patient IDs
it'd be make admit it make it a lot more
efficient so the first thing I'm gonna
do is I'm going to change how the query
actually runs
I've actually got a del Darren Storr de
Lawd it's actually a package which I've
already put in so if we go to the
admission so now I'm basically feeding
in a bunch of IDs and I'm using an in
statement of all the IDS in the just
comma separated instead of getting one
by one and all this is doing on the
return type is basically batching up the
admissions to the right persons and dry
persons admissions and giving you an
object back that's ultimately all that
does so what we have to do though is
something slightly different we have to
put our date loader in so this is how
you and every request you want to create
a new instance update a lot of
ultimately it does it does batching
first but it does caching as well and
what means by caching is every time you
make a request and you may be requesting
multiple say the same patient in a
single request it puts it in a cache so
you have to keep hitting the database
every time and it does that by default
you can turn the cache off so this is
why we create when every time because
you don't want to share that information
across everyone using your system
because if it's in a cache they're gonna
get out of that day off basically and
you don't want that so this is how you
instantiate a new data loader and it's
basically I'm passing in a bunch of IDs
it's always going to do is it's going to
look on the event loop and when it
comes to assert period it's gonna say
okay we are bunched all these 10 IDs or
how many patients what we have I'm gonna
pass this now to this get admission
method which is just our convenience
method to go to the database so what we
have to do though is we have to change
our loader here so we have a mission
so now we're getting the from admission
and we're doing an admission loader and
the do not load and this dot load will
basically please object is passing the
patient ID so it's just going to group
up a bunch of patient IDs so now if we
go back to our app we should see if I
was to refresh this nothing no that's
not entirely correct
so let's see what missed
yes good job someone's watching so we go
back to our application in terms of the
server I can now add in the missing
component right
this isn't yeah that's kind of kind of
gone wrong slowly so let's fix that
so now what we've done we've set the
admission to point to the loaders and
that's just passed in again on the
context so let's clear this out let's
rerun this now if we go back
that's much better we have three queries
instead of I think 12 or 30 so you have
to be very cautious about how you
structure your data otherwise look great
for the user and they will get the
information they need but when your
query and your back-end engineers will
be like this is worse than what we had
before and that's ultimately what we
don't want to do so let's go back to the
slides
so I've already mentioned some of the
challenges that you face around graph
curl because it's one of those
technologies where it's old with all
this great assets in the sense that it
can help you an efficiency and so on and
so forth but actually there's a lot of
problems it does have one yet for you
trying to use in the real world it's not
a straightforward it's just okay we can
use any salts all our problems it
doesn't so some of these challenges are
one of those unpredictable execution is
what we saw when we saw the nested
queries and we got the n plus one this
is a challenge you have to look at
upfront so I advise people to put like
telemetry for your queries in either on
the back end or your resolve functions
to keep a track of what is actually
going on because ultimately you won't be
able to solve any performance problems
without them and there's various tools
that you can do with it
the other one is graph QL doesn't handle
file uploads you can't do a multi-part
HTP file upload or anything like that's
a trial don't even think about using it
it's not designed for that stick to any
of the RPC oh you arrest whatever you
want to use work
graph cool as we've seen in the one of
the early things I want to show it in
post so it's no longer at important so
we don't have a concept of caching
anymore with a rest-based API you have
you can leverage HTTP caching making
these very can use headers there's
various things that you can do or we can
have cache servers like varnish or
squiggle that sit in front
they like to cache there but you can't
do this regret curl so this causes a bit
of a problem so ultimately there's a
couple of ways around this you use a
client and that client that client will
cache your information as and when
needed but on the server you have to
think about how you're going to cache
are you gonna put a cache in front of
your business logic are you going to
cache at the database level you have to
think about these things because
otherwise the problem that you're gonna
have is every time you're just going to
hit the database are you gonna hit your
endpoint and if there is doesn't change
so often that is not really much for
benefit that you're going to get in
terms of performance or anything because
you might as well stick to using a
difficult REST API
it doesn't really help you in that sense
and the other thing that haven't really
talked about is authentication
authorization and ultimately graph QL
doesn't care about this there's it's not
bothered is there's has a context object
and you can pass the
the JWT token whatever you want into it
but there's a video that I've got on the
resource at the end from graphic real
summer which shows you two or three
patterns of how if you want to do
authentication or off the reservation I
advise you to watch that because it's
taken I think from how the way Twitter
do it it's very informative and there's
different patterns that you can use so
I'm not gonna go over that into much
detail but as a whole it doesn't really
particularly care about it's just it's a
thin wrapper over your API ultimately
what you want to expose so what about
real-time data so now this is the second
part of what I wanted to talk about so
up until this point if we think about
what we've seen we have queries and we
have mutations and we have this very
simple request in response model we fire
some dairy off to a server and it gives
us some something back
always we fire someday after survey
there's some sort of mutation on a side
effect and then we get some data back
but with real-time day is is very
different we want to have like an event
stream over time so we might get a
result in the next five minutes or the
next twenty minutes or the next half an
hour I'll get multiple ones every second
it doesn't follow the same pattern as
the request in responsible and one thing
about graph QL is that it's transport
agnostic you don't have to use HTTP all
the demos will be HTTP but you can use
WebSockets and I've seen people use
mutations over WebSockets they've seen
people do queries over WebSocket so you
can choose any transport protocol which
basically allows you to do a character
data set so that's why you with a graph
curl you can support real time because
it's agnostic to its transport layer so
what are the some of the use cases of
real time information so a typical one
to chat so everyone's used to things
like whatsapp slack and various other
bits in various other applications and
then we have things like notifications
so if you think about a good example is
Facebook and like people saying
someone's like your post and so and so
forth same with Twitter and retweets
we have collaborative tools which is
kind of like online coding tools and
things like them and we have live feeds
so get a live feed just simply things
like if you think about the Guardian
website or the BBC and you're watching
you're waiting for an important event
and it updates all the time with what's
the latest happening so these are kind
of the use cases that we kind of see
with real time applications
so real complications can be categorized
into kind of two areas and it's
basically one called pollen water called
push so Paul is a very simple scenario
which we've all seen which is basically
just polling HDTV spec it's been around
for a long time and it's very simple and
it can solve a lot of your problems
generally if you have an application
where you know how often the date is
refreshed and it's quite cheap to query
that it's very easy to set up on the
client side some more thing to Paul you
don't need anything else that I'll just
work for you don't have to anything
fancies it's a great solution still it
comes into play when you're Daria's kind
of you don't know the time periods and
you maybe have an expensive query
running every time then it's not so good
to be using it but the common one is
pushed so we're all used to push
notifications as a whole so people who
have iPhones and Android phones you'll
see notifications from I box up and
various other things they're all based
on push notifications they pushed it out
when something's happened when it's an
interesting event it'll send you saying
okay this has happened so in graph QL
there's actually two ways to do
real-time API is what I want to cover
subscriptions live queries is kind of
experimental at the moment they spend a
lot of packages if you want talk to me
afterwards about that I can show you and
pointing to the right direction of those
but that's not in the spec yet fully so
what live queries are is kind of like
it's like cheap polling ultimately stay
driven so has anyone used firebase
before or meteor there's reactive layers
in meteor on this firebase has a
real-time database that's ultimately if
something changes it can fire stuff out
but the difference is between live paid
subscriptions the ultimate thing is is
what you have with libraries is you
don't care about why that happened if
it's a change we just want to listen to
it
we're with subscriptions that gives you
the final control is like you understand
why that happened because you have a
payload in the event you knew why what
the reason for was for that so the two
different scenarios in the soft kind of
two different problems so that's what
subscriptions ultimately are they're
event-driven they're not they basically
allow you to subscribe to like it's like
a query of data and then over time you
will get like a multiple number of vents
back so we have a look a bit a little
more detail query
subscriptions actually uh so they're
based on real-time events so the idea
that I just mentioned was if something
interesting happens
tell me about it and tell me why that
happened and ultimately client we find
the ship of the day that's pushed to it
and what we mean by that the if you
think about what the query was like
subscription is very similarly changed
subscription at the top to the from the
operator keyword and essentially you
define the day that you want when it's
pushed to you and that's ultimately what
happens so you define the data shape
again it's very very similar so that's
the ultimate premise of how it actually
works under the hood currently is the
implementations that pubs are based in a
spec it doesn't say you have to use
pub/sub but if you look at any packages
available currently generally the
premises that a lot of people using pop
up the pub sub pan and the publisher
subscribe so when do you want to use
subscriptions because ultimately
subscriptions for real-time data your
application generally will not be built
entirely on real time daily not always
only a small part of your application
potentially might be real time that you
want for instance you might have a
screen that fits in a filing system
where you want to keep up with stocks
but the rest of the information in the
stock itself or the address and so on
self aesthetic that didn't have to be
real-time so one of the use cases is
when the initial query is quite
expensive but the subsequent following
editions all the events that happen are
small so the incremental changes are
small so that's a very good use case of
it so a typical example in graph QL is
you can set for query by itself to blood
the data initially and then you can set
a subscription afterwards say okay just
keep updating my stall with this
information that comes in so that's one
of the use cases and the other one is
when you actually care about stuff in
ultimately real time you want a low
latency update so for chapped locations
say if he's using slack you don't want
to wait five seconds for your actual
message to come through you expect it to
come through in a reasonable time frame
when that day is pushed so how they
actually implemented so on the left of
this diagram in pink we have the typical
model of what graph QL is currently so
obvious request response and we have a
graph QL API and we have a domain which
goes off and gets our data so we can use
queries and mutations on that side and
that's how we work with crazy mutations
on the right we have two new components
ultimately the first one is because we
want real-time information we have to
have some way of delivering that
information so one of the way it is we
have this bi-directional transport so
the typical examples using WebSockets
but you can use any bio-dad tional
transport it's not limited to WebSockets
so you need to kind of create a
connection on the server as well as a
client to say okay now we have this
connection I can tell you what's
happening and then you have your the way
you handle subscriptions and so it's
pub/sub based there's the one I'm going
to use is an in-memory collection so
never use that in live because you'll
fall over completely it's not designed
for scale but for down purses it's
perfect but in the real world you want
you something like Africa radius r mq QT
and then we have our events so the
structure what happens is is that for
instance when we have a mutation say
when our patient wants to be discharged
we might want to update our UI to say
remove them from the list because it's a
real-time patient ward we don't want to
see them on the list anymore because
it's not valid so in a mutation that's
an event that we care about we will
basically say okay publish the fact that
we've actually done something and we've
reaction has been discharged
so now whoever subscribe tell them about
that and pass them the information
they've asked for and that's that's
ultimately how it works so this is the
architecture of Basin from a javascript
point of view these are some of the
packages are available so on the client
you can use the same script in transport
which is a WebSocket it works with just
plain old vanilla JavaScript relay and
Apollo client in the middle we have the
actual server so you have your same
transport layer and then you have
subscriptions so I'm going to use an
in-memory package which is a graphical
subscriptions one which is pub/sub based
but there's Redis the post breast and
Mongoose non-employment but there's
Kafka there's mqt there's a few other
ones it's quite a few there's now
currently and then you have your
reference implementation and this is
generally how the structure is so what
what you can do is and we'll see you
later in the client is you will have in
when you're on the client you set up to
certain levels of transport you set one
for HTTP which follows out queries and
mutations and then we have our
subscriptions which run over WebSockets
and we'll go into that in a minute
so let's have a look at another example
just to kind of like hammer home the
point so imagine we go back to our UI
the top we have our patient view and the
discharge button now which currently
doesn't exist but on another screen a
nurse on award actually has a view of
the wardrobe and they once you load that
page they said okay and want to
subscribe to any patient discharge
events so what happens is someone else
wearing the hospital discharges the
patient so I will click on the button
and then we run the mutation as normal
on the server but the mutation itself
actually triggers a subscription that
says okay this is actually happened this
is how it's happened for and why I'm
going to send you this information and
what happens is it will discharge the
patients always no longer see the actual
patient at the bottom anymore and this
is a general high-level view of how it
works we'll see in principle that
changing we need to make from a code
perspective of how it works but this is
generally how subscriptions work
currently so if we go to our demo now
what I'm going to do is I'm going to add
the subscriptions in now so the first
thing that we have to do like with any
of this so let's close all this to make
it a bit clearer is in our schema we
have to define our subscription so now
what we have we have on our scheme we
have queries mutations our subscriptions
and we have this concept of ascription
called patient discharged and we have
this ward code about which war they've
discharged from this is going to be very
important in a minute and I'll explain
why and then we have the event that we
care about and that is just here all
I've got is basically a return back
encounter ID and went to about the
patient ID and that's all we have so
that's how we do our schema but in the
same way we have to change our mutation
so we no longer just basically remove
the patient
so now it's mutation is slightly
slightly update so I'm gonna quickly
waster this because we're nearly out of
time we are our time bow quickly whiz
through this so essentially we have this
discharged patient and what we have is a
pub/sub and this is the the return type
of what comes back is what we're going
to send to our basically our subscribers
so if we go have a look in our
subscriptions that's actually first
resolve a function in so again our
resolve function and after groceries
quickly is that we have this pop song
it's an iterator and the topic we care
about is it discharged and we have
basically if it's this ward code because
you don't want to send it to any just
any old user we want to send it the
people who subscribed by that ward
because you don't send to ward 23
because that patient does exist on there
so that's how you said that description
up in terms of this resolve function
then we still have to update our resolve
mapper and the sense that the
subscription patient discharge there and
now a subscription uses this pub sub
framework so built-in memory one he's
just basically on top it says patient
discharge and we do this pops up so now
if we just go back to our UI for a
second yep all we have to do is change
our server to support
so I've updated this server file and
ultimately is a new subscription server
and this runs off WebSockets
so I'm gonna go through this quickly but
all this code is available on github so
anyone who wants to go through it can't
so ultimately how you set the server up
so from a client's perspective all we
have to do is add in our query for our
subscription I actually would change our
client first so our client supports both
web sockets as well as HTTP so now we
have WebSockets client here and then if
we go to queries we can add our query in
which is basically how we set up a
description where it's very similar to a
query what we want to return is
encountering the patient ID and now all
we have to do is in our ward view is
register that subscription and this is
how you register a subscription it's
just like a query so we have our normal
query at the top and then we set up a
subscription mode to subscribe to one or
more events and all we're gonna do is
remove from the list basically the entry
that's there so in theory if this is all
worked if I reset this and I was to go
to discharge its discharged and oops the
user is gone and if we just refresh
there won't exist hi the works the
database is rebuilt unfortunately but I
just want to show you quickly the
subscription so you can look in the
frames you will see actually how the
subscriptions set up on the lifecycle or
subscription so we can see it's in its
in its payload and it's subscribed and
that's generally a very quick overview
of how to set up subscriptions because
we kinda rack time so one last thing is
that you can enrich payload each
resolver the cue subscription you can
change your payload the return type that
you get back this in advanced scenario I
probably haven't used it in anything
useful yet but if you ever need to
change payload that comes back
you can do which is pretty useful and
there's no such thing as a free lunch
because subscriptions are stateful and a
managing state is hard
you can't just scale your server like
you would with an API import another web
server in and put beyond do a lot of
bouncing off you go because you have
connections long-lived connections
between your clients and the messages
that we're sending so you have to manage
that and so you need to think about
distributed load and then you have
quality of service at scale how you're
going to manage the number of events
that come through which take priority if
you look think of example I cook there's
millions of likes and there you
subscriptions and they use the same
platform how what takes precedence how
many messages come through how big is
there like two why they could come
through can the client actually handle
them so you have to think about
throttling and buffering and how you can
organize your events and then these are
some of the resources the authentication
ones are bottom the the leap RM one they
want to learn more about subscriptions
the event and may have how actually
works it's an event system definitely go
watch that the slides will be up repos
small on Twitter and unfortunately did
run out of time with that but anything
else thank you and just ask me
afterwards</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>