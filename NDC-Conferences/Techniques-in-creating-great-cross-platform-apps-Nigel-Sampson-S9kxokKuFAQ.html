<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Techniques in creating great cross platform apps. - Nigel Sampson | Coder Coacher - Coaching Coders</title><meta content="Techniques in creating great cross platform apps. - Nigel Sampson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Techniques in creating great cross platform apps. - Nigel Sampson</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/S9kxokKuFAQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to technics and creating great
cross-platform apps
so I just want to set this thing to
start with about kind of the context of
this talk and what we used to think
about as applications kind of started
out on just the iPhone right just small
mobile apps probably just consuming an
API and some content but since then apps
have gotten wider and wider right we
have devices like tablets which you know
but more attuned to like creating
content and since then things like
Windows as well as Mac OS now have an
app store you have more more complex
larger applications and now we're also
seeing things on TVs like Apple TV Xbox
and sometimes even more esoteric devices
such as hololens so we've got this kind
of wider range of apps we want to
devices we're gonna target apps towards
also this ends up meaning we want to
probably target multiple platforms
depending on if you're mobile you're
probably looking at just Apple and
Android and if you're kind of hitting a
more wider range devices like desktops
and TVs you're probably also gonna want
to bring Windows into that so xamarin as
a tool sets probably one of the best
ways to do this in terms of hitting all
of those sort of frameworks and devices
and we're gonna comment a bit of what
was ever as quickly just to get a bit of
a recap but also we're gonna look at
something around mvvm so this is a
presentation model pattern and what I
found is as applications get larger and
larger the view models team to kind of
bring that code in and we're gonna look
at some ways about how we can sort of
reduce complexity within these apps so
that's kind of the basically the gist of
this talk we're gonna look at a quick
recap on xamarin mvvm you know just make
sure we're all got a good baseline of
what we want to talk about we're gonna
look at what's new and B is 2017 for
sharing code some are new tools and
techniques there and then the world just
to the stalk which is around how we can
reduce the immortal complexity as there
are apps get larger as they move from
just consuming an API and more that sort
of content creation so Who am I
my name is Nigel Sampson I'm a tickly to
push pay a payments company in Auckland
New Zealand I'm the project lead on
calibre micro which is a crop
cross-platform in the in framework
funny enough and I'm an MVP for Windows
platform dev there's my Twitter and
github panels if you want to catch up
with me later on so let's get into this
what is xamarin zamarons a tall set
which lets you work on Android iOS and
now MacOS as well using c-sharp with the
hummus it's in API access and full
native performance so what does this
actually mean it means you're actually
targeting the actual API is the
underlying API is on those platforms
using a c-sharp a good example of this
is this so here we're using objective-c
to set the background image on a button
top ones Objective C one C sharp they're
roughly similar different brackets they
look pretty much the same the really
cool thing about this means is that if
you're looking for a problem
and you're working with xamarin you can
just sort of look up the answer for
normal iOS and then so mentally convert
that Objective C into C sharp it's not
that particularly difficult this does
mean though that you end up writing for
that app for that platform directly but
you can share code using you know more
kind of patterns
so what does this lead us to in terms of
architectures if we want a charge of
sort of a tradition we're gonna write
this three times we end up with a sort
of a siloed approach like this we're
gonna write one app in Objective C when
F and Java one happen c-sharp and we're
not going to share any code we're gonna
write the same bug probably three times
as a test of three times and chances are
not fixed for that many fix to it fix it
two and a half times zeroing gives us
something like this we hack we can we're
still running three separate user
interfaces we were writing them natively
and targeting the appropriate patterns
and user interfaces for those platforms
but we're now sharing our application
and business services across all of them
we write at once we can test it once we
can unit test it in a beauty of air
doing it this way is that this code is
guaranteed to be platform agnostic which
means it's very easy to unit tests we
don't have to worry about sending out
GPS dealing with file systems because
that's probably gonna be dependency
injected in and it also means that we
can easily move it across to even more
platforms if needs to be but that's kind
of half the battle
in my opinion in this top layer is more
code there's stuff we can share there
it's sort of extract and reuse this is
what we call the view model in patterns
like presentation model from Martin
Fowler which came out of what he talks
about a while ago but it's sort of been
popularized more as in vvn now this is a
pet in and extract state and behavior
from your user interface into classes
we're gonna call view models this means
that they're cross-platform it means
they're testable what do I mean by this
so we all think of this sort of
canonical login page we have a username
we have a password we have a button to
login right
we don't want user to click the button
until they login and so sorry until the
into these name and password but when
they click that button we want to check
to see if those credentials are valid if
they aren't valid we want to show mirror
message if not take them on to the next
page that state and behavior is common
across all your platforms
why write that three times why not
extract it from that user interface
right at once test it once and bind it
to that user and
this gives us a pattern that looks much
like this we now have our view models
extracted from our user interface we
have a shim of what you'd call the sort
of the platform specific stuff talking
to the GPS the filesystem push
notifications and the like we also have
a shared application services so take a
look I see what this looks like so I
have this example view model here looks
much like I just talked about we have a
username and password which the user is
which is being used by the user we have
a computed property here called can
login it's only true when user name and
password are entered with a message we
can sit back to the user a simple login
method
Bracey checks other credentials valid if
not just by a message otherwise go on to
the next page our interactions here
around the navigation as well as youth
indication adiprene are being injected
by dependencies so this means we can
easily test this we can look at our you
know tests I can quickly and easily test
hey given various combinations user and
password can use a login and using mocks
if I say these credentials are valid and
I login on a view model verify weaving
on to the next page so this means that
I've extracted the state and behavior
for this login page out into a separate
class I can share across all my
platforms and unit tests it really
simply from the user interface side this
is xamarin forms which is essentially a
UI abstraction layer layer of across all
the platforms I'm binding my username
and password on entry text boxes so it's
properties and I'm using the caliber
micro feature here we run essentially
attaching that login method to the
button one of the features of Caliburn
is that once when I bind this login
method to the button it'll look for
another property called can login and
bind that to the visib in able of the
button so that means as your idea chain
is because this is a two-way binding as
I change username and password can login
changes but
suddenly lights up and they can click
login and underneath that an error
message when something goes wrong this
is a really simple sort of example about
how we can write sort of stay tuned
behavior for classes that's
cross-platform and easily sharable so
there's a lot of really good in movie in
frameworks up there a few of them sort
of almost based here in Australia
Michael Redland works on fresh mvvm I
think he's around this year and Geoffrey
Huntley he works on reactive UI and
he'll be doing talk later today of
course I wouldn't be remiss in
mentioning calibre my car which is the
one I work on so there are some new
options in vs 2017 these are ones around
how we can share code across more
platforms I just want to talk about them
for a bit the obvious example here is
dotnet standard this is my kind of like
my favorite ordering this is my sort of
general approach I want you to stop that
standard if I can
it'll work my way down portable class
libraries they've been around for quite
a while and actually now with three
served on extended to Microsoft are sort
of officially deprecating portable class
libraries as sort of an approach towards
sharing code I'll go into a bit more
about this standard in a minute multi
targeting is the other one it's a new
tool set that came out with vs 2017 and
it lets you basically use I've put on
the same line as shared projects because
it works the same way in sort of your
approach to writing code and shared
files it's been around since Visual
Studio has been around and with its pros
and cons so what does dotnet standard
there are whole talks on this so I'll
try and cut a little bit into it but
donít standard isn't a library it's a
standard in the same way that 802 11 is
a standard for Wi-Fi
Microsoft published some standards these
are basically lists of api's that a
version of a runtime must implement to
say it implements that standard now
what that means is you can now when you
create a new project instead of using
portable class libraries we pick which
frameworks you want and when a new
framework comes out you have to wait for
other authors to basically open up their
projects clicking your checkbox pushed
and you get instead you pick a dotnet
standard version this means that your
code if it's written against that
standard will run against any version of
any framework that implements that
standard the standards are always
additive they never removed
so anything that influenced 1.5 will
also point 1 4 1 3 1 2 etc which is
quite useful it also means that if you
target 1.6 say straight away or 2.0 when
new versions of frameworks come out they
actually implement no standards your
code will all suddenly automatically
work on there without you having to do
any more work which is quite cool what
you kind of end up having to do as
authors is looking at a matrix like this
which looks particularly complicated but
we're just seeing the darling Senate
versions across the top and the various
flavors of framework down the bottom and
we can see where they get implemented so
we can see here that you know pull for
framework 4 6 2 implements tonic
standard 1.5 and what you can use
basically it was work out what things
you want to target and therefore what
version is the docket standard you can
use across all these things so multi
targeting with the new SDK tools that
came out from Microsoft basically on the
last sort of six months we have some new
project types and you have the CS
projects on lots more one of the things
that has is a target framework element
which basically says this is the
framework I want to target you can
manually edit that file say target
frameworks and put in a semicolon
separated list of these frameworks
what this ends up with is essentially
when I build this project I don't get a
single dll output now I get three
folders in my bender bug one for each of
these frameworks in three separate dll's
I get one one project is now doing
multiple outputs targeting different
frameworks so why is this useful it
means that rather than having to write
potentially in dotnet standard assembly
and dependency inject code in you can
write one project there actually targets
the actual frameworks themselves and
uses things that are appropriate just
for that framework if you do that
however just write in some code that in
this case I'm taking one for 1945 and
Windows 10 if I wrote some Windows 10
the specific code in there and I hope
build two of those outputs are going to
fail horribly so I need to do things
like build definitions and you know if
DIF around that bit of Windows 10 code
but for certain circumstances it
actually makes a lot more sense we're
going to a couple of examples of that
let's take a look so I'm gonna actually
use the the caliber micro code here as
an example it's this first example the
top one caliber micro a core is a dotnet
standard assembly so if I right click on
that this is a really cool new feature
in 2017 I can actually edit the project
file without unloading it which is
really handy so this is actually a bit
more work this is actually the entire
project for all this code the CS files
are automatically included you don't
have to actually define them in your arm
CS proj which means that if you've got
two devs working on the project which
conflicts won't happen as much which is
really quite cool most of the stuff
isn't actually needed you can actually
get rid of most of this but the
important part here is this target
framework where I'm saying I'm targeting
Don it's the end at one point on because
the core of caliber Micro is actually
quite simple means I can target 1.0 and
basically run it almost anywhere just
really quite useful
the next part here is
this platform code so this code runs and
actually targets the Zemel platforms
across multiple frameworks Windows 10
xamarin and so on seven forms and
actually what WPF as well so we have our
sort of shared code stuff that works
everywhere and then in here I have some
platform-specific code so if I edit this
project you can see on the top line I'm
targeting lots of different frameworks
I'm saying Windows bills I want me to
build something for tunning it's not
it's in one for nineteen four five
windows 10 mono Android or xamarin
Android and xamarin iOS
I have some common properties defined
for all of this but then I can start to
do some stuff that you'd kind of define
only four different frameworks so in
this case I'm doing some defined
constants and so when the target frame
work is done it four five to find a
constant net when it's Android define
Android so it's this lets me put if
Android in my code and kind of
conditionally come pile around that and
then there's obviously some properties
here that I've just specific to those
platforms down here what I do is I
remove everything that's in the platform
code so basically everything by default
all those setup files automatically get
included into all target frameworks
that's not what I want I don't want one
of the code that's in that mono android
folder being compiled into Windows 10 so
I remove it I remove everything in the
platform's code and then I do a none
include this is a bit of a hack but it
means that it always means that all the
files always show up in my solution
Explorer and they won't get built I can
then go down here and say when compiling
four four five do the references I need
to do into four there and then I include
everything in the WPF all the back end
so essentially now when I could build
for dotnet four five I'm building for
everything
main folder plus everything in that
platform folder excluding all the other
platforms when I build this I get four
five different assemblies all targeting
the appropriate frameworks all able to
use platform specific code so if I look
in something like the convention manager
you know I can have this conditional
code in here
doing different stuff on different
platforms but for the most part the code
is sort of 89 percent shared and it's
not worth the effort to trying to sort
of dependency injection of stuff in so
this is a really good approach if you're
doing a lot of work that's quite close
to the middle in terms of user interface
but want to share a lot of that code
between them so let's get into the meat
of this talk so what I really wanted to
kind of talk about here was this idea
that as we target larger platforms you
know we're targeting things like
desktops and TVs we're building apps
that are content consumption but content
creation our apps get more complicated
now when we write larger and larger code
bases there tends to be sort of cut
points we find where code is the easiest
to add and it kind of accumulates we see
this in MVC in the controller layer
right the controllers tend to be the
easiest place to edit code those
controllers get bigger and bigger and
bigger we call this MD pattern that
controller if you want to go read up on
it just to have a quick search for on
Google and search the Thomas the Tank
Engine memes and you'll eventually find
some stuff around sort of in VC Fat
Controller in the mvvm in an application
whereas this tends to be the view model
if you want em to get bigger and bigger
as it's kind of the easiest place to add
code and often I find I see people if
you're building applications where this
sort of shared user interface you know
there's nothing up in the top left the
top right of the screen which is common
across all screens we find that people
want to kind of stick that into base
classes you know base view model that
all your classes inherit from they can
share that behavior and all as well
this just means that your coat is harder
to test you got more setup work to do
and it can be a bit more complicated so
let's sort of look at ways we can sort
of tackle this so one thing I want to do
to start with is introduce a couple of
concepts and I think navigations office
sometimes the easiest way to talk about
this in most platforms we have a control
that sort of deals with navigation in
iOS it's the UI navigation controller in
Windows something like a frame most in
the VM frameworks wrap that control in
our class navigation service and expose
that as an interface out to your view
models typically what happens then is
your view models can then tell that
navigation to us go to this new view and
then the view can use something like a
view model locator find the appropriate
view model for that view instantiate it
activate it and all as well this leads
us to a problem though our view models
we don't want to talk about views we
want our view models sort of abstract
from the view itself and also we don't a
reference that view because you
typically want their view model in a
shared piece shared documents telling us
Emily and actually can't talk to the
view directly this leads us to kind of
stream based navigation or URI based
navigation we were referencing that view
virus strength often some frameworks we
end up sort of registering differently
used with strings and then saying hey go
to this view which can make things a bit
more arm refactor unfriendly what I
really want to do is target few models
I'm gonna say full this view model I'm
gonna go to this other view model with
some parameters so this is kinda main
concept here of view first versus view
model first so view first in the sense
that we're telling the underlying
control go to this view as that view
changes we react to it create a new view
model and carry on with its view model
first
what we want to make changes to our view
models and have used interface update to
reflect it this is the kind of core gist
of what we want to do here make changes
in our view models update to reflect the
views so I talked initially about you
know pushing stuff into base classes and
called cross shared behavior we already
don't do the sorry we already do this
you know user interface it's alright if
we've got something that's up in the top
left to top right of our screens we
don't write do that interface across all
of our screens we do it once and some
sort of user control or a fragment and
reuse it across all that screens we
should do this with our view models as
well
we should favor composition of our view
models rather than inheritance
structures don't have a hierarchy of
view models that represent sort of the
flavors of your screens compose them
together and how does this work so this
is a demo we're gonna look at later on
which is essentially is to github
browser we have a shell view model that
basically deals with creating the
application and sort of structuring a
few things the menu view model on the
right that's responsible for sort of
basically looking at github building up
a menu and we have some repository
details and issues list we can switch
between the shell view model shouldn't
have any responsibility in terms of
talking to github itself the repository
details are issues lest should the shell
should only be responsible for switching
between these user these views this
means that you know while we have four
view models for the single screen it
means that we can break this up into
sort of neatly testable parts and we can
do this because we have a view locator
given a view model by convention we can
find the view for it most frameworks as
I said have a view model locator they go
dead away given this menu view we can
find it you mean you view model what we
want is the other way around giving them
if you want to find them in your view so
how does this work in practice
well our shell dig middle is going to
have a property of a type menu view
model called menu we're binding this to
a Content control so this is a
sort of windows mo but this works and
xamarin forms as well using a Content
view we're going to bind some attached
property here what this does is
essentially tells the framework
hey I've given you a mini view model go
find the appropriate view for this view
model instantiate it and certain to this
content control this means that our
shell view model all that has to do is
expose the property now shell viewed
only has to say this is where it goes it
doesn't have to know at all how that
menu actually looks or works we can do
this with multiple views for the same
view model as well and the patterns we
see around this are things like master
details where we have a list on the left
which is a sort of a master view of that
uh that page and then we have the sort
of one once it's been selected we have
the view on the right which is the
details so how can we do this we can add
some stuff around context so we can add
a context to our selection same sort of
thing which means we can go from order
details view model to order details with
a master view so it's take a look at
some of these things
so we have a really quick demo here
which I'm just going to show the start
of we have essentially our shell here
which doesn't doesn't do much at the
moment we have our menu where I can
select a repo and see its title and
readme etc if we look at our shell view
model it doesn't do much the moment
right all it has is a a menu view model
it has a active screen and that's it our
shell view doesn't do much either
we have our split view control so I'm
doing all this in Windows 10 just
because it's easier to demo this all
works cross-platform xamarin forms and
the like so this all works on Android
and iOS as well it's just that this is
the easiest way to demo this code so we
have our content control here inside the
pain of that split view and I'm binding
that to the menu so the framework here
has taken that menu view model working
out what's the appropriate menu view and
instance you ain't pushing that into the
the content control further down here I
have another content control which is
down to the active screen in much the
same way and I have some buttons here to
shift between the details in the issues
list which we can go ahead and implement
right now
so I'm gonna create my view details
method and all that needs to do is set
the active screen to the details of your
model also for our issues
considered like so sir our issues and
details were created up here in the
constructor so these are syn Cheetos
child view models we talked about these
are the things that have the the
functionality to go to github look at
the repo details and look up the issues
list and all they're doing is changing
the active screen which is this property
here which we know is bound to that main
content control so if I spin this up
let it compile what we get is again our
shell viewmodel
not really caring about how those user
interfaces are displayed or even how
they're actually working at all we can
test this we can test the shell really
quickly in the fact that we can call
this a view issues method and then
assert that the current screen is that
it shows view model what's really
important about this sub is pick one
here I can now switch between issues and
details just by clicking them so it's
really important right because in that
first example I talked about that
meaning you've been exposed as a menu
view model and then looking for that
Minu view that was sort of singularly
tight we're only exposing a menu of your
model in this shell example yeah I'm
exposing a narrative screen is just of
type screen and I'm switching it between
two types between our repository details
view model and an issues list view model
the framework is working out what the
appropriate view for that view model at
runtime and we get this quick nice and
easy switch
in our issues list we get much the same
thing leave a list view on the left
we're binding it to inserting the
appropriate view for that thing on a
view model list and we're sitting the
context to the master view again then
the main content of the screen we're
doing that again with the active item so
this is the thing that the user is
selected and we sit in the context with
details view and we're binding the
active item to the selected item on that
list box what this thing gives us
as we select something here that listbox
two-way binds to the active item in the
view model we then use it basically
insert that view for the view model into
the other side of the user interface but
with a different context this means that
we can have two separate views over here
you have a details view and a master
view for that same view model and we can
switch between them as we need to this
is quite good for you as a suit for
master details but there's a lot of it
other scenarios we can do this we can
take this even further in our issue list
view so at the bottom I have a combo box
here which is essentially just a view
selector I want to go and into my list
box
turn the take remove that context and I
can go set a binding on this to that
view selector and the path is the
selected items context so I'm just
finding a list of views to that view
selector and now
we have dynamic context selection for
this so an example you'd think about
doing this is if you were in sort of
Windows Explorer right we know when you
have a drop-down where you want to pick
between sort of details view versus
expanded view of us as a quartet cetera
so if I go in here switch over to the
list I have a combo box down here where
I can switch between different views
really easily but it's by dynamically
binding that context which up as that
context changes of the you locator
switch spins back into actions is well
given this view model and giving this
new context
what's the user interface for it again
this means that we can do some really
simple stuff in that idea a shell view
model doesn't care about github doesn't
even need to know about it our issues
list our SUV model simply defines what's
needed to show that issue list
sorry issue and the issue a list view
model itself is the only thing that
really cares about going to github and
getting those issues we've broken down
our code into about four separate view
models all are independently testable
independently testable sorry and all
cross-platform
so a lot of immune frameworks have this
idea of being navigational we're right
as you go to a view model it says hey
I've been navigated to or I've been
navigated from this works really well
for this idea of signal screen view
models if you have a view model that
encompasses your entire screen and
you're just shifting from view model to
view model then this works really well
when you're composing your view models
together when you're building up largest
trees of the models that are all
managing each other then simply meaning
navigational wear isn't enough these
view models need to have life cycle they
need to know when they're being
displayed on screen when they're not
being displayed on screen this isn't
just navigation aware because they can
come right come back if needs be a good
example of that is the master list we
talked showed before as we select a an
item in that list we need to better know
that hey I've been selected I'm now
being shown in this larger part on the
right now this life cycle needs to be
managed by something and typically in
most frameworks like this it's called a
conductor this conductor is conducting
the the sort of behavior in the life
cycle of its child view models and we
can think about this like the navigation
service itself is simply a conductor
it's essentially moving between view
models conducting that behavior and it's
saying hey I've been navigated from
you'll be navigated to and the like and
that's really important and we'll show
why in a couple minutes once we've got
this tree of view models we want to keep
them decoupled right we don't want to
basically have to pass references from
like the menu you saw when I press click
on the menu item the repository di was
updated we don't want to have to hit
though have those tightly coupled
together and we can use patterns such as
mediator of Integra Gatien or messenger
to do it and almost all frameworks sorry
like this have some sort of built-in
functionality which we can take a look
at so we can see here you know this
example
we have a menu v-model it's pushing
messages to our event aggregator and the
event aggregator is then pushing them on
to the repository details and issues
list means that our view models only
need to paint on that event aggregator
they don't need to depend on each other
they're not tightly coupled and it means
that we can sort of make use of this by
pushing messages in from other places
that mimic the same thing as clicking
something on the menu view we don't need
to care about that which is quite good
so let's take a look at these in a bit
of depth okay
so we have our issues list view model it
doesn't do much but it inherits from a
thing called conductor collection one
active so this essentially means that it
maintains a collection of child items in
this case issue view models and only one
of them is acted at one time right so
you can think of this as being really
analogous to master details you know we
have a little glimmer collection one of
them is active at one point and really
this just means that we have in the base
class an items collection of type of
verbal collection issue view model and
we have an active item of the same type
same sort
our issues viewmodel inherent some
screen so it has a couple of special
interfaces one it's called I activate
one is called I deactivate what this
means is that we can then override and
talk about code that happens when you're
activated this is code that happens when
you're deactivated so we can Alice
essentially write code that says when
that issue of you model is selected run
some stuff when it's kind of something
else is selected deactivate the old view
model and run some code there what we
want to do here now is load the issues
for this i sorry load the comments for
this view model so i'm going to hear it
from something called on initialize and
what this essentially is is the first
activation so initialize happens on
first activation only the view model
camisa was subsequently deactivated and
then reactivated but for the most part
we only want to run sort of get the
comments once and once once we've loaded
them into memory store the moment so
your model if we then come back to this
issue we don't have to go back and get
the comments again so we can run kind of
like first activation only so we can get
the comments
and then add them to the collection of
comments we've already got here take a
comment so we want to select we need to
await this given a comment build a new
comment view model based off that
comment and spin this up what this means
is when we select that issue in the view
model the conductor that issue ListView
model will tell that child issue less
issue item sorry that it's been
activated because it's the first time
activation that on initialize will be
called we can get the comments so
against it some comments loaded now at
the bottom and it means that when we
click somewhere else we go here and then
come back to this one those comments
were already loaded we don't have to
worry about going back and getting them
again so this is I this is this really
strong idea of about adding lifecycle to
your view models not just being
navigational we're not just saying hey
you're now visible but as they come sort
of in and out as these things get
visible and not visible then we can do a
bit more with them let's look at this
event aggregator I mean you view model
thing we're selecting from on the left
is depending on this event aggregator
and all it's doing is when we select the
repository we're constructing a new
message
and this message is just really a simple
detail of actual repo details the owner
in the name and we are then publishing
it on the current thread of the event
aggregator so it's all we're doing all
the message cares about is that sorry
the menu cares about is when you select
something I publish which makes it
really testable right you don't need to
worry about if I'm wanting to unit test
this menu view model when I click this
like repo make sure the issue details
show up from the unit test point of view
it's just when you call select repo
verify up messages published on the
integra gator you know we can break
these tests by sort of separating the
view models in the user interface we
also make the tests easier as well our
repo details view model which cares
about this a game depends on AB
interrogator but also implements
interface called I handle repo selected
message this means then you know it's
capable of handling these messages and
on construction it's calling subscribe
this on Tracy says subscribe to messages
on the view model and based on the
interfaces I implement you can tell what
messages I care about and all that
implement all that interface does sorry
is heaven I handle I'm sorry a handle
method called repositories taking that
message in and we can then respond to it
get the details and populate them
appropriately and if you model so again
this makes it really easy it's a unit
test in that now on the repo details you
model I can just call that handle method
myself in the unit test passed the
message in and verify that the living
water reacted appropriately to that
message
so we've decoupled that menu view model
from our repo details view model and
made them a lot more testable and a lot
more decoupled as well
what we can then do is take advantage of
this by sitting publishing message from
other places that essentially simulate
the things in as menu clerks so what
I've done as I've registered this app as
a protocol handler so click a URL it
opens up the app with URI got some code
in here that's parsing this protocol so
it's just in DC owner name so I can say
given a link in DC slash and Hydra
Samson slash talks open up that
repository and what I can do here
this is the code that's essentially
passing that protocol when it comes in
it says all right here's the or I posit
get that stuff out and work out whether
it's successful
I can then in my application here get a
reference to the event aggregator via
the container because I'm in the main
route I can then take a message
construct a new repository selected
message based on the owner and the name
that I've positive that URI and then I
can again we'll publish on the UI thread
that message
so now we're essentially because we've
decoupled that menu from the repository
details it means that anything can tell
that details to switch repos right we
can now have things like your I
protocols we can have other parts of our
user interface that are completely and
utterly far away from their details say
hey switch context switch different repo
which means you can have buttons buried
down in sides potentially issues so if
you imagine those issue comments had
links towards other other repos all that
child view model that issues view model
right at the bottom can do so the whole
application switch context is this
publish that message it doesn't need to
know about that she'll at all it just
needs to know about the integra Gator
and that message type so we spend this
up
as again we changing things we're
clicking things on the menu we're
publishing that message the repo details
is listen to that message in all as well
and if I open a sample HTML file here if
we just quickly look at the source we
can see that it's linking to that
protocol we talked about when I click
the button we switched over to that repo
now right we've got that activation from
the URI we're publishing on a message on
the integra Gator our repair details
response to it and all as well in the
sense that we didn't need to kind of
further complicate a shell or our repo
details it just kind of works in the
fact that we can sort of publish those
mythic messages separately
so what a recover here we talked about
the fact that xamarin MVM is a great
tool set for for building cross-platform
applications across multiple frameworks
a course re across multiple sort of
devices right we can target everything
from phones like iOS all the way up to
Xbox and more esoteric devices such as
hololens we can use something like nvvm
to further extract state and behavior
out of our user interface and share it
using cross-platform techniques in a way
that it's easily unit testable more
maintainable and oftenly cross-platform
we've seen some new things in visual
studio 2017 around techniques to share
code across platforms using dotnet
standard as a way to now write coding
standards rather than sort of ad-hoc
selecting platforms using portable class
libraries and as that goes forward means
that you can be able to write code to
target you that sort of automatically
light up our new instances of frameworks
like Tizen or even as existing
frameworks rip their versions your code
will suddenly work if they're targeting
standards you're already using it also
means that we as app application authors
we don't have to wait for new and
existing framework developers to sort of
spin their project up took a new box in
portable class libraries and published
in you get that was one of the biggest
problems I had a previous job I was
working on sort of early release
Microsoft platform stuff so we were
getting weekly builds from from
Microsoft the trouble was that nothing
worked
Nannie or the normal open source
libraries you wanted to work with
actually targeted that platform because
it didn't exist yet and literally all
you had to do was open that project tick
the box in portable class library
rebuild and worked if it's targeting
darling standard you won't have to do
that essentially all these frameworks as
long as that new new version of that
framework implements our standard all
that code was automatically there for
you you don't have to wait for things
like JSON dotnet now support
what's Windows 10 or anything like that
as long as it is long as Jason got net
targets that standard any 300 minutes
that standard will work
we saw stuff like multi targeting so
this is a essentially just a revision on
shared files right it's before a few
Platzer I played with shared projects
you know we had one shared project which
had all the code and we had about three
or four head projects with reference to
shared and when you built each of those
sort of copy and paste at the cut across
and got the output now with multi
targeting we have one project that can
actually build multiple different
outputs which is really useful if you're
kind of building that close to the
middle code that really has to touch
platform specific things but for the
most part is reasonably shared we looked
at navigation and this idea of view
first versus view model first
so do that we want to use view model
first instead that we want changes in
our view models changes in the
composition of our view models to
ultimately update the user interface
rather than the way around this means
that we can better test the behavior of
our view models better decouple the
behavior of view models and it means
that sorry that we can sort of bitter
break down these view models and share
them across teams and sit in terms of
being able to say write the stiff you
work on menu this work on a positive
details and the contract between them is
that message we looked at conductors and
life cycle and this is this idea that
view models shouldn't just have this
idea of hey I've been navigated to but
more this is the concept of activation
and deactivation such that when you're
composing an entire tree together you
can cut a better manage what's happening
all the code for this is up on github
that's URL some of its spirit across a
few different projects but it's all
there we encourage you to take a look at
it
do you have any questions jump back to
that you can take photos yep yep so the
code I wrote for this is just Uwe
basically just for defending my purposes
that it's really easy to do my long
I don't Windows box all the stuff I
showed there like that view model where
I'm binding and doing view injection
works and xamarin forms using Caliburn
as well all right so we can I've got a
blog post up that shows doing that
master details on Zimmerman forms which
means it works across Android iOS anyway
that seven forms runs and to be honest
like the behavior here around sort of
detect having a view model locator and
injecting views while built into the box
in Caliburn isn't particularly
complicated to write and could be added
to it almost in here any framework you
want and really isn't even like you apps
specific right you can do this in
JavaScript reasonably easily as well I
think a lot of frameworks already took
this idea of breaking down these big
screens into components or few models
based on with your own JavaScript or
thing that's pretty no one makes sense I
can just seen you some links later on if
you want zimmern forms do you thing else
yep so the advice was so the question
was in this sort of framework how would
you handle different sort of device
specifics essentially like asking
permissions for cameras and so on so
typically what happens is we jump back
to an architecture diagram it's
typically what we see is that code tends
to live in this kind of layer here right
so it's platform-specific code you have
to write against those specific api's
you then kind of wrap it up in an
interface and then sort of expose it by
the container to these appropriate
applications for your view models in
your other application services you've
got an example of that somewhere
yeah so this is a that first cross
platforming me the example I talked
about so this is an example of like a
navigation service on Android the sense
that it's working out what the current
activity is were switching activities as
it goes and that's exposing this
application navigation service and it's
written in that's inside the sort of the
android project in this case and then
the application itself is registering
that application service into the
navigation service into the container
and therefore any of you want or can
kind of use it and work with it directly
and other projects come along and just
implement that service so you are always
going to have some code which is sort of
platform specific you're always going to
need that in terms of is it with camera
work with GPS and so on the idea is if
you wrap it up in GPU inside an
interface means that you can kind of
test against it without having to put it
on on the simulator or actually on the
device because if you're using things
like automated UI tests those things
need to be a slower and more fragile
more code yet you can kind of put in
these gray boxes means that it by nature
it's cross platform which means you can
unit test it without the platform being
there and therefore you know you get
that speed of sort of live unit testing
if you want vs 2017 or two standard unit
testing without having to spin up
simulators or actual devices anything
else excellent thank you
I'll be around outside if you want your
questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>