<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Compositional UIs - the Microservices Last Mile - Jimmy Bogard | Coder Coacher - Coaching Coders</title><meta content="Compositional UIs - the Microservices Last Mile - Jimmy Bogard - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Compositional UIs - the Microservices Last Mile - Jimmy Bogard</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8WrjthKFbTw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everyone thanks for making it to the
next to next to last session is that
right before you have to take trains and
get back to your homes
my name is Jimmy today we'll be talking
about composite UIs
which i think of the last mile when it
comes to micro services you can find me
on twitter @ @j bogart and this
presentation and pretty much everything
I do is on my github comm /j bogart and
i also blog at Jimmy Bogart comm I also
have an older blog on those techies so
if you search for lo techies you'll find
a lot of my old content there I've got
hundreds of posts over there that are
just languishing in an old WordPress
site that I don't know how to get off
there so a lot of stuff over there too I
do a lot of open source stuff so you
probably know me from autumn apper but I
also have other few projects for other
projects I like mediators one and the
other one is HTML tags so that's a
little bit about me let's talk before we
get too far into composite you eyes I
want to take a little bit of time to
cover a few important points about micro
services now micro service is a little
bit interesting to me and that's it
seems like it's a interesting movement
in which it takes older concepts puts
new names on them and then takes credit
for those old concepts so I want to
really try to ground on some of these
ideas that have been around for
sometimes decades
first of all micro services is not a
specific technology or stack so it's not
a sure it's not AWS it's not dr
kubernetes it's not domain different
design it's not rests it's not any of
those things
in fact if someone's trying to tell you
that you have to do micro services with
a specific technology or stack they're
probably trying to sell you something so
be very wary of that that was really
what got SOA in the end was the vendors
taking over all these different pieces
so this talk will try to be as vendor
agnostic and talk about fundamental
technology choices and not try to talk
about specific products that can help
you out so what is the micro service
kind of depends on who you ask
unfortunately there's a lot of
definitions out there but I try to find
because it's got micro in the name the
smallest and most concise definition of
micro services and it came from the
micro services book and micro services
in that book was defined as its small
and focused on doing one thing well
and it's autonomous and that's it that's
your your two lines about what a micro
service could mean now behind there of
course there is a lot of arguments about
what those terms can mean so for example
if you're building micro services and
something like go or rest small could
mean really really small but if using
something like Java then maybe your
services or half XML configuration and
so they're very very large there's no
real consensus about what small means
but it's small enough and of course the
one thing what does that mean like one
if statements one piece of information I
show on the screen that could mean a lot
of different things as well but for me
personally what a microcircuits is the
smallest most focused thing they could
still be autonomous and autonomous is
something we're going to be talking
about a lot during this talk they gets
composite you eyes are the thing that
throws a wrench into the entire autonomy
principle so autonomy means a lot of
things first of all it means we have an
infinite independent ownership
availability and delivery of our service
so typically this is a full-stack team
all the way from the product owners and
business analysts all the way to testers
and deployment one team responsible for
the entire delivery of this one
individual service they're also
responsible for its uptime so there's
not a separate DevOps team doing here
but have a DevOps team they're doing it
you're doing it wrong that's DevOps
wrong I'm sorry DevOps is supposed to be
engrained inside your teams it's about a
delivery pipeline not about a specific
team this microservices may it's
supposed to be managing the information
inside that service as well as access to
this service this is where those big
brokers on the SOA land really screw
things up because that's where a lot of
data and ownership started to seep into
or these big central applications and
big frameworks so a micro service is
intended to encapsulate all the
information and control access to that
information as well next they should
manage any failures associated with any
sort of request so I'm not letting it be
someone else's problem it is my problem
I'm supposed to have the pager or Apple
watch that I'm getting buzzed whenever
something goes down and finally needs to
maintain contracts talking to other
potential services
so with all these together all this idea
of autonomy we can start to paint a
picture of a would look like in an ideal
world building a system full of
micro-services in this ideal world we
have individual services that have their
own separate autonomous autonomy
boundaries doing their own individual
thing they each have their own
applications they each have their own
databases I might have a sales
application on MVC core I might have a
shipping application on old NBC we have
the orders people over there that I
guess are hipster folks so their budding
a building an electron up on top of
MongoDB and of course there's a poor er
people your people still in an IBM
as/400 mainframe they're probably
counting on the day so that retiring
maybe they're getting a pension or
something I don't know and I don't know
what the user interface is for those
people but I probably green I would
think so so with each individual set of
services here you can imagine that each
set of the people using these
applications only really uses those
individual applications and nothing else
you may have like a CIO or CEO that
needs information from all those sources
and of course like one gigantic Excel
spreadsheet to run the company but for
the most part individuals that use those
applications don't really cross any
service boundaries they use their
applications for their daily work and
they go on with our day except for this
guy over here the ERP person is probably
playing a lot of Pokemon or something
like that I don't know because it takes
a long time for your results to come
back from that old mainframe over there
now there are occasions where these
different organizations do have to talk
to each other they have to coordinate
some activities to actually run the
business but for these back-end services
autonomy can be pretty easy to do
because the users are constrained within
each individual application and in fact
when we're looking at how to draw the
service boundaries in the first place
it's also I would say trivial but it can
most part just look at the
organizational boundaries of the company
and then design your service boundaries
around them this was known as Conway's
law that says any organization that
designs a system defined broadly will
produce a design whose structure is a
copy of that organization's
communication structure so basically
build the apps and services around the
organization structure of your company
and as long as your organization is in
organized
is ridiculously then it should come out
to be okay in the end there are some
downsides to this of course if your
organization is not structured well or
not structured well for the future you
may have to build services for the
organization you want not the
organization you have or you may have to
reorg to get to the organization you
want and then build applications
according to that but for the most part
services belong to specific
organizations inside the company and in
fact if you looked at these boundaries
Andry one time one hundred hundred fifty
years we may find that the exact same
service boundaries we drove for
different organizations inside a company
100 years ago are the exact same things
they'd have today they'd be responsible
for the same sort of things that have
the same sort of activities and tasks
they do on a daily basis the only thing
that's a little bit different is maybe
the today the everything is a little bit
more sped up so I can communicate much
more quickly but otherwise if I'm
looking at how to connect these services
just one to one I'm going to be using
the exact same communication styles and
structures I would use from 100 years
ago the same exact constraints I would
have 100 years ago are still the same
constraints I have today I would still
have I can have blocking communication I
can have a debate and communication but
for the most part even though latency
has gone much down as long as I'm not
making silly choices about those arrows
they have back there everything's to
just work okay we can go pull out those
old integration books that tell us how
to connect different pieces together and
use standard protocols I going to use
rest or HTTP or maybe graph QL because
that's a thing now
and I can use different messaging
protocols and as long as I choose really
forward-thinking protocols and
communication styles I should only have
a problem connecting those back-end
services together but we're not here to
talk about that we're not here to talk
about those back-end systems that are
really easy to do and we just do some
like integration services to connect
things up we're going to talk about
compensate you is now not picture I
didn't have all the services there was
no real composite UI I might have some
communication between different services
but there's nothing that actually
represents a single view into the
company and that was a problem though
because if I look at those different
services I had before none of them
actually generate
any revenue for the business there's
nothing that the user comes in and says
I want to buy something I need all these
services can you have a a coherent
singular experience for me so let's
suppose a rewind time again back a
hundred years and see what would a
composite you will do I look like before
there are any computers involved so in a
compensate UI circa 1900 or so these
these did exist I might see something
like this does anyone know what this is
this is the very first department store
that existed in the world
this is Selfridges in London Selfridges
really pioneered a lot of the concepts
behind department stores
the idea behind sales to have a sale to
like 10% off for some holiday that's
something those really that was really
pioneered by Selfridges and before these
kind of department stores you would
typically go to a specific person who
made that thing to buy that thing so
you'd have to worry about any sir
composition you went to the Hat maker to
get a hat you went to the shoe maker to
get a shoe and it was that single-stream
delivery that you went to the person
that made a thing to get the thing this
really threw all those concepts out the
window and said right why don't we have
one single customer experience where
someone can come in and buy a wide
variety of things and have that nice
seamless experience where they don't
have to worry about oh this kind of
thing versus that kind of thing and they
just go in and peruse many items and buy
whatever they want so the comp is at UI
of this kind of I think this is what
1940s looking at those cars there's
probably yeah probably everyone's
wearing a hat at this point I look very
hot in their suits as well if I looked
at what that compensate you oh I was
back then it would be one of the
departments inside a department store
this one for example I think is the
perfume department you can tell it's
also old because one of the things
that's they've really pioneered as well
is having people spray the perfume in
your face to make you want them or to
run away I don't know and there's none
of those people here but they should be
and what this provides is again a single
experience for consumer who can come in
and consume all the
back in services that a departments will
provide shipping inventory warehousing
everything comes together into this one
single interface where user comes in and
the entire experience is designed to
sell them something so look at the kind
of challenges it would take to build
this kind of experience for a customer
well they don't have to know any of the
back-end services and departments behind
the scenes a lot of the challenges they
would face with this kind of experience
are very similar to the ones we would
have with the kind of experiences we're
trying to building to we're trying to
build today so if I can figure out what
are they how are they building those
compositional services before computers
I might be able to use those same sort
of techniques to build those kind of
services today and I think of this
problem as the last mile problem this is
by the way this is a term right that
everyone uses in places where they don't
use miles it's not like the last
kilometer problem here I don't think I
verify this with a few like everyone
else I guess besides the United States
uses kilometers except for us and the
idea here is that this came from
telecommunications is it's super easy to
build these really big backbones of the
Internet's and telecommunications
so phone internets whatever it might
have you it's really easy to build those
really big pipes that can go from city
to city or country to country but the
really difficult part comes in taking
those final services and delivering them
to the final end user and that final end
user is the most important part without
someone to answer a phone there's no
phone network without someone to browser
edits there's no internet without these
final users of these services there's no
point in having the service in the first
place the same thing with our composite
you is the company you eyes are almost
always built to handle that final user
who's going to be purchasing something
or in some way delivering the revenue
stream to my company so in this original
set of services where I have these
made-up services like sales shipping
orders in those poor ERP folks although
they may have upgraded now maybe they're
on SA P which is obviously infinitely
better than a main
right there's got to be some single
coherent user interface on top of all
those existing services now if I look at
something like this when I when I first
started getting into e-commerce about 10
or 15 years ago , the UI is were a
really tough problem and there are
almost zero tools available for us to do
this easily so when I was in my very
first e-commerce job what we would do is
just not compose at all and this is a
valid choice we can say who this is the
the challenge is too great
let's just not compose things together
and we'll just build these really tall
vertical slices that go all the way up
to the top so you may even notice this
as you're going through a website if you
keep an eye on the domain and sub domain
you may notice it changing over time
this is built in the time before people
could really build these kind of
composite applications unless they just
threw up their hands and said forget it
we're just going to build instead of a
singular interface for the end user
we're just going to build multiple
applications that have their own
delivery and release schedule and we're
going to we're going to take that all
the way the top to say the H have their
own databases they each have their own
you wives they each have their own teams
and they're all completely responsible
for the entire experience for that one
individual vertical now we did have some
ability to share things between
different services here in that case
we'd build a content delivery network or
CDN for just like the most very basic
CSS and sometimes sometimes a little bit
of like fonts and things like that but
for the most part the only thing that
was shared are these really static
assets that don't really change over
time until the marketing department gets
like a windfall of money and they decide
to change everything because how else
would they justify their existence
so with this content delivery network
it's okay but it doesn't really provide
any shared behavior or any shared
experience between these different
applications one of the things that we
found and I was actually part of the
order's team for this one application we
were part of it was really hard to fake
a composite UI with all these disparate
applications the user experience almost
always suffers we don't have some
singular coherent user interface that
ties everything together seamlessly for
you to the end user
and you know when you're in one of those
applications or in one of those user
experiences where they haven't tied
anything together
pretty much every single helpdesk phone
operator is a non composit UI that is
you were exposed completely bare
whatever crazy back-end services and
departments that have behind the scenes
so something's wrong with your plane
ticket you call service they say okay
let me route you over to the
reservations department you get over to
reservations reservations said oh you
actually purchased that with airline
miles
I had to route you over to the rewards
Department's Rewards Department says who
that was a transfer from another user
from another person now I have to go to
the transfers department and so you're
completely exposed to every single
organizational inefficiency behind the
scenes when really you just wanted to
fix the problem with your airline ticket
so although for some of those kind of
back-end pieces
I'm a optimize for not composing pieces
together because I mean they've already
purchased the ticket so you know screw
them but I for people that haven't quite
entered my revenue stream yet I may want
to actually compose thing together to
build that really nice and user
experience so supposing we go down this
path and we say ok now we want to build
that nice user interface to compose
everything together we're now presented
with a choice where are we going to
compose these different pieces together
and how are we going to do it if I look
at any one individual requests in an
application there are a number of ky3
major players that take part and the
requests for something and presentation
of it to the end-user
each of these presents a choice for me
about how to compose pieces together now
it's not exactly in tier because this
crosses over to user space but you can
in most part think about it in terms of
there's the application that the user is
running for me it's typically a browser
but it certainly could be a sick client
application an electron application a
mobile application this is the
application that it's run on the users
side and this could be one of the places
that we compose we can also compose
before that user gets the information on
the server side or we can compose all
the way back to the backend into the
data
and so for the rest of the time I'm
going to be walking through each of
these different areas of composition
walk through some of the techniques we
can use to help compose these pieces
together and some of the advantages and
disadvantages about each of these
specific areas for any big application
I've worked on whether it's a large
e-commerce or an even a back-end system
I don't really say I would pick one over
the other it really depends on what I'm
trying to accomplish with the end user
and then I make the appropriate choices
about where to compose based on the
different constraints I have and most
importantly the end user experience I'm
trying to achieve so let's first look at
how we can can can compose at the
browser side will be using everyone's
favorite example for service or new
architectures or Mau micro services
which is going to be Amazon
I just haven't insert something randomly
of course and of course Bieber comes up
he's matured over the years it looks
like so looking at this this is the
experience I want to have a lot of times
I start from wireframes or something a
little more substantial the first thing
I need to do when looking at how to
compose these pieces together is every
single framework has their own way of
composing pieces so I have to first
choose what is my front-end technology
I'm going to be using to pull these
different components together each of
those front-end frameworks has their own
flavor of how to compose pieces together
angular has the concept of modules react
has the has the has the idea of
components aralia anyone use aralia here
a few of you okay I'm sure it's going to
be around next year sure uses components
as well and finally if you're using just
some like random noun J s component that
hasn't been invented yet then it's
probably going to be called components
for the most part it's going to be
called a components and whatever library
you have except for angular which will
muddle the definitions and mess things
up as they're want to do now in each of
these components I can always build
these components independently of each
other
but the problem is how do I distribute
these components to actually package
them up and hand them to the front-end
team to actually use and and be able to
be deployed to my in server
luckily we have a technology that allows
us to do this and it's known as web pack
web pack which i think is very close to
his 3.0 release it's able to bundle up
front-end assets into a singular package
that can include my back-end
over my anomic back-end but my kind of
JavaScript code to handle requests the
information I'm going to be showing in
the screen any sort of styling in CSS
that needs to present information in a
certain way the templates to be able to
template eyes and show that information
and finally if there's any interactions
that happen so I click a button or I
click a little drop-down or click a link
there's handlers associated with that to
be able to perform some action based on
what the user is doing so I slice up my
user interface start to build more and
more of these individual web pack
components in each of these web
components stretches down talking to an
API behind the scenes so I'm building
not just a single set of components for
everything there's always some sort of
backing service for each of these
components that's going to be talking to
most the time the team that's building
the API is also the same team building
the individual components we often call
these front to back or back in front-end
services the idea that I need to stretch
my team all the way from when they're
presenting the information to the API
behind the scenes I try as much as
possible to not have the API team and
the front-end team being different
people that's when you start to get in
these weird like oh it's let's develop
against a swagger definition and then
it'll meet in the middle somehow
magically and in reality it's more like
they're they're way off because we can't
actually service that request or
appropriately so I try to make as much
as possible our team's handle both the
backend service and the front-end
component that's servicing that piece
because the end the user shouldn't care
these different boundaries it's just
just work and the best way to work is to
have everything vertically completely
coupled to each other so with all these
different funding components talking to
the individual back-end services I can
start to go back to my user interface
and start building these individual
components around these different
widgets I see in the screen so I might
have the promos widget at the top there
the promos team is connected to some
marketing team that knows for certain
holidays we want to promote specific
specific things up there
that's the banner I really never look at
it's just like some holidays coming up
buy flowers or cards or something and
I'm like meh I'm good thank you very
much I have different a team for the
account information maybe there's one
that just takes care of images this one
is a CD or music so different formats
that could be different based on
whatever music I'm looking at and so I
build all these different widgets for
all these different components now
assuming I can build all these different
widgets appropriately and I have
individual service teams that are
building each of these widgets the final
piece is to package and deploy my
widgets to the final in end user and the
end application so in our systems well
will typically have as individual
service teams packaging up the web pack
components publishing them to either an
internal or external externally hosted
but still secured NPM repository and
then at Build time our store website is
pulling down those web pack components
deploying them into our fund and
application and then my friend and
application when a request comes in is
going to call the appropriate back-end
service behind the scenes now this is
way this is where you may start to get
into things like API gateways to help
manage this communication or manage the
security of it that's perfectly okay
just make sure you're not using a PA
gateways like the SOA people use those
big heavy brokers the API gateways
should be as small as dumb as possible
and ideally inside one of those service
verticals and not something that tries
to compose everything all together one
thing will not recommend is using an API
gateway to be your unit or your your
vehicle of composition it will just
become a mess of business logic and
craziness and that's one of the big
reasons why SOA failed we want to try to
avoid that with micro services because I
just can't take another definition of
the exact same thing that's like the
better way to do it
nano services or service I just I can't
I can't do it anymore
now when you're building these one of
the ways you can tell if you're not
getting the boundaries quite right if
when you have these cases where you have
components talking to each other when
you have components talking to each
other in order to perform their business
function then
not really that autonomous the idea
behind autonomy is I should be able to
perform my action my thing that I'm
lived the reason my existence without
having to rely on any other services I
should just have to talk to my back-end
service services service to the request
and be done with it so if you have a lot
of communication on the front end of
things talking to each other that's a
really good sign that your boundaries
are wrong you should take another step
back and say maybe my boundaries should
be a little bit bigger and not be so
perhaps noun oriented and more
capability oriented if you have services
that are things like order service and
and product service and user service
those are the nouns of your system
doesn't really describe the business
function it's supposed to be so when I
see noun oriented architectures that
often means they're very chatting
because I have to coordinate many
services together so instead we have
things like checkout as a service which
is a specific user flow that the user
goes through that's more that's more
rooted in the business side of things
and this is just a symptom of that
problem a lot of communication going on
now there are lot of other details about
how to glue these pieces together and
governance models as well those are
going to be very company specific about
how you should pull these pieces in most
of the time we have a kind of architect
team or an enterprise architecture team
that doesn't just produce powerpoints
all day long but they're the ones that
trying to build the pieces of how to
pull all these different things together
so there are typically the ones that are
there that are defining what it should
look like on the NPM package server what
are the naming conventions should be and
then actually helping design the shape
of those components so they don't have
this really chatty problem with poorly
designed components
now as much as I like to compose on the
browser side that really works so I want
to have a lot of independent widgets
from each other but it doesn't really
work well when I have to compose
multiple back-end services into a single
widget to be presented to the end-user
for those kind of services I find out a
little bit better to be using
server-side composition as opposed to
client-side composition client-side
composition as well it only works if
you're using a really good front-end
framework and you may not be able to
just switch your entire development team
over to react or angular or whatever nor
should you just to be able to do a some
kind of composition now unfortunately
unfortunately a server-side composition
is I'm going to be honest it's a little
bit messier than client-side the
frameworks that you typically use on
your projects almost universally aren't
designed for composition they're really
designed to handle a single request and
get a response back in the form of some
single HTML document but how you compose
the little HTML pieces together that's
really not what these frameworks are
designed to help out with so sometimes
you can leverage some existing kind of
extensions in the in the front end of
the background frameworks sometimes you
have to invent your own new way of
composing things and so I'll show two
ways of doing that on the server side
composition now in server side we're
almost always going to be using
model-view-controller our controller
model view or controller view model it's
NBC the letters can be switched
independently of each other and so look
at this and now I have to decide again
now that I've chosen server side
composition which one of these three
areas I'm going to I'm going to be using
to perform my composition I can just
tell you right now not in the controller
controller shouldn't have logic so
either it's on the model side when I'm
building up the model of information on
the screen or should be on the view side
when I'm actually displaying it to the
end-user let's look first at the model
side composition monocyte composition in
a website like Amazon I can typically
see it in something like an invisible
product details section of a screen this
is something that's going to be repeated
over and over again and
typically doing something like give me
all the product details for this
specific product ID or SKU or what have
you and I want to take all those pieces
together and pass them to a view to have
one single nice widget that everything
can come together in this case I don't
typically have different service teams
for individual little snippets on the
screen because they're not that
autonomous they can't really live by
themselves they have to be pulled
together into one single coherent user
interface if you have teams for example
to like junk up your styling or mess up
the HTML you really want to have a team
responsible for this entire widget to
make this thing make sense to the
end-user and not expose that however it
came to be behind the scenes and the
service teams behind the covers so in
something like this what you typically
happens in an application is I issue a
request for some kind of data that says
I need this one for example I need some
kind of product details for search
results but the product details can come
from a lot of different places what I
like to do is go to all those different
places gather up all the data from all
the different people that I'm talking to
and finally get that one single view
model that I'm going to be passing
through the diffuse to say I'm done
getting all the data here's the final
result so we can start out with a
request it says I need some sort of
product results for this product
specific ID will make those requests to
every single back-end service that we
need to get that information from
product catalog the pricing service the
rating service recommendations customers
who bought this also bought that other
thing and then finally once all those
pieces are done I have now one single
model that it can pass into finally the
view to render all that pieces all those
pieces of information most of the time
though I don't like to tie myself to
specific objects and types these systems
like this I want to be as loosely
coupled as possible so most of the time
I'm not tying myself to a type I'm
really typing tying myself to a request
an HTTP requests that says any of the
services that can service this request
please give me your data and that will
give it and show it on the screen
now this is where things can also go
really horribly wrong when people are
building out these kinds of
architectures I've seen this go so
poorly that nine-figure projects have
been cancelled like spinning over a
hundred million dollars be cancelled
because they screwed this up we want to
make sure that these calls to these
other services are very fast we want to
be waiting on one of these services to
get a response back before we go on to
the next one
or if one of these is down I don't want
to have one of these services that is
unresponsive or slow or just completely
gone to screw up the rest of the request
so we want to make sure we're rebuilding
these things that we're putting some
resiliency around each of these calls so
that if something goes wrong we can
still go on and service the next request
an application that did this wrong had
hundreds of these kind of API calls and
literally if one of them failed or was
slow the entire page broke that's not
really the spot you want to be in we
want to have autonomy in this overall
top level UI service it can't be
beholden into these lower level services
to be up or available at all times this
is often where you see the Netflix chaos
army start to come into play well
they'll be able to take out individual
services and make sure that the front
end can still appropriately render okay
so for example if recomendation service
is down we just wouldn't show the
recommendations and we move on with our
day there's a lot of literature out
there about how to handle resiliency and
service-oriented architectures in
the.net c-sharp world there's a great
project called poly project which we can
wrap all of our service API calls and
some resiliency like if it fails three
times in a minute stop calling the
service or if it's if it keeps failing
then let's exponentially push out the
time because maybe that service is just
getting overwhelm with requests but I
want to have something that says make
this not a single chain of links for one
link broken means the entire chain fails
I want to make it more resilient so that
if one thing fails the end user may
never even notice that services out
so this kind of composition Mazal does
not exist in asp.net NBC core or almost
any other framework I've seen out there
Django Rails really nothing like that
has this kind of like here's a request
and who are all the pieces that can get
my information and then show it on the
screen but we can build something
similar ourselves what I'm trying to do
is just have a request go through a
series of services and says whoever can
service that request append some new
data on so we can come up with a rather
simple interface that just says I'm a
interceptor and if I match this
individual request context that could
include the URL information it could
include the query string could include
some HTTP headers so maybe I'm looking
at different languages behind the scenes
then entire request context tell me if
you match or not and if you do match
they don't then at that point I'm going
to hand you the request context and this
view model as a dynamic which is
basically a dictionary evolved a loose
and you are going to append your
information on top of that individual
view model now the reason why I'm using
dynamic in c-sharp is because that again
don't want to couple myself to one
individual contract type information the
last thing I want to do is have to worry
about versioning and all this sort of
junk like that strongly but no just
pretend of our dynamic object and then
we just won't be stupid in the front end
and misspell something and that's about
as good as we're going to get typically
fine for these kind of things we don't
really like stomp on top of each other
with different property names because
we're you know we're all friends we all
go out to beers on Thursday so we know
we're not going to screw each other up
like that so finally this sort of like
dynamic Dictionary sort of access is
plenty good enough for most of the
scenarios I run into now the idea is
that with this view model appender each
of these different services implements
those different view models of Pinter's
and they also look at the controller and
action and path information and say I'm
one of those things so I will go out and
call to whatever API behind the scenes
or it could be just content to going
straight to the database and appending
that in
Meishan into one final view model that's
going to be then finally passed out to
the view to be rendered the view doesn't
care where the information came from the
controller doesn't care where it came
from I just know I have a series of view
model of Pinter's that can append
information to my view model and finally
get that one final coherent results to
the end user
magic allegedly now this this is
something you have to kind of come up
with yourself of course there's no
framework out there to help make this
possible it's very dependent on the kind
of application you're building the
framework you're in and exactly how
you're composing pieces together so you
kinda have to go back to those old
patterns books to see what are good
design patterns to help enable these
kind of architectures but once you kind
of set it on a good approach like this
that is not so coupled to any one
service then it makes it really easy to
add new kinds of appenders to append new
kinds of data those are just new
implementations of these things so that
was model side composition the next
piece for a back-end server side
composition is going to be view side
composition the view side composition is
very similar to what we had in the
browser side composition we're
effectively slicing our screen into
individual pieces but instead of those
pieces being composed in the browser
which may not work in every single
scenario we're instead going to compose
those on the server side such as one
piece of HTML being returned to the
end-user
now again at this point it's going to
very heavily depend on the server-side
technology that you have in this case if
I'm using asp.net core asp.net core has
a concept of a view components every
single MVC framework has something like
this but these view components in asp
net core are one their replacement for
the old child actions of MVC but what
these do is they encapsulate kind of a
mini requests on the server side where
the mini request includes some kind of
invocation kind of like a controller
action but hopefully smaller more
lightweight it encapsulates my
all for the individual widget and
finally some sort of view or template
associated with rendering that model so
after I slice up my screen to each of
these individual pieces each of those
individual pieces is going to be not
just a template to be shown but it's
going to include these view components
whence you capsulate the entire request
their other good thing about these is
they can include their own parameters
and business logic so I have to say you
know show me the product details for
this specific queue or the
recommendations for this specific queue
I can pass that parameter through from a
sort of top-level layout all the way
down to the individual components and
have it get that request specific
information from the very top level or
if there's some kind of custom business
logic which we'll see that can be
encapsulated as well the very last thing
is that this is typically invoked from
the view I'll typically a kind of a
master page layout the very top level
view that has everything organized
together these are the pieces that are
going to invoke those individual
components in MVC core the way we can
define one of these view components its
nets so of course we're just going to do
inheritance that's what they like to do
I inherit from this view component
object this view component object in
this case showing the stock information
whether it's in stock or not it can take
its own dependency in this case I'm
taking the pendency on an entity
framework DB context but of course it
could be whatever you want here if you
need to make a call to an API if you
need to make a call to some other kind
of in-memory service I've made a call to
maybe a Redis provider for cash
information it's really completely
encapsulated inside this component about
how to get the information is going to
be showing on the screen so in this case
I'm going to go to the DB context get a
list of the stock items that match that
individual SKU and then finally display
that view on the last line there and on
the view side I'm only trying to show
that one individual widget on the screen
so the HTML here is just that one single
widget almost always I have something
that can identify that one widgets and
this
case I have an outer div that says this
is the availability div and of course
this is going to be some junk for CSS
classes and then inside of that I'm
going to be displaying the stock message
to say whether this item is in stock or
not the model CSS class for in stock is
going to be green and for not in stock
it might be red so I also have the
controller the view component tell me
exactly how to display this information
on the screen next I need to invoke this
component from inside the outer layout
so this is going to be the outer layout
code that is trying to pull all these
different components together into one
single coherent user interface and it
can use this component invoke async ugly
way of doing things there's a better way
in HP net core 1.1 which I can just use
this tag helper to say show me the stock
info for this individual SKU in this
kind of compositional model it is the
outermost layout or template that is
defining exactly what we're just going
to be showing in the screen and exactly
how to call into those widgets the
widgets themselves most the time I'm
going to be using something like another
package manager to distribute these
probably nougat fur nets in which I
would build my package behind the scenes
and then it will distribute that
component out to the front-end so that
whenever the front-end runs it's going
to get whatever or the latest version of
my component is and that's going to be
what's getting plugged in to here as
well now we do have to worry about
component versioning as well so I really
don't want to break the contract of what
this what this what this these
parameters look like but for those kind
of things it's not I don't find those
pieces really break over time if I want
to show stock information for a SKU I'm
really not adding new pieces of
information it's just show me the thing
for the SKU and then it's done so to try
not to worry about too much like
versioning sort of things when it comes
to calling into these pieces because it
just don't find they change much over
time okay so we did browser base
composition we did server side
composition both in terms of building up
a single model for a complex widget as
well as views
composition where I'm pulling multiple
widgets together in a single page the
very last compositional option that
almost everyone ignores is going to be
database side composition now I'm not
talking about like again this is where
people can get in trouble because
they'll use compositional tools to help
compose multiple API calls together this
is really talking about a situation
where I want to pull multiple pieces of
information from the backend into some
coherent database structure that is
tailor-made for whatever we're kind of
requests I have on the front-end
now a great example of that is going to
be a search page this case I was again
looking for Justin Bieber CDs and I
wanted to just sit you know show me all
the Justin Bieber CDs there are that's
out there it looks like there's 352 of
them if you can believe that and if I'm
looking at trying to service this
request I don't want to put a burden on
all of my different service teams that
hey to say hey not only do you have to
be experts in this kind of in this kind
of technology and this kind of service
and this kind of capability that you're
doing for the business you also become
search experts because I'm going to
query into you and try to query results
out of your system this is another place
I can see I see a lot of
service-oriented architectures really
falldown is that they try to push the
burden of something as complicated as
search on to all those different
services it's not just search as well so
things like product recommendations
those customers who bought this item
also bought there are databases that are
designed to answer that kind of question
and if I try to push that kind of
question that's really hard to answer
for some certain databases like Zen try
to build a recommendation engine and
sequel server and live to tell the tale
yeah it's not fun at all because it's
not really built to like make a lot of
these different connections between
things but for something like this
there's really great tools out there
already existing and open source and
free this one for example we went with
elastic search which that is their
funny-looking logo a lot of six search
the way it works is you have it's
basically a fancy key value store
document database that it's little key
value that it built up a structure
each of these individual things I'm
trying to search on so all the
information you're seeing in this widget
that you can search upon has to go into
this one single document and then on top
of that I put on top of that different
indexes that allow me to search over
those individual documents so for this
one I can kind of imagine looking at
each individual search result there's
some kind of document that represents
that information I'm going to be showing
on that screen and that it can search on
as well I have to put all this
information into the search database
again because that's the primary access
I'm going to be using here now if I look
at this
and look at the service boundaries
different services own each of these
different pieces of information I have a
catalogue service that owns the kind of
master SKU ID and Product ID as well as
some basic product information there's
some sort of image catalog that owns the
content delivery network URL so this one
for example I can just go to a Bieber as
a source 100 score shirtless to find
that shirtless Bieber image it's not
actually true but it'd be nice if it was
the different formats for the music
that's coming from somewhere else
because again not every single piece of
content has every single piece of music
and it can change fairly frequently so
if suddenly Justin Bieber revoked his
rights for streaming for some unknown
reason then that would need to come away
from this result and finally I have some
sort of like review detail information
so like the number of stars up there and
then how many people are reviewed it
again I want to have that right in the
results now this is not all the
information from all these different
services I'm very selective about what
exactly information I want to include in
my search database because I don't -
just pollute it with the superset of
every single piece of data ever
collected across all my different
services I'm being very purposeful about
how I'm building out this search
document but each of these different
pieces of data does not come from the
search service this is where the DBA is
kind of come in they're like wait a
second something's wrong I smell data
duplication we have duplicate data I've
got that same SKU in my product database
in that front-end search
servus I've got the same URL and my
content delivery CRM thing behind the
scenes it's now being copied over to the
front end and how we're going to manage
all this crazy amount of duplicate data
this is also where I see a lot of people
tried someone abandoned service for
architectural principles because they
say right we're going to build services
but we can't duplicate data because we
have to own that information the
services owning the information does not
necessarily mean that it's physically
inside their boundary there was a great
paper from Pat Holland this is one of
his more like family-friendly names of
talks that he has he has some not so
friendly for anyone but this one's
called immutability changes everything
now Pat Helen was an uh was an engineer
at Microsoft and some other database
companies before that who literally
designed a transaction system inside a
sequel server he went to work for Amazon
and Salesforce and said huh you can't
actually build these systems with one
single master database behind the scenes
you have to give up something in this
case we're giving up owning physically
all the data in your system so what
happens if I copy that data somewhere
else when is that okay well it's okay
it's the other services that are
receiving the information are not
allowed to change it that is it's
immutable I told them when things have
changed and they just have to take that
information and store it however they
want to this is exactly our search
service search does have some ownership
of things it owns the shape of the data
how it should be structured inside the
search database it owns the SLA of the
response how quickly it comes back as
well as how relevant that information is
to the end-user if the search
information and results aren't relevant
and don't make any sense to the end-user
well then no one's going to use search
anymore but for me these days I almost
don't even use Google or Bing or duck or
whatever if I know something's going to
be on a specific website like Stack
Overflow or Amazon I go to that website
and do the search because the search is
happy I'm so well good so the search
service owning all these pieces but
doesn't actually own any of the data
behind the scenes
so the entire document that we saw none
of that data is actually generated by
the search service there may be a
relevancy piece down at the bottom that
I clipped out but as far as the actual
product information search service
doesn't know any of that stuff now we
want to have happen is for the in order
for the search service to be at any way
possible to be used in Bilt's it needs
to make sure that the search data is
there at the time in which I'm
performing my search so how do we get
all these back in pieces to push that
information back up this is where we
start to build these backend integration
components there's a lot of different
names for these things
I call them denormalize errs because
there are taking kind of normalized data
from other services and squashing them
down into one single document for my for
my document database search database in
the front-end but this is a completely
out-of-band process that's happening
behind the scenes and not at all visible
to the end-user I'm pulling in all these
different pieces of data so that when
the front-end user actually performs
that search they're not going to
entities back in services they're just
querying to that one search database and
getting a result back and calling it a
day now for a lot of companies I work
with it's not as easy as drawing a
PowerPoint and like pointing an arrow in
one direction next I have to kind of
design how these pieces are going to
come together and so in that case you
can't have to go back to some of these
old integration books to say how do we
connect these back-end services together
so depending on the service I might use
different API patterns so for example I
could look at the catalog service and
say well there's just a known number of
SKUs in the system so why don't I just
call that API once a day do once a day
updates and pull that data into my
search database I just for however many
millions of things are a million of
things there are out there just once a
day
get the latest results and call it a day
now when I'm designing these
interactions and these integrations
something I have to keep in mind is how
often does that information change in
the backend and how quickly from that
information in the backend have to make
it up into effectively my cache on the
front end with all the other all the
other composition models we saw that can
all be like basically
I've data but for something like this I
have to make a choice about how how soon
does that information need to be updated
based on back-end changes and the truth
of the matter is not that often because
users don't care like if Justin Bieber
decided to change a CD name to something
else like how oft like how quickly is he
going to make that decision
well maybe Bieber would be changing his
mind about that all the time I don't
know but for something else someone who
doesn't have so many mind changes then I
don't worry about that information
making it to the front end so very
quickly it could wait a day because if
there's really no business loss in that
day of information being out of date
then who cares now even might have some
cases where information has already been
sort of pre composed for me so in this
case there is a there's a database of
images and SKUs but if I go look at my
API call as it turns out that
information was already being returned
with me with a catalog so I could just
say we don't have to call that service
at all we'll just sever the connection
and move on in the next one we may have
some that are more kind of old-style
services in the backend maybe there's
the use of the as/400 style of services
and back-end and for some of these I may
have to choose an integration style
I might roll it and I might not like but
I'll have to live with so in this case
for the format's it's something that
almost never changes but could in this
case maybe it serves a lot of other
internal clients and so we're able to
use an existing integration method in
this case it's just a file being dropped
on a shared drive somewhere and so we'll
just consume that file once a day to
suck in all the different formats for
all the different SKUs again it's not
the prettiest kind of code to writes but
sometimes I just have to work with
whatever is already existing there now
sometimes I have to react more quickly
to changes and in this case I want to
use a more reactive integration mode in
this case messaging is a great way for
us to be able to react to those changes
so in this case I have a review database
that's built on top of sequel server for
whatever reason and I want to react to
that information quickly because I want
to have to I want to make sure those the
stars that show up are pretty frequently
update
because if I go add a review I kind of
expect it to show up somewhat quickly so
in those cases I want to have that
information being pumped out shown very
quickly to the end user in this one I
may not have any existing integration
possibilities with me so this one I may
have to like by the DBA a bottle nice
whiskey take him out and say hey can you
go ahead and like add some triggers for
me they can generate messages and then
those messages I'll go ahead and consume
in my side and just don't tell anyone
please because we don't want the DBA the
DBA police to come on on us here so as
people make changes in the review side
it generates new messages that it
consume on the search side to update the
same results and reviews on my side so
when someone does something like show me
a product with more more than four stars
they don't give a result that says three
and a half stars because it was just
reviewed or something so basically all
these different compositional options
with browser side server side and
database side and none of these are
going to be a completely
across-the-board decision for you you're
really going to have to look at how your
application is built together and what's
the most important thing for the end
user but I would say for myself the
first thing I my very first choice is
just don't compose until it's absolutely
necessary composition is a very hard
problem to have it's very difficult
challenge there's a lot of tools today
to make your life easier in terms of
packaging and distribution but it's
still a hard thing to do so you want to
really make sure you have those
boundaries rights and the user
experience right before you partake in
this challenge by the way when I say
it's a challenge doesn't mean like we
should try it it should mean like we
should think carefully about it and not
just dive in headfirst
whatever compositional model I choose
whether it's browser side server side
database side whatever that is I'm going
to base that decision on what's best for
the end-user experience because again
the whole reason why we're having to do
this is have that last mile show the
user show the user this final user
interface and we have to be going from
that design backwards to see what are
the right ways we can pull these
different pieces together now again
we're building distributed systems so we
want to make sure we're not treating the
Elsie's to distributed computing as
truths I see people screw these apps up
when they just assume latency or zero
services are always up things like that
so treat those fallacies as if they're
always happened which is what I
typically do I just if I'm going to call
a server I always ask myself what
happens when this goes down not if or
not just ignore it altogether and the
final piece I notice especially for
something like the search service these
front-end UI services that start out as
just kind of generic pulling pieces
together can very often graduate into
their own service boundary onto their
own that fulfills a specific business
purpose so with that thank you very much
that was compositional you is the micro
services last mile we aren't here for
questions otherwise have a great rest of
the conference
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>