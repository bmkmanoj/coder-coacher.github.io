<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional C++ - Kevlin Henney | Coder Coacher - Coaching Coders</title><meta content="Functional C++ - Kevlin Henney - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Functional C++ - Kevlin Henney</b></h2><h5 class="post__date">2017-02-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mlkE8EJZODw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright alright morning um so what I
like to talk about is not dysfunctional
C++ but the functional stuff because
everybody seems to be talking about that
now it's a little overdue I wanted to
say about six decades overdue but you
know it's better better late than never
and everyone is looking at how they can
either extend their respective languages
to embrace more concepts that we find in
functional programming and indeed in
other paradigms but because there's been
a bit of a bit of a land grab there's a
bunch of stuff that now goes under the
functional bucket there's actually logic
programming and so on but there is this
idea that people are becoming a little
more open to it sort of brought a
paradigm ideas and there's a lot more
cross fertilization between languages
now any language that starts adding this
stuff later is automatically at a
disadvantage from its heritage so each
language is going to manifest itself
differently based on accidents of birth
it's there are things that it will
support better than other languages and
there are things in C++ were far better
than things in Java in supporting
functional programming and vice-versa
and so what I'm going to concentrate on
here is I'm not going to go a hard core
functional I'm just going to start
looking first of all at one of the
points of adjacency in other words what
are the things that are comfortable for
people who may already be working in C++
and a relatively nearby in terms of
their reach into the functional space
and then take things a little bit
further in one sense there's two aspect
there's two halves to this talk and the
second half is kind of the talk I'm
doing this afternoon thinking outside
the synchronization quadrants so apart
from obliquely mentioned concurrency a
few times this morning
I'm not going to explore that although
it's obviously one of the motivation
areas of motivation from C++ and
a functional approach I'm not going to
do that because most of that stuff's
going to find itself in this afternoon
so just so you know we've been wondering
where this stuff is why you're not
talking about concurrency there is a
specific reason to now in terms my
background I have a lot of standing
interest in terms of patents patents of
the way of thinking not as a shopping
list of cargo cult programming or I
should shove into my program every
patent is a problem-solving structure so
I generally approach things when people
present me with new language features or
new library extensions I that although
there's a little bit of me that enjoys
the technology for technology's sake the
little language features for their own
sake so there's also another bit of me
that goes yeah but why would this be
useful is this a is this a solution in
search of a problem and in many cases we
do find this to be the case so I'm very
interested in or why would I use is what
problem does this solve which for me
characterizes why I'm interested in
different languages and paradigms but
I'm also interested in the code level of
things and why pull together this book a
couple of years back I've had a past in
which I have been involved in the C++
standard as well as a couple of other
languages and a couple of other industry
bodies but what I'm going to do is I'm
going to start off very very simply with
a very simple perspective from Michael
fellows and yeah there are lots of
different ways of characterizing
different paradigms we're going to pick
on object orientation and functional we
could talk about procedural we could
talk about logic we could talk about AFP
and a bunch of others but let's just
pick on those two and there are
different ways of characterizing them
and I quite like this one from Michael
feathers it fits conveniently into a
tweet object orientation makes code
understandable by encapsulating moving
parts functional programming makes clear
understandable by minimizing moving
parts and that's not a bad way of kind
of capturing the respective ethos of
both of these things and what we see
with functional programming is this
reduction of moving past is very very
helpful now that is obviously not
something that is unique to functional
programming it is just strongly
characterized with in functional
programming
certainly when I started working in C
and C++ extensively I've had the good
fortune to have been exposed to a couple
of functional programming languages and
I found that very strongly influenced my
style around that second sentence that
idea of reducing state change localizing
state change minimizing state change
very powerful concepts so taking this
into going to kind of the source of all
functional wisdom or at least Haskell
programmers which have you believe that
that's the source of all functional
programming wisdom this simple idea in
functional programming programs are
executed by evaluating expressions in
contrast with imperative program where
Perisher programs where programs are
composed of statements which change
global state when executed one thing to
understand here is that there is a shift
in the terminology normally when we talk
about global state we are talking about
a globally accessible via scope state as
in this is a global variable or
sometimes people say well we don't have
global variables in our programming in
our programming range because we're
using c-sharp as I as well yeah you do
statics public statics are basically
global variables as a scoping etiquette
but they are still global that is what
most people will refer to when they talk
about global state or is being referred
to here is the overall accessible state
of the whole program that is that is how
they view that they're not talking about
global variables here functional
programming typically avoids using
mutable state okay so observations many
programming languages support
programming in both functional and
imperative style but the syntax and
facilities of a language are typically
optimized only one of these styles and
social factors like coding conventions
and libraries often force the programmer
towards one of the styles now I think
this for me is one of the most important
insights because people often will come
into a language or paradigm they will
look at the language and what it offers
divorce from its eco system but also its
culture social conventions found this
fascinating quite a long time because in
my
long long distant past I programmed
Fortran and I remember when when people
started talking about Fortran having
modules and things added and I was a
little skeptical that some of the data
abstraction facilities have been added
would be embraced widely and that
skepticism is actually reasonably well
borne out because it's just not in the
culture that's not where the as it were
the center of that language is and so
what we find is that there are languages
in which you can do a number of things
that people don't either because of
expectation because of history but also
there's a strong pressure exerted by the
libraries around them and people
sometimes find that they have to swim
upstream in order to get the effect that
they want so what we see is the
influence of all these other external
factors not just the language itself I'm
going to try and isolate the language a
bit here but I want you to recognize
that this is what kind of holds sway so
for example a number of languages have
had Landers or lambda like facilities
for a very long time but it was only I
mean I'm going to pick on JavaScript for
a moment JavaScript kind of basically
gave Landers to the masses but it was
really particular frameworks and
particular styles and event driven
programming that really drove that into
people's common everyday P program if
you look at the early dhtml stuff very
little use of this idea of anonymous
functions being passed around and then
you look at modern JavaScript the world
has changed quite radically and also in
terms of supporting it so what we see is
that some of these frameworks and styles
and architectures will influence that we
may see the same thing happening in C++
as the years on fault now I guess the
first question I ought to ask because I
know part of the answer this is who here
is actually actively using C++ so I can
find out okay has used C++ in the past
right okay using C++ 11 onwards okay so
okay so I'm going to try it that stuff
quite a large gap to bridge because I
know Shawn there is on the committee so
that's quite that's a bit of a span so
I'm will not try to keep all of the
people happy all the time so if you sit
there in curly bracket misery that's
just
you know too much okay so let's pick
some practical examples cuz people
people often say well you know is
anybody actually using this stuff is
anybody actually using this to influence
their architecture and playing it simple
yes example from Facebook in talking
about how they built the moment
subsystem to keep our C++ API boundaries
simple we adopted one-way dataflow the
first thing to observe they are driving
this from the idea of simplicity so
there's a goal here they're not they
don't open with efficiency or rather
they open with developer efficiency not
runtime efficiency they're opening hand
is let's try and keep the API simple
okay let's try and make this easy to
work with
okay adopting one-way data flow
basically one-way data flow allows you
to eliminate the challenge of
interaction interaction is a non-trivial
thing that we deal with in code I do
something over there it does something
back to me and suddenly everybody has to
know everybody else's state will know
something about them so there is an idea
here of reducing the knowledge and
coupling within the code one-way
dataflow is simply a way of saying I
hand something off and actually quite
frankly I have no idea where it's going
to nor do I care so you can structure
code in that way and we see this in the
adoption of reactive programming and so
on again not going to Delhi from
Facebook but that idea of being able to
I just pass it on and I really don't
worry about it I can have a very simple
view of the world I receive stuff I pass
things on my receive stuff I pass things
on does simplifies things radically the
API consists of message to perform
fire-and-forget mutations so state
change may happen but if you don't know
about it your little bubble universe is
effectively immutable so there's kind of
like sleight-of-hand trick that a number
of functional programming and functional
architectures actually achieve by saying
well this piece of code doesn't actually
know that there's a piece there's a
side-effect caused over here and it
doesn't affect it it is not affected in
that sense as opposed to something like
a classic observer relationship where
perhaps I send a notification something
comes back to me and says well what did
what changed well
is clearly a coupling between the
Turbots if I send a notification saying
here is everything you need to know I
have no idea what this other party is
going to do with it this view for
example so therefore I have a very
simple view of the universe it's a
constrained one my bubble is immutable
change happens elsewhere if it happens
at all a message to compute view models
required by specific views in other
words of view being effectively
immutable to keep the code
understandable again the developmental
view we write functional style code
converting converting raw data objects
into immutable view models by default ok
now we actually start caring about
performance as we identify performance
bottlenecks through profiling we added
caches to avoid recomputing unchanged
intermediate results in other words the
idea is that it's a smoke and mirrors
thing we're going to support the idea of
a simple programming model and if that
means we have to do more work under the
hood then we do more work under the hood
rather than expose it on the outside
this is very different if you've dealt
with legacy C++ code this is kind of
quite different legacy C++ code has this
very strong characteristic of mechanics
on the outside and that's what it feels
like that you're always combating and
dealing with mechanics the word
simplicity is not the first one that
comes to people's minds the resulting
functional code is easy to maintain
without sacrificing performance so
there's that simple idea of this these
are the priorities just how we're going
to reason about it so I'm going to start
off with just a very simple kind of
having mentioned the observer approach I
want to look at how we can move around
the move around the space and get again
a sort of uses a little bit of way of
exploring and flushing out a couple of
C++ 11 features as well as differences
in error in terms of how people would
approach C++ so it's winter as I slid
from the hotel over the paving stones
began here it's a bit chilly so
therefore the heating system is it's
quite useful and I'd rather not have to
just turn on the heating system myself
and turn it off manually what I'd like
to do is have a timer and trigger it
from a timer so here's the timer I'm
going to try and decoupling
timer coupled directly to the heating
system so in kind of mezzo era middle
C++ the way I do is I just go to pick up
the Gang of Four book and say right I'm
going to decouple this using a command
object and I'm going to have a command
object timer the command object will
then go and run turning on or turning
off in fact I have to do that kind of
yeah so it's very simple I end up with a
sort of interface like class purely
abstract there's nothing else from that
interface except perhaps a virtual
destructor and so we have this kind of
ritual and choreography and it yeah it
kind of gets a bit boilerplate II very
very quickly if we look at this I've now
got to turn on command I pass in a
heating system I remember the heating
system I override the execute function
and then I turn the heating on so it's
called back I turn the heating system on
and I have to remember the heating
system so I've got private state there
is only one line of code that actually
does anything in there and everything
else is just padding and that's just
turn on so in the name of enterprise
coding we go and copy and paste that and
just change a couple of things and then
somebody says what maybe we could use
inheritance and factor out the common
out and just down that pathway lies
keystrokes and boredom there is no real
benefit to this this is a lot of work to
get a very simple idea of could you
please turn on at this time could you
please turn off at that time the idea
that might that the English is actually
far far shorter and easier to understand
is definitely not working in this style
favor okay so some people then realize
in the C++ you know they recognize and
this is the problem with a lot of C++
out there is it's not really C++
regardless of whether it's C++ 11
onwards it's C+ it's kind of right well
yeah see with a few bits of C++ thrown
in and a little more bits of library and
a little more type safety and they will
reach for the void pointer they will
reach for how they did callbacks and see
and there is a problem here although
I've tried to name this in the use
syntax that make
as clear as possible what I'm going to
do is I'm now going to pass in a
function and then I'm going to pass in
the data that the function must operate
the only way to make this general
purpose and decoupler ball in a
statically time language in this sense
is to use the void pointer now the void
pointer is quite simply a way of telling
the compiler hey thanks for your help
but trust me I'll take it from here you
know it's it's there there's a sense if
you're if you've got void pointers
floating around high level code it is
not high level code the perfect voice
pointer is there for a very good reason
this is not really it there is also
something else missing here there's a
coupling it's an important idea there's
a coupling between the function and the
argument that you pass in the coupling
is they must be the right type when you
bind things together when you have two
things that are coupled together we tend
to call that a thing or an object so in
other words what we've done is we've
defragmented an object two things that
naturally go together should be together
we've gained the opposite direction here
but for this there is a benefit there is
a brevity you know rather than having a
huge amount of boilerplate I've only got
a tiny amount of boilerplate it's as
ugly as sin and if you are not currently
if you've not currently incorporated
keyword casts into your coding style and
they've only been around since the mid
90s and I never see plus plus world gets
a little geological in its place
sometimes but I remember having a
discussion with somebody they objected
to the use of things like static cast as
opposed to old sea star casts I said
well I just think my code look ugly I
said well caster an ugly thing and they
should not look beautiful they should be
if there are ugly things they should be
easy to identify and they should also be
very graphical so yeah we've got this
however we are playing a little fast and
loose with the time system so yeah this
is this is sort of a c+ approach now
from kind of boost boost libraries and
uh Gregor's work originally on this
through the TR one technical report one
that informed quite a lot of the library
editions and C++ 11 and
polymorphic function rappers are added
the idea of a universal function pointer
effectively very simple idea I can now
point to a function I can point to a
member function I can point to an object
that masquerades as a function it really
doesn't matter as long as I can call it
like a function then that's good and I
can pass it in there so this idea of the
universal function point of being
provided in the library rather than
language there's a sort of a tighter
relationship we're going to see in a
moment with library and language it this
is definitely when it comes to standard
function it is massively convenient but
I would say it's a little bit like
sausages if you look at the
implementation it's one of those things
that's you know many people enjoy eating
sausages but if they saw how they were
made that'd be definitely be a less keen
on it so don't look at the inside of
standard function just use it as a
universal function pointer and so what
does that give us well the simplest
thing is that now we can actually are
now actually declaring two objects on
and off two timers but what I've got
here is I no longer actually have
introduced an intermediate abstraction
in the first command style solution I
introduced classes with a lot of
boilerplate code in the C style solution
I introduced functions which still have
a little bit of boilerplate and also
played fast and loose at the time system
here I don't need anything intermediate
whatsoever the bind function does it all
for me okay basically it's a partial
application it takes the heating system
turn on function and it binds it to the
heating object takes the heating system
turn off function binds it to the
heating object and for later execution
and that's what happens so there's a
really good decoupling here we are now
just working with functions effectively
we can go a step further and use C++
Elevens lambda Sigma X where I simply
just pass in now this is where the
language in the library can't get it or
what rather the language and conventions
get a little bit closer together the the
function function objects are
surprisingly efficient
there's no real indirection going on
with them they generate the lambdas
actually generate simple function
objects from compilers point of view
they're available for optimization so
they aren't genuinely objects it's just
that you cannot name or talk about their
types meaningfully and they're very
lightweight there's no there's no
indirection no real interaction going on
here and this one works really rather
nicely and is actually slightly tinier
in some ways than the bind solution
which was this kind of the default way
of looking at it now when we look at
Landers a lot of people will go like hey
look Landers that's that's very
functional and of course they are the
foundations of functional programming
but these also worth pointing out that
this solution is both a good
object-oriented solution and a good
functional functionally influenced
solution the idea that being able to
pass a function around is a purely
functional idea is definitely not the
case it's been the idea being able to
pass a block of code around as an object
has been present in function
object-oriented programming since 1967
with the first programming language that
could claim to be object-oriented
simulator and a stimulus 67 it was
possible to pass blocks of code around
but somewhere in there that kind of got
lost and we're only just rediscovering
it here and if you take it to its
logical extreme this wonderful
observation from William cook paper from
about five you five six years back on
understanding data abstraction revisited
makes the observation that lambda
calculus was the first object-oriented
language if you really explore this in
terms of what lambdas with closure you
end up with a perfect object model
although he's wrong about the years
actually older so basically
C++ 11 onwards allows you to program
like it's the 1930s for like yes back to
the future but there is some joy in C++
is choice of syntax every language goes
its own way this is actually legal C++
this is a lambda that takes no arguments
and does nothing and this is its
execution
yeah so you can have great fun with this
kind of stuff but yeah so that's a legal
character sequence feel
three in your board moments to see other
long character sequences of punctuation
you can have a lot of fun with this so
take this bit further in 97 things
there's a nice observation from Abel
Gance and applying functional
programming principles refers to
referential transparency a desirable
property implies functions consistently
yield the same results given the same
input irrespective of where and when
they are invoked now we often look at
this
sometimes people approach this from the
point of view of mathematical elegance
but there's another aspect here and this
gives us this gives us the idea of
reducing mutable state because for
something to be consistent in this way
you can't go around changing stuff so a
function evaluation depends less ideally
not at all on the side effects of
mutable state now I'm not going to
advocating mutability for its own sake
I'm leaving an advocate it based on
mathematical purity or even fashion it
is quite simply to do with this it goes
back to a point I made earlier in terms
of cognitive load understanding the
ability to understand something if
everything keeps changing you have to
keep track of that as a programmer and
the more plates you keep keep spinning
in your head the more likely to fall so
this idea very very simply is we can
have this simple concept of flow and
that thing is exactly where I left it
when something does not change when I
leave something it does not change for
reasons that are unknown to me or
surprising I'm not even talking thread
to you can get all of this in a
single-threaded program the principle of
astonishment a principle of least
astonishment is often violated through
such mutable state so there's a simple
idea that the last time I did this I got
this result the next time I do I should
get the same result it allows you to
focus more on the code and less on
managing the state Bertrand Meyer
captured this by saying asking a
question should not change the answer I
can I'm going to make a bold bold
observation here I suspect virtual
miners and have kids because this
definitely is not a child's property
it's a property of mathematics but not
some children but there's another
observation it's sort of a follow on
which is asking
nor should asking it twice ditto for
children okay but there is this idea
that you keep asking the same thing and
you get the same answer there is a
consistency here so the most obvious
entry point C++ on this one it's going
to be something like Const and Kant's
correctness again as a that's something
that people find they struggle with
depending on their background I have to
say that through accidents of early
exposure to functional programming ideas
I found it a very comfortable thing to
slip into when I were - when I started
working the C++ the idea and many
deep-sea c89 the idea that I was able to
say look this one shouldn't change and I
know it's not a hard and fast promise in
a language that supports things like
avoid pointers and memset it's not a
hard and fast promise but it's a fairly
good promise and you can do an awful lot
to have it supported and throwing back
at you if you violate it and it's also
an act of communication that is
enforceable but passing everything
around we also care about references
some objects get quite large we rather
not copy them around by by values they
get too large so therefore we pass
things by constant reference C++ 11
onwards allows you to use r-value
references
therefore mitigate certain copying costs
again this puts a lot more load on many
developers of their developing new
abstractions but I think one of the most
comfortable things is that if you're
using just standard library this has
been done for you if you're passing
vectors around and returning them by
value you are not paying the cost that
you think you are by looking at the code
this is a really important point because
sometimes people will distort their
coding habits because of anticipated or
mythical performance problems but let's
take a step further how do we isolate
code for this referential transparency
idea why aspect is immutable value to
find a value object type whose instances
are M useful but C++ is a copy based
language
so although we care about this
immutability at one level there's
another way of achieving isolation and
the other way of achieving isolation
is by using copied values again this is
one of those things I want to pick up
from a comment I made earlier about the
differences in languages and where they
start from if I'm working in something
like Java it's more natural to use this
because Java is a reference based
language everything is pointed to I'm
passing everything around by sharing it
that's how I communicate that's its
default mode this is actually quite
uncomfortable in Java and requires
programmers to remember to clone objects
and it's not particularly efficient you
keep hitting the heap all the time so
this is the natural way of expressing
that C++ has a default mode of saying I
copy if you if you name a type then it
gets copied and that gives us a certain
isolation in other words the idea that
if I have if I am an object that has
state you asked me a question I can
return you a copy of that and you can do
what you like with the copy but it will
not affect me similarly if it were
immutable I would have an isolation
there as well so there's this idea these
are two techniques for isolating things
make a copy of something or make it
unchangeable something I'm going to pick
up this afternoon so for the sequence
plus point of view I'm going to pick on
them my old favorite the the date class
states are always hot I do this for a
number of reasons one everybody's
familiar with a domain two very few
people are actually really deeply
familiar with the domain no I'm not
going to do a full date class that's
that's great fun but well beyond the
scope of this tool so there's only one
true ordering for the constructor I'm
going to pass it three integers I could
use types to distinguish those but that
that's not relevant to this example but
there's only one true ordering this ISO
8601 year-month-day you're using
anything else you're wrong okay as
simple as that there's three orderings
big-endian little-endian and middle
Indian middle Indian is what is used in
North America and it was a reminder of
why we have an Atlantic Ocean against
the night it's an isolation war but here
yeah Mother's Day I'm going to let the
compiler default the copying operations
and others I'm going to get the Year
getting a month get the day in the month
set the year set the month set the day
in the month
this is them this is a kind of a habit
that people have for every guest they
have a satyr and they don't even know
they're doing it in fact sometimes we we
optimize doing the wrong thing by
allowing IDs and editors it's like yeah
generate me a pair of those people don't
even know they're doing it when I run
when I run classes I'm often fascinated
by you know somebody well you've got a
setter for that oh I don't know I didn't
realize I had that there even though
they just go into a kind of like a fog
of just like Auto typing I've got our
guys I've got some data member I must
have a getter and a setter I've even
seen a coding convention that says for
every data member you must have a getter
and a setter so it's a an encoded way of
doing doing the wrong thing badly so
yeah just because you have a guess it
doesn't mean you should have a matching
cetera
so I'm going to slap slightly and we'll
have a setter let's treat this
transactionally typically you don't just
tweak dates you normally have something
that you want to do you don't go through
intermediate states that are awkward
either the idea is for example if I have
the 30th of January and I decide that I
want to move this to February clearly
there's a sequence dependency there if I
try and set the month to February whilst
I've left the day in a month at 30 then
that's invalid but if I swapped the two
operations around then suddenly it
becomes valid and it's capable Hank this
is a bit awkward we don't want to get we
don't want to get that situation I want
to treat the date as a whole so we end
up with a set that's a lot of people
will walk into that then you get today's
date set like this what many people
don't realize is they've already got
this operation we don't need this we can
actually restrict the mutability in
other words what I'd like is a date
class to be I'm going to leave one
mutable operation and it's actually the
one generated by the compiler we've
already got it yeah it's called the
assignment operator if I treat the
assignment as a rebinding then
everything else is about the object it's
about asking a questions you get to
create it you get to ask it questions
and the only other thing you can do is
assign and that's that's already taken
care of if you're worried about
validation the validation happens in the
constructor we don't need to repeat the
validation code validation code takes up
a lot of space when people have these
individual setters and yeah I can
achieve exactly what I did before but
it's now simpler
but I can also take this a step further
I mean we can start playing around with
C++ eleven syntax we can start getting a
really quite light the only other thing
I would suggest here on a point of so so
this is kind of basically my
recommendation you're going to start
creating value types where possible
don't have state modifiers treat them as
they were as if the only operation that
you can change is to rebind and there
was treat assignment as rebinding but
also I'm going to say get rid of the
noise get something is an imperative
with an expected side-effect this
programming this this little naming
thing that we've been doing I found an
article that I wrote in 1995 where I was
complaining about the prevalence of
people using get as a prefix it has only
got worse since the 90s and people use
get as if it's some kind of natural
query but if you think about it in
English that's not its role get is not a
query it does not mean go go and do
something without side-effect it does
not mean ask a question okay we've ended
up with this rather dysfunctional noise
prepended to all of our functions and I
get money from a cash machine there's a
huge great side effect on my bank
account disappointingly if you get
married there is a state change in your
life okay it is not without side effect
so it's it's not perfectly healthy and
so therefore if you want to try and
embrace a more functional approach that
I'm going to make a very simple
suggestion stop using imperative names
get is an imperative names you want the
code to feel functional you got to get
your head in the right space language is
strongly influential and what's
interesting is the minute I drop the get
this simultaneously becomes better
functional code and better
object-oriented code yeah we get rid of
the object-oriented assembler that
plagues so many code bases ok so that's
great if I want to change the whole date
but normally people don't want to just
change the whole day and they will
object this is it we'll look that I can
I see what you're doing there but
actually I do want to just change them
I want to deal with the first of every
month I want to cycle through the month
so I really just want to change one
field effectively well okay let's do
that so what we're going to do here is
we're going to just say okay I want that
date with the year as something else or
with the month of something else or with
the date they in the month or something
else rather than change that state we
asked a question what would the day be
if we did that so this style is kind of
the Builder style we see that in a
number of fluent api's it's very very
common but it is sometimes it's not been
as embraced in this respect as I think
it could be people often use it really
for building complex option objects
that's where they think about it or
creating full dsls
but I'm going to say that every small
class every single value type is its own
little language you need to kind of
explore this idea of how do I talk about
the values and their relationships
that's what you want to talk about the
relationships between values
hence functions that is what they are so
we end up with a style that looks a
little bit like that
and should we not wish to reinstruct er
which that call is doing their greet we
wish not to reinvent the constructor if
actually it turns out that the result of
the operation is exactly the same as the
current date then we can put that into
the point is that that's hidden behind
the scene and we can elaborate it with
year with month with day month and so on
so we end up with some very very simple
styles and it's really a case of what we
need to do is when we say we often talk
about abstractions we say for my data
types for the values knowledge that my
code has during runtime what are the
things I can do with this object and
perhaps do is a bit misleading that's a
very strong imperative and we tend to
default to thinking about the idea of do
having a side effect and we think of
many objects as being state machines
which has its value but perhaps a
different way of approaching this
particularly for value style objects is
to not think about doing but what put it
another way what
can I ask you this what conversations
can I have with this object that puts
you in a slightly different frame and
you're less you end up not dictating the
terms of things you end up having a
reasonable side-effect free conversation
that is based on transformations which
is exactly what's going on here
now as you fully aware most code doesn't
just deal with data examples you
normally have that most most most state
in code is inside collections inside
containers of things how's this kind of
thinking apply to that sometimes people
feel they hit a brick wall it's yeah I
see the individual values I can support
these immutable ideas I can have this
idea of a much more pure style but I
need containers of this stuff I need
vectors of this stuff I need masses of
stuff so here is a question and
containers how do we do this so I'm
going to imagine so this is another real
library I'm just going to sort of put
this out there as I have doodles around
with this someone on my machine in the
past I just could put this one out
there's here's an idea I'm going to joke
you know jokingly called the FTL a
functional and a template librarian
supposed to be STL what would be
involved in such a thing if I were to
adopt a functional style what would be
involved well I'm going to have all my
value types if you asked for van types
it's always going to be constand
iterators we only have one iterator type
there are no considere ters because
there's no difference between a
constituent and it's ready to keep
anything really simple you can ask a
container it's empty its size begin the
end the only non constellation we're
going to offer is the assignment
operator and again I'm going to use the
philosophy of rebinding okay what's that
going to look like we're basically
saying the containers not going to
change we're going to be a very simple
example to start with a set and this is
a truly immutable set once you've set it
you cannot change anything and there's
nothing else that you can do with it
except asking questions and relatively
simple questions here I'm going to
choose a optimal representation and
sense why I'm going to represent it as
an array of its value members
therefore it's very cash friendly it's
going to be in sorted order
therefore compatible with your idea that
you find the set in the STL and you can
find things you can count things you can
you know you can do the basic search
operations and we can initialize it I'm
going to use the superclass 11
initializer list perform there
in fact that's essential to this
approach I don't need a builder approach
to build this I'm basically going to say
this is great for reference data in
other words I have a set of things
that's never going to change and I would
just constantly like to just check
whether something's there there's no
tree structures involved there's no
hashing involved this is very very
friendly and very fast to look up I just
can't change anything nonetheless there
are cases even regular code where
without transforming when I say regular
code I mean regular C+ that's where this
turns out to be useful that's another
example have an array an array actually
looks very much the same but I can index
into it and again this is completely
immutable
once you've set the array you cannot
change its content its size or anything
like that and this is logically similar
to the C++ 11 array template which is
actually mostly useless I found part of
its reason for existence was to allow
simple initialization but we find that
it's less useful and we hoped
ok this is all good but you can see that
this only applies to a very very
restricted range of things that I want
to do I really have to know the values
that I want when I create an array or a
set and I cannot change them I cannot
change anything about it there's no
transformation here that is going to be
cheap so how do we get around this why I
don't propose to give you a full
introduction to persistent data
structures I'll give you a light
introduction to persistent data
structures persistent data structure is
a data structure that always preserves
the previous version of itself when it
is modified such data structures are
effectively immutable as their
operations do not visibly update the
structure in place but instead always
yield a new updated structure there is a
sleight-of-hand
in other words there's a very neat trick
that we're basically saying if you hold
a container and somebody else comes
along and maybe pushes something into it
or pop something from it they will get a
version of that that is the popped or
the pushed version but you will retain
your version you will retain your view
they will actually get a effectively new
object but the way that it's done is
that nobody can ever prove we've had a
debugger but actually new stuff and
side-effects happened okay so it's a
beautiful illusion not to be confused
with the other useful web persistence
although that said there is an
interesting idea that I observed
recently the position data structures we
often talk about in terms of concurrency
but even without concurrency they make
sense because they are all about
decoupling temporal decoupling
decoupling State across time whether
that time is affected by concurrency or
whether that time is later points of
execution they are bound in the same
same sort of ethical set okay so what
I'm going to do now is I'm going to a
bit of a simple vector this vector is
based on contiguous memory as the name
vector implies and we continue summary
and use of operations empty sides it's a
ray base as we can see down there I can
subscript I can ask the front in the
back and I can get the raw
representation but there are two
apparent modifier operations or modifier
related operations pop front and pop
back these are constant time operations
I'm going to maintain the ethos of the
STL these are constant time operations
and so it turns out that unlike the STL
the there is a pop front here that can
be done in constant time so similar
philosophy what we're going to see the
operation set is slightly different but
for just one moment I'm going to
concentrate on this I'm going to change
the names because those names have a
radically different effect if somebody
comes from the STL and looks for pop
front they're going to be surprised that
this does not do what pop front expects
they expect it to do pop front should
change the state of the current object
they are working from that is an
expectation has been
since the early 1990s but it also
there's another point here that I
mentioned earlier if you want to pop
back as an imperative what I'm asking
really something different this vector I
would like to see the popped front
version into more of an adjective
driven phrase and a verb driven phrase
so I'm going to use a different but
clearly related name but also one that
is not an imperative to distinguish
these so you get back now you get back a
new vector is that it's not going to be
expensive well not really because what
we've got here is in the representation
we've got basically pointers iterators
showing you where the beginning and the
ending are and so therefore you can pop
front and pop back to your heart's
content and share the representation or
what's happening in each pot each pot
front and pot back operation is a return
of those three a return of the anchor
and the Fromme and the until and that's
all good so what's this looking like in
memory it's going to look like this I'm
going to end up with say a variable a we
initialize our vector with four values B
equals a okay we're now aliasing now an
important point here and one of the
things that C++ favors in contrast to a
number of other languages is that I can
maintain a solution quite successfully
thanks to the use of Const because I've
said that it only contains Conville use
there's no way that B can make changes
except by doing the extreme violence
that is available to us in C++ but
that's generally visible through casts
but there's this idea that actually by
default there is nothing that somebody
can do to change the view that a has of
this this is very different to something
like Java JavaScript and most c-sharp
stuff where by default you have no
ability to say by the way the contents
of this cannot change the best you can
do is offer a comment please don't put
objects in here that could be changed by
other means the point here is we've
actually got a type level guarantee
about how we work it doesn't it does
work with the way that we work now more
interestingly is what happens when we
pop it C equals a pop front we get back
the version that looks like this as far
as the user of C is concerned they've
now got a new vector that is only size 3
the user
they does not see any change B sees the
same thing as well that's great for
popping but sometimes we want to push
now the only way to get that sorted is
to use a linked representation so we can
we can link this out and we can end up
with a we can do the B thing again we
can do the pot front but now this is the
great illusion if we push then what we
end up with is a new prepended head and
if somebody else pushes on the front of
it you end up with another beautiful
tree in memory the idea is that
everybody is sharing representation and
there's no side effect without doing
violence with the type system there's no
side effect that they can induce that
will undermine this illusion so the
representation sharing that guarantee
that gives of some kind of guarantee of
immutability is absolutely profound in
this it's also not a new idea this idea
is really rather old I quite like old
books this is my copy of the list 1.5
programmers manual it's originally
published in the early 1960s it turns
out we knew this in the past
it did have a brief obsession well two
brief obsessions was list at different
points in my programming career no it
never never programmed commercially but
I did point out I have a deep fondness
for the list model it's simple elegant
and something with which all developers
should have an infatuation at least once
in their programming life because it
will change the way that you sick just
have a you can have the put in fact
raishin in private you don't have to
make it public you can do that and you
know if you if you think lists a bit old
hat go for closure nobody's watching so
there is this however and actually this
is part of an article series that I
wrote when I was writing for the CC post
after users journal it's also a timely
reminder I was always told never write
articles that have part numbers in them
I used to and I had two columns for
different magazines where I submitted
such and such part one and the editor
came back and said I'm going to change
that title I said why said well I don't
know that you're not going to get run
over by a bus or that we're not going to
fold as a magazine or that you never
submit the second part or something
happens you know just it should
reasonably self-contained so the only
time I've ever successfully published
something that's called that has part
one of it is this one and I've never
wrote part two so I left people hanging
there for a bit and in fact there's an I
wrote this class called there was a list
I was very pleased with that the idea of
a list that is list like in C++ very
probably put more effort into the names
than anything else but there is an
important point there there is a
dangling reference here to part two part
two never existed and this leads us into
one thing if you have been watching this
closely you you may have noticed there
may be a little problem and we just show
let's just show what the list let's just
reclaim the idea of a list which is
effectively a forward list this is how
we might represent it that list that I
showed you that is that that holds
constant front and pushed front there's
no back operations and we've got a
classic kind of link structure in there
it's a singly linked list I put the
length in there because you can actually
reliably hold onto the length here where
is that not the case with forward lists
in standard but if you're watching
carefully there's a little bit of a
problem that problem is that in not a
single one of the slides that I have
shown you have I talked about there's
this question I've got raw pointers here
have I talked about the question of
memory management which is the the the
classic the classic issue that people in
company with data structures such as
this and and so there are basically two
philosophies and two philosophies of how
you deal with objects you're no longer
using and
it turns out that Shakespeare carefully
and cunningly coated these two
philosophies into Hamlet now you thought
that this was the tragedy of Hamlet
Prince of Denmark actually this was a
discussion about memory management
models very cunningly encoded Hamlet
favors garbage collection
yay from the table of my memory I'll
wipe away all trivial fond records he
favors that kind of approach now what is
C++ spend on this one that's an
interesting one and there is a funny
enough and I'm kind of glad Shawn's in
the room because we were on a panel in
Las Vegas 10 years ago 11 years ago was
it yes unlikely it was another decade it
was a long time ago in a galaxy far far
away and there was a question about the
future of C++ and what things you should
you see added and that was in those
heady days of optimism where people
actually thought that C++ Oh X the value
of x would actually be decimal and there
will be a 2008 or 2009 standard but I
mentioned at the time I said there are
four things that if C++ is consider to
be considered a systems programming
language which is its heart its center
if it is to continue to be considered a
systems programming language then there
are four things that it must have one of
them is concurrency it must be able to
support a threading model because
systems support threading models
increasingly therefore having a systems
programming language that has no view on
this is ridiculous
so I said that's an absolute must
another one was dynamic loading because
again operating system architecture has
been doing this for decades to have a
systems programming language that does
not have a consistent philosophy of
dynamic linking again does not make
sense third one was a decent system of
reflection there are large classes of
architecture that are enabled and
simplified through the presence of
reflection and these have become
increasingly common plug-in
architectures one of the things that is
you can always tell there's a difference
in terms of how maybe it's
plus plus programmer versus a Java or C
sharp programmer will approach something
in terms of framework design and one of
them is the availability of reflection
just opens up large classes of simple
approaches to Architecture and that was
missing from simpler stuff and the
fourth one was garbage collection
increasingly systems have a garbage
collector we saw this at the time was
dawn net having a C++ binding and the
workarounds that were enabled for that
so those are my those are my that was
what I basically said this the language
really needs to have these to be to make
it future well we got the threading the
dynamic linking is kind of happening a
little bit later than expected
reflection is nowhere to be seen
why not the garbage collection well yeah
so yeah sums it up on the C++ 11 FAQ on
his on his home page garbage collection
is optional in C++ that is a garbage
collector is not a compulsory part of an
implementation C++ 11 allows you to have
this actually it doesn't it does not
allow you to have it it allows the
vendor of the C++ compiler to have it
that's not the same as you there's very
subtle difference it basically means you
cannot write a program that is portable
and relies on garbage collection you
have no control I don't mind the idea
that it's optional but it's no longer
under programmer control I can't
therefore reliably all that code that I
wrote before when I wasn't managing the
memory and all the other slides if this
assertion satisfied in other words we
have garbage strong garbage collection
if we have that available all of my code
works if it if it we don't have this
available I've got memory leaks
everywhere and I can't ask for its
availability there's not a feature I
control it is a thing I can answer so we
have a little bit of a problem there
it's almost worse than not having it at
all it's a bit of a halfway house so
we're back to a failure it turns out
whose philosophy is more classically C++
tis in my memory locked and you yourself
shall to keep the key of it you can
have to manager yourself now for a lot
of people managing it was always a bit
of choreography and C++ 11 came along
and said you know what you don't have to
worry about this I'm going to give you a
smart pointer for reference counting the
shared pointer great that kind of works
a couple of little caveats is that you
have to provide your own deleter if you
wanted to delete an array but that's
that that that's not entirely
unreasonable but we also have to respect
this something else shed having a
reference kind of pointer is there are a
surprising number of inefficiencies if
it can be efficient in some cases but
there are some surprises Rob Murray
observed this a long time ago in C++
strategies and tactics he said his
observation from an implementation point
of view is certainly or certainly sound
use counter class is more complicated
than a knowledge non use countered
equivalent all of this horsing around
with use counts takes a significant
amount of processing time it is not
cheap okay there is a simple point here
the garbage collection run
asynchronously modern garbage collectors
running in different threads they will
be intrinsically potentially more
efficient and there are different
classes of efficiency you may care about
but if you are always hitting something
and expecting to increment and decrement
account that's going to pay you're going
to pay a cost for that particularly in a
threaded program okay there's a it turns
out that if you can guarantee your code
is single threaded this is just going to
be a simple plus plus or minus - if you
can't guarantee that you're going to end
up with an interlocked incremental
decrement
if it turns out that your object the
object that you are sharing is only
shared within one thread you will still
pay the interlock increment and
decrement the cost you have no way of
signaling from compiler by the way I'm
not actually sharing this between
threads so go with this minus minus plus
plus so there is a bunch of costs here
we haven't really taken it away from
programmer there's also an additional
memory cost there's a separate
allocation in this case unfortunately
because we can't use make shared so
there's a bunch of stuff here it's not
as efficient as people would like to
think of it and then there is a what we
might consider to be the ultimate
showstopper
if I put it into that list class what I
showed you I mean it for the vector
class works absolutely fine there's no
rule and there's no problems with other
than the ones I've outlined which
probably won't be too problematic with
this but the usage of this particular
type but if I go to the list there is
genuinely a problem if I transform those
raw pointers into shared pointers we
have a problem and that problem is a
very subtle one and can lie hidden it's
not that you can't solve it it's just
that you have to solve it and this is
the problem I'm going to have a list of
stuff doesn't really matter what the
stuff is the list of integers the list
of strengths that is not relevant
I'm now going to fill that list by doing
a push front I'm going to push for I
know basically and all of that I'll have
to do a little extra adaptation because
it won't know about pushed front but if
we do if we tweak around with that then
we would hope that we would be able to
create let's just add a thousand items
we end up with a chain we end up with a
list of a thousand links that's
absolutely fine each one of which has a
shared pointer pointing to the next one
so there's this is all good except for
one small problem I've put the curly
brackets into this example to highlight
the fact that chain goes out of scope at
the closing curly goes and a scope at
the closing curly which means that the
destructor for chain will be called now
this is a link structure so we've got a
we go to pointers of the head the
destructor for the head will be called
it is referring to one other objects so
it's count goes to zero it's going to
refer to another object hey guess what
you need to go as well because my
destructor is executing and we end up
with this down the chain that's great
except that it's a recursive call it
turns out this blows that blows your
stack for surprisingly small values you
should be okay with a thousand but
around 2,000 it blows up which is a
trivially small list
this is a problem it's not that you
can't solve it as I said and this is the
problem with the c-class plus community
I find at times that hey I've got a
really clever technique the fact that
you need a clever technique and you need
to see this is actually the problem this
is a problem at garbage collection
solves out of the box you have to you
cannot just simply have a simple
persistent data structure which is
frustrating from this point of view you
can have trees but you're going to
struggle with actually long chains so
this is frustrating
the plus side is that we get to use
Const which means we can ensure
something about representation sharing
but there is a complexity cost a
cognitive complexity cost and code
complexity cost and to dealing with
reference counting as our default way of
trying to manage sharing so wrap up with
observation from John Carmack and the
games demigod no matter what language
you work in programming and functional
style provides benefits you should do it
whenever it is convenient and you should
think hard about the decision when it is
inconvenient you may find you cannot
adopt all of these techniques or even
the super set because I've shown couple
of subsets of ideas here in your code if
you're already using STL extensively and
you've been shying away from functional
objects now is the time to kind of go
back and revisit that you will find at
the STL design was informed quite
extensively from Alec stefanos
experience with scheme it has a very
strong functional overtone it's not
necessarily fully functional but there's
a lot of stuff there that gets you
thinking a very different way from their
kind of classical C++ approach and even
traditional STL usage once you've got
once you start using lambdas and
binds and polymorphic function wrappers
that gets that starts achieving an awful
lot more in terms of this expressiveness
but it's not just on that side it's not
just a matter of Liberty sprinkling
Const over your code it is about
shifting the idea of this object
doubting that you should open with any
any discussion with an object you should
open with the strong doubt that you need
to change
it's state ok you should seriously doubt
that that is a reasonable thing to do
you should use that as your as your
position of design until otherwise
proven sometimes you will find actually
that this is the right way of doing it
state change is the appropriate answer
but rather than choosing that as your
default you should choose it as as the
the other answer the default should be
I'm not going to change it and I have a
battery of techniques that will allow me
to not change it but occasionally you
will come out possibly quite frequently
depending on the age and architecture of
your codebase you will say well you know
I recognize that this would be good and
I have fought hard about it but it is
not convenient but now you know ok but
you will be surprised how many other
cases can be moved over the line to
something that is not simply functional
for its own sake but actually really
rather simple to reason about and
understand so I'm gonna finish with a
Russian word that has incorporated into
the artist artistic world as a kind of
movement or philosophy Auslan aney D
familiarization the artistic technique
presenting to audiences common things in
an unfamiliar or strange way in order to
enhance perception of familiar in other
words what I've done here is taken C++
and try to offer it from a very
different perspective people often throw
phrases like multi-paradigm around but I
want to look at it just from that point
of view and show you where it fits and
where it doesn't and they have some new
ideas and I hope that has been useful
thank you very much
but I'm standing here so if you want to
ask me question asking questions then
that's great thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>