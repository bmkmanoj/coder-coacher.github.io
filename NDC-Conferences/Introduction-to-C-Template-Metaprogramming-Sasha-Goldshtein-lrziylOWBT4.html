<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to C++ Template Metaprogramming - Sasha Goldshtein | Coder Coacher - Coaching Coders</title><meta content="Introduction to C++ Template Metaprogramming - Sasha Goldshtein - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introduction to C++ Template Metaprogramming - Sasha Goldshtein</b></h2><h5 class="post__date">2016-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lrziylOWBT4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so basically building contracts for your
api's making sure our certain properties
of types are met before your API is
invoked and can do stuff at run time the
other thing is member detection so
basically building your own type
checkers which verify that certain types
have certain properties have certain
members have certain subtypes then we
have algorithm selection so basically
we'll specialize a certain algorithm
such as an STL algorithm or one of our
own based on the type properties that we
detect so we there's a bunch of examples
and I'll show you a couple and finally
towards the end there's a couple of
examples of compile time computation
with context / which really allows for a
lot simpler a lot simpler type checking
and a lot simpler computation where
you'd have to use recursive templates
and a bunch of complex stuff before I'm
going to just be using a lot of examples
and most of the stuff I'm doing here
requires C++ 11 should work with any C++
11 conformant compiler maybe except for
visual C++ which still has some
incompatibilities some of the code
requires C++ 14 but it can be rewritten
to only require 11 and without some
features such as deco type which were
introduced in C++ 11 it's quite hard or
anyway harder to implement some of the
things I'm going to talk about and some
are even impossible actually with the
older version of the standard
so some motivation and examples here's
an example of a situation where
constraint checking could actually be
useful so if you're sitting in the back
you can't even read this whole thing but
this is basically what happened when I
just launched xcode built a little
simple plus project and tried to use as
a map key a type that doesn't have the
less than operator right so i built an
STD map and the key is a type that
doesn't have the less than operator now
just declaring a map like that as you
probably know that
doesn't cause any issues in compilation
time however trying to use it so once I
try and insert an element into the map
with a certain key that blows up and
this is just a very small part of the
actual compiler error message that I
received but one thing to note is that
the error is coming from clammed in this
case is pretty decent so it's telling me
invalid operands to binary expression
less than where I am trying to invoke
less than on values of type Const foe
and foo is the key type in my map which
doesn't have the less than operator but
then if you look at some of the further
notes emitted by the compiler there's a
bunch of nonsense here so why do I care
about something called a tree with the
value compared and if you look a little
lower it has some ridiculous stuff about
not being match not being able to match
the operator less than four pairs of
whatever so if you're an experienced C++
developer you've seen this error before
and you know that you just forgot to
declare a less than operator so your
keys are invalid but for less seasoned
developers this is very troubling and
they can spend a while you know just
posting this thing to Stack Overflow and
getting flamed by everyone so better
error checking for example in the STL
could be really helpful if at compile
time we could get a nice error message
that says well in addition to all these
other problems it is likely that what
you forgot to do is just to declare less
than or specialized STD less for your
type and just move forward so the other
example I've mentioned is algorithm
selection where you have multiple
versions of an algorithm that can be
more performant more efficient for
certain types here's a couple of classic
examples from the STL which a lot of STL
implementations actually use so STD copy
can be specialized if the thing we are
copying is a plain old data type doesn't
have any sophisticated assignment
behavior and you're copying from pointer
ranges not iterators so if you basic
have mem copy situation and you are
allowed to just optimize and use mem
copy instead of the slower loop version
of STD copy that can be a considerable
performance gains for certain types
another example is a stealing distance
and distance as you know finds the
number of elements in a range between
two iterators so for certain iterators
such as random access iterators it can
be implemented in constant time of one
write and for say forward only iterators
you'd have to actually traverse the
iterator so you'd have an O of n a
linear time implementation so that's
another example of where figuring out
some information about the type could
help optimize an algorithm select the
right algorithm at compile time and then
another example as I said is compile
time computation so certain things can
be pre computed at compile time or
solved entirely at compile time one
example that I really hope to show you
towards the end is strength validation
so if the user provides a literal string
as an input to a certain function we
could check that that string has certain
properties at compile time instead of
throwing an exception at runtime and for
certain api's such as maybe printf right
it can be useful to emit errors as early
as possible at compile time instead of
deferring to runtime so there's a bunch
of users which hopefully illustrate this
is a practical thing to talk about even
though that the most practical in the
world the main tool we'll be using
throughout this talk is templates
visualization so this is just a very
very quick reminder of how this works
what it looks like so basically here we
have a partial and an explicit complete
specialization of the LES template so
les has an operator that can be invoked
as a function and it compares two
objects determines which one should be
sorted before the other we also have a
specialization for pointers here which
compares not the pointers but compares
the targets right the point is that the
things the pointers are pointing to and
finally we have a complete explicit
specialization for a char pointer
where we use strcmp so we're not
comparing the the chars we're not
comparing the pointers either we are
comparing the whole string until the
null terminator so that's just the tool
we're going to be using and hopefully
you're all familiar with that but it
never hurts to just see a quick example
so let's start with constraint checking
as you probably know in the standard
library
there's the header type traits which has
a bunch of useful metaphor which take
types and return in some cases values in
some cases types method functions
basically operate at compile time on
types and produce either values like
boolean x' for example does a type have
a certain property or other types so for
example you could have a meta function
that takes a type and adds a reference
to it so it produces the same type but
with a reference added at the end or
removes Const from a type that kind of
thing a lot of these can actually be
implemented pretty easily so if you're
looking for exercises on on meta
functions you can implement a lot of
these type traits yourself there's a lot
of corner cases to take care of but you
could a lot of these however cannot be
implemented without actual compiler
support so the standard library
implementation on a particular platform
would have to ask the compiler for hooks
which implement some of these type
traits because there's no way to express
in the language itself checking for that
kind of constraint so some useful
examples is pointer for example checks
if a type is a pointer type and you know
it sounds easy but if you actually look
at the implementation you have to take
care of pointers to functions and
pointers to members and constant errs
and pointers to constant a bunch of
other edge cases so it's useful to have
this in the library we have more complex
more complex traits such as is no throw
copy constructible right so does the
type T have a copy constructor which is
marked no except and will not omit
exceptions at runtime we can use a lot
of these and we can develop some of our
own type traits based on what's
available in the library
and based on other techniques as well so
here's a very simple example of using a
type trait this is not a standard
library situation it's just the type
I've figured I want to develop it's a
class called array there's actually STD
array in the standard library but
suppose that's not what we're seeing
here and my array wants to be a no throw
kind of type and now except type I want
the constructor of the array to not
throw exceptions I want all the members
actually to do the same and so if in my
array I have a statically allocated
array of t's I would like to produce a
clean error message in case that type T
does not have an on throwing default
constructor so I can mark my own classes
constructor as no except and that will
produce some error message if T doesn't
meet the necessary requirements but I
actually want to go further than that
and I want a clean assertion that says
exactly what happened if the user uses
an incorrect type so I can put a static
assertion that uses a standard library
type trait and checks explicitly that T
has a default constructor a
parameterless constructor which does not
throw which is marked know except
explicitly another example of using
traits in a situation that's not exactly
error checking but rather sort of making
sure your implementation is very
accurate is is this example from swap
over here so this is STD swap pretty
much with some minor changes introduced
everyone's familiar with STD swap and
what it does inside is it tries to use
move operations right in case the type T
supports move I wouldn't like to copy to
a temporary and then copy back from the
temporary I'd rather just do moves all
the way and I would like the swap
operator to be marked no except I would
like it but I'm not actually sure if the
code inside is going to be throwing
exceptions or not I don't know in
advance whether for example the move
constructor and the move assignment
operator 40 are marked no accept or not
so I don't want to omit an error in that
case I don't want to place a static
assert in my swap that says no you can't
use the swap function if your T is not
no accept because that just is plain bad
instead we could in this case for
example use the conditional form of the
no accept operator so we could say that
ok this function is no except in case
certain properties are met so this is
the no accept operator which takes a
boolean value that has to be known at
compile time
so my swap is now accept as long as T
has a no throw and no accept move
constructor and a no accept move
assignment operator if these two
properties hold then the code I wrote is
actually going to be now accept correct
so that's just another use of constraint
checking and type checking that we could
introduce even if not to omit errors but
just to make sure we're really
expressing ourselves very accurately ok
so suppose we have the basic type traits
figured out the ones that are in the
standard library but we have a unique
situation of our own we have some kind
of property of a type that we want to
detect that we want to test for one
example that I often use in in training
workshops is is determining whether a
certain type is an stl container okay so
for example imagine you're building a
serialization framework or maybe just
the debug printing framework that takes
an arbitrary object and wants to print
it as accurately as possible so if the
type already has an output operator
right then I'll just invoke that if the
type is a container
I would like to detect it's a container
and print out the contents right print
out the elements of the container and do
so recursively so this can be useful for
serialization can be useful for again
debug print outs but the question is how
is this generic template print function
or serialized function
is going to figure out if our type is a
container or not we'll have would have
to have multiple implementations and
pick the right one but in order to pick
we have to ask is this thing a container
so we could go with the formal
definitions of what a container is or
maybe a range if we want to work with
somewhat newer concepts but still it
boils down to asking does a type have
certain properties so for example to be
very naive I could say a type is a
container if it has a beginner function
so you know a bunch of types might have
a begin member functions and not be
containers and also arrays are
containers but they don't have a member
function called begin but that would be
an approximation or I could maybe say a
type is a container if it has a an
anesthetized F called iterator right
like vector iterator as the map iterator
and so on so again that wouldn't work
for arrays but it would be an
approximation and if we want it to be
like super accurate we could just ask
what do we want to do with that object
if it is a container so the answer is
okay if it is a container I want to
enumerate all the elements in the
container and then I could just test for
that directly so can I invoke begin and
get something that looks like an
iterator which I can increment and
compare and dereference so there's a
bunch of type properties that we want to
be checking so this happens a lot again
if you're building a generic libraries
that have to ask for that I have to care
about the properties of the given type
sometimes just to reject certain types
and in other cases to specialize your
decision based on properties of a type
so let's build something that detects
whether a type is a container there's a
bunch of techniques for this even in C++
98 we could sort of ask if a type has
certain members for example or if a type
has certain nested type thefts but in
C++ 11 with deco type and with a bunch
of further advances we have easier
solutions for this problem so again we
want to build
our own type traits which ask does a
type have a certain member or more
generally does a certain expression make
sense for my type
does it compile and even maybe does it
produce a certain type as a result so
for example not just for example for the
dereference operator on iterators I
actually wanted to produce a value if I
have a void returning the reference
operator that's a little fishy for for a
container so we want to ask if a certain
expression makes sense and maybe
produces a particular type so there's a
very cool trick here introduced by
Walter Brown I think a couple of years
ago at CPP con I was very impressed when
I saw it first there's a bunch of other
ways to express the same thing but this
one is so clean and so concise that I
really fell in love with this technique
and I've been telling about it to people
since so basically you have this super
simple and weird-looking template this
is actually a alius template which
defines void T as void for any type
right so this is a template you could
say void T of int void T of float by DT
of state vector and it's always just
work void it's always defined to be void
the point is not that it is void the
point is that if we try and use this
thing if we try and use void T with a
type that's not well formed with a type
that's not valid then this thing just
has no definition the thing doesn't make
sense so void T wouldn't be sensible
whereas if we use any valid type as the
template parameter here we would get
void always just regardless of what we
put in there's alternatives for this in
the standard library but it's later it's
really clean to just see it this way so
here's how we use it for is container in
our example up top there's the first
version the more general version of the
is container temple
eight and it has two template type
parameters T and another one which is
unnamed I don't care what is called and
it has a default type parameter value
which which is void so this one is the
more generic template it's not a
specialization and this one is defined
to inherit from stood is array of T so
basically if we if we go to that is
container template up top and we ignore
everything else on the slide then it's
basically equivalent to asking is T and
array if T is an array then this
template recognizes it as a container
and if T is not an array then we don't
recognize it as a container so we've
taken care of arrays separately and is
array of course is defined in type
traits and we assume it works correctly
and then we have the specialization it's
occasionally unclear why this thing is
even a specialization of the first thing
so how would you convince your friends
that this second definition is a
specialization of the first it has fewer
type parameters right so the one up top
has two type parameters even though the
second one has a default value but the
one on the bottom only has one type
parameter so that's that's enough for me
I suppose and this is container template
is a specialization in case well T the
first argument is just the T we got
passed in and the second thing the
second type parameter which has a
default value of void over here the
second type parameter is that void T
template specialized well as a permit
Erised with a T iterator right with the
nested iterator type def and if we use
this specialization then I just inherit
from the true type to indicate that yes
we are a container so basically if this
specialization is chosen then we deduce
that tea is a container okay so for this
specialization to be chosen what needs
to happen is that void tea of that type
is well formed if it is not if our type
is for example an int then what we have
over here is just int column column
iterator that doesn't make sense that's
not well formed and then substitution
failure kicks in and we just ignore this
specialization and we have our base case
which will then deduce that int because
it's not an array is not a container but
if tea does have a nested iterator type
def then this thing over here is well
formed and this is just plain void right
and then this is a specialization of the
previous case and this specialization is
a better match so the compiler when
doing the the template specialization
pattern matching would pick this version
and deduce that our type is a container
because we inherited from two type Y
just one final thing why does it matter
that this here is void why did they put
void in here and not something else
everyone's looking to the first for the
same person to answer
every time that's why we need type 9
equals whatever T returns like ya know
so what I'm asking is why is that does
this have to be void and not say int
right yes because this has to be void
and the thing that happens is if the
user of my template of is container
doesn't provide the second type right so
my user says is container of int the
user doesn't specify what the second
type is so if the user says is container
of int I would like both versions to be
potential candidates so in this case is
container and the first version would be
is container of T and void and this one
would be is container of T and whatever
void T produces so if void produces void
we have our two candidates and the more
the more specialized one can be picked
but if here I said int for example then
when the user says is container of
whatever then what the user actually
said is is container whatever comma
comma int right and then the second
specialization would just never be valid
because void TDOT produce an INT that
produces void so all the parts here
matter right it does matter that we have
void up there it matters that void T
returns void everything is important in
this in this skeleton if you will for
member detection now you might ask can
this be generalized further and yes it
can so here we're just testing if a type
has a certain nested type def but we can
make this further generic if you will so
if I want to test that a certain
expression arbitrary expression pretty
much on arbitrary types makes sense and
that's the trait I am checking for
that's the property I'm testing for then
the general recipe would be we define an
alias template for that specific test
and it's basically just the deco type of
whatever this expression returns so
suppose I want to check if t1
as a member function called foo which
takes a t2 right so I have this Elias
template which is a template in t1 and
t2 and it is declared as the deco type
of this expression here which declares a
value of type t1 reference and then
invokes full on it passing in at t2
right and the deckle Val function it's
just a very stupid silly little function
from the standard library
it has nobody it's just a declaration
because we use it in context which do
not require evaluation so it's basically
just declaring t1 for us or - - for us
that's the only thing we care about once
we have that test we just plug it into
our skeleton so the the generic version
of does my condition is my condition
true for a certain pair of types the one
over here the generic version takes t1
and t2 and death dummy
void template parameter and the
specialization takes t1 and t2 and
whatever void T returns when invoked
with my test which is up there so if
that expression makes sense if this
thing here is well formed then void T
produces void and we pick the second
specialization and if it is not well
formed then we pick the first one and we
reject that property and we could even
test if we wanted that my test t is not
just well-formed we could ask what kind
of thing it is so I could add for
example over here I could add so is my
test T of t1 and t2 actually say an int
or a Const reference or whatever else I
wanted to assert so we basically have
now a generic recipe for checking
properties of of types
thanks to this void T trick this again
it requires compiler support so for
example my my usual go-to compiler again
which is Visual C++ still has some
restrictions around expression
substitution failure is not an error
expression spin I so it would actually
reject a bunch of these examples
the more conforming compilers GCC clang
they're they're okay with this and
Microsoft is working on fixing the V
edge cases that still don't work and
actually this kind of template is pretty
useful in the standard library as well
so just as an example in the standard
library there is a type trait called
is assignable which just determines
whether one type can be assigned to
another using the assignment operator
you could easily implement it using this
generic trick right so over here in the
deckle type body we would have just you
know deco Val a assignment deck eval B
and we'd have to test if that is
well-formed so standard libraries all
over the world can now use this instead
of requiring compiler hooks or you know
some sophisticated one of tricks there's
just a generic trick that works for all
the cases so that was member detection
and once we have that let's talk about
some ways write some strategies for
actually using the property we
discovered for choosing one of multiple
algorithms again if we want to optimize
STD copy for example for pointers to
primitive types as opposed to the
general case of just iterators we know
nothing about so there's three general
strategies I want to show you which are
common in a bunch of different template
libraries including the STL one is just
explicit specialization when you write
all the boilerplate yourself the other
is tag dispatch which is useful and used
a lot in the STL where you have multiple
versions of an algorithm so basically
the property you're testing is not
binary to a false it has multiple
degrees of being true and there's also
stood enable if which is usually used if
you want to disable a certain function
if you want to remove a certain function
from the set of overloads that you would
want the compiler to consider so let's
take a look at a few examples again just
an overview of the tricks that
a lot of libraries use so this rather
verbose thing on the screen is an
attempt to specialize the sort
implementation just a general sort that
takes iterators for two cases one when
the type we're sorting just has general
properties is generally comparable right
so it has a less than operator which
provides order and the other case is if
it's hashable if there is a way to
produce hashes from values of that type
so if it is hashable maybe I'm going to
use a different sort algorithm like
radix sort and if it's not hashable I'm
going to use something else it's just an
example I'm not saying there's a
practical use of this kind of sort
implementation but we want to ask about
the property of the type and then just
redirect to two different
implementations so I can have this base
case
of a sort imple cross template which is
undefined basically I don't care about
it because I am going to have
specializations for both of the cases so
this base template is a template of some
type and the boolean and then I have two
specializations I have one for some type
and false and another for some type and
true so I basically covered all the
cases because bullying's can be either
true or false so there shouldn't be any
case where we actually get to the base
template and the compiler would complain
that we haven't actually defined it so
for false I have one definition of a
static sort function and for true I have
a different definition of a static soit
function so basically this is just a way
of picking overloads at compile time I
have two functions in two different
class templates and I'm choosing the
right one based on whether some property
is true or false at compile time so now
I just have to ask is that property true
and redirect to one of the options so in
in this version which is the the
publicly accessible one that's the thing
that
clients actually invoke in this version
I specialized sort
imple I parameterize sort in pull by
whether the value type of that iterator
has some properties so is hashable v
that's not a standard library thing but
it's a tight trait that we built right
using the techniques we talked about
previously
so sort in pull of my iterator type and
either true or false just picks one of
the two class template specializations
we had over here and then I invoke the
static sort method and death passing in
my iterators so we have just
successfully picked one of two
implementations based on a boolean
property of some type this is a bit
verbose but it works and in some cases
you might actually prefer it for example
if that type that you're using actually
has to have some state and member
functions it's actually useful to just
pick one of multiple class template
specializations and then just work with
that class template kind of like the
strategy pattern except you're doing it
in compile time and not at run time and
this can be obviously expanded further
to a bunch of additional examples the
other alternative which is a pretty
common in the standard library is tag
dispatch this doesn't require class
template specialization just multiple
overloads of a certain function and the
overloads are different only by usually
a trailing type which can take multiple
type values so here's a classic example
from distance this is an STD algorithm
that finds the distance between two
iterators right how many elements are in
the range between two iterators so this
is the publicly accessible declaration
so distance takes two iterators what it
returns is well whatever iterator traits
difference type is for my iterator type
so conveniently we have iterator traits
which is supposed to tell us things
about iterators this is yet another
example of a meta function that takes
types and returns values and types for
us and then I invoke a distance helper
which is not a publicly accessible
interface and distance helper takes the
two iterators first and last as well as
an additional parameter and this one is
also obtained from iterator traits so in
iterator traits
I have iterator category which is a type
so I instantiate that type over here and
that's what I pass to distance helper so
now distance helper can be overloaded
for various types that iterator category
can return just for simplicity suppose
iterator category is sometimes an INT
and sometimes a float so I can now build
to distance helpers one that takes an
INT and one that takes a float as the
third parameter and in such a way
specialized my implementation iterator
category fortunately doesn't return int
or float
it's a metaphor that returns one of
multiple types indicating what kind of
iterator is we have in our hands right
so it could be forward iterator and
input iterator be directional iterator
random access iterator and so on and
here's what the actual helper could look
like so for random access iterator tag
which is the iterator category for
random access iterators my
implementation just uses the minus
operator right so we just find the
distance between the two iterators and
for anything else this is the second
version of distance helper it takes
iterator tag base which is the base
class of all the other iterator
categories of all the iterator
categories so for for iterator tag base
we have this implementation here which
declares a counter and then just
traverses the range incrementing the
counter till we reach last right so
while first is not last increment last
increment
till we get to the end and then return
em so this is going to be the linear
time version and that's going to be
hopefully a constant time version and we
just used a property a type property
returned by iterator category to choose
one of the two so that's a pretty common
technique as well and a third example I
want to show you is enable
just like a lot of classes and it also
has this constructor over here which
takes a universal reference to any tea
and the reason you'd usually have that
kind of constructor visit for it now
okay so the reason you'd usually have
that kind of constructor which takes the
universal reference is not to emulate a
copy constructor in a move constructor
on your own type but rather to enable
construction from some other type so for
example maybe my widget it can actually
be constructed from for example a couple
of configuration values and it want to
optimize for two cases one when I'm
passed and our value reference which I
can move from and the other when I'm
passed the constant reference to an L
value which I can only copy from that's
a pretty common situation but ignore
even ignore the reason why I actually
have that kind of a templated
constructor the issue here is hiding
what can happen is that if my if the
user of my widget class initializes a
widget and uses an L value reference to
a widget which is not Const so basically
just widget ampersand write an L value
reference to a widget which isn't Const
then the compiler can choose between my
copy constructor which takes a Const
reference to a widget and this template
constructor which was never intended for
situations where T is a widget but it
would apply in that case and it would be
picked because this constructor works
were where the T ref ref actually
resolves to just a widget ampersand to
an L value reference to a widget so we
have a constructor that takes a
conference and a constructor which takes
a non-conference and that second
constructor would be preferred so
essentially we built a universal
constructor which hides our own copy
constructor this is undesirable so we
can ask the compiler essentially to not
pick that specific overload that
specific constructor
if I'm using a widget as tea so the way
this typically works is that somewhere
in the signature and there's a lot of
places you could actually put that in
the signature somewhere in the signature
you put enable if and enable if is a is
very similar to voice tea actually it
just determines whether an expression is
well-formed and then it's used for
substitution failure to remove that
overload from the set of overloads that
can be considered so in this case the
expression I'm passing to enable if is
not is same tea widget reference value
so basically a boolean which says
whether or not tea is the same thing as
an l-value reference to a widget so if T
is the same thing as an l-value
reference to a widget this expression
because of the not here this expression
is going to be false and then we have
enable if of false and enable if of
false is not defined so it's not a type
it's not any type whereas enable if of
true is void kind of like our void tea
template so in the case where enable if
T here produces void this template
overload is considered valid and in the
case we're enable if T takes false and
it is undefined this constructor is just
removed from the set of candidates
because it is a substitution failure
when trying to match the template
arguments the template type arguments
you could place that enable if in a
bunch additional places maybe in when
reviewing template libraries you might
have seen enable if it as an additional
parameter right so in some cases you put
it as an additional parameter which has
a default null value you could use
enable if as the return type not in a
constructor though constructors can have
declared return types but in other
functions you could use enable if T is
the return type again just to get the
compare
to consider that type as part of the
functions signature and again if it
doesn't match then this signature that
overload is removed from the set of
candidates that the compiler would
consider so in this way we could just
disable this overload in certain
circumstances and this trick is used a
lot in DST oh yeah is there way to apply
no so if you if you declare a copy
constructor in the move constructor then
the move constructor will be chosen if
you have an r-value reference if you
have a reference to a temporary if you
have a reference to an L value then the
copy constructor will always be chosen
automatically just think about it your
move constructor is going to be moving
so it's going to destroy the object if
you have an L value that would be
extremely unsafe you don't need this
trick at all if you just declare a copy
constructor in a move constructor and it
want the compiler to pick it it was not
but if you so you say no template here
no Universal reference just a copy
constructor and a move constructor right
oh that's fine and the Constructors what
do they take do they take widgets or do
they take that one of the template
arguments hmm but just one constructor
but they're not a copy and a move
constructor if they don't take the exact
type right so if you have a constructor
that takes for example in this class if
I had a constructor that takes an int
you wouldn't say that's a copy
constructor or a move
it's just yet another constructor so if
this thing was a template of whatever
and you had a constructor taking
whatever and not widget of whatever
that's not a copy in our record a move
constructor it's just yet another
constructor yeah hopefully that clears
things up okay so we do have a few
minutes left so I want to show you real
quick just one more example of using
sort of the same techniques for a
slightly different scenario for a
compile time computation and first I
just want to make sure we're all
familiar with Const exper so basically
in the good old days to perform compile
time computation you'd have to do stuff
like that with recursive templates
that's just a classical example I'm sure
you've all seen that thing so for
example here I'm calculating factorial
by having a class template
specialization for size T where the base
case is defined as 1 and then all the
other cases are recursively invoking
that class template until it's
specialized down to 0 so first of all we
can replace a lot of these recursive
templates with constant exper which was
introduced in C++ 11 so when applied to
a function context per means that in
some cases the value that this function
returns can be obtained at compile time
so you don't have to actually invoke it
at runtime you can just sort of run
through that function at compile time
and get the output so here's factorial
as just the context per function and
obviously the advantage here is that
even though the thing is calculated at
compile time
you still specify it exactly the same
way as any other function that would be
calculated at runtime furthermore you
could use that factorial function with
values that are known at compile time
and then the result is known at compile
time or with values that would only be
known at runtime and then the result
would only be known at runtime which is
nice in C++ 14 a lot of restrictions on
Const exper were lifted so for example
now in context perform
you can use loops and you can declare
local variables which you couldn't in
C++ 11 where the whole thing had to be a
single return expression so that opens
the door for a bunch of additional
things that you can express as compile
time computation and you can even now
have types which are constants per
essentially so here's for example the
complex type tuple has similar
situations so here's a complex type
where the constructor can be constants
per and it has a real and the set real
function which are contexts per and the
conjugate function that can be contexts
per so basically we can now express
computations on complex numbers and they
will be performed at compile time which
is rather cool I think what's even more
cool is that Const and contexts per are
two totally distinct concepts right so
for example here's a function which is
concepts per but it's not Const it's
actually mutating an object that
mutation just happens at compile time so
that's what we're saying
by using Const exper here this function
here it's mutating a value but it's
happening at compile time so that's what
context per means great so that's just a
very very quick overview of Const exper
some simple users are rather nice so for
example you can replace the horrible
array size macro which takes an array a
statically defined array and returns the
number of elements in that array it can
replace that with a context per function
template which is template where the
template arguments are the type and the
number of elements in the array and we
just return the number of elements and
that array size can be used at compile
time situations so for example you could
declare an array whose size is array
size of some other array which is a
rather common use of array size so
that's a compile time known value
another example is the power function
which can be calculated recursively so 2
to the power of something is sum is you
know comes up a lot so these are simple
users and there's a bunch of them in the
library and in code you'll drive
yourself
here's a slightly less obvious use wear
contacts per can actually replace a
bunch of class templates which you would
use which you would use to define meta
functions before so our task here in
this particular case is to build a
compile-time facility a compile-time
function basically a meta function which
takes a certain type trait a boolean
property of types such as is integral or
is floating point or is no throw move
constructible some kind of boolean
property of types and an open collection
of types just any types we want - 1 - 2
- 3
an arbitrary number of types and we want
this thing here and F to evaluate
whether this boolean meta function is
true for all my types t1 t2 t3 and
return true or false which would be
known at compile time so this is a
classic scenario which you would solve
using class template specialization
before Const exper was available
you'd have to build a couple of class
templates recursively they would have to
derive or extend each other here's the
context / solution which for me anyway
in some cases is clear so here's the
base case for n def for this little
function the base case doesn't take any
types
it only takes the operator it only takes
the binary function the boolean function
such as in is integral and it returns
true because if you apply that function
to know types then we could say it is
true for all the types for all the know
types we have and then the interesting
case the recursive case is over here
where we have that upper operation the
boolean property of types we have the
first type and we have all the rest of
the types and the rest can also be empty
so we could be down to just one thing
and we just perform a recursive
invocation right so we ask is OP of T
through
and the recursive invocation for all the
rest of the types is it true as well and
that's what we return and the whole
thing of course is context burst so it's
all evaluated at compile time it's not
like at runtime you're actually going to
have any recursive invocations that
whole thing just folds down to true or
false at compile time and for me in some
cases this context per function style is
more readable and more understandable
than class templates which would have to
interact with each other through
specializations especially if the thing
you're working with is values and not
types so in this case I'm working with
values they have true/false which I have
to combine in some way and not types
which would be harder to combine using
just functions so my final example from
the context / area is one I've come
across about a year ago maybe a little
more which is parsing strings at compile
time so here's a little class called
CSTR for a compile time string which has
a constructor from an array of
characters with an own size so it can
basically be initialized from literal
strings write literal strings known at
compile time so that's a an array of
characters and the size is also known
what this constructor does is just
initialize members the pointer to the
beginning of the string and the length
of the string and now I can have in that
class multiple constant exper operations
which interact with these fields so for
example I could do length function which
would return length I can do an is empty
function which returns whether length is
0 I could also do a function which looks
for a certain character in the string
and returns the first occurrence and
that function would still be constic
Spur because this whole thing is
performed at compile time and one
example of using it is for printf like
situations where I want to test
that my format string is valid so just
think about it if the format string is a
compile-time literal string which
happens in a lot of cases you can
validate it at compile time not waiting
until runtime to make sure the format
string is valid so in this very simple
example I have a static assertion which
makes sure that the count of % signs in
my format string is the same as the
number of arguments passed through the
printf function so that's obviously a
simplification because in printf format
strings you can have double % and that's
not a placeholder but you know the
general idea still holds we can test at
compile time whether a certain a certain
string literal has a certain number of
percent signs and reject at compile time
that format string if it doesn't so for
example if I invoke my printf function
with two arguments but only one % the
compiler could complain and that static
assertion would fire and tell me number
of arguments doesn't match the format
string so obviously this is just a
prototype right but it can be used in a
lot of situations where I have to
validate strings at compile time for
example imagine a regular expression
constructor that tests that the regular
expression is well-formed a bunch of
things that's there are quite easy to
Express once we have context / because
you can essentially reuse the same code
the same algorithm for testing things at
compile time and at runtime so that's
just a wrap a wrapper case for for my
examples right so we have about three
minutes left so if you have any
questions there'll be a little time I
hope I hope you've seen some examples of
using template metaprogramming in a
variety of tasks in both libraries and
applications so admittedly a lot of
these examples are from the library
world implementing STL algorithms
optimizing them and so on
but hopefully application level examples
can also be extracted from these samples
and with the tools we have in C++ today
such as deco type such as context
for it's a lot easier to build these
kind of solutions than it was in C++ 98
now if you're seriously considering
investing in in TMP libraries instead of
building these basic tools yourself
there's a bunch of options to choose
from right so you don't have to build
the basic Combinator's for example for
testing whether a certain property holds
for multiple types that kind of thing
you don't have to build yourself unless
you just enjoy the process I enjoy the
process but still you don't have to
build these things yourself there's a
bunch of libraries including and boost
some modern some older which provide
solutions to common tasks that you have
to perform at compile time so this is
all quite fun and hopefully will be
applicable to at least some situations
you encounter and if you have any
questions we have about three minutes
yeah so yes
instead of instead of okay so just
repeat the question why did I show you
an example of using class template
specialization and tag dispatch instead
of just using one of them so first it's
nice to see a multiple options and
second tag dispatch is usually used when
you're trying to invoke a function if
you have a whole class template that you
want to pick and that class template
would have members and would have
behavior so state and you have multiple
functions to invoke I think it would be
more convenient to use specialization I
think it's also a matter of taste to
some extent all right well anyway thank
you very very much for coming and I'll
have some samples for you on Twitter
later if you'd like to explore some labs
yourself and the examples I've shown you
here today I hope you enjoyed the rest
of NDC thank you very very much for
coming thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>