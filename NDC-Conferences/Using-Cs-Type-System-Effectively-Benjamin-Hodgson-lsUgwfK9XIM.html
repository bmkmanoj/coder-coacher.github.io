<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using C#'s Type System Effectively - Benjamin Hodgson | Coder Coacher - Coaching Coders</title><meta content="Using C#'s Type System Effectively - Benjamin Hodgson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using C#'s Type System Effectively - Benjamin Hodgson</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lsUgwfK9XIM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in January of this year Robert C Martin
the author of a lot of good books such
as clean code wrote a blog post
comparing type systems and unit testing
it was a rather controversial blog post
given that he suggested that people that
prefer types should quit their jobs and
never be a programmer again and you know
I've social media as we all know is a
really good place to get reasonable
rational balanced debates I thought
maybe we could look at some of the
responses to this to this controversial
blog post so at alpha on Twitter says
everybody who shared this should be
ashamed of themselves on reddit 1792
says yeah Uncle Bob off you
obviously enough Cystic asshole who
thinks too highly of themselves this
one's my favorite this is some someone
called combinatory logic who says here's
the nigel farage or donald trump of the
software world I'm Benjamin I work at
Stack Overflow
where the team that brought you Stack
Overflow and this debate piqued my
interest because I'm interested in in
programming language design and type
systems and that sort of thing I find
that stuff really fascinating and one of
the things that really struck me about
the more reasonable comments on the in
the debate on social media that this
post generated was the the people that
stepped into the fence type systems and
the people that were siding with Robert
C Martin on sided press they weren't
even really talking the same language
right so for example well so Tomas Petra
check kind of agrees with me he says
like it's their incommensurable these
two worldviews right the backgrounds of
the people that the program in strongly
plight language isn't like to use that
is completely different than the
background of dynamically typed
programmers who prefer to use tests and
it leads to posts like this one for
example who this guy Jake Wharton I
think he's he's done something
remarkable he's both sort of
underselling and over selling the value
of a type system in the same post right
he says type systems are the form of
text well they're really not I don't I
I don't use a type system like I use a
text suite a test suite to verify the
behavior of my code whereas a user types
type system to help me make sure my code
is designed well and so like if you're
if you're a if you're someone that
really believes in the value of unit
tests rather than flight systems you're
not even really going to like understand
what this is about that you're going to
just say well what's the point in like
having a having if I can write text then
why would I bother writing types for me
a type system is a lot more about
driving the design of a system and
that's what I'm going to hopefully
demonstrate to you today oh yeah the
other thing that struck me as absurd
about this debate was it's not like type
sir the opposite of test right in many
ways they're complementary you need both
of them to build a reliable system that
continues working as you grow it right
there's an idea called the Swiss cheese
model the Swiss cheese model perceive
the system as a layer a collection of
layers each of which are imperfect right
each of these layers has a hole in it or
some holes in it but bugs only get
through to production when the holes in
all of these layers line up so the game
of software engineering really is to
have as many of these layers as you can
and to use them as effectively as you
can in order to minimize the number of
holes in this in your in order to
minimize the likelihood of a bug getting
through or through all of the holes in
in assistance of production so some of
these layers of cheese that you might
want to use fight unit tests certainly
but also code reviews continuous
integration production monitoring all of
these are important and necessary tools
that we humans use to reason about about
code and keep it correct as we grow a
system so like I said this talk is about
using types to drive the design of a
system really weaving types into the
programming workflow and so in order to
illustrate that I thought we could build
I work at Stack Overflow and I thought
we could build one of Stack Overflow
features which I think gives a
particularly potent illustration of what
I'm going to try and impress upon you
so the feature I'm just going to quickly
demo what the feature does it's very
simple
you guys probably can't see that right
let me ambiguous it is that big enough I
guess so
so slack overflow as you all know is a
QA site but you may be less familiar
with other product which is a job board
a programmer jobs board buy so here's
what the jobs board looks like it's at
Stack Overflow coms best jobs and the
thing that I'm going to demonstrate to
you is our advanced search feature right
so this this this is that the search box
here supports a query syntax right so I
can say I can write at a guy thing look
for c-sharp jobs and I can also say I
want a job that pays there's either a
remote job I want to be able to work
from home or it pays all it pays I know
50,000 pounds right and so if I look for
this like I was I guess it's included
and yeah so this one for example this is
a this is this job's worth more than 55
K this one can be worth more than six
five K so I'm good let me look for
remote one this one or this one's remote
but it's also worth more than 50 K
anyway so I thought we could implement
like a miniaturized version of this
feature together does that sound good
from nodding goods so let me just so
this is kind of this this little query
language it's kind of a miniature
programming language yeah so it
shouldn't surprise you that in the stack
overflow code base we have a miniature
compiler for amateur programming
language so let me so this is a very
sort of thousand-foot overview of what a
compiler does right source code comes in
a text
you know string a file text file comes
in we run it through a process called a
parser which extracts structured data
from the syntax of your source codes
then the parser produces what's called
an abstract syntax tree I'll give you a
demonstration of what one of those looks
like in a minute but it's basically an
in
a tree structure that reflects the
source of the code that you wrote right
in your file and then the compiler
itself after the parser it's structured
as either a short or long
whatever series of operations on this
abstract syntax tree some of them for
example an optimizer that like for
example kills dead codes that would
consume an abstract syntax tree and
produce a different one one with the
dead code removed but other ones for
example the code generator that produces
machine code or LLVM or sequel or
whatever is that you're targeting with
your programming language that's that's
an operation that takes an abstract
syntax tree and produces maybe a binary
stream for the machine code that you're
generating or something or and some ASN
that you're later went to an assembler
something like that and another another
possibility for an abstract syntax tree
after you've optimized etc would be to
run it in memory write over a detection
of objects or so so that would be an
interpreted language like Python
automatic so here is the program that
we're going to write this is way too
small let's that's not the program we're
going to write anyway here's the program
we're going to write no that's not it
either that's better okay so can you
guys read that light at the back good
okay so here I've got a list of jobs
with tags oh I should say obviously
we're not going to implement the whole
feature because it's quite a big feature
height we I'm going to implement three
syntactic constructs I'm going to
implement tags I'm going to implement
ending of two queries and I'm going to
implement not right so the boolean
negation so here's an example right of
an impact query that has a flag c-sharp
a tag Java it's negating the Java tag
and it's using an to join them together
right any questions so far
so here I'm running I'm running this
input two input string through the plaza
and
then I'm running the resulting query
this is going to be an abstract syntax
tree which I'll show you in a minute I'm
running it through an interpreter and
I'm running that for every job in our
list
so since I'm looking for c-sharp c-sharp
jobs and not Java jobs I'm expecting I'm
not expecting job two to make it see
because that's got Java in the in the
list of tags and not expecting job 3 to
make it through because that doesn't
have c-sharp right so when we run this
program eventually only job 1 should
appear on the on the screen any
questions about what's about to happen
we're going to implement a miniature
compiler and we're going to do it in a
type driven way okay so first things
first what does an abstract syntax tree
actually look like right so here's an
example an example input string and
here's the abstract syntax tree that we
are expecting a parlor to produce out of
it so as you can see the outermost layer
of the tree of the in memory tree is the
and operator right that corresponds to
this central and in the middle of our
query well and what and what they found
is doing is it's taking the left query
here and it's ending it with the right
query here right on the left hand side
we see another and write this one and
that's got the feature tag and not Java
not as another as another operation
another node in our syntax tree and on
the right hand side we've got the all
nodes with the remote and salary
operators any questions about what this
abstract syntax tree does don't be shy
if you have a question it's likely that
the person sitting next to you has the
same question so okay
what does one of these abstract syntax
trees actually look like in code right
let me jump back to this just GD a bit
smaller okay so an abstract syntax tree
is a type right if I give you an
abstract syntax tree all I can say is
that I don't know necessarily what the
user types but I do know that they type
to a query right so we're going to
represent this as a base class and
abstract base class and for each of
these types of nodes and knots and tags
we're going to represent that as a
subclass of said abstract based class so
here's for example the tag sub class it
contains a string which is the actual
tab that you type D G C sharp or Java
and so here's and right it contains two
recursive occurrences of a jaql a jaql
since like jaql by the way I should say
is job's query language jaql I'm going
to probably repeat the word jaql quite a
lot or JIT will so an and nodes contains
the left-hand side of the end operator
so in this example this act that the
left-hand side of this end would be tag
c-sharp right that's this end here and
the right-hand side would be not with a
Java tag inside it so and easie is a
binary operation it's got two sub trees
right it's got two jql syntaxes inside
it again we don't know what sort of node
those take us interpreters can be
because synthetically it's a determinate
and here's not right not only has a
single operands but again it's a subtree
it's not necessarily like a particular
type of node one thing I wanted to draw
your attention to here is I've given
these I've made these classes immutable
right none of these none of these
properties have public setters that will
just get only properties and I'm
initializing them in the constructor and
then making sure that the that the
arguments of the constructor is not null
in each of these cases I do this as a
matter of course for pretty much every
class I write not necessarily like
compiler e stuff just like if I'm
writing a constructor NBC controller or
something I will give it a constructor
and I will check that the argument
no the reason for that is like if you if
I were to give these public sectors I
see this sort of code a lot like just
like Get Set no constructor and then
like I'll say like new and and left
equals you know foo write equals bar the
problem is though it's very easy to
forget one of the fields right and then
you end up with nulls in your system and
it's and you have to check it you know
everywhere if if you if you have a
constructor and you have null checks
inside your constructor you can be
guaranteed that you haven't forgotten
any of the fields this is especially
important I find when you're adding
things to an existing class it's very
easy to add a new field that should
always be set and forget to set it
everywhere so if if you you know put it
int and those sighs all right that if I
if I just do get set I then have to
manually find all the places in the code
base where this node is being created
and make sure that the size has always
been set right it's a lot simpler to say
in size and then set the set the thing
in the constructor and then just
literally chase all the compiler errors
right this is like a big part of my
workflow and I'm programming I literally
just I make a change which I know will
break the type checker and then I just
go through and chase all the O's any
questions about about that
that's very a very simple lesson yeah
do I have cus to it the question was
since I do this a lot do I have custom
exceptions for when an argument is not
as that is that what you say I think the
systems are argument null exception is a
perfectly good thing to use here is what
it's for
yeah and everyone understands it if I
had a Benjamin null exception haha
people would be confused when they saw
that in the in the codebase but at my
last job we had a class called the boo
that recommendations engine because the
person that wrote it was called boo that
and we can bring ourselves to change it
even years after he left because it were
too good of a name okay right so that's
um that's what a syntax tree looks like
okay back to the slides
oh yeah I just wanted to draw your
attention to a possibility here right in
most cases right if you're implementing
something like a programming language
you know all of the types of nodes in
your sister types of syntax tree nodes
in your system right in this instance
there are three and only three we don't
necessarily want this base class to be
open to further sub classing in another
module and so a trick I occasionally do
it's a little bit heavy weight so it
kind of depends on you know personal
taste is I make the JQ else I would make
this base class I would have I'll give
it a private constructor and then I
would nest these three subclasses inside
it like that means you can't add a
subclass of the JQ else in fact because
you have to be able to call your base
classes constructor you can't add a sub
class without modifying the actual jql
syntax class that's just a little trick
that I sometimes like to use okay any
more questions about the representation
of an abstract syntax tree no okay come
to somebody
okay so now that we have written this
abstract syntax tree we need to be able
to process it right we need a way of
taking an abstract syntax tree and I
mentioned earlier that a compiler a
typical compiler like Rosslyn is
structured as a sequence of operations
that modify a syntax tree in some way
and then eventually another operation
that generates in Roslin's cases il in
many other cases it's like native code
or LLVM I like that so what do these
operations actually look like we need a
way of implementing a function which
looks at a syntax tree and perhaps
perform the transformation returning a
new syntax tree or generates code or you
know whatever type checks it or run some
diagnostic depending on depending on the
requirements of your programming
language so given that there are three
types of nodes right andand and knots
and tags each of those nodes has has its
own meaning and an operation on the
syntax tree should treat each of those
nodes of his own case yeah so we need a
way of examining the type of mode that
you're looking at right one simple way
of doing this would be to just you see
is or as operators see sharpies or as
operators isn't isn't check isn't cast I
should say or as in check or we could
use the new C sharp 7 pattern matching
stuff all of the or we could equip our
base class with a an enum like with the
node type and then switch on that and
then down cast it to the actual nodes
all of these suffer from a problem right
the main problem my opinion is that you
don't get any checking to ensure that
you have covered all of the cases all of
the possibilities all the different
types of node in your operation right so
if I want if I were to come back here
and add another type of node called or
or like salary or remote or whatever I
need to make sure that I've updated all
of the operations in my compiler because
otherwise the user could type an or
query and then suddenly I don't know
what to do with it and I throw an
exception and the users unhappy right
and I would like compile time feedback
for that right and so
I'm saying like if node is and then do
this if node is not if node is tagged
whatever
likewise the C shop seven pattern
matching switch I don't get any feedback
from the compiler when I add a new node
and I forget to update one of the
functions yeah any questions about the
shortcoming of if is as ins switch the
other downside of is and as is that you
could forget to in the case of easy
because you could downcast it to the
wrong type in the case of eyes you could
forget to check it for null either way
it's a bit sort of syntactically clunky
in my opinion this is the pattern
matching stuff does make a big
improvement on this but like I said it
doesn't it doesn't firm it doesn't it
still has a shortcoming that it doesn't
require you to cover all cases okay so
the design I came up with here is
something that I think is quite
syntactically lightweight but it does
require you to rewire your brain a
little bit and think think a little bit
more abstractly about the about the
evaluation model of your program right
so it looks a bit like this I'm calling
it match just for two to evoke the the
notion of pattern matching C sharp seven
pattern matching but it's it's very sort
of syntactically lightweight and I'm
leaning on Landers to do this right so
the idea is that if I'm so this is this
is a function that takes a query and a
job and it tells you if the job
satisfies the query right so this is
called continuation passing style right
the way I define an operation on a jaql
node is I say well there are three
possibilities right it could be a tag it
could be and ought to be not and I need
to define a way to to handle each of
those cases right the way I'm doing it
is I'm writing those out as lambdas and
then I'm passing it into the into the
node so the node can decide which which
of these lambdas to call based on its
own type right any questions so far
about - I'm about to type it out so if
you're confused now hopefully seeing it
written out will well simplify that okay
so we want to write should I write the
write the implementation first right so
I'm going to write an abstract methods
and we want the caller of this method to
be able to choose the return type of the
operation that they're writing right it
wouldn't be very good if we were to
hard-code
bool as the return types because then
that would preclude us from compiling it
into an elastic search query which is
something that we do that's like
overflow or like performing any sort of
tree rewriting because then the return
flight would be jaql syntax again so we
need to we need a generic type here we
need to parameterize a return type so
abstract T I'm going to call it match as
I said to vote that's a matching so when
you're calling this function you need to
provide a lambda that covers each of
these three cases and so the first cases
is a tag right so I'm going to so this
is going to be a funky lambda which
returns are you and it's argument is
whatever was inside the tag right so
this is a function a string to a you and
I'm going to call it tag not a you at
see I'm help me out if I type something
wrong because I am actually typing this
and I probably will get something wrong
what about the the second possibility
the second possibility is that I gave
you an and node right so um and has two
subtrees inside it and so the
continuation that you're that I'm going
to pass once I check that you that you
gave me an N nodes
I'm going to have two subtrees to give
you right so I'm going to this is going
to be a function of two jaql nodes to a
T right and then of course not have a
single subtree inside it and so if I
perform my type test and learn that it's
or not I have one
subtree to give you any questions so far
about how this is going to go down
okay so now we need to this is an
abstract method so now of course we need
to I need to be public of course so now
we need to go ahead and implement this
abstract methods in the three subclasses
so if we're looking at AB a tag node
override to match God sometimes computer
the too helpful okay
so we're looking at tag we've got this
is the tag class and so the mess that
the the func that you need to continue
the method with is the tag func right
and the thing that we pass it is the
value of the tag any questions so far
okay I'm just going to copy and paste
this right so now we're looking at an
and node I have two jaql syntax is to
give you and the correct functor call
here is and right and left and right and
in this instance we're looking at a not
in so the correct functor call is not
and it's going to be operand okay any
questions about how how we're using
we're using these virtual methods to
allow the subclasses to choose which
func to call any questions okay so now
what remains is to actually implement
that checking operation right the
operation that takes a query and job and
tells you whether the job matches the
query so this is in interpreter so I
left this as a to do right so I've got
I've got this nodes and so what can I do
with the nodes well the only thing I can
well that's obviously a recursive call
for this the only thing I can do is a
node that's not one of these extension
methods which I'm going to show you the
other one of them in it is is match
match the type of the node right and in
order to match something I need to give
it three functions so the first function
is the tag function
so what do I do if you gave me a query
which is just like c-sharp
I've got a job and I've got a tag what
do I do with it right so this is a
lambda as I stated earlier so I want to
see if the tag is in the jobs list of
tags yeah so J tags contains tag what's
right if it's an and nodes I've got two
jql syntax sub trees and I want to look
at each of these sub trees and see if
they if the job matches that query yeah
so I need to recursively check the left
subtree against the job and they'll
check the right subtree against the job
and I need to end those to the bulls at
those two returned I need to add them
together yeah
and finally not take some operands and
again I want to recursively check that
copper and against the job and then I
just need to negate it any questions
about this about the recursive traversal
of this of this syntax tree nope sure
okay so what I wanted to illustrate here
was that this is a type driven style of
programming right so we've the first
thing I did was I wrote down the
signature of this of this check function
you know I wrote that it takes the jqf
interaction it takes a job and it
returns a bool and knowing that I need
to scrutinize the jql syntax in some
manner to find out what type of thing it
is the only thing I can do with it is
match it right and then in each of these
three continuations in each of these
three branches of the methods there's
only really one thing I can do is kind
of obvious what's correct at this point
because I have a string for the tag in
scope it's kind of obvious that I need
to
implement I need to call contains right
and likewise for and not it's kind of
obvious which which ball I need to
return right there's nothing in the type
system that stops me from saying right
this always returns false right that's a
bug the type checker doesn't help me
here and I think it would be
unreasonable to expect the type system
to do so this is what unit tests before
right but the type system nonetheless
helps me think about what I needed to do
in each case I split the split the node
into three that split the method into
three branches and in each branch it was
kind of obvious what I had to do
thereafter once I've done that bit of
work any questions about about this fake
pattern matching thing okay what do they
have next oh yeah right so last time I
get to sort this turned out to be it's
good to be a little bit controversial
right the classic hello object-oriented
style of writing this codes it would be
to put a virtual methods on the base
class jaql syntax called check that
returns a bool and allow each of those
three subclasses to override that
virtual methods and return that return
that bull right what I don't like about
that in this instance is first of all it
couples knowledge of like if you if you
have a lot of operations like generating
elasticsearch query or like doing a an
optimization the jaql syntax nodes have
to know how to do that right the
knowledge has to be inside the syntax
tree where the things actually job is
really just to be a syntax tree but more
importantly it's about what operations
do you want to make easy for future
developers right which which which
direction do you want it to be opening
right so the virtual method style makes
it easy to add new types for example if
I wanted to add like or salary or
remotes to our to my jaql syntax class
that would be easy all I have to do is
override them the virtual virtual method
for each of the operations I have
because
like I've got a virtual method so check
and I've got a virtual method for
generate elastic and I've got virtual
methods like realizing you know I just
have to override each of those virtual
methods in in the new subclass time I'm
adding but what it makes difficult is to
add a new virtual method because if you
have lots of data types you have to go
through and change every single data
type in order to add the new the new the
new operation to the to the type yeah
lots of lots of lots of possible cases I
have to add after override the new
virtual method in each one of those the
the pattern that I implemented the
lightweight visit so I call it makes it
easy to add new operations because the
operations are decoupled from from the
syntax tree itself but it makes it hard
to add new types of data because I have
to go through and change every function
that's been written already right this
is called the expression problem it was
named by Phil waddler who is one of the
towering figures of the programming
language design community he he he
implemented Java generics and him and he
invented the type classes and stuff like
that so you probably used his work at
least indirectly he called it the
expression problem because it's
particularly relevant to this sort of
code right where you have an expression
tree it syntax tree and you want to be
able to add new sites and new operations
because you want to be able to evolve
your language but you also want to be
able to write new optimizations for your
language or add a new back end to your
compiler or something like that yeah
don't underestimate how big of a deal
the expression problem is it's one of
the central tensions of software
engineering if I published at my base
class and I have a bunch of subclasses
in consumers of my library who I've
never even met if it's an open source
library I can't just go ahead and add a
new operation that they have to override
because I'll upset everyone right there
I'll break all all of the code as soon
as they update and likewise if I have
operations that are defined in in other
people's codes if I add a new if I'm
using the functional style of writing
code if I add a new
operation if I had a new subtype I
should say all of my clients have to
change all of their existing functions
right any questions about the expression
problem okay right so let me just go
back to my table of contents so I've
shown you what an abstract sense
actually looks like and I've shown you
what a simple interpreter looks like
what's the time that I got sewn to no
not really
so now I'll show you what a parser looks
like okay now parser differs from an
interpreter or a type checker or code
generator in that it doesn't operate on
an abstract syntax tree it produces an
abstract syntax tree from a string right
so I can obviously can't hope to use
that match method that I just wrote to
produce an abstract syntax tree because
it's a method on the abstract syntax
tree already right so this is going to
require a new approach I wanted to show
you a style which first of all
illustrates the so I showed you the
visitor pattern I want to illustrate the
other way of flipping the matrix right
the reason for this the reason I went to
the visitor pattern in in the in the
syntax tree is that there's a small
enclosed set of nodes but there's a
potentially large number of operations
on the tree right for the parser there's
a lot of ways of of building apart a lot
of a lot of pauses in the world a lot of
different ways of producing a structured
data from a string but you can only once
you've got a party you can only really
do one thing with it you can puzzle
string right so the style of parser I
what I like to use is something called a
part of the Combinator library now this
idea it's an old idea it's not it's not
my idea at all but it's about
representing a parser as object which
you can which do a simple thing and then
a number of operations to combine those
simple positives in sir more complex and
interesting parsers write the code that
it kind of looks like with the code the
code that it produces when you write the
positive combo when you
right code using a positive Combinator
library looks kind of like a script like
an embedded domain-specific language in
C sharp which sort of defines a script
for a given part of the follow so let me
and I've put a sort of miniature example
at the top but I'm going to show you a
more interesting one let me shrink this
okay so for example here's a parser that
parses the passes a not jaql node right
and not jaql node is the string not and
then some other jaql node right so that
might be a tag or it might be like a
parenthesized a group of other nodes
right likewise and I'll show you so the
way we pass this is we pause like a
single expression and then we pass the
word and and then we pass the next
expression okay
so for example a tag this is probably a
better example I'm going to pause a
sequence of characters I'm going to do
it in between two square brackets and
once I've done that I'm going to produce
a tag node right any questions about
what this what this part of Combinator
idea looks like for a consumer I'm going
to implement it in a minute so so
basically it's about building an
expression a C sharp object using this
passive type using a like a collection
of methods that the the parsing library
provides that kind of looks a bit like a
domain-specific language okay so let's
think about the design of what a
positive so first of all there are a few
ways to create very small parcels that
do like exactly one simple thing
the first parser we we implement that
the first parcel that we provide is we
call it I'm calling it return and it
does nothing I all it does is produces a
value right
in this instance it's that integer 3 but
it might be like a string or it might be
it might be like it might be a tag right
or not nodes another part that we we
want to support is a positive that
always fails and produces a parse error
okay it doesn't doesn't do anything to
the input string of characters it just
fails and then the third the third
primitive parser is one that consumes a
character from the input string calls
along the input string by one character
and returns that character yeah there
are also a few operations to take these
simple operations and build more complex
ones out of them
right oops we want to be able to
sequence two pauses right so if I pass
the string foo and then I need if I'm
trying to recognize the string foo bar I
might structure that as like parts of
string foo then parse the string bar
yeah I'll go into a bit more detail of
how that works right there's also the
possibility that I'm looking at if so
when I'm passing a jaql syntax tree I
don't know what the user is going to
type right they could type a tag they
could type an and query they could type
salary all of those are possibilities
that my passwords going to have to
handle it doesn't know which one to
expect right so we need a way of
choosing between two pauses right based
on what the user types so if the user
type the tag then I should delegate to
the tag parser
if the user types an and query then I
should delegate to the end parser and so
that would be like had it here so this
like this expression parser says like a
JQ l node is either a tag or it's a not
node or it's a expression a
parenthesized expression I forgot and I
know I didn't know it and then for an
expression it's a single term and then
it's an it's an and and then it's the
word and and then it's left of the
expression okay
right so let's think about how about
what this how we're going to implement
this parts all right what type are we
going to use to represent a para well a
positive is a function that takes the
string and produces some sort of
structured data of a given type right so
a positive for Bulls would take like the
string true will the string false and
then the book would produce this T would
be a bull yeah and it would fail on any
on any other string but if you actually
get down to thinking about how we're
going to support the operations
particularly then and all it turns out
that this simple type is not quite
enough so let's think about how you
would pass two puzzles in sequence right
so the string fubar foo then bar if I
pass the string foo I then need to look
at the rest of the string after I passed
foo in order to pass the word bar right
does that make sense so actually it
turns out that it consumes his foo bar
right the first parser has to leave
something behind after it consumed it's
part of the input string has to leave
something behind so that the second
parser has something to look at yeah
so instead of returning just a tea I
need to return a pair right I need to
return the structured data that I pass
the value and I need to return the
leftovers from the parser here
the remaining input string for the for
the second part of the then method to
consume okay
another subtlety about the then methods
is that once I pass the string foo that
is a successful pass by itself right I
have a result to give you right so if it
was like foo and then return 3 by the
time I passed the word foo I have a 3 so
that before I've even thought about what
the next part of its way
so the general version of the extend
method actually takes a parser which
returns T's and then it's able to use
that T to choose what the next part is
right I'm seeing some confused faces you
have any questions
let me show I'm going to implement this
in a minute so if you think about how to
articulate your question and then come
back to me okay what about the all
method right this one the one which
chooses between a pair of parcels right
well in general in the presence of or so
so here at the top is a puzzle that can
either pass through or bar right those
are the two valid inputs for this parser
in the presence of or each each a given
input string may have more than one
valid pars right so here's a sort of
slightly pathological example but here's
a puzzle which passes through and
returns the value one or it can pass
through and return the value two how do
you know which one is the correct one to
a turn right the simplest way is to just
return both of them right each of which
has their own leftovers yeah so in fact
rather than returning a pair of teen
string we're going to return a list of
T's and strings yeah this is also how we
implement failing a failure parser we
just return no results and it's also how
we implement the do-nothing return paths
that we just returned a single result
and don't consume any input yeah so this
is that this is the type we're going to
be working with and hopefully you'll
never forget it because there's a nice
nursery rhyme thanks to Fritz were a
part of the things is the function from
strings to lists the pairs of things and
strings okay so let's let's actually sit
down and write those functions that I
wanted to write like so here they are
I've just got them all returning null at
the moment so here's my here's my
positive type my delegate function from
strings to lists of pairs and things and
strings okay so how are we going to
implement a a part of that doesn't
consume any inputs but returns a single
value okay well so like I said it's a
delegate which means it's a function and
it takes a string as an input so let's
say input arrow and what's the return
value right well I said we don't
consume anything from the input string
so the remaining input is literally the
string that we were given right there's
no there's no difference between the
input and the and the leftovers and the
value that we return is the value that
we were given right so I'm going to
return a single singleton list
containing the value that I was given
this value and the same input that you
gave me to pause yeah any questions so
far about what phone do shout out if you
have any questions interrupt me okay a
puzzle that fails again this is a
function because part of the function
some strings to results a puzzle that
fails is a positive any results to give
me yeah so I'm just going to turn an
empty in your mobile C of and it's this
tuple type yeah I'm using the C sharp 70
pulse here by the way it's a it's a
pretty nice new six or seven under
feature okay this one's a bit more
interesting what about a parser which
consumes a single character of any any
character right and returns that
character right so this is a plaza which
returns a char so again it's a function
from an input string to right well if
the input string is empty then I can't I
can't give you a cat to write so input
links is 0 if it's 0 then I can't do
anything right so I'm just going to fail
if you did in fact give me an input then
I want to so the the I want to pop a
cat's off the input and that's my
results and the leftovers the remaining
input is the rest of the string apart
from the first character yeah so I'm
going to return a singleton thing so
this is going to be the first character
of the input and the leftovers are going
to be the remaining in to forget that
right does I do long
I need to need to cast that to an
ienumerable
I think maybe what have I done input of
zero it should be it should be that
should be a char and that should be a
char I think I think I got my type in a
fictional I was because that yeah that's
not a char leader there we go that's
what is I think I don't need that car
stuff tool okay so there's a parcel
which consumes a character from the
input string and then it passes passes
the rest of the string to the following
parts at which I will show you now so
how do we implement a Plaza which runs a
first parser and then runs the setter
uses mic so it's the puzzle that runs
we're going to return a parlor and it's
going to it's going to what that I was
going to do is going to run this PE
parva and then it's going to use the
result of P pass it to s and then run
the with the resulting parser on the
leftovers that the pea pods are produced
okay so it's going to be a function of
course because part of the functions so
to run the P power we give it the input
string right and so this is going to be
a ienumerable a collection of things so
and this second part is going to return
a collection of things so I want to
select many I'm just using the normal
link select many here so this is this is
going to be a chief ball whoops
result in the output of a puzzle is a
pair of a results and leftovers right so
I have a function which needs a T and
the Chi pull it that either is a pair of
T and some leftovers so the only thing I
can do with F is give it the T from the
cheap oh yeah now what do I do with the
resulting parser I want to see no it's
not going to this expression right we
took a func of T to positive view we
gave it a T so now this expression is a
positive view yeah what do we do as a
positive view where we it's a function
so we apply it to something what do we
apply it to we apply it to the rest that
the remaining input from the first
parser right which is cheap leftovers ok
any questions about then it's a little
bit some very terse so there might be
some questions about fit sure okay what
about a parser which can run two pauses
well this one's pretty simple again it's
a function part of the functions we are
going to run p on the inputs and then
we're going to run q on the inputs what
do we do with p and q well each of them
returns an enumerable of results and so
we just want to return all of the
results right so we just want to contact
the two enumerables so P input that can
cats Q input so those are our six six
five primitive operations right it turns
out that this is enough to allow us to
now work at a much higher level we can
talk about combining parsers using these
five primitives rather than talking
about like looking at an input string
using you know writing a function that
looks an input string and then produce
as a results on that thing produces some
leftovers right so yeah
okay okay okay the question was why does
this all power to use the concat I
didn't explain it clearly enough okay so
we've got two passes right P and Q and
Peter a parser is a function right that
takes an input string so we want to
write a function from an input string to
a collection of results right each of
these passes produces a collection of
results right once I've applied so the
first thing I do is I apply P to the
input string and I apply Q to the input
string to see what results those two
parcels returns right but as I said
earlier in the presence of alternatives
a given input string may have multiple
valid passes right so it's possible that
if P just failed and didn't return any
results or this key failed and infernos
was but in general they may each return
multiple results yeah and so the result
of combining two positives in this
manner is all of the results of the
first part and all of the results of the
second part does that make any sense
yeah
any more questions have I done a good
enough job of explaining that now there
might be some you sure there aren't any
questions about this Venn method okay
all right all right so I was talking
about how these five primitives allow us
to combine to talk about combining
parsers right not about not about
examining an input string and like doing
a character time we can talk we can work
at a much higher level and combine
parsers why so for example what's a good
example
okay so here's one which maps a function
over the results of the parser right so
this a parser which maps the function
over the result of the parts are runs
the first pars on the input string takes
its result remember then is a takes a
takes a fun because its arguments so it
takes the result and the puzzle that we
returned doesn't do anything it doesn't
change the input string at all all it
returns is the results of applying the
function to the results yeah likewise we
can do we can do a link e there which
takes a predicate and fails returns no
results if the predicate
not if the if the result of the positive
not match the predicate right so again
we're going to use those n methods we're
going to run the predicate over the
results of the parser if it's exceeded
then we don't do anything but if it
failed then the puzzle fails yeah one
more thing I wanted to show you is I
guess you guys probably know that the
LINQ query syntax this from select thing
is not bound to ienumerable any type
that implements the Select many method
with the correct signature you can use
from X in thing so I've written select
many here it's basically an alias for
then with a little bit of little bit
more stuff at the end of it but that
allows us to write a quite a nice sort
of script style way of writing a parser
we can use so what so the way you read a
from selecting for a parser is you just
read it from top to bottom so this says
1 the before parser run the parlor and
then run that after part this is a
parser it's the function which takes the
parser and runs it surrounded by two
other parts that's right so that would
be like parentheses so in fact in this
example so I'm for a tag I'm saying
it's a bunch of characters in between
and open back in a closing bracket yeah
so that's kind of nice anyway the point
of this though is that this is this is a
library this is reusable code right it I
haven't mentioned jql syntax in anywhere
in this it's the the client code that
talks about Jake your syntaxes
but the design of this library is the
type really we wrote down a type which
supported the operations we wanted and
then these operations kind of wrote
themselves given what we expected of the
type yeah so so yeah so we kind of let
the type system drive the design of this
of this pausing by doing there's one
more thing I wanted to save I forgot
what it was it's down here I think
now it's gone never mind
okay are there any more questions about
this pausing library nope okay so that's
so shown you or less okay oh yeah I just
wanted to talk about
I've written a library which does this
but some but it's basically faster than
the stupid thing about this
implementation the really stupid thing
is that I return a string of leftovers
right a string is a sequence of utf-16
characters packed into an array and so
that means every time I consume a
character I copy
almost the entire string right so this
is this is a really awful part it's got
really awful asymptotics because every
time you can seem in single character
you copy the rest of the string into a
new string and then send it on to the
next one which is just it's just
appalling ahem so in my library which is
on github I'll put the slide back up all
I do really is I keep the string as it
is and I have a pointer saying where am
I in the string currently and I just
need their left and right as necessary I
also have tools for pausing expressions
in a in a slightly nicer way like this
jqr syntax is an expression so in the
real implementation our code basically
using my expression pausing stuff and I
also support lazy pausing so I can pause
a stream or a text reader rather than
just a string which I know is silly in
memory there's I have a couple of
competitors in the in the plaza
Combinator space there's F parsec which
is an extra out library that's very good
but it's not easy to consume from
c-sharp because it's an extract live
where you have to pull in the full the
whole extra up standard library and some
of the operators have really strange
names as fewer if you look at them in
c-sharp there's also a library called
Spratt sure which I guess is probably a
German words I don't know and I write
another one sprockie
thank you I basically we were looking at
tools for parsing for this jaql feature
and we looked at Strucker and
basically said I can do a better job
than Spock there I think I think swagger
has some some efficiency problems which
basically can't be fixed without
rewriting the whole lightly in a
backwards incompatible way so that's
what I did I rewrote and I called a
pigeon
oh jeez I've got to wrap up I just
wanted to very quickly talk about the
downside of this match method this match
method right
this one right so each of these lambdas
is a closure we reference the job right
if you look at the the the the il that
Rozlyn produces for a closure what it
what it does is it create it lambdas
basically compiled into a class right
and when you invoke when you pass parser
lambda around what you're actually
passing around is a reference to the
classes method right so the problem with
the match method is that every time you
call this check seeing you allocate a
new closure on the heap the idea that
the so that's what produces such bad
performance right it's like it's like 10
times worse than than the than the the
fastest implementation that I
benchmarked and it and it has heat
residency where's all the others just
live on the stack so my idea was
basically let's write a compiler plug-in
that looks that looks for calls to this
match method and rewrites them into the
switch statement that you would have
written in the naive way right the
Untied switch statement that you would
have written in the naive way here's a
very simple algorithm I haven't really
got time to go through it but this is
this is what the sort of generated code
looks like right so you'd like this
match method on the left and I'm going
to generate a method which just does
like a switch statements and it does the
switch and cast and returns the right
thing the code on the right-hand sides
has no allocations right but the code on
the left hand side does because I'm
closing over this Y variable this is
kind of a crap example because I should
have used two jql thing but this is like
this is like a different language which
uses which does like
two expressions plus in science climate
the problem is really the Roslin is not
at the moment sets up for writing
compiler plugins I think not somewhat
user defined optimization pauses passes
so I basically I'll show you kind of
what the code looks like it's a bit
messy I basically had to there's a load
of crap in this top-level methods which
you know I have to manually import all
the writes see chart references and I
have to look sort of manually in both
the compiler after having like one my
own stuff I would like to see a future
was an API which supports plugins in the
meantime at Stack Exchange my esteemed
colleague Sam O has written we've
written our own bit of infrastructure
which supports compiler plugins and what
we're using it for a Stock Exchange's
localization so rather than look up a
translated string at runtime we
literally just rewrite the calls to
localize we rewrite those into a big
switch statement based on the user's
current language okay that's more or
less it I the the takeaway from this
talk is is that a type isn't like a test
right a type is a design tool it's a
thinking tool if you allow the types to
drive or even in the case of that
passing library the type kind of was the
library and we just had a bunch of
methods which the type sort of naturally
supports right and you can you can use
that to produce some very simple code or
at least some very terse and readable
codes often though that requires sort of
rewiring your brain to think outside of
the imperative mode of thinking right so
the the pausing stuff this is quite sort
of this it doesn't necessarily look that
much like c-sharp it's kind of it's very
sort of expression e and not very like
you don't you know you'd expect to see
some for loops if you're iterating over
a string writes and like this is kind of
like a slight abuse of the of the link
since
so my advice would be try learning a
functional language if you could follow
what I was doing today then functional
languages are well within your grasp I
promise you don't be don't be scared the
downsides of this style of writing code
I touched upon slightly if you're using
a lot of closures as as I was earlier
then you're going to you're going to end
up allocating a lot as I showed you I
would love to see a Rosslyn tool I would
love to see support in Rosslyn for
writing sort of pluggable compiler
optimizations so for example I could
write like I could I could ship some
code like jaql syntax in a library and
together I could ship a compiler plug-in
which allows you to write typesafe code
that generates fast imperative code you
know also I wanted to bring to your
attention the fact that there's some
interesting language design going on
right now particularly in light rust and
go languages where they're using the
type system to help you reason about the
performance of your code and the
correctness of your code right so rust
has what's called a borrowed checker
which basically makes sure you don't
leak memory that's a performance issue
but they're using type systems help you
even about it okay I've got maybe a
couple of minutes for questions now I've
got - one minute for questions so see me
after if you have any questions thank
you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>