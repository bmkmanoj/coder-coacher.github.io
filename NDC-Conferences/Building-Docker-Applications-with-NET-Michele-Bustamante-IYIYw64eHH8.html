<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building Docker Applications with .NET - Michele Bustamante | Coder Coacher - Coaching Coders</title><meta content="Building Docker Applications with .NET - Michele Bustamante - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building Docker Applications with .NET - Michele Bustamante</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IYIYw64eHH8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody i'm michelle darou
Bustamante
and have a company called salons I do a
lot of architecture consulting cloud and
security focused we specialize in all
things I guess
cloud and otherwise but I particularly
run a cloud practice where we've built
up quite a bit of micro-services talent
with many different platforms and all of
that of course is founded on docker at
least in our our work together and I'm
going to talk to you a little bit about
building docker applications for Windows
but also cross targeting Linux or
Windows so looking at some of the tools
with Visual Studio that are new they've
actually just released some stuff this
week so all my demos are going to work
and that's all I have to say about that
so we first should talk a little bit
about why docker and of course you've
probably heard a lot of stories about
why docker is helpful useful powerful I
would say I'd start with it enables
micro-services architecture which of
course is another word that people hear
all the time and I will start by saying
not everybody needs a micro services
architecture of course and so this is
overloaded often talked about for things
that are not requiring it but that
doesn't mean you can't still apply
docker without going full-on micro
services so it enables micro services
architecture and the reason we go
towards that path is for the flexibility
of faster release schedules enabling you
know your applications to be deployed
frequently updated with less regression
of course over the whole application and
the reason we want that is because the
business cares it's all about the
business if it is valuable to your
business to have a micro services
architecture then going forward in this
path with some form of baby steps which
I'll talk about in my second talk today
will probably be beneficial and how far
you need to go might depend on scale
size of solution and desperate need for
the type of things micro services solves
in terms of problems while creating new
ones faster release cycles is the main
thing that the business will benefit
from and that's why we usually look
first to the business to see is this
going to be valuable docker enables the
because of course it's supported by a
lot of the platforms that enable
microservices applications why we like
docker also is because it gives us a
polyglot development environment I can
have developers that do golang or Java
or drop wizard it's different forms of
java.net applications node and Python
and and use the right tool for the right
job as they like to say and then at the
same time be able to come compose those
applications together or those moving
parts those components in an
orchestrated solution and so the fact
that we can enable that with containers
is is really powerful and I would say
beyond that it's also highly powerful
because of the developer workflow that
it enables so if I would say I use this
probably on a daily basis and it's one
of the most powerful things I can do
with docker and that is have a new team
member join a project and literally say
install docker and run you know get the
latest repo and run compose up and what
that does is it gives them literally a
complete for example back end to the
front end that we might be debugging in
Visual Studio or some other tooling and
I don't have to have them install you
know sequel events store run scripts do
migrations all the things that just
waste time and cost a lot of dollars
when you need to set up a new machine so
I would say compose up one of my number
one favorite things to do just even in
development if you're not even using
docker for a you know deployed solution
at this time it's highly useful in
development and of course with the micro
services target you know the the target
goal of a micro service enabled solution
we are probably looking at a lot more
moving parts a lot more updates to the
release cycle smaller components of
course that are composed together and
that means we have more complexity and
with that complexity including in the
orchestration platforms and the
management of those we of course are
hoping to get some gain on the other
side which is where the business has to
be behind it otherwise you will fail so
the business behind you you have a
target goal you build a micro services
solution you start targeting platforms
you need
DevOps culture to survive that if you do
not have you know high availability
disaster recovery visibility into logs
great dashboards for managing things and
knowing when something's wrong
self-healing you know and and drills
against those things to know how does
the system behave when we make failure
happen it's a lot of work upfront the
payoff is on the other side you spend a
lot of money early am i selling you on
this yet you spend a lot of money early
for the game later but the first eight
months is is a lot of work right no pain
no gain and so what we're looking for is
that resiliency that comes with the
other side of that effort which is oh
look at this I've got great logs I've
got an instrumentation I've got into and
activity tracing all these things that I
probably should have been doing anyways
with all of my applications but now I'm
forced to do or I literally won't
survive the micro services movement
so with that docker enables all of this
what does this mean to a.net developer
obviously it means something to other
developers too but we're focusing on
the.net tooling number one you can run
your dotnet framework legacy
applications let's call them legacy now
cuz of course cores been out for at
least a week 2.0 so dotnet framework
applications you know can run in Windows
containers and that means that I can
literally with very little changes to
the app have that be deployed alongside
other container other containerized
parts of the solution and then later
migrate the monolith into something a
bit more palatable something that's
better factored and so on so I can still
get that thing into the cloud migrate to
the cloud more easily there's lots of
things we can think about there we
didn't have that before windows
containers because of course dotnet apps
would have to be fully rewritten into
asp net core to go to a linux based
image so creating new applications we
can go with dotnet core and we can
target either Linux or Windows a lot of
people target Linux just because a lot
of the container platforms are very
mature on Linux but of course that is
starting to evolve and change and it
also changes with the need to have a
mixture of legacy and modernized
applique
so now we care more about having one
container platform that's made me
focusing on Windows VMs instead and so
we can decide that's what I'm targeting
if that's my culture if that's my need
so the fact that I can build new apps
and target Linux or Windows depending on
what we're trying to achieve the fact
that I can take my legacy apps and then
of course have that same development
experience I'm used to today I'm in
Visual Studio
I have f5 debugging experiences and I
also have tooling to help me enable the
docker experience so now the heart of
all of this would be that I'm taking a
nap and I am building an image for that
app and I have to have that base image
is compatible with my target environment
so it's gonna be Linux then I choose a
linux based image it's gonna be Windows
then likewise a Windows based image so
in the docker store which used to be
called docker hub we actually have
images just a smattering put here you
know the the Nano server image which is
the smaller form factor image that would
support you know your Linux equivalents
let's say but targeting windows
lightweight and then we've got Windows
server core which would support our is
si is based deployments and so of course
I'll need a heavier image that has a lot
more moving parts to support those
legacy applications and then we've got
an ILS image which has pre deployed iis
so of course that's now the layering
aspect we get into which is which image
should I choose if I would like to go
with a raw Windows image and install the
other things myself then I can build my
own layered images on top if I would
like to use something that's bedded and
you know blessed by Microsoft and then
build on top of that then I can choose
one from the store so the Windows images
are here and then we also have the Linux
based images that have asp net core
enabled ready to go so you would choose
one of those images and that would light
up deploying kestrel and the estriol
based access for example instead of iis
right so i'd have a web server or
reverse proxy for that I can deploy just
Net Applications if there are going to
be some sort of projector or you know
console type thing some some
process that runs no need for a web
server and then of course there's even
build containers and the build
containers enable us to have a drop to
command line experience and/or
automation experience for building the
images without having to set up a bunch
of things on my CI server even to do so
so for example Jenkins can take
advantage of you know using some of
these build images just like I can in my
own dev environment and then of course
we have layers on top of that you know
having you know source code SDKs built
into some of the images and then things
like sequel server variations no I'm not
going to deploy a clustered sequel
solution with containers data and
containers is not generally a
recommended approach in most cases you
want data clusters running on hard metal
but I would say this is extremely useful
for development and it can be useful for
smaller deployments that only really
need something that will run most of the
time you might be one of those people
but you won't admit it so sometimes
people deploy stuff and they're just a
startup and they need it up and running
that's an easy way to do so I just
wouldn't recommend it for long term
right so we have these images you can go
to the store and choose from them but we
will see that we're going to choose them
as part of working with the tooling that
comes out of visual studio of course
with the whole support for legacy dotnet
applications we now have the ability to
port all of these legacy applications
and they could be WCF base they could be
different versions of asp.net anybody in
here has ever had an old version of
asp.net applications running maybe you
know pre 4.5 you know it happens and so
you know you can build a container that
has exactly that so just for some
examples you can take the is docker file
and this illustrates things like you can
add windows features so this shows
adding the windows feature of iOS but of
course you could also have features your
app needs this is the kind of thing you
would do as part of your docker file
description you can do things like
service monitor is the entry point for
keeping is alive in the container you
can copy over source or executables and
them as part of the launch of the
container so you can describe that in
your docker file two things that you can
do that legacy apps might need or even
other apps right so this is important to
know asp net 3.5 this is an example
docker file that has that is based on
3.5 just to show that that can work too
and this also has things like dotnet
effects 3 being deployed so i can do
things like WCF and so forth right so
exam example of adding packages as part
of your docker file description for a
legacy app very powerful and then
something out of the box that might
support your dotnet 3 apps likewise we
can configure iis requirements so there
are some handful of things that you
might want to configure as part of IIS
there you go and likewise you might want
to do things like tailor a custom
container that is exactly for your app
with the features it needs with the iis
tweaks it needs with the entry point
some sort of runtime executable that it
needs and again these are just examples
of things you can do and also showing
that we have these you know sort of
variations of legacy containers
available and ready to go as well
ok so with that let's talk about docker
for Windows so in order for me to
develop for docker I have to install you
know the the docker seee on my machine
and the newest evolution of that is
docker ce4 windows or for Mac so that we
used to have things like katana or
kitematic I should say and we used to
have you know docker tools for the
Windows machine that ran different ways
so you know docker for Windows and
docker for Mac exist so on my Mac I
actually have the latest docker for Mac
working and of course docker for Windows
is the one that will support me doing
either targeting Windows or Linux
containers I can't do that on the Mac so
if I want to do Windows development I
have to buy myself a Windows machine and
not saying I only bought this so I could
do a presentation but let's just say I
used to use a Mac all the time and now
I'm doing dogger for Windows because we
have more demand for that in our
ecosystem so you need a Windows machine
for that in other words so I install
docker for Windows and that
is is you know a single installation
right it's a native application that
gets deployed and it also integrates
with PowerShell or other shells on your
system so I can go directly to
PowerShell it's really easy I didn't
have to set anything special up and I'm
able to run docker commands immediately
so that's pretty cool
docker for Windows has a Linux VM so
right now Linux if I'm deploying to
Linux and testing locally it's actually
running virtualized that's going to
change in the future I don't have a date
for that but I know I'm allowed to tell
you that it's going to change in the
future so that we don't have the
virtualization step right now it doesn't
I don't even notice the difference to be
honest it works just fine
so just to know that it's coming okay so
right now I have a VM and that helps me
execute Linux I can also look at the
mode I'm in by just typing at PowerShell
command docker version and that'll show
me am i running in linux for example and
if i'm running in linux versus Windows
right so the client of course is a
Windows but down there it's showing that
I'm running a server which is the Linux
based which means I'm targeting
everything I do right now at the command
line is going to show me images that
I've downloaded for the Linux
environment and it's going to be any
containers that I've run that are based
on the Linux base image and I can switch
over to Windows container so there's a
little you know toggle for that so
you'll see me using these things I'm
just giving you an overview first and so
once I switch then I'm gonna see that
I'm running in Windows and I can go
docker version and see what am i running
at the moment it's surprisingly
difficult to remember which one you're
running sometimes and so if you're doing
things like switching between the two
which might not be a day to day
development task you will find
interesting errors happen because you're
not running in the right environment I'm
not suggesting that will happen in any
of my demos because why would I forget
but it could happen and now you know why
so if I switch back and forth right
that's how I kind of know what I'm
targeting right now and then of course
there's Visual Studio so if I'm building
apps in visual studio with dotnet
framework proper and or asp net core or
dotnet core then I'm going to
so take advantage of the tooling that
comes out of the box not literally a box
but that looks like a box as well so
let's talk about docker enabled projects
so I'm I'm in Visual Studio I want to
create a new application I want it to be
darker enabled so what I'm gonna do is
mostly demos at this point and talk you
through things we can do okay by the way
as a point of reference I have a docker
for sorry I have a Visual Studio preview
installed because only just yesterday
the preview stuff landed in the main
line Visual Studio 15.3 for 2017 I did
not dare to install that the day before
a talk so I'll be using preview for some
things and the regular previous version
for others in the essence of happy demos
that work I thought you might like that
so I'll mix between the two and I'll
explain the differences so that you
understand right okay so I'm going to
show you Linux and of course when I
create a new ASP nut core app targeting
Linux then I'm gonna have a docker file
that targets a base image like Microsoft
asp net core and actually they have
multi targeting base images now so in
the newest tooling you'll find you don't
actually have to specify if it's a nano
server or not it gets figured out as the
build server takes as the build
container does its job and so you know
in some of these demos I'm showing
specifically targeting a version for the
base image I still agree with doing that
as a rule because it can bite you going
to production for example if all of a
sudden when you build your getting
latest write if you don't already have
the image on your machine or your
environment so I still suggest target
specific versions always right that's as
you're doing things so for what that's
worth you'll also notice that when we
look at the docker file if you're
familiar with docker proper meaning
docker without going through tooling and
debugging like in Visual Studio you know
this copy source line and things like
that are actually intend
so that visual studio can allow you to
be debug right so it actually does
things like mouth drives and when you're
running then hooks in and entails the
logs into the output window and makes it
possible for you to debug so we would
not normally have you know a lot of this
kind of stuff in our docker files with
source being passed in as a variable
right so little things like that are
just done for you but what I find is the
most important part of that is I still
want to be able to create a new app in
visual studio that's enabled for docker
I want to be able to debug when I feel
like it but because I'm used to working
without those tools most of the time and
because I want to eat my own dog food as
they say and use my logs as my guide of
errors then I will usually not rely on
the debugger for docker work so I think
there's times when that's extremely
useful and I think that when you get
into multi container solutions it
becomes more complicated to do that and
I think you know again it's it's an
opinion but being able to just drop down
to the command line with the same things
visual studio generated for you is
really helpful and useful to know how to
do so that you're not creating custom
docker file just for my command line
experience separate from the things that
I do when I'm in visual studio debugging
f5 so I'm going to show you that as well
I just thought I'd give you the context
upfront so I'm going to create a new app
for you know targeting Linux and then
we'll do the same for Windows and we'll
switch to Windows containers in order to
run that and I'm going to make sure to
show you the command line features some
things that we can come back and review
after so let's do that
okay so first and foremost let's do a
docker images just to give you an idea
what I've got on here and let's also
make a point of checking which I'm in so
I'm going to switch over to Linux
containers to start with I was just
flipped over to the other so see I
caught it ahead of time mm-hmm okay
you can I'm sorry not that I know of no
cuz it's really it's a it's a native app
that's helping you switch so I don't
think so okay so we've got docker images
and now I'm gonna see a whole bunch of
different ones right these are all the
linux based ones right so that's just to
illustrate you know I can type top four
version and I can see that I'm running
in Linux here mm-hmm and then docker PS
see if I have any running containers
doesn't look like it docker PS - eh
doesn't have any containers running it
so just to give you that clean slate
here's what I'm starting with and I'm
gonna go over to preview so here is my
visual studio preview which again now
this tooling you're gonna see is in the
15.3 release of Visual Studio 2017 so
I'm going to open create a new project
and we'll select ASP nut core
application and I'm going to go ahead
and type docker demos and we'll call
this demo one cuz apparently it is and
now you'll see it lets me decide how I'm
targeting whether it's Linux or Windows
that's a new thing with the latest
tooling what it does it put something in
the project file that allows it to know
which it's targeting I don't know if
that's going to be a long-term thing
that stays but it's something you should
know because that means you can't just
change your docker file and run against
Windows without you know going and
editing that project file so it's
probably not a natural thing to think to
do I'm not gonna build a container and
literally try to multi target the same
app and just switch between unless I'm
doing a demo so it's not likely that
that's going to be impactful but so
right now that's kind of a new thing
that they target so I'm going to hit Web
API and we'll go ahead and run that it's
going to open up you know create the the
standard API project you know API get
values type of thing but it's also going
to create some docker assets for me so
I'll have a docker composed project
that's created in here and the doctor
composed project has a yeah Mille which
is describing the services that are part
of this composition right so when I run
this compose or compose up it's going to
say oh I have this one image it's called
demo one and you know I'm going to go
ahead and build it using the docker file
in the context which is in the dot demo
one directory so let's go over and take
a look at that docker file and in here
you can see that it's targeting core 1 1
because that's what my template once
that I chose and so it should
intelligently choose a base image that's
compatible basically and there's a
number to choose from right so I won't
get into the details there but and then
of course this is what I talked about
before this will allow debugging to
happen because it's going to go ahead
and mount drives and things like that
and that all happens actually under the
cover so another thing that's changed in
the recent is if you use the previous
tooling you would have seen a couple of
at yama files that were you know layered
you'll see that in one of my examples
now they've sort of ingrained or sort of
built into Visual Studio the
intelligence too when you're debugging
do the things it wants to do without you
having to see it and that way when you
drop to the command line
you know you're not really dealing with
visual studio assets you're dealing with
just raw docker things so I think that
makes a lot more sense so with that I've
got docker compose I've got a controller
I got go in there and maybe make a
breakpoint or something because that's
what we get and just so you know it's
not running some other app will say
hello NDC as nobody ever thought of that
in the demo before and I'm gonna go
ahead and give that a run so this will
be my you know debug experience it's
actually going to use the default
network it's going to generate a port
for me it's going to run it or localhost
and it will it will tail the logs in the
output window so you'll start to see
logs after we get past the build process
and so there we go so I have this API
values and it's just returning a result
to show that it worked and if I type
some other
value I can jump in here and I'll get a
debugging experience so you can see that
and continue and go right so I get the
results in here and let's see let's go
to stop that and we'll go back to visual
studio I got to remember which one I'm
in so here we go okay so new project
docker enabled f5 debugging experience
targeting Linux with a compose file that
right now just has one service I'll do
two services in a bit and then in terms
of output if you take a look under build
you can see how they went about building
the solution so basically if we kind of
come out here let me jump back a bit and
I'm going to scroll to the top some of
the interesting things that you'll see
is that it will do a compose and I'll
just kind of scroll in here it'll do a
compose with multi file right so you can
see that it's got the basic compose file
and then it's layering on top of that
you know the one that says hey this is a
development environment with an override
and the reasoning of around that is to
tell Visual Studio also with environment
variables what environment are we
running so that it can inject all those
things that we talked about right to
give you debugging experience and so on
so so you can come in here and you can
see things like that if we kind of
scroll down a little bit further it just
shows you the resulting compose file
after layering you can see that the
volumes are getting mounted you know
just details that allow the debugging
experience to happen but I don't really
want to run in the debugger all the time
so what I usually use compose for is the
non application assets initially until
we're ready to test our app as a docker
app i want the performance of just
debugging a regular web app web api all
the things but i want to hit maybe some
server-side data maybe multi
multiple types of databases that all can
run in a container I could have Postgres
sequel events store you name it
a Redis cache and have all of that sort
of running in my command line as a
separate part from the solution and then
of course you know when I'm ready and I
want to test the application is working
still as a docker container then I can
go ahead and start dropping down and
running as docker so I wouldn't do that
necessarily for every step of my
development it's it's something you can
think about okay I think it really hits
you when the solution is big when
there's a lot of files and it just takes
longer right because you got to build
the image and all the things and I don't
like to wait for that stuff right so
okay so let's go back to the command
line and let's do this docker images so
now I have an image for demo one one C
and I can say docker PS and demo one is
actually running right now right so I'm
going to do this stalker I'm gonna use
my magical delete all running containers
and I'm going to show you the experience
that I want to have when I go down to
the command line so I've got this new
project and Here I am and I can see I've
got my composed files these are the
things that created the project the the
DC project docker composed project so
what I'm interested in is hey how did it
know to build the files where did it put
the files and then how did it build the
image with the files because I need to
reproduce that experience and that's
where the CI build container comes in so
what I can do is let's do this
see I got build oops and to do up
so now what this is doing is it's taking
the CI build it's going to restore
packages on the solution and then in
that container go ahead and publish the
solution but since the drives mounted
it's going to publish it to a particular
path called object docker publish and so
that path becomes really important
because the things that Visual Studio is
doing for you is looking to that path
and it actually has a docker ignore file
saying you know that it should allow
that particular path to be available
otherwise it would not be available if I
was trying to build the image for
example so now I've actually got that
set of files built and that should have
created the output in the object docker
publish folder now when I run this let's
do this I'm going to go ahead and let's
take a look at the compose animal again
and so what we're going to do is we're
going to do a built override and so
docker compose I'm going to take the
compose animal which just says this is
the service this is the image where it
is right so we've just this is the
source where it is and this is the image
I want to build it's going to be called
demo one and then it's going to go over
here and it's going to override with the
developer setting if I choose to to use
that override so I'm going to hit enter
and that what that will do is go ahead
and build what was output to the object
published so if I didn't run that CI
container first to publish output the
same way visual studio is used to doing
it then it's a little harder to use
their compose files and if this is not a
bad thing it's just a matter of knowing
I like the command line dropping down to
the command line experience I can have
both perfectly easily it was just two
commands right so that way I don't have
to always be running in in Visual Studio
and the other reason that's useful is
because I can't Tale logs if the
container is running in debug I'm gonna
see the logs in the output window so if
I'm interested in actually seeing my
real logging experience maybe overriding
is
it to elasticsearch or somewhere else
then I need to run it as a non
development environment right I'm going
to run it from my command line and I'm
going to get that traditional experience
so what I could do now is we've got
docker images and it's reproduced a new
demo one you can see latest 33 is the
image ID and what I'm going to do is do
a docker excuse me
docker compose and that will go ahead
and run the image actually it's probably
running a second one let me do this
docker compose okay and I have an image
running it's two-way is the container ID
and if we take a look over here we can
see the port it's running at which is 32
seven eight three and now I can pop up
here and say let's go to 32 73 and hit
that just like I would otherwise and it
looks like it's working right so I can
just go back to values see that I get
output and it's up and running right so
one of the things I was trying to point
out here was that you can so let's go
back over to the beginning and what I
wanted to show you is that you can do a
docker compose logs follow and so what
that will do is follow the logs of all
the containers in the compose file I
couldn't have done this and got any
output in the command line if I was
running in Visual Studio so again that
comes back to that I'm in Visual Studio
I'm gonna see it in the output window
same development experience I'm used to
have five debugging I'm gonna drop down
the command line I'm gonna see how
things run without all of that with less
overhead and with my traditional logging
output okay so okay
now that was focusing on Linux let's go
to Windows and what we'll do is hit
switch to Windows containers and we'll
just go ahead and clear that here now in
the past like I said before the new
tooling came out I would actually just
take the same you know example change
the docker file to use nano server and
then I could actually run a building
image for targeting Windows using the
same solution but you know now we've got
a bit more of a targeted solution that
when you creates the solution in the new
preview or the new release it'll
actually target a platform so I'm not
able to do that which again it's not a
bad thing it's just something to be
aware of in case you were used to doing
that so what I'm going to do is get out
of here and go to demo one and let's
instead create a new windows and the
other thing that was not working until
recently which is great is I can now do
Windows debugging in Visual Studio so
that's a recent advancement so so we'll
do demo two and little target Windows
and away we go so there's a couple of
nuances again that are different just
because it's now evolving the tooling
I'm gonna get the same solution that I
had before I'm gonna get the same five
debugging experience that I did not have
before with Windows so now I get it and
I'm going to have you know a docker
compose but you're gonna see an empty CI
build that's just because Visual Studio
is actually going to do all the work of
you know Jen going and building the
published output for you and gathering
the correct CI container so it's
starting to hide some of this custom
stuff that's related to f5 debugging and
running from you so that you don't have
to deal with it it's still again
evolving the tooling is getting updated
pretty frequently now so something to be
aware of so if I go to my compose file
you'll see it looks the same as the
other one and now we have composed three
that's another thing that's an evolution
it would use to be that it was
are getting 2.14 windows in the previous
version of Visual Studio until this
release so compose 3 is now available in
debug mode and the other thing that you
should know about Windows is that right
now
networking requires me to actually
specify a network so that we can have
communication with the container and
that's also going to change right it's
going to look a lot more and more like
the the linux experience that we're used
to but they're working on some DNS
changes there's some DNS Cassatt caching
issues there's just some improvements to
networking that will allow us to have
local host experience so right now it's
going to go to an IP address which I
could go get from the command line but
Visual Studio is now able to do that for
me I used to have to go find it so I'll
show you what that all means but that's
why you're gonna see a network to find
in the override compose eventually that
won't be necessary
ok and so let's go ahead and run this
so I'm actually in Windows so I have the
new solution I think I threw a
breakpoint in and again this is now
possible for me to debug Windows as well
so so I'm going to talk a little bit
more about compose and you know
networking in the talk later today
actually so right now for this one I'm
gonna leave some of those details alone
just so that you know if you're
interested okay so this is running and
then at some point it will launch the
browser and it's actually going to go
and find the IP address but in the
meantime let's go to the command line
here and let's do a darker PS and see
what we've got
looks like I have demo to running so
this for a is the you know the first two
characters to describe the container and
you can notice here that it's hitting
against an IP address like I told you
right
it's mapped to port 80 so I don't have
to see a port at this point now given
that if I didn't if I was dropping down
to the command line and I wanted to know
what the IP address was then I would
have to go and
find it so it's helpful to know how to
do that so you can do a docker exec and
I can say for a IP config and then that
will tell me the IP of that container so
that I can address it instead of
localhost until the fix comes right so
if I was wrapping down to the command
line that's how I would do that and you
know everything else should work
basically the same right we have Windows
we have we have logs we've got
breakpoints so if I go back over to the
browser and I hit something it'll hit my
breakpoint right so okay so those are
pretty simple examples just to sort of
kick off and this is just sort of a
reference for you around some of that
dropping to the command line stuff that
I think people will find useful we
talked about Windows and you know what
you didn't see me have to do is choose
the base image and make it a nano server
image because that's actually being done
for us
visual studio tooling right so when they
do the build and run they're actually
assigning the right base image on the
fly now so you don't actually see that
assignment in the Windows environment
right now so again new tooling just came
out all that matters to you is that if
you want to get explicit with your
docker file you may want to go in and
put a particular version as you're
evolving your solution to a particular
you know deployment that should be on
version X yeah so let's talk about
adding darker support then to an
existing app so this is all fine I can
start fresh green field I can add
multiple services to a solution that's
another I guess philosophical discussion
around you know what is the
micro-service approach to visual studio
solutions and repositories and just as a
tldr I would say really the solution
should be the micro service so unless
these you know services compose together
all the time then they probably
shouldn't be together in this
solution you need a repository it's a
nice clean separation it helps your dev
teams work in isolation like they should
learn to when we think microservices
autonomously and not depend on one
another and not have coupled code and it
forces you to think about how I share
code and say for example nougat packages
that have explicit versions that you
opt-in to download I could go on about
that but I won't so that's just a quick
taste just something you want to be
thinking about now I can take an
existing app and it's got maybe web apps
and api's and well you've never seen an
app with 97 you know projects in it I'm
sure that's probably not going to
convert well just FYI
so you might think about at least
compartmentalizing the parts of the
solution you're going to docker eyes and
start looking at that repository
approach but if let's say I took a
simple example a web app and an API and
they need to talk to each other we can
now dig into how do we add those things
how do we add docker to that existing a
couple of things in the solution and
what does that build for you in the
compose description right it's going to
have multiple services it's potentially
gonna have dependencies on multiple
services which we'll see in a later
example and so on and the other thing we
want to talk about our environment
variables of course because you know
you're probably if you're running an app
in Visual Studio gonna use app settings
and that makes sense you know you're
you're running with web config if you're
a legacy app but you're running with app
settings if you're a core app right and
I want to keep doing that because that's
natural for the development cycle and
then what I want is of course for
environment variables to override that
if they're present and I'm not gonna you
know I can make the environment
variables and those overrides available
just by putting them into the compose
file you can put them in the docker file
too but it makes a lot more sense to do
it in the compose file because that's
really the deployment the deploy and run
artifact if you will right that's the
task or service description that you're
going to be using when you go to
container platform that's going to ship
up those overrides to the container
platform as well there's various ways to
do that that's a
discussion for the later talk I'm a
bookend today I have a talk at 5 o'clock
in the morning so so yeah so we're going
to talk about environment variables and
overriding those as well so let's take a
look so I'm going to go into my Web API
solution there we go okay so this app
right now is a web app and API talking
about app settings
I do have base address localhost it's
looking for an API address right so this
is API base address is looking for and
that would be this API right so this API
has an address described in its launch
settings with the application URL so
it's basically you know so that the two
can communicate so if I were to run the
app without docker it'll run in iOS of
Express and then I can run the web app
and it will find the API and everything
will work or it could maybe not work and
that's another option so right let's
just go to docker ok that's weird it
doesn't really matter though so I'm just
gonna go over here and let's try having
docker keyboard ok
so what I'm gonna do is add darker
support to this app so what that will do
is generate the docker compose project
again generate the yeah mol and this is
actually using the previous tooling only
for the sake of not suddenly using new
tooling you know all the way through
this particular session just to be safe
so I've got a docker compose yeah Mille
and you'll notice that that actually
dropped me to version 2 but in fact it
works with 3 right so I can actually
update that if I like you'll also notice
that the docker compose therefore has
these layers that are version 2 so why
do I care about the version of compose
that might be worth mentioning
so the tooling for Visual Studio sits on
top of docker for Windows docker for
Windows uses compose 3 that's what it
uses so everything that we want to do
with docker all the commands that we
issue to build and run container stop
and start containers compose up with
containers is all working against the
docker you know Community Edition right
that's part of docker for Windows the
studio on top is really just tooling
that generates templates and projects
assets and so the previous tooling
obviously hadn't caught up yet so this
is just to point out that it's not that
there's anything broken with you know
the darker parts it's just that the
tooling didn't have a template so so we
can easily just go in and edit this of
course if you install the latest Visual
Studio you won't have to so there you go
okay so I've got these compose files and
I've got this web app that now has a
docker file and the docker file
indicates core 100 because it picked the
right base image because this happens to
be a 100 I haven't updated it on purpose
you know just because that illustrates
the choice of images right and so now
we've got our web app let's go ahead and
add docker to the API and what that will
do is update my compose so we'll say yes
we want to update the compose and let's
go take a look at that and now you can
see that I've got a web app and I've got
an API yeah I don't have to specify the
network for Linux it's just going to
work
speaking of Linux let's go back there
thought I'd forget didn't you okay okay
so basically with that docker compose in
place and with you know the web app and
API set up with docker files when I do a
compose up by hitting a5 it's actually
going to run the two so if I go run then
the one thing that will happen that
won't work right is this API base
address so the API base address is not
in the environment variables yet so I'll
add that after but I just want to show
you the running at first
I'm guessing it just didn't switch yet
those are the weird errors you get
I'm gonna run that again just because it
might have just not quite been finished
with the windows see it's doing a docker
compose here and it's stitching together
all those compose compose files and
should be building there we go I think
it just hadn't flipped fully from
Windows to Linux so you get kind of
weird errors in the debugger when you do
that okay so this is the app it's just a
website fake website with a you know
speakers and sessions conference sort of
view and when I hit speakers I'm trying
to find the API so the Web Apps
obviously running and it's containerized
API is also containerized but it's
actually just not gonna work because it
can't find the address right so we'll
let that think for a sec and in the
meantime I'm gonna go drop back here and
let's say Joker yes and we'll see that
I've got a web app and a web dev running
yeah so in order to fix that up what I
would have to do is you know set the
environment variables and so forth and
let's go over here I'm probably going to
hit an error and I'm gonna stop
debugging and what we would do is we'd
head over to the compose and go to here
and I would add to the Web API an
environment setting right so I'd say
environment and I would say API : base
address equals HTTP and the name of the
actual API by DNS which is API so that's
what it's looking for now instead of a
port and all those details because going
to use the networking from the compose
up so we're gonna get the default
Network created for us and that's how
we're going to address each other
through DNS okay and so we give that a
run again and it should be able to find
that
so you see it's creating its compose
it's building rebuilding the images if
needed and then it's going to run the
two containers again and eventually that
will hit over to the website and there
we go
and then I did my job that should work I
don't know why I'm hitting a breakpoint
there but let's see oh I guess I didn't
do my job well this is all part of
showing troubleshooting skills because
you know we need those two so we're
gonna head over to here and I probably
just did something wrong
most likely yeah yeah I think so I think
I put it in the wrong place
probably
okay I'll give that a run again you know
sorry wrong address there yeah I think
it's the other direction it's hard to
see the tabs and this stuff so I think
it's probably yeah I think that's not
the right level actually that's weird
oh oh oh sorry yeah that's it I knew
that I totally knew that
I just didn't read it right so yeah okay
so that's gonna work and in the meantime
let's let's continue so a couple things
I wanted to point out about that example
is compose up ran the two and basically
built both containers ran the two of
them and put them on a default Network
and allowed me to address through DNS
which we'll see works in a moment it
still gave me the debugging experience I
can do the same with Windows so I won't
show that again just because that would
be like a dupe but let's see oh that's a
weird breakpoint to hit so that makes me
feel like it's not gonna work I say that
out loud I think I did yeah it's gonna
be something super dumb but I don't
really care cuz we all know it's gonna
work right I put quotes around it
sometimes it takes quotes sometimes it
doesn't I don't know
oh it's Web API not API that's the other
problem it might help to use the correct
address so
this could totally happen to you one day
so it's really important we go through
these things I'm gonna let that run and
let's continue so when we override
environment variables we don't want them
to be secrets that's a whole nother
discussion around using docker secrets
most of the orchestration platforms now
have first-class support for some form
of secret management and then that would
be a different way to you know capture
you know more sensitive information like
database connection strings passwords
and things like that so you don't use
those for environment variables but of
course settings like addressing relative
addresses and things that obviously are
not at risk for misuse if this doesn't
work I'm just gonna like you know really
shoot myself or not do that but thank
you oh okay right thanks yeah that was
like really painful God hello world
fails really what's wrong with you
okay so environment variables now the
other thing that we want to be able to
do so we've talked about new apps we
talked about new apps with windows we
talked about debugging you have five
experiences talked about multiple
container applications and compose up
and doing that with the debugger I could
also drop to the command line and do the
same old thing that I showed you before
and get my compose up with the multiple
containers there and what we haven't
talked about is the migration of the
legacy apps but we've shown some
container or some images that would give
you the baseline for that right so you
also have to start with the right image
depending what your app needs to run and
there could be other things your app
needs to care about that are out of the
scope of the docker parts like where's
the database where do I log other things
that maybe don't go on the container but
as for the container itself it's really
the same experience when you migrate a
legacy app you're going to add docker
support it's going to create a base
image that matches what's appropriate
for this app's version so if it's a 4.5
app it'll choose that and so on it'll
enable I I ask by default if it's a web
app so that you'll get that out of the
box and there's um you know obviously
some of the same debugging experience
out of the box as well so you will get
an f5 and debugging experience with the
legacy app 2 and it will mount the drive
so this is a
just showing what one of the docker
files look like when I did a migration
and the other thing that you can do and
this is where we get back into that
developer experience for productivity
I needed a local sequel database for
this what I did is I took a product that
I have but an old version in TFS just
for an experiment so it's a mess in
there trust me it's an old version and I
basically took the snap board app that I
own and I migrated that and it's got a
ton of stuff in there and it just kind
of worked out of the box but I needed a
local sequel database so I grabbed the
sequel image and made it so that my
compose file included that after the
fact so that I can do a compose up and
actually have data locally and give that
to other devs so we can all work on the
code together right and so I call that
compose app developer love because it's
one of my favorite things because we
work with lots of different teams and
it's painful so a couple things that I
would show you on that I have that
already running actually over here so
this is that snap board application and
it's got a web app which was the thing
that I did the add docker file which
you've already seen okay and what you'll
see in here is that there are some
changes to the docker file instead of
showing the service Mon entry point
which you would normally see for the
docker file for iis it actually shows
this powershell bootstrap entry point
I'm going to explain that in a few
seconds after I run this but I just want
to point out that this is because of the
previous tooling and there are some new
improvements now coming that will allow
environment variables to work with I is
in your legacy app containers without
having to do this special bootstrapping
so what this was enabling is for me to
take any environment variable overrides
and in the bootstrap it says go and put
those in the machine level of the
container
obviously assuming we're not dealing
with sharing and secrets across
container
multi container apps and not that and
you know then we start service mine
so it was basically a hook to work
around something that was
available and the new container or image
that they've given us actually supports
this out of the box so just to point
that out it supports it out of the box
for everybody but us because it just
turns out that we're using a complex
connection not connection string but a
URL that needs to be encoded and that
seems to be one bug they still have in
this new fix so I still need to use the
bootstrap PS for this example but most
everybody wouldn't have to so again this
is about environment variables how do
they work when I do a legacy app
migration I added the docker support it
gave me the docker file it gave me the
composed project
it gave me out-of-the-box something that
would start with service monitor and I
could have just put environment
variables in my compose file and it
should have worked but since it didn't I
hooked it with the bootstrap so all
that's oh this is already running so
that might be part of it or I did it who
won that bet I just want to know
somebody was betting against me I know
it I forgot to go to windows tap it I
almost had a perfect oh okay maybe that
was funnier in my head I find it really
amusing personally okay so that's the
kind of error you get when you forget to
switch back so let's do that again
okay okay so what that's going to do is
run the sequel image as a container it's
going to run the snap board app it's
going to map the environment variables
which we're basically indicating which
storage account in Azure do I need to go
to to get my images that will display in
the UI and so I'm not going to show you
things breaking and not working but you
know you can I proven I can be trusted I
think so it will just launch and and
work and we'll see something like this
right so we'll basically have images
being shown in the snap board and you
know this is all stored in the
database that was launched so and this
will go in debug mode when it gets there
but in the meantime I'm gonna keep going
so a few things to be aware I've already
mentioned oops that's just okay a few
things to be aware of the new docker
compose 3 no longer lets you put
conditions that check for the health so
I was previously checking that the
sequel server container was healthy
before snap board ran so when you do
multi container deployments or compose
up so you don't need that condition
anymore so now the way it works is you
just put MS sequel and by default in a
future release of compose coming soon it
will check for health for you so you
won't have to put you know as long as
you have a health endpoint in your
sequel docker file it will respect that
right now it doesn't do it automatically
so we're in this limbo period where they
don't support conditions anymore so
you'd have to write a little custom
thing for that I've given you a
reference for this in the slides so that
you'll be able to come back to and take
a look ok the other thing is there's a
couple of fancy things in that sample
like DNS caching seems to be an issue
with Windows again there's a bunch of
networking improvements that are coming
really soon so things like DNS caching
that might get you where containers
aren't communicating well it's gonna be
you know shortly not a problem any
longer so some of these you know fixes
that have references that are well-known
and documented on github will no longer
be relevant the entry point bootstrap I
already talked about which is the edge
cases around some when when the
environment variables don't map and then
lastly let's talk CI CD for a sec so
I've been doing these things locally
right I'm a developer I got Visual
Studio I build images I run them as
containers I test etc I probably have
some logs I don't you know obviously at
some point I have to push these images
somewhere in order for me to be able to
see them deploy to the cloud or to my
container
platform and so the way we do that
obviously can have many options I can
command line push to a docker hub I
could command line push to an azure
registry or I can do CI CD or the CI
part of CI CD and actually have my check
in or my commits to get repo turn into
an image which is a really nice way to
set it up quickly so we have all that
you know easily working with T at V STS
so for example if I commit or check-in
to get our TFS connected to my VSDs
account then it will actually go ahead
and pull the latest code build the image
push that image and not really sure why
this is I want that to go away but I
can't seem to make it there we go okay
it will push that image to whatever
registry I've configured which in my
case is going to be an azure registry
called Michelle busto the tags will be
tags relevant to the registry that's a
bigger topic but you know to push to a
register you have to tag it accordingly
so it can be found and pulled by the
container platform or by you when you
want to run it so now I've got this
immutable image that can traverse
between dev tests UAT and staging and
production right so I'm not going to
touch it again only change environment
variables that's the vision so the
vision is that with CI CD you know your
deployment environment wate
or UI T which might also say prod if I
fix the slide would pull from the
correct tag that would indicate this is
the version we want right now and that
would go across all of your you know
images that are being deployed to the
container platform it could be as simple
as you know just VM that pulls in hosts
or it could be a container platform
that's managing many hundreds of images
and containers so the idea again behind
that is that I should be able to just
check in and I actually have something
right here that works I say that before
I'd Emily cuz sometimes things do work
and I'm gonna go into my ping controller
and I'm gonna say I've got this
controller just has an endpoint I say
paying it says pong but I'm just going
to say
and II see Sydney my demo worked and
then I'm gonna right-click and commit
and I'm gonna take that one file so I
don't need all these guys just this guy
and we'll go ahead and stage that and
scroll up to the top and we'll say
updated during demo it doesn't really
matter if I spelled that right but there
we go
and then we'll go ahead and sink and at
some point this is going to be doing an
update but if I head over to here I
should be able to see that this will
have Q to build so I have checked in or
committed and this should kick off a new
build at some point so this is my last
build was 275 let's let that think for
two seconds and when we're going to go
quickly over to Azure and show the
repository this is my Azure repository
the last one checked in was 72 to 75 and
if I head over here at some point
refresh it's going to show that it's
done or did I push that is the question
right
did I push I'm gonna go back over here
you might have to push to get that
results I hear that's necessary okay it
just pushed so that means this guy is 2
7-6 in progress so it's going to go
ahead and I have this build definition
here that indicates which repository to
go to and all that there's a lot of ways
to configure this but it's just to give
you the example that there are some
really easy ways to get your images
built quickly and get them pushed over
to whatever your repo is so that people
can use them right away in your
environment so this will go ahead and do
its build and when it's done we're going
to end up with another image over here
and that is that so what do we talk
about we talked about docker tools for
Studio 2017 that the preview is now
actually live and that I very safely
chose to demo between the two of those
we have Linux and Windows support we
have dotnet framework and a core support
you get an f5 debugging experience for
both now you get command-line experience
if needed and I told you why I like that
multi container build run so that's
another thing that's good to do not only
for your source but other things that
you need to run against like data
backends and things like that we can
integrate with VST s and build CI CD
pipelines I just showed you the
beginning of that with CI and at the end
of the day it all works on your machine
and hopefully everywhere else as well
and that's all I have to tell you today
so thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>