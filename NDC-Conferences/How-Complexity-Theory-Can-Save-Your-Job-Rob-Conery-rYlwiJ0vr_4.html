<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How Complexity Theory Can Save Your Job - Rob Conery | Coder Coacher - Coaching Coders</title><meta content="How Complexity Theory Can Save Your Job - Rob Conery - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How Complexity Theory Can Save Your Job - Rob Conery</b></h2><h5 class="post__date">2017-02-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rYlwiJ0vr_4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I think it's about time to start let's
see you in it that's right I'm right
about that thank you for coming
5:40 in the afternoon end of the day of
the conference the perfect time to talk
about complexity theory don't you think
I think so I think so well hopefully I
made this somewhat entertaining this is
my story hopefully it's going to be a
fun story about getting fired which is
always fun me completely making a fool
out of myself and hopefully you not it's
the point of the talk I want to point
out that complexity theory what I'm
talking about
is complex surprise it's it's kind of a
hard thing to understand it's taken me
the last year-and-a-half to even have
any kind of grasp of it it's a very deep
topic if you hear me say anything wrong
please come up later tell me if you
follow me on Twitter I'll put on Twitter
if I get anything wrong and one of you
people pointed out hopefully you know
about complexity 30 to a degree as I
said I've been researching it the last
year and a half I am NOT an expert so
I'm not up here as Professor Connery
explaining complexity theory all this is
me researching I want to make that
perfectly clear this is just the results
of my research so why did I do any kind
of research um well I I have a
self-taught programmer and so over the
last year and a half I decided that I
wanted to fill the holes in my knowledge
I wanted to be able to have a
intelligent conversation with just about
anybody here in the room who's smarter
than me no doubt and I don't know so
much and so I decided to start
investigating and that's what I did over
the last year and a half and I thought
after a while this would be kind of fun
I'll blog it now a lot of people when
you tell them that they think oh you're
a big egotist you know you're going to
just write a blog so you get like get
famous like no the act of writing a blog
post is a commitment you are committed
to telling people what you think so
that's going to drive you to research it
and know it more and then someone
suggested we should write a book like
charge money for this you kidding me I
don't well actually that's a really good
idea because that pushes you even harder
to do it right
that's I want you to know that I didn't
take any of this casually but the big
you might be wondering but what actually
started all this and what started this
whole process is me getting fired in
2009 and not knowing why and I lost a
job I did I lost a job because I tried
to tackle a problem that I couldn't
solve and I don't know if anyone here
has ever been faced with that where you
literally come up against the wall and
you have to tell your client or your
boss I couldn't solve it so that was me
in 2009 and it exposed me as a major
impostor if you will it made me feel
really horrible because what I ended up
coming up face first and I just went
right into complexity theory I didn't
know what I was doing the time and I
didn't realize that I was facing a
problem that was a classic problem and I
shouldn't have been trying to solve it
so this last year and a half as I
mentioned I have come right up against P
and NP and all those fun topics I want
to mention I got to give a shout out to
my slide designers I am a horrible
artist I tried my best some of the
slides are by me but most from about my
kids I actually paid them money to do my
slides and they think that's quite
exciting so also you're going to see
some other pictures in these slides and
they're all public domain I wanted to
point that out public domain or free to
use so let's start the story shall we
once upon a time this is me as a
developer at least this is how I look at
myself back then that is actually me by
the way um I had no idea what I was
doing but that's kind of fun when you
first start out you don't know what
you're doing it's a constant process of
discovery and excitement whether let's
do this so this is about the time of the
second or the first comm bubble and my
main field was database work and I
didn't know anything about analytics but
I got hired by an analytics company so I
started working for them and my boss
came up to me one day and he gave me a
very special project and he said I want
to see a query just like Amazon's bought
together so if you think about an
e-commerce system we have products and
they look at a product page and then
they want to see related products that
other people have bought or you would
see that with your good Amazon so if
you're buying a coffee maker then you'll
see filters people also bought filters
right that's a pretty powerful query so
I think sure why not
that was always my answer to everything
I could figure it out
books I've got the Internet I've got
Google and I also have failure and
that's exactly what happened I could not
do this query and it perplexed me but I
thought it's got to be away right now if
you think about this how would you do
this you maybe some of you have written
this before but you have products and
you have a table of let's say a hundred
thousand orders and you have to find the
products that were bought the most with
Product X so what kind of query would
you write that's gray one query two is I
need you to mine the database and buy
the products that were bought the most
together how complex is that do you know
if you have a word for it do you know if
it's a classic problem you should never
try also would you even try that the
next question so at the time I worked
with my handsome friend cavae
and we worked into analytics company
together and I promised him I put his
face on the slide just kidding
he was a Harvard MBA is a Harvard
Harvard MBA UC Berkeley Graduate very
smart man when the smartest men I know
knows his statistics cold and so I sat
down with him one day and I said you
know cava I have a really tough query I
need the writing here's the deal it's
just like Amazon and without skipping a
beat he says oh yeah that's a co-current
query I'm like yes it's got a name and
this is important when things have names
they solidify themselves conceptually in
your head you can tie a word to a thing
and there's a lot of people that believe
that you don't know that concept until
you have a word for it that the two are
actually tied together in your brain
that's a whole other topic for me I'm
just jumping up and down yeah it's a
thing and let's do it so he knows sequel
copy no sequel really well and he also
knows spreadsheets
I know sequel I know spreadsheets there
is the structure of your query so I have
orders and order items join together two
orders the quarter items with the order
ID there's a couple ways you can do this
but if you're doing in pure sequel this
is the thing you want to do what I'm not
showing you is the inequality join that
also has to go in there it is a circular
nightmare query it's pretty fun we got
it to work it which is mean
unfortunately when you ran it over the
whole sample set it crashed the server
and it I think it ran for 48 hours
before it died and it's just not a query
that
supposed to run in the database which is
fine because thinking one night I said I
can use an intermediate table that's
what I called it
so I just be normalised a table and I
called it sales relationships and what
I'm going to do is I'm going to just
build this using some code so from ID is
the target product to ID is the other
product and then I just go and check the
database and into increment the sales
count so if I'm writing this in code
which I did in the hotel room the other
day because I was bored I don't know I
just decided to do it because I wanted
to show you what it would look like in
code and this is what I ended up doing I
didn't use sequel I used code I know
this is a little bit small I'm gonna
zoom in on in a second but this is the
whole routine to generate that to that
sales table so over 100,000 records I
can build that table with this let's
break it down so I'm using the Chinook's
sample database I don't know if you've
ever heard of this thing it's just
albums and records and sales so it can
be any sample data set we were actually
doing something completely different had
nothing to do with e-commerce what we
still have these products we are these
records we needed to relate so we can
just go with this sample data the first
thing you do is you pull out all the
products or the albums in the database
and then you're going to start looping
over it and they're going to run a
secondary query for each product and
that secondary query is going to go over
the database and pull out all the orders
where that original product was involved
yeah lots of fun and then what you're
going to do at that point is you're
going to look and see if a relationship
exists yes increment a counter no don't
this is not a terribly exciting routine
until you see this
that is called success and I when I when
I got this to run it took about two
hours at the time and this is again 2009
timeframe I got it to work
and so this is randomized data I
randomized some data just to show you so
that these relationships might not make
sense but on a real data set they do so
for instance coincidentally we have Guns
and Roses at the top sold as Metallica
and a sales count of 20 what does that
tell you what does that tell your boss
about your sales it says 1 you got a lot
of metalheads right in the end and they
loved they loved the old stuff
that's daddy's intelligence that's
actionable intelligence and man oh man
was my boss happy about this
I delivered and not only not you can
create this table real time and so I
would just run that routine every night
clear this table real time we had a win
it was radical and I felt quite happy
because I didn't know what I was doing I
literally did not know what I was doing
and that can be good and it can be
dangerous because here's my thing my
thing is if failure is the best possible
teacher
I love failure and I try and be really
open about failing as much as I can
because man you learn the heart of the
harder you fail the better you learn the
opposite of that is true as well
success can be the worst teacher if you
just are accidentally successful doing
something like I just did it makes you
think that you understand it and that is
a disaster because it kind of inflates
your a little bit you start to think
like whoa I know analytics and that's
just not the case I felt really really
excited but I was not
that's me by the way that's that's kind
of how I felt really can
seventeen-year-old conceited Punk you
can't really know I know I'm looking out
this crowd you guys must have done
something like this been successful at
it but yeah like I got this wired I can
do have sharp sorry I have to do an F
sharp call it every single talk I do but
the reality is something different this
is me crushing a puppy thinking I know
everything about dogs
I loved this dog and I could tell you
anything about puppies and dogs and I
was a kid but this is the reality of
where I was at you know you might be
thinking well you solved the problem
isn't it isn't that kind of what we're
here for you solve the problem what's
the problem let's talk about the problem
see if we can play a game called spots
problem and I've kind of highlighted it
for you I just don't want to make it too
you know complex so yeah here's the deal
I've got a nested for loop that's
running queries now that's I'm running
this on the side server this is the only
routine running so this works fine for
us a small size execution so it's no big
deal I didn't have to worry about
crushing the server now let me ask you
this what if my boss came to me and said
well how can we relate three products
instead of two
does anybody know how much more complex
that problem is if you had to guess all
right it would be called factorial
complexity and that is something that
will result in bad things so in order to
have three related products I have to
run one two three nested for-loops
which means disaster for related
products five related products six you
keep going keep nesting those for loops
that's pretty complex don't you think
that's a pretty complex routine keep
this in the back your mind factorial
complexity something that you should be
able to recognize okay let's fast
forward to 2009 that's me again this is
web 2.0 time frame rails is kind of a
hotness lots of sites built with pastel
colors and big fonts so I am now just
kind of getting back into web
development I've moved away from
database work and I am a one-man
wrecking crew is the way I contact first
myself
so anyway I'm building sites and I'm
having a good time one day I get a I get
a call from a friend says hey can you
build us a rail site when I say yeah I
like rails I've used it on my own I'm
starting to build a business with it and
but yeah I'd love to have a contract as
long as you know that I'm new at this
and I said well that's actually not why
we hired we want to hire you we heard
you good with analytics and I should Oh
as a matter of fact well no the truth is
I told the truth like I've done it
before I worked an analytics analytics
company I did some cool queries and I
built the database and all that and so
on and then I can I can probably do it
what's your problem and and they say
well we're building this website and
it's basically I'm going to call this
problem the board Millennial problem
it's for college freshmen or first years
I guess is what you call them over here
but freshmen over there they're brand
new to a university and they show up and
they don't have any friends they don't
know where to go what to do and so this
startup decided hey well let's get these
people together we're going to help them
find each other we're going to match
them up and not only that we're going to
match these groups of people to events
in places that they want to go - sounds
like fun matching hooray and at the time
I actually said wait a minute I am
building a Ruby on Rails
sigh and you just hired me to do that um
we're not talking about anything else
right and they said well actually you're
building the algorithm I kind of pushed
back and he said I don't know how to do
it but then I thought wait a minute I've
done something like this before I can do
it I can make this happen
stupid decision so here's the way this
breaks down I am given a profile of some
students when you sign up you have to
check some boxes and tell me about
yourself and so on and then I have to
match you up with other people so not
only do I have to match you up I also
have to have some kind of scoring on
that match so for instance you might
casually not get along with somebody you
might really get along with somebody you
might hate them you might not care so
there's that weighting and I looked at
dad I'm like hey I remember a term
reading about this on ventureBeat or
TechCrunch or whatever the heck it was
at the time the social graph Facebook
did it right and they're using PHP and
I'm using rails so I should be able to
do this because somehow rails can do it
over PHP all right a little bit arrogant
a little bit arrogant but come on stay
with me now you guys have felt this
before you've got a rad platform that
you're using you've got a cool database
as you're all this other whatnot you
could be able to you should be able to
solve any problem so does anybody know
the name of the problem that I was
trying to solve just by my descriptions
anybody familiar with classics problems
ok it's called click click click on
Australia to show this it's basically
using a social graph or developing a
social graph applying some kind of logic
to it and creating subsets of graphs
within a greater graph does anybody know
the other definition is cleek it's
called np-hard and np-hard is the
classification in complexity terms of
what this means does anybody know what
np-hard means anyone empty hard means
that you get fired if you try and
implement np-hard this is fun I was
expecting somebody yelled out again I'd
be hard to read man really I really want
this to soak in I kind of
tongue-in-cheek I did I lost my job
because I could not identify click and
and it's weird
I would think now love I should have but
back dammit
care about that problem who cares about
that problem I thought I could solve it
that's the thing and I want that to soak
in it's not like I didn't know it in
terms of like how to implement it I
didn't know what it was I couldn't
recognize it and that's why that's my
that's what I'm trying to say because my
client blamed me of course because I had
to save them I don't know how to solve
your problem and they said why and I had
no words for it I just said it's too
hard and they said you're an idiot I
thought you were good fired me went
through a series of other developers
went out of business if I had words to
explain what the problem was and why it
was so hard my money saved a lot of
people at a time a lot of money that's
the truth okay so let's fast forward a
few years and every every year so I get
together with some college friends
coffee happens to be one of my college
friends and I did not go to Harvard no I
did not go to Berkeley I just happen to
know him i sat on the corner where he
used to walk by and we could have some
money not really
well maybe okay a little bit so anyway
every summer we go we go on this little
like guy trip we go and go fishing and
hang out and do stuff and so I sat with
him and this is I think three or four
years ago I said hey you know what I had
this weird problem once and I had to do
and I described it to him social graph
subsets of social things and everything
and his reaction was pretty pretty
appropriate that's kind of flying that
doesn't look like him see I was like see
see no no resisting the ball joke John
you know I am you know okay anyway so he
says to me if you're a complexity theory
I'm like yeah no no I have not I have
not heard about this so he starts to
explain it to me and it turns out
there's this thing called complexity
theory and he's going through all these
classifications and tags and numbers and
data that my eyes start to cross this is
tough stuff right but he starts to
explain it to me in a way that is sort
of helpful and he says basically think
of it this way there's all these buckets
in terms but the bottom three here P X
and our our the thing is this thing you
should kind of get to know basically
means easy hard impossible like
that's math okay he's like okay let's
step into it so you starts to explain
this to me because imagine you're trying
to do something simple you're trying to
sort a list using quicksort like I don't
know a quicksort is but okay it turns
out quicksort an algorithm to sort of
list so here we have an array you put a
partition in there and you sort a list
in places it's an interesting algorithm
and he said if you if you had ten items
like this and then you bumped it to 100
how much harder would that be to do not
hard at all how much longer would that
take and I'd say no another millisecond
okay how about a million I might take
another ten milliseconds well how about
ten million well I don't know 100
milliseconds and he's right so 1x 10x
100x think about time like okay all
right I got this I got this and because
you have a graph right you tried to
build a graph now you have a graph and
you want to run some calculations over
that graph to find the shortest distance
from one node s to all the other ones
ABCDE
and they said okay Nene but there's an
algorithm called Dijkstra's shortest
path and I said whatever okay so what
because well you can actually run that
over a graph and calculate the shortest
distance in a reasonable amount of time
it would take you maybe a half a
millisecond to calculate that because it
just cycles over the graphs and it works
and you said if you add 100 nodes it
will still work maybe an extra
millisecond if you add a million nodes
then it starts to slow down a little bit
but it's maybe a hundred times ten
thousand times and there's that thing
again 10x 100x 5x whatever we have an
equation now to think about the
complexity of what we're doing because
that's the way if you ever know if you
know anything that Big O notation talks
about complexity in terms of math so we
talk about complexity in terms of math
it could be as simple as saying oh
that's about ten times as hard or that's
a squaring operation I'm smart basically
what that means is you have polynomial
complexity it's a polynomial equation
what's a polynomial equation this is
where you get to remember maths it's
that right there anything that has two x
or two x plus three times whatever or
something squared something cubed
whatever this is a polynomial equation
if you can describe the complexity of
something using terms like five times
ten times whatever
polynomial
what does that mean well P just happens
to be the term or that's the letter that
starts the word polynomial so we call it
P time
that's what mathematicians would say if
we're talking about complexity and this
is the way mathematicians think about
complexity in terms of complexity versus
time or how much time given the inputs
and the change and so it's say oh that's
P time that's a key time thing you're
trying to do so let's think about chess
just as something different so copy is
explaining to me I'm a horrible chess
player by the way he says what for you
and I are playing chess and I asked you
to ride an app that you could snap a
picture of that chess board and have
that app tell you how to win the game
how hard do you think that would be so
here's the fun thing is that there are
more electrons in the universe than I'm
sorry there's more moves in chess and
there are electrons in the universe a
lot of chess fans think it's actually
infinite it's not it's finite based on
mass doesn't matter but it might as well
be infinite because there are a ton of
moves now if we're trying to figure out
how to optimize a chess game yeah that's
really hard to do now think about the
complexity of this you and I are playing
a chess game and I say Shazam and I make
that chess board go to 10 by 10 instead
of 8 by 8 how much harder did that chess
game become became exponentially harder
so when you think about complexity in
this way it's not sorting an array
you're actually getting into something
that is mind-blowing ly difficult in
fact some of these problems when when
they start to scale the time frames on
this include the Sun blowing up a few
times and as opposed to like where we
you and I are concerned in pea time
stuff which is you know I know gosh it
took five milliseconds to soy DeRay I'm
really bummed this would be like Sun
blowing up ten times over so this is
this is really important so anyways
Kobe's explain it to me I'm like I get
it exponentially hard okay I think I'm
understanding this because well the
problem that you are trying to solve
there is in the same class it's not as
hard as chess but it's in the same
complexity class it's called XP XP or
just exponential time okay that really
makes sense and he goes it's also
np-hard and I said there's that word
again what the hell is empty hard
and he starts to explain it to me and my
eyes just cause like God can just
somebody make this simple and so he
tried to but we're up sipping scotch in
the hills and like I give up so I'm
happy that I now have a word and a
problem that I can tie my failure to
which i think is important unfortunately
I don't have a way of solving it and I
don't quite know what it even means so
over this last year and a half that's
what I dedicated my life to is to trying
to figure this out well I shouldn't say
dedicated my life made my career alright
so I'm going to do my best to see if I
can explain this to you and if I don't
feel free to throw things at John
Galloway over there and then he'll talk
to me about this thank you okay
so when the talk is done you guys want
to go do something I think we should
okay what should we do so how do we
solve this problem so what would likely
happen in a group I know all of you
faces where you're sitting in a group
and someone says anybody wanna go do
something and everyone looks at each
other do so it turns out that this
problem is fairly complex to solve right
how do we find a place we all want to go
to the best place and that's going to be
the key thing where if we had some
choices or whatever what is the best
place that we can go to there's a number
of ways to solve this let's step through
this how do we solve this problem number
one Scott Hanselman could be sitting
here in the front row and he's not thank
God but he's sitting here in the front
row and he could just stand up and said
we're going to go to Chipotle because
Chipotle has the best everything and I
want a Diet Coke so any turnaround to
you guys and say let's go to Chipotle
and I would say yeah then turns out
Kathleen Dollard is sitting over there
the other side she's not either but she
might say you know what I am fancying
pizza I want to go have some pizza let's
go to Neal's Yard and we need some
cheese while we're up there would not be
fine and so we take a few more few more
ideas from people then we do a vote and
we go with a was the biggest we go with
the biggest the biggest vote getter I
guess you could say how complex is that
the only one I have a guess
not complex so if you know big on
notation this is order n order n just
means we had two choices we had to pick
one it's as hard as many choices that we
have if if you're familiar with Google
and PageRank this is how PageRank
actually works this how PageRank solves
complex problems what page range rank
does is it uses the authority model so
they suck in every single page off the
internet and they look at the incoming
and outgoing links of each page and then
they they basically increment a counter
so let's say that middle site or the red
ball right there might be handsome in
sight and that little site and see down
there that you can't see it would be
mine right so if you're searching and a
keyword comes up and it hits handsome in
site it's ranked above me because he's
got more bound links he's got more
Authority he stands up in this room and
says we're going to Chipotle and ever he
goes oh my god implement basically we're
going to do what he says that is AP time
solution because we're just searching
over Authority and that's easy did I
solve my problem of finding the optimal
place to go no no I did not
that is not an optimal solution but it's
close that is key and so we need to
think about this we didn't quite get the
optimal we can't prove it's optimal we
got really close how can we get optimal
let's talk about this so Kathleen
realizes like we're going to go to
Chipotle si do something and so she says
how about we all just just decide as a
group what we're going to do where we're
going to go and so we start making we
break into conversation and we kind of
sit there and icon to you you talk to me
we talk to each other and we're coming
up with ideas and we're breaking into
little subgroups and I really like
someone's idea so that bond is a little
bit strong yes I like that one and then
someone else says we should go somewhere
over here and like no I don't want to do
that and so the conversation starts to
grow and take on on life of its own and
our group momentum is slowing things
down and then it before we know it it's
going to turn into a ridiculous mess
come on
see a well-rehearsed slide right here by
the way what we're trying to do and this
is important this is what that would
look like I think we are trying to and
this is important we're trying to
optimize the combination of us we're not
trying to optimize individuals we're
trying to optimize our group as a
combination what is that we're all
connected in this so okay we understand
each other we're trying to optimize all
that it turns out this problem has a
name which is if you switch those around
it's called a combinatorial optimization
you just trying to maximize groups of
things that have a relationship
this is exponentially hard so that's
fine except we know that now we know
that we're trying to optimize complex
things that gives us a new word that we
now understand so when the group looks
at each other in the zone all you want
to do what you want to do think
combinatorial optimization words are
important okay it sounds kind of scary
exponential time stuff is really complex
but that's where the fun is
and this is where we start getting into
the head banding kind of thing we now
know we have simple problems we have
hard problems we have impossible
problems exponential problems kind of go
back and forth between right after
simple and then right before impossible
and here is a modified graph there's in
the red up there is the new term I'm
going to throw it you called NP I'm
going to define what NP means in just a
second but I do want you to keep in mind
that the fun we get paid for every day
what you and I work on every day are
problems that are in NP and you don't
know that yet maybe maybe some of you do
but hopefully you will by the time we're
done working in P time problems sucks I
mean that would be like me saying so can
you make me sorting algorithm please
clutch use the framework so NP is where
the fun is as I mentioned these problems
are a little bit hard to put your finger
on and I'm going to warn you that you're
going to want to throw things at me
right now just go with me in order to
understand NP we have to believe in this
thing called Roth's lucky algorithm
Rob's lucky algorithm is something a
little bit different than a normal
rhythm here's the way it works we have a
set of decisions right here I'm going to
start with the square we're going to go
through and just we have to decide on
whatever it is just pretend this is a
decision graph yes no yes no yes no
success yes no yes no fail with my lucky
algorithm I'm just going to tell you
what the answer is the first time every
time and I will be right so let that
sink in I know that sounds crazy as
developers we don't want to think this
way as developers when we are working
with these when we are working with
these systems we want decisions like
loops we want to build a decision out of
another decision we want to know what
came before and what came after in other
words when we put data into a system
like this we have to be able to
reproduce it there's a name for this and
it's called deterministic as you might
or might not know this is deterministic
system where did it come from I don't
know let's determine it by looking at
the code there's always a way to figure
out how you got there and from where
came a non-deterministic system is a
system that is just essentially magic I
will just tell you how does this work or
how this works now you might be saying
thinking so okay it sounds a little bit
magical but if you ask Luke how he blew
up the Death Star which I'm sure all of
you have at some point he wouldn't be
able to tell you other than I just
relied on the force it's kind of same
thing he wouldn't be able to tell you
how he did it he wouldnt be able to tell
you what mechanism fired his hands and
fired the gun and Boom Bang you wouldn't
tell you how that little circle thing
sound magical does it sound magical now
let me ask you a question does this have
any effect on you looking at this
picture my little friend you want to
come up here and pet my little friend
why would this have an effect on you I
mean did your parents tell you and say
this is a hornet don't touch it
did you ever get stung by one I know a
lot of people have but they tried to run
away first and they screen their head
off if I showed you a picture of a
spider maybe a height you would have a
reaction to this can I ask you how you
have that reaction no I mean you might
be it'll tell me oh of course
evolutionary selection and it's race
memory and instinct and I was born to do
those is how we survive okay sure that's
fine it's a great theory not provable
non-deterministic that's my point
non-determinism exists believe it or not
it's kind of confounding to think about
so it sounds magical like wait a minute
but there are actually computer computer
languages that you can use to program
non-deterministically Prolog is one of
them and this looks kind of crunchy but
basically what this is right here is a
function two functions with the exact
same signature and they basically handle
two different conditions it's not
pattern matching basically the deal is
that these functions get called at run
time determined by the machine not use
the programmer that's a key thing to
understand and even has a failover
backtracking so if it tries one function
call and it doesn't work it can go back
and try the other one why am i bringing
this up because if we can solve problems
using the force then really complex
things become easy right really hard
problems exponentially complex problems
like super crazy that group decisions
become easy so that has a special term
to mathematicians because they're very
interested in this
that's called non-deterministic
polynomial time so remember polynomial
time P just means easy it we have a set
of problems that become easy if we can
use magic quote me on that okay so let's
think about this so if we if we could
use my lucky algorithm to decide where
we're going to go after this all
Kathleen has to do is to go through a
list and say all right I'm going to use
Rob's algorithm should we go to Chipotle
No Piccadilly Circus no should go to a
hotel Pub Bing this right answer let's
go we just solved that problem which is
interesting we're playing a game at
Catan later on and if you think about
Catan as a mathematician right Catan is
a set of decisions that you're trying to
optimize to win the game so at any point
in Catan you could use my lucky
algorithm and say should I do this
should we do the shoot is it digital you
can go through the list you can iterate
over the list and Bing the right answer
will show up boom you win Catan I win
Catan you and your group are kicking off
a brand new project you've got a lot of
decisions to make and using that word
decisions over and over you've got a lot
of decisions to make as a group what
technology what dates for the four
what team members are going to tackle
what so you can sit around we're going
to talk about it might as well be
talking about where I'm going to go
later to have a beer at the pub or
whatever you want to drink if we had my
lucky algorithm I could just stand in
the middle of the room we can cut this
meeting short and get out of there in
just a few minutes because I could just
tell you what you're going to do so I
know that sounds crazy - stay with me
there's an explanation knowledge that's
what NP is exponentially complex
problems solved easily well lucky guess
I know I'm simplifying that term we're
going to get into some more detail right
now let's break it down because there's
more to NP in factors to subclasses a
there's a lot more to it but there's two
subclasses that you really need to know
the first one is decision problems and
you keep hearing these same decisions
because that's really at the core of NP
this notion of decision problems what a
decision problem simply is is any kind
of any kind of thing that you want
answered with a yes or no question or
true/false answer so we can loop over
all kinds of complex stuff and then
based on the answers in that loop we can
decide on some really complex stuff you
can think about it in programming terms
as what values for X and y it will turn
true now it's programmers using a
deterministic system you would have to
plug in all values for X and y to see
what the answer is to this
that's deterministic non-deterministic
you just know X&amp;amp;Y need to be true or
false the second kind of problems that
we have you keep hearing me saying
optimization no optimization is being
maxim didn't mean most it could also
mean least whatever you're trying to
find an end you're trying to find okay
this is the stuff I'm interested in my
board Millennial problem is an
optimization problem we know it's a
combinatorial optimization problem so we
now have two types of problems that we
kind of keep talking about over and over
again
so at NP we have two buckets that we
want to think about these things I'm
sure you've heard the term np-complete
so a problem it's a decision problem it
probably has a yes or no answer that you
know is complex is np-complete can
problem it's an optimization problem
oh there's other ones too that's what
the asterisk is down there
tend to be np-hard or our np-hard I can
make it I can go ahead and claim that
stealing here is now the full definition
of np-complete to see you don't think
I'm waving my arms making up things
np-complete problems are can't believe
using bullet points exponential time
problems so we know it's exponentially
complex exponential time P time problems
in other words easy if we're using a
lucky guess and then also the most
important is it's verifiable in P time
what does that mean it means you know
that that is that is the correct answer
so if I'm looking at a big old set of be
looking at a big old set of decisions
and I apply the lucky on rhythm and I
get true back that is a valid a
validated answer that is verified that
is proven and P hard problems on the
other hand are not verifiable in P time
why is that because as a group even if
we're sitting in here trying to do the
combinatorial optimization of what's
going to be the best possible pub
Kathleen stands up and says let's go
okay we can go but how do we know that
that's the right answer or the only way
to know is to do each one of the things
go through every single iteration every
possible decision to verify you don't
have a position on these things and then
go and actually do it so that's that
just puts the complexity right back into
exponential time so this is the thing
about np-hard problems they're at least
as hard as any other problem P ok so we
know that in other words it can't be a
simple problem like sorting and you
can't expect that to be and be hard you
can't just make that claim it actually
has to be in NP this is another tricky
one this is where people used to blur
their eyes any other problem in NP can
be reduced to it talk about that in just
a second just you know you can reduce a
problem by just shaping it rewording it
living something is around you can you
can you can reduce one problem to
another NP and claim that simp yard the
final thing and this is what trips up a
lot of people it doesn't actually have
to be in NP in terms of classification
because NP hard is kind of a tag doesn't
mean that this is a classification for a
problem in fact there is a problem that
is literally impossible to solve
it's the halting problem if you've ever
heard about it it's a alan turing's
claim that you can't write a program
that will determine if another program
will stop or halt it's an impossible
problem to solve because it involves the
infinite recur
Loup it's empty hard why is it np-hard
because of reduction and this is the key
this is the key the key the key the key
the keys this whole big fat mess a
problem is np-hard if ever the problem
in NP can be reduced to it I can take
the halting problem just by saying will
a program halt that's a yes or no
question I get back yes or no I claim
it's np-hard because I can reduce that
to a decision problem if I can reduce it
to a decision problem this is important
if I can reduce it to a decision problem
its np-hard and I can make that claim if
it is a decision problem it's
np-complete you might be thinking okay
so what I'm going to build this a little
bit a little bit more here let's go back
to that if statement this is actually a
classic np-complete problem this is the
first np-complete problem that's in fact
this problem was defined by Lebanon cook
back in the 70s kind of started out the
whole complexity theory thing a big long
conditional statement like this has a
funky name it's called the boolean
satisfiability problem in other words if
I have a big long conditional statement
what values for x and y will return true
if I can have a decision problem I can
reduce so it's called fat I know it's
np-complete I can take that a step
further and see if I have an
optimization problem that I can then ask
in the form of a yes/no question that's
a reduction then I can say well that
must be np-hard the reduced problem is
now np-complete so what I know that was
something he liked ok goody we're doing
on this word dance we're doing this
algorithm dance why do we care about
this well number one the obvious thing
is my lucky algorithm doesn't exist
right I mean if it did one that'd be fun
because there were a whole bunch of
complex stuff gets solved we can cure
cancer there's a protein folding is a
bunch of heavy duty scientific problems
that can be solved if we did have this
in fact it is one of the most pressing
problems of science today is there a
lucky non-deterministic algorithm
because if there is then every problem
that's in NP that we've labeled becomes
P they all become
same P would equal NP and I'm sure
you've read about this heard about this
there's these crazy blog posts and I've
read them too and I've never understood
what that meant now I do so if we had a
non-deterministic algorithm and you
found it in this room you get a million
dollars because the kraid's to suit the
Millennial Institute has this millennial
problem millennium problem now a
millennial problem too no doubt they
have a millennium problem where you'll
get a million dollars if you can come up
with this which is pretty neat a lot of
people are looking into this they don't
think it's magic they think it's real if
you sit in a symposium some day and you
bring this problem up you'll get a lot
of people pounding the tables because a
lot of people don't believe it's real
it's interesting one of the things does
it exist and we just haven't found it
yet a lot of people would say that's a
really dumb question to ask if we
haven't found it then I don't know if it
exists and I would say look out the
window at the airplanes landing across
the way 200 years ago no way man today
just everyday things how I got here in
10 hours which is kind of ridiculous to
think about 200 years ago absolute
miracle so we kind of have to keep our
egos in check in terms of science so we
have a non-jew we don't have a
non-deterministic algorithm which means
that bad things can happen if you try
and solve np-hard problems
so this is where we get to turn the
corner a little bit because not in every
single case not always I know can't you
can't just be hard-nosed about it and
say if you try and solve an np-hard
problem you're going to get fired that's
not necessarily true it depends what
you're trying to do I got lucky when my
very first query my co-occurrence query
I got lucky because I only had to
optimize two things so the graph was
made of basically two things I didn't
have to do very much it was still a
factorial problem even this might be
doable even this I can sort of dabble in
NP if I want to as long as you keep it
small there's no there's no problem
shutting down your server it's actually
kind of doable this is the work that we
do every day and in computer science we
come up against these problems that are
in NP even a cleat problem we have an
approximation with google's pagerank and
we can
I'm sorry we have an approximate we have
some approximation algorithms that we
can use your click that actually make
little subsets in a larger graph it
works it's not perfect you might be
wondering why you're looking at a
picture of a rabbit understanding the
problems that you are asked to create or
I'm sorry yes those to understanding the
problems that you're asked to solve are
critical and it turns out there's a
whole list of these problems that you
might have heard of but they're all sort
of related now I want to step through
these right now to show you what I mean
your daughter says dad I want to rabbit
and if they are as long as you clean up
your room and she says no problem can
you help me I say sure and I go grab
some bins out of the garage and my wife
pokes her head in and says okay I need
as much space in the garage as possible
so you need to make sure you optimize
the packing of those bins I only want
the smallest amount of possible bins you
can you can panic can you guess the name
of that problem
it's called bin packing and it's a
classic math problem that people have
been researching and trying to figure
out an algorithm what's the easiest way
that you can take these items that are
related by size and squeeze them into
small possible volume there's another
related problem to bin packing is called
knapsack which is a fascinating one
again you have all these items you want
to pack into a single knapsack you want
to maximize the maximize value minimize
weight can you guess the complexity of
this problem you should because I just
use some key words optimization of a
relationship combinatorial optimization
it's empty hard of course you've all
heard of this one I hope you have cities
to visit your boss wants you to go
client inge which is a word I just
learned and you want to go visit some
people he says you make sure it's the
cheapest possible path that you can take
so we have these cities that are related
by this notion of cost once again we
have decisions to make based on related
items and we need to optimize that
relationship in order to have the lowest
cost traveling salesman problem which is
classic by the way hopefully when we're
done you're going to understand to see
you guys to start to understand the
slides it's kind of cool
so that's Traveling Salesman absolute
classic and you're sitting at work and
you're trying to do these things in your
head you can think of it
I'm going to optimize something I'm kind
of working on something that I can show
is a graph it's related has to make some
decisions
you're started with deal with complexity
though you're starting to speak in
complexity theory which is something
that is critical to me at least looking
back on my career I wish I would have
had those words I wish I would have had
those labels because I would have
avoided a mess okay it's not about
avoiding a mess it's also about
embracing a mess and making sense of it
because as computer programmers we try
and help people by delivering value to
help them make decisions to help them do
things in fact if you squint your eyes
really hard a computer program is
basically one giant decision tree it's a
huge huge conditional that's what it is
your computer program is np-complete
you're working on an np-hard problem
that's just what you're doing it depends
how you go about doing it what does that
mean turns out that we don't need to
solve these things perfectly you don't
need to solve them completely right we
don't need to make sure and prove that
we've done it we can have these things
that are close enough and these are
called heuristics and they're also
called approximation heuristic is a rule
of thumb it's generally what you do
approximation algorithms are things that
have guaranteed results you're not going
to have the perfect result but it's
going to get you within 10% 5% or
whatever so for instance Traveling
Salesman you can use what's called
nearest neighbor it's called a greedy
algorithm because what you do is you
traverse the graph and you do what's
optimal at that moment in time so let's
say I'm in London and I need to fly to
Munich and I also need to fly over to
Frankfurt and then I need to fly into
Oslo and a few other cities
so following nearest-neighbor what I
would do is I'd say what's the next
cheapest City and I go there and once I
get over there what's the next cheapest
city and I go there greedy because it's
right in front of me I do what it says
to do you can using that on average get
within 25 percent of best cost you not
only that now you do that is a way to
solve that problem for your boss as long
as your boss the client knows this all
these other algorithms and heuristics
apply to all the problems that I was
just talking about there are ways to
deal with these things
they're not going to be perfect but
they're going to be close enough
PageRank is not perfect it's close
enough if I see here in Google best pub
in Docklands is that we're back I can
tell it says to do this it's the Alps in
right and we'll just go there we'll
probably have a good time there are
genetic algorithms that you can use to
just go over again and again and again
and again a decision a decision set and
just work it just keep going over and
rely on a pattern to eventually up here
kind of like ruts in a road with a with
you ever seen those wagon wheel ruts and
milled West ring towns no maybe no no
genetic algorithms work that way they
use the idea of evolution so you run
over this this problem set repeatedly
and using Bernoulli's weak law of large
numbers which means a pattern will
eventually resolve like flipping coin
the distribution will come down 50-50
the more times you do it same kind of
deal with genetic algorithms and you can
actually solve some really complex stuff
like not getting stung by a bee as I
mentioned we work with n P every day we
cling to the side of it we kind of
dabble in it a little bit you don't go
too deeply if you didn't you try to
solve it perfectly you'd end up like me
and getting fired or if you could work
with an approximation and you know the
approximation exists or a reasonable
heuristic well maybe you can save your
job or maybe you can be the person to
come up with a non-deterministic
algorithm and get rich well I think it's
about time to use kathleen's good advice
I think that's it for me and this you
think it so difficult to understand the
stuff try writing about it speaking of
that's the book I wrote if you're
interested and you want to go take a
look at it stop at big machine dot IO if
you have any questions please come up
and that's it for me thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>