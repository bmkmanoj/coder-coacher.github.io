<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Web Apps can’t really do *that*, can they? - Steve Sanderson | Coder Coacher - Coaching Coders</title><meta content="Web Apps can’t really do *that*, can they? - Steve Sanderson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Web Apps can’t really do *that*, can they? - Steve Sanderson</b></h2><h5 class="post__date">2017-07-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MiLAE6HMr10" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello hello okay
great that works and we are finally
ready to go oh my god it says a good
number of you in here today that's great
well I hope you have enjoyed your day so
far and you'll have a good lunch which
has given you lots of energy to be full
of buzzy excitement for all the cool
stuff that we're going to do in this
talk so quickly introduce myself my name
is Steve and I work at Microsoft I am on
the asp net team so i do a whole bunch
of stuff related to SP net MVC mostly
but as well as that i'm really
interested in what's going on in the
world of javascript and what's view for
us as web developers so I'm guessing
that we've basically got a roomful of
web developers here no worries if you're
not but hands up if you write some sort
of client-side code today JavaScript or
typescript that's I think yeah the
considerable majority of you okay so if
you are like me then you are probably
interested in what new possibilities are
emerging for us as web developers and
what new cool things we're going to be
building into our apps over the next
year or so that we couldn't possibly
have done before now if you want to
learn about that sort of stuff one of
the best resources I think is available
is provided by all the different browser
makers so each different browser maker
has got a sort of service status or a
platform status web page that you can go
to I will give you a nice big list of
all the things that they're working on
and links to the specifications links to
discussions and things like that this
one here is Mozilla's one and that shows
you all the stuff they've been doing it
also tells you what the status of these
features in other browsers are that sort
of thing and of course there's also one
for Chrome this is chrome status com
that's nice because it shows you which
version each of the different features
is going to be shipping in and again it
gives you some indication of what level
of consensus there is for other browser
makers to ship each of those features as
well and finally of course we've got the
Microsoft edge one the edge platform
status page there and that shows you a
whole bunch of cool stuff that you're
going to be able to do soon as well such
as the very exciting ambient light
sensor API which means that your webpage
will be able to detect whether user is
in a dark room or a bright room while
they're using your page which is going
to be
great I have no idea what you will do
with that but I'm sure you'll come up
with something awesome
now as for where all this stuff comes
from where do these ideas originate and
where is the consensus actually built
what is the official source for all this
well you can go and have a look at the
w3.org page and they've got a very very
long list of all the standards that
they're working on specifying and you
can go from there to all the mailing
lists and you can get involved in the
discussions and so on there's a lot of
stuff then it takes a long time to wade
through so what I'm doing for you in
this talk is I've been through 900 or
something items on there and I've picked
out a few of the things that are
particularly interesting for us to talk
about things that I think is going to
make a noteworthy difference to the way
you build your application and hopefully
will be fun for you to see as well okay
so that's what we're going to do in this
talk we're going to go through four
particular feature areas now the first
two I'm going to quite a lot of detail
on and they're quite big and well-known
features so I think you'll probably have
heard of them although no problem if you
haven't I will hopefully be able to show
you some aspects of them that you have
not seen before so there should be some
new stuff in here for everyone this the
other two items three and four on their
list are quite small niche features that
I personally never heard of until a
couple of months ago probably a good
number of you want to fair to them as
well but they are pretty cool and
hopefully they'll give you some ideas of
stuff you can do as well okay so the
first item on our list that want us to
look about is service workers okay
that's quite a big and important feature
area ends up if you think you at least
vaguely aware of something about the
basic concept to service workers not
very many we're probably talking ten
twenty percent of people okay and how
many of you who have heard of it are
actually using it in production in some
way I'm looking for any hands no okay
maybe nobody alright well that's
reasonable because even though this
concept has been around for a couple of
years people have been talking about
this and building up to it it hasn't
really been feasible to actually use in
a real application until kind of now-ish
really because browser support for that
is just landing this year in the middle
of this year depending on which browser
you're talking about so what is the idea
of a service worker well
if we go right back to the very
beginning of programming on the web a
certain feature has remained constant
throughout all that time which is that
you can only run code when your page is
loaded in the browser your page is the
thing that delivers the JavaScript in
the first place and the browser will
stop you running it as soon as the user
moves away the serviceworker changes
that serviceworker allows you to define
some JavaScript that will register in
the browser and then the browser can
just run that code anytime it wants to
whether or not the user is even on your
page and that is what makes possible a
whole bunch of interesting new features
and the best-known one of these features
is the ability for your application to
run offline I'm going to show you some
demos of that in a second but there are
some other good features as well for
example if the user does stuff while
they're online then a service worker can
synchronize that back to your web server
as soon as the user gets a network
connection later even if they're not
still on your page you can also use this
to receive push notifications from your
server so normally if you want to send a
notification from your server with
something like WebSockets signal or
whatever it only works if the user is
there on your site but a push
notification can be sent to your
serviceworker whether or not the user is
on the page and finally coming in the
future the ability to run tasks that are
scheduled in the future none of the
browser's have implemented that one yet
but it's specified and should be coming
along soon so the best way to understand
that is of course to see it so let's
switch over to a demo and I'm going to
show you adding some cool serviceworker
best features to an application and the
application that we're going to add
these features to is this one it's kind
of a new site it's just a you can
imagine this has been like a social
network feed or it's what you feed or
something like that or you could think
of it as being something a bit more
business II like something that delivers
a list of jobs to your staff that they
have to do over time something like that
anyway it's some content that has to get
updated and there's not really anything
in this side just yet if we look at the
code for it you'll see it's just a bit
of plain static HTML nothing very clever
there we don't really even have any
script in this just yet I've got this
file page j/s but as you can see it's
not really doing anything
we just got an event handler that says
when the page is loaded we're going to
do something but I haven't done
yet so what we want to do is register a
serviceworker
in this browser and I can do that using
the serviceworker api a bit like this so
I'm saying navigator dot serviceworker I
would like you to register this
javascript file because the
serviceworker is a JavaScript file that
gets registered with the browser so that
is technically all we have to do the
remainder of this code we don't strictly
need but it's quite nice just to see
whether or not what we just did
succeeded or failed
ok I'll save that and now you're
probably wondering what is in the
serviceworker dot JS file well let me
show you now a serviceworker responds to
events that's the only thing it can do
the browser raises events when it wants
to your serviceworker responds to that
and at the moment i'm only responding to
this one event called install and as you
can probably guess the browser is going
to run that when the serviceworker is
installed into the browser as a couple
of other things here as well you're
probably wondering what is this self dot
import script well this is how you can
load one javascript file into another in
serviceworkers in a normal web
application you load JavaScript files
using script tags but of course you
can't use script tags in a serviceworker
because there are no tags
there's no document so obviously you
need a different way of loading scripts
and that's what this thing is doing up
here and then finally what is this Skip
waiting thing well with a service worker
you get control over how and when your
serviceworker is installed there are
various different ways you can do that
and this skip waiting is a way of saying
I just want to install it right now
please
I'm done with waiting I don't care what
else you're doing just install this for
me please so that's what that's going to
do ok so if I go back into my browser
now and I open this console there and
let's clear out and hopefully when I run
we will see it runs the code that I just
wrote and it will register and install
that serviceworker
ok so it says serviceworker registered
that was the actual page running and
then the browser fetch the serviceworker
javascript file and it registered it and
it ran the install event on it now it
only runs the install event once so if I
hit reload you'll see the page can re
register it as many times as it likes
that's fine nothing's going to happen
the browser will fetch the serviceworker
code in the background and it will say
hang on that's the same thing that I've
already entered
also I'm not going to bother installing
that again it will only install it again
if you actually change the code so let's
just make a small change to the code
there and I'll come back I'll hit reload
and then hopefully we will see it is now
ran the updated code and it's installed
an updated version of my Service Worker
ok great
but what can we really do with a Service
Worker what can we actually accomplish
here well like I said you can only
respond to events and there are various
different events that you can respond to
and a good one to get started with is
this event called
fetch and the browser will raise that
event every time it wants to fetch some
content from your domain so every HTTP
request it's going to make it's now
going to call this fetch method and I
can write whatever code in here I want
to programmatically modify that request
or modify the response ok so I'll save
that come back to the browser and I'll
hit reload and then hopefully it will
install my updated serviceworker and the
next time I hit reload I'll get loads of
log messages because every time it's
making an HTTP request now it's passing
that through my JavaScript code and if
you notice up here this request here is
for the initial page that is before any
of my page JavaScript is loaded so this
is a new thing it's never been possible
to observe the initial page load in
JavaScript before because obviously your
JavaScript wasn't there until the page
had at least started loading but with
the serviceworker you can you can
intercept and modify every request to
your domain
apart from requests for service workers
because that would be a weird sort of
infinite loop thing so you can't
intercept requests for your service
workers but for anything else you can
okay now that we're able to intercept
our requests we can do some stuff to
modify them I'll give you a quick
example let's say that I want to listen
for all requests for PNG files and
whenever any requests for a PNG file is
about to be made I'm not going to do
what normally happens instead I'm going
to fetch a different file and serve that
to the browser instead so I'll go back
and hit reload and I'll wait for my
updated Service Worker to install and
now if I hit reload all of my images
will get replaced by a different image
and that is obviously very useful as a
way of pranking your co-workers but that
is not the only feature of service
there are some other cool things that
you can do as well and like I said the
most well-known one of these is the
ability to run your application offline
let me give you a quick example of how
that might work so I'm going to remove
the silicon that I had before and I'm
going to take you through three
different ways that we can do offline
support with service workers with
different functionality and the first
one and the simplest one is going to be
assuming that we can pre cache
everything okay so what I'm doing now
I'm changing the install event here and
I'm defining a hard-coded list of all
the different resources on my site that
I want to make available offline and I'm
going to use a new API called caches
caches are available to your service
workers and they allow you to
programmatically define caches of HTTP
requests and responses that you can then
use later
so I'm saying okay I'm going to delete
any cache that already exists with this
particular name and then I'm going to
create a new cache with that name so
it's nice new and empty and then I'm
going to wait for the browser to fetch
all of those resources in my hard coded
list and add all of the responses to the
cache and when we've got all that we can
stop waiting to install and we can
finish installing the serviceworker
right and then when the browser tracks
to make a request to an item on our site
I can just assume that we've already got
it cached so for every single request we
try to make we'll match it against our
caches and we'll just serve the cached
content back to the browser let's see if
this works then and then come over and
reload to update the serviceworker and
then i'm going to reload again and this
time everything should be served out of
cache so I'll hit reload and you'll see
that the page has come up it's working
as normal but if we look over here on
this network tab you will see that all
the content has been served from the
serviceworker rather than from the
internet which means that we don't even
need the internet anymore we can be
completely offline if we want to and to
prove that for you I'm going to mark
myself as offline this will simulate
having no network connection from the
computer at all just to show you that
really does do that if I try and go to
example.com you'll see I can not get
there and it says there is no internet
connection okay so you wouldn't be able
to
you wouldn't expect you can go to any
websites right now but if I go back to
that page I out before you'll see it
pops up just as if I add a perfectly
good internet connection and it's
serving all that stuff programmatically
out of the cache which is great but this
is not a complete solution there are
still some issues that we might want to
solve for example you might not want to
hard code a list of every single
resource that you want to make available
offline you might want to do that
dynamically in somewhere and another
issue is what happens if the underlying
content actually changes now well let's
see I'm going to add a new news item to
this list now so let's say I'll have a
new item here and we'll say it's a class
CNBC and we'll say breaking something
important happened read it now you won't
believe what happened next
okay all right so I've got that
wonderful click Beatty item in my list
there and my user wants to get the
latest news so they come along and they
hit reload or they get say any new
content oh that's because they're
offline so that's quite reasonable I'll
go online now and I'll hit reload but I
still don't see any updated content why
is that because my application is
hard-coded to just serve everything from
the cache so it's never even going to
check whether there's any updated
content that's not great so how about we
make our logic a little bit more
sophisticated next approach that we
could use offline approach - we could if
we wanted to try making a request to the
network but if that fails then we'll
serve content from the cache so I'm
saying we're going to try the actual
network if we get a good result we'll
return it if we don't then we're going
to go back to that serving from cache
logic let's try that so on my first
reload it's going to update the
serviceworker in the background and then
when I reload a second time we should
see we get the new breaking news story
showing up there which is great but if
my user is offline and I hit reload then
the application still works because it's
now serving the cached content so that's
an improvement we're now getting new
data when possible and we're falling
back on the cache when we have to that's
good but there's still scenarios where
you will get a very poor
user experience for example what happens
if the user does have a network
connection but it's just unbelievably
slow or it's some sort of captive portal
that's never even going to return the
content anyway what's going to happen
then well we can try and simulate that a
little bit I'll go online but I'm going
to simulate a very very slow network
connection some plain Wi-Fi there and
I'm going to have to what will I do
okay let's start by going to a blank
page and then I'm going to see how long
it takes to load so it's loading loading
still waiting and the images are
starting to appear now you can see we're
still waiting though and it's really
slow and finally it's loaded ok good so
it did work but it's a really poor user
experience and obviously their network
can actually might be even slower than
that it might take half an hour to
download or something crazy and the
users just going to click back and
obviously not bother to visit your site
what can we do about that then well we
can make our logic a little bit more
sophisticated still at the point of me
showing you this is to show you the
power of service workers to
programmatically control what your
application is doing with the network
you can implement whatever logic you
think makes sense to your site such as
this here I'm saying ok we'll use the
network if it's fast but if the network
turns out to be slow then we're going to
serve cache content so I'm saying here
all right we're going to try to make a
regular request to the network and if
that works then we're going to return
that network response if it was fast
enough but we're going to time that out
after 200 milliseconds because people
can't be bothered to wait any longer
than 1/5 of a second and if it's going
to take longer than that then we'll just
fall back on serving the cached content
but a little cleverly in the background
will allow these slowly requests to
continue running and when the slow
request eventually does complete we'll
programmatically update our cache
content with whatever we got back so now
our application should be a little bit
faster so let's just reload that that's
going to take a while but that's going
to update the serviceworker on the first
request now I want to change my new
story I'm going to go back and change
this let's have braking - something else
happened ok that's important news that I
user wants to see
they reload are they going to see it
well no they're not going to see it
because their network is too slow so I
hit reload and we're just going to see
the previous cached content and that's
going to come up after 200 milliseconds
reliably no matter how slow the network
is but in the background we're still
fetching the updated data and storing
that in the cache so the next time the
user hits reload then they should see
rating 2 and they get their new news
story there ok so I am not trying to say
that this is the one through correct way
to do offline access I'm just saying
that you get to control it you get to
make the decisions about how to
prioritize between going to the network
how long you're willing to weigh whether
you're serving cache content whether you
can define all that cache content in
advance whether you have to do it
dynamically it's all up to you because
the serviceworker API is give you that
level of control and there are other
features as well that this gives rise to
like I mentioned before you can
synchronize things that the user does
offline that is when they try to make an
HTTP request to your server that can't
complete because the network is not
there you can say actually let's just
store that one for later and then when
the network connection comes back up
then you can get a notification even if
the users moved on to a different
website and then you can do what you
want to take that data that they had
before and find somewhere synchronize it
back to your server again you also
mentioned you can take push requests
from your server and maybe you can do
scheduled tasks in the future ok now as
for actual browser support as of this
month it's good news in Chrome and
Firefox because they've already got this
stuff shipped it's very close to being
shipped in edge as well it is actually
implemented it's in there it's just
behind a flag that the user has to turn
on at the moment so hopefully that will
be on by default pretty soon WebKit
isn't or Safari let's say is not quite
so clear what they're doing with this
somebody on a mailing list posted yeah
we should do it but that's the only
public statement that we've had and that
doesn't really count as a public
statement so we don't really know what
they're doing but you know apparently
they know that they should do it and
hopefully they will do that ok right
then next major feature area that I want
to do some in-depth demo is about is
another feature that I'm sure you've
heard of but I'm pretty sure you won't
have seen some of the cool stuff that
I'll be able to show you just now and
that feature is web assembly
I'm sure you've heard of it so won't
bother asking but for anybody who's not
quite sure what that is
it means a couple of different things
one thing is in a sense it's a
completely new way of running code on
the web it's a new sort of application
runtime that's available in the browser
is actually JavaScript it's a specific
subset of normal JavaScript that can be
optimized to run extremely quickly the
browser can verify that it's safe
extremely quickly and there's also a new
binary format for delivering that kind
of code to the browser and that format
is called web assembly it's a low-level
binary bytecode format that you're not
really meant to read yourself you're not
really meant to write it yourself either
the idea is that you can compile to that
from some other language and again the
best way to understand it is to actually
see it so let's have a go at compiling a
bit of code to web assembly and then I
want to show you the actual web assembly
code itself that's generated the actual
byte code or at least a human readable
version of it because I had an even
person we've seen what web assembly
source code looks like until a couple of
months ago and I think it's really
useful to understand what it's doing if
you can really actually see what the
code is so we're going to start with a
bit of C source code here let's just
refresh that okay so the easiest thing
that you can compile to web assembly
today's C or C++ and here I've
implemented a very basic C program that
prints out the Fibonacci sequence and
the mathematicians among you will know
that Fibonacci sequence is just a series
of numbers that's defined mathematically
it doesn't really matter what that
sequence is I'm just using it using it
as an example of an arbitrary algorithm
for this talk now this bit of code down
here you can ignore
that's just responsible for reading an
argument from the command line I'm
calling this other function and that is
the algorithm that actually prints out
the Fibonacci sequence
now the normal way of running C code
would be to compile it to a native
executable which you could do with
something like the GNU C compiler and
then we could run Fibonacci and it will
say okay how many terms do you want ten
terms and it's going to print out our
ten terms of seven Archy brilliant but
can we compile that to web assembly of
course let's see how to do that to
compile C to web assembly we can use
the inscription see compiler which takes
pretty much the same set of parameters
as GCC except it can produce JavaScript
or web assembly so I'm taking my
Fibonacci dot C file here I'm saying I
would like you to give me some web
assembly please and this is all going to
be wrapped in a file called Fibonacci
dot J s so if I run that now it should
actually compile that and if I look at
the files that are on disk it has just
created those two files those two files
are the actual webassembly binary file
there that contains the actual
application code and then we've got this
wrapper file JavaScript stuff there and
that deals with actually being able to
run web assembly and do the interrupt
with it from the browser's normal
JavaScript API and you might think 48
kilobytes just for that six lines of
code or whatever that's kind of a lot
isn't it well yet it would be except
that that 48 kilobytes also includes the
entire C runtime needed for all the
stuff you do with regular C programs and
memory management and all that stuff so
there's a lot in that actually not just
the few lines of code that we wrote now
to actually run that we need to launch
it from a web page and here's a web page
it doesn't look much like one but it is
and it's got a script tag in it that's
going to be able to load this Fibonacci
JS file and then I'm also pre defining a
bit of config that's similar to passing
arguments on the command line so if we
actually run this now in our browser
then hopefully we will see our C code
has run and if we look in the console
you'll see we've actually got the
Fibonacci sequence printed out okay
that's good but how does it actually
work what does this web assembly code
look like inside well we can't really
read the wesam file
my screens don't ask but yours is ok
good ok so we can't read the Westham
file directly because it's a binary
format but we can get a human readable
version of it if we want to or at least
kind of human readable depending on what
kind of human you are but hopefully
you're the right kind so we will run
this now and then if we have a look
we'll see we've created some new files
in fact I'll show you over here ok so
we've now got a source map file and a
web assembly text file
washed okay I'll look at that in a
second but the fact that we've got a
source map now means if I reload you'll
see we've got the actual C source code
available in our browser debug tools and
theoretically you can even set
breakpoints on that and step through in
practice you cannot because it's
horribly broken in all the browser's
right now but I'm sure they will fix
that you can see where they're going
with this anyway the point of this is I
want to show you this web assembly text
file now like I said it's a pretty big
file that's got loads of C runtime stuff
in it so it's sort of massive and you
obviously are not going to just
immediately go yeah I know what that's
doing but we can more or less understand
it if we do the following so if I go and
say I really want to know what my print
Fibonacci function looks like in
webassembly
so I'm going to copy that name and then
I'm going to search for it and we'll see
here's print Fibonacci in webassembly
and it's got loads of setup stuff and
just loads and loads and loads of hard
to understand code but it does have line
numbers so we can see that these two
statements here correspond to line size
in our C source code what is line 5 well
it's this one I'm declaring to locals
and the first one has a value 0 and the
second one has the value 1 and if we
look here we'll see it declares to
locals and the first one has value 0 and
the second one has value 1 so it does
pretty much make sense and now it is
hard to read but if you look through it
you'll see that it's a stack based
virtual machine with typed entries on
the stack so in some ways it's
conceptually quite similar to the dotnet
runtime it does make sense more or less
we can see for example let's see we can
see here this is where we're actually
doing an addition so we're getting two
locals here and we're using an integer
addition on them and that's from line 11
if we look at line 11 you'll see indeed
we're doing in addition right there
so yeah it does seem more or less
plausible and this is what the browser
is actually running when it runs web
assembly although it normally runs it
from a compact binary representation not
from text okay good all right and so
that shows that we can compile some C or
C++ source code to web assembly and
you'll be pleased to know that there's
some work going on
to make other languages compiled to
webassembly as well for example rust go
swift various other things can be
compiled to webassembly and if you think
about it theoretically at some point in
the future it might even be possible to
do something awesome like compile a
dotnet runtime to webassembly
and if we could do that then we could
even load and run net code directly in
the browser on web assembly which would
be amazing but it sounds a bit too good
to be true does it or should we actually
try and do that shall we see if we can
make a dotnet runtime compile to web
assembly right now and actually do a bit
of a will first of getting dotnet core
running inside our web browser okay so
I'm going to change directory here and I
want to show you something first so I'm
going to show you this directory that
I've got here and what is inside there
well I've got a lot of C source code a
lot of it and what that is is a dotnet
runtime now it's not V dot net runtime
it's not the regular full dotnet
framework it is not the full dotnet core
thing it is a separate net runtime a
third-party one which is smaller and
it's designed for portability it is not
designed for compiling to web assembly
since it predates web assembly by
several years but it only took a few
small tweaks to get it to actually build
through the inscription tool chain so if
we do that the result of doing so is
contents of this directory we have DNA j
s and DNA awesome so what's DNA DNA is
dotnet anywhere that's the name of this
dotnet runtime okay now it's a bit
bigger than what we had before these two
files together a 350 kilobytes more or
less and you might say in class quite a
big thing to put in your web page isn't
it but this is before any sort of
minification or gzip compression so by
the time you're serving that for real it
should be well under 100 kilobytes okay
but does it actually work let's see
first I'm going to have to run this in a
browser so I'm going to go over to this
other page over here and you'll see that
again I'm using a script tag to try and
actually load DNA J s okay let's set
that a start up project and actually I'm
going to run it from the command line so
let's do HTTP server
okay and then I'm going to go to this
localhost localhost to port 8080 so run
that and we should see that indeed it is
in fact running the DNA runtime there
and it's saying okay here's your usage
instructions please tell me what dotnet
executable you would like to run okay so
I'm going to need a dotnet executable
here and that's cool because I have got
one I've got the famous console app one
that everybody knows and loves and
inside there we've got a very simple bit
of hello world code and I'm going to
need to compile that so I'm going to do
build and after that has built which
will happen soon I'm sure
there we go then we are going to have a
file on disk and if I go into bin-debug
net coop one one then you'll see that
we've got console app one DLL that we
have just compiled and that's a five
kilobyte package of net compiled code
right now I want to load that into DNA
so I'm going to go over here and I'm
going to change these arguments I'm
going to say I would like to load and
run console app one DLL okay now that
file needs to be loaded over the web so
we need to point it to a particular
location I'm saying I want you to load
that file from this location here and
also by the way you're going to need to
load this core Lib DLL which contains
implementations of low-level dotnet
things like string and lists and stuff
like that okay does it work come back to
the browser hit reload one more time and
indeed we've got hello walls so we've
got our actual C code running in the
browser there and just to show you more
venturi Flight applause yeah okay now
just to prove to you that really is
actually allowing me to run arbitrary
c-sharp code I'm going to drop in a
c-sharp implementation of prince eben
Archy there and I will call that print
Fibonacci let's run that with 15 and I
will build that so build build console
app 1 okay
come back hit reload oops come back hit
reload and then we've got our c-sharp
7rt running so it was very quick and
easy for us to get updated code into the
bounds of that so I hope you think that
is pretty cool and interesting the fact
that we could bring our own dotnet
runtime into the browser through
assembly now if you are anything like me
you probably look at that and you think
yeah wouldn't it be cool if there was
some sort of framework that you could
use to build single page applications
with dotnet code rather than having to
write any JavaScript or tight script or
web pack or any of that stuff would be
cool if we could just do all this with
dotnet running on web assembly I thought
that too so so we have a little look at
what that might look like okay so before
I really get into that I'm going to
caution you that this is not a shipping
product this is an experiment this is
just for you to be amused by and also
because I'm really interesting what you
actually think about this whether you
think this is something that you would
actually want to use whether anyone
really cares about this sort of thing so
I definitely want your feedback but
don't expect that you can just download
this and start building some production
application with it when you leave this
session okay so let's create a new
project I'm going to create a new
application which is going to be a rich
client-side application with c-sharp and
razor running in the browser or should
we call it my super thing okay and we
will create that that's going to create
an initial project for us there and
hoping that all the packages restore and
we can actually build that is that going
to work hopefully yes
yep that's compiling okay so I can now
run that in a browser and when that pops
up you will see we've got something that
resembles a single page application
takes a moment to come up the first time
because it's compiling stuff in the
background and there we go now if any of
you were in my talk yesterday you may
find this to look quite similar because
it looks the same as the angular and
react and other templates that we've got
shipping at the moment and it's got the
same functionality as those do so we've
got basic client side navigation I can
go backwards and forwards we've got an
example of a component that lets you
increment a count and an example
affecting some data from the back end
there but what does this curve really
look like then so let's expand all this
stuff and we will see that it is not
react or angular or anything like that
and in fact there is no JavaScript in
here whatsoever none it is just C sharp
and razor and what does it really look
like well let's have a look at this
counter code here it's very very simple
and predictable okay
I'm using c-sharp to say I'm going to
have a count property which is an INT
and then i've got a method that when you
click when you call it it's going to
increment that count i'm using razor to
display the current count and i've got a
button that you can click and it will
increment the count in that kind of way
so that is how that works and other nice
things work too for example if i want to
change my code let's change that to
counter one two three it's just going to
update very quickly and if I want to
make it go up in tens rather than ones
then I come back and click that and it
will do okay so it's compiling very
quickly there and it does that by having
an instance of the Rosalind compiler in
memory there so not inside the browser
button on the server there we've got a
Rosalind compiler that can very quickly
produce updated dll's that can get
loaded and run through web assemblies
app so that's very nice and fast but
would it really be nice for you as a
developer to build something like this
what would the actual experience be like
let's have a go at adding a bit of
functionality to this site now and I'll
do the classic example that everybody
always wants to do which is of course a
to-do list so I'm going to create a new
file to it represent the to-do list
component so add a new item and it's
going to be called to-do list CSS HTML
okay and then I want to have a reference
to that file from somewhere else I want
the user to be able to get here okay so
I want to modify this navigation menu to
add a new entry on it I will go to the
nav menu there and I'm just going to
scroll down and copy and paste one of
the existing list items here and I'm
going to link that one to to-do list and
then I will also change the text to-do
list okay it says and now we've got two
lists in the menu I click on that and
we'll see the to-do list component shows
up there okay now how can we actually
implement a to-do list well we're going
to do this with c-sharp so I want to
define a class to represent a to-do item
so firstly I want a code block that I
can put some c-sharp in then I have a
class called to-do item and every one of
these to-do items will have a string
property called text and a bool property
called is done that's a reasonable model
for a to-do item and then I want to have
a list of these
so let's have list of to-do item which I
can type eventually calls to do items
equals new list of to-do item okay so
we've got our list of to-do items there
now I want to display that in some way
the first thing I will display the
number of items in the list so let's
have to do items dot count and we will
see that initially there are zero items
in the list like you'd expect and I want
to actually display the contents of the
list as well so let's have an list here
and I'll say for each of our item in
to-do items I want to have a list item
that displays item dot text now you
won't see anything straight away because
there's of course nothing to display
there's nothing in the list I need to
have some way of getting stuff into that
list and I will have a button add item
okay now currently when I click that
button it's not going to do anything so
I don't have any behavior wired up to it
and how can I actually add some behavior
well if we go back to the good old days
of JavaScript many years ago we would
have an onclick handler and then we
would start writing some JavaScript in
there but now I can write some c-sharp
code in that that will actually run when
the button is clicked so I'm gonna say
to-do items dot add new to-do item and
then we'll set the text on that to be
new thing okay yeah I need a semicolon
on the end of there because that's a
complete line of c-sharp okay and then
when I click this button you will see we
are now adding items to our list and
they are showing up so that's good but I
don't really want to hard code this
string new thing and I don't really like
the fact that I've got all this c-sharp
code in line and an event handler anyway
that doesn't look great so I'm going to
make a method to do this let's call it
add item okay and then I can take the
code that I had there before let's just
drop that in here and now of course I
can come I can invoke add item from
there if I want to but there's a nice
little shorthand I can say on click add
item and that will set behave the same
as before okay but I want to change this
text I don't want it to be new finger I
want the user to be able to type some
text in so let's have a text box and
I'll say type here okay but currently
it's ignoring what I type in
textbox I need some way of capturing
what gets typed in there there are
various ways we could do that but one
way would be to have a string here let's
call it next item and then I'm going to
bind the contents of that textbox to
this string property there and then when
we add an item I'm going to say we'll
use that text that you've typed in I'm
also going to set it back to null which
will clear out the text box so you can
enter your next item straight away so
let's go first and second and that's all
working very well it's very good okay
what else do we need to do to make this
into a convincing application well we
need to be able to edit the contents of
the text and we need to be able to mark
items have done so I'm going to add a
bit of extra HTML in here pretty simple
stuff I'm just gonna have a textbox that
binds to item dot text ok so that's now
going to display an editable thing that
you can edit and that does actually edit
the underlying data structure even
though you can't really see that it does
and then also I'm going to have a
checkbox so input type equals checkbox
and then I'm also going to bind that to
item dot is done okay so now I can mark
items as done or not but you can't
really say that that see that that takes
an effect does that actually do anything
when I check that box in order to
actually show you that it does let's
change what we're counting instead of
counting all the items let's just count
the items that are remaining to be done
how many incomplete items are there
we'll count all the items where their
item is not yet done using a bit of link
code there so now if I add some items
then we should be able to see though
that I can show up and as I toggle these
boxes the item count changes okay good
so we are able okay okay alright
everyone loves to-do list so now that's
pretty cool because it allows us to
build our application in a really
familiar and nice interactive kind of
way but I'm sure some of you are
probably sitting there thinking is that
really practical though I mean seriously
you're shipping an entire dotnet runtime
and core libraries in your webpage so
that's going to be like hundreds of
megabytes or something Internet you
crazy that can't work well let's see
let's see how big this thing actually is
so I'm going to go over to this net
work tab here reload and you'll see that
the whole thing there 326 kilobytes now
I think we all know a certain single
page application frameworks written in
JavaScript that will produce bigger
applications of that typically on
average so this is quite a reasonable
starting point size there and that is
before any serious attempt to actually
optimize it so they know code stripping
and some of the code is not even
minified and it includes bootstrap as
well so that's quite reasonable and the
other objection that I expect that some
of you are probably thinking is oh
that's all very well for browsers that
support web assembly but you know most
browsers or at least the ones my special
customers are using don't support web
assembly so that's no good is it well
let's see what happens if we try to run
this in a browser that does not support
web assembly Internet Explorer 11 our
old friend definitely does not support
web assembly so what happens when we try
to run our application in there well it
just comes up it works and I can still
do all the same stuff that I was doing
before all the functionality is there
that we implemented and it all behaves
exactly the same how is that even
remotely possible given that it's a web
assembly application there and the
answer is that web assembly is really
cool it's pretty amazing technology it
is designed for easy backward
compatibility with browsers that don't
support web assembly so like I said the
actual runtime is more or less a subset
of a certain type of JavaScript so it's
not that difficult to have a polyfill
for web assembly and that's what's
happening here
when we detect that your browser does
not support web assembly we'll just
dynamically load the polyfill for you
and then the application will work
exactly the same as if the browser did
it adds about 100 kilobytes to the page
weight so you don't want to do it all
the time that's why we just do it
dynamically for browsers that need it ok
right then I hope that is of some
interest to you it's pretty cool that
web assembly allows us to do this sort
of thing bringing in a custom runtime a
custom framework and yeah that's pretty
cool now if you want to have a look at
that you can go to this location on
github and you can download that project
temple that I was just using there and
you can have a play about with it
yourself and I'm going to caution you
one further time but this is not a
shipping product it's an experiment but
I am interested in what you think of it
and whether you could make any good use
of that
okay now do browsers support web
assembly yet well yeah pretty good news
it's already on by default in Chrome and
Firefox it's fully ready to go pretty
much in edge it's already there behind a
flag so the user has to turn on the
config setting to see it but again I'm
expecting that to be on by default
fairly soon and slightly better news
from Safari this time they have actually
acknowledged that they are really going
to build this and ship that so that is
officially listed as in development as
far as Safari is concerned okay so that
is web assembly we are going to move on
to the last two things now these two
things are slightly more obscure
features and I will give you slightly
more sort of casual level demo of them
and not so much technical detail this
time but I hope that they will be
interesting to you give you some cool
ideas about things you could do the
first one is credential management it
sounds about as boring as it can get but
it is actually pretty useful now we've
had to deal with credentials as web
developers since the very beginning of
web development we've always had
usernames and passwords and sessions and
cookies and login screens and
registration and sign out and all that
stuff that we've all implemented dozens
and dozens of times and the browser has
not done very much to help us with that
a credential management is a new set of
API that allows the browser to
understand the concept of usernames and
passwords or other types of login flows
and do something actually useful for you
it gives you a way of storing
credentials in the browser in such a way
that the user will get automatically
logged in on all their devices so the
user logs into your application on the
desktop and when they pop it open on
their phone they'll find that they're
just logged in they didn't have to do
anything they didn't have to tell them
that it's the same account or anything
because the browser can deal with
synchronizing credentials for you it
also gives you some native user
interface in the browser for things like
account pickers and switches and that
sort of thing of course you want to see
it so let us move on to our fourth and
final demo application and I'm going to
introduce to you a little bit of project
that I've got working on in the
background it's a bit of a business idea
that I've had I'm hoping to get very
rich out of this
it's called CEO portal the idea was CEO
portal is
that powerful businesspeople the the big
Titans of the industrial world can come
along and they can register on this and
then they can do all the stuff that CEOs
need to do through a website let me just
show you that if I bring that up you'll
see we've got some nice sort of
corporate web design going on there I
think this will strongly appeal to SEOs
from what I understand and so yeah the
other thing about CEOs that you need to
understand is that they're very very
cautious about security they want a very
robust and clean login and registration
system where they know that their
account details will be protected so I'm
going to show you how we can do that
with a bit of credential management but
the first thing I want to show you is
what this page is doing when it actually
starts up so when this page first loads
it tries to ask the browser hey have you
got any saved credentials already for
this user navigate to that credentials
get and in this particular case it's
going to return undefined because the
user does not yet have any saved
credentials and so we're just going to
display our application in a logged out
status and then eventually our user or
potential user is going to be convinced
that this is a good investment for them
at their time to register for this
application so they'll come along and
they'll create themselves an account
like that and they're going to click on
the register button and when they do
that this code will run down here so
we're going to instantiate a new
password credential there are various
different types of credentials that you
can instantiate a password credential is
the simplest one it's just a username
and a password there were other types
for different types of federated login
systems to instantiate a password
credential we need to give it the
username and password or but in this
case as a shorthand I'm passing it an
instance of form an actual HTML form
element and the browser will be able to
pull the username and password out of
that form by quit by convention so when
we've done that we'll now have a
credential object which has picked out
the user names Steve and password and
suchlike and then we can say hey browser
will you please store that credential
for me and when we do that the browser
will display a bit of native UI here to
say do you want me to store this
credential actually and the user will
obviously click the blue button because
they don't read it and
it will save the credential in the
browser that and now we can switch over
to our logged in view okay so this is a
logged in view you can see various
things that CEOs need to do that they
can do from this screen or they can sign
out if they need to now next time this
page gets loaded and we try to check for
credentials again we will get slightly
different behavior so if I hit reload
now you will see again we're trying to
get credentials and if we look we've got
the password credential object back with
our username and password so we know
that we should display the user in a
logged in state and also every time we
make any API calls to our back-end we
can pass the data from that credential
to the backend as well so that it knows
obviously to do the relevant server side
authentication checks okay so my user is
now starting in a logged in state and in
fact every time I reload if you have a
look up there a little message just
flashes up to the user I'm signing you
in as Steve because the browser knows
about these credentials now it knows
what your username is and it knows that
it's automatically signing you in and we
get other cool features from the browser
as well for example if the user has got
multiple accounts let's register another
account like this let's just delete the
breakpoint okay I'll save the burt
credential as well and now when I go to
sign in you'll see the browser is
prompting the user which of your
accounts do you want to sign in at so
you've got a quick account switcher that
can be Bert and I can quickly become
Steve again very good okay so that gives
us a pretty nice way of giving the user
the ability to store their credentials
and like I said it can be automatically
synchronized across their devices so
they don't have to keep logging in on
each different device that they go to ok
so what's the question you asking about
browser support in Firefox and edge you
are okay well how about this to answer
your question right so this feature is
only in chrome today so chrome is
pushing ahead with this agenda
they've already shipped this feature the
other browsers have not actually
confirmed that they're going to do it
but it is a standard track feature so
you would hope and expect that they are
going to do this but it is early days
for credential management and so if you
are going to use this right now you're
going to need to not rely on it
completely now thankfully the way these
API is work you can reasonably well
polyfill all of it apart from the actual
synchronization across devices so we
could have a polyfill that stores the
credentials in local storage or
something else like that I'm not aware
of a good polyfill right now actually so
if anyone wants a cool open-source
project that they want to start and get
loads of people using you can polyfill
credential management I'm sure you'll
get a lot of users okay so that's
brazzers bot any other questions about
credential management at this point no
ok great ok so we will move on then from
that to our fourth and final feature and
this fourth and final feature is a it's
a thing that mobile and native
applications have been able to do really
well for quite a while but deaths but so
but web-based applications have been
doing a pretty terrible job of it and
that is taking payments from users this
is another thing that's been around
since the very beginning of programming
on the web we've always wanted to get
money out of people reasonably enough
but the but it's been a pretty terrible
user experience so far on the web
because if you want to make someone give
you money you have to have some sort of
checkout form where they manually type
in their credit card details and their
delivery addresses and all that stuff
and it's like so many steps that 80% of
them don't even bother to finish it and
you don't make as much money as you
otherwise would have whereas if you
think about how a native mobile app
works if it wants some money out of you
it just pops a little thing saying
please give me a fingerprint to confirm
and then here your money is mine
wouldn't it be nice if you could do that
sort of thing on the web as well that is
what the payments request API is for it
allows you to tell the brow
I want some money from this user please
and you tell it how much and what the
money is for and so on and it will
display some native user interface to
tell the user hey this application wants
a payment from you and then if the user
confirms it
then all the payment details go to you
now the way that the actual UI looks
will vary depending on what kind of
browser or device it is if it's on a
mobile device it's probably going to ask
them for a fingerprint or something on
the web it may ask for some other kind
of on the desktop it probably asks for
some other kind of confirmation so let's
have a go at adding a payment feature
into the CEO portal so that I can get
rich ok so how and why are we going to
get money out of our users well I've
thought about this carefully and I've
come up with what I think is a really
good business model so let's say that
our user is signed in there a powerful
CEO and they're thinking about which
executive activity they want to perform
today and I assume that most executives
really like reviewing key financial
documents they seem to be into that sort
of thing
so they click on this button and what
happens is ah this is a premium feature
which you can unlock now for just 50
gems and a CEO probably thinks cool
that's a good deal quite happy to spend
50 gems on that but oh no I've got zero
gems I mean I have to get some more gems
so let's get some gems shall we and
that'll take us into the gem store and
well think hmm how many gems should I
buy not sure but for whatever reason my
attention seems to be drawn to this 50
million gems option that it seems like a
reasonable choice it's the most popular
choice you know and all the features in
CEO portal require to spend gems so I
think 50 million would be a reasonable
amount to have now when the user clicks
that button I want their money how am I
going to get their money well let me
show you a bit of code that's going to
run when that is invoked so if I open up
the JavaScript file that's in there and
we'll scroll down down down down to buy
gems now that is the function that will
run when the user clicks the button and
what it's going to do is it's going to
compute a bit of stuff to do with the
amount that I want to charge them this
is an important thing to understand that
payment requests api's do not do any
computations for you they will not
calculate tax or shipping or anything
else like that it's entirely up to you
to provide whatever values you want it
to display in the UI so I'm computing
some values and then I'm defining a new
payment request and inside that payment
request I can configure what sort of
payment methods I'm willing to accept in
this case it's just credit cards but you
could have other things like Android pay
or whatever other stuff that a given
device might support and then we can
configure that on this occasion I'm
saying I'm taking these types of credit
cards that you can give me and then I
can also define order details as well so
what are the line items what's the grand
total what's the shipping information
that kind of thing and then finally I
can give other settings such as do I
want to collect shipping details from
this user or not and then I can say to
the browser can you please show this
payment request to this user and then
we'll get a call back when they confirm
or reject that so let's see that
actually happened I'm going to click on
this button now and when I do that a bit
of native UI will show up now I did not
design this this is built into Chrome
this is just what shows up and it
displays all the information that we've
asked it to so the user can see their
order details and the tips that I've
added there which I think is reasonable
and the online delivery as if there's
any other way of delivering virtual gems
and and then the user can select from
their predefined shipping address I
don't know why but you know that's just
to show you that we can do that and we
can also select a payment method that
they would have pre stored with their
operating system with their browser or
whatever depending on what kind of
device they are using and then finally
the user is going to click on the pay
button of course and if they are doing
so in chrome it's going to ask them to
confirm with the CVC number so I'm just
going to type in some number there and
I'll hit save or ok and then the browser
will return all this payment information
to you the web developer for you to do
what you want with now I am trusting
with you with my card number here so
please don't abuse that trust I just
want to emphasize that the browser is
not actually making the transaction for
you it's not contacting a bank or
anything like that it's just giving you
the store details the stored payment
number the store to shipping address and
any other options that they've chosen
and it's still up to you to pass that
through to your normal payment processor
or whatever but the point is that the
user did not have to type this
then they just tapped a button or did a
fingerprint and you get the payment
details and hopefully your conversion
rate is much higher than it otherwise
would have been now the way this
actually appears to the user like I said
will vary depending on what device they
are using or what browser and if I show
you how this looks in edge you'll see
it's slightly different so if I bring
this up in edge and I'll do the same
thing where I'm trying to buy my gems
what happens in this case is that the
Microsoft wallet will pop up and then
the user will be able to make their
payment using whatever they've got
stored there in their wallet so it
varies by device type and by browser as
it should because that will maximize the
chance that your user has actually got
the stored payment information and is
willing to actually give you the money
now is that supported in browsers well
it's better news from edge this time
because that feature is already shipped
in edge good well done those people
chrome has already got this one live as
well Firefox has announced that it is in
development so hopefully it won't be too
long before it's live though as well
unfortunately again Safari is the
lagging one there because they have not
even acknowledged the existence of this
as a concept yet so we don't know if or
when they're going to do that but
realistically if you want to use
something like that today you're going
to have to have some kind of fallback
for browsers that don't support it
because someone's going to be on an old
browser and you don't want to refuse
their money so you're going to have to
say for people who support this you can
pay with one tap for people who don't
you're going to have to go after some
tedious traditional checkout form where
you type in your credit card number and
all that ok any questions about payment
requests No all right great ok so that
is all the stuff that I'm going to have
time to demo for you today we've just
been through a whole bunch of different
upcoming features that create new
possibilities for your web applications
just to finish off let's imagine what
your next cross-platform web application
might look like and what it might do
well it might have some really cool
features for example you might be able
to use service workers to make it load
instantly even if the users got a very
slow network connection or or no network
connection at all
you could also use service workers to do
things in the background for example if
the user does stuff while they're
offline you can synchronize that back to
your server later and you can receive
pushes from your server even when the
user is not on your page you could also
potentially write your application in
a completely custom language or runtime
of your choice he could use maybe
Darnell Swift or rust or something else
like that thanks to the power of web
assembly you could also give users a
really clean login system with its
synchronizes automatically across their
devices and you can hopefully even get
money out of them with just a single tap
or fingerprint none of these features
you would realistically have done last
year there might have been some sort of
vague ways of doing some of them but it
wasn't very practical whereas as of this
year that sort of support is actually
landing in browsers that customers are
actually using so you can realistically
do some of this sort of think so that is
all we have time for I hope you enjoyed
this session please remember to evaluate
on the way out so that you can control
what the schedule is like for next year
and I hope you enjoyed the rest of your
conference thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>