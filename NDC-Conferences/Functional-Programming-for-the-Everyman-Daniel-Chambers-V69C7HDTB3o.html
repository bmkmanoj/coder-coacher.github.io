<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional Programming for the Everyman - Daniel Chambers | Coder Coacher - Coaching Coders</title><meta content="Functional Programming for the Everyman - Daniel Chambers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Functional Programming for the Everyman - Daniel Chambers</b></h2><h5 class="post__date">2016-10-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/V69C7HDTB3o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay good morning everyone thanks for
coming I hope you all had your coffee
several like this morning I know I'm a
bit tired from last night but let's get
into it
so my name is Daniel chambers and I work
as a senior consultant for edify my
twitter handles up on the slide so if
you have any questions or feedback
please feel free to tweet it at me or if
you see me around the conference please
do come up and have a chat happy to talk
I'm so out of all the talks that I've
done so far my most popular one is
probably the one where I introduced
f-sharp to.net programmers
I like f-sharp and I think more people
are dotnet so they should use it to
write cleaning composable code so you
might then be wondering what I'm doing
doing a functional programming talk in
c-sharp and JavaScript instead of an
f-sharp well there's kind of two reasons
one is that I do have a talk later this
afternoon on high school so that's
fulfilling my hard core functional side
but the other is that when I realized
what I realized when I did that f-sharp
talk was that whilst a lot of people
like the look of f-sharp
they can't just jump ship off what
they're coding in right now and for most
people what that means is it's probably
c-sharp and JavaScript we've got years
investment of these in these code bases
and we can't just chuck all of that away
overnight
I'm going to quote directly out of the
Lord of the Rings and say what Boromir
says is that one does not simply shifter
f-sharp some people are scared off by
functional programming because it can be
quite different from the typical
imperative style code that most people
write in their day jobs but what most
people don't realize is that they've
been doing little bits of functional
programming for a while now because
functional programming contract
constructs have been stealthily added to
c-sharp and JavaScript for quite a few
years the problem is is that most people
don't use these features to their
fullest extent that they could and when
I look at the code that I see written
you know there's a lot more that people
could do there so the aim of the talk is
to show you how you can use these
functional features of your language
together with functional libraries so
that you can get some of those
functional programming benefits now in
your day job then once you're used to
this first level of functional
programming you'll be naturally
attracted to more full-blown functional
languages like f-sharp and functional
techniques so first a little bit of
history to put functional programming in
its context so in the beginning there
was unstructured programming where we
used go-to statements to allow the
programmer to quote control that flow of
development that flow of the programs so
this allowed us to write programs that
quickly grew out of control and ended up
being quite messy this is where
structured programming was introduced to
kill off that go-to we littered that
level of abstraction up a notch by
formalizing those those looping
constructs into four and while loops we
introduced procedures and subroutines
and they were added to split code out
and make it more easy to reuse
structured programming was an attempt to
make the flow of control clear this was
a big step up from unstructured
programming because it made that code
much more easy to reason about because
of those common control structures
unfortunately structured programming
still has a nasty floor and that's
global variables everyone here I'm sure
knows the pain of global variables and
how that how code that uses them is
extraordinarily hard to understand and
reason about so solve this
object-oriented programming was created
to kill off that global variable by
providing language features that make it
easy to encapsulate state it does this
by tying data and subroutines together
into a concept of a class it also takes
further steps towards code reuse by
introducing inheritance and composition
again we've lifted that level of
abstraction up a notch with the aim to
improve our ability to understand code
and reason about it this again allowed
the complexity of our software to jump
up but as you probably know there's
there's still issues with state
management in a while variables are
local to classes they're still variable
and they're shared by everything in the
class and and possibly externally
functional programming takes this
the next level its aim is to remove
state altogether state is variables
whose values can change we can remove
state through the judicious use of pure
functions which are functions that have
no side effects and therefore always
return the same output for the same
input this simplifies the code by
removing moving parts where the moving
parts in your code are those variables
functional program functional
programming words that level of
abstraction even further by treating
functions as values which makes reusing
code trivially easy it also allows for
that for the implementation of libraries
that act as domain-specific languages
which make it easy for you to focus on
writing your business logic rather than
writing control logic so an example of
such a library is link and the domain of
link is the sequences of values so
you're probably wondering well don't I
need a functional programming language
in order to do functional programming
and the answer is no Eric Meyer of the
lincoln eric's reactive extensions firm
he defines functional programming as a
style of programming where expressions
are more important than statements this
is a key point in understanding
practical functional programming
expressions take input and deliver a
result and we combine those expressions
together to express a wider program
expressions don't have side effects they
return a value
this means statements are the antithesis
of expressions and therefore of
functional programming but have an
explicit in they have an implicit side
effect against the global state and
since we're trying to eliminate state
altogether we need to get rid of
statements and focus on expressions so
functional programming languages make
writing codes solely in expressions
easier by adding language features to
help support this good news some of
those features have been brought into
the language we use the languages we use
every day such as c-sharp and JavaScript
so let's have a look at how we can use
our day-to-day languages to start doing
a little bit of functional programming
so c-sharp 3 introduced lambda
expressions and this makes functions as
first-class values easy this introduced
a wave of functional
libraries to be added to don't net link
is the best known library link is
basically functional programming sneaked
into the language by stealth so guess
what if you've used a bit of link you've
already done a little bit of functional
programming link is really a set of
higher-order functions that is functions
that take other functions as parameters
that and that lets us deal with sequence
of sequences of values using only
expressions and no statements this means
that we can eliminate side-effects and
variables from our code when we deal
with sequences and it also allows us to
write simpler and more readable code so
link is typical of functional
programming it raises the level of
abstraction up when we're dealing with a
domain in this case the domain is of
sequences and the library allows us to
reuse code that has already been written
to deal with sequences this means that
we can write business logic that states
what we want rather than how to get what
we want
this style of declarative programming is
easy to do when you're programming
functionally all functional programming
languages will have a library like link
in them however in order to think it's a
sort of sneaked functional programming
into dotnet without scaring people
Microsoft used different function names
to what you typically see in in
functional norms so for example in most
functional programming languages the
Select method is called map aggregate is
called reduce or fold any is called
exists so hopefully you're starting to
realize that functional programming
isn't a totally weird beast that can
seem terrifying you're already using it
a bit with libraries like link however
what I see when I look at most C sharp
and JavaScript code is that people are
dabbling a little in functional
programming but they couldn't prove
their code even more by fully embracing
it so let's start looking at some
practical code examples of how you could
write your code more functionally to get
rid of state and make your code more
readable and maintainable this way you
can start taking further steps down that
functional programming path and do it in
your day job so let me switch out of the
slides and I've got some first initial
examples
in link pad so what I've done here is I
basically written some code in c-sharp
and I've written an imperative version
of some code and then I've transformed
it into a functional version so that we
can sort of contrast compare what that
means for us so in this first example
it's a very simple it's a very simple
little algorithm we're basically taking
a string which would contain someone's
name and splitting it up into first
names middle name and surname in a name
class so this is some pretty typical
logic we might write a name in our
business applications so this is the
code that we'd look to write if we were
writing this imperative Lee so you know
we take that string in and we're
returning the the name class out so the
first thing we're going to do is we're
going to take that name string we're
going to split it up on spaces so we can
just get out the individual names and
we've also used this overload which
means that if there's any double spaces
we get rid of those empty strings then
what we're going to do is we're going to
create that that new name class and it's
going to be an uninitialized set at this
point effectively all those properties
will be null then we're going to write
some imperative conditional code where
we're going to manually check the length
of the array we're going to say okay if
there's one or more names than the first
name so the first thing in the array
where so we're going to manually index
into that will be our first name and
we're going to side-effect against first
name in order to store that if we've got
two or more names we're going to
manually index to the end of the array
grab the last name stored is the surname
with a side-effect if we've got three or
more names that naturally means we must
have at least one middle name
so what we're going to do then is loop
through the middle names with a manual
for loop and start from the second
element and go up until the second last
and then append them together in a
string builder now the string builder is
naturally going to end up with a
trailing space so we'll have to trim
that off and we take the string out of
the string builder and then side-effect
it into the the middle name on on the
class then we'll return that instance
from the from the from the method so
this is pretty typical imperative code
that I'm sure we've all written at some
point what the the first thing you'll
notice here is that what we're doing is
we're literally instructing the program
how to get what we want what we'd rather
do is declare what we want and work at a
higher level of abstraction to make this
smaller and more and more readable so
let's have a look at a first version of
the way we might do that so in this
first version what we're going to do is
again we're going to do our split and
then what we're going to do is we're
going to create the the name class
instance but this time we're going to do
it using an object initializer
expression so straight away what we're
doing is we're initializing a name class
instance but with no point in this code
here have we ever got a name class
instance that's half initialized it
always this expression when it can
evaluate some completes will return a
valid name so this object initializer
allows us to set our properties so here
what we're gonna do to get the first
name is instead of manually indexing
into an array and having conditional
logic we're going to lift our level of
abstraction up and think about sequences
so we have an array an array as a
sequence a library for sequences is
linked and link has a first to default
method that we're probably all used at
some point so this is a great example of
where we could write manual logic but
really if we work at this high level of
abstraction and declare what we write
was rather than how we actually end up
with code that's a lot simpler and much
more readable to get a surname what
we're going to do is we're gonna use a
ternary expression so ternary
expressions are great for allowing you
to write conditional logic but then stay
writing expressions rather than writing
statements so here if we've got one or
more name we're going to use the last so
again instead of manually indexing into
the end of an array we'll just say give
me the last so again we're sort of
working at at that declarative in that
declarative space for the middle name
we're going to use a ternary expression
to check to see whether got three or
more names and then if we do we're going
to write a bit of a link pipeline here
so in c-sharp because C sharp isn't a
full-blown functional programming
language we don't have nice ways of
composing functions using operators so
in c-sharp there's we typically use this
fluent style where it's generally
implemented using
Methos where we can sort of dot from one
function to the next so in this case
what we're going to do is going to take
our name sequence and we're going to
skip off skip away from the first one
because that one's just our first name
and then we're going to take up until
the last the last element but not
including the last element then what
we're going to do with our sequence of
middle names because that's what that
expression effectively represents now is
we're going to aggregate it down to a
single item so aggregate is how you
would take a sequence of items and
reduce it down to a single one which is
typically why it's called reduce in in
functional programming languages so here
this will reduce it down to a single
name but of course because of the way
this works a bit like our imperative
version we're going to end up with a
proceeding space in this case because
the very first time we're going to take
the first middle name and add it to this
empty string so we're going to end up
with a space so trim solves that for us
so what we can see here is that we've
written code that's a lot shorter than
what was there before it's much more
declarative we've eliminated all the
state in that code and all of the side
effects and we've just worked with
expressions rather than with statements
but there's still something here which
is a bit icky and that's that trim
wouldn't it be nice if we could just you
know get a string and in the right
format to begin with rather than getting
one that's a little bit wrong and then
fixing it so let's look at how we could
do that so this is where we could kind
of look around you know in our libraries
and we find out that okay we've got
something called string join and that
will give us the behavior we want it
will take a sequence of strings and then
give us the back joint together in this
case with a space but if there is only
one string it will just return that
string rather than trying to mash it
together with the empty string but we've
now lost the readability of the code
because again c-sharp not being fully
functional we do have to use string
joint in this in this prefix position
rather than where we rather than where
we'd prefer it being in sort of postfix
position but we can work around that
quite easily so what we can do is we can
just create a little extension methods
class and then create an extension
method off of this the ienumerable of
string and then just pass through to the
string join and what this means is that
we can
to end up in the place where we want
where we can add string join to the end
of this pipeline of functions and now
this reads reads much more nicely so you
can kind of see what we've done here is
we've been able to reduce our code down
we've eliminated the use of statements
and just work with an expression so that
we can sort of lift our level of
abstraction up and program declaratively
stating what we want rather than how to
get what we want so another example I've
got for you here is this one so what
we've got here is a little data model so
we've got something called an
application so you can kind of think of
an application in this case to be like
what one would fill out on paper so like
you know you're filling out a form and
this form has a life cycle and it goes
through a number of state changes so on
the model we track the state changes
this thing's gone through so you know it
started out in state 1 and we record the
time that it moved into that state and
then at some point it moved into state 2
at this time and then it moved into
state 3 at this time now
imagine where we're taking this in this
model and we want to display it to the
user you know and one of the nice things
we want to do for the user is not just
show them the start date but we also
want to show them how long it was in a
particular state for so how we typically
handle that is we'll create a view model
for the for the state change and on the
bat we'll calculate that duration and
then just to make it easy to bind it in
to the UI so what we're going to do is
write a bit of code here to calculate
that duration so if we think about how
we're going to do that it's basically a
set of subtractions so in order to
defect in order to figure out the
duration of a state we basically want to
take it's the time that it started and
the time that it ends ended and then
subtract the start from the end to get
the duration so we can say that the end
time of a particular state is the start
time of its successor so in this case to
get state once duration we want to take
state to start date and subtract state 1
start date away from it and then state
threes for to get state twos duration we
want to take start state 3 start date
and subtract from it state to start date
and for state 3 it's a little bit
different because that's the state we're
currently in so there is no real end
date so we'll just use now time to
represent the end date because that way
we can say well how long have we
in the state up until now so if we're
going to write some imperative code here
in order to to calculate this and create
those view models what we'll have is a
function that probably looks a bit like
this so what we're going to have is
basically a function which takes our
state changes in and returns a list of
state change view models out so we'll
create our list of of view models and
then what we're going to do is we're
just going to loop through those state
changes and and yank out from using the
index the current state now we need to
determine what the end date is for this
particular state so what we're going to
do is we're going to index forward one
in the array to get the next state start
date to be the end date of course we
need to be careful we don't end index
off the end of the array so we have an
if statement to protect us from that so
and then if we are in the the final
position in the array we obviously grab
the now time to use as our as our end
date we use our object initializer to
create our view model and calculate our
duration by subtracting the start date
away from the end date then we take that
view models and then add it to the edit
to the view models list and eventually
once we've gone around that loop we
return the view models now that's that's
pretty typical code not particularly
difficult but we could improve it a lot
by again lifting a level of abstraction
up and thinking about sequences and
thinking about how we could write this
in a declarative style rather than this
imperative style so let's take a step
back and think about the problem so what
we've basically got here is effectively
two sequences of dates we've basically
got our start dates in a sequence and
we've got our end dates in a sequence
and what we basically want to do is
subtract those two off of each other so
we want to be able to walk through those
two sequences together and then subtract
off each pair so naturally you know that
being an operation over sequences we can
hope that there's something in our DSL
for sequences which is in this case is
linked to help us do that and there is
there's a function called zip so what
we're going to do first is get our two
sequences so we basically got our
sequences of start dates or
that's our state changes list that's
basically the same thing and what we now
need to get is our sequence of end dates
here and we can do that here by
basically just taking our state changes
skipping the first one so that we end up
starting on state two and then
concatenate sequence an additional state
change which contains our hour now time
right so that means we're now have both
this sequence and this sequence here so
then what we want to do is basically
step through those two sequences
together so we're going to use zip to do
that so zip takes two sequences the
state change and then the next states
and then you give it a lambda where it
basically calls the lambda with each
pair so we'll take our current in our
next states and then we'll use an object
initializer to calculate our duration by
doing the subtraction and then to list
that out and return it so you can see
when we transform this into using a
declarative style and and used linked as
our DSL over sequences we're able to
write code that's a lot more simple and
a lot more readable and it's also a lot
shorter so this is sort of the perfect
example of a case where you know we
could we could write how to get what we
want and this in you know our imperative
version here is literally saying how to
get what we want we want to index
forward in an array and look forward but
we don't want to go off the end so we're
managing all these little bits ourselves
managing that state let's not manage
state let's lift ourselves up and
declare what we want rather than how to
get what we want okay so so far we sort
of looked at dear selves over sequences
another thing we work a lot with in
languages like C sharp and JavaScript is
novel types so we can make our lives a
little bit easier by programming
functionally when we're dealing with
novel types so here's a very typical
example of a bunch of null checking
you've probably written before so again
we've got some application and on it we
have say it some identity details and
energies those of someone filling their
stuff out and on that we have their
address and then on their address we
have their suburb and here we basically
want to pull out that suburb
but of course the path could be null
along the way at any point right so we
need to make sure that it's not null so
we don't get our null reference
exception and if it is not anywhere
along the way we basically want to
return unknown as the suburb so we start
with that we do an if statement and then
if we can get to where we want we start
affecting and suburb and overwrite it
with the value that we want so this is
using statements let's see if there's a
way to write using expressions instead
so the first thing we want to do is add
a couple of add a couple of tools to our
toolbox so we basically want to write
this little maybe function and what this
may be function does is it's an
extension method that extends off of in
this case reference type so T can be any
reference type that's what this is
saying here and then it takes a function
which takes whatever that T is and
returns something so that can be
whatever that lambda decides it wants to
return so the implementation is very
simple all we do is we use a ternary
expression to say is our T our object
not null if it isn't null call the
function with it if it is null return
whatever the default value of T return
would have been so if T return was like
a strings or some reference type then it
will be null if it's a value type it'll
be the default of whatever value type is
similarly we have a version for value
types nullable value types here as well
so this particular version takes a T
which is a value type so struct and but
it's an honorable value type so it has a
users has value and then does a very
similar thing so if we use this maybe
function we can write to that null
checking instead using expressions
rather than our statement so here what
we can basically do is say grab our
identity details maybe if it's not null
access to the address maybe if the
address is not null access to suburb and
then what we're going to do is we're
going to use the null coalesced operator
to basically fall back to the unknown
value if anything along this path is
null because if this is null then this
will not run and this will not run right
well the land that won't be called you
just fall back to know if address is
null then
this lambda won't be called because the
address was null so it just flows and
composes through quite nicely that's
such a nice pattern that in in c-sharp
six they actually decided to lift that
idea up into the language so that's a
great example of more and more sort of
functional ideas getting incorporated
into the language so in c-sharp six you
can actually get rid of the maybes
altogether and just use your conditional
member access operator so in here you
can basically you just go question mark
dot and you sort of get the same
behavior where identity details is then
if identity details is is null we won't
access address and if we if it isn't
well we'll we'll access it and so on so
that's a much Tercel way of writing the
same the same logic however that doesn't
mean that the maybe method can just go
in the bin it's still about its uses so
imagine the case here where we basically
want to drill into the same data
structure but instead of grabbing the
suburb we want to grab whether or not
it's an apartment address and then we
want to say yes or no is the string
because think maybe we're displaying
this in the UI and we just don't want to
display true or false we want to give it
a bit more of a friendly human when he's
friendly human words so here again we're
using if statements were sight affecting
into his apartment yes/no let's tighten
this up using that conditional member
access operator and maybe so we can
basically do add any details question
mark dot address so optionally access
address and then maybe if address is not
null look at the apartment and use a
conditional to get a conditional
expression to transform yes or no so
maybe is great when you want to drill
through a path but you maybe also want
to do a transform and run a bit of code
at the same time the conditional member
access operators great but you can't do
that you can't do this with that so this
should still be in your in still be in
your toolbox to allow you to keep
writing those declarative expressions
rather than writing statements so we've
sort of seen a few examples in c-sharp
now let's switch over and have a look at
a few examples in in JavaScript instead
so I've got BS code here
and I can't make that any smaller so
what I've done here is I made a few
examples in node they're quite simple
and this first one is basically putting
the the logic we did for splitting full
names into into JavaScript so you can
kind of see here that the things that
you learn and these libraries that you
learn in c-sharp it's not wasted it's
not wasted knowledge that's sort of that
sort of DSL over sequences is widely
reusable across languages it might look
a little bit different but the ideas and
those concepts are the same so if you if
you go looking in JavaScript you can
find a library called lodash which will
give you those that DSL over sequences
if you go to F sharp you've got the same
sort of thing there if you go to Scala
you've got the same sort of thing there
if you go to Haskell again it's the same
sort of thing so this these are these
ideas and these and these knowledge is
you know you don't lose it when you move
from one platform to another so
javascript tends to come with a pretty
anemic standard library you don't get
much out of the box but that's where the
open source community is sort of stepped
up and there are lots of libraries that
you can pull in to fill in the gaps so
if we want this sequence we want this
DSL over sequences of values this is
where a library called lodash can come
in and save the day so lodash is sort of
the successor to a library called
underscore which was called underscore
because it used the underscore and then
lo - they played on the name and and
that's how they sort of got the lo -
name so in this particular example what
we're going to do is again do this
support this full name splitting so
we're going to split both by string and
in this case we don't have that overload
to just eliminate empty strings for us
so we'll just do a filter ourselves by
hand to get rid of the empty strings
then we'll create an object with those
properties and you'll notice that again
we're using underscore dot and we've got
those very similar functions that we had
in link we've still got them in
JavaScript so in this case we can call
first on our array of names and it will
return the first and I think it returns
undefined if that is empty so that's why
we use the basically a truth a check to
fallback to null because I'd rather have
null
undefined' here for surname we've got
ternary expressions in JavaScript so we
can do the same sort of thing here we've
got a last so we can call that now for
middle name it's a little bit different
so JavaScript in c-sharp aren't the same
obviously so in c-sharp to compose
functions nicely we use 10 to use
extension methods in JavaScript there
are a number of ways of achieving the
same sort of thing so in this version of
lodash there's a function called chain
which they're basically implemented
which what we'll do is you give it the
input to your chain and function calls
and it returns some objects which you
could continually dot off of and build
up that set of operations so in this
case we start out with chain we do a
drop to skip our first one so notice
it's drop rather than skip but it does
the same sort of thing take we do a join
and then value is how we sort of exit
out of that chain and get our final our
final value out of it so if I run this I
can prove that it does work so it runs
and you know splits up our names as we
expect so you can kind of see here that
we're also able to lift our level of
abstraction up and write declarative
code in JavaScript as well
now the lodash team have this is the
sort of code that you might write if
you're using a slightly older version of
lodash if you're coming in new you'll
probably use the latest version which
case they've got a slightly different
way of composing functions because what
they realize is when they implemented
chain is that the way chains implemented
requires them to basically pull in all
of lodash in to require the whole thing
in now when we're bundling up our
JavaScript and sending it to the sending
it to the client we want to try and keep
our bundle as small as possible so we're
not you know using up too much bandwidth
and we don't want it to be slow so the
lodash is kind of a kitchen sink of lots
of different functions so if you only
use a small subset of them why send all
across all the ones you're not using so
they didn't really want you to have to
require in all of lo - they just wanted
you to be able to requiring the bits
that you wanted and chain didn't let
them do that not in a clean and easy way
so in low - 4 they implemented an FP an
FP sort of module where you can
individually require in functions you
want you don't have to but even though
if you're trying to keep your
keep your bundle size down then this
does help so you can see here I've
required in all the same functions we
were using before but this time the way
we compose them together we don't use
chain we use flow instead now flow is a
function which basically takes multiple
parameters so JavaScript being dynamic
we can pass as many parameters to a
function as we want and it can figure it
out later
so you basically just pass as many
different functions to flow as you want
and then flow returns itself a function
which you call with the input to your
chain of functions so again here we're
just calling drop take and join but it's
a bit weird this time because you know
we're not dotting things together we're
sort of calling drop and then it returns
something which goes into flow and
somehow magic happens so let's see how
that magic works so what what the low -
guys have done is they've basically
picked up a technique from functional
programming land called function
currying so here's an example of an
uncrewed function and these are what
we're typically used to writing in
c-sharp and JavaScript basically
functions that have more than one
parameter right so there is an example
of how you'd write drop in that
unpowered form so you'd have count and
array as to its distinct parameters on
the function if we were to carry this
function we need to be able to reduce it
down so the function only ever takes one
parameter at a time so my drop down here
is the curried version of that so it
takes one parameter the first one count
and then returns a function that takes
the next parameter array which when
invoked does your action so you know
that's kind of how they split up those
multiple parameters into into functions
that each take one parameter at a time
so down here you can kind of see how
that's how that's um invoked so you call
my drop with the first parameter it
returns a function you invoke that and
you know if things happen so that's
what's happening up in here when we
compose together our function so we're
calling drop one here and that what
that's doing is returning a function
that when given an array will drop one
thing from that array and return an
array and then take is returning a
function that when you give it an array
it will return an array so what Flo is
basically doing it's very simple it
returns a function that when you give it
an array it will pass that array to the
first function here that function will
take it return something Flo will take
the return value from the first function
and pass it to that as the input to the
second the second function will do
something return something Flo will take
the output from that passes the input to
this and so on and so forth so you can
basically flow together many functions
into a single larger function so this is
this is basically how functional
programming languages do functional
composition they compose together these
functions into a wider function and
that's exactly what Flo is doing so Flo
here all of that expression is returning
a function that is the the composition
of those inner functions so another
interesting thing about the way this is
done is you can introduce your own
functions here so if there isn't one in
that bag and there probably is because
lodash has a ton of them so always look
in there doc to see whether there's
something that does what you need before
before writing your own but if you want
to you can actually put your own
functions in here and they can just
participate because this thing just
composes together any old functions so
if I put in the one I implemented below
and run this it'll work just fine even
though it's not a function that was from
from lodash so if I switch over to this
example this is another good example of
where if we were to write this code in
an imperative style we'd end up having
to write a bunch of state management
code when really we just want to state
what we want and get it so this
particular example we've got a list of
users they have email addresses and
names and what we want to do is write a
bit of logic that figures out whether or
not an email address appears more than
once in this list of users so maybe we
can put a warning up in the UI and say
hey you've entered the same thing in
twice so in this particular example what
we're going to do is we've pulled in all
of lodash FP so you know I can't be
bothered pulling it in each of the
functions by hand here so I can still do
the same underscore dot and get my
functions so we're flowing together a
number of different functions here the
first one being count by
and what that's going to do is it's
going to take our list of users and then
it's going to run our lambda for each of
the users and the lambda is going to
return some value which count by is
going to count the number of times that
value turns up so in this case what
we're doing is we're returning an email
address which we're lower casing and
trimming so that if there's different
casing we ignore it if there's trailing
spaces we fix that up and it will count
the number of times that email address
shows up and whatever we do is in a very
JavaScript fashion it will return object
so it won't return an array it'll return
an object where the properties on the
object the property names are the email
addresses and the property values are
the the counts the number the number of
times that email address is turned up
so then what pic buyer will do is pick
by will take an object and it will
filter the properties on that object so
it will call this lambda with the the
name of the property which in this case
is the email address and the value of
the property which in this case is the
count and allow us to basically filter
off properties we're not interested in
so in this case we're saying okay I only
keep the properties we're only keep the
email addresses where the count is
greater than one because we want to look
for the duplicates or the triplicates or
whatever right then we can flow the
output of that which will be in the
object with only the duplicate email
address properties on it in two keys and
what keys will do is only keep the
property names and return them in an
array so effectively we're passing in an
array of users and we're getting back an
array of email addresses so I can run it
and we get back out a duplicate email
address from our list so if you think
about how you'd implement that
imperative lis it would be a lot more
gross than that so you basically have to
do something where maybe you'd loop
through your your your list of users and
you take each email address and you put
it in an array and then as you did that
you'd say well there's this thing
already in the array if it is then put
it in another race so that we can return
that with because it will contain the
duplicates either there's a lot of this
basically passing around in state
management that when we work at this
high level of abstraction we work with
these D cells over sequences you know we
don't have to do that instead of writing
how to get what we want we want to
declare what we want up front so we want
to use that declarative programming
style
what's an interesting here is that we
can actually shrink this code down into
an IVA short even shorter form so what
we can do here is we can actually
eliminate this function all together
because all this function is actually
doing is just taking users and passing
it to whatever flow returns so that's
that's a bit redundant if we want to we
can actually shrink this down even
further so if we get rid of the function
body and put our equals there get rid of
our return and all we're doing here is
we're just keeping the function that
flow returns and that is exactly the
same code as what we had before so when
I run it same output so you know we can
shrink that down even further which is
nice alright so what we've looked at so
far is DSL over sequences of values and
sort of some DSL DSL function over
dealing with nala ball types so now
let's let's shift gears and look at a
different type of DSL that can help us
so if I switch over to a different
folder let's go over to rxjs
what we're going to look at is a use of
a library called Rx which you may or may
not have heard of our Rx is pretty cool
so what we've looked at we've looked at
a sequence overvalues is you know we've
looked at something where the sequences
are pool based so when you when you
iterate over like for example an array
and think about a for each loop you're
basically saying give me the next item
give me the next item give me the next
item and then maybe you quit out earlier
with a break or something like that but
you're in control you get to say when I
want the next value sequences of events
are different right so you don't
necessarily have control over the source
of those events so if you think about
maybe a map a user moving their mouse
across the screen and as they move their
mouse events are firing with the XY
positions of their of their mouse
coordinates you can't control how the
user is moving their hand they get to
move the hand however they like there's
just firing events and you effectively
have to catch those events and handle
them as they come in so you're not in
control
the sorts of events you basically
receive them as they get sprayed at you
so secret when you're dealing with a
sequence of values you don't have to
worry so much about time you're in
control but with sequences of events you
do have to worry about time and writing
imperative code to deal with timing is
hard this is where our X could come in
handy because not only can it deal with
sequences because it's it deals with
sequences of events but it can also deal
with timing of events and that's super
useful because when you can just
declarative loose a deal with time for
me it makes your code so much more
simple so I've got a couple of pretty
neat examples of what that could do for
you so in this particular project it's
just a little node server a little node
Express server that's running some stuff
and a little angular app so I am I going
to go into the Express and angler stuff
it's not really the point we'll just
look at the RX stuff so if I switch over
to the website okay so the first example
is a pretty typical one where we've got
a user driven search page so here what
we've basically got is a text box they
can type into and then because we want
to keep our user experience nice and
live we basically do searches as they
type as opposed to wait till they're
finished and then have them press a
button to execute the search we want to
keep that nice you know fast user
experience so you know to implement
that's not exactly hard you just do
requests as they type but there are some
subtle there are some subtle bugs that
can come in when you just do it in a
naive way so one of the interesting
things about asynchrony is that things
may not necessarily come in the order
that you expect so as the user types in
to this box and we're sending out HTTP
requests there's no guarantee those
responses will come back in the same
order that we sent out the requests
because you know a request one a request
may take longer than another maybe the
network got a little bit slow maybe that
search is a bit more expensive maybe
your servers a bit more under load
there's no guarantee there so you have
to be able to deal with that but when
you write a naive implementation like
what's on what's better code that's
backing this particular page you can get
yourself into some strife so when I type
into this box and I type the term slow
in that particular request I'm on the
server side I force that to be quite a
slow
and then the words slow fast that result
will come back quickly and we'll see
things come back out of order so as I
type this we can see the responses
coming back we've got our seventh zero
indexed and then suddenly we flip back
to our third response and it's
overwritten our later response and now
we're showing the wrong search results
on the screen this is actually more
common than you'd expect I think the
latest place where I saw this turn up
was on the power website if you go there
and type into their package search they
have this issue where sometimes if the
things come back out of water you get
stuff coming back and overriding your
search results which is a bit annoying
now let's have a look at the code that
that implements this so this is a bit of
angular code if you don't if you're not
familiar with angular don't worry too
much about it it's pretty typical
basically the scope is a view model on
which you put things and then the view
can bind to the stuff on the scope and
you can also put functions on the scope
that the view can basically call when
things happen so in this case what we're
doing is we're setting a search function
on the scope and that search function
will be invoked every time the user
types into that textbox so effectively
for every key press this search function
is going to get called this search
function what it will do is immediately
bundle up their search terms and then
call you know do an HTTP request to our
server side pass those parameters
through and then this particular
function will return a promise which
allows us to hook a call back in to
receive the response asynchronously so
this is our callback here we'll receive
our response we'll just grab the results
and put them in the scope so that you
know they're displayed on the screen but
the subtle bug here is a timing bug
where you know these responses there's
no guarantee that these callbacks will
be called in the same order that we
actually sent out those requests so we
need to we need to be able to solve that
that timing issue now we could do that
by hand by you know putting it put in it
capturing an index using the closure and
then making sure the index that we could
see here is you know make sure that it's
not you know less than the one that
we've set somewhere else and we do all
this munching and state handling but
that just makes our code more
complicated and again we're stating how
to get what we want rather than just
what we want
we want to lift our level of abstraction
up and in this case we can think about
our problem in terms of sequences of
events and we've got a library on hand
that it does allow us to lift that level
of abstraction up and and write
declarative code over sequences of
events so let's have a look at the good
example so this one is basically the
same code but instead rewritten to use
our X so our X is available across
multiple platforms it's in JavaScript so
there's rxjs and there's also our
excellent Nick because that's kind of
where it started it and I believe
there's ports for our X for the JVM and
a whole bunch of other platforms going
as well so I'm also using a library
called rx angular which just provides a
little bit of glue between between
angular and rx just to make things a
little bit easier so one of the things
that Glu provides is this create
observable function function on the
scope and what will do is it will put a
function in this case called search just
like we had before on our scope object
so it will this thing will mutate the
scope which is a bit weird and then it
will return this observable sequence so
this search observable is and is a
sequence of events it represents a
sequence of events so just like before
that search function is put on the scope
and then we've got something in the view
which basically will call that function
every time someone types which means
that our search observable represents a
sequence of events of the user typing
right so as they enter it keys into that
into that textbox we're going to get
events firing down this pipeline right
so then what we're going to do is we're
going to use like our functional
Combinator functions here so we're going
to use flat map now flat map in link is
called select many so there's not too
much scary there so what it basically
does is it takes a sequence of sequences
and then flattens it into a single
sequence so here our outer sequence is
our sequence of keystrokes effectively
and our inner sequence is HTTP requests
so you can you can imagine HTTP requests
being a sequence if you think about them
in terms of the event of their response
their response
arriving so they end up being sequences
or one event where the one event firing
is the response but they are a sequence
nonetheless and that's the way our ex
allows you to do things so you can
actually in here what I'm doing is I'm
just returning that inner sequence which
is that HTTP request and that's a
promise and Rx is smart enough to look
at a promise and go oh this is a promise
cool I'll just treat that like a
sequence of one event so after this code
here has evaluated what what we
effectively have on hand is a sequence
of responses now but what's interesting
here is we've actually used flatmap
latest and this is where our X's ability
to deal with time comes in super handy
because flat mount pilatus not only
flattens a sequence but it also deals
with time and it says that if any
earlier in a sinner see like any events
come back just throw them away if later
things have started so this will just
straight away solve the problem and any
requests that come back out of order any
earlier earlier made requests whose
response comes back after a later
request has already gone out those will
just be discarded automatically by our X
so this here is basically how we take
our sequence of responses and then
effectively handle each of those
responses so safe apply is something
that our X angular gives you so that you
can hand it the scope so that it can do
all the angular munging of apply and
digest and stuff to make sure that when
you update your view model the view is
rebound and so on and so forth so here
we're basically just taking our
responses just like whoever before
assigning them onto the onto the scope
and and we're done so on the very last
time you do subscribe and that's
effectively what activates your pipeline
and starts you listening to that
sequences that sequence of events so
straight away we can see that you know
this is this is not a huge transform to
the code we had before in fact the main
structure which is basically this stuff
right is pretty much intact and this bit
here as well and we've just changed how
we've composed it together to use our X
instead of you know doing it by hand and
because our X does allow us to work at
that high level we can we can get free
stuff like flat map latest so let's have
a look at
how this will work now that we've got
this new code so if I type this in we
can see the right response comes back
and then if we wait a few seconds there
won't be any other requests coming back
and stomping on my current results so
let's just solve that problem straight
out of hand now because we're sort of
working in this functional declarative
style we can add new things to this
quite easily in a in a very safe way so
you'll notice here you know this is
quite an efficient for every keystrokes
that I did I sent out a request so I
sent eight requests here been really you
know one or two - effaced
so we can solve this very easily by
using our X now if you think about try
and think in your head how you do that
if you were doing imperative code you'd
have to write a whole bunch of state
management to say oh how long has it
been since the last time that the user
put a keystroke e and has it been long
enough and if it has then send request I
don't want to do that you don't want to
do that we just want to use D bounce and
D bounce we can just compose it in
straight there and what this is going to
do is going to take that sequence of
keystrokes and then transform it into a
sequence where it will only allow events
down the pipeline once the pipeline's
been quiet for 200 milliseconds so if no
event has come down the pipeline for 200
milliseconds it'll like it'll let only
the last one through so that way the
basically throttles our our rate of
events down this thing so if I now fresh
this guy and type in here we get run
request rather than eight and it was one
line of code to change that so you know
those are the sorts of advantages that
we get by working at that high level
abstraction and leaning on these
libraries to allow us to program
declaratively so I have a final example
here which is one which does a bit of
polling so here what we've basically got
is a little page which pulls the server
for State so on a previous project that
I worked on you know we basically built
an application form where the user could
enter in a whole bunch of details and
then eventually submit the thing and it
would go off and be processed async
I see on the service side so that
processing may take a few a few seconds
so we basically drop them onto a Status
page where we live showed them the
status of their application as it moves
through certain states so you can
probably see where the source of that
state change example came from so we
knew that it would probably only take a
few seconds for the full process to
complete so we wanted to keep that UI
pretty alive so we just polled pretty
quickly and but we knew that sometimes
third-party services got slow and when
they did there's not a lot we could do
about it you just had to wait so we
didn't want to just pound the server
every second while this thing sat there
for maybe a couple of minutes because
that's just wasteful so what we wanted
to do is basically slow up holing down
so that we you know eventually we were
only pulling every 10 seconds so we kind
of set up a little polling function
which basically allowed us to poll every
one second ten times when the page first
loaded then every four seconds ten times
and then every 10 seconds until
eventually we got into the state we
wanted in which case we didn't want to
poll anymore because we've moved into in
this case I simplified it down to just
loading and complete so once we're in
that completes state we don't want to
poll anymore because we're done we don't
need to so we want to stop pulling in a
certain point so we sort of hold fast
slow down and then slow down further so
if we go to the code what we've got here
is how we construct that so the nice
thing about working with sequences of
events is that we can actually write
this declarative code so if you think
about polling that is just a sequence of
events it's a sequence of clock ticks
right so we can model that so what we
can do here is use our X so in this
first line our x observable return is
going to create a sequence that fires
one event because what we want to do is
basically fire immediately so I you know
we wanted we want to poll once a second
ten times but first we want to send one
amelie we don't want to wait one second
so this gives us the sequence which
fires once immediately and the value
that gets fired down this sequence is
null because I don't actually care what
the the events are in this case all I
want is the timing and for them to drive
something so then to that sequence we
simply concatenate
another sequence in this case we're
going to concatenate a sequence where
we've ticks every one seconds that's
interval a thousand and then that's just
a sequence so we can say take ten and
that just limits it to note you complete
after ten then we concatenate to that a
sequence of ticking every four seconds
ten times and then to that a sequence of
ticking every ten times into infinity
because we haven't limited that with a
take so that will just continue ticking
every 10 seconds until eventually we
want it to stop so that gives us our
polling observable which is our sequence
of events that will tick in that
behavior so we'll take that polling
observable and just like in the previous
example what we're going to do is we're
going to use flatmap latest to basically
hook onto that and do our HTTP requests
so again flatmap latest to make sure
that our responses if they do come back
out of order
just it to take take and care for us
then what we do is we take our safe
apply and you know as the responses come
in we apply those changes to this to the
to the scope so that we can see them in
the UI so we take the state and put it
in there and now interestingly what we
do here is we look we look for the
completed state and if we have completed
what we do is we take the subscription
that comes out of doing a subscribe so
if when you do is subscribe back from
that you get a subscription and if you
want to stop listening what you do is
you take that subscription and you
dispose it and that basically stops
listening so in this case once we've
headed complete once we've hit completed
we don't want to listen anymore so we
just dispose our subscription and we
stop ticking and we stop doing our HTTP
request and polling the server so let's
have a look at how that works in action
so let's refresh this you can say that
this is ticking up once per second and
then after 10 seconds it will slow down
and start doing it once every 4 seconds
and then over on this other tab I've
basically got a that's gone to the 4
second stage now over on the other tab I
basically got something that lets me set
the complete on the server side so let's
set that completed come back here it's
already picked it up we're now completed
we're not pulling anymore these numbers
won't change so we've been able to write
something that if you were to try and
write that sort of timing logic declare
by hand using imperative style code
would be pretty hard but when we're
programming functionally and we've
lifted we're lifting our level of
abstraction up and writing declarative
code code instead you know and we use
the right libraries things like rx we
can write this sort of complex timing
logic in a really simple clear way
that's very understandable for other
people to read and therefore quite
maintainable okay so that's the last
coding example so we'll just click back
to the slides and wrap up so what we've
seen today is how we can apply
functional techniques to solve
day-to-day problems functional
programming features are present in our
modern imperative languages and new
versions of these languages tend to
bring more functional features so we
sort of saw how that c-sharp added that
conditional member access and obviously
way back when it added lambda functions
and JavaScript itself has actually added
arrow functions relatively recently so
arrow functions they're named for lambda
functions you might have seen one of
those in the examples I put one in there
so you know we can see that these
languages are pulling in these
functional features over time so that
should give us a bit of an indication of
you know the way things are heading
functional techniques techniques do
allow us to program at that higher level
of abstraction we program declaratively
and we state what we want rather than
how to get what we want we eliminate
side-effects from our code because we
program with expressions rather than
statements this makes our code shorter
more readable and therefore more
maintainable the code does look a bit
different but it's not impossibly
different it doesn't take long before
you find that style of code natural to
read it's a similar step forward that
the unstructured programmer took when he
abandoned the go-to for the for loop
obviously there's a lot more to
functional programming than what we've
seen here this is just sort of the tip
of the iceberg but this is a great way
that you can get started in your current
code base and reap some real benefits so
once you get your toes wet I think
you'll quickly realize that programming
functionally isn't that hard after all
and you're going to want more of it
so the slides and code for this are
available up on github there's a link
there so feel free to go check them out
and have a look at how things are done
in more detail and if you have any
questions please do ask them now or if
you want you can talk to me after the
session or if you see me around or
Twitter or whatever so if you have any
questions please do pop your hand up yep
yep so in order to do that what you
probably end up doing is putting
composing another function in there that
just for example prints it out to the
console because you can easily compose
other functions in there the simplest
way to check that is probably just to
put you know a console out in there or
if you want stick a lambda in there and
then put a breakpoint in the lambda if
you've really got a if you've really got
to pause the execution and have a look
at everything there so you can hook into
it it is a little bit more awkward
because breakpoints are kind of just
sort of designed around imperative
step-by-step code so yeah it does make
it harder it's a bit like that in link
as well so sometimes it helps so if you
need to get into the middle of a like an
expression like that sometimes it helps
to just split the expression into two
expressions and then that way you can
put a breakpoint on the result of the of
the first half of the expression and see
what it evaluates to and then and then
once you've finished debugging just put
it back together so that that's often
the simplest way to to get a debugger
into that expression and see what's
going on anyone else
so yes if you're using f-sharp you will
get currying so f-sharp is is that's
part of it the way it does functions it
will carry things automatically for you
and it's got the optimizations to make
that that fast on the.net runtime
c-sharp I don't think so you could do it
yourself but to be honest I don't think
the coded it you'd end up the code it'd
be pretty ugly to do it like you could
do it but I don't know whether on the on
the whole that would actually make your
code more readable or less readable so
it's sort of a double-edged sword there
I think if you're gonna if you're gonna
really embrace that sort of thing I
highly recommend you look at f sharp
because it does it is a dotnet language
so you can still get all the nice things
that you've got in dotnet and stay there
but you then do get a fully functional
language which can do these things for
you so you get occurring for free and it
just deals with it which is cool yep
if you're doing like really really
highly performant stuff you'll probably
find it a bit slower because yeah you
are incurring additional function of
calls there and there are there is a
little bit more like bookkeeping going
on I know the I remember reading about
the resharper guys and there they were
using link all over the place in their
codebase and of course resharper needs
to be really fast like really fast
so they actually had to go and unroll a
few things and do it by hand because it
was a bit slower so yeah in those cases
if I were you what I would do is what
they did which is basically implements
it with link and a nice way first and
then if you find that it is causing
performance problems down the line then
unroll it invited imperatively but I
think it's unwise to try and prematurely
optimize by just going out I'm not going
to touch that because in most cases
that's not where the bottleneck in your
code is going to lie in most cases going
to be somewhere else like a database
query or something else it's not
normally that bit of the code but look
if you are writing code that is that
bottleneck does like that then yeah it's
gonna be a little bit slower but this is
where other languages like things like
Haskell where it's built for that can
optimize for that and it's a bit faster
in those languages so sort of you you
pay a cost figure readability in
something like C sharp and F sharp so
anybody else know okay cool thanks guys
thank you for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>