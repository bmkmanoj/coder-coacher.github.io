<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional Design Patterns - Scott Wlaschin | Coder Coacher - Coaching Coders</title><meta content="Functional Design Patterns - Scott Wlaschin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Functional Design Patterns - Scott Wlaschin</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/srQt1NAHYC0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this is functional design patterns
and principles and whether something is
a principle or a pattern sort of depends
on what your language is so I'm gonna do
this the language I'm gonna use is
f-sharp for demonstrating but the the
concepts work in pretty much any
programming language I of them maybe
COBOL certainly you know JavaScript or
Python or something so if you're using a
you know a language with these things
built-in then there'd be principles and
if they're not built-in there's a
pattern so whatever you want to call it
okay so my name is Scott blushing just
my Twitter handle and can you see there
on the screen just fixing something here
there we go my name's Scott volution I
have a website f-sharp for fun and
profit comm which is if you can guess
it's about f-sharp and there you go so
let me before I get into a functional
programming patterns I just want to tell
you a bit about myself because a lot of
people think that functional programmers
are you know very academic and very
intellectual and stuff and that
certainly doesn't apply to me because I
used to be just a normal person this is
me in my childhood as you can tell I'm
pretty old this is a childhood photo
that's that's me down there was a family
holiday they didn't work out very well
and you know I was my first love was
actually small talk so I'm actually an
oo programmer I'm not like a pure
functional programmer and even the small
talk beeping this motor was real oh oh
by the way people in the Java oo that's
not real over so even the small talk
people would be snobby and they're a
tease the Java people and you know
enterpriser it's like shooting fish in a
barrel or marine vertebrates and an
abstract bowel proxy factory so we would
make fun of Java just like everyone else
does but they're not introduces some
functional programmers
and this is what they look like and I
especially captured by these people and
taken away to an ivory tower and
actually they put me in the ivory tower
the Haskell people actually have at the
very top of the RV tower they're sharp
people that's me we're on the second
floor the Visual Basic people were down
at the basement the list people like on
a completely different planet so anyway
so I've come back from the Eiffel Tower
thumbs up from the ivory tower and I can
now say with a straight face all these
weird functional programming things like
you know omona and it's just a mono din
the kabuna functors and yeah that's yeah
it's easy what's the problem you know so
this is what's really off-putting to
functional program people so I will not
say this in this talk except maybe at
the very end so there's going to be a
very easy beginners talk on functional
programming so if you're an expert
already if you were to understand that
you know that I find this interesting
but I promise I won't use any weird
words so design plans this is what we
were taught in the ivory tower okay so
you know all these low design pans from
the Gang of Four and this is what we're
taught it's the functions you know
open/close principles do that with
functions dependency inversion principle
functions functions
you know functions functions and
functions so it's and this is true by
the way
the problem is functional patterns are
different the real thing is I'm not
trying to put down our patents because
the function of people have their own
patents and anyone who says they don't
is fooling themselves it's just they're
very different so it's true that you can
do the strategy pattern with functions
but the functional people you know have
to do monads and they have to do other
patterns in the program so that's
basically what this torts going to be
about so I'll talk about some this is
the basic outline of the talk I talk
about some core principles functions as
parameters which just solve the key
functions as functions and functions
everywhere well then I'll talk about
continuations and partial application
which are really really important
then I'll talk about manners and
hopefully I won't if you can all kind of
haven't do a mass exodus at that point
but how monads are useful that everyone
thinks about - about Wyatt why why do
people go on about monads all the time
I'll talk about maps how you deal with
data that's been wrapped up like things
like lists and so on and then I'll talk
about mono AIDS
that's another mathematical word and one
of the problems with the functional
programming world is that all the words
that are used all kind of mathematical
words you know monads and modes and
functors and sounds really confusing
them complicated and kind unfortunately
the math addition sort of got there
first the actual concepts are really not
that complicated it's just you know if
you just get your head past the words
being strange the fundamental concepts
are pretty straightforward so some of
these things will be patterns you know
if you're doing this in JavaScript you
don't have monads built-in so that would
be a language pattern if you're doing
Haskell monads built-ins it's not yes
just a fundamental thing yeah all right
it's gonna be one of those tours where
you whiz round you know you see all the
sites in like five minutes
you don't really get a chance to stop
and visit probably there's no way you
can understand everything in this in an
hour it's really just like I say so
super fast or you can say look I saw
this I saw the Eiffel Tower
you know I saw Big Ben or whatever I can
come back later and actually spend some
time if it looks interesting so I'll
show you what they look like if you
think it's interesting you can learn all
about it later on so don't worry if you
don't understand everything there's no
way you could understand it all right so
let's start with some core principles
most important things to understand
about functional programming first all
functions are things we think in the oow
world we differentiate between methods
and data in functional programming
they're just things like everything else
composition everywhere so a composition
like Lego gluing things together to make
bigger things so no inheritance no
onions that's just like composition
everywhere you'll see and then types are
not the same thing as classes nowhere
it's more like sets
and it turns out to be quite useful in
some ways and we'll talk about that so
let's talk about functions as things so
here's a function and I like to use this
kind of railway track analogy a lot so
here's a little piece of railway track
and there's little tunnel on it and
something comes in like an apple goes in
along the railway track and it comes out
of the tunnel that's a banana right and
we would say this is a function that
turns apples into bananas right and we
like this Apple our banana that's your
function it's a standalone thing it's
not attached to it it's not a method
it's not attached to class it's just a
thing so here is how you might define a
normal thing like is there a equals one
and you know the compiler makes this a
box and it puts the one in it and it
calls it said I guess you used to that
in a functional programming language
like F sharp you say here is a function
let add of x and y equals x and soy and
it basically meant that good pilot makes
them but a railway track but what's
interesting is the same word is used let
in both cases and that basically defines
something and it's not coincidence the
same word that's used because defining a
function and defining a simple thing not
that different I mean you sort of
interchangeable functions are things
just like integers and strings as on so
functions are things they can be used
anywhere a normal think amuse so they
can use be used as inputs and outputs
for example so here is a function that
returns a function now don't worry about
the actual chef sharp code but look at
the pretty pictures instead so there's a
piece of where we track the input
there's a normal integer where the
output is a function there's the
function there or here's a function
which has something as an input a
function is the input and the output is
an integer or here is another example
which is a some sort of transformation
thing it takes an integer as the input
it's a bit certain just output but
there's an extra thing an extra
parameter which sort of controls how it
works my strategy if you want so
functions as inputs functions out sports
functions as parameters that's it
once you understand that concept a lot
of the complexity is basically you can
see and get really complex stuff
building from this right you can have
functions that return functions that in
turn return other functions that have
functions of family you can't get
complicated but the basic principles
that that's it that really is it there
are no you know manager classes and
though factories know you know whatever
that's really all it is
okay so composition composition
everywhere here we have two functions
and one is an apple - banana function
another is a banana cherry function and
I want to glue them together what is the
obvious way of gluing them together well
I take them and I kind of stick them out
I take the output of one and I glue it
into the input the other and what we
have now is a new function which is an
apple to cherry function that's
composition that's all it is just gluing
two functions together to make a bigger
function but there's a couple of cool
things first of all this new function
you can't tell it was built from small
functions it's now another function and
I can then take this function and glue
it with other functions to make an even
bigger function and the cool thing is
the banana disappeared weight of the
banana go there was a banana originally
and it's not there anymore so this is
how you kind of get encapsulation right
the the the low-level code cares about
bananas but when I've built up a high
level piece of code the bananas have
disappeared and all I care about is
apples and cherries so when you're
designing this composition its functions
all the way down let's say you start
with some low-level operation like upper
casing a string it takes a string as
input it and spits the string as output
okay that's a very simple function but
then we take a bunch of these kind of
low-level operations and we glue them
together and we get like a service like
an address validation service okay where
you the input is an address and the
output is some sort of validation result
and for the min alleles unused I mean
some people might know know what a
service is right because you might be a
millennial a service is just like a
micro service but without the micro in
front
no I they take me services you clear
them together you get a particular whole
use case like updating your user profile
or something on a website requests comes
in and the result comes out and then you
take all these use cases and you stick
them together into a web application and
the input is an HTTP HTTP request and
the output is an HTTP response and
inside now you have to have some sort of
switch where you decide which use case
to run you know a controller or a
dispatcher or whatever you want to call
it so you can see this kind of fractal
composition you build big things out of
small things that's the fundamental
principle of functional programming all
right another one types are not classes
and now we're talking about statically
typed function program here so not
JavaScript or closure but F sharp and
has two one so on so what is the type if
it's not a class the type is just the
name for a set of things that can be
used as inputs or outputs so here we
have a function it's got a set of inputs
and set of outputs if a set of inputs if
you take all the integers all the
possible integers and we say this is the
possible inputs for this thing we call
that the type integer here is the type
of all strings all possible strings we
call that type string okay so it's just
a set it's a it's a set of data
there's no behavior right they're not
objects it's literally just data and of
course there can be more complex here's
a set of people we call this type person
here is a set of fruit we call that type
fruit here is a set of functions which
take fruit to fruit so these are fruit -
fruit functions and that is a type as
well so you can have type functions can
be types as well so that's all the type
is but types can be composed now this
fact that the types don't have any
behavior it's just pure data that means
they can be glued together it's hard to
glue objects together because when you
glue them together how do you what do
you do with the behavior this object has
this behavior in this one has this
behavior and how'd you handle it if they
just peeled 80 that doesn't that's not a
problem so this idea of gluing types
together to make bigger types
that's what we call an algebraic type
system or a comparable type system and
again composable like lego so how do we
glue types together well there's two
ways of gluing types together there's
only one way of gluing functions
together but there's two ways of doing
types and the way is and and or alright
so what does that mean and again it's
only possible because of the separation
of data from behavior so an an type
let's say that you want to make some
fruit salads and you have an apple and a
banana and show you right so I take one
of each and I make them stick them
together and I have a fruit salad okay
that is an ending together and this is
your very copious is a very common thing
even in other languages it's like when
typical is a record type iOS trucks and
in F sharp we'd write it like this it's
an apple and a banana and a cherry the
Apple is of type apple variety and then
bananas of type and on a variety and so
on so far this is just what you'd call
the record DTO or something like that
very simple but there's a different way
of doing it in F sharp which is not
available to you in C sharp and that's a
choice or an oo type so if you have a
snack you could say it's a apple or a
banana or a cherry and that's not
something you can easily do in C sharp
or object or languages and we'd write it
like this
a snack is either an apple so the
vertical bar is the kiss the clue here
it's either just like an or is like a
vertical bar in promo now who knows or
an apple or a banana or a cherry and
this turns out to be an incredibly
useful concept for domain modeling I
don't know if anyone came to my domain
modeling talking it this morning but I
talked about this a lot because it's
like really powerful thing alright so
let's see how we do composition with
types this is that's kind of a silly
example let's do a real world example
let's say that you have a payment
processing system and you take three
kinds of payments let's say you take
cash and check some credit cards and
depending on the type of methods we need
to have different kinds of information
like if you take a credit card you need
to have the credit card information and
so on so how would you implement this
well in an object-oriented language like
C you'd probably have something like a
interface or a base class and then you'd
have a subclass for cash and a subclass
for check and a subclass for credit
cards and so on right and each of the
subclasses would have that extra
information now in F sharp we would
compose this over to we build up a thing
from more more pieces so we start off
with the kind of primitive types with
check number and a card number say and
then we say ok a car type is a Visa or a
MasterCard so we're using the combiner
and then we say a credit card
information is a card type and a card
number so we've got a composing by
adding together and then say ok a
payment method is a cash or check or a
card doing or and then okay payment
amount is a decimal and a currency is an
or it's either euros or dollars so and
then finally a payment is a record it's
an around and a currency and our payment
method so what we've done here is we've
built up purely by composing smaller
types we've built up quite a useful
complex type in you know 15 lines of
code this is really nice this is why I
think for domain modeling functional
language is really great ok
all right so that's about the Fencibles
now let's talk about our first pattern
here which is using types to help us
design functions better and this is
designing for totality that sounds
interesting so what do we mean by that
let's say we've got a very simple a very
silly function 12 divided by okay it's
not it's not the function of error
actually used in practice but it's good
for this demonstration I don't want to
make it too complicated so 12 divided by
I'm gonna write it kind of in a pseudo C
C sharp star so basically if the input
is 3 we're going to return for if the
inputs 2 we're going to turn 6 if the
inputs 1 we're going to then 12 and if
the input is 0 what are we going to
return all right so that's your first
question what happens if the input is 0
well typically people are just like I'm
going to throw an exception invalid
argument right now if I look at the type
signature it says that you give the
input is an int and the output an int
right you could mean it I'll give you an
it back and that is they lie okay that's
not true because sometimes it will throw
an exception and it's not documented in
if I just look at this and I can't tell
looking at it and the Plumber is that
you've lied because you say you could
you told me you can handle any int you
said I exception in is input and if I
give you a certain kind of n you say
sorry I can't handle it it's like well
why do you even tell me you can accept
it if you can't handle it right don't
don't do that all right this is not how
this is the bat this is a bad way of
writing the function so let's look at
how you can solve this a couple of ways
to solve it first way is to put a
constraint on the input so rather than
saying weeks of any int I'll say I
accept a nonzero int ok and we'll have a
special type because it's just a set of
all known servants right and so it's
just a type or non servants and 0 is not
in that list so I don't have to handle
it in my switch statement all right so
it's always going to work it's never
going to give an error and if I look at
the type signature now it says you give
me a nonzero integer and I'll give you
back an int and that's true that's right
that's a good type sees there's never
done
no lie to me and it's also given me
documentation it says here's the
constraints you have to follow for this
function to work now where you how you
get an answer integer it's not my
problem that's somebody else's problem
though yeah but that's this is a total
function in always a never gives an
error here's another one you can
alternatively well then constrain the
input you can extend the output so
rather than saying you know I'll return
it end it's like well sometimes I will
turn into maybe maybe not so you know if
you give me a zero I'll say no I can't I
can't do it I'll give you back nothing
but if you give me a three I'll give you
back something if you come here - I'll
give you about something
and so this is what in F shall we call
this the option type you see there's
something or nothing so again if I look
at the signature it's like you give me
energy
and I might give you back an integer
again it's telling me the truth it's
acting this documentation and it's not
lying
so total functions are really important
part of it's a really important
functional this whole concept of using
types like this I've used you know the
nonzero integer type and so on using
static types for the main modeling is
really fantastic documentation and you
also get kind of compiled time checks
like I say if I can't pass a zero into
that function it won't let me only works
for statically typed programming
languages so sorry closure people on
solid JavaScript people big topic don't
have enough time to talk about it I did
talk about it early this morning or if
you're interested you can go to my
website if shot will find and prophets
slash ddd and i have the slides and a
talker
alright functions as parameters so this
is a really important principle along
with functions everywhere and functions
being used for everything another really
good tip is to parameterize everything
and let me show you what i mean by that
so here is a function that prints all
the numbers from 1 to 10 that's a very
exciting function now if you're a normal
experienced programmer you would look at
this and say yeah you've hard-coded the
numbers 1 to 10 in there what happens if
i want to do 1 to 11
right YV hard-coded that list and it's
like that's a good idea
let me pass the list in as a parameter
all right so now I'm going to pass the
list in as a parameter and for each
element in the list I'm going to print
the number that's much better and we all
think that's a good that's a much better
way of programming where if you're a
functional programmer you say yuck
you've hard-coded the behavior in there
too why why are you printing what
happens if I don't want to print what
I'm so I want to print something else
well don't hard-code that pass that in
as well all right so I'm gonna pass in a
function which is the action to take for
each element all right so now what we've
done is actually decoupled all things
the looping cup the looping action has
been decoupled from the the type of list
which has been decoupled from the action
I'm taking each element in fact this is
no longer printing a list this is just
looping through a list right so I've now
got completely generic list iteration
this would basically be it or something
I'll come over for each or something I
come over it is in the link and it's
really easy an f-sharp it helps if your
language makes it easy because I'm a
lazy programmer I don't want to have to
like type a hundred things and figure
out what the types are in F sharp you
can literally just put in the parameter
and the compiler will figure out what
the type is for you so you don't have to
type it this is very nice
let's look at a another example I say
have two functions one calculates the
product up to a certain number and the
other count places some up to a product
to a certain number now you can see
there's some duplicate code right don't
repeat yourself we all know about the
DRI principle let's not repeat ourselves
so how can we get rid of this duplicate
code so what we do is we focus on what's
different about each function and what's
the same about each function so there's
some common code there's the looping
code and the returning the last bit
that's the common part what's different
is that the initial value is different
each time and the action that you take
each time as you iterate through the
list it's different right so what we can
do is is get rid of the is is to extract
the common code and have everything else
be proud
so this is how you do it in F sharp in F
sharp it's called fold and so we've got
a parameter we've got an action
parameter and we've got an initial value
parameter and then we do it's basically
the same code as before we're going to
initialize the total value I mean the
total we're going to loop through the
list and for each item in the list we're
going to do this action with the
elements and then we're going to return
the total at the end okay and this is a
this is actually a built-in an f-sharp
function didn't have to write it but
what again we've done is we've got the
common code and we've parameterize
everything else the initial value has
been parameterised the action has been
prioritised what's cool about this is
when it comes to when you actually come
to use it if there's the f-sharp
equivalent the list fold function is
built-in and I don't have to do loops so
in F sharp it's really unusual to write
for loops you tend to use these kinds of
collection functions and what it does is
it allows you to focus on what's
important so what's important is the
difference in the initial value of any
action I don't care about the looping
code that's not relevant to how okay
what I really care is what is different
between these two things and by by
pulling those out as parameters it makes
it really obvious and in any decent
functional programming languages lots
and lots of collection functions like
this there's fold as mat there's collect
and reduce and the day so if you are
learning a function phone language the
first thing I'd do is spend a lot of
time learning the collection line B
because it's really useful and you'll
find out you probably know how to write
a loop ever again functions as
interfaces so functions these function
types like fruits food or intend or
whatever they provide interfaces for
free if we take a kind of c-sharp
interface like this I bunch of stuff
whatever it is I don't care what it does
if you take the single responsibility
principle which is only one reason to
change and you take the interface
segregation principle which is don't
make me depend on things I don't care
about if you take them to the extreme
you end up with the concept where every
interface should only have one methods
because otherwise you might have an
accidental dependency so let's get rid
of those two extra methods and now we
have in the face of the list it looks
like this
now this interface is just a function if
it's got one method it's really just a
function so this is a interface of
something that takes an int and a Spitz
happening and we do this all the time so
we tend not to use interfaces we tend to
use functions like this and but the cool
thing is that any function that takes it
in and spits out an int is compatible
with this interface all right so here's
add two or more times three these are
functions they take it in and they spit
at them in so they're compatible into
this interface I don't have to inherit
from an interface right I just say
they're compatible with this interface
and I can just use anywhere I see this
into int function I can pass in one of
these other functions right so after the
fact you can design things off a fact
without having to preemptively think
about what your interfaces are so let's
look at a strategy pattern for example
so here's the o type strategy pattern I
have a class I a dependency injection
with an i bunch of stuff that's the
strategy and so on you wouldn't do this
in a functional language what you do is
this you just pass the strategy and as
an extra parameter write that so the
strategy is just a function that you're
parsing and you've kind of little slot
for it there you pass in that extra
thing and now you've strategized the you
parameterize the functional with the
strategy and again anything will fit
anything will fit their strategy as long
as it's you don't have to inherit from a
bunch of stuff it's any into int
functional work right so you don't need
to create an into int function in
advance here's another one decorator
pattern so let's say have some function
like is even okay and it takes in an int
and it spits out a boolean
here's my little function done as a
railway into pool
now let's say that I want to log the
inputs and the outputs now I want to
everywhere where the original function
was I want to have the new function so
the new function hats are conformed to
the same interface it has to have an inn
to come in and a boolean come out right
so I write a kind of logger wrapper
round the original one where it loves
the input now but that's the kind of
classic a decorator model and there's a
little slot where I stick in my function
and there's the code don't worry about
that you know so I take my my in the
bottom part you can see I take that is
even function I pass it into this logger
function and it spits out the even the
log log version of that function that is
actually not the functional way of doing
it because it's not really using
composition let me show you the
functional way of doing it so I've got
my is even function and I want to log
the inputs and outputs so what I do is
I'd take my thing and I've stick
something in front and I'd stick
something behind
and I'd glue them all together and I get
a new function so this is much more this
is more a functional thing I have a you
know these little small pieces that I
glue together to make bigger functions
so my logging my logging version of this
is just like the log function composed
of the ease even function composed with
a lot of function that gives me a thing
and again it's completely compatible
this combined function it takes an int
as input and spits out a bull anywhere I
have the original function I could
replace it with its log function and be
compatible okay so all this Melway track
stuff problem is only works with
functions which have one input and one
output because otherwise doesn't work
right so that's a problem good news is
that every function in fact does have
one input and one output so every
function is a one parameter function in
a fractional primary language and you
think how can that be true what about
functions that have two parameters right
it's like that's surely that can't be
true so let me prove to you that it's
true so here is an odd function add and
it's got two parameters right now I can
also define it as a sort of a 0
parameter things this is defining as a
thing with a lambda so the adze is just
a lambda with two parameters right you
can do that see shortly what you can
also do is define as a one parameter
function which spits out another lambda
which is also one parameter
so this last one is a one-parameter
function that spits out another one
parameter function and you can actually
do this for every function so every
multi parameter function can be turned
into a one parameter function that spits
out another function and that function
in turn can be a you know if it's got an
extra proud of one parameter function it
spits out another parameter another
function and that in turn all the way
down until you get down to the end so
every complicated function can be
reduced into a series of one parameter
functions and that means that all these
tricks about doing well we try to go
that that always works and let's look at
a real example let's look at 3 which is
1 plus 2 there's some advanced maths
here and you can the pluses can be do it
in as an infix but you can also write it
as a as a prefix so these two things are
exactly the same so 1 plus 2 is the same
as as the plus treated as a function
with two parameters right same thing and
then we're going to do is we're going to
take the first two of those things like
that and we're going to like give it a
name we're going to kind of copy and
paste it into something else and give it
a name like that
I've got add 1 all right so it's
literally copying and pasting that code
now this add 1 is a 1 parameter fighter
you think is it missing a parameter well
it's sort of is but it's it's a function
this that needs an extra parameter to
add one you need to pass something to it
until then add one to it all right
so plus you can think of classes a two
parameter function or you think as a one
parameter function that was spits out
the one parameter function so I can take
this add one function that I just
created and I can pass it you know pass
two into it and it gives me three so
every multi parameter function can be
converted into it into one parameter
function like this and that leaves the
really important thing called partial
application so here is an example of
partial application I'm going to print
my name so the print function is two
parameters the first parameter is the
format string and
second parameter is the name I'm gonna
print okay so that's a two parameter
function but what I'm gonna do is do the
same thing I'm gonna put parentheses
around the first two bits like that and
I'm gonna pull that out and give it a
name and then call it hello now this
hello is a one-parameter function
because it's missing the extra the name
thing was missing but I can still use it
without the name thing and then I have
to provide the name later on does this
make sense yeah hopefully it makes sense
this is something that's hard to get you
head around if you're if you're new to
functional programming but you can see
it's really useful because I've I've
taken this thing I've now kind of made
it a Hello function I can use reuse over
and over so I can we use this hello in
many places for example if I'm working
with a list so if I have a list of
things there's a list of names and for
each name I want to say hello well I can
just iterate over the elements in the
list and call hello for each one now
hello is a function but it needs one
parameter and so that will be provided
as it loops those lists each parameter
and then it'll be passed each element
this will be passed in and here's
another example I can say add one and
define equals two and then they need an
extra parameter and that can go take one
one 200 which is the list I can take I
can map that which is the same as select
a link in which is adding one to each
one and then after that I can then
filter by the ones that equal to 2 and
so on so forth
so this is a really common way of doing
stuff in functional programming and by
the way that little vertical bar thing
with an angle bracket that is the F
sharp pipe operator it works just like
the pipe in UNIX where you just take the
output of you know you take the output
of this thing and feed it as the input
the next one so this is take the list of
ones or hundreds and feed it in to the
list map take the output of that feed it
into the list filter and so on so we use
that all the time to kind of create a a
pipeline again like gluing all these
railway tracks together you get this
pipeline effect
and partial application can be used for
dependency injection which is really
nice you don't need a special dependency
injection framework it's really simple
I'll show you now this is a bit
complicated so I'm sorry if it's a bit
confusing but let's say we have we need
to get a customer from a database what
we're going to do is define something
which gets me a customer given a
customer ID it returns me a customer
right now I've defined this in such a
way that I don't care where the customer
comes from does it come from a database
does it come from a cache does it come
from the far system it's like I don't
care because in my code what I want is
some way to get a customer alright this
is what we call persistence ignorance
just like I don't care about the
national database now one actually write
a real piece of code that uses a
database I need to pass on a connection
string or of connection or whatever
right so here's my actual code and it
part by part in a connection and a
custom ID and it actually does the work
okay
now the problem is this function needs a
connection so this function says you
give me a database connection and a
customer ID I'll give you back a
customer and that function is not
compatible with my my ideal function I
want which is the gate customer but what
I can do is I can take that DB
connection and I can pass in just the
database connection and not anything
else not passing the customer ID just
passing the database connection and that
gives me back a new function using
partial application I could wreck a new
function and this new function no longer
has the database connection as part of
it it's sort of been baked in to that
function
so the new function I get let's get
customer one you'll want it needs as a
customer ID and it gets back a customer
so I've basically hidden I've injected
the database dependency stuff into it
and it's now baked in and it's not for
anyone else and just use it without
knowing about databases and this is very
cool because I don't need to define an
interface they don't need to define you
know an ioc container and i think i can
just literally use partial application
and if i do another one let's say yeah
you can see that the one I want
the top and the one I finally get at the
bottom they're exactly the same they're
now compatible so I can use any way I
want something at the top I can use this
this function at the bottom let's look
at the equivalent for a cache so let's
say I've got a I want to get the
customer from a cash like Redis or
something well let's say in this case
I'm gonna pass in the dictionary okay so
I have a dictionary parameter you give
me a dictionary you give me a customer
ID and I'll give you back the customer
again this dictionary parameter is
messes UPS is a required interface it's
not the same thing I want but if I
partially apply the dictionary I get
back a new function which all it now
needs is the customer ID so again after
doing the partial application my ideal
function and the actual function match
up and I can use this function
everywhere I used the original function
so that's dependency injection very
simple what's nicely so you can see you
actually get a lot of functionality
without needing any special frameworks
that's one of the reasons people like
functional programming right
continuations don't call us we'll call
you
here's a divided function again I'm
using very simple examples the divide
function if the bottom number is zero
I'm gonna throw an exception and it's
like why right who gave you permission I
don't want to throw an exception I want
to do something else why who gave you
permission to thoroughly well it's like
the method decided it's gonna throw an
exception let's not do that
let let me be in charge I don't want it
to be just how can I be in charge the
answer is for me to pass in parameters
okay parameterize all the things so I'm
gonna pass in two extra parameters
something to do when it's zero and
something to do if it successful and so
my code is going to say if it's if the
bottom part is zero
call the f of zero function and if the
bottom part is not zero call the success
function right so now at this point I am
gonna call it's completely in control of
what happens if I want to throw an
exception fine if I want to turn it into
something else that's fine but the
method itself doesn't care about you
know doesn't isn't in charge of what's
going on so letting the caller decide
what happens is a really important
principle
I decide what happens next so the F
sharp version is a little shorter as you
can see again it's got the two
parameters and the top of the bottom now
the only problem with this is four
parameters it was originally a tube
round of function now so for brand
impression that's kind of annoying I
don't want to have to pass four
parameters around over and over right
wouldn't it be nice if we could somehow
sort of bake in the behavior we wanted
in this particular context so let's say
I don't want it I want to throw an
exception in this particular context in
this other context I don't
well let's bake it in so let's define
some functions some helper functions so
if it's zero I'm going to print bad and
if it's successful I'm going to print
good okay and then so this is my setup
and then what I'm going to do is I'm
going to partially apply those two
things to my divide function so
originally it was a four parameter
function after I done partial
application it's now a two parameter
function so I can go back and I can
pretend it was just like the original
one it's a two parameter function and I
call it all right that's very cool or
let's say that I want to say well
optionally yes and maybe I'll give you
back something I'll give you another
thing
so again I can set up the helpers I can
set up by what I'm going to do I do a
partial application and it turns it from
a four parameter function into a two
parameter function and then when I can
just use it just like an original just
like I did originally it's a two
parameter function or I can go back to
the original one I'm going to say okay
it's going to fail then the phone
exception on zero otherwise it's gonna
turn the answer again I can partially
apply it and I can call it so by by
parameterizing all the behavior like
this you can actually get a lot more
flexibility in how the code works and
then the partial application allows
you're going to get it back to something
that's easy to call something that's
sensible core so let's look at a some
real examples of why this kind of stuff
is useful here is some some trivial
thing I don't know it's doing do
something do something else and
sometimes there's nulls and we have to
handle the nulls so if it's not null we
do the next thing and if that's not now
we do the third thing and so on and
you've probably done a lot of this kind
of these kind of nested null checks like
really annoying
people call this the pyramid of Doom
because you're gonna like if you have 20
things you have to go deeper and deeper
and deeper and deeper now you can do
early returns and stuff but just hold
bear with me for a second okay because
you can't do that in like tasks if
you're waiting for tasks complete you
know wait for a task complete and when
that's done do another task and when
that's done do another toss and stuff
you can't your turn out that it's the
same problem you end up with this
pyramid of Doom right so how can we get
rid of that well let's go back for null
one you know you might say well nulls or
curse no we're gonna use this option
right it could be optic and something or
nothing so now the code looks like this
and it's like actually that's just as
bad okay
it's not any better than that it's still
 Lee
that's not solving the problem just
using a special type doesn't solve the
form we have to think about something
else there's a pattern we can explore if
you see this if it's something do
something otherwise do nothing if it's
something do something I'll always do
nothing if it's something no there's a
pattern we can use there so we're going
to write it a helper function if it's
something do something otherwise do
nothing but what do we do what exactly
are we going to do when it's something
all right
how can we make this exists all right
well we parameterize it just like we did
before we're gonna pass in a parameter
so a little function if it's something
do something and we pass a little
function right there's a little function
and if it's something we're going to
call that function and if it's nothing
we want but once we have this this
little helper function our code becomes
so much more simple we just say if it's
something do this thing and if it still
something do this next thing and if it
still something do this next thing so
now we our code is now nice and straight
we don't have any kind of period as doom
it's nice and linear so much much
cleaner and that is what a monad is
really all you need to know okay so it's
really thinking about it's just chaining
continuations together okay obviously a
Mona is a bit more complicated but today
that's all you mean no it's not it's not
something that's not like rocket science
it really is just a way of chaining
functions like this together
so I'm gonna go and use another railway
analogy which I like which is a switch
points whatever you call them here it
says input and maybe you get something
back and maybe get nothing back all
right so I'm going to use a branching
railway and I want to glue these
together so the composition of one way
of simple functions is easy but how do
you glue these together together all
right so if it's on if something happens
I want to do this but if nothing happens
I want to kind of bypass it the trick is
to glue them together is to turn them
into this Y so this is before they've
been glued together and his are they've
been glued together so there you go
that's that's the secret of gluing more
complicated together now here's the
problem gluing one track functions
together is really easy you just stick
them together even gluing to track
functions together is really easy but
these kind of switch functions all these
points they have one input and two
outputs right and so they can't they
can't connect
you can't glue them together so how are
we going to solve this problem all right
how are we going to combine these
mismatched functions and the answer is
bind so bind is some functional
programming jargon which functional
programmers like to use it's just got a
secret handshake if you go up to like a
functional programming say and I
understand what mine is that yeah you're
another club you know people get excited
by binds you can read into that way well
ok so here's our function that doesn't
work right that doesn't work for
composition if we could turn it into a
two-track function like this then I
could glue them together so what we need
is something that transforms a function
to another function so this is where we
have function as an input and a function
as an output and we have a function
transformer and then we could then we
could work with it
so let's design our function transformer
so here's our function transformer what
it is it's a to track and it's got a
like a slot on the top like a little
if you've ever played with like wooden
things you know there's like little
slots and stuff so this is something
that transforms one of these switches or
points into a two track
so a to track the points goes in and the
to track comes out and it's really easy
that's all it is that's the sort bind is
it's very simple you just pass something
in and if it's something you know you'd
call it like it was before you go on to
that weave railroad track and if it was
nothing you just bypass the whole thing
so this is the core of a monad right
here I mean I'm not expecting you to
understand this like stay away but you
can I just want you to realize it's not
that complicated it's not so scary it's
just a way of changing things together
transforming one kind of function into
another kind of function so if examples
go to our option thing this is what it
look like before and when we use bind
this is what it looks like now right so
it converts this kind of triangular
pyramid of Doom into a nice flat thing
if we go back to the yeah this monadic
bind if we go to the task analogy there
we go we're waiting for something and if
it completes we go on to the next task
if it doesn't completely bypass it and
so on again same kind of model we're
going to write a special thing called
task bind which is again it's just a way
of passing in continuation when this
task is finished what do you want me to
do okay and this is also called a
promise or a future mean they're all
very similar these kinds of things and
this is what it looks like before when
it's finished do this other thing when
it's finished do this other thing when
it's finished did theirs I think when
you use the bind this is what looks like
it looks very flat very linear very easy
to understand and you've also hidden a
lot of the complexity it's like you can
really focus on what's important which
is what the steps are
okay so let's chain era handless
together here's a function that does
some processes a customer request it was
seized request you validate request you
can authorize the email for some reason
you update the database you send an
email whatever a bunch of stuff you're
doing this is kind of typical thing you
might do in a web service the problem is
you've got errors like if the request is
not valid you have to return and if the
database couldn't be found if they can't
find the customer record that's an error
and if the database times out that's an
error and if the server's down that's an
error and all of a sudden your clean
code has got really ugly with all this
error handling and I'm sure you're aware
of this in fact you know a lot of 50% of
your code is fully a rounding so how can
we make this look nicer right we use the
same principle we say we do something
and I see that a success or a failure
right again it's this two-track model so
let's say we want to validate the input
there's one if the if the name is blank
that's a failure if the email is mank
that's a failure and otherwise it's
successful again it's this branching
model right so now again we have all
these different things that validation
could succeed or if could fail the
update database could succeed or fail
we're sending an email because succeed
or fail and we want to chain all these
things together and we've just seen
exactly how to do that we transform them
into these two tracks and then we can
glue them together into a big pipeline
so this is what I call well we're your
into programming and if you're interest
if you google that you'll find I have a
whole talk about it so this is what I in
in a functional language this is what
the code would look like before without
error handling
you know receive the quest and then pipe
it in to validate and point it in to
update and point back in to send email
and so on now after error handling it's
going to look like this okay so that was
before after error handling it's gonna
look like this okay which is looks the
same that's this is the cool thing it
looks pretty much the same code because
the error handling has been hidden
behind the scenes so behind the scenes
it's got this two-track model where the
errors have been shunted off to the side
but it's a nice point the nice things
that's been hidden from you as a user
looking this go you can your code is not
clogged up with lots of our hand in code
so yeah CF shava find a profit slash of
rock ok maps ok so we have these things
like options and lists and stuff this
whole often there's a whole world of
things with chef apparel is like a
parallel universe of these things and in
functional programming we offer end up
me in this world we we do something we
have an optional something we do
something have a list of something and
then to process it we have to kind of
come down to the normal world and we go
back up and we go down we go back up and
come down and this is really ugly
code you end up with code that test like
extract this and you know what you
really want to do is kind of somehow
stay up when you Pro once you've got up
into this world of doing something you
want to stay in that world and only ever
come down at the very end for example
that's that's the nice way of doing it
so let's let's look at a real example
here's my add 42 function because 42 is
a very important number this doesn't
this only works on normal introduced it
doesn't work on optional integers so
let's make it work on optional integers
so we're going to say add 42 to an
optional integer and now we have to say
well is it something or is it nothing
and if it's something call this function
and then take their thing and then turn
it back into an option again this is
really ugly code we're unwrapping it
we're doing the thing and then we're
wrapping it again right it's ugly
come down
unwrap go back up that's exactly what
I'm saying this is what you shouldn't do
so what we want to do is somehow take
this add 42 function have it in lifted
into this world of options how do we
lift how do we take a normal function
and turn it into a function that works
on options
that's what map is so a map will take a
normal function down here option dot map
in this case and we'll turn it into a
function up here and that's called
lifting in this case it's using map so
we take our 42 function you do map on it
and it lifts it into ad 42
- option though in this in the bottom
one we can pass in a normal integer get
43 then the top one we can pass in an
optional integer and we get back an
optional 43 so in the code we would just
usually say add 42 the option we'll just
say it's the Mac of add 42 and we can
just use it and often that's very nice
we've got a little helper function but
often we'd actually literally not even
create intermediate function we just
call it directly option map add 42 and
that creates this at the intermediate
function for us and that works with
lists so anything you want to do on a
list you can take a normal function and
lift it into the world of lists and it
now works on lists so for example add 42
we want to work on a list of things we
do list back and it transforms each
element in the list if we have async
things we have things that it works in a
normal world we map it into a lot of
async things and so on and so forth it's
a very very very common pattern this
mapping pattern so in a functional
library there's a lot of generic types
that have a map function and you've
basically learn how to use it and if you
write in write your own if it doesn't
because it's really important so okay so
jargon alert these are called functors
in functional programming people but
mapable type in a functor same thing but
I'm not going to use the word function
because it's it's mathematical all right
ma nodes okay people who are scared of
mathematics should leave right now and
if anyone faints oh okay here's the
mathematics we're going to deal with
okay one plus two equals three so is
that too scary for people how about this
one one plus two plus three is the same
as a 1 plus 2 Plus 3 and what about 1
plus 0 is 1 and 0 plus 1 is 1 okay
that's not how it's not too scary
people aren't freaking out ok so let's
let's look at this this isn't really
obvious ok let's look at this from a
mathematicians point of view and let's
give it some mathematical jargon because
it doesn't it's too easy to understand
let's make it more complicated
so let's look at 1 plus 2 cos 3 the
mathematician would say oh this is
interesting there are some things in you
and then some way of combining these
things and you get another one of the
same kind of things we add two integers
and we get another integer
multiplication is the same thing we've
got two things we've got some way of
combining them and we get another one of
those things
here's strings we've got two things
strings and we got some way of combining
them which is strength and cat and we
get another string or we have two lists
or two arrays and we can cap them
together and we get another array okay
very very common right now what's cool
about this is you can do something
clever so if you have 1 plus 2 that
gives you another integer right well
because it's another integer you can add
something else to it you can add 3 to it
but that's another integer too so you
can add another number to it right and
so on and so forth so what we've done is
we've taken a pairwise operation which
is plus and because this because this
property you can actually extend it
something works on lists so 1 2 3 4 we
can add them all together right so
that's kind of cool what about the next
one this thing of not caring which order
you do something dude you add 2 &amp;amp; 3
first or you add 1 &amp;amp; 2 first doesn't
matter right now if there's different
things subtraction of stuff did you do
it doesn't matter but for addition it
doesn't matter right so what's
interesting about this is because the
order doesn't matter 1 plus 2 Plus 3
plus 4 you can either do the 1 plus 2 in
the 3 plus 4 separately and then add
them later or we can do the 1 plus 2
first and then do the 3 next and then do
the 4 next right there's lots of
different ways of getting to the same
answer that turns out to be really cool
because we'll see in a minute okay so
like say as subtraction doesn't work
right the order of the combining doesn't
matter so the multiplication works
listen cat works and so on alright last
one 1 plus 0 equals 1 so a mathematician
so worse interesting you've got a
special kind of thing that when you
combined it nothing happens you get back
the original thing right so for addition
that special kind of thing is called a
zero for multiplication that special
kind of thing is called 1 right
it's a special kind of thing where you
multiply it you get back the same answer
for Strings that special kind of thing
is empty string and for lists it's the
empty list and someone so forth okay
so now we've got a generalization you've
got a bunch of things and you've got
some way to combine them pairwise first
rule you combine two things you get
another one of the same thing
associativity which is when you combine
two things it doesn't matter which order
you combine them I mean you have to
combine them in the right way but the
order doesn't matter and finally there's
an identity element there's something
that when you add it to something it
does make a difference those these
things are called a monoid right and
that's it so the fancy mathematical word
for something which is sort of basically
common sense why is that hi do I care as
a programmer why do I care about this
stuff well we already saw that if you
combine two things you'll get another
one of the same thing that turns a
pairwise operation into something works
on lists so one plus two plus three plus
four I can say take that plus sign and
stick it everywhere between the items so
I could have one two three four and in
f-sharp this is called reduce right so
I'm going to take it the reduced
function is the same as taking that
operation and sticking it between each
number all right so any any pairwise
operation can be applied to everything
internally using reduce multiplication I
can say reduced by an non-possession so
stinking cap so take the list of strings
and I'm going to reduce them using plus
so these two things are the same whether
I do it especially or whether I do it
reduce okay
okay there's Sosa tivity thing why is
that useful well because I can because I
can calculate things in different orders
I can do stuff like divide and conquer I
can do parallelization I can do
incremental stuff let's look at
paralyzation let's say I have I want to
add 1 &amp;amp; 2 &amp;amp; 3 &amp;amp; 4 and I have like 2 CPUs
what I can do is I can do 1 plus 2 on
one CPU and I can do 3 plus 4 and under
CPU and then I can combine the answers
right and I know it's going to work
so I've literally paralyzed my my
multiplicate my addition okay obviously
pretty trivial but you can see that if
if you have this property you can
actually split a task into multiple
parallel things and then add them up at
the end that's paralyzation but even if
you don't need paralyzation the
incremental accumulation is really
important so let's say I do 1 plus 2
Plus 3 and the answer is 6
okay and then your boss comes along and
says you know what actually we need to
do want us to plus 2 plus 4 not just
what this do okay so I have to start all
the way from the beginning and do all
over again
no you don't write you've already got
the first 3 done you don't need to do
the first 3 again you can just say I've
already got I've already figured out the
answer 6 I can just add 4 to it why I
can do an incremental calculation I
don't have to do a calculation from
scratch and then finally if I want to do
is reduce an empty list or I have a
divide and conquer and one the steps is
empty what do I start with and so this
is where the zero comes in it's very
useful when you have missing data or
empty data and so on so and there's a
semi clear if he doesn't have an entity
it's still worse there's a thing called
a semi we don't care about that all
right so let's look at this useful let's
say I have some other lines I've got an
order by the way I'm just going to go a
few minutes over I hope if you need to
leave early that's fine I'm just I'm
running a little tiny bit late so if you
have some order lines and you want to
add them together you could say well I
could just loop through them add them
but what you could do instead is you
could say oh I know these are ma nodes
so I floated as ma node and insulin are
then like a combination of moloids is
another one ID so all I need to do is
write a pairwise operation I can say
pairwise add two lines together
by adding the quantity and adding a
total and then I can say reduce so I
take this pairwise operation and I apply
it to the entire list by using reduce
and now I've added up my entire order
and that might be overkill for this kind
of thing but you get the idea that
writing a pairwise operations often
simpler than writing a more complex
operation another really useful one is
to convert non more nodes to monoids so
let's say you have some customers now
customers you can't add customers
together they're not things you can add
together but let's say you have some
customer statistics that you want to add
together like how many how many times
the customers visit your site or
whatever now the customer stats are
numbers and stuff they can be added
together and that's a monomial
but so what you need to do is you need
to transform your customers into
customer stats right and we're going to
use a map function for doing that with
the transforms one thing another thing
and then once we've got the customer
stats we can do reduce which collapses
them into a single customer stat okay
this is a map followed by a reduce
alright so you may have heard of that
this is very similar to what Google does
obviously it's much more complicated the
giggle thing but the concepts are the
same it's map followed by reduce yeah
there's someone tweeted this this is a
very nice little diagram you have in
these ingredients for sandwich you can't
add you know a loaf of bread to an onion
right but you can have the slices of
bread and slices of onion and those good
when we combined so what you do if you
do map you map to the loaf of bread into
a bunch of slices you map the onion into
a bunch of slices and they need to
reduce on the slices to give you a bunch
of sandwiches there's kind of a funny
way to think about it how do can make me
a sandwich right one more expensive more
ways to cheat ma9 so let's say you have
a log file for each day or your customer
logging and you add them together with
their strings so you can add them
together and you get a really big file
if you turn them into summaries the
summaries can be added together much
more you know much more small you know
more efficient code so you can turn a
log file into a summary of the loafer
and then they can be added up
incrementally right you all you just do
because it's a mole and you can
incrementally add today's summary you
know
entire five years with a date you can
always just add the latest data and that
is called a monoid homomorphism this is
why this is why the language is kind of
off-putting to people no I see ma nodes
everywhere so like if you're doing web
if you doing metrics for a website or
something there's a well-known one using
counters rather than rates alternative
use ma nodes so using count as well and
rates because counters can be aggregated
if you want to know how many customer
the number account of customers is
easier than the number of customers per
second and and so the count of customers
that's a mono dick and rank aggregation
and so on all right almost finished
function composition is that a monoid
right so I've got two functions I'm
going to glue them together and I now
get a new function which is an apple to
see cherry function and that is not the
same you know there is no ones were not
the same as any one so I can't clear
that together I mean I can't take that
it's not the same kind of thing however
if I have Apple to Apple functions and I
do them together I get another Apple
Apple function okay so this is a model
this is cool functions confident
function composition is a monoid it's
not awesome I know it's very awesome so
what do we call it we'll call these
things functions to have the same input
output shall we call them functions with
the same kind of input output no now
we're going to call them endomorphisms
so again more jargon so here's some
endomorphism so this is integer integer
functions of all net more firms because
the thing I can literally do a reduce
same kind of thing and I can get a new
function which is the combination of all
these functions maybe not very useful
but it just shows it's not just for
numbers and strings you can do for
anything
so finally mono aids versus monads they
both start with M but they're kind of
different and they're kind of confusing
but there is a connection and I'll
quickly go through this so we have these
these monads which are like I'm using
this kind of branching railway track and
if you there's a way of gluing two of
them together could get another
branching where we track right that's
composition monad composition so I get
the same kind of thing as closure
and it doesn't matter which or do I do
in right so I got associativity right
and I got a closure I got associative
these things are mono EADS okay this is
branching where we tracks actually MA
notes and so there's something called
the Monad laws which we care about but
they're really the same as them on ID
laws in disguise so this thing of
closure an associative in identity and
people say you know what happens if I
break the Monad laws well of course you
go to jail but more importantly you lose
things like the benefits of aggregation
whole point of having these laws is that
you can combine things and get a new
thing so there you go a monad it's just
a monoid in the kind of in offenders so
I haven't really explained this but you
can see that you know once the jargon
has been demystified a little bit
there's a lot of its to do the jargon
but it's you can see that monads and
Manos
kind of related and you don't really
have to care so much but it's kind of
cool but hopefully your head doesn't
explode
too much on that one all right thanks
very much if you want the slides and the
video they'll be on my website at /fp
patterns up there if you're interested
in F sharp you can go to F sharp org and
I have a book coming out called the main
modeling made functional if you're
interested in it you can get the early
access Edition right now and it should
be coming out in November and if you've
got any questions please come and see me
outside I'll be happy to answer any
questions thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>