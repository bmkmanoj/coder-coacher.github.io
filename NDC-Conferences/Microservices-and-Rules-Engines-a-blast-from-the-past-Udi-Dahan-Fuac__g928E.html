<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Microservices and Rules Engines – a blast from the past - Udi Dahan | Coder Coacher - Coaching Coders</title><meta content="Microservices and Rules Engines – a blast from the past - Udi Dahan - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Microservices and Rules Engines – a blast from the past - Udi Dahan</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Fuac__g928E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">how many of you from Oslo by the way
okay a lot of you okay it's been a while
since I've been back to NDC for those
who don't know me my name is Judy Jahan
a Twitter I'm at Judy de haan I work at
a company called particular software and
we make an service bus but that's not
what I'm going to be talking about today
my shtick is micro services and
service-oriented architecture and in
general building complex
enterprise-grade software and my guess
is that most of you have already heard
of micro services before who's heard of
micro services before yes okay that's
pretty much everybody now for those you
know a little bit about me you know that
I tend to take a contrary viewpoint so
if I say something about micro services
which is different from what you've
heard about before that's normal okay so
what I'm going to be talking about today
is a different kind of micro services
approach and then from there I'm going
to be introducing something that my
guess is a lot of you haven't heard
about for a long time this thing called
rules engines and seeing how these
engines and micro services end up
working together to solve a special
category of business problem that most
people run into when they've already
really committed to their architecture
and it's kind of too late to make any
changes to that so answer me this raise
your hand if you've ever had to deal
with the feature that didn't really fit
with your architecture and then you told
the other stakeholders on the project it
would be faster to write the system from
scratch than to implement this feature
on the current codebase yes raise your
hand if you've said that before okay
this talk is for you by the way don't go
doing Big Bang rewrites there always end
in tears but that's the topic for
another time so first of all before
getting to the whole rules engine side
of things I want to set the record
straight on microservices microservices
originally was meant to be SOA done
right
another blast from the past remember him
why did we need SOA done right to be
rebranded because this SOA turned into a
big pile of crap that everyone's like
Ayanna do SOA it's crap it's heavy wait
it's complex micro services they're
small they're agile they're fun
so rebranding is something that we tend
to do a lot of in this industry roughly
every five to ten years we take the last
good idea and then we give it a
different name now the problem with any
type of good idea is that it starts to
get popular the more popular it gets you
end up with everybody's doing it and you
know what the problem is when everybody
does something it's kind of like agile
for those you are who's I'm an agile
sorry who's in a company that calls
themselves agile let's ask it that way
all right
most companies call themselves agile all
right now raise your hand again if you
think your company is actually agile
okay I'm getting maybe like a tenth of
the hands that are going on so that's
kind of the thing with micro services
it's become this very popular term that
everybody needs to have on their CV so
go yeah we're doing micro services too
just like everybody was doing agile a
long time ago now a lot of times the
contrast be why are we doing agile why
are we doing micro services you know the
problem when something gets too popular
is that we kind of lose rational
discourse around it so imagine if I came
to your company and I said to one of
them the management guy said you know
what you guys you're not really agile
but is who are you saying we're fat
right agile is such a good thing that
the alternative is being fat and slow
and ugly and all those types of things
and that's kind of how we've ended up
with micro services as well is that
everybody needs to have the micro
services brand where the alternative is
that bad big monolithic everything in
one place
in short fat so we're like oh no no
monoliths those are bad we don't want to
do any of those anymore instead we're
going to repackage things in such a way
that now all of the different pieces of
code are in their own processes and look
at me microservice right so we got bad
on the one hand which is everything
monolithically together and then we've
got good on the other hand where
everything is these small tight little
darker eyes containers orchestrated with
docker swarm or meso sora kubernetes or
some other new fancy technology that
nobody can pronounce and they're like
yes this is it this is the future we're
going to be so agile and scalable
Netflix watch out right but looking at
this picture for a second how is the
coupling any difference in is the fact
that I'm doing the call remotely Jason
over HTTP does that magically make my
coupling disappear how does that
actually change the quality of my
software and I got a short answer for
you all of this micro services stuff
it's not going to make your coupling any
different all you're doing is
rearranging the mess that you've got if
you have kids I have kids four kids by
the way it's like asking them to clean
their room
you don't actually clean it they just
sort of spread the mess around
differently or shove it all in the
closet that's kind of what we do as
software developers when we're doing
some sort of reor Kotetsu effort is we
take all the coupling and kind of spread
it around and hope that nobody notices
sprinkle on some nice docker over the
top of it it's kind of putting like a
carpet on top of a mound of dirt and
there you know you're microservices
ready now some people will say no young
you can't do it that way obviously
you've got too much coupling between
your services what you need to do is you
need to put all of the data that you
want to transmit in some database and
then you call
the other microservice and tell them hey
okay you go do something with this ID
they'll go to the database read out the
data that they need and presto change-o
coupling disappear oh right look at how
decoupled my micro services are I'm only
sharing IDs my api's are never going to
change now you know we've heard yeah you
shouldn't share databases between micro
services so yeah doing that that's
that's a bad thing but then today hey
you know maybe if we put a rest service
around the database nobody will notice
right that's like putting a carpet over
the mess in our room and voila micro
services so let me summarize this whole
micro service how you're doing it wrong
thing
bottom line services micro macro micro
or otherwise are not about remote calls
that is so important I'm going to say
that again micro services are not about
remote calls calling something remotely
does not change any logical coupling so
I know I'm flogging a dead horse here
and if you've seen me talk before I've
mentioned this over and over again but I
keep seeing it happen over and over
again so this kind of thing that we were
talking about before where you've got
one process calling another process
remotely calling some kind of code
that's not a service similarly if you
put a REST API around the database and
call that remotely that's not a service
if you host everything in docker
kubernetes dr. swarm all that kind of
stuff container eyes it run it on Azure
stack scale it up down inside and out
that's not services so you're saying
we're fat right ultimately it comes down
to logical coupling we need to have
services that are fundamental
decoupled from each other we need to
hack away that chain of logical coupling
and it really is a great deal of effort
it's not the kind of thing that you can
just sort of spread the mess around
differently so let's talk coupling
starting with layers
who doesn't love layers I don't love
layers by the way so layers what we've
noticed over and over again is that with
all of these layers the business still
comes to us and says you know what
I need another field to appear on this
screen and then we're like okay so I add
that field to the database and then I
add that field to my mapping logic in my
ORM and then I add that field to my
domain objects and then I add that field
to the DT OS that are exposed by my API
and then I add that field to the view
model and then I add that field to the
view
I say hey that's maintainable code right
you know what I need code generator
who's ever built a code generator to do
one of these things come on raise your
hands those of you raise your hands who
would do it again yeah I got a couple of
hands up there
you must be consultants then you got
some people come on so you know what the
problem is we don't have enough layers
right five layers wasn't enough right we
started with three layers remember the
good old days where was client-server
two-tier then we moved to the three-tier
architecture and that wasn't enough and
then it was end here because once we
realized one two three we better just
abstract this away 2n right we're good
at doing that so add layer after layer
after layer some anti-corruption layers
so that we can say that we're doing DDD
right who likes doing DDD yeah okay good
the problem is you will have this kind
of coupling top to bottom no matter what
we've tried for roughly twenty years
the early days of client-server to
somehow get that coupling to disappear
it's never worked and this is one of
those moments where we kind of need to
move through those seven levels or it
may be it's a 12 step process where in
the beginning there's denial what do you
mean there's coupling there is no
coupling it's all encapsulated step to
anger how dare you say that there's
coupling in there and gradually we move
through grief oh my god I can't believe
I have all of this coupling and finally
there's acceptance yes there is coupling
it's a fact of life move on but I'd like
you to take a step beyond just
acceptance go into kind of a Zen state
be one with the coupling to really
embrace it into your being and from that
state you might have an epiphany that
while there is lots of coupling top to
bottom when we look side to side
sometimes there isn't very much coupling
in there at all that bits of logic that
deal with say a product's price couldn't
care less about the number of stars that
the product has and vice versa that the
bit of logic that deals with the
customers shipping address really
couldn't care less about what the
customer status is so yes this is
related to customer and that's related
to customer and this is related to
product and that's related to product
but when we look more deeply into the
transactions that are operating through
these entities we kind of realize you
know we just sort of lumped them
together by convenience what if we split
them apart what if the services that we
were looking for were never a layer
maybe there are these kinds of vertical
slices that just kind of happen to have
a lot of the same layers with each other
and we can take them apart not only at
the business logic layer and that the
data access layer at the API level we
can go all the way up to the UI and say
even a single screen that we're looking
at even a single controller that we
might have written in the past maybe
that's not actually a single controller
anymore maybe the product catalog pieces
the product name the description the
image that's in one service and the
ratings are in another service and the
price is in yet another service and the
inventory is yet in another service and
yet they're all associated by the same
product ID but realistically when a
customer is making a purchase we don't
need to know what the image of the book
is when we're replenishing the inventory
of a product we don't need to know how
many stars it has there's lots of stuff
over here that both at a UI level and a
business logic level can really be kept
apart now if you want to see what it's
like to build this type of compass at UI
I've put together a kind of holding your
hand model so put this up bitly slash
particular dash microservices to show
you how you can do this type of
composite UI with angular now there's a
whole bunch of other stuff in that
github repository so feel free to kind
of go around and they're there a whole
bunch of exercises but it'll give you a
model where you can see what this type
of micro view / micro controller UI type
of thing how you can build something
like that and then how to flow that type
of decoupling all the way through to
your back-end now the same as and again
this is sort of an easy UI to look at
because everything kind of has its own
widget that is laid out separately on
the page we can take this a step further
and arrange these types of things in a
grid as well where we've got product
catalog and image information as sort of
one part of the grid and then ratings as
another part of the grid and prices as
another part of the grid so we can do
this exact same model even though the
layout is kind of more in
for twines and you'll see that also in
that bitly link that I showed you before
now where this leads us to is an
important conclusion about what the term
service means and it doesn't mean so
when you think about it in the browser
we're going to have JavaScript code that
angular code those angular modules from
a whole bunch of micro services we're
going to have the yellow micro service
that's telling us the product catalog
information we're going to have the
orange micro service with its bit of
JavaScript in the same browser telling
us about the price information we're
going to have that grey micro service
that it's showing us the information
about the inventory levels so in essence
when we look at the runtime environment
a service isn't necessarily running by
itself it's running alongside components
from other micro services in the same
host and that's not just true about the
browser the same thing can happen on the
web server so if we're doing server-side
composition rather than client-side
composition the same type of thing
happens very often what we'll see is
that we will be taking a component or
two from service a with a component or
two from service B and putting them in
the same process and the same thing when
we look farther back from the web server
into App servers or any type of logic
like that you'll very often see that
these type of logical micro services are
not physically deployed by themselves in
fact most of the time in order to do any
type of UI type of work we're going to
need them to be hosted together so
beyond just a hosting side of things I'm
going to get back to that in a little
bit I want to talk about the data side
of things so yeah you might have heard
of terms like polyglot persistence that
I'm kind of illustrating over here where
one micro service has a sequel database
and another microservices a sharded
database and
third one has a graph database the
important thing here is that these
services own their data entirely and
that means a lot to actually own your
data because a lot of times there's that
element as we said before okay we're not
going to share database but then we end
up just sending all of our data from one
micro service to another via an API call
so the fact that we're not talking
through a database but we're sending
effectively all of the business data via
an API call
we've still shared our data we just
didn't do it via database we did it by
an API call so when we say that services
own their data what that means is that
the data remains encapsulated in that
service the service doesn't share that
data it doesn't send it out to other
micro services and that means not by an
API call not by a shared database and
for those of you that are using some
kind of publish/subscribe event-driven
infrastructure same thing not going to
be sharing all of that data via an event
mechanism so yes these types of highly
encapsulated services can pub/sub with
each other and will need to pub/sub with
each other but be very careful about the
amount of data that you're transmitting
across ideally you want to be sending
nothing more than some identifiers so an
identifier maybe a date time something
like that if you start sharing data
that's volatile like a price or an
address that's when you start getting
into trouble and again the issue here is
not about how you share it but the fact
that you're sharing it in the first
place so this element of encapsulation
is super important that's the number one
touchstone of logical decoupling you
want to decouple things don't share so
much stuff between them now the other
area where people kind of get a little
bit thrown off about microservices and
this is where microservices ultimately
meets the SOA done right it's not just
about a single system because what we're
looking at so far might give you the
impression that we're designing micro
services for system a in and of itself
without taking into account anything
else in the organization but we need to
take a much wider perspective the
problem that we have and this isn't
entirely our fault this is how IT as a
whole is structured is that you know
your team is given a project and that
project is to build one system and
that's what you focus on for the next
year and a half of your life and
whatever other teams and other projects
are going on it's like well you know
they do their own stuff and if you need
to integrate with them okay so you call
their API they call your API but really
we tend to have our blinders put on in
order for us to have proper and complete
data encapsulation we need to look
beyond just one system we need to look
across the entire enterprise for all of
the different kinds of systems that are
there and oftentimes what we'll see as
the exact same data is used and modified
in a bunch of different systems so if
we're talking about price information
yeah it's going to be available via
mobile app and that's going to be
available in our back-end and that's
going to be available over a portal and
that's going to be available in a kiosk
application the same data ends up
traveling across all of these systems so
if we're going to say that a service
owns its own data and doesn't want to
share it then the only way that
something like that's going to work is
that if our services extend beyond the
boundary of a single system such that if
there's price information there is one
service that owns that whether that's in
the mobile app the kiosk application the
single page application the internal
Oracle forms finance thing that we've
got services as a logical construct
own their data wherever it may be even
if those different systems are written
in different programming languages so it
doesn't matter that the mobile app is
written by iOS developers and the portal
is written by Java developers in the
backend is written by dotnet developers
the focus here is on logical ownership
so as you can understand where that's
leading to is that if we have a team
that is focused on a micro service then
that team will likely make be made up of
developers that have objective-c
knowledge net knowledge Java knowledge
JavaScript knowledge and all of them
need to work together on that same
business domain now where this leads us
to it's kind of a very different state
with regard to our systems because after
we've taken out all of those components
so the part that deals with the price
and the part that deals it to address
and the part that deals with the product
name and image and description and
inventory and the ratings really what's
left of the system in essence the system
kind of becomes this green Lego board if
you will that we take a red Lego brick
from the red service and a blue Lego
brick from the blue service and we
arrange all of these things together on
that platform but that fundamentally the
system doesn't really have its own code
very much all of the code is belonging
to the services the system doesn't
really own its own data the data is
owned by those services and if you
follow that model you'll end up with a
very different style of architecture and
that's actually what's going to give you
the benefit of microservices because
that way when you make a change to the
blue you're not going to break the red
because you're just not sharing stuff
between blue and red and when you make a
change to the red you're not going to
break the yellow etc etc this is what
makes doing micro services
slash service oriented architecture done
right hard
because ultimately it's different from
everything that we've been doing so far
kind of like agile right if you want to
get the benefits of agile you gotta work
differently just as a quick anecdote I
was at a client maybe a year ago that
was doing agile and I sat in in one of
their stand-up meetings it was hilarious
everybody was standing up everybody was
saying this is what I did yesterday this
is what I'm going to be doing today this
is what I'm blocked on but nobody was
listening to anybody else everyone's
just kind of on their phones in the
stand-up oh my turn yesterday I did acts
today I'm going to still do acts I'm not
blocked on anything they went back look
at me agile right if you want to get
benefits you need to do things
differently the same thing with
microservices a lot of this stuff it's a
fundamental architectural shift and that
doesn't just happen overnight now that's
all the microservices stuff now I want
to tell you well where this type of
model kind of runs into difficulty so
this model does break down unfortunately
you can have a high level of
encapsulation but invariably you'll end
up with some slightly more complex
business domain where you're going to
try to keep things all separate and
encapsulated and not sharing data with
each other and then there's going to be
the sense of but I can't I have to send
data across and that's what I'm going to
be talking about for the second half of
the talk
it's the where this type of
encapsulation runs into problems so
starting with search who needs to do
search on their system yes search okay
so the problem with search with are
multiple problems with search the
biggest problem with search is that
Google has spoiled the world right the
average user
picks up their phone tykes in some
random crappy string of text that isn't
even correctly spelled and Google in
sub-second timeframe knows what they
meant to search for and finds the most
relevant result for them and it's just
there on their phone they're like oh
great once upon a time that was
considered magic once upon a time people
appreciated just how hard it was to do
something like that but after you've
gone through that process as an end user
50 times a day for the past five years
you just kind of expect it and then they
turn around to us and Talent Search
they're like okay did I mention that I'm
not Google did I mention I don't have
20,000 engineers and a hundred thousand
servers and a data set from all of the
users on the planet searches over the
past 20 years like I'm sorry I tuned out
after the part that you said Google I
was looking something up on my phone
they just expect us to do that so here's
a small tip don't try to recreate the
same level of magic that Google has
you're not going to succeed so one small
thing that I want you to know about
search for those of you because a lot of
you are trying to do search okay
understand that search is not just about
the free text search there's this
important part called relevance if you
have a data set that's large enough then
your users want relevant results not
just matching results here's relevance
in a nutshell 30 seconds or less what
you need to do to return relevant search
results ready go every time the user
clicks a search result you need to
increase the relevance of that result
every time they click back and click on
a different search result you need to
decrease the relevance of the previous
click for all future searches anytime
they do a text search and then they
change the text again
you need to reduce the ranking of all of
the results that you showed them for
both of those text search results are
you getting an idea of how hard this
stuff is that will give you Google as of
20 years ago in the best case all right
this stuff is damn hard now what I'm
gonna be talking about here is a
different category of search for example
a product specific search where users
want the ability to say okay I'm looking
for a product let's say it's a watch
and I would like to see watches with a a
blue face on them I'd like to see them
made out of metal
I'd like the price of the product to be
I don't know between $100 and $200 that
kind of search now the issue that we
have with this kind of search is that
well now I'm dealing with colors and I'm
dealing with the metal band or the
leather band or in the color and the
color of the band and how much it costs
and while historically I would have said
hey color is in one service and the
manufacturer of the watch is in another
service and the price is in another
service all of a sudden I got this
search the needs top right across all of
these fields now I have a problem how do
I keep my up until now separate
microservices from becoming entangled
again let me give you another problem
customers specific pricing so there's
this new thing called the internet you
might have heard of it where users can't
see the prices that other users got so
we can actually charge different people
different prices for the same product
isn't it awesome now some of you in
Europe might be saying that's against
the law
which is why ecommerce go so well in
North America and you don't really have
really strong e-commerce plays in Europe
or not the same level but customer
specific pricing is that same kind of
thing where in the paso de said sure a
product has a price
and a customer has an address but then
someone in the business says you know
what customers in Oslo there are rich
bunch we can charge them more customers
who are living on the outskirts of Oslo
we'll charge them a little bit less
customers who live way up north in
Norway we're going to charge them in
gear pellets so this element of saying
the customers address is now going to
influence the price that we show them or
for example this customer bought a lot
of stuff from us we should give them
discounts to keep that flywheel spinning
this customer hasn't really bought very
much from us yet so don't give them any
special discounts
unless it's Easter and then an Easter
we're going to have some other kind of
special promotion that's going on once
again what started out as a nice simple
separation we're sure customer addresses
are in service a and the product price
is in service B and you know all of that
kinds of very nice cleanly separated and
now we get these requirements from the
business and they're saying nope sorry
you've got to tangle it all back up
together again let me give you a third
category just to make sure because
everything needs to be done in threes
fraud detection fraud detection
something that's very important anytime
you're dealing with money and lots of
business systems end up dealing with
money somehow
so let's talk about fraud for a second
fraud is one of those really difficult
types of domains where once again the
business starts looking at all sorts of
weird patterns so for example it's a
this customer all they've ever bought
from us is books and then one day out of
the blue they're buying a fridge now
that wouldn't be so odd but the shipping
address that they've selected from the
fridge is different from all of the
other previous books we've all sent them
to a different address and on top of
that all the IP address that they're
using for making this purchase is out of
Nigeria
so we're getting to this point we're
saying you know something weird is going
on here maybe we should flag that as a
potential fraud and axe ask the customer
to approve it by a two-factor
authentication on their phone so
whatever these types of rules that we're
dealing with fraud are again I hope
you're getting that impression of we're
going to get these categories of
requirements that say data that would
have been nicely separated between
different services now kind of ends up
intermingled in a bunch of different
places and that's really the problem
with most type of architectures is that
in the beginning of the project because
we're nice and agile and we want to
focus on you know you aren't going to
need it just ship it focus on agile
delivery we usually tend to pick the
simplest easiest requirements at the
beginning of the project right and then
we deliver those and we feel good about
ourselves and then we pick some more
simple requirements and then we deliver
those and after a year we finished all
of the simple stuff and we're feeling
good about ourselves and then we start
having to deal with these kind of more
complex ones and that's the issue that
we get blindsided by this complex domain
and by that time we've already kind of
put a whole bunch of puzzle pieces
together and now we have just a bunch of
puzzle pieces and they just don't fit
and we keep trying to kind of turn the
microservices around and say maybe if we
do this and maybe if we publish that
event and maybe if we do this UI
composition eventually you kind of just
throw up our hands in there and say look
it would be faster to write the system
from scratch then to implement these
requirements on top of the existing code
base at which point and type it was
saying what microservices didn't do it
for you your answers ah
the solution is actors everything needs
to run on Erlang that's how you build
the next what's up and get bought by
Facebook for 19 billion dollars right
so how do we go and do that next project
on top of actors in Erlang again we pick
the simplest possible requirements and
go through this process over and over
and over again only this time where my
consultants who's the consultants in the
room raise your hand if your consultant
then we go do it at another client right
we can rinse and repeat the exact same
practices over and over again only this
time it needs to be written in F sharp
why because I don't have F sharp on my
resume yet all right got a stay current
but we're back to the fundamental
problem that how do we build these
requirements how could we prevent
creating a tightly coupled mess when the
requirements seem to force us into that
position of tying everything back
together again so this is not just the
talk where I say sucks doesn't it have a
good conference or used to be consultant
if you want to answer this question
you're going to have to hire me there is
a way out and I already told you what
it's going to be right at the beginning
of this talk rules engines now who's
heard of rules engines before today okay
mostly you have who's used a rules
engine in the past if fewer hands are
going up keep your hand up if you
enjoyed using a rules engine okay I've
got one out of a room of maybe 300 okay
you're the same one that likes to do the
cogeneration right now the thing about
these rules engines again a long time
ago rules engines got really popular and
then kind of the fell out of fashion
kind of like service-oriented
architecture so I figure it's just about
time for a rebranding of rules engines
maybe we should call them micro rule
right what do you think you think that
domain has taken somebody checked out
for me right that's how you know how to
brand something first you check if the
domain is taken then you find out it is
and then you come up with a different
name right so when talking about rules
engines I want to talk about rules
engines not as like a full-blown rules
IDE that you're dragging and dropping
things and authoring all sorts of crappy
stuff in XML and not that kind of rules
engine stuff I'm talking more at the
level of design patterns so you might
have heard of the Gang of Four design
patterns or patterns of enterprise
application architecture all that kind
of stuff that's what you need to think
of it's a pattern of implementation
where you want to have this kind of
decoupling from the rules engine the
sort of generic piece of infrastructure
and the rules themselves that are
executed by that rules engine that in a
nutshell what we're talking about here
so some type of generic infrastructure
that you can plug into from different
services so let's start with that search
that we were talking about before
fundamentally this search process can be
thought of as a kind of filter or a
collection of filters that gradually
take different steps along the way and
say okay first thing we need to do out
of all of the product IDs let's do some
free text analysis and see what are the
product IDs that match that from there
let's go through a different rule which
filters out the products that have the
right price
or filters out the products that have
the wrong price and then we go look at
the brand of the product that they've
selected and then we look at the color
of the product that they've selected but
the thing that I want you to think about
over here and that's the important
distinction is that this search engine
not search service this search engine
what it does is it allow
each micro-service to put a component
into it and then that search engine will
run that set of rules so in terms of
just regular software design imagine if
there was an IEEE filter product IDs
interface and each of those services
wrote a component that implemented I
filter product IDs that's really all
that we're talking about over here a
generic type of search interface that is
implemented by each one of those micro
services and then we take the component
from read and the component for blue and
the component from green and the
component from yellow and we put them
all in this generic search engine and
that's what allows us to be able to have
this kind of search which is taking into
account price and color and brand and
all that kind of stuff without creating
any additional dependencies because now
the thing that's dealing with price
doesn't need to know about the color and
the thing that deals with the color
doesn't need to know about the brands
each micro service can remain largely
autonomous but again what we're talking
about here is not the whole micro
service but the search component of that
service all right so when you're
thinking of how you end up building this
kind of stuff it's one component out of
that service and once we get all of
these search result IDs that kind of
filter out the very bottom of this then
we can go back to the grid that we saw
from before and say great now I know
these are all the product IDs that match
that let's do that same UI composition
from before where we're going to have
the blue service that shows the product
catalog information of the images of the
book in the names of the book and
authors of the book and we're going to
have the yellow service that's showing
the ratings and we're gonna have the
green service which is showing the
prices so that way the search engine
doesn't necessarily need in and of
itself access to all of the data
directly I'm going to reiterate that
the search engine is generic and doesn't
take a dependency on all of that data
all it's doing is generically calling
and looping through all of these I price
or product ID interfaces so search take
that box let's talk about customer
specific pricing we can follow that same
sort of model just with a slight twist
where we have one component that
provides us the list price so how much
would this product cost if there were no
discounts and none of the other customer
specific pricing so what we'd have here
is not a price service but a pricing
engine a pricing engine that exposes
interfaces that each service can plug
into so after the search after that
pricing engine gets that original list
price from the I provide list price
interface then it loops through all of
the implementations of I provide price
factor so what we have here is a type of
model where instead of the special
offers saying ok what we're going to do
is decrement the value by X instead it's
better to operate at the level of a
multiplication where each of these
components is giving us a price factor
so based on the Easter special offer
that's 10% off based on the fact that
the customer lives in Oslo that's 20%
more expensive the fact that this
customer has purchased a lot of stuff
from us over time and they qualify for
something there that's 25% off and the
nice thing about this type of
multiplicative factor it doesn't matter
which order we run the rules in right in
other words if you take $10 and then you
multiply that by 0.9 and then you
multiply that by 1.2 and then you
multiply that by 0.75 it doesn't matter
which
order you're doing that multiplication
in so once again that pricing engine can
largely be agnostic which services are
providing the rules and what are they
doing in what order do those rules need
to be running so what comes out at the
other end is a price that is eight
dollars and seventy six cents and the
average user would look at that so
that's an oddly specific price right I
can't imagine that there's anybody in
that company's back-office that decided
that this product should really cost
eight dollars and seventy six cents but
that's that customer specific pricing in
action so when looking at these types of
engines always try to think when you're
designing them this is just a design
pattern
what is that interface that they're
going to expose and how can you set it
up so that it doesn't really matter
which order the rules are executed in so
that's customer specific pricing let's
talk fraud detection for a second we can
do the same kind of thing where there's
some base fraud score that everything
starts from let's say 1.0 and then we
have information about the shipping
address then we can say okay if the
shipping address is in Nigeria but the
customers regular address is in Oslo
Norway then that increases the fraud
score by 200 percent and then we look at
the credit card information let's say
where the credit card was issued and the
IP address of where it's currently being
used from say okay it seems to be being
used from someplace in the British Isles
of that is a tax haven so wow I don't
know maybe this is fraud maybe this
person just decided to move to someplace
in the middle of nowhere for tax reasons
but let's increase the fraud score a
little bit let's make that say 25%
bigger and let's look at the order
history what type of products have they
bought in the past what type of product
are they buying now and again each sir
service with its own data has its own
fraud component and again it's not
looking at what any of the other
services are doing it's the same based
on the data that I have how much am I
going to increase or decrease this fraud
score and then what comes out at the
other end is that based on all of these
generic I provide fraud multiple rules
the fraud score ended up being I don't
know 126 and because that number is
greater than some threshold that we've
defined therefore we're going to require
two-factor authentication so again what
I want you to take away from this is
that even though we get requirements
that say fraud pricing search all
require data from multiple services the
way that we resolve this conflict in
terms of the coupling is by recognizing
that search isn't a service that pricing
isn't a service that fraud isn't a
service rather it's a composition of
this generic rules engine type thing and
all of the components from all of the
other services that are plugging into
that again I want to reiterate the
reason why this works the reason why
this holds up is that a service isn't
necessarily a runtime separately
deployed component the way you need to
think about services is they are a
collection of components where some of
these components are going to be
deployed together in the pricing engine
and some of these components are going
to be deployed together in the search
engine and some of these components are
going to be deployed together in the web
front-end for just doing some UI
composition the service is not a unit of
deployment I said that earlier in the
talk I'm saying it again a service is
not your unit of deployment you take
these components from multiple service
and you create a process that is your
runtime deployment the process not the
service there's this many-to-many
relationship a given service will be
deployed to multiple processes and in a
given process you're going to have
components from multiple services if you
follow those two separate degrees of
freedom in your architecture you will be
able to avoid creating all of that
logical coupling mess that we talked
about before so just want to add some
really small bits of stuff just from the
framework design perspective what you're
going to want to have in these generic
engines is some code that asks startup
of that generic framework you process
you're going to the runtime directory of
that engine say ok find me all of the
assemblies which are over here scan each
one of those assemblies see if there are
any types in it that implement I provide
price factor I provide fraud multiple I
filter product IDs whatever that generic
interface is for that specific engine
and once you have all of that then in
essence when you want to plug in more
rules all you need to do effectively is
to drop another assembly in the runtime
directory now you may want to add later
on some more management around this to
say well what what rules are running in
each one of these places
and that's when you start moving out of
say the sort of really generic design
pattern type of world into more proper
rules engines with management and the
ability to turn on or off a given rule
in a given place but you don't need to
start with all of that heavyweight
infrastructure it can really be as
simple as a loop at startup scan the
assembly scan the types find an
interface so I hope I've given you some
idea about how that really old rule
engine approach can be connected to the
more modern microservices approach and
really help get rid of a lot of the
coupling that we would have otherwise
had now my guess is that you still have
a ton of questions and you're wondering
all that sounds great but how do I do
this in my domain so if you want to find
out how to find micro-service boundaries
and how to combine all this stuff
together I've got a five day course and
you can sign up for that my guess is
that most of you you know you got to go
to NDC Oslo that's kind of it so what I
have is a bunch of videos from that
five-day course available at that URL go
particular net slash NDC 17 so go in
there sign up and you'll get videos that
go through a lot of these types of
patterns and practices and a lot more
details and I can cover in just a 54
minutes that I have over here for you if
you do have questions feel free to come
up and talk to me afterwards once again
my name is Rudy de Haan I'm on Twitter
at Judy de Haan and working at
particular software and we try to make
building these types of really complex
business systems easier whether it's
through these types of talks the types
of videos that we have available or
infrastructure that enables building
these types of loosely coupled systems
better so have a great rest of your
conference thanks for having me and have
a great day bye bye thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>