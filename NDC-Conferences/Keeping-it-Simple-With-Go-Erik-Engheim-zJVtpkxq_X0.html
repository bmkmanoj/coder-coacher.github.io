<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Keeping it Simple With Go - Erik Engheim | Coder Coacher - Coaching Coders</title><meta content="Keeping it Simple With Go - Erik Engheim - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Keeping it Simple With Go - Erik Engheim</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zJVtpkxq_X0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Eric enge Haim I work at a
company called Rockstar which is located
here in Oslo and I'm going to talk about
a Google go which is a programming
language from Google it started as one
of these 20% projects that you can the
employees of Google can have and it was
basically to try to deal with the
problem that they do a large-scale
software development at Google
and while languages like Python that
they use are quite easy to use it
doesn't have quite the same
opportunities for optimizing performance
and they use C++ of course which is much
more complex language to work with so go
was I think intended at the kind of
sweet spot between the two of them so
what I'm going to talk about here is not
really a tutorial of the language the
more going through the kind of design
choices that was made in the language
and and the features and why that might
be make it an interesting language for
you to explore in the future so the two
the two main topics that I want to focus
on is software complexity and
performance so why did I choose these
well if you look online for
introductions to go it's very common
that they talk about concurrency because
this is really one of the main selling
points for go they have very nice
concurrency primitives that for people I
want to utilize all the course and their
CPU go is a nice language but I wanted
to do something different that
something's more relevant for me because
this wasn't the reason why I got
interested in go regionally I was
because of the at my company we create a
C++ a desktop application for
visualizing the subsurface so I don't
really work with web technologies and
and concurrency isn't as important for
what I do but this is software that
started back in the early
1990s written in C++ so with a very
diverse team we have physicists
geologists not magicians computer
scientists so it's a very mixed kind of
team and so there's a lot of complexity
in dealing with the stocker development
so I think that go was an interesting
program Lang's to look at how you could
approach some of the problems that very
often come up when you're working with a
complex language like C++ as for
performance you can see I mentioned
Moore's law here so it's been I'll talk
about the end of Moore's Law the the
over the last years what that usually
refer to is the fact that the the clock
frequency of the CPU hasn't really been
going up instead it we've been adding
extra course of the CPU and there's one
way that to dealing without with go
which is using the concurrency
primitives but there are many languages
today that have added ways of dealing
with that you see that whether it's a
closure or a scala
or c-sharp you have ways of doing that
but I think one thing that's interesting
that I want to talk about from
perspective ago is how to deal with
things that have to do with the fact
that we are getting a wider divide
between the performance of the CPU and
main memory so the CPU is increasingly
waiting for data from memory to do its
job I think it was one of the yesterday
I was in one of the talks talking about
C++ optimization I was mentioned that
the CPU spent some like 89 percent of
its time just waiting for data from
memory so laying out your memory so that
the cache can be effectively utilized
it's quite important for performance and
it's not something that's really been
handled very well by the kind of
mainstream languages that we have they
don't really have methods to control
your memory layout and access patterns
so one of the central things I think for
go with respect to dealing with the
complexity of software development is
that they really put simplicity at the
core of its philosophy and by that I
mean in many aspects in terms of the
semantics and the grammar of the
language but also the kind of tools that
surround the languages just if you look
at build tools or formatting dealing
with external libraries and so on it's
very simple usually and I put up this
easy and simple here because I want to
illustrate that these two terms easy and
simple are often conflated but they're
quite different so if we use this
analogy with a circle saw and a handheld
saw you could say that it's a lot easier
to cut wood with the circle saw but it's
a lot more complex you have to have an
electric sockets to to get current to
drive it there's probably a motor in
there that might break down and you have
to service so there's many more moving
parts and things that can go wrong that
you have to understand whereas a
handheld saw anyone can sort of figure
out how that works and if something
doesn't work you can kind of easily
reason about it it's all in there in the
open and I think it's a good analogy for
what go is like it's not the most if
you're writing code you're not going to
get these sort of dense very expressive
things would go that you would get from
some of the other modern languages like
Scala which is very expressive that
allows you to do a lot in a few lines of
code the problem with a language like
Scala I think is that it's a lot more
complex I remember one of the languages
that I was trying to teach myself last
was with Haskell which is you know very
expressive and powerful language but it
takes quite a long time to just
understand the type system where it's
the appeal I think for go is that it's a
language you can pick up in a couple of
days and start doing things so if you're
dealing with large teams
and especially companies that have to
hire lots of people from different
backgrounds you can get them up to speed
with go very quickly now it doesn't mean
that go is extremely verbose or anything
I think that Java is much more verbose
language so they have tried to keep it
simple but also remove the kind of
unnecessary complexity in language so
one area that this is the simplicity is
some a benefit is that go is an easy
language to parse now why does that
matter well it matters because it makes
it a lot easier to build different kinds
of tools like for method completion
refactoring code analysis code
navigation and for me as a professional
C++ developer for most my career it's I
think it's a very relevant thing I think
I program C+ buffers on my 15 years now
and I think most of those years I never
really had any good tools for doing
refactoring and even when I had things
like code navigation would frequently
break down or not work so I think this
is something that is important for a
language to think about so just to
illustrate this with a practical example
so this shows a definition of a function
and the variable in C++ and if you look
at this there's if you're going to if
you imagine that your compiler and
you're reading each token as you go it's
not until you get to the parentheses
that you know that you can distinguish
whether this is defining a variable or a
function and if I was going to write a
regular expression to search for
function definitions it's not trivial
because just searching for something
with the parentheses that could be also
a method call and not a method or a
function call and not necessarily a
function definition if you contrast this
would go if it's a lot easier to read
for the both for us and for the computer
because the very first keyword that you
see in a statement tells you what kind
of statement
is so you start a function with the
funky word you start a variable
definition with var and you would be
from defining a typo we start that with
type and so on
now they do try to keep go syntax to
look a lot like the sort of C++ Java
kind of syntax that were used to curly
braces but they do change a little bit
you can see here they put the type
information in the back and it might
seem like an unnecessary change to make
but I believe this makes a lot of things
a bit easier from a reading perspective
so if we look at an example of a AC
structure it's a little bit annoying and
C you have to write this struct in front
here so what typically C developers do
to compensate for that is to use the
type def and the problem now is that you
have the identify you're creating comes
at the end where you get all this
complexity first that you have to read
before you can see the name of the point
in goal because the type information
comes at the end you can see that first
we start with type this is what kind of
statement are we doing and then then you
get the identifier immediately after and
then the complexity is put at the end so
the last line there that's defining an
instance of a point and you can also do
that with type inference uses Colin
equals so that DV is a little bit from
this idea that you start with a keyword
that identifies where it is another
example I think which is frillies for c
programming and c++ that shows the
benefit of this way of placing the type
information is with higher order
functions so I'm not sure how many know
what the higher order function is yeah
so okay so it's not as known as I
thought it was so basically the higher
order function he comes from functional
programming would and basically means is
a function that takes another function
as an argument or it could return other
functions so in C++
well we have when the sink is that but
back in the day we would use function
pointers and if you look at this
function area takes a function pointer
as an argument unless sure if you look
at this if you can glance and see what
exactly the name of the argument here
and imagine if we have more arguments
it's not very easy to read this so the
argument here is called foo now if you
contrast this would go you can see that
and go the identifier always comes first
and the type information laughs so you
can see that right away even though you
have this complexity of the function
definition so that's here so if you want
to use this here's the definition of an
increment function we're just passing
that to bar so that's the bar is our
higher-order function it will look quite
similar and go doing this so because
this part of here looks is awful to read
what we usually do when you're
programming whether it's C C++ or even
Objective C I'm actually program more
Objective C the last years you would
typically use a type def to give it a
name but even that is a bit awkward I
found myself having to look this up
because the the name of the type theft
is located right in the middle here so
that's that's not very nice to read
resin and go this is quite
straightforward right you get you start
with the keywords saying what statement
is and then you get the identifier in
the complexity type at the end some
thing I want to talk about is types and
go so there's a lot of different kinds
of types and go that you're used to
strings integers floating point I don't
want to talk about all these so just
going to talk about the things that are
interesting because they're different
from what you're used to so the first
one is arrays so that's different with
arrays and go is that there are value
types and what does that mean well it
means that if you're trying to assign
from one variable to another you're
actually copying the whole array over
you're not just having another reference
or another pointer to that array another
interesting is that the length of the
array is actually part of the type so if
you think about this you can mention
that causes that would cause some
problems right because if I try to pass
if I try to define a function say a sort
and I have to specify the length of the
array then that wouldn't be very generic
function you know I don't want to write
a different source function for every
possible length of an array so how you
deal with that well go have something
called slices so that just it's a very
lightweight data structure that just
points to some underlying array and
defines as a starting point and an end
point so the way you would create a
slice is just using the colon operators
to define the start and the end point
for this slice and you can see in the
orange bracket here that we don't
specify any length so length is not part
of the type of a slice so this is kind
of how you deal with general functions
in an go if I want to do a sort function
or a find function then I will typically
have it accept some some slice a very
common thing then would be to create
empty slices so a lot of time when
you're programming go you're not really
creating arrays directly but you're
you're creating slices but it'll be a
little bit cumbersome to first creates
the array and then take an empty slice
from that so we have a built-in function
calls make that will let you do that
so the green is is the number of
elements you get and then in orange we
have the capacity of the underlying
array now this might make you think that
why should arrays be value types in the
first place and that the type the length
should be part of the type well there
are advantages to it so I'm going to try
to show you that with this example so
imagine that we have one way of dealing
with say array vectors that could
represent say points in space
or a velocity in one particular
direction you could do it like this with
a structure so it has an x and a y
number and then we could set the
individual elements like this we're
creating a V vector and a u vector here
in different ways and what we might want
to be able to do operations like adding
two vectors together now might be nice
to actually be able to iterate over
these the components say it is X Y Z and
so on and you want to be iterate over
them you can't really do that with a
structure so there are some advantages
to using an array for this so then we
would define the VN u like this you see
is that the number of elements in the
array comes before the the element types
and then we want to be able to do the
same thing as I showed you earlier so
this is how we would implement that so
now this will just be copied you can see
there there's some simplification and go
where you the arguments have the same
type you don't have to put it on the
back behind each so that can save you
some typing so the benefit of having the
lengthening prototype is if that I put
the wrong index air for instance for
then I would get a compilation error
because the compiler knows that there is
nothing at the fifth element in this
array okay let's look at defining new
types so this probably look if you're
familiar with C or C++ this looks
probably a little bit like a type def
you're creating a Celsius and a
Fahrenheit type based on a 64 bit
floating points that we typically double
in in c-sharp or Java
now we assign some values to these in C
or C++ you could just add these together
that we find but in go you will get a
compilation error
though is very explicit with everything
you don't have sort of automatic
conversion from one type to the other so
if I'm adding a floating-point value and
an integer I'm not going to get a
conversion I'm going to get a completion
error and I have to explicitly do the
conversion so what we typically want to
happen is I want to be able to define
say some Celsius degrees and then be
able to convert that to Fahrenheit when
I need to so see here that I'm putting a
method on my body temperature variable
and that's a cool thing in go you can
add methods to the primitive types so
way you would do that is like this so
the way you can see that this is not
just a regular function a free function
but a method is this first the first
part here so we don't you have to be
explicit about what we would normally
call it this or a self pointer in other
languages so now you see methods I think
it's it's good to talk about
object-oriented programming because
that's quite different in go the
background for ghost take on
object-oriented programming is that
inheritance hierarchies are problematic
and I seen that a lot in the work that I
do with C++ it's the application I work
on started back in the early 90s and I
think for a lot of applications back
then they people thought that obviously
oriented programming was a kind of
silver bullet so they tended to overuse
it so what we see is often we have these
ten level deep inheritance hierarchies
not very nice to try to make a
modification in there or understand what
these different classes are and then
there's other minor annoyances like you
override a function or a method and you
wonder am I
chose to call super in here or so the
Supra dot and the method right
and then you might wonder should I call
in the beginning or the end and then
there's other things that I guess don't
Papa's often but sometimes it happened
to me which is when I change some member
function that's being called by another
method which we call another method
initially is called by the constructor
so I change that to a virtual method and
then it would blow up when you're
running the constructor because you
can't call a virtual method from a
constructor not even indirectly and you
don't necessarily get a very nice error
message from that another thing is I'm
not sure any of you heard about the
fragile base class problem one person -
okay so the price a base class problem
is two kind of theoretical criticism I
guess you could say about inheritance
which is the ID and observing
programming right we have these silos
you you can just work separately with
your class and do whatever changes you
like and as long as you maintain the
interface everything is supposed to be
fine you can nothing's going to change
in how you interact with everybody else
but when you're doing inheritance that
kind of encapsulation or separation kind
of breaks down and I'm going to show you
this example how that works let's
imagine that we have a bag class where
we're just holding up a number of
integers so this is this is some Java
code here and we're able to add another
integer check how many integers we added
to the bag
and a convenience function allows it to
add all the integers in another bag now
this is of course a bit contrived
example just to show you so we're
creating this counting bag which is
supposed to be a kind of optimization of
course a little bit pointless where
every time we calling add were
incrementing this n variable that is
supposed to optimize count because you
can just return n
and checking the the items of course
this will only matter if you're using
prisons a linked list or something like
that where you have to use linear time
to count the number of elements anyway
we're going to focus on the add all
method so imagine there is a develop
that comes along and he figures out oh
it's very poor performance a call adds
indirectly on all these elements it's
much higher performance for some reason
to just call add directly on the items
now what's going to happen you could do
this change what happens is that you no
longer call the add that has been
overridden in counting bag which means
the N never gets updated so the counting
bank doesn't work anymore and that's not
supposed to happen because if you
consider bag the developed there has not
changed any of the external behavior if
you ran this in a unit test all the
external behavior would still be the
same and the person that's created the
counting bag
class did that occur didn't do anything
wrong with an involving the interface so
these are kind of problems can happen
that kind of is not supposed to so it's
not with our reason that object-oriented
programming
people have sort of realized that there
are some problems with how we do it
today so there was this um I read there
was this Q&amp;amp;A session with James Gosling
so the creator of Java and they asked
him if you could do Java over again what
would you change and it said I'll leave
out classes so I'm not sure people took
baths entirely is serious but that's
that's exactly what they have done in go
so there's no classes and there is no
inheritance in go instead go focuses on
compositions or maybe what we call a
mixin if you're using for instance Ruby
now you can do composition in pretty
much any language of course the
difference is that
go when it's added specific features to
accommodate it more now you might wonder
well how are you going to do
polymorphism if you don't have
inheritance well you can define
interfaces that types can adhere to so
that's still possible but they work a
little bit more like duck typing
unless you're Rui familiar with the term
duck typing yeah it's something that's
common for dynamic languages like Python
and Ruby and basically idea is that you
don't care necessarily what you say the
type is but more about what's the
behavior if it's if it quacks like a
dock it walks like a duck then it's a
duck is kind of the idea
so what go has is sort of like the
static type checking version of this is
which is called structural typing I'm
going to show you that in a moment how
it works so let's just look at this
example imagine maybe this is some
application for drawing application you
can draw different shapes and you want
to check whether point is inside a shape
so depending on what shape you're
checking there's going to be a different
algorithm for checking whether a point
is inside a circle compared to a
rectangle so that's why we need some
kind of polymorphism to deal with this
to pick the right algorithm at runtime
so what we basically want to model is
some interface that I have here in
yellow a shape that you can ask is this
point inside the shape and maybe some
optimization opportunities like checking
for a bounding box so you can quickly
look through all the shapes and in gray
we have some concrete cases a circle
rectangle might have a polygon and so on
that would implement concrete algorithms
for for checking inside on those
particular shapes so if you are doing
this and say C sharp we probably do
something like this to find an interface
shape then
then we would inherit that and implement
the inside and bounding box and likewise
for a circle let's look at what they
look like in and go so again we start
with with we type in the beginning and
then instead of putting struct in the
end we're writing interface so we have
to list up the methods that have to be
in this interface so this is a
definition of the the rect structure so
you can notice one thing that I quite
like about goal is that you don't put
the methods inside the tight so I'm not
sure if you think about it what's the
benefit of doing that well the benefit
is that you can put your methods in
different files so if instead of putting
a lot of code in one file you could
spread it out and if you look at this
you might notice if you look at type
that there's something that's miss
seemingly missing and same if you look
at the circle you can see there's no
mention of shape anywhere there and
that's what I talked about the duck
typing or the the structure of the
structural typing which is that in in go
you don't have to say that you're
implementing an interface it's enough
that we have inside and bounding box
which is the finance interface so if I
was add some function that took a shape
as an arguments and check whether a
point is inside then I could just create
a rectangle and I could pass that
rectangle to this function mouse click
and go within in codes check if this at
compile time check whether this type
matches the interface defined on shape
so what's really nice about this is that
you can you can get a third-party
library from someone that say you can't
make changes to and maybe they haven't
thought about after interfaces for those
types that could be useful to have but
you can just define those after the
facts and go because you don't have to
say that something implements interface
so I can just add interfaces so if you
can gain me some code I can just add
interfaces in a way to that code data
structures and go I think is quite
versatility you can define this you just
saw a rectangle like this so you don't
really use normally constructors and go
there actually there aren't any
constructors in go and you can also use
a more verbose way of doing this where
you're writing out all the members
I might wonder well that's the benefit
of that well here's a cool thing if you
look at the JavaScript dictionary usage
this is very similar so you can just
like in JavaScript you can create some
very complex structure with a lot of sub
structures in it and we can initialize
in very much the same way and you can
change to order things and you could
have excluded say for instance the Y and
go would have initialized that as 0 so
you get kind of the benefits of a
dictionary in JavaScript but it's it's a
statically typed so I couldn't add
elements that don't actually exist there
let's look at this alternative and go to
inheritance so we're doing composition
in go when we kind of want to mimic what
you often do with inheritance we use
something called embedding so to show
you that I'm going to I'm going to do a
slightly different rectangle than in
there earlier so say we have this point
and size type and then we define a
rectangle like this so you can see a
difference is that I didn't put any
variable name in front here I just put
the type straight in there
and this is what's called embedding and
what that allows me to do is if I create
a rectangle like this then we just as
name of the variable you will just use
the type name so it will be like this
but the cool thing is that I can do like
this so basically the X and and the
width in all these they become available
at the top level so it's kind of the
same that you would I do if I was
inheriting size and point in a rectangle
so let me show you how the the bag
example would work with embedding and
why you won't get into the fragile based
class problem so we're defining the bag
has a slice of integer items and since
go doesn't have constructors we have to
just create a regular function you can
see that it returns a star bag so for if
you're not used to see your C++
programming that's returns a pointer to
a bag object so go does have pointers
but it's not it's not in the bad way if
you will that it wasn't simple to us you
can't do pointer arithmetic so you can't
just point to arbitrary places in memory
and the the ampersand symbol that you
see in front here that takes the address
of the object so that's what gives you a
pointer yeah yeah yeah exactly so
imagine in this case we want to treat
this as a kind of reference type I guess
now when when interesting thing airs you
normally wouldn't necessarily relax a
with the rectangle I didn't define any
special function for doing this but you
can imagine is that you have a number of
members in your struct that you have
some invariants that you want to
maintain so that you don't want people
to just arbitrarily set values there you
want to have something that creates it
then what you do is when
in Ingo if something has a lowercase
letter in the beginning its privates for
that package so means if I use this from
another package
I couldn't create an instance of it
because it has elements which are
private so I would have to use a
function that it's public so something
that starts is capitalized like a new
bag to actually created so it's a kind
of way you can also get the same
benefits that a constructor has and then
we have add item we're using a built-in
function called append that allows us to
increase the size of a slice and there's
a built-in function Len that gives you
the number of elements in a slice or in
an array then we have this at all a
convenience function so in an go we can
we can write a regular for loop that
you've probably seen in most of these
c-like languages but we can also use the
kind of Python ish thing where you set a
range and that gives you each element in
that successively so let's say we create
the counting bag what we do is we embed
a bag inside it and then we do I'm not
sure what the exact terminology would be
I would call this is basically a
shadowing of the add method because what
happens because we're doing embedding
all the methods that exist on bag would
be available at the top level but you
might want to change them so we can do
this kind of shadowing it's not quite
the same as overriding so we call add on
on bag you can see the first line there
and then we update the end now we have
our counting bag that or optimization
now if we look at the case where you do
the optimization the problem is that no
one would ever do it that way and go
because they would know that this at all
here can never call counting bags out
because it's not an override
shadowing so the counting back can't
change anything in the behavior in the
bag so anyone who would implement this
would also shadow the a doll so you
never will put yourself in a situation
where you can just randomly change
something and break it I talked about
that go is good for large-scale software
development one of the reasons for that
is its compiled spouse so when talk
about why that is there's nothing that's
been on my mind because the software I
work in has something like one hour
compensation time and that's really bad
for productivity of course we've gotten
better now so we can do more incremental
bills but it's still something like it
can be five minutes or so so go has been
designed specifically to to run saps and
it seems like it's not necessarily
always given with modeling's today to be
that from what I understand Scala is has
ignore this is actually quite slow and I
guess for a C++ developers perspective I
you know no one should ever forget that
another thing I I dislike with a lot of
modern software developments I've been
an iOS developer for some years and also
did some Android development and one of
the things I noticed area is just to
build systems that go slow for C++ but
also in the Java side of things can be
very complex you know I thought when I
looked at the Java even thought am I
actually an XML programmer and it's
quite a lot of XML that you have to deal
with goal is pretty neat in that you
actually have no configuration files
goal just fetches your dependencies and
and builds so you might wonder well
how's that possible
whether they went done is that they
thought about it in the language itself
so when you write in the source code
import you write actually where it's
located on the internet so because it's
built in a time where people were used
to how
living code on github bitbucket and so
on so you can just write the location in
your source code to refer directly to
your repository
now that gives us a problem with dealing
with versioning so one of the ways that
they deal with that is kind of like I
guess with the rest api so you put in
the URL so you put say a v1 air to refer
to version one I know this isn't the
perfect solution I haven't built big
enough systems and go-to to really
encounter this as a problem for me but I
know that it's something that some
people complain a bit about so when you
want to build a go project just right go
get and that will pull down it will look
through the source code and pull down
all the dependencies and then just write
go build and you're done so you know
make files or ant or whatever to do this
another important thing for being able
to build fast is dependency analysis so
in go if if we imagine see here is a
package and go so that a package could
be a number of files that have in the
beginning you write some a package name
if we compile this we would get a bunch
of code in the binary file and then in
the header you would have the the
exported types foo and bar because they
are capitalized they are public so
they're going to be exported now imagine
that B depends on this so we have a new
type spam that's using the foo and the
bar type if we compile this it's only
going to export spam and bar that's
because well spam was defining B and bar
is the only type that's actually visible
from spam because you can see the the
food type here that has an instance
variable of ham that is private because
it's a lowercase letter in the beginning
so then when you're compiling a you
don't have to know about this so if
you're compiling in C++ the problem
there is if you're importing these
headers say I'm compiling some a dot CPP
file and if I'm importing B then I'm
also end up importing the headers for C
as well so you're importing the same
files over and over and over again so
this is one of the reasons while C++ is
very slow to compile is of course a lot
better in Java and I guess also in
c-sharp but because you can have
circular dependencies there you have to
keep a lot of files in memory and that's
something that's illegal to do in and go
you will actually get a compilation
error if you had a circular dependency
something was it yeah you'll get an
error mrs. s import cycle not allowed
and will tell you where the cycle is so
let's go to the next main topic which is
performance so when I start with saying
why memory layout matters there was a
project I'm not sure if that's still
around but it's called Jake it's which
is implementing it in Java and what's
the develop when a developer Sara called
Sean O'Hair's comment was that Jay gets
really struggled with performance
because I didn't have an efficient way
of representing the sha-1 hash values
these are just structs in NC that
contain a 20-byte character array and
this could just be made into one
contiguous block of memory and see
whereas in Java if you do that because
it's everything's references in Java you
would have like pointing some different
location in memory I'm going to show you
what we mean by that so this is the
overheads that's imposed by classes
if I define this type points in Java
with an x and a y so you see the green
is what you actually is interested in
the X and the y so that's we got four
bytes for each of these and then on the
top here we have mark which is used by
the garbage collector
and classism where it's storing what the
the type information about points and
then we have this four bytes or ages
wasted to gets alignment in memory if
you contrast this would go go only has
going to use only eight bytes of memory
where Java is going to use 20 bytes
member in this case because in go you
can't have any inheritance that means
there is no point in keeping track of
what the type is you know what the type
is and yeah this gets worse if you get
more complex structures so if I define a
rectangle that contains two points you
will end up with this situation Java so
you're getting this leaves area three
times over
whereas ingo you will just get one
contiguous block of memory this gets
even worse if you're looking at a race
so we have an array of the three three
elements here three points and then each
one will just point to different places
in memory right so going to be spread
out whereas in go if you create three
points it's just going to be a
contiguous memory like that why does
that matter well we can look at what
happens with the CPU and the cache if
we're having fragmented memories so on
the top here we got five elements that
we want to read and then I just simplify
this a little bit like a toy caste we
have these various slots in the
- and not sure if you know how the CPU
works but when you're reading an
individual bytes of memory you want to
get a bytes you never actually read just
the one byte you're always reading a
whole cache line that can be something
like 64 bytes at a time and that's what
goes into one of the slots in the cache
so if we if we're trying to read these
five elements and then we do we get one
cache miss to get these first two
elements and another cache miss to get
the third one then we continue like this
- so we get three cache misses sorry you
get four cache misses whereas when we
got contiguous memory we get one and two
cache misses
now this matters a lot because memory is
so slow that in the period we get a
cache miss we could execute something
like a thousand instructions so there's
not much point in you know optimizing
your your algorithms or multi-core or
whatever if your memory access pattern
is awful
there's going to be slow anyway so just
in short really what this means is that
data should be aligned with the cache
lines because if it's not aligned right
you would have to read to two cache
lines and you should avoid getting
fragmented memory and I didn't really
touch upon that but generally speaking
you should have memory that's used
together it should be our data is used
together should be close in memory so
for instance if I have rectangle you
don't want the lower the point to find
lower corner in some area of memory and
the one and the upper corner another
memory because you're typically going to
use both of these at the same time now
you see that you could embed stuff in in
go so might wonder ooh and I saw that I
had a pointers you might wonder well why
do we need pointers at all if it's so
great to just create these contiguous
blocks of memory
so the obvious need is for recursive
data structures like a tree or a linked
list so the way we would define these in
an NGO is like this we have a we have
the the value and then we have left and
right and then we put the star there
that indicates that this is a pointer
and likewise with a linked list so this
is how pointers work the star is used
for what we call dereferencing so usable
that indicates something is a pointer
but when we're using it in encode we are
using a presenter called dereferencing
and the ampersand is used for taking the
address of an object so let's just look
at how that works
Sarah I'm putting a number in V and I
want p2 to point to this V so I'm using
the the start to say that P is a pointer
and then I'll use the ampersand to get
the address and then put that into the
pointer so if I want to change the the
thing that's being pointed to by P we
have to put a star because otherwise we
just change the address so this is it's
going to change the value of v2 to so a
bit more practical example here if we
have a linked list and we want to link
together all the elements in the linked
list then we can define the elements and
then we just to take the next pointer to
a we take the address of B and then the
address of C to put that on on B's next
so one thing that's nice with the
ability to use pointers and and the fine
structures in memory and control the
memory layouts that you can do in go is
that we can create what we call
secondary memory alligators so even
though go is a garbage-collected
language just like java unlike Java in
house you have the ability to create
alligators that are a little bit like
what you could accomplish in C and C++
so I'm going to show you something
that's called an arena alligator that
could be useful for say binary tree
where you know that every element is of
the same size it could be useful because
for a binary tree you could create a lot
of elements and they get scattered
around a memory you might want to
control where they're located in memory
and you want to do the since you know
that they're all the same size and
potentially you could do the allocation
very fast
so here's an example how that would work
you would start by allocating some chunk
of memory and then you would take that
chunk and have each elements point to
the next you create what we call a free
list which is what we're using when
we're figuring out which element can we
take from our memory allocator and use
when we're building up our tree so we'll
just always the way it works is you take
from the top you take in elements so we
allocate their roots node then we take
the next element from the top so we just
continue like this
now with none we used up all the memory
so then the arena alligator would have
to get a new chunk of memory now we can
start and we have to create the new free
list and we can start pulling off that
free lists I might want to wonder what
happens if we remove an element so I'll
say we remove the three well then that
will go back into the free list again so
on next allocation that will be the one
that's pulled off so the way we would
implement this we start with a function
definition undefined here some values to
initialize a note and then so this is
the the arena that were allocating from
and then we're getting a tree node
returned defined here the how the type
looks so we have the head which defines
the the head of our free list so when we
go into this function the first thing
with check is is the head empty
is it nil it is empty well we have to
allocate a chunk of memory I said so
weezing make to create a slice with the
underline array of three elements and
then we iterate through this array and
set the next pointers so we get our free
list so you can see there you see the
ampersand so you I get the address of
this one becomes it set on the left and
then when we're done I'm done with that
we set the first note to be the head
node so regardless whether you have to
whether head there's nil or not the next
thing you would do is we just take the
element from the top right from the top
of the free list and then you would set
you would set this this head to point to
the the next number to here so we're
doing there
and then finally would initialize our
node so let me summarize what we gone
through the whole idea of go is we're
choosing simple over easy so we're not
necessarily making the most compact
expressive language but we're trying to
make it very explicit and and simple to
use so people can learn it quickly and
you don't have a lot of gotchas or magic
that can trick you over I really noticed
this I was on a Ruby on Rails project
and it's I knew from before that it's
really fun to write Ruby on Rails it's
so fast to write Ruby code but I noticed
I didn't try being on the other side and
jumping into a project I don't noticed
that all this magic going on in Ruby was
pretty awful for reading the code and
that really made me appreciate that and
go it's it's very explicit so the ghost
standard library I think is some of the
easiest code that I encountered to just
read through so even though when I did
iOS development and I wanted to find out
how for instance something of HTTP
protocol worked I would typically prefer
to look at the go code action the
standard library to see how it work
because I thought that was easy to read
and another thing is that a language
like Java has a lot more efficient
garbage collector than go so they kind
of just chosen a sort of middle ground
between manual memory management and
garbage collection but they have a less
efficient garbage collector but they
give you a lot more ability to control
your memory access patterns and
potentially make your own secondary
alligator's okay so do any of you have
any questions I'm not sure if this are
there anything you want to revisit that
wasn't clear about how go works yeah
to work in this one you don't have
generic yes so my experience is it's
something that's typically brought up by
people who don't program go it's a very
common complaint about go and I think
that it definitely is a - I mean I I
think generics is quite nice - how often
it's but I don't think it's nearly as
bad as people make it out to because I
think you will see that when you use go
that the way the language works makes it
much less of a problem there are some
example code that people show how you
can create kind of generic things and
the language features make is a little
bit easier to avoid the same amount of
boilerplate that I would get say if I
was doing the same thing in C
programming language for instance so
although it sounds like it's going to be
a lot of repetitive coding and annoying
I I must say that in a lot of ways I
found go programming more fun than say
Swift coding which I quite liked Swift
but even though Swift has all those
features that go was supposed to have
kind of you know it doesn't have nil
pointers have generics a lot of much
more kind of meta programming it's also
feels a lot more constrained and strict
ago it's very very pragmatic language I
think yeah any other questions is
anything he wants me to revisit that
yeah so that could be one issue so as I
showed see if I can go back to as you
see
you see they here the one weighs just
creating I guess a different repository
and just put the version number there in
a way so you just have that as maintain
that at a different version I know that
it's something people complain about and
go but it's it's possible to do it yeah
to download one specific version yeah
you could you could set up everything
kind of manual I mean there's nothing
really that prevents you from say
creating a make file and just specify
where you should get everything so you
could yeah I mean I could this path
could be somewhere locally on the file
system so it's kind of up to you if you
want to do it in a different way yeah
so this is kind of outside of my era
expertise I think that maybe when you I
think if I remember correctly when
you're building you might specify
something some information about that in
flags but I know for instance if I
compare it to to objective-c or iOS
development where you can rely more on
some scheduling in the kernel I don't
believe you can do anything like that
and go the jack you would have to look
that up it's not really something I know
that much about yeah anything else
yeah so one thing that I thought was
really cool I haven't tried it a lot is
a kind of very generic refactoring tool
so you know how you can specify regular
expressions so this is kind of lets you
specify kind of grammar and go and then
a replacement pattern so you can have
kind of like a command line tool that
you can do a kind of primitive
refactoring woods they also have yeah
you want you wondered about generics
there there are some opportunities and
go some tools and some integration would
go where you can generate you can
generate code so you could have a kind
of a code template if you wanted to
mimic something like generics yeah oh
I'm I'm one of the holdouts on on Mac on
textmate but you know it is not so
updated now so the last thing I tried
was Adam which I think was that's quite
good tool sir so you gets well both in
text mates and an Adam you can install
things that gives you command completion
but then Adam you had more things you
can jump to a definition as you're
typing you can see the arguments that
you need and so on
I think I try that way back but I think
that's probably a lot better than any of
those a few I'm a little bit anti IDs I
guess you know when I kind of likely
would go that I didn't have to use it
otherwise I'm usually stuck with an ID
if I'm doing iOS development is no way
of doing that without an ID yeah anybody
else okay well thanks for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>