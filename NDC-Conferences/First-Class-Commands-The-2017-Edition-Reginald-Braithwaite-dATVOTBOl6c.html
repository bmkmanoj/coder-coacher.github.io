<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>First Class Commands: The 2017 Edition - Reginald Braithwaite | Coder Coacher - Coaching Coders</title><meta content="First Class Commands: The 2017 Edition - Reginald Braithwaite - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>First Class Commands: The 2017 Edition - Reginald Braithwaite</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dATVOTBOl6c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning thank you very much for
attending this talk I'm sure you are
going to be the very best audience I've
ever had today's talk as you can see is
about first-class commands which is a
design pattern that goes right back to
the original Gang of Four design
patterns book and I do find it to be a
useful and powerful pattern and I'll be
talking about why I feel that way but as
you can see from the subtitle the thing
that I find most interesting about this
particular pattern is that it's fertile
and what I mean by fertile is pretty
much exactly what the word literally
means it gives rise to other ideas it
provokes other thoughts other
architectures even if they're not
directly implementations of the
first-class command pattern so for those
who are not familiar with the pattern I
am going to discuss the pattern of
course and then I'd like to digress and
discuss some of the things that
implementing the pattern or thinking
about the pattern have provoked both in
myself and in other software designers
and I hope that either this will remind
you about why you find this pattern
interesting if you've been using it or
will make you curious about other places
you could take software design
now in software when we say something is
first-class we mean that it is a full
fully important entity in our software
for example if we say that a language
like Lisp has first-class functions we
mean that they can be passed to other
functions as arguments they can be
assigned to variables they can be
returned from functions they're just as
fully featured as any other value that
you would have in the programming
language a command is exactly what it
sounds like if someone says reg be on
stage at 10:20 they're telling me what
to do in software I command is the same
thing it's an instruction to tell
something else to do something and when
we say it's a first-class command we
mean that that instruction can be passed
to a function return from a function
store it in a variable and the first
part of this talk is going to be exactly
what the screen says why do we care
about commands and from there what power
do we get from making them first-class
so let's get started the canonical
example of using commands is when you
have some sort of mutable data I myself
am a big fan of the more immutable data
functional programming paradigms however
somehow in 35 odd years of programming
I've never quite been able to escape the
fact that most programs actually have to
make something change or appear to
change so we're going to talk about that
today there are ways to take everything
that I'm going to talk about today into
a more immutable data functional world
we're not going to discuss those here
today but those of you who are
functional programmers are super excited
about functional programming well no
doubt want to take these ideas and and
to take them to a new place so here's an
example of a hypothetical mutable data
structure it's just a buffer and I mean
it in the sort of old-school Greybeard
sense of some sort of string or other
thing that we can edit like a buffer in
in an editing program as opposed to
strictly a buffer in a signal processing
sense we have some way of constructing
this data structure I happen to be using
JavaScript for the examples but this
programming this pattern goes back to
small talk C++ I originally learned it
with something called object pascal and
those of you who are getting a little
Grecian gray in your in your hair and
beards will lab will remember that from
way back in the early early early
Macintosh programming day we have a
replace with method and we have some
sort of way of turning it into a string
we've encapsulated some sort of data
which looks like a string and with some
methods
and this is the type of thing that we
might use when working with a buffer we
make a new buffer we give it some
context some content of course we could
have a constructor that takes content
and so on not important for this example
and we have an ability to replace
sections of the buffer with something
new if we were making a really really
really ultra simple text editor the kind
of thing you might do say if you're
teaching your children to program or
something you might use a structure like
this and in fact we're mostly going to
talk about text editing here today
although there are many many many other
applications besides this but this is a
particularly easy one that I think
everyone can grasp so here we have a way
of creating a buffer and then doing some
edits on it using the replace width
method now our buffer is an object and
somewhat conforming to the
object-oriented pattern or paradigm it
has methods that act upon it and it
encapsulates inside of it all the ways
to implement the methods that we that we
invoke on it in the object-oriented
programming paradigm we treat objects as
first-class entities we assign objects
to variables we can pass them to
functions or methods as arguments we can
return them from functions or methods
objects are just like int or strings
some of you are old enough to remember
when that was revolutionary but I hope
everyone is nodding along and saying yes
we get that it's 2017 not 1967 now we
happen to have only one method of
interest in this super toy simple
example replace with but of course we
could have others but there's this idea
of an object and a method that you
invoke upon the object
but in most programming languages
methods are not first-class entities you
can for example in C++ get a reference
to pointer to where the method can be
invoked but you actually don't have the
method itself in languages like Ruby you
can actually get unbound method
separately in JavaScript you can get
functions which you think are bound to a
prototype and so behave like a method
and we can in some languages get methods
as first-class entities and if not if
there's not a convenient way to do it we
can make our own and let's take a look
at an example of how to do that here is
an invocation of a method so there's the
method itself there is the object upon
which the method is being a boat and
then there are the arguments for the
method now invitations are not
first-class entities in JavaScript
they're not first-class entities in
small talk they're not first-class
entities in C++ Ruby allows you to get
unbound inbound methods but they're not
first-class entities in Ruby they just
happen if Emily they just happen but
what if we wanted those to be
first-class entities notice not the
method but the invocation of the method
what could we do with that well if you
think about an invocation we have a
couple things that happen we have to
know who the receiver is we have to know
the method itself we have to know the
argument in a world full of mutable
State it's a little bit more complicated
than that isn't it because the receiver
was in some state before the method was
was invoked and then it'll be in some
state afterwards and modern languages
being as garbled as they are except for
those people who are in the room where
Haskell is being displayed or perhaps
elixir will tell you that a lot of other
side effects that can happen the outside
of the object that's actually receiving
the method
so they're a little bit messy but if we
had some way of treating them as
first-class objects we'd be able to do
some things with them I mentioned a
couple earlier multiple times we would
be able to pass them as arguments to
another method or a function we would be
able to receive them back as a result of
a method or function we'd be able to
store them in variables let's talk about
that last one what could we do if we
could save in vacations and again not
methods but the indications of methods
we could put them in a variable what
kinds of variables do we have we have
simple variables we have maps we have
queues we have arrays we have properties
of other objects
here is an editing piece of editing
software and this edit class represents
a method invocation we give it
everything that we want to invoke in
replace method on a buffer we construct
it and then later whenever we want to
actually perform the invocation we call
do it this is a form of delayed
invocation
here's our buffer object again but we've
made a change notice what happens now
with our alleged replace with instead of
mutating the buffer in place it returns
an edit object
and now whenever we call your place with
on a buffer we can take what it returns
and we can push it on to a - how many
people here are doing front-end
JavaScript development out there in a
full stack or focused yeah I know
asking nowadays about front-end
JavaScript development is like asking
about punch card development the 1960s
everyone does it even if that isn't your
thing this looks awfully familiar this
looks a lot like getting a promise back
from from performing a lot of
asynchronous indications doesn't it and
we're going to talk about that in a
moment but what we're going to do is
every time we allegedly want to make a
change to a buffer we're going to get
this edit object back and put it on a
job queue this isn't the only thing we
can do but this is a good example of one
and then after we've done that a bunch
of times we can invoke them in this
particular case is no difference between
the old invoking the method which
changed the buffer right away and then
sticking them all on the queue and then
invoking them in a hurry but once we've
got this job queue we can do other
things with the job queue this pattern
is sometimes called manager worker I
think sometimes but it's related to the
command pattern job choose give us the
ability to defer execution in the last
bit of code that we just showed we
didn't deferred for very long we tried
to execute them all right away but for
example if part of that was an
asynchronous invocation we could wrap
some code around that that handle
promises maybe call the RSVP library or
something and force them to be
serialized something like this
now the fact that we have taken that
invocation and put it into an object and
this is what promise pattern is about in
a very specialized way and where is the
command pattern is more general is what
allows us to separate the issue of how
we want to invoke things from those
things that need to do editing changing
or whatever the buffer knows okay when
you want to replace something here's a
here's a command but the buffer doesn't
have to know anything about whether
commands need to be serialized it
doesn't know about whether they're
asynchronous or not we separate concerns
and later on in this talk that I'm
wrapping up there will be a slide that
talks about separation of concerns we
can this particular thing by the way I
stole from the Ember concurrency
homepage because it's a nice diagram it
shows about serializing a bunch of a
bunch of commands one of them has
finished in this diagram one of them is
currently running and two others are
waiting we have the ability to control
this separately because we've bundled up
the indications into into objects we
have the ability to this particular
thing as a diagram that was shown to
explain how ember concurrency works but
we could actually display this type of
thing to users and in our user
experience in their user interface if we
wish to and we have the ability to look
at the state of one of these objects
if we add a new method to edit we can
ask it questions now if things were
asynchronous and concurrent we could ask
what is your state are you waiting are
you running are you finished but we're
going to talk about another thing we
could ask those things are all generic
to all asynchronous objects but what's
interesting is when we have things that
are specific to the particular command
in the case of an edit what how much of
the text has changed that matters in the
case of a user experience we might want
to know whether the string is going to
get longer or shorter so here's an
example we do replace with we get back
an object and then we ask it for its
name for its net change the first one
adds 40 for the second one subtracts one
from the length seems like a very simple
idea as you said before with
asynchronous commands we might care very
much about their state this is useful in
a lot of cases one from an actual
production application I happen to be
very familiar with if something is
currently running you sometimes want to
display a little progress indicator now
you can do something like you can say
okay set is loading to be true fire off
some asynchronous event then in the
promise on the dot then I want to set is
loading to false wait I have to also
catch in case it doesn't resolve and
it's rejected so I have to set is
loading in that case and then let me see
now can it's actually throw an exception
or will it always come back with the
catch I think that depends upon exactly
how the promise is constructed so I
might have to wrap it all in a try-catch
handler very annoying much easier if the
command actually just simply exposes
this current state and then you can
sector is the the is loading or the
appearance of a button or whether it's
disabled based on the state of the
object
you can also do a similar thing if you
want to do bounce commands if you have a
button that saves or submits a passport
application online and someone clicks it
a bunch of times you don't actually want
to take all of those submissions at once
so you usually have to have a little
piece of code and you can call you can
wrap a handler in the debounce function
and if I were reading a book about
functions that lap functions JavaScript
along say for example that might be what
I what I'd find really exciting but it
might also be exciting to simply say to
yourself okay what if the thing the job
queue or whatever that knows about
managing these commands can also have a
little bit balancing for us that way the
piece of user experience code doesn't
have to know about debouncing that way
the Edit the Edit object does not be
added object that the buffer object
doesn't have to know about debouncing my
persistence store using whatever
framework doesn't have to know about
debouncing the queue that's managing
things knows that it can only execute
one command at a time again these are
specific examples but the larger pattern
is if we take the method invocation out
of the object that would otherwise
manage it state the buffer it gives us
the ability to take certain things like
inspecting the state or serializing
things that are asynchronous or
debouncing and put them somewhere else
so our concerns are neatly separated in
each particular thing that we're working
with a buffer a queue has a clearly
delineated set of responsibilities that
are I'm sorry I use sometimes use
complicated words because because it
makes me seem smart responsibilities
that are congruent
another thing that we get out of
commands remember our job - in the
original example I won't go back to the
code we simply remove them from the
queue but we could mark them as done for
example we could have a history most
software applications have a history we
call it a log and then you have to go
and buy or rent or build a whole bunch
of tools to grep through the log and
find things that you want and if you
actually want to expose that as a
first-class entity simple logs are not
going to do I don't know about rails
logger or ember logger or whatever but
all those things are completely useless
once you get to applications at scale
this entire industry is built around
being able to manage laws and it seems
so silly when really what we'd like to
do is just have them as first-class
entities we already have tools for
displaying list of things sorting things
searching things and whatnot they just
need to be models right and if we have
commands we would have models now this
particular application that again I'm
quite familiar with work on didn't do
that when it was first designed so
believe it or not things happen and then
another piece of code somewhere else
looks at the things that are happening
and constructs these things called log
entries as models when it would have
been much simpler we know in hindsight
to simply construct commands in the
first place and save those as models and
then you have useful things you can do
like display this timeline to users
reflecting changes that have been made
to an incident again the original
command pattern is very simple it's just
instead of editing the buffer directly
create an edit object that you can
invoke elsewhere or later but it's what
makes this interesting the fertility of
the pattern is that once you separated
these other things like managing a
synchronous asynchronous 'ti or
inspecting them for your user experience
or treating them as first-class objects
not just internally in the architecture
but through to the user experience like
the timeline they sort of follow
naturally once you say hey each and
every one of these implications is a
first-class entity which sort of
provokes the mind to look for other
opportunities even if you don't have a
requirement right in front of it
another example if you're working on
anything non-trivial and certainly in
academic consumer-facing space you often
have some sort of tracking things going
on that keep track for example if you
build a new feature sometimes you want
to count how many people click on your
new button or try your new feature and
so on you might be doing some AV testing
I've seen code bases that are simply
littered all the way through there's
front-end code and so on with little
tracking things that fire off to
somewhere else and again why would I
look at some user experience code and
need to know that we're tracking that
particular button click or something
that's that's complaining
responsibilities but once you start
thinking in terms of commands it's like
oh yeah well really what we should be
tracking is when the command is invoked
and then the particular piece of code
that handles a button clicking or
whatever simply creates the command and
send it somewhere else to be invoked and
then tracking and so on happens
somewhere else dr. adel goldberg who
wrote one of the big small top bibles
she said something that really applies
to almost all object-oriented
programming which is in small talk
everything happens somewhere else and it
is sort of the annoyance of
object-oriented programming these are
always tracing to somewhere else but
it's also the joy in that you can
arrange the different things in
different places to have different
responsibilities and yes one button
click may in fact be a complicated chain
of things that are handled by a whole
bunch of people of people and I am
anthropomorphizing
not people but a whole bunch of
different entities within the software
and that could be good now I did say
that when something is a first-class
entity we can pass it to a function I
did say that we can return it from the
functional method and we saw an example
of that being able to call a buffer and
then get back and edit objects and one
of the things that we often do with
functional programming is we transform
something we write decorators for
example a function that or we will read
map an array we transform the array into
a different array based on passing in
something this is kind of the
combinatorial approach to programming
and it does have a place
in object-oriented programming and it
especially has an interesting place with
implications or commands let's take a
look
you recall our edit when we call do it
it would actually perform the Edit on
the buffer now we're adding a new method
I know it's hard with the screen if I
show the entire class with our new
method then the text gets very small so
we have to remember that knows how to
perform an edit in the first place and
it has this new method reversed what
does this do well the Edit actually
encapsulated what the old texts look
like and the new texts and so what it
does when you call reversed is it gives
you back a new edit object that reverses
the effect of the first edit object so
this is as if if I had a wrecking ball
and I knew how to wreck a house that I
could ask the wrecking ball and it would
give me an unrest in ball that would
reassemble the house from pieces being
able to reverse an action very unlikely
in the case of a wrecking ball in the
house that is very useful when working
with user experiences unfortunately this
is some sort of arcane magic that seems
to have been lost when we move to the
web from desktop applications I don't
know why there here's an example of
being able to reverse things we have a
doer edit object and then we can get an
under by asking the doer for the
reversal or the reversed version of
itself and when we invoke do it on the
doer
it changes the buffer and when we invoke
do it on the undo er it reverses the
buffers changed I hope everyone is
nodding along and thinking I know
exactly where he's going because of
course this has been a staple of desktop
applications going back to about 1981 or
so a little bit earlier if you look more
in research projects but in terms of the
public consciousness being able to undo
things it has not exactly been
revolutionary in any field of endeavor
except web development so let's recap
what we're able to do with our ability
to reverse commands we have a buffer you
have a replace with method and I've
added something you recall when we
talked about job two's and so on the
ability to have a history
well our buffer now has a history and a
future as it turns out and when you call
replace with it creates a doer it asked
the doer for thee for the undo notice
the buffer itself does not know anything
about how the reversal takes place
that's left up to be up to the command
itself after all maybe the command has
to persist a copy online somewhere the
buffer shouldn't assume that knows
exactly how to undo something we push
the undo Iran to the history and then in
this particular case we invoke the doer
and return it how do we undo we can
create a method and what does it do it
grabs the underwear off the history it
creates a read or because of course if
you reverse the reversal you're back to
where you started we stick the reader on
to the future and then we perform the
engine
how many people here are nodding along
and understanding exactly what we're
doing with the future and the rest of
you are asleep I soon because I know
you're all very intelligent and ahead of
me by at least two slides so here's an
example we take our buffer we do to
replace wits so now if you're following
along in your head we have to undo errs
in our history we can undo twice and get
back to the original state and thanks to
our future we can redo here's our redo
method which looks suspiciously like the
undo method and by hitting redo twice we
move back to the first state there is
zero reason why a web application
written in 2017 does this for everything
except well that's not the way this
other web application I saw it does it
but we have the technology all we need
is the will
so we look at what we've talked about so
far
taking a method invocation taking the
implementation out of the basic data
objects or model and putting it into a
separate first class object with its own
methods like we'd like do it or reverse
if we look at the ability to manage
those elsewhere now that we've separated
them we got an example job queues we've
got another example using histories and
futures to implement undo and redo we've
really seen the basic command pattern we
see that there's lots of different
things you can do whether it's managing
a synchronicity or providing a user
experience that displays a timeline or
introspecting asynchronous things so you
know what the state of an application is
or managing the concurrency of them or
undo we do all of these things kind of
flow naturally once you say huh
invocation should be first class the
entities in themselves and these are
just a few examples each and every one
of you is working in a domain where
you're going to say oh here's the thing
we could do if we were using the command
pattern you saw that we stored our
commands our indications we queried them
and we even transformed them that was
the magic of being able to ask a command
how to reverse itself and that's very
interesting and it raises a question
with our buffer application when we push
something onto the future we will be
sorry when you push something onto
history we threw the future away does
everyone see that I don't know what it
is one two three four five six seven
eight nine something like that why did
we do that
let's take a look at the ante pattern if
we comment this line of code out and do
exactly what we did before actually sort
it do something slightly different we
make a change to our buffer we undo we
do another command what happens if we
redo now we didn't throw the future way
so it's still sitting there and in fact
you should be able to hit redo I happen
to know the answer we get some somewhat
garbled text the problem with the code
that I've shared with you is that it's
coupled to some ephemeral or implicit
state of the buffer it doesn't actually
store the old state of the buffer and so
on it just kind of assumes that the
buffer must be in whatever condition it
was when you first invoke that by
blowing away the ability to redo things
once you do once once you perform some
new command we avoid this problem and
that's how most applications work but
it's not necessary if you look here this
is what we do
we had quick we replace with fast and it
remembered the position that it was
replacing however if you do that same
transformation in a different place in
the text that is replacing it from four
to eight as we did before
but unfortunately because we changed D
into my it's now no longer replacing the
word quick is replacing part of quick
into space this is how we got the
garbled text because all it remembered
was what place to do is change but if we
look at commands and think about them we
had our buffer we had a past and a
future that was our history should call
that this history we had a history we
had a teacher in the initial state there
are no actions whatsoever then we
perform a command and we have a past
when we undo it moves into the future we
kind of moved back but that command is
still in the future if we want to do
redo redo is like moving forward in time
undo is like moving backwards in time if
we then do something else it's in the
new thing that we're doing replacing the
doll with mine is in our past but the
future is still there untouched because
we didn't throw the future away in this
version of our code but now the future
command is no longer semantically
correct we no longer really sit I mean
in our brain we were replacing the word
quickly fast but so the text buffer is
just replacing the characters between
four and nine with fast and when we hit
redo we get this garbage and we move the
replacement into the past but
unfortunately the text is wrong the
problem is that every single command is
really dependent upon the state of the
buffer when it was invoked which means
it's dependent upon the history of
commands that happen before it how many
people here if I say the word or phrase
event sourcing know what I'm talking
about
naturally anything that is mutable can
really be thought of as an ever longer
increasing set of transformations on an
initial state whether they come through
events or commands and if you change
that order you get a different outcome
if we stick a new command into a history
all the things that follow are now is
really it alters the effect that they're
going to have because it's a different
history if you think in terms of a
mutable object as a history moving back
and forth in the history without
altering it is fine but change in the
history is not fine
so here are the edits that we were
working with our fast edit and our my
edit one of the things we can do recall
we could inspect commands we can ask
whether one command is before or after
another command by this I mean lexically
before after this of course is very
specific to an edit if we know that we
can ask whether a particular command
what it looks like if it's prepended
with another command in other words if I
take this command and say I know what
you are but I want you to imagine what
you would be like if there is some other
command in front of you and I can get
back a new command that has the
equivalent effect
now if we try to stick the fast change
in front of my we actually get back the
exact same command because the fast
change doesn't really change what our my
change should look like because my
happens lexically before the fast change
but if we go the other way around if I
say to the if I look at the fast change
and say what would you look like if I
done this my change before you it's
actually going to give me back a
different command this command produces
the equivalent effect it moves it
because it knows that the net change of
the my command means that it has to
change where it edits in the text
so now whenever we add a new command we
go into the future and we say we need to
take every single thing that's already
in our future and change them tell to
ask them give me back whatever the
equivalent command would be now that you
know there's something else stuck in
front of you if you're thinking in terms
of a mutable data structure as being a
history the net effect of a history
we're essentially saying okay I know
we're sticking something new in the
history so now I need to know I need to
solve for the problem of what additional
things after this would produce the same
effect as the original history so let's
look at how this would work we can
replace the word clickless fast we can
hit undo we can replace the word my with
za and now remember when we replace the
word my with the the entire future has
to be transformed and in fact we get the
correct response we have the ability to
redo commands even if we stuck new ones
in front all these math and changes are
possible because we are using the
command pattern it gives us the type of
flexibility that goes beyond what most
desktop applications do with undo and
redo
so now so far this seems like a clever
coding trick or something but what's
important about this is not a ha now I
know how to implement a redo that can
handle doing additional indication what
what does this provoke
I said commands where for tile design
pattern what thinking this is produce
and this is what it tells me
besides that doctor who is a fun show
and the Tenth Doctor is pretty awesome
but that history and time are things we
can manipulate as first-class entities
we sort of got a hint of that with the
job queue we decide whether things
happen concurrently or sequentially you
can cancel things we can get their state
and we can also rearrange things we have
the ability to alter the flow of time
for entities in our applications
inserting a new command and being able
to redo things doesn't seem like a big a
big deal but once you get a hold of this
is like cooking for the designing line
let us imagine that Alice and Bob are
editing a script how many people here
know who these two people are excellent
Alice B toklas very famous as a
companion to Gertrude Stein and she also
wrote a cookbook which contains I
believe the first written reference to
hash brownies the gentleman is Bob Fosse
the only director to have won the Triple
Crown he won an Emmy Tony and an Oscar
in one year as a director never done
before never done since I need a heck of
a dancer or he was Alice and Bob both
have their own buffers
here's a simple version of the buffer
that we can work with it has a history
Alice replaces dog with my Bob replaces
past our quick The Fast and our buffers
have diverged now if we want to merge
them back back together we have to take
Alice's edit and apply it to Bob's
buffer and we have to take Bob's edit
and apply to Alice's buffer let's do
this remember the prepended width that
we use in order to be able to insert
edit into our time frame for redoing we
can use that exact thing when merging
Alice and Bob's buffers we can even
write a method that append the whole
bunch of things from somebody else and
treats them this is equivalent to we're
going to talk mention get later
it's like rebasing
and when we use our append so that Alice
gets Bob's edit and Bob gets Alice's
edit or edits and only one in this
particular case but there could be more
than one there buffers that had diverse
converged again to have the same content
how many people here use web
applications that do this every day
oh come now Google Docs now there is a
little bug in my code okay a big bug and
the problem is that if we run append all
multiple times we're going to gargle all
the text if every time we want to
converge the buffers we say tell me all
the edits you make and then try to apply
them it's going to blow up there's a
saying that every successful technology
creates problems that only it can solve
object-oriented programming is like this
in spades the promises use some
wonderful things and then you run into
some problems with it then you have to
learn more object-oriented programming
patterns to paper over the problems that
the first set of patterns created and
that's what my talk is showing here so
we're going to get complicated we're
going to use Goods and we're going to
apply them to edit so we can track which
edits we've already merged and then
we're going to be able to get the dips
and understand which bits of the history
we haven't already merged
and it's a lot of work all of this by
the way is online and you can download
it and play with it if you wish but now
when we perform we're going to be going
and looking for those bits of somebody
else's history that we haven't already
applied that aren't already in our
butter so really the actual buffer
itself is just the convenience for
showing things to a user what's really
important all the real manipulation the
real work we do is in our history of
commands our new code simplifies our
replace with dependent append all
and here's a whole bunch of code and
really what we ought to do is test it
now
there's a saying lungs testers I got
this in a Twitter thing and I can't like
forgot to write a reference to it so
please hit me up afterwards because I
don't like to borrow other people
sayings without attribution but someone
tweeted a woman as a matter of fact she
tweeted I don't break your code I break
your illusions about your code so we
were trying to fix a problem between
Alice and Bob when they tried to
synchronize more than once we built all
these goods and so on you have the
illusion that it works so if we're
really going to try and stress test it
we'll introduce Carol so now we have
Alice Bob and Carol and all going to
edit the script so Alice has a buffer
she shares it with Bob she then makes a
change she shares the change buffer with
Carol Bob makes a change Alice
incorporates Bob's change Bob
synchronizes with Alice Alice makes
another change Bob gets Alice's changed
changes and then Carol gets Bob's
changes and if we run our code it stays
synchronized the entire time so perhaps
we've got the right thing going now the
algorithm I've just given you for
synchronizing is known as operational
transform and it looks really really
good when you use buffers as as an
example
but it gets really complicated once you
start doing things like editing trees
like if you want to write an operational
transform algorithm that works with any
arbitrary JSON tree or any database then
you get into all sorts of little
problems and so on and it becomes less
simple we also have a problem that one
of the beauties of the command pattern
especially when working with things that
users do is that we can make semantic
changes I'm doing an edit you know I am
I am acknowledging an incident I am I'm
speaking from my own domain
I am reassigning an incident to a team I
am escalating but as you add more
commands you've got to sit down and
start working out well what happens if
you prepend and append with a resolved
little it sorry and acknowledge with a
resolved well that doesn't make sense
because you can't acknowledge an
incident that's already been resolved in
pager duty so we've got to somehow have
an error state for that with buffer
edits everything seems to work all the
time so you start to get really really
complicated because you're basically
building a matrix of all the different
combinations and it's not that simple so
sometimes people say huh well maybe we
should let go of the semantics and what
they'll do is they'll set up like if
you've got say some big JSON object or
something well just scan it periodically
for changes collect all the changes into
some sort of a different object and then
do is some sort of merge operation with
the dibbs this is called differential
synchronization the original version of
I forget which text editor collaborative
text editor used differential
synchronization electron hat does some
synchronization synchronizing using
differential synchronization it is an
effective algorithm but it's a trade-off
you lose some of the semantics so if you
want to use the same thing for time
lines that you did for synchronizing
documents that's not going to work so
well
here's an example from Google Docs you
could just scan it and find all the
changes now as I said in passing when
you use something like differential
synchronization you gain some
mathematical simplicity it is a little
bit easier you don't you don't have to
necessarily worry so much about
acknowledgments versus resolves and so
on but you do lose those exact same
semantics that are useful to you what
you do gain some flexibility now the
differential synchronization is not the
command pattern but what I said was
interesting about the command pattern is
how its fertile it leads us in new
directions now this idea of
synchronizing documents you know once
you start think about it it's a really
big problem space isn't it how many
people use software that merges changes
to documents okay a number of people are
either too busy to raise their hands or
asleep because of course if you're doing
any kind of version control you are
using software that merges changes to
document now there are only two hard
problems in computer science right caste
and validation and naming things and if
we look at this buffer and rename things
does this not look very familiar to you
I used to work at a company called
something hub completely get out that's
it and we cared about this stuff all the
time
git is a kind of differential
synchronization it doesn't actually know
a bet you renamed a variable doesn't it
just it just scans documents for changes
and distributed version control does
allow you to make some things that look
semantically semantic II I know this
particular thing I don't know if you've
ever used this feature but if you use
github and you look at changes to a
human readable file like a markdown file
or a nasty docx or something
it has a mode where you can see this
kind of edit it looks kind of like what
you might markup if you someone gave you
say their talk and said what do you
think
and they said I'll change this word and
change this word and so on in order to
make this look human readable the code
actually has to have a whole bunch of
heuristics that look at the raw disk and
then try to back infer what kinds of
edits humans might have made so you end
up incorporating a lot of additional
complexity I also confess that pager
Duty had this problem and that we want
to have this nice timeline that is
semantically rich red space way to
acknowledge this and so on but we have
to kind of back-and-forth commands right
off the get-go we save ourselves a lot
of these annoyances and I think this is
an important problem to solve when I
first started in software when I really
first started in software computers were
as big as a room now they fit in our
hand users have a completely different
set of expectations about which things
are live in which things are kind of
batch processing we read a lot of we
write a lot of web applications as if
we're doing batch programming submitting
punch card jobs you know you fill out a
form and you click Submit and so on
however our users are texting each other
in real-time they use things like Google
Docs to to keep track of how many people
are in on this vacation they're going to
take to spring break or whatever it is
that that they do and then we build
applications that don't keep up with the
stuff that they get on their phone for
30 cents and we charge like half a
million dollars to build them most web
applications are kind of out of sync
with the ex-patient expectations people
get from using consumer devices to me
that's an opportunity it's not a
criticism I'm saying wow look at all
this fertile land that we can go and
settle and do cool things with
for example here's some a user
experience for a competitive product no
actually that's paid your duty anyways
one of the things that we do is we
manage schedules for people being on
call now do you suppose that three
people might get together and be able to
each of them on their own computer
collaboratively edit a schedule no do
you think paid to do the audit no better
than this I think so because we use
Google Docs to do all kinds of things
collaboratively and then our own the
software that we build using Google Docs
collaboratively isn't collaborative
needless to say this is something I'm
personally championing but everything in
the world I think ought to be
collaborative most of it already is we
just need to get excited about this why
can't I collaboratively edit this why
can't I make my own schedule and merge
it into another schedule the way I can
merge things why can't I do version
control of schedules why can't support
help me fill out a form online lives to
say oh yeah fill that out no no no about
that click somewhere else what's up with
that it's not hard now it's very easy to
stand on the stage and exhort people to
do these tremendous things that involve
rewriting all of the code from the
ground up or a completely new paradigm
of course actually going out and doing
those things is completely different
matter and the fact I don't advocate it
software is best developed using a kind
of experimental tried little thing get
some feedback make some changes learn
from it you no doubt have seen other
talks or read books or or discuss with
with your colleagues or fervently
following a philosophy where you build
skateboards bicycles motorcycles cars
not try to invent the Tesla from scratch
right off the get-go so anything that
involves is complete boil the ocean
rewrite all of your code in a new
paradigm is a little suspect and that's
why I say the interesting thing that I'm
trying to share with you is not here's
the command pattern go out and do it as
much as here's a pattern thinking about
it is fertile and leads us to new to new
directions
but practically what can we do modestly
how can we get started well the first is
to think about separating concerns for
example we happen to use ember at page
your duty and we said we switched and
started doing everything using a plug-in
called ember concurrency which happens
to have tasks which are a heck of a lot
like command invitations partly tasks
instances which are rolled into a task
which looks a lot like a job - and then
once you start separating that you say
to yourself well notification that the
command has succeeded maybe that
shouldn't be in the user experience
object that actually shows the widget or
the button that should be somewhere else
so we can invoke those commands using
AIDS or using a service objects and so
on you can do little things one by one
and move towards a world in which the
indications are separate from the data
objects you have you have data stores
that know how to save things but you
don't necessarily have to invoke them
directly from the from the user
experience object like a widget or a
button putting something in between
might give you some additional
flexibility you don't have to
necessarily bloat your data store object
up but just once you start thinking
about this you can start moving in these
sort of new directions it just takes
being familiar with these patterns with
knowing how they work so that you can
start to see the opportunities when they
arise to do small things and make small
experiments so as I say the point of
this talk is not go out and rewrite all
of your code the point of the talk is
think about what some of these things
are think about where you'd like your
software to be one day collaborative
real time to have real timelines to have
undo to basically give people the
experience they're already getting on
their little device that and find
opportunities to do little things little
experiments that will get you moving in
that direction thank you
I think we have a little time if anyone
has a question or you can race off and
be first in line for the espresso
machine</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>