<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Go, Microservices and all the joy! - Andrzej Grzesik | Coder Coacher - Coaching Coders</title><meta content="Go, Microservices and all the joy! - Andrzej Grzesik - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Go, Microservices and all the joy! - Andrzej Grzesik</b></h2><h5 class="post__date">2017-04-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SVouWfoHhk0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to my talk
go micro service
be some irony nan some of the slides I
didn't included in the subject but be
warned if you're allergic to irony and
sarcasm be warned
my name is andrew jursic I know it's a
bit complicated so my twitter handle is
much simpler and I know this is the last
session of this very long and very I
enjoyed it so far
greatly but also quite I'm also quite
exhausted conference so if you want to
talk to me I'll be happy to have a
conversation immediately after the talk
or if you have to run to the airport
because you have an airplane to catch
feel free to drop me an email tweet to
me
of course you might go to my blog and
try to contact me through there as well
a couple of things about myself I come
from Poland I used to lead the Polish
Java user group now I do it remotely via
email I also am related to crack of
Hadoop user group software craftsmanship
crack of a conference called geek on and
I also am a Java champion which probably
is something that you haven't never
heard of it's something similar to
Microsoft MVP if I understand the
concept well enough this session is
about going micro services and to give
you some background I've been using go
since 2013 I've been working for a
particular auction site you probably
have heard of it the name is four
letters long and the project that we've
been doing is well we were basically
changing how some static assets are
being served in that infrastructure the
story is if you go to any large website
that has rules and regulations and help
and it serves number of nationalities
and it has a large amount of traffic
well they will have to have a separate
infrastructure for serving static assets
not natural and we started to redesign
the whole approach which used to rely on
a number of Drupal instances we wrote
the whole thing using go not only but
the front and serving part was using go
and we were extremely happy with how it
performed since then I've become a fan
of the language
and I wanted to tell you a bit more
about it what's it good for what it's
bad for because it's not a silver bullet
it's I am not advocating you abandon all
the languages that you already know and
you're using for other things and you're
happy with go is good for certain areas
it's not a perfect thing it's not a
thing I would definitely use everywhere
so go it is a relatively new language
and it was first announced to the world
I think in 2009 if I remember correctly
since then it has gained a lot lot
popularity a that's a screenshot from
Tyagi index screenshot is relatively
recent it was taken yesterday so you can
see go has the lucky 13th position
within the last year it's jumped from
position 54 to position 13 of course
somebody might say at IOB index isn't
really relevant to anything because it's
based on what people search and what's
advertisements there are so not super
useful not a very scientific method but
we don't have a good way or a great way
to go to compare programming languages
popularity that's one of them another
way in which you could see how popular
it becomes is look to look at Stack
Overflow how many questions about gold
are there and the number is increasing
tremendously you can see that it's
already now it almost has taken over
Ruby probably within the couple of
within a couple of months it will take
over Ruby and then there Phi PHP
assembly all within seven eight years
because it's 2017 the beginnings and it
was announced in 2009 so the question is
why should you even look up go why can't
we write all the software in the
languages that we all have been having
since well since we started I think if I
remember correctly John for knowing man
wanted to was perfectly happy with
people writing machine code as you know
very well we are not using machine code
too often we are writing in languages
that that offer us better abstractions
so if you look at the ghost website
some reasons some rationale for the
project is well first computers are
quicker the hardware that I'm running on
my phone is much much faster than the
desktop machine I was having 10 years
ago which is scary I have more RAM on my
phone that my my first computer head of
harddrive that'sthat's that's insane
in terms of progress the thing is
software development which means us
humans usually we are the bottleneck to
languages the paradigms haven't really
changed a lot we still do very same kind
of loops very same kind of orders very
same kind of instructions and hardware
that we run the software on it has
changed tremendously if you take a look
at this slide that's how many this is
how many cores had did every server CPU
released from Intel head since 2006 up
to 2016 I basically just went through
arc dot intercom which is a website that
has all the technical specifications for
the CPUs and then plotted them onto a
graph you can easily see that there is a
Grove there is a huge growth in there in
the core count and you can safely assume
that this growth will continue which
means we will have more and more cores
and programming for a single core as you
very well know is different than
programming for 24 cores if you've been
to yesterday's excellent presentation
about being quick and being running fast
while being friendly to the to the metal
then well you might know why we have to
write code differently for multiple
cores because all the all the story
about caches and memory sensitivity and
read/write and memory bandwidth has been
explained but basically what's also go
projects has managed to capture is the
emergence of multi-core computers has
generated worry and confusion because
one approach is to use locks and mutexes
and do software controlling threads
manually but it's difficult this is this
is hard this is difficult
who who is who can write trouble-free
multi-threaded
here and is absolutely certain they will
run work immediately no hands
yeah I can't I make mistakes and the
worst thing is those mistakes are
sometimes hardware-specific sometimes
they are they only manifest themselves
if you have let's say two CPUs in a box
sometimes the only manifest if a cpu has
a specific number of cores because those
are very strange problems things that we
humans are not really great at at
identifying and that's not natural this
for me to think about another thing is
software projects become bigger and
bigger and bigger you probably know and
work with some very large systems very
complex systems and there is a natural
trend in the world that we will need
more programmers we've all heard about
all the initiatives that want to bring
and invite more people to start coding
and if you want more people to code then
you naturally introduce a bottleneck if
I'm programming with one of you what we
need to communicate if we want to
program in a group of 100 would there
will be more bottlenecks so there is a
law a very famous law that's called and
all flow it's illustrating how much how
much speed-up can you get by using
multiple execution units depending on
how many how much software is
parallelizable versus how much cannot be
cannot be made run in parallel because
it's serial so as you can see the
performance isn't going to grow linearly
it's not going to grow straight and
there isn't a natural barrier if there
is even if there is a 95 percent
parallel portion of our software so if
just 5 percent means we can only get
around 20 20 times speed-up which means
obviously adding more more and more and
more execution units translating to
course probably isn't the way if we keep
having serial elements in our software
and we we've known that for a couple of
years and things such as Capt RM have
been around 1/2 K
a lot of weights they are things that we
all talk about consistency distributed
systems well distributed databases there
they are I think because we cannot do
multiple phase comets over large
clusters of any database servers well
despite what salespeople from Oracle and
my sequel and Microsoft SQL Server would
life would like us to believe it's not
possible and there is a solution to that
this solution one of the solution was
identified by mr. horror a number of
years ago in a paper called
communicating sequential processes the
idea is we shouldn't communicate by
sharing memories so we shouldn't have
one piece of memory that we will share
in protects access to instead we should
share many bright communicating which
translates to share the messages let's
exchange messages between threads
between your execution units don't build
artificial barriers because it's hard
because it doesn't scale it's it's hard
to scale and now more than ever before
it's something that's that's actually
well speaks to us very very strongly so
I did mention go and I do mention
microservices and it will hopefully all
come together towards the end of the
talk but how does go handle approach
that well go has the notion of channels
which are pieces of memory in which you
can well thread safe pieces of memory
into which you can put and from which
you can read type-specific well that I
objects so if I want one go routine
which is an equivalent of a function
running in a thread I can well put it
into a channel if I want somebody else
to read it well they can do it what go
runtime provides is channel will be
thread safe channel we will have all the
necessary memory barriers so you don't
have to risk false sharing you don't
have to read
reads that only read half half of a long
because because something no go runtime
provides all the guarantees but it takes
something in exchange you don't get
control over your threats you don't get
control direct control over your
execution units if you want to control
which go routines work you have to use
channels for that or you can use some
other concurrency constructs and they
are all listed in the documentation but
the idea is you don't write threads if
you've written any PHP have you let's
assume you have read about how PHP
handles web requests a web request comes
in and a specific threat in an
application server will handle
everything and there is no sharing and
that scales perfectly and for further
information I haven't written any PHP
it's just a useful illustration and that
means that nothing has to be sure if
there is something to be sure it will
you just send the data to a database
probably or to something else this means
that there is no way in which somebody
can make a mistake about concurrency
about serialization about anything else
that forgo allowed us at the mention the
auction site to handle all of the
traffic that was accessing those help
and other static content sites by using
just four machines before the number of
machines was way way higher I think the
default default was nine and it was
going up to twenty something twenty or
thirty machines we've go just by chip
rewriting the application by not using
things that that would share states we
ended up with with just four machines
handling and having enough in a
bandwidth just just to handle with all
the spikes moving on another important
idea behind ghost creation is some
fundamental concepts such as garbage
collection and parallel computation are
not supported by systems languages and
they mention systems languages and
systems languages means here C and C++
because in Java in c-sharp we do have
garbage collection we were very happy
with that we have parallel computations
that's that's that
that's easy to do you cannot use actors
you can use a kind in the Java world you
can use a kebab net in the in the CLR
world you can use other actor and other
frameworks whereas in the closer to
metal systems you don't get that there
is no decent well there is there are
garbage collection collector
implementations for four-seater you can
do reference counting you can do smart
and Auto pointers but it's tedious and
it's error-prone and if you've written
software with that you will run into
problems sadly if only because somebody
did something that'sthat's not totally
expected so go did designers of gold
decided that memory our garbage
collection and not having to worry about
how memory is accessed is much easier
because this allows people to write
software in an easier way and remember
that these I look at people as the limit
the limiting factor when it comes to
writing software at time so that
simplifies everything so go is easy and
all go is also super fast if you who has
been writing and working with large
systems written in C or C++ anybody so
let me tell you a story well I used to
work in a system that was taking care of
crew management for an airline or a
couple of airlines actually hey the
whole build was taking a day so 24 hours
when you wanted to deploy well come up
with a new version so you'll write some
code you press compile you go home
you come back now on the next days you
see if it went through if it didn't you
fix the air or try to press compile
again and then go home again and that
was on a large large multi-core multi
CPU machine so the system was large and
took forever to compile because C and
C++ compiler with all the with what's
happening in this compiler purple
pipeline isn't just designed with will
speed up at first go on the other hand
was designed as a language that should
be easy and as a language that should be
fast so it compels almost immediately
that's very important in Google where
gogo comes from because they do have a
lot of
I don't know how much code they have
exactly because I have never worked for
Google but our software the one on the
add dimension to auction site which name
I'm trying to avoid but you can find it
on LinkedIn and is you usually took
below two seconds to compile every
single time and there is a question I
think so how does Google compilation
speed come compare to Java or C sharp or
do I understand you correctly so when
you compare it to to to Java it's faster
when you compared to c-sharp I would say
it's also faster and there is a crazy
idea that go the designers are go
decided that if you want to have any
dependencies you will compile them along
the way
so despite him compiling all the
dependencies that you have it's fast
it's really really really fast of course
I can repeat really an arbitrary number
of times and that won't give you
anything but you can take any project
from from from github and then try to
compile it and I I haven't found
anything that I had to wait for the
compilation to to actually happen of
course yes I work on on powerful
machines I work on well it this is a
magnet problem the desktop I used at
home is it's powerful the workstation I
use at work is very powerful but it's
it's a couple of seconds and that's
that's it well I mentioned dependencies
aigo the designers of god also decided
that the dependency management is a
problem it's a problem because when you
use maven or nougat or whatever other
dependency management tool you want to
use I'm not even looking towards node
and left pads the infamous issue you
have problems because you have to
download the Internet and then every
single time you do it you you don't know
what what you get with go the default
depends that up a dependency manager
that also comes with the tool change
that you install as part of go SDK will
just get the sources of a particular
library which means you will compile
what you will run with and that will be
statically linked which means you will
produce a single binary and then that
binary blob candy can be deployed can be
distributed among well your cloud of
machines you
any number of workers that you want to
run with and that's it no dependencies
no runtimes no specific libraries that
you need you need to install because
everything is contained in the target
program binary that you wanted to create
which if you work with large
environments it simplifies a lot if you
work with small environment so
simplifies a lot and teaches you that
you only have one thing that you have to
worry about and we'll come back to that
later so release cadence I mentioned go
was announced in 2009 it's a new version
comes out usually every half a year and
then somebody could be afraid like what
what about compatibility what what
changes between separate language
versions because if you look at Java or
C sharp or other languages but there are
major changes sometimes goals go mostly
changes tools it has optimizations in
improve it improves runtime it doesn't
add a lot of language features so it's
you you usually get to see no language
features being added between version 2
version which means what you get now is
will be 99% of what you will have in a
couple of years most probably which
means you can then go now and you're
good to go no pun intended
of course the libraries will be changing
the libraries will be evolving no new
things will keep being added to the
ecosystem but the language itself the
core platform is relatively stable the
improvements are all around and the
improvements are under the hood in the
runtime in how GC handles and behaves in
how much latency the GC is dealing with
and causing and I mentioned GC if you've
worked with other managed art forms GC
can be a problem latency if you want to
control it in Java that's that's almost
like it like a dark art how do you
configure how do you tweak your garbage
collector so that's your latency
deposits in used by garbage collector
are less than 100 of milliseconds it
might be some tuning you might also get
some very smart consultants to do it for
you
they
the job but it requires a lot of
knowledge in go the exact amount of GC
tuning that you can do is limited to the
amounts of memory that you can dedicate
to the process and that's it that's the
decisions have been taken and made for
you a focus is on latency and there are
no tuning handles which means you're
happier everybody's happier because if
focuses on latency which means services
will have to respond faster because
they're all applications shouldn't work
too often or if they block they
shouldn't go they shouldn't stop the
world for for too long you don't have to
do basically to a PhD just on the top on
the subject of GC tuning moving on I
mentioned it's opinionated because
things such as formatting that's already
decided for you there is a one official
go formatting it's using tabs it's
putting curly braces in very specific
places in a line there is also a
formatting tool as part of the default
tool chain so you don't get to decide
you don't have to waste your time
discussing that I mentioned dependencies
the approach with dependencies if you
have a dependency just take it compile
it with with with your application and
then this is the whole thing this is all
statically linked together so it's easy
for deployment if you want to reason
about what went wrong in the application
you get the sources you don't have to
look at what are the sources of this
library that I downloaded from endo
internet in a compiled version only to
learn that somebody maybe I don't know
accessed an artifact repository and
removed all the sources are actually the
version that is deployed doesn't really
reflect what's what's in the source tree
those situations have happened they have
happened to many of us a number of times
and they are very unpleasant situations
to the back go doesn't have it because
you'll get an ease of deployment and
ease of reasoning of what's actually
running because there is only one binary
and micro services this talk is about go
the language and micro services and the
question is why do we even look at micro
services what's what's wrong and why why
would what was the idea is it just
because I wanted to put two popular
terms in the subject of the stock of
course
not a software in general is hard it's
it's it's not trivial somebody could say
why why is software hard or which aspect
of software being hard I want to tackle
in this very talk I'll focus on the
human aspect I tend to say software is a
people problem so no matter how what is
the number of ten or hundred times
programmers you have in your team if you
have a large project to deliver you need
many programmers which means well we are
limited by the very same law that we
we've seen which limits how our software
runs and what limits the performance of
our software it's Islam tells law again
if I if we all have to talk you know in
order to be able to deploy something and
deliver something that means we will be
limited in performance if we all want to
release one large chunk of work testing
that large chunk of work is a
serialization step which means it will
be slow if you look at different pieces
of functionality why should my
configuration system be dependent on
somebody's catalog system why should my
catalog system will be dependent on the
search I just want to release something
that will manages so I don't know the HR
accounts HR accounts are independent of
orders that some kind of e-commerce
website does if we are building a
monolith then we all have to be ready
with with our pieces of code in order to
be able to compile then to test then to
deploy if we split that naturally well
we get a speed-up because we start being
able to deploy somebody well subbu said
that independent deployability is the
primary driver for micro services every
other driver is secondary that is a very
strong opinion too one towards one one
direction and I can agree and disagree
at the same time but what I would add is
independent the playability as a goal
yes but what what is enabled by being
able to independently deploy is I can
work independently of another
elsewhere which means we can go our
separate ways we can add features our
separate ways in ads the speed that we
want to both work and that also means
large number of people can introduce
large number of changes to the same
project the same system to be precise
because they are a large system can
become a number of smaller projects
which means we don't have to wait for
somebody else to deploy they're part of
changes so that we all can deploy and
release and use the new new awesome
functionality that we wanted to deliver
and software is only useful when it's
when it's working when it's running I am
a huge anti-fan I despise writing
software that doesn't get used it I
think it's a waste of time unless you're
relearning something like and just
experimenting and many people do with
the same do the same there is a number
of companies that artificially limit
their release cycles to let's say twice
a year once a quarter and sometimes well
something like that of course right now
we all talk about continuous delivery we
start to deliver software and more and
more often well Windows 10 is a great
example what they change they have
introduced they started to release new
builds of the system with especially the
early access much more often but a large
number of so a large number of software
projects are still delivered rarely if
you have a large system you will have a
number of dependencies the ability to
change one dependency and to move
forward with one dependency
independently off of the other is
extremely extremely powerful and big
systems are hard and big the bigger the
system is it's it scales with the number
well with the size I could say
quadratically but that doesn't give it
it doesn't give it justice
big systems like like Google and there
is no single person on earth that
understands the whole of Google there
was no person on earth that understands
a single the whole ebay how everything
of eBay's systems works there is nobody
that understands the whole of Facebook
because it's just impossible but that
also means that if we cut a micro
service if we cut a piece of software
that that just does one thing and one
thing only in one thing well we
are able to comprehend we humans can
deal with a web software that takes
order talk so did the shipment service
to talk to the warehouse service and
then this that's whatever is needed one
may be prints labels may be also may
reserve some instances of our certain
product so that the core so that the
delivery guy can throw it over the fence
of your neighbor so that then you get to
talk to the neighbor but that's beyond
software problem and understanding and
being able to change the system is and
being aware of the system leads us to
something I call software discovery
problem I don't think it's it's an
official term but I like to use it
because it's it's something that's to do
with how do I know that there is a piece
of software that that's what I want to
do if I want to add two numbers I will
not think whether there is a library for
that that's trivial enough I will I will
just do it if there is a problem of
padding things from the left then if I'm
the Java in the JavaScript world I will
in no way be able to write it I will of
course have to use a library and then if
that library something happens to it
well we are all doomed in a large
organization like my favorite auction
site that I keep mentioning hey how can
I say how can I tell if there is a there
is something that verifies clients
address clients phone number client
something well the answer is well I
don't want to know about it I don't
probably want to write a something
that's probably somebody has written
before given that they have exposed it
as a service and services exploit as
naturally in a towards api's api's which
are hard because api's mean governance
and api is mean and governance means you
need people that will look after the
api's and you need people that will look
after the overall shape and what's
what's possible what's what's available
what's what's there and there was a very
smart person called the surname is
Conway I think he was his name was
Michael huh Melvin yeah so so my bad
at least you have agree on the surname
that's how that's half a success a
organizations design systems which are
similar to how the organ organization is
work which means api's will reflect how
organizations are designed which means
if your organization has an artificial
boundary or a natural boundary let's say
a few development office in London and a
huge development office in San Jose then
the software will reflect that it can be
a good and it could be a and it can be a
bad thing at the same time because the
api's will be very friendly towards
everything that's internal which means
everything everybody who works with me
in the same office there will be great a
fee is for let's say doing contacts and
payments and shipping and then poor guys
on the other side of the pond will have
to deal with something that we actually
never thought of because they don't even
exist in the time zone that we are
mostly in and that's unfortunately
visible the great thing is with API is
that are exposed as rest or sorry as
Jason are or something like that you can
actually write it down and produce a
webpage produce a catalog produce a
service that will say well those are our
corporate api's this is what you can do
with our systems if provided you have
the right permissions you you have the
right data to put in this is what you
can get out this is also what you you
can check the catalog you can check the
pricing strategy there was an excellent
talk yesterday called micro service
micro services mega failures if I
remember or mega-disasters if you have
the time I would recommend you watch it
because well it did mention a couple of
things I wanted to mention in here but
it's already been said on attendees see
so there is no pony and I'll be
repeating that but that's a good talk it
mentions some of the problems that are
visible when you have a number of
services in a company and there are so
some things that will be repeated like
network problems like tracing like
logging like the bugging if you have a
service a calling service be calling
service C calling service D you will get
into a number of problems how do you
solve it should you write the software
we'll allow you to do it easily I would
argue that you shouldn't I would say
don't I would say use the framework let
somebody else
fix the non-essential problems for you
this is why I love that that's a
framework can go for building
micro-services it's called go kit I like
it and it has integration into very into
a number of things that are useful or
even essential when building micro
servers I wouldn't advocate that you try
to reinvent the wheel because well you
can solve more important problems in
your business and again we talk about
micro services let's take a moment to
look at this quote so there is a pattern
I noticed anybody who starts working
with micro services soon starts to look
up things like kubernetes DCOs
consistency protocols taxes maybe raft
maybe something else and each CD how do
you share configuration how do you do
something else maybe you should write
our own tools to do our own cloud our
own micro services our own containers
and the scary thing is no there are
solutions available from all the very
major crowd cloud providers there are
open source tools that do it for you
just use them don't waste your time
don't waste your breath because our
business our industry will move on and
yes it will be great fun but that's
that's not the point if you want to look
at what's what's currently available
what would a cut through the landscape
there was a talk today by Michelle
I dare not pronounce the surname about
docker platforms so many docker
platforms so little time because there
is already a number of people who are
doing platforms for running docker and
I'm saying docker because that's that's
the reasonable default for most of
people right now who want to do
containers but you are not restricted to
running docker you don't have to use
docker to run micro services you can do
micro services with something else
running docker is not mandatory it's
just a useful useful thing because it
allows an average an arbitrary thing to
be shipped with the operating system and
just just bond and protocols the quote I
have shown you before mentioned rest and
then mentioned Jason and Jason should we
do everything with Jason well Jason
there is a genius quote about the using
Jason for for everything in the Internet
I think it's well it says something
about the internet right now is running
in debug mode because it's you can just
examine it with with developer tools and
all the micro services all the services
that talk Jason want to each other well
it's not efficient it's not space
efficient it's not fast latency is less
than ideal it's constrained you cannot
do comments in it it doesn't have a
support for any kind of schema should
you use it for everything maybe maybe
not there are other formats so protobuf
yes XML and soft services yes of course
rest is not not very important what is
important when you're talking about
protocols and formats is to specify what
you are exposing what is the contract
that you are providing with your service
what what you are going to respond to
what was the service level and that is
important because protocols and
contracts allow new stacks to be built
and I will say new stacks because new
stacks will take keep taking place some
people prefer to be constrained to their
own corporate frameworks and people
prefer to use something very very very
specific and very arbitrary but software
ants and capabilities in the world eyes
are moving tremendously quickly I would
say that's dying to a stack thank
yourself to a stack thank yourself to a
probably corporate stack it is a
monolith in disguise why because of
course we can try to say that progress
will be when we split that one huge
monolith into a sea of services and now
we have achieved micro services this is
better than Zen we're done but no
because when you have a corporate
framework when you have an arbitrary
framework that is the only thing that
you can use in your environment when
it's a very heavily opinionated and very
heavily invested in for
work you can't change any part of the
system without actually making the
framework supported if you cut yourself
away if you are restricted only by
following a protocol and then talking
JSON or XML something protobuf to other
services you're fine because you it can
be an old application that can be Java
it can be dotnet it can be go which one
should it be I don't know there is and
that there have been enough flame wars
on stackoverflow went and blogs that we
don't have to have another one in here
the reality is there are tools which do
certain things best in specific
languages one trivial idea one trivial
problem is machine learning
right now machine learning if you're
going to do machine learning you're
probably going to do some are your most
certainly going to use some Titan that's
almost guaranteed which means nobody is
going to fight a holy war that we
shouldn't do machine learning and Titan
because we are a let's say a C++ job or
a c-sharp shop or or a Java shop we will
not touch back then no the tools the
solutions are in Python you will use
Python because that's that's how it
comes which means if there is a
corporate framework that we have to make
support make it support our Python
infrastructure well it will be a lot of
work half a year later maybe till 12
months later maybe something some time
some more time later we will be able to
make some change in the case of
dimensioned auction site they do have a
corporate forum OB that they do have a
number of site of pages that rely very
heavily on the own dimension corporate
framework they have run themselves into
a problem they can't change a number of
pages dramatically they can't introduce
new things as quickly as they would like
to because the framework ties them it's
a very old very heavy very cumbersome
right now I think very non modern and
because people just just left it let it
be
it was left alone and also because it's
cumbersome because when you cut things
into a number of services some people
might go and say well you know what we
could just serve isn't next to this one
next to this one next
and have it all in running the box and
sister in the boxes is a huge
anti-pattern it's a scary scary thing
that is I think people do it a number of
companies have been it through that how
it manifests itself well they they buy a
very beefy server they give it to the
developers developers do their magic do
the rituals do there are water dances
around it they deploy a system and that
box is the only instance of a certain
well-known provider of something that's
a thing that we can discuss outside of
the room when nobody's recording it and
that's that that's what the system is
it's the thing in the box because nobody
designed it nobody tested nobody took
the time to cut it in two separate
places
in two separate things because latency
because if you have different machines
if you have different different virtual
machines different systems you will have
serialization you will have problems of
network latency will have problems of
what runs what's what breaks what's the
probability that my service code that
allows my user to sign up will actually
succeed an excellent example yet made
yesterday microservices mega-disaster
stock was just multiplying 99.9 SLA well
availability of every service if you
have to go for a number of services well
there is a very little chance that
nothing will break on while you're
trying to run a query so watch the
recording when is available avoiding
micro service mega-disasters so a
framework well another quote the late
cost of the coupling is high so yeah
because we didn't we didn't we have a
corporate framework everybody uses that
it's it would take a lot of time to
actually go in and hang disentangle that
stuff mess so taking a framework a part
takes forever so but nobody does it
which means in the end it will limit
business agility it will restrict
organizations ability to change its
direction to make changes to its to its
website with the state to everything
and now we can come back to the question
or well try to marry
why would I advocate that you should do
micro-services and go first idea for
first part is there are good tools for
go it's a mature solution it works and
number it works a number of places it
powers the number of solutions code is
relatively easy I'm not showing too much
code here because I respect you are very
smart people you know how to use Google
you know how to go for language
tutorials you know how to do it there is
no need for me to teach you how to use
go you can do it in your own spare time
the the idea is that go is happy with
its scaling making performance software
it's great at it it's type system is
simple people who used to write software
in C C sharp Java Scala can pick it up
almost immediately in terms of
popularity it's only growing so if only
if the only thing you're looking or
you're going to look at in the number in
a couple of years is job security it's
great the number of developers the
number of projects that go is taking
place that are using go is just think
it's constantly increasing which means
sooner or later you will use go
somewhere so what will be useful to to
to have it available to you and now an
important point is where would I say you
should use go when you're if you're if
you did make a decision to actually try
to learn the language one of the first
tutorials that you will see is doing a
hello world and then probably a telnet
server a web server or something like
that it's amazing at doing services it's
amazing at doing middleware it's amazing
at doing things that talk to the network
it's just great at that I have never
written a UI application with go and I
probably wouldn't wouldn't try I
probably wouldn't try to power a web
framework with go because I prefer
richer type systems for the business
back ends because richer type systems
for me in the back they they they are
they offer a certain richness which
which pays off in time because you can
because of course you can do DDD you can
introduced types and type hierarchies
and go it's just I prefer how it works
in Java and Scala lines and another
areas however if your solution has to do
something with taking in traffic maybe
combining certain a number of queries
and then coming coming up with a
response maybe orchestrating such as
other services may be talking to add to
a number of backends and then combining
the responses go will be perfect for
that its approach to scrabble its
approach to concurrency its approach to
multi-threading the fact that you don't
get to do multi-threading the fact that
we have to communicate via channels
means you will not have to debug the
software because your multi-threading
multi-threaded code has errors because
it's simple to reason and it's
performance and it's fast
and it's also very very very easy to to
reason about and if you need to scale
that just put it on a more powerful
machine the fact that you're not
blocking the fact or not that you're not
using course that you're not using
threads directly means that you don't
have to worry about then you will only
allow go framework to run with a certain
number of execution threads and
everything will else will be taken care
of taken care of and so because you will
probably hopefully look at go and you
will probably will want to read
something about micro services those are
the books I would recommend go
programming language naturally because a
good language tutorial is useful it's a
great book and micro services in go is a
book that still be in under for the
introduction out of what will be on the
market because I think there is another
one being done by parked and I've seen
mentions of a third one being prepared
somewhere this one looks like the best
position that will be on the market I'm
saying will be because it hasn't been
finished and sadly an early access
version isn't available just yet release
it because when you're building micro
services you have to know how to make
micro services and systems reliable and
resilient and make sure that they
actually from end to end work and
enterprise integration patterns
that's a classic that's a classic about
doing message-oriented middleware and
building systems that rely on messages
flying back and forth because when
you're doing micro services you will
have that's effectual that's effectively
what you what you have to deal with a
number of independent runtimes
more or less dependent that sometimes
have their backends exposed to
themselves sometimes not but they will
talk via messages from our API through
Kafka from message buses through
databases and the patterns that have
already been some of them have already
been designed they also solve a number
of problems and there is a already book
about it so I can only recommend that
and with that I will say thanks because
I know some of you have to run to the
airport thank you very much for coming
to the last talk of the day and if you
have any questions just raise your hand
and or shout or approach me Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>