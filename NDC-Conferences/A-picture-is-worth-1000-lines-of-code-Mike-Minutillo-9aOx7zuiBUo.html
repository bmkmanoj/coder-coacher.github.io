<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A picture is worth 1000 lines of code - Mike Minutillo | Coder Coacher - Coaching Coders</title><meta content="A picture is worth 1000 lines of code - Mike Minutillo - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A picture is worth 1000 lines of code - Mike Minutillo</b></h2><h5 class="post__date">2016-11-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9aOx7zuiBUo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right everybody welcome to in DC
Sydney my name is Mike I have the
distinct privilege of trying to follow
Scott Hanselman I promise that I
probably won't be anywhere near as
entertaining as that guy this session is
called a picture's worth a thousand
lines of code it's about visualizing
software systems but stepping back from
your code and actually getting an
overall picture of what your system is
doing and how it works I'm going to
start with a bit of a personal story
from my own history and then we'll look
at a technique for designing and
visualizing software architecture called
c4 is pioneered by a guy called Simon
Brown we'll look at a tool which is used
to automate see for architecture
documentation of visualization and then
we'll look at messaging systems and how
we can leverage the audit trail data
that you can collect from those
messaging systems to visualize those
systems in a bunch of different ways as
well to get a feel for how those are
working so like I said my name's Michael
Anita lo i live in perth western
australia where i work in my home office
for a company called particular software
we make the reliable messaging platform
in service bus which is the
infrastructure behind the NDC sydney
2016 twitter leaderboard are we screwed
up has everybody seen their Twitter
leaderboard all right so if you tweet
using the hashtag NDC sydney throughout
the conference there's actually a
leaderboard thats collecting and
aggregating those tweets and it puts
your name on a board so you can see the
top 10 people top 10 people that are
tweeting the top 10 people that are
being retweeted and so on have a
collective and aggregating that data and
you can see it on all main screens
around the place so before I get started
can we just get a show of hands who's
actually heard of in service bus lots of
people awesome can you keep your hands
up if you're currently using in service
bus very few people so everybody's heard
of it but nobody's using it okay so when
I was first interviewing with particular
I had heard of in service bus but what I
didn't realize was that they make this
suite of other tools to go and support
in service bus systems and when I first
joined the company I heard a run
through the grapevine that I was going
to be working on this one it's called
service control has anybody heard of
service control two guys and one of them
works on it which is awesome this is
going to be great for my talk right
because when I first had when I first
heard about it I didn't know what
service control was and now particular
is an open source company so I did what
I think a lot of the people in this room
would have done I went to github I found
the source code cloned it locally and I
opened it up in visual studio and hit f5
and it ran and it ran as a console
application and put out a bunch of log
messages and then I had absolutely no
idea what to do from there I didn't know
what the system did I didn't know how to
make it do what it did I didn't know
even who would be using it normally so I
stopped it and I jumped into the code
and visual studio and I went looking for
clues the first clue that i found was i
found references to Owen and nancy FX so
maybe service controllers a web site of
some description then I found references
to in service bus that's not a big
surprise this is a tool designed to
support in service bus so now it's a
website that's doing messaging maybe
then I found references to kaliban micro
so now it's a WPF desktop application
website that's also doing some messaging
and then I found references to Raven
db's now it's talking to a database
somewhere I don't even know what's in
that database of where that database is
was completely and utterly confused and
after a few hours of digging through the
source code I still didn't have a really
clear picture of what service control is
and what it does but I have to stop at
that point because i had my first
shedule meeting by onboarding buddy Greg
he's over there hi Greg and I asked Greg
a guy's Greg about service controller
said what is this thing and he showed me
this he talked me through it he said
basically when you have a system running
on in service bus it's going to be
sending these little packets of data
backwards and forwards called messages
and when an endpoint gets a message and
processes it it's going to stick a copy
of that message into a central location
called an audit queue and that's where
service control is going to take over
service control is going to read that
data out of the audit you do a little
bit of processing on it stick it in its
own little internal database and then
make that information available to the
other tools in the stack now what dragon
managed to do with one
picture a few sentences I'd not been
able to do with hours of digging through
the source code looking at the source
code was showing me all the detail of
what service control did but it didn't
help me to take a step back and see what
service control was doing in the broader
context what had been trying to do was
look at the shape of like a state forest
by examining the individual leaves and
was just not possible to do at that
level now after we'd had a bit of a chat
and we've been looking at this image I
had a question and I asked Greg on this
diagram he does this is eric you think
underneath the other key what does that
name you told me sometimes when a
message is being processed it runs into
problems and it can't be can't be
processed successfully and instead of
going to the autocue a copy goes into
the eric you again service control is
going to pick up that information stick
it in its own internal database and then
make that data available to the other
tools in the platform in fact you can
even issue a request to service control
and it will push that message back into
your system so that could be processed
again I thought I understood what Greg
man so drew on the diagram I said like
this he said yeah so now by
communicating over the shared visual
representation of what the system was
doing we were able to reach consensus
and get our mental models in sync
sometimes you really need to be able to
step back and look at your code from a
distance to figure out what it's doing
and unfortunately a lot of the tools
that were used to tools like visual
studio they're not really designed to
help you do that and a lot of the
training and the skills that we have are
not really designed to help us do that
and when i first started looking into
how you could visualize software systems
and came across the work of this guy his
name is Simon Brown he lives in Jersey
which is a small island in the middle of
the English Channel I presumably that's
what New Jersey is named after does
anybody know I don't know so Simon is an
independent software consultant and he's
traveling around the world specializing
in software architecture helping teams
get up to speed and deliver their
software projects and understanding the
power of this visual communication Simon
would frequently stand at a whiteboard
and ask the team members to draw their
software and what he found was to
varying levels a lot of teams were not
equipped to do so they just didn't know
how to do that so some people would draw
very complicated diagrams some people
would draw diagrams at various different
levels of abstraction a lot of it didn't
make sense and it required somebody to
stand there and walk you through the
visual documentation and it didn't
really help you really had to have
worked on the code for some period of
time and have a lot of context and a lot
of history in order to be able to
understand what was going on in the
system and so Simon started giving these
people tips before asking them to draw
their act actually give them one or two
just point it these are the sorts of
things that I'd like to see this is the
kind of information that I'd like you to
show me and over time those that set of
tips that started to develop into a bit
of a framework called c4 and you can
learn c4 in about 10-15 minutes in fact
going to go through it now and but it's
only get to the end of it your entire
team is going to be much more effective
at communicating visually about your
software so let's have a look-see for is
primarily two things the first thing is
it's a set of common abstractions
they're going to be used to describe
your software architecture so these are
the building blocks that you're going to
be able to take to describe your
software system and how it's going to
work the second major aspect of c-4 is a
set of views so once you have this model
you can then slice it in a number of
different ways using these visualization
techniques to be able to show the
software at different levels so let me
show you an example jumping straight in
at the very top at some level your
domain is about software systems and
users you have people somewhere in your
domain that are doing some job and
they're interfacing with software
systems to help them to do that job now
here where I talk about software systems
and treating them like a black box so no
matter how complex it is internally
facebook is a software system twitter is
a software system youtube is a software
system whatever project you're working
on it's just a black box at this level
so we've seen something very similar to
this with with service control the
context view is going to show your
software system in context surrounded by
all the other users and software systems
that it interfaces with let's have a
look at the service control one starting
with just dropping a box with the name
of your system in the middle of a
diagram you give it a one or two
sentence description these are going to
help the first person who comes to your
diagram if they have no idea what
service control is that couple of
sentences is really going to help them
to figure out what they're looking at
once we've got your system on the
diagram we need to add some more systems
that are going to interface with your
with your system in the middle so here
because the service controllers
interfacing with just some business
system somewhere it's just modeled as a
as another box business system that's
performing some business function now we
put in a line to show that the business
system is using service control so
that's what the direction of the arrow
is now we want to talk about how that
how that relationship is being managed
so who's actually how that sorry how the
business system is using service control
so just like we want to put a
descriptive label in each one of the
boxes you will put one on the lines as
well so here we can see the business
system is sending some kind of data down
to service control when a previous
diagram had it not a couple of software
systems service inside is querying data
from service control service pulse is
querying data from service control as
well so this is just showing software
systems you don't have any users yet so
let's throw some users into the system
developers using service insight
operations people using service pulse
these guys aren't talking directly to
service control but I still like to
model them at this level anyway because
these are the people who haven't come
screaming when I break something in
service control and there's one other
class of user which is important at this
level and that's this this guy the
system admin sheets going to be creating
starting and stopping instances of
service control now this is it that's
all the detail you're given wants at
this level there's no technology choices
at this level this doesn't say
nservicebus anywhere it doesn't say
Jason or HTTP or ravendb
this is how your non-technical
stakeholders the people in your business
this is how they think of your software
system so this is the kind of view that
you want to be able to present them this
is like a 30,000 foot view as far above
the code and the detail as you can
possibly get this is what your system
looks like once you start to draw this
and show it to non-technical
stakeholders an amazing thing happens
they actually have an opinion as to
whether or not this is correct now that
was a massive surprise to me I don't
know about you guys I spent years
writing hundred page documents without
software architecture and you hand them
over to the CTO and he pulls over it and
picks out all the nitpicky things that
he doesn't like and then signs it and
you take it to the IT people and they
read through and they pick out all the
things they don't like and then they
sign it whenever you give it to a non
technical person they just sign it they
don't read it this is a single diagram
it's going to fit on an a4 piece of
paper maybe in a three piece of paper
once once it gets more complicated but
they non-technical people are going to
be able to look at this read it and
internalize it very quickly and they're
going to have an opinion as to whether
or not it's right and you should listen
to that opinion because those
non-technical people have usually been
around your IT infrastructure for some
time and I have some feel for what all
the pieces are and how it all fits
together frequently if you're a
contractor or a consultant when you're
coming into an environment you have a
lot less knowledge about the environment
that the non-technical people do so
print out a copy of this and carry it
with you and at the end of every meeting
just sit down with with non-technical
people and get them to mark it up get
them to draw on new arrows whenever you
people want to make a change to your
environment where they're adding new
software systems or new users get them
to draw it on the diagram don't do it
for them get them to do it because it
really helps you to get their mental
model out of their brain and onto the
page and it helps you to reach consensus
with them so that's the very very very
high level we're so far above code that
you can't even see technical details
here what's the next level down well
diving back into sea for the next
abstraction down is the rather
unfortunately overloaded term container
which was made very popular by Daka but
you know we might hold that against them
it's c4 was first but doctor is far more
popular at this point now here we talk
about a container in c4 terms are
talking about a logical deployable unit
this is something to host see the code
or data it could be a web application it
could be a window service it can be a
database via mobile app and the
containers view is going to decompose
your software system into the containers
that make it up but it's still going to
show everything else from the context so
all the other users and software systems
that your system interfaces with are
still going to be present around the
edges of that diagram only now instead
of being connected to the black box that
is your system we've opened up your box
into a white box and we can see how
those things are connected to the
internal parts of your system so back
into the service control example we can
see we've got the black box of service
control in the middle so let's blow it
up just something a bit bigger we've
still got all of our context around the
edges but I've taken the users away
because on the slide is actually not
that much room and you in started to add
some technical details so the business
system now is saying has to be built on
top of in-service bus and it's been
figured to use some kind of transport
and here you know msmq RabbitMQ as a
service bus curvy of building the system
notice that we haven't put all the
technical detail on the document so we
haven't said how service insight and
service pulser built because to service
controllers things are irrelevant but
this is actually important to us so in
the previous diagram we showed that the
business system was sending just a
single stream of data through to service
control but where does that data go once
you actually open up the black box then
you have a white box you can start to
see three different input streams coming
through got audits errors and basically
everything else and those things are
going to be using that same transport so
that's why it's an important technical
detail at this level behind those three
channels we've got a single window
service that's going to be reading in
that information when that window
service is wanting to store some
information is going to stick it in a
data store which is going to be in
bedded Raven 2.5 database we had our
software system service inside and
service pulse they're going to be
creating that Windows service using HTTP
and getting back Jason responses and
then we've just got one other class of
user that's that system admin they're
not connected to anything at the moment
so when they want to manage instances of
service control it turns out they're
actually using a completely separate
desktop application written using
Caliburn micro and WPF that's where that
technology choice comes in now if the
previous diagram is specifically for
non-technical stakeholders this is
exactly the diagram you want to carry
around to talk to technical stakeholders
it's exactly the same diagram it's just
got a little bit more information on it
and at this level you want all of your
technical choices all of your technical
details you can put version numbers in
here put protocols in here how are
things communicating and how are they
connected this is the diagram you want
to take to the CTO because the CTO is
going to want to know all those
technical choices when you're talking to
the IT and infrastructure people they're
going to want to know all of the things
that they're going to have to support in
production and what they're going to
look like and when you're adding new
developers to the team this is the
diagram that you show because it helps
to them to orient themselves throughout
your solution in a way that just looking
at a solution full of projects doesn't
easily give you this is actually showing
you the relationships between the
logical parts of your system and how
they connect so carrying on diving even
deeper if we've decomposed our software
systems into containers the next step is
to get a little bit closer and to take
one of our containers and decompose it
into something else the next abstraction
in c4 unfortunately another overloaded
term in software engineering is the
component now component is a funny one a
component is a logical grouping of code
or data that's got some interface to it
just performing some architectural a
significant function so if you've got a
subsystem that sending emails no matter
how many classes and things are involved
that's a component if you've got
something that's doing some calculation
and other pieces of the system rely on
no matter how many classes are involved
internally in that thing that's a
component so when you're showing the
components for you you're actually
taking one of your containers and
opening it up and turning it into a
white box again but you're still going
to have all the context from all the
previous views you want all of the other
containers in your system and how they
connected to these internals of this
container you want to know all of the
software systems and users that are in
the broader context and how they
connected to this container which
components are they connected to
internally when I first tried to do this
for service control I did it using some
simple rules I basically said anything
that's serving up an HTTP request that's
a component so any other Nancy modules
that's a component anything talking to
the database that's probably a component
anything handling a message from an
inservice bar standpoint that's probably
a component and I started to put all
this together into a diagram and I got
to this and that's about when I stopped
because even though this is showing a
bunch of components and the
relationships between them and how those
things are connected to those external
software systems and users and
containers we're starting to get too
much detail in a single diagram so now
the diagram is actually losing its value
because there's so much detail here that
you just can't see the individual pieces
we're looking at leaves again when we
really want to see the shape of trees so
what do you do we need to find some way
to divide this diagram up need to find
some mechanism by which you can pick out
individual components that are important
and show them all on the same diagram so
one way you can do this is to look at
individual use cases so here is a use
case for service control this is showing
just those components which are related
to audit ingestion so pulling messages
out of that audit q doing some
processing on them storing the data in
the database down the bottom here this
is our external embedded ravendb
database pulling that data back out
using an HTTP API and then we've got our
external software system down the bottom
there that's calling into that
into those things now imagine that
you're a new developer on service
control today is your first day and you
have a meeting with the team leader and
the team lead takes you into of Rome and
in front of a white board she draws the
context view and talks you through it
and tells you where service control fits
into the broader architecture of the
entire enterprise where the pieces fit
and what they do and then she scrubs out
the service control box in the bigger
net draws it again in a bigger in a
bigger manner and she starts drawing the
individual containers internally and
connecting them and showing you all the
technology choices and all of the way of
those things communicate and if she
pulls out this as a piece of paper and
says and this is the audit ingestion
system and for the next two weeks I want
you to be working with somebody in the
audit and gestern system how long did
that conversation take we've just been
through it in about 16 minutes and
already I think most of you would feel
fairly comfortable looking at the
service control code jumping around it
looking now at the detail level that's
the power of doing this sort of
visualization and and viewing your
software from standing right back you
can start from no knowledge and very
rapidly get down to something very
specific so what's the next step well
imagine you've jumped out of a plane
over over your software down the bottom
is the colored in visual studio the
first thing you see when you jump out of
the plane is this context view there's a
black box which is your system and then
a bunch of other black boxes that it's
connected to and then you as you fall as
you start to get closer now you can see
the containers view now you can see the
white box you can actually see the
details that are inside your software
system how those things are connected
and how they relate and how those things
are connected to the other pieces of the
of the enterprise you fall a little bit
further and now you can see the
individual components inside one of your
containers but it's a giant complex mess
there's all these pieces flowing around
and you can't make out any detail but
you fall a little bit further and now
you're closer and then you can see just
these
cooler area it seems to have some some
shape and some understanding and you
figure out what's going on if you fall a
little bit further you're probably going
to smack into the ground but just before
you do you see the next level which is
classes anybody that's used to
programming an object-oriented language
is already fairly aware of classes right
we know we deal with classes all the
time at this level the class view is
just a UML class diagram because this is
the level just above the code and and
you see your components in your clout
your components that can be decomposed
into the classes that make it up and at
this level you're talking about
inheritance hierarchies and
collaborators and that sort of thing and
I'm actually not going to show you a
sample of a class view from service
control because it's not that important
this level is entirely optional and you
would only ever construct a class view
if you had something that was very
complicated that you wanted to show to
somebody so if you had a complicated
inheritance hierarchy or composition
structure at the class level then you
would include a clasp you so context
containers components and classes for
different views at different levels
slicing through your architecture those
four views will start letter C hence the
name c4 now when one's looking at the
service control diagram that first one
something interesting occurred to me I
couldn't have drawn that diagram by
looking at the code the in service bus
pieces and the the other applications in
our product stack that appear on that
diagram are not directly referenced in
the code no amount of looking through
that code would have allowed me to
generate the diagram which means you
have to draw that kind of diagram by
hand you've got to do it manually don't
really have a choice but that's okay
because how often does the context of
you change or to ask the question
another way how often do you introduce
new architectural e significant
groupings of users or new software
systems that you have to interface with
into into your projects
very rarely right and how long is it
going to take you to update a diagram
when it does change 15 minutes half an
hour an hour if you're feeling really
lazy and you just want to fill in your
timesheet you're talking to adding a box
and a line to a diagram unless you've
got a lot of boxes and a lot of lines
you're not going to have a complicated
layout because you've probably got your
system in the middle and everything else
is just to star around the answer give
me a bit update it really quickly now
how much time is it going to take to
make reality match that new diagram
weeks months I've been on at least one
project where it was years so it's
actually ok to do this by hand it's
going to change very rarely when it does
change it you can change it very quickly
the percentage amount of effort and time
required to keep the diagram up to date
in comparison to the amount of work
required to meet your system match that
is very small so do it by hand write on
the whiteboard do it on a piece of paper
do it frequently because the more you do
it the more you're going to burn that
information into your brain and get your
team to be able to do it so that
everyone on your team should be able to
reproduce one of these diagrams what
about the next level down the containers
of you well here we can start to
interrogate the code to try and pull out
some of the some of the structural
information if you've got a project
inside Visual Studio you're looking at
you know projects inside of a solution
and you can see the technology stacks
that those things are based off of you
can see which ones are desktop
applications and which ones are web
applications so maybe you can start to
pull out some of that detail and do some
of those things automatically but you're
still not going to be able to show how
those things are connected to external
systems or you're not gonna be able to
show very easily how those things are
connected to each other either the
technology choice is required for the
commuter intercommunication there's
probably something you have to add in
manually skipping the components for a
minute how frequently do you think at
class few changes what has it a guess
that every single check-in has a chance
that it's going to break one of these
class views even at the higher level of
the components view if you generate one
and look
it depending on the speed of your team
and your continuous integration software
there's a chance that's wrong with in
about 15 minutes don't do these by hand
so where you've got a context view and a
containers view you're only going to
have one you're going to be able to
print one side on a piece of a3 paper
and flip it over and print the other one
on the other side you can carry that
around as a single sheet and you've
already got a significant way towards
documenting your software architecture
the components view you can end up with
at least one per container and we
already saw that in any sufficiently
complex container that's probably not
good enough so you can end up with a lot
more of them don't do them by hand
because they're going to very quickly
and easily go out of date and then it's
just a waste of time you may as well
just don't bother so if we're talking
about doing things manually versus
automatically what do I mean well after
talking about c4 for a number of
different years Simon I created a
startup called structure Rosa the
structure Iser is two main things
firstly it's this website structure has
calm and if you go there you can sign up
for an account and you can start to
create models in c4 and then you can
create views you can create a context
view and a containers view and different
component views it doesn't currently go
down to class views but that's usually
good enough but the other thing that it
is is its client library and it's
implemented in Java and in c-sharp both
versions are up on github and the
c-sharp version is actually available
via you get and you can install this
package and then you can construct a
workspace define all the users and
software systems that make up your broad
context and how those things interact
you can construct a view a context view
and then push it up to the website and
that's all that's literally all the code
you need to run and when you go to the
website you'll see this which is pretty
similar to the context view that i
showed you for service control at the
beginning okay well now that we've got
that we can move in and we can go down
to the next level we can take our
software system and we can start to
decompose it into its containers again
using the same
kind of very simple API we can construct
a container view and then push it up to
the website and when we go you go there
you get containers view now this is
awesome for three reasons firstly when
you check this in with your code you can
include as part of your continuous
integration which means every single
build that you do can produce
architecture diagrams clean and they can
be pushed up to the cloud and then if
you actually build these diagrams in
structure Iser you can embed them into a
documentation so you actually create
links to the URLs and it's just going to
feed up the most up-to-date
documentation every time you call it the
second reason it's really cool is
because it's going into service control
you can use your service control tools
to look at the history of your
architecture of a time you can start to
diff and blame your architecture find
out who did what when and why and the
third reason this is really cool is the
unofficial reason which is that we all
hate vizio and visual studio is much
cooler than that so now we're actually
getting to write code alright what about
if we want to go any further than that
we're going to go down below the
containers remember I said the the
context view and the containers view
about something that you probably didn't
want to do by hand so even if you're
writing code to do it you're still
maintaining those things by hand if you
want to get further than that decompose
one of your containers into its
subsequent components structure as it
will do that to you have a couple of
options first option is that you can do
it by hand as I said this is incredibly
dangerous because it's really easy for
these things to go out of date and you
can spend a lot of time looking at the
wrong diagram and not really
understanding what it is that you're
looking at so what would be really good
is because we're actually looking at
code what if we did some reflection over
the compile assembly and then called
this API so we can pull out the
individual components and then call this
API for each component that we find so
that we can produce the collection
component
that's actually already built into
structure as it in a thing called a
component finder you can configure the
component funder with a number of
different strategies to basically say
what are the rules that I've set up here
so if you implement I event publish it
then you're an event publisher if you
implement if you extend import in rich's
if you're using important richer as your
base class then you're an import in
nature and when you call component fine
to find components it's going to run
through all of the code and it's going
to picking out all of the things that
match and it's going to construct those
component records for you so you don't
have to do it by hand again if you added
this into your source control repository
and now you're doing it on every single
build you have up-to-date architecture
documentation coming out on every single
build that the modeling level you want
all the components you can possibly find
in the system and you want all of the
connections you can possibly get but
when you're doing the views those
visualizations remember don't try and
put everything in the same view it's
going to be very complicated so you're
going to have to be a bit more careful
about how you pick out the individual
views the individual components to show
on edge view so it's all I'm going to
cover in terms of c4 and structure eyes
I've got some resources and things at
the end if you want to have a look but
the last topic that I want to talk about
is visualizing messaging systems when I
talk about messaging systems in in
service bus we have these things these
different processes they're going to be
running on different machines scattered
throughout your architecture and in
service bus terms we call them endpoints
they're actually reasonably close to
something like your container in c4 what
happens is when these endpoints want to
communicate some information they're
going to package up that information
into a just a normal net class called a
message and then going to hand that
message off to some infrastructure to
deliver it somewhere now importantly the
code that's sending the message doesn't
know where the message is going so it
just creates a message and it says send
s so a logical operation saying that
want something to happen and the
infrastructure takes care of ensuring
that something on the other side
we'll handle that message and do
something for you when the message gets
to the other side this endpoint could be
down maybe you've taken it down for
maintenance maybe that machine is down
maybe even the communication pathway
between these two things has gone away
okay somebody in the network is unplug
something but the infrastructure will
make sure that this message arrives at
the end point that needs to process it
and when it gets there it's going to
call some code to some custom code and
part of that custom code could be
anything maybe you're talking to a
database may be talking to a file system
maybe you're processing an image you're
creating a PDF or sending an email or
doing a credit card payment whatever it
is but part of what you can do is then
send another message so you can have
this stream of messages happening
throughout the system because the
endpoints aren't really aware of each
other they're all very loosely coupled
there's a special type of message which
doesn't get sent so it doesn't go to a
specific destination it's called an
event an events don't get sent they get
published and rather than rather than
going to a single endpoint a number of
endpoints in your infrastructure they
can all subscribe to messages of that
type so if these two end points down the
bottom are interested in order shipped
events when this endpoint at the top
here publishes that event it's going to
get pushed down to all to both of those
endpoints now again this endpoint the
one doing the publish isn't aware of the
subscribers it doesn't know who they are
and these subscribers they're not aware
of the publisher so they don't know what
that message is coming from so
applications built this way systems
built this way they tend to be very
flexible very fluid because it's really
easy at a time to add new end points
that are publishing new messages and
publishing new events and subscribing to
existing events and then you add still
more endpoints and they're subscribing
to a subset of those events and they're
all publishing their own event
and what you get is a sort of emergent
architecture where over time you have
this soup of events and endpoints and
the infrastructure is making sure that
everything continues to work but if each
of the endpoints is typically only part
of one software system in your
enterprise so we might have one software
system here and one software system here
and the fact that they're communicating
via events means that those endpoints
aren't actually aware of one another so
it can be very difficult to keep track
of how those things are communicating
over time and sometimes the business
will come to you because something has
happened and they just don't know why I
don't know why that thing has happened
in the first place I have no idea now to
be good if you'd be able to answer those
questions right straight off the bat
when the business comes to you with a
question it's awesome if you've already
got the answer so the first trick we're
going to pull is we're going to create a
central location called an audit log and
every time you get a message and process
that message you're going to stick a
copy of it into that central audit log
and that means whatever the business
comes to you and says how did we get
into this state you can point at the
audit log the answer is in there does
anybody ever tried to find a needle in
an actual haystack because if you've
been running one of these systems for a
while your audit log is going to have
tens hundreds thousands millions of
records and finding the ones that are
relevant is going to be really difficult
the trick to finding a needle with that
in it in a haystack get a really big
magnet right so how do i get a magnet on
top of this data we need to turn it from
being just the data store into being a
database something that we can query
something that we can pull information
out of on command but in order to do
that we need some metadata associated
with each message that's going in so
that we can use those to query and
visualize what's happening so
piece of metadata we're going to add is
a thing called conversation ID and this
is just a number that's going to
uniquely identify a trail of messages
through your system it's really simple
when an endpoint wants to send or
publish send a send a message or publish
an event it's going to stick some kind
of unique identifier right and normally
this is a good here I've used an integer
but rest assured that the identifier 17
is unique across all my slides so
normally you'd use acuity because then
it's going to be unique across all of
the endpoints in your system the
infrastructure is going to add this
conversation ID and then it's going to
deliver the message to wherever it needs
to go and when it gets there there might
be new messages that are coming out so
as a result of processing ship order we
might be publishing an event saying
order shipped so the infrastructure is
going to take the conversation ID that
we have for the incoming message and
copy it into the am going message it's
kind of sticky identify that's going to
travel through the system and when the
order shipped event gets handled at the
other end if that results in more
messages those messages will also have
the conversation ID 17 this is really
important because once you have an order
database filled with all these messages
if you find one that looks kind of
interesting or if the business comes to
you with a question and you find one
message that looks like it might be part
of that you can call its conversation ID
and query the database by conversation
ID you can find all of the other
messages that were related to that one
sequence of events so the NDC Sydney
2016 Twitter leaderboard is built on top
of a messaging system it's running on
top of in-service bus we are collecting
all of the messages that it's processing
into a central database in this case
service control and so when I found a
message that look kind of interesting I
find out the conversation ID and I
queried it and I got like a bag of other
messages so we've got seven messages now
this has already helped immensely right
because we had thousands of records and
then we have seven but we can still do a
little bit better by capturing a little
bit more information a little bit
metadata so we need two more to be able
to produce a useful visualization the
first one is message identity pretty
simple every message that goes out of an
endpoint is going to get its own ID when
it gets to the other end if there's new
messages that come out of that they're
also going to get their own ID but now
we want to show that there's a
relationship between these two things so
by creating conversation ID we can pull
both of these messages out but now we've
just got a bag of messages we want to
show a relationship between them so when
this order shipped event is going out
when a copy the message ID from here
into a new metadata field onto the
outgoing message called related to now
because we've done that for every
message in the conversation whenever
we're looking at this bag of messages we
can figure out eat for each one which
message caused it which means we can
show a certain type of visualization
called a message flow and we can show
that ship order led to order shipped
happening back to the Twitter exit the
Twitter leaderboard example these are
the same messages again but now I'm
added now I've added message ID and
related to so now we can use that
information to arrange these into a
message flow we can see the processing
analyze tweet led to tweet analyze being
processed six times why 60 anheuser yes
no it's not retweets so the reason why
they're 6 we can find by adding again a
little bit more metadata to our to our
audit log and then we can update the
diagram with that new piece of metadata
so in this case what we're going to do
is whenever a end point processes a
message it's going to receive a message
it processes it to do something it's
going to take its name and stamp it into
the metadata of the message and then we
can show that metadata on this diagram
ok so the Twitter leaderboard is running
on an application called a hash bus
which is where that name comes from but
here we can see this hat bus application
processed analyze tweet and that led to
this endpoint processing at we'd
analyzed this endpoint processing at
we'd analyzed the assembly and
processing at we'd analyzed and there's
six different endpoints that are
processing that one tweet analyzed event
and each one of them is is a projector
don't need to worry about what a
projector is and talk about that in a
minute so this is cool right we've
already managed to just by querying the
database we can start to get a picture
of what our system looks like under the
covers but where did this Annalise tweak
come from well it doesn't have a related
to so we know it wasn't caused by
another message coming through the
system was caused by something else but
it still had to be sent from somewhere
so just as we added processor metadata
to each one of our messages let's add
sender as well and when we do that we
can update the diagram to show where
this message came from awesome what
other metadata can we add to this let's
add some timing information let's add
when messages were sent and when they
were processed pretty simple but now
we're starting to get into this problem
again where we've got too much detail
happening in this diagram this diagram
isn't the right way of looking at this
detail when you're looking at timing
information what you want to see is a
timeline of how things would develop of
how things happened and it's actually
easy to do we can do that with just the
metadata that we've got here so now that
we have the conversation
we have a list of endpoints that are
involved in that conversation once that
processed and sent messages so we can
pull out that information we can draw
them all those boxes at the top of our
visualization and then we can add in the
concept of time you know throwing some
timelines and here we're saying time is
going to move forward as we move down
the view now because we had the
information about when things were sent
and what things were sent and we know
which message started the conversation
we can add it to the diagram and we can
show this endpoint Center message here
and it was processed during this block
of time and then we know the sequence of
events that followed from that because
we have all that in our conversation we
have we can see which messages went out
as a result of that message then we can
easily draw it on to this diagram now
what wasn't obvious from the previous
visualization but is probably hopefully
obvious now is that this endpoint
process things are a little bit later
than all the rest so if you had an issue
in your production environment related
to timing that you needed to diagnose
and you handle this metadata already in
your audit database you can just walk up
to it and produce this visualization and
the answer jumps off the page you can
see it not only that but it's starting
to show these static relationships
between these endpoints remember I said
the end points aren't actually aware of
each other so this hash bar Twitter
monitor when it sends and analyzed tweet
it doesn't know where it's going but the
infrastructure is going to deliver it
and it's going to deliver it to this
hash based application and then hash
based application is going to publish an
event but it doesn't know where that
event goes but here we can actually
start to see where that event goes we
can see the static relationships that
happen between the endpoints so you can
pivot the diagram again we can show the
endpoints and we can show the messages
that flow between them but there's
actually a problem with doing it this
way does anybody know what it is problem
is that we're not showing everything
the problem is just like every project
and every endpoint only has a part of
the picture each conversation only has a
part of the picture as well so if you're
looking at this conversation
conversation one you're not even going
to see and point B because it didn't
send any messages and it didn't process
any messages and if you pick another
random conversation conversation to now
we CN point v load up but we can't see
end points a and C and it's hard to know
by looking at individual conversations
whether or not you're seeing the whole
picture the whole enterprise how
everything is connected we can do a
little bit better than this so imagine
this is just a subsection of your audit
audit trail we've got which message was
being sent what conversation it was a
part of what message it was related to
where it came from who sent it who got
it and what it was and what type of
message it was let's throw away the
first three columns we don't need those
whatsoever for this next type of
visualization we're going to just use
who sent a message who received a
message and what type of message it was
if we look at the first row we can start
to draw a part of our diagram so we know
about end point a and end point c and we
know about ship border between them if
we look at the next row we can add any
new information we find to the diagram
as we go so now we already knew about in
Point C but now we know about end point
D and the order shipped event if we keep
going once we've been through the entire
audit trail we can actually build up a
reasonable picture of all of the
endpoints that make up our system and
all the messages that flow between them
now if we do this back on the Twitter
leaderboard example something stabling
happens a brand-new endpoint appears one
that's really used one way we'd have to
be really lucky to hit one conversation
in a million to find that one
conversation that involves the ketchup
endpoint so it was something that we
wouldn't have drawn by looking at
individual conversations we needed to
find the right conversation
and this type of view is using all of
the conversations in your database to
build up something now this is a step
above what we were doing with c4 with
static analysis because this isn't how
we think the system is going to behave
this isn't how we've designed a system
to behave this isn't how we hope the
system behaviors this is evidence of how
the system has behaved this is a
snapshot of the behavior that has
actually already taken place this is not
designing your system this is
visualizing your system you're actually
seeing what your system is doing under
the covers which means every time you
want to look at this view you should
generate it again from scratch because
you may have new data you may have new
information that's been added but it can
take a while to generate right because
you've got hundreds of thousands of
millions of rows of data so that's
problematic we can do one step better
than that because the process we just
looked at is a MapReduce function by
looking at all your order data we're
going to map each entry into an edge
between two endpoints and then we can
reduce that set of maps documents down
into a distinct set of edges between
between nodes and we can draw a diagram
now if you are putting stuff in an order
database in that order database is
capable of running a MapReduce function
you can keep this up to date in near
real time so you can have a consistent
and always up-to-date view of all of the
endpoints in your system no matter which
software system they belong to and how
those things are communicating I'll be
back here me something
yep mapreduce cool so one last thing I
want to cover about this type of
visualization which is that it doesn't
show you everything it's only showing
the pieces that are doing messaging so
it's only showing you end points that
are sending messages and processing
messages and it's only showing linkages
between endpoints where they're
happening via messaging but there are
other things happening in the system as
well there are external software systems
that were interfacing with and this is
where the knowledge of c-4 and the usage
of c-4 helps because we can start to
just add those things manually into the
diagram so here I can tell you the top
two end points that make up the Twitter
leaderboard about talk to Twitter it's
not really a big surprise with your
tweets from somewhere right if you tweet
hash NDC Sydney we have to know about it
so this is how we know about those two
end points of the top there they talk to
Twitter and then they both send analyze
tweet messages and they go down to this
hash bus application thing which is
going to do some processing and figure
out you know whether or not this message
is interesting it's going to publish a
tweet analyzed event which is going to
go off to six different projectors down
the bottom here but that's not the end
of the story it's just the end of the
messaging part of the story because each
one of those projectors talks to a
web-scale Mongo to the instance on top
of that manga tip instance there is a
web api and then connecting to that web
api we have a number of different viewer
applications which the little console
windows that you see around the place
that show the top ten people in each
projector so you really need to take
this messaging view and augment it you
need to add in some things manually so
some final resources if you're
interested in c4 structure aiza and the
works of Simon Brown I highly recommend
that you follow Simon Brown on twitter
check out Simon's blog coding
architecture calm where he talks a lot
about how to do this sort of stuff and
he talks about architectural e evident
coding styles so hey you can write code
in such a way that you can find those
components and things check out
structure a SOCOM
you can find instructions on structures
or calm for how to sign up how to create
your first model you can also find out
how to get get a handle get your hands
on the the client libraries to get
started with those if you're interested
in in me and visualizing messaging
systems and what we're doing in
particular you can follow me I'm wolf
buy it with a way if you buy me a beer
I'll explain where that comes from you
can email me directly so Mike mini
tiller particular doesn't it we had a
couple of blog posts about this topic on
the particular blog and I'm going to
tweet out a few links about the
individual blog posts that I think are
relevant so if you're interested go and
check out twitter.com / will fight and
you'll find that if you happen to be
building on top of in-service bus today
or interested in building on in service
bus in the future and you are interested
in these types of visualizations we
actually have to linger does it for you
already that's a tool called service
inside and these screenshots down the
bottom are from service inside so we can
actually already collect all of your
messaging the in service parts
infrastructure already adds all that
metadata and things into it and service
inside already produces those
visualizations for you so my name is
Mike minute illa I mean about nine
minutes early but that's all I've got
for you thank you very much so we
probably got five minutes does anybody
have any questions yep
yep
absolutely sir yes so really what you
need is you need some way of correlating
that information so you need to know
who's who was on one end of the
communication channel who was on the
other end and what the nature of that
communication channel was in between
yeah absolutely but it's much easier to
do with messaging systems because you
already just putting those messages in
an order database so it's really just
side loading more information into a
process you're already following
anything else no I haven't it'd be
really interesting to do actually
because yeah we collect all the data and
the API is open so it be possible to
push all that into something like power
bi don't be cool
absolutely so the the example of the
code that actually showed there that was
actually not using the built-in
component finder strategies so when you
set up the component funny you can
specify the kinds of strategy you want
to use for finding components but you
can write your own strategy so you can
put in whatever you want so if you'd
rather use attributes you can do that
there's also an example on the github
that's not part of the main package
that's using Rosalind to pull it out of
XML comments who else awesome thank you
very much I'm going to be at the
particular booth which is upstairs for
the rest of the conference so if you do
have any questions any comments or if
you just want to come check out what
we're doing come along to the booth and
we'll chat to there thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>