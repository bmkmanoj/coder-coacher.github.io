<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Serilog: Instrumentation that Works for You - Nicholas Blumhardt | Coder Coacher - Coaching Coders</title><meta content="Serilog: Instrumentation that Works for You - Nicholas Blumhardt - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Serilog: Instrumentation that Works for You - Nicholas Blumhardt</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/f3pposukOSE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is Nick
crowns pretty much in enterprise Dev
I guess if you if you haven't maybe
before though through the you know it's
through that I've ended up involved in a
whole lot of open-source work they
probably come across a lot of FAQ in
your travels which was one of my early
projects a couple more things like that
along the way this talks about Sarah log
which is an open source library that I'm
working on at the moment in case you're
in the wrong room you can okay and then
it's right down the front you see I've
got a little mini LCD screen here on the
back of the monitor so you can get a
good view actually no but before I
forget if you want any of the very last
run of the original sorry log stickers
I've got a couple
I keep forgetting to pass them out so
there's those ones so we've got an hour
I probably won't need every minute of
that so it's playing time for questions
at the end and I'll make sure I spend
some time out by the coffee cart if you
want to want to have a chat so we just
um we just jump right into it so
everyone I assume has done some work
with a plugs over the course of their
development so far yeah how was the
experience was it enlightening is that
us it's satisfying I don't know I I
think the most terrifying moments in my
software development life of have often
been accompanied with stack traces and
and logs so and they give me that little
feeling that feeling about prehension
but there's just something very
satisfying about digging through an app
blog whether it's trying to work out
what's going wrong in a system-wide
performance is poor or just really to
understand better how the how the system
behaves in a range of different
circumstances the the thing that gets me
though and that a reason that I'm being
pulled into really thinking a lot more
about them is that in contrast to just
about everything else we do whether it's
you know the work we do with databases
or or Web API eyes or other other kinds
of eventing like event sourcing
application logs have been left in a
very unscientific kind of territory that
the feeling that you get when you manage
through a log with regular expressions
or with text search is not I mean it's
satisfying almost because you achieve
something
of all the friction that was involved in
the process right is that does that
pretty much sum it up yeah so the I
guess the the beauty of logs is that
because they're unstructured and
freeform it's very quick as a developer
just to go and dump some kind of data
into a log as the you know as the mood
takes you as you're writing code leaving
yourself a little trail of interesting
things that you might want to UM
want to pull back out in the future and
you can do it speculatively because it's
so cheap and that log becomes this kind
of super set of all the other
information in your app like with
interactions with other api's and the
state changes that the app goes through
itself the vexing thing is that that
very those very characteristics that
make application logs so interesting
also our big part of why they're so
frustrating and that really brings us to
to Sarila which is the project that
we're here to talk about it's a solution
to some of those some of those issues by
taking a little bit of a fresh fresh
look at app logs and Donette it's been
around for four years which is which is
crazy it makes me feel much older than I
probably should feel it began as a
pretty small scale open source project
but especially in the last couple of
years it's picked up quite a lot I
originally gave this talk in in Oslo in
June and I have to confess to recycling
a few slides now so we had two two and a
half a million downloads on you get at
that point I don't know what the met
whatever the metric is itself very
scientific and in a couple of months
since went out up to 3.4 million so the
growth of Siri log is is definitely on
that exponential kind of kind of curve
and I think that since you've all spent
a lot of time and dotnet that's maybe
even slightly surprising because we've
got n log and we've had log4net since
way back in the very early days and
they're really mature capable
battle-tested libraries so coming along
with a new logging library there has to
be something particular about it that
makes it um you know that makes people
actually consider leaving those very
comfortable existing tools and trying
something new and Sarah log is one of
those things I think we've got about 80
contribute
across all the different repositories
we're about 15 iron repos on you get I
think and it's it's completely
contributed driven now I think so anyway
what this talk is not the thing about
logging library is that at this
configuration level they're all pretty
much the same like you'd expect that
because Sarah log is fairly new compared
with log4net
or with analog that we might have a few
more modern kinds of sensibilities in
the API like configuration is done via
code primarily rather than being through
the long esoteric XML DSL switch now
look really tired against the JSON sort
of syntax that we were adopting in
things like Donna core it's also being
born into a kind of a more modern net so
it's had good support facing can those
kinds of things built right in there
from the start
other than that though the goal of Sarah
log wasn't anything like building a new
better logger configuration API you can
really understand almost everything
there is to know about configuring Sarah
log from this slide and this is about
the the extent of how much will dig into
this side of Sarah log you can see that
it's configured with the typical kind of
targets like you can log to the console
you can log to a file and you can log at
level so you might log less interesting
messages that the debug level only turn
those on when something's going wrong
and you can log errors at the error
level so these are kind of
bread-and-butter and these are not not
the things that Sarah log was about
changing oh that last point as well as
an interesting one Sarah logo also is a
bit opinionated in that it doesn't
actually have any any static state by
default which is another little twist so
the API of server logs really designs is
just building little generic event
pipelines and you can can you can
construct one logger or you can
construct a hundred we don't force you
into having any kind of one global
logger for your app although that's
often the way that people use it
so what the talk is about and hopefully
to inspire you just got a bit more time
looking into Sarah log is the the couple
of concepts that make Sarah log novel
and more interesting subject to dig into
those two the way that Suri log captures
events across that's really the the
primary kind of reason that Sarah log
was built how can we make logs both
trivially easy to capture as well as
trivia trivially easy to process with
with software and tools offline when
we're actually going to do analysis the
second thing that would do is off of the
back of I guess building more more
structured logs events in Syria log have
a have a lot more of a first-class
nature and the second part of the talk
will look quickly at event enrichment
which is how Sarah log makes you able to
join the dots in a very large base of a
very large volume of logs which is
typical of apps today
part one yeah message templates so a
little bit of a historical view so we're
not really the first to consider this
problem text logging is the the primary
kind of thing that people think of when
they think about logs and that's the
printf debugging that we've all done
since we were running basic on a
Commodore 64 along a long time ago and
to the present day another school of
thought has existed which is that
instead of actually writing out lines of
text for logging logs we should be
riding out structured events that have
properties you can see the left hand
example with text logs show that we're
capturing really a string describing say
a transaction being committed here and
on the right hand side we've got exactly
the same information but with my very
act together sue they're logging API
we've got a first class property
describing what the event is it's commit
and then the amount of time that the
commit took and you can see from the
output on the Left the strengths of
text logging you don't have to really do
any anything special to pass the the log
statement that's in the code that's
about as as simple as it could be to
record an event like that and in the
output you've got all of your human
perceptual system finely tuned for
parsing large amounts of text and you
can read it like a narrative like the
app started up we took an update request
we committed something to the database
and you don't actually even really
acknowledge to yourself that you're
having to parse that to get some
information out of it and when
something's gone and gone wrong in an
app that's really important because the
pressure is on you've got to figure out
what's going wrong you don't really want
to spend your time dealing with the kind
of dump of JSON that we seen right the
cons of text logging of course are that
of those events there's not really
anything particular that ties together
that commits versus the updates except
for the fact that they've got some
common words in each of them so when it
comes to actually going and taking that
list and asking the question well what's
the average commit time even even though
it's easy to read it's very hard to
quickly pull that information out and
also writing regular expressions that
pull out pieces of text convert them
into numbers and then deal with them is
a is a menial process that detracts from
the time you could actually spend
understanding the log better so on the
right the solution to this is that we
recast events as events which makes a
lot of sense that's really the the
natural way to think about logs I think
and it's favor imagining a query that
goes through and filters those those
events by the event being a commit and
then goes and averages out that elapsed
property you know it's a much easier
task to have as a programmer and if you
were doing some diagnostics and you had
a stream like that and you knew what
information you needed you could get it
out very easily with probably without
having to really do any extra pausing or
or anything beyond what you could do
with some JSON and some c-sharp
of course the downside is that this is
when you know what you're looking for if
you don't know what you're looking for
then trying to make sense of a big
of text I probably created a straw man
here by printing Jason to a console
right because you know you can print
Jason pretty printed in a browser but
you still have that at that problem that
you'll you have to look at each line of
an event that's written this way to try
to extract some information from it now
okay of course why don't we just combine
both approaches you know we'll have a
message and we'll have some have some
structured properties as well and
historically people have tried that a
number of times the problem turns out to
be that in both cases you end up having
to actually invest more effort upfront
in order to take both sets of data so if
you're going to write a message and
you're going to write some properties
then then it's going to take more if
there's gonna be more friction at the
development end and you don't
necessarily get all the benefits at the
Diagnostics end because you haven't
necessarily got all of the things that
were interesting in the message also
representing those properties and there
are few different takes on this with
different different approaches none of
them has really taken off and today text
logging is still number one and that's
still what we see in nearly 99% of apps
and I saying was doing structured
logging without a sarah log yeah no oh
sorry clickers getting you better there
you go
so if we really do want to solve this
problem though if we if we go back and
look at the the text log that we've got
using a format string here assuming
you're all familiar with c-sharp and
don't have format strings when we when
we started out we actually did have a
separate a separate representation of
the event that's going on and that
payload it was in our application when
we were when we were writing the log
message and we just jammed those things
together to make the message and we lost
that structural information by pushing
everything down this text but let's say
if there was some magic that we could do
we don't necessarily have to render the
whole thing directly immediately we
could we could conceivably take the
format string and we could keep hold of
that elapsed that elapsed timing
and store those in an event somehow and
then when we get down to the point that
we want to render it to the console we
get the exact same human readability as
we had before but that magic box in the
middle perhaps we could do something to
also keep the structure around so that
if we want to do the mechanical analysis
then we then we have the option of
turning that on and that is is the
essence of Sarah log and hopefully we
will see I window layering is not ideal
there we go
so what we'll see here we've got here
we've got a very short program I believe
that if you can't demo it with a console
app it's too much to take in so we got a
very short program it's a sophisticated
hello world this is Sarah logs Sarah log
being used to write a string of stream
events that include the counter and a
username so a piece of text in a string
so if we run that out
okay there's our CEO you see right away
that sorry log is a bit different and
this is the first kind of place where
the fact that the that the event is
represented with more than just a blob
of text becomes obvious because we're
running out to the console but in homage
to the visual studio 6.0 color scheme
that i think it was there her c++ in
those early days the the numeric values
they've kept that type and they've come
out as magenta and the string values
come out as as a nice same piece of text
and so this is this is giving you a clue
that under the under the hood there's
more happening in several log than meets
the eye but on the surface we've still
got a format string and we're writing
out the same information as we did
before
ah for some reason my mouse cursor has
gone it's gonna be interesting actually
I I think we can update this as well so
I can't resist a bit of eye candy and
instead of Visual Studio 6.0 we might
have this one in Visual Studio code so
you get the idea that in fact the the
log event has become sort of almost like
literate programming right like the the
data and the texts are interleaved but
they're not really the same thing they
haven't been combined together and of
course at the console that's not really
going to make much difference except to
maybe make the task of scanning through
logs a little bit easier if you can
highlight some interesting things about
them but what that does mean is if we do
go and we blast that out as I still have
the problem of new mouse cursor say as
Jason was a compact Jason the formatter
there we go same events out to the
console again you see we've we've got
the same log statements but it's
producing an event the template here
which is hello number 0 comma 1 and then
we have these properties attached 0
which was that first placeholder has the
value 0 1 2 3 4 as we iterate through
the loop and one keeps that string value
and
see we've got a little bit more attached
there we'll have a look in a minute in a
minute so of course we're not also gonna
read a lot of Jason at the console but
when you've collected thousands of log
messages obviously from different
sources naming properties things like
zero and one who's gonna first this get
tiring very fast and I mean writing read
reg X is bad enough I can't remember
whether I've got a you know have a back
reference to the first capture or the
second capture half the time and where
their indexes start from zero one so so
Sarah Clark has a little twist on this
which is to which is to allow you to
name these placeholders rather than keep
them as indexes so it's an extension of
dotnet format strings in very a very
very slight way you'll see that
everything else that happens in them
don't net format string still works with
Sarah log of course they can be
completely backwards compatible so you
can take your log4net code and move
forwards to the new world so here we've
got the number court counter and we've
got a name there and if we get the same
JSON out you'll see that we kept the
same template but instead of instead of
having numeric properties attached we've
got counter zero and name my handle
there let me know by the way if the font
size is no good down the back there it
seems pretty huge from here but my face
right up against it
hey if you're really observant - and I
keep forgetting to mention this but I
think it I think is really cool if you
use resharper who's used to be sharper
yeah you write a format string it
highlights the format string and tells
you if you have say put two indexes and
only one property at the end so you
might be a little bit hesitant to lose
that with Sarah log someone has written
a really cool Rozlyn extension called
Sarah log analyzer and you see in this
case we've got 77 there is underlined
and get a little squiggly and if my
mouse my imaginary mouse cursor can
mouse over that you see error while
binding properties positional property
is not
we're named properties are being used
and so we can change that back to
counter and we get rid of this quickly
hopefully so that is a vs extension that
you can pop in and it will it will help
guide you and make sure that you and you
can you and your team and not is not
kind of just creating random syntax as
you use sera log it produces errors
through the visual studio code analysis
system so I have it turned on as you
know it gets picked up in warnings as
errors in my bill that's a nice little
extension to be s there okay alrighty so
we're probably still not going to get a
realistic and appreciation of what it's
like to use sera log when we're writing
Jason to the console
you could write Jason to a file and then
use some tools to pick it up and and
then ingest those files into something
else later on there are plenty of tools
out there I guess for like document
databases and the like that you could
pipe those into Sarah Locke has a notion
called sinks and each sink in Sarah log
is essentially like a target or in a
Pender in n log or in log4net and a sink
is a destination for logs and most of
the time
Sarah log wants to you to cut out the
middleman you can pipe your log events
from Sarah log directly into a database
directly into MongoDB directly into a
sequel server all those kinds of things
or into elasticsearch or spline cross
seek or things that we'll look at a bit
further on and the nice thing about that
ecosystem is that there's really good
support out there now for for JSON
documents and a lot of different data
sources we'll have a quick look at
Postgres because I think that the the
JSON support Postgres has is really
interesting for this use case so this is
the same program oh damn I showed you
all my my username and password for my
local database lucky I'm not on the
Wi-Fi so we write the same messages out
and if we pop up over to the console you
see we can we can do a select from logs
here in a whole Postgres session run our
app
okay
change a startup project no not debug
yeah okay okay so run that we don't see
anything at the console anymore but now
if we whip over and look at the output
in that logs table that you can see the
a big block of configuration for there
here are those same events in a Postgres
table and Postgres is really cool
because in addition to being a sequel
relational database that really worked
hard to extend it to cover a whole lot
of interesting modern use cases and and
one of the ones that we're seeing here
is that in that properties column let's
do it again okay in that properties :
we've got the first-class properties
that we wrote out of the console and
Postgres actually has a extension to
sequel that can let you zip in and
filter based on values in those
properties so imagining that this is a
big heterogeneous log stream we can say
where properties on so it's greater than
the value 7 and then we just get those
those individual events out so we've got
a message in there that's as good as any
kind of text logging message that we
previously would have used and yet we've
been able to zoom in and just grab those
properties events that we're interested
in without any log passing anywhere in
the pipeline from right back here where
we wrote the log event to the post rest
table so that table is just generic
we've got a JSON column for the
properties so we haven't had to do any
more work at all to cut to go and query
on logs based on structured data and
then we would have really had to do to
just record a dumb text log in a file
Postgres is not the only place that
sarah log will send logs to will have a
really quick look at seek which is what
I spend my days working on these days
I'll just guess where my cut my cursor
is we can write to multiple destinations
at a time seeks good for showing this
stuff especially offline because it's a
I can run out locally I don't fully it
will see same events go out to the
console okay and this is and this is a
web UI together those very same those
very same events so now we're taking the
same lot of events we can write a text
log to the console we could write a text
log to a file or Jason to a file or
Jason to postgres or send that to a log
server like seek and in all those cases
we've got the combination of the text
logs as well as being able to do things
like say counter is greater than 7 in a
first-class way where the value from the
log file keeps its type and we can jump
in and use that property without having
to to tell the system any one widget if
you think about it it's obvious the
problem in the beginning that we're
working to get around here is is that we
were throwing away information so
there's not sorry so there's not
anything that I'm that we're really
doing this magic we're just stopping and
doing what was originally hurting us you
know we're writing a log event we throw
away all the information that we really
need later on when we want to do
diagnostics so we saw how message
templates take us through from
originally just doing plain text
formatting to having that capturing
stage separated out to record a
structured event as well as the the text
that it's rendered into and we can see
how having that intermediate step gives
us the ability to choose whether or not
we're going to render or whether we're
going to serialize into some other
format one thing I didn't show in the
demo is that it wouldn't really be a
first-class structured logging
experience if we were restricted to just
recording simple
and numbers because if you're writing
Jason objects to a log you know with a
with an API design for that then you can
write a raise you can write structures
and you can capture all sorts of other
information from your program that way
Surrey log hacks this in in a sneaky way
by introducing the structure capturing
operator which is the little @ sign in
front of the property name by adding
that one in Surrey log will actually
serialize whatever object appears in
that in that position and include that
as for the structured object in the log
event rather than rather than using two
string like you would without the
operator and this has led to all sorts
of hilarity in the past now before we
really had thought about it a lot we get
bug reports from people who would say
log an object that had a system dot type
in there and you follow the you follow
the serialization through the properties
attached to system dot type and you've
got type two assembly so you start see
realizing that assembly doc declared
types and starts realizing those and
really quickly you find yourself in
gigabytes of data there are there are
definitely limits in there to protect
you today but we still view serializing
stuff into the log as being something
that's a pretty strong opt-in not really
something that you do by default but now
you know house here at sarah log got its
name it's a serializing logger so is
this at all a good idea we thought so
for a while it's nice to see that it has
actually caught on a bit outside of
sarah log as well and if you use sarah
log with dotnet core then you find that
you can use message templates like that
with the microsoft extensions logging
api over the top of that and even MVC
itself in the dotnet core version like
this one is actually using message
templates to generate some of its
internal events so when you when you log
your your requests and things out from a
net core app you'll find that all of the
things like the action name and
controller name that appear in those
messages they're all now actually
first-class structured properties that
you can sort search and filter on
whether you're using stereo or not but
we you know Sarah logs got a good mature
implementation of being able to take
those things and
and send them to all sorts of
destinations while the logging
infrastructure in dotnet core is still
mostly a facade over different
implementations like Sarah log but to
try to make sure that we don't really
drift off in just making I guess
arbitrary changes to the formatting
stereo log and and also to give people a
pointer to other implementations there's
also a site out there you can go and
have a look at where you see a few more
places that message templates are
implemented so in addition to donate
core there's also analog 4.5 has now
created an implementation that's in beta
or alpha I should say I think at this
time there are implementations for Java
and rust and Python and a couple of
others ok all right
okay
so this is so this is a slightly more
realistic log stream it's still much
tighter than the logs that I've been
forced to spend hours eyeballing in
different past lives for sweating
profusely but this is more like the kind
of thing that you'll see when you're
actually using Siri log to collect data
from a real app and this one's just a
I'm just a test data set that's
collecting data from some kind of
admissions portal a typical kind of
hospital admissions system and you see
that we've got the same oh and I've got
a cursor back yes okay you'll see that
we've got the same kind of structured
data here with a lot more properties
attached we're getting all those for the
time being so in this instance we can do
things like we can go and um we can go
and take commit time elapsed she's been
added to the message we can find that or
we can do things like oh there we go now
we can plot it over time etc etc but but
interestingly I mean those are the kind
of those are the kinds of I guess bonus
features that you get from from using
something like Sarah log most of the
time that I turn to application logs
like it's really nice to do analytics
and and everything else but most of the
time I've got a problem to solve and the
things that terrify me are usually the
unknown unknowns they're not the things
that I know about I mean I know I've
been watching my commit time on
transactions as the systems we're
running for months on end and I know
that they're not going anywhere fast and
so when a bug report comes in generally
from the field all you typically end up
with is is the
is the idea that some at some stage in
the afternoon something didn't happen
that should have happened and in the
logs there somewhere is the clue and but
the logs look normal and you can scroll
for you know you can scroll for hours
and they're um they're generally even
from a fairly quiet system here
thousands upon thousands of logs and
there's a very strong limit on how much
data you can actually take in by eye
until you start to the coffee cup start
stacking up on a desk and and you still
haven't found any clues and the system's
still not behaving properly
it's a horrible experience one of the
one of the interesting observations that
we made through building stereo log is
that in even a fairly large system there
are always orders of magnitude more
events than there are kinds of events so
we might have a million events in the
stream since yesterday morning but the
application has only been running a
certain number of scenarios in that time
running a certain number of lines of
code and so once we've actually looked
at an event for say this sequel server
circuit breaker state is open we know
that's got nothing to do with the
problem or unlikely to have anything to
do with it the nice thing that Sarah log
lets us do is that because all of the
events for this message have actually
been generated from the same template
you know the template is going to be
circuit breaker breaker name state is
state and all the events that were
raised by that same line of code whether
they've got garbage in those properties
or not it can all be identified because
you can track them back to the type now
you can track them back to the message
template and in this case we use the
hash of that message template to be able
to zero in on finding the events which
is great if you're doing in the
analytics kind of case because you grab
all of a particular kind of event and
then just go and pluck out the
properties to do analysis on but more
importantly for me
is that once we've decided that we're
not interested in that event anymore we
can just exclude that from from whatever
view we're using to read the log stream
and if we do that for a little while
like the problem is nothing to do with
the claim checks and oh I could tell you
it by the way we will give you an idea
of what's left so we've got 52,000
events to get through but as we zoom our
way in we're not interested in that
claim status so exclude not interested
in that exclude and as we work our way
through looking at different kinds of
events that are not going to be relevant
to our problem we start to design to
zoom in on maybe things that are more
interesting for our particular scenario
and eventually you would hope given a
bit of determination and probably still
a few cups of coffee okay it's nothing
to do with update checks and hey this is
the event you can't afford to miss so
probably probably sifted through 60,000
events by excluding only you know a
dozen event types and for for
Diagnostics this is a super powerful
side effect and most of the time when
you first see Sarah log you hear about
all of the all of the advantages of
being able to query based on properties
and filter based on properties but in
practice the thing that saved in my bay
the most of it has been the ability to
go and actually sift out an interesting
thing it's like triage particular kinds
of exceptions or triage particular kinds
of warnings and make sure that I can
separate out the data that I'm
interested in from the things that are
obviously just noise it's kind of the
dem tal moment isn't that it's like wait
there's still more we've got this so
we're just looking at those in seek of
course but it's not a sea creature
specifically even if you're writing a
log file with Sarah log you can still
plug in and enrich to attach that hashed
message template value straight into
your log file and then be able to go and
search using whatever tools you use for
that plain text processing and still get
the
having event types their first class do
you see here we've got the the the full
event has actually rendered into the
message and then we just sneakily hashed
the template using something like murmur
or Jenkins hash or something like that
and stick that value in there in a way
that we can search it out again later on
okay so just to look at the second part
of I'm sorry log so on the surface we've
got the nice capturing syntax for for
recording structured data and then down
at the end of that pipeline of event
processing we can pop these things into
all sorts of different sinks but in
between we've got events that I captured
from your log statements and then sort
of make their way through a pipeline of
filtering and and other kinds of
processing and by treating events as a
first-class entity and having an API
that's really tuned for them we can do
some interesting things in several log
so just a word on terminology we're
mostly talking about correlation here
which is the the ability to connect the
dots in a very large event stream if
you've done work with WCF and
correlation or the you know the
correlation ID header in in a web
application you're probably thinking of
correlation as being something that's
about a single identifier sarah log
though is geared strongly towards
supporting a more natural style of
correlation where say you've got a
you've got a stream from your
application of millions of events if
you've only got one dimension to starts
start filtering down it's gonna be very
hard to start to home in on a
particularly interesting set and to
really help make that possible not only
do we collect the payload in each event
from the message sarah log allows you to
attach all other different kinds of
contextual information to an event so
that you know we might know for instance
that the problem was
to do with this particular customer and
so we can filter on customer ID and then
switch onto another dimension it was
when we were processing a claim for that
customer so we look at the claim ID and
the customer ID and we can start to to
narrow things down that way
and so you can see there's there's
really like an infinite number of
possible ways to to correlate different
sets of related events in this kind of
system yeah and that was that slide so
once Sara logs started with him started
producing fully structured events that
way it really opened up the opportunity
to go and think hard about I think hard
about how to make those events richer
and and more useful for Diagnostics so
here we've got another I still don't
have any cursor oh but if I scroll I do
here's the trick okay it's now good
another console app similarly trivial to
the one we were looking at five minutes
ago now it's a it's gotta log the
sequence of events it logs a start up
event a done event and then and then
with within each iteration of the loop
its book ending that calculation with
some we're gonna do this we've done it
and then we do it and then another event
that tells you that we've done it when
we run that see Oh actually let's leave
that yeah you would have you would have
seen over when we were looking at the
last data setting in seek that we're
narrowing down to a particular demo
using this selector over on the right
here what we're really what we're really
doing there is that each of those little
programs is using and enrichment with a
property to be able to be able to
separate it from all the other programs
that were running in the same in the
same session so in this case we want to
enrich it with the demo property
and this one is called the enrichment
demo and he is he the most basic and
fundamental way of of narrowing down to
a set of events with Sarah log if we
refresh that again see now all of those
events that came from that from that
application have got demo attached we
can find that and then actually I
believe that we've already set up a
filter for it there we go
so Sarah log lets you pin individual
properties to an event and most of the
time that's going to be something like
the name of the application or if you're
just running my application it might be
the name of the particular service
component or sometimes the environment
they running in you might want to
separate logs that are from dev of a
test or acceptance testing that static
kind of enrichment is is very useful but
fairly limited it's more frequent that
you'll have some kind of of data of a
value that changes as the application
runs typically these start out with
things that you'll be familiar with from
using log phonetic and log like
yesterday enriched with thread ID the in
console app I hope there's nothing crazy
going on here and we actually do get
what I expect in that case it's going to
be
that doesn't look so good does it ah hmm
perhaps the perhaps the little selector
is not the right one call that one there
we go
somebody can point out my typos later on
so in this case the thread IDs always
one but every lock has a little tool box
and a number of different packages that
you can add they go on enriching with
different values like the thread ID the
current HTTP request ID the current
machine name the logged on user name all
of these pieces of ambient data can get
attached to an event was that you really
having to worry about it at the place
that the app that the event is logged
getting uh getting done a bit more
specific and I think the most
interesting piece of the enrichment API
in Sarah log is something called log
context and as I said earlier on one of
the principles that Sarah really tries
hard to adhere to is not to go and make
assumptions about being the only logger
in a process and and not assuming that
any particular static state belongs to
it so to be able to get your ambient
context into stereo log you need to opt
in with enriched from log context and
from then we can go and do we can do
operations with log context like pushing
push property onto the stack in this
case we could call it will call it
iteration sorry that should be and we'll
put I there that should be
property okay
sorry about the clicking the last thing
I wanted to do at 9 a.m. on them on a
Friday morning was prove that I'm not a
keyboard warrior but so in this case in
that using block all of the events that
have been raised will have the same
iteration property attached to them we
sit back and look at those I see here we
got the answer was a 9801
if there's something wrong with that
answer then by using the property we've
attached through the log context we can
gonna find all of the events that were
related that was 99 okay so now I know
what ninety nine squared is great so the
local context is is useful for things
like perhaps it generally appears in
middleware more than it appears in user
code but if you've used something like
mass transit or in-service bus you
typically find that your whole
application is built up with just these
little islands of activity that occur in
response to something like a message
coming down the bus for a particular
order or for a particular customer and
when that process begins you've got the
opportunity to push that message ID onto
the blog context or push an HTTP request
ID onto the context and then if
something goes wrong in the processing
of that message you can go and you can
go and just pull out all of the events
that occurred only within that logical
threat of execution this is part of
where Sarah logs async async'
friendliness also comes into the picture
because hey what is what is the threat
of execution has changed about half a
dozen times over the life of dotnet we
used to use logical call context and a
few other few other things
so now Sarah log actually uses async
local of T for that which is a fairly
new type if you if you're on a framework
that supports it and that way it follows
a thread of execution even if there are
weights embedded in there so you can run
this in async code just like you can in
a synchronous code so the the last kind
of way to approach enrichment is the DIY
and I think the the thing I really like
about sever log is that there isn't
really a lot of magic in the library
itself the the pipeline is really just a
pipeline cobbled together from different
plugins and in this case you can quite
easily at this point if you want to say
put an event type locally into your logs
then you can write a new event type and
richer and a free Sharpe advise me today
and all of these things are implemented
with something called a log event and
enricher which is plugged into the
pipeline you get a log event that comes
through the through the process and then
you can inspect that event in an richer
and see whether or not there's anything
interesting about the event that would
mean you want to add more data in there
so people have used this for things like
pulling values out of the exempt
exception data property to actually tag
on the event as first-class properties
when an error occurs so say if you're
using Postgres you've got a whole lot of
data on attached to each event that
comes back from Postgres that gives you
things like the the internal Postgres
error code that implement that raised
that exception and whatever you're
working with you you'll find there's
similar cases it's also possible to do
things like look at the message template
and generate a hash that you can then go
and include in your output format to
show in a log file and enrichment is is
really an area you're ready for lots of
creativity so at the moment in in Sarah
log itself we've got things like the
api's for doing fixed values for the
ambient state the scoped state you can
also attach properties to an individual
event using an enrichment API called for
context so take a log for context pass a
property value and then that gives you a
customized logger
that will attach that value to every
other event that you raised through it
but where this all fits into the big
picture sarah log has has quite an
interesting pipeline it's it's in a
fixed topology which you probably feel
initially might be limiting of course
you
the neat thing is you can chain multiple
pipelines together but events in this in
a semi-log pipeline go through if they
pass them in a minimum level check now
you can customize the way that values
are captured so just like Jason
Jeannette you can you can say configure
the sÃ»retÃ© serialization for user
objects and exclude the password field
say if someone logs those and so at that
capturing stage you can go and do things
like implement custom policies for say
if you're working on a system that does
a lot of GIS you might want to log GIS
objects instead of position objects
instead of as strings you might want to
automatically convert those into a
particular into a particular structured
format once you've gotten through that
process of capturing the event then
things like the enriches that we've been
looking at plug-in now all the ones that
we were using previously in the demo
like the thread ID enricher and log
contacts contacts and everything they're
just based on a simple API that lets you
inspect the events and attach more data
to it it can be a little bit scary I
think at first though to crack it open
because just like JSON net if you if
you've worked with the dynamic data in
JSON net then you'll have seen things
like J objects and J array and you might
ask kind of like why don't we just have
object an array sera log is a bit
similar it's got an object model for
representing property data the reason
for that is and I think that I bet
there's at least one person here who's
been just me sweating it since the
beginning of course going and grabbing
objects from your programming from your
application sticking them in events and
then passing them through an
asynchronous pipeline is kind of like a
concurrency in home there to realize
this early on and Sarah log uses the
type system that has it has built into
it like you'll see scalar value here for
thread ID it uses that to enforce that
only a certain set of values will
actually be carried along with a log
event and everything else either has to
be turned into serious error logs
internal types or or converted using to
string so all of those values then once
they're attached to a log event or
immutable and therefore mostly and
reasonably so
to do things like putting a in a batch
so that they can be patched up and
shipped maybe over HTTP but I work a
thread so there is a little bit to
contend with if you want to jump in in
them and write your own enriches but
it's certainly not super complex the
final stage of that pipeline across is
filtering client-side filtering is
something that I always imagined would
be would be really heavily used in sera
log you can write a filter expression
for your sera log pipeline that says
exclude all of the errors where the
error code is whatever so that you're
not so you're not collecting a lot of it
over time though I think we're the
people using sera log of tended to move
on from log files and on from things
that have those kind of constraints and
more towards collecting things in
backward back-end logs servers and these
kinds of systems typically have
mechanisms to filter at the server side
and that's much more ergonomic to go in
exclude events as they arrive at the
server will have short retention
policies that knock events out based on
based on a set of criteria than it is to
actually go and update applications with
the filters but the filtering is pretty
sophisticated as well there if you if
you define a use case where it's
important to you so that's the real
whirlwind tour of what makes sera log
sera log we looked at message templates
hopefully you're itching to go in them
and template up all of your log messages
now or even even if you've got log
Fernet or analog go and switch them and
and start collecting things with those
numeric properties because even like
filtering for an event based on a
numeric placeholder is not the worst
thing in the world
compared with I don't know what kind of
regular expression madness you'd
otherwise have to do and we looked at
enrichment and how to kind of slice that
slice log stuff in across a lot of
dimensions that way I think I'm just
about short on time now but I've got um
some time for some questions if there's
anything that anybody would like to dig
deeper into sure yeah
yeah well you see I use the static log
class only because yeah I use a lot of
IRC as well as I suffered the IOC bug
for many years as well and I do I do in
my apps as well inject pretty much
everything that I can't get away with
making static and stateless like you
know functional style stateless I've
tended personally not to inject dialog
just because when I look at a component
for i/o see that constructor list is
such an important piece of documentation
for me and I want to go to look at it
and see really quickly what the
components going to do I don't really
want to have to have our logger in all
of those but you can't of course wire up
your ioc container or a published one
that i published a new get package
called auto effects area log integration
I think that it gives you an idea of how
stereo log can be configured that way
with Auto fact the asp.net core donate
core vlogging subsystem has something
similar that it can do constructor
injection that way it's definitely a
possibility and not anything kind of
prescribed against and that's that's
actually the original reason of course
why there's no static state in Syria log
because you might want to configure IOC
so that some components get a completely
different logging pipeline to others one
of the instances that that might occur
is some sometimes you can configure a
logging pipeline with a different set of
policies to make it into an auditing
pipeline so yeah there's no place where
you might want to kind of choose that
implementation rather than just use log
the static class anybody else anything
else yeah sure
implementing your in sync yeah we could
just about we could just about do one
now I'll try I'll try I love it yeah
look I love a good challenge
I did get my morning coffee and I wasn't
that um so you're your own sink is oh
that's the page down button so the sinks
as well as the underdog Sarah log is
Sarah log was really optimized for being
easy to get going with I didn't think
when I first started working on the API
that anybody would spend a lot of time
working on working on writing sinks for
a brand new logging library that was
unproven it's kind of like chicken and
egg so the things that the sinks are
also very easy easy to write we can do
something like console ah do I not have
system look console we can write we can
write it out the just the timestamp
event I understand
hey and our richest still throws but
that probably gives us another
opportunity to see to see Sarah log in
practice so Sarah log did there we go
there's a there's our other sink in
action they're printing out the time
timestamp there's a there's a bunch of
machinery for doing things like
formatting events artist text using it
using a format string and those kinds of
kind of niceties and they're there's a
range of Jason C realizes that you can
use to do Jason based inks so you see
even though our enricher was throwing
every time an event passed through their
ass every local will collect up those
exceptions and just send them to an
internal log its carried its carried
that fail stop perspective through from
log4net where the logger shouldn't bring
down the app if it can avoid it
generally of course because your apps at
that point crashing in
you know if I can't be fought with fire
in that instance so yeah there are lots
but given that there are probably about
a hundred sinks out there I think now
even more you don't generally find
yourself writing new things too often
you can pretty easily grab the code for
any of those ones from github when you
get and and adapt any other questions or
we have some time
yep
yeah so that the configuration subsystem
so the question was how would you change
the log level with that configuration so
several log does have configuration in
fact and here's another opportunity to
demo the switch back over to the other
example
but the fantastic sorry log am analyzer
so you can configure sera log completely
using XML configure if you want it's
just that you need to add read from app
settings and install an app settings
package or read from configuration to
use there's bid on that core all right
the donate call Jason configuration but
the analyzer has this great little hack
where you can write your code first and
say in this instance let's add minimum
level to it debug and now we're going to
go and put that into app config I'll
Center we've got a choice between it
says show app settings configure app
settings so Jason config I just hit
enter and we can actually get the Sarah
log analyzer to generate the XML config
there and then copy and paste that into
the config file and get it going
so I hat off to the that people have
worked on making this thing this thing
go because it really it does show how
having also having code first gives you
a lot of metadata to work with to do
these kinds of cool things so any other
questions
yep
you use right to Splunk yep yeah there's
a package for Splunk there's a package
for a pin sites another very popular one
and elasticsearch and lovely and lager
and yeah typically all those different
back ends have different characteristics
of how they like events and so they see
this the sinks are all rather
specialized for them and the last
question on the front yeah yeah yeah
yeah yeah that is a very good point so
you can also with with the asp.net core
I login subsist logger subsystem or she
says the dotnet call logging is just the
habit of having watched asp.net core
develop you can actually plug Sarah log
in there and have the framework write
all of its events through its a logger
and then continue to use Sarah log
directly yourself in your code or chop
and change pick and choose whichever API
you want because yeah ultimately the
donut core logging subsystem is a facade
and you see that there are providers out
there already for things like log4net
and and n log I should I don't know
about log than that maybe yeah maybe I I
need to go and check it out again ok I
think that's we may have one one last
one last question yeah
ok good oh sorry with it was there one
ok ok great alright thanks very much
coming on really appreciated your time
coming out to see this one especially so
early but yeah catch me a few if there's
anything else that you did want to to
know a little bit more about and I hope
that I hope that you can take away some
things that make your life debugging and
diagnosing things a bit more pleasant in
the future definitely let me know if let
me know if you have some wins yeah
thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>