<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Mobile Architecture at Scale - Gergley Orosz | Coder Coacher - Coaching Coders</title><meta content="Mobile Architecture at Scale - Gergley Orosz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Mobile Architecture at Scale - Gergley Orosz</b></h2><h5 class="post__date">2018-02-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JxwRrQJoRas" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning
welcome to this first session of the day
thanks for getting up as early as you do
I
so it might not be the usual time before
we go so this talk will be about mobile
architecture at scale about how we built
and how we built an app or an
architecture that we're developing with
over 100 engineers on the same code base
I'll talk about why we're doing it why
we need 100 engineers and so on but
before I jump in just to get a bit of
feel for for you guys how many of you
are native mobile developers iOS or
Android if you wouldn't mind putting up
your hands okay how many of you are
doing mobile development in any other
platform and and how many are just doing
other things that made a back-end
develop and other engineering or
anything else awesome
in terms of company size how many would
you mind putting up your hands if you
work at a company that's small that's
smaller than 50 people or so yeah and
then for the rest of you I'm guessing
that'll be more than 50 people
great so with that in mind
I'm pretty sure you're gonna be taking a
bunch of civil way especially on the
larger company side the things that I'll
be talking about will be about mobile if
you have in the mobile it'll I'm hoping
it also make a lot of sense because I
will not go into the the trenches of the
mobile code itself but rather did the
thoughts and and in general things and
just a little bit of background about
myself I I'm an engineer manager at uber
I've been with ruber for about a year
and a half but before for about 10 years
I was a software engineer I I started on
the Microsoft Office stack I I had a
Windows Phone stint building a couple of
apps there WCF that's where you know I
learned a lot of my kind of architecture
knowledge the dotnet framework design
guidelines was one of my biggest
influences and then later on I moved
over to do mobile development web
development iOS and then I enjoyed at
uber and I've actually been I'll talk
about a bit about that a bit a bit
surprising on what our tester means on
mobile on how little or sometimes it can
feel a little bit more shallow but I'll
get into data and and why but why our
teacher is important so we'll talk about
three things today we'll kick off with
the motivation of why why we decided to
do something very different
at who
than the rest of the industry especially
with mobile developers we'll talk about
architecture why we ended up building a
new architecture and and why we didn't
seem to see that the things out there
work for us and then I'll talk about
something that a lot of you can take
away is how do you scale the
architecture if they're even an idea at
a big company to have everyone use it
the way they should
so I'll kick off with the motivation so
in terms of motivation I'll talk a bit
about a diverse history or more the
app's history how the architecture grew
and how we got to this point where we we
decide to rewrite and and why we did a
rewrite up after a couple years so how
many engineers does it take to build
Hooper I get this all the question all
the time and and the answer is it's
about one or two this is the uber team
back in 2011 building I think the second
version of the app is first one was
built by contractors and we threw it
away start from scratch that is the
whole team you know busy really seeing
the latest feature I don't know sure
those credit cards or whatnot the things
have changed as you know and and uber
has grown exponentially especially in
terms of engineering so you can see that
in about five years we went to having
one full-time engineer to about 100 and
this is sort of mobile engineers I'm not
talking about any other this is only
mobile engineers and a lot of Engineers
especially for the mobile you're
thinking of what hundred mobile
engineers like why would you need to
have many people like I from my previous
experience like I worked at a company
where we had about Skyscanner we had
like it on one app we had like about 10
engineer's max and that was a really big
team and we had some really big
challenges there
so why hundred well you know doober you
start you need to request a ride that's
what we call the rider app then there's
a driver's side where drivers also have
an app and they need to do a bunch of
stuff as you can imagine well ooh BRR it
turns out we're about this is rough I
don't have the exact the exact number
but we're about 80 countries in about
600 cities and in every city we have
different things in every country we
have different regulations that we need
to do so there's a bunch of extra stuff
there and then we're not just nubra
anymore but we have things like so we're
not just kind of
taxi company but we have things like
eats we have now half right we have some
self-driving things where we also have a
mobile app if you ever get into
self-driving car you see an app in the
backseat that shows you a bunch of stuff
and you can interact with it but and
these things are not as as simple when
you request a ride like sure you connect
the rider with the driver but there's a
bunch of other things that are going on
for example you can now schedule a ride
I just did when I came to the airport
you see a bunch of news items which you
know you might not seem that important
but they're they're doing a bunch of
things you can split the split the fare
with someone you can in the u.s. you can
have a family account and check on your
team where they are tracked them I like
in a good way
you have Airport pickups yada yada yada
it all adds up and and all of these are
typically they're responsive as
different teams so that you will have a
mobile engineer who was responsible for
this experience on one app or the other
four drivers as well we we have things
like uber beacon in the US you have
those little glowing things you have the
cash experience how do you make sure
cash you can pay with cash and a few
people know but in Indy in Latin America
you can actually pay with cash from uber
we have uber pool maps are super
important there and again it starts at
up same with being in so many countries
we now have a bunch of Engineers so now
we have a dedicated team for example for
app performance who measures how fast it
does what are our critical bottlenecks
fixing those thicker networking making
sure we work well in low latency
environments and so it starts set up and
then of course we have separate apps for
each sprite etc so it kind of all all
comes about uber whenever you open uber
in a different country or even a
different city you you might get a
slightly different experience
we do have features that are only
specific for one country so that's the
answer that's why we have a lot of
Engineers and again it does start if you
want to start build a simple uber app it
is you know one one engineer can do that
so the the app has grown over the time
you know it started this is this is the
app about maybe like four five years ago
it was you don't have too many options
you could say pick me up you could
select maybe the vehicle type that was a
big improvement
the initial ones and then we start to
add more things you know you had a bit
more vehicle types we had to be a bit
more creative around how he did that we
have you could
your pickup location again more more
features came in and they starts a bit
bit crowded you might not see but uh
it's things are barely fitting you can
barely read it but it was it was kind of
okay and then again more and more things
start to come up more more teams came
putting in their features kind of
cramming them in and the map starts to
get smaller and smaller and we got to
this point of that we call the where to
moment there is an actual screenshot
where this is the whole app in a smaller
device like that is the map and I'll
just zoom into there's so many things
going on there it is all features the
SOS features and and uh and and it says
SAP swipe down for what it's you can't
even see what exactly was so this was
the point when we decided the design
team decided or the product team decided
like this needs to stop like like we're
cramming everything and uber should be
about you getting from A to B not about
these you know it's turning into like a
newspaper or like in a in a really bad
way like a tabloid so this was a point
when the design team and product team
said like let's just let you change
everything let's change how the app
works and let's start clean let's make
sure the map is in front you know things
are we sell the features but they're
kind of you know more contextual whatnot
so at this point the engineering team
was like sure that sounds great you know
what does this mean what does it mean we
had an opera texture that was some based
on NBC or MVP that different paths
little bit different or like well we
need to change all the views obviously
we need to change your sequence so we
need to change a lot of the business
logic like you know we can keep some of
it but practically we'll have to we'll
have to like throw out about 50 or 60
percent of the code and I mean if you do
that what is that is a rewrite so like
okay so so we actually need to do a
rewrite it's not that we have a were
asking for we have to do it so we said
cool if we do a rewrite or well let's
take an opportunity to do a proper
rewrite let's just not just keep
building what's happening but let's
address maybe some of the the
engineering things the the challenges
that came with our chat your growth so
what paint so on so now let me talk a
bit about like what pain points we had
with our texture growth so in the Europe
when when we started maybe even before
dispersion but after the architecture
was like this we had I'm gonna talk
about Android but this is
to iOS as well you can replace activity
with view controller or you can just
think if you're not doing mobile
development just you know component
where the logged in activity that was it
well okay not entirely because after a
while you know this is a bit too big to
be one class or one one activity so we
brought we broke it up to have you know
a menu a location like a menu was there
that small thing if you could expand
location controller let's say a product
selection so like a couple of components
and then each these components have some
sub view sub components so you know that
was our initial artist pretty pretty
nice very simple we try to you know make
sure responsibilities are clear we used
against something like MVC or MVP which
I'll touch on but as they artistry grew
we we we saw some issues one of them was
how do we store state so here based on
your your selection that is like a
separate component based on what you
select that little guy will show
something different and that might be a
different responsibility so those things
have to communicate and the easiest way
to communicate things is via state so
that's what we introduced we said hey
you know at the logged in level at the
parent level let's have some sort of
state this guy knows about it it's
somehow collects that data so whenever
you would fear you know swipe something
you would modify that state and the
other controls root node great this
worked pretty well so that's what we
have we started to share state between
components and it they work really fine
until well but when I tell you you know
this was a rare texture I'm a bit lying
because this was really our our
attention at this point like as you have
more things your parents start to grow
but by small things but it starts to
become bigger and as we start to add
more things we start to become even
bigger and and then we had that state
lingering around so I'll get to the
point on what this actually meant
ensures biggest problems so when we came
to rewrite we actually sat down I said
like honestly like what our biggest
problems because it seems you know like
it's not as fast as it used to be like
with the three team three percent it was
faster and then our number one problem
was actually the number of engineers we
had a hundred years by this time all
working on the same app and and and that
is the crux of it I for my experience
architecture is not really important
when you're a small team for one person
you can have the most complex app in the
world in one function or you know maybe
one are exchanged if you want to make it
really hard for next person but it'll
work but team of three you want to have
some some things kind of figure it out
who does what with a team of ten you
kind of want to understand you can put
something where but we were at a hundred
and we were trying we were following all
these best practices still one thing
that we saw is people did not no longer
understand how the whole app works like
they understood parts of it but a new
person joining it tipped them forever to
figure out a lot of stuff and they made
a bunch of mistakes they start to
interest a bunch of bugs because they
were not aware of things like states
like what state existed and I'll talk
about that second and modifying the app
start to get slower so you know you know
that joke or when if your product I just
you know what takes so long to add a
button we got into a situation it wasn't
adding the button that took a long time
making sure that we didn't break
anything on the way so what a state have
to do with with this whole problem so
let's let's say that kind of a half
hypothetical but like somewhat practical
example we wanted to build a small
component that would show kind of
notification when your driver was on the
way so you opened the app you know you
say alright search for we request a ride
you get the kind of loading indicator
and and one from the server you get this
this notification that a driver has has
accepted and started going you get this
little pop-up now the code for that was
was something like this and it's not
about the details but I just want to
highlight it's a bunch of code but the
the most important part of what it what
we wanted to do we just wanted to have a
component that could show a notification
saying it's on the way and we could tie
it and now we have a bunch of stuff
around state because we had a global
state we need to make sure like well if
if the trip has already changed we have
a trip level state that the trip has
kind of updated that we know that driver
is on the way then then we show this
toast but if you have or if you already
started the trip and you get this
back-end message you don't want to deal
with that so you don't want to show it
and then you have to store some some
local state now we had to do a lot of
this stuff because we had this
state which is which was just none of
this components business but like
everyone has to know about it because
you will break other components so
instead of this we have had to write
something like this and this was just
one example of how whenever he added a
new component instead of being something
simple and you know one responsibility
it had to know about the rest of the the
app which led to the the other problem
modifying the app let's say we wanted to
add a new kind of component or module
like normally you would just add this
component and you're done
well in this case you always need to
modify the the parent as well but that's
not really true because now yeah we
actually need to either modify or test
every single one of the siblings we need
to make sure that these things all work
now I mentioned that uber works in 80
countries now and back then it might
have been only 40 but a lot of the bugs
that we saw happening was oh something
broke in India what happened oh well you
know the US team added a new feature on
uber pool and it just broke the UI and
in here like what happened while they
didn't test in India like and it's a
they didn't know about it so it just
started to become slower and slower and
slower so these were our main pain
points so we're like great we can start
from scratch your design is saying yes
we can rewrite our CEO I'm back in the
day Travis was saying we need to rewrite
you know our history our future depends
on its are like great but before we
jumped in all right so down let's some
goals like cuz you know let's just not
rush into this thing before we set some
goals we just I just want to highlight
some things that as you were as a
company we had as constraints and
opportunities that not all companies
necessarily have or no one constraint
was that we needed to stay native the
reason for this is were a part of two
reasons one is we're a partner to Apple
and Google they bring the latest
features they actually come to us and
say hey you guys need to do this or can
you do it but it's a you know it's like
we sometimes we would very much want to
do it it's a it's a mutual beneficial
ratio we're at that size and and then
the other reason is we don't want to
give up control so performance is a huge
thing for us we we have a whole team
looking at performance and how we can
optimize the
just if we go with something like
xamarin react native whatnot we are
giving up control for that third party
we could of course invest in them and
then help that better but going back to
the first point we do need to have
support new features often before
they're out often before they're public
like a couple of companies were you know
who who would become launch partners it
would make it more difficult for us so
we decided we're saying they'd like we
need to be data bits it's not a question
native on iOS native on Android the
second important thing is we decided to
have independent iOS and Android code
bases we wanted to have that native app
and want to be able to change them
independently an example is we want to
add Android pay for Android Apple pay
for for iOS and and there might be some
small like we want to feel the same but
we want to reserve the right to have it
different because of this building
something that generates code even
inside of us for the two apps we didn't
really want to do it so we have separate
repositories for those what are some
things that I think ever was lucky to
have or I was lucky to have it be be a
River to be a company has it oh we have
something called a mobile platform team
I do Burwood called platform team kind
of a team of developers whose only job
is to help other developers in the
company it's like they don't like this
is this is like the cool team this is
like the people you hire to build cool
stuff cool tools for developers they
they are the ones who build frameworks
they build performance tools they like
their role is like their job is help
other developers be more productive or
better at the company so that's pretty
cool few companies have that you know
companies like Facebook and above a
certain size you have it
uber had this pretty early on which
which helped us with the rewrite and it
finally we had something called a mono
repo so unlike a lot of places that use
pods and and and whatnot you pull it
from different repositories for four
components we have all our source code
for our are all our iOS apps were in one
repository and we had a separate team
who made sure that the bill times were
really fast so we would optimize this
with what we would try to make our
compilers better so the opportunity here
is that we didn't need to worry about
all the schooling we just said like hey
guys our build is slow can you do
something about it and a couple of
engineers would work on it day and day
out and they would just make it faster
and integrate with our you know build
tools for our 4x code or IntelliJ etc so
that's that's pretty cool all right
let's get back to like what what do you
have for this rewrite
we have this really great team to
support us we need to say native alright
what should we do number one thing is we
want to get isolation and testability
you know what I show the diagram of like
I add something I have to modify
everything good and none of that or like
as little as possible can we just like
have everything do one thing and one
thing only and and be testable as well
we want developers to be productive
let's not get slowed down and you know
it's this is a bit harder to measure but
we want to put that as a goal there next
we knew we're at a hundred engineers we
knew we will be at like you two hundred
and years in a year and and and so on
like can we do something where we just
don't have to rewrite again like is it
possible please the next one was a bit
specific to to uber but every app of a
certain size can empathize we want to
have to always work like at uber like we
update the app every week and bugs will
go out there like it's you know the more
engineers you have the more it is we
want to important us to always work how
do you say it should always work well we
said is let's turn it into something
measurable the core flows are the things
were like it's the most important but
your question that you request an uber
you get an uber you know you use it like
we wanted that stuff to always work that
other stuff you know updating your
profile whatever that can break
sometimes it's not great but it can and
we said like out of 1 out of 10,000
sessions should only have an issue like
and that's like 99.99 or like let's
measure that and and you know let's make
sure that it works and finally a to to
to things we want to have the and this
is again when you're big enough I will
monitoring to be a first-class citizen
not an afterthought was an afterthought
and we wanted to make sure that that we
could experiment run a B test without
crashing everything whatever you see you
graphed we have we have a lot of
experiments running similar to like
let's say Facebook or whatnot so you you
might see some things that other people
don't you're you're helping us to figure
out if things work so thank you and
sorry
and finally as we talked about all these
things we realized hey we have this iOS
team we have an Android team wouldn't it
be cool if we could do something that
was kind of similar again we have
separate code bases but in the past the
iOS app had an MVC architecture Android
I have an MVP we had
different structure we still have the
same feature but all teams I didn't
really talk we're like can we do
something that's just have our engineers
talk and and do something Hannibal
similar so so those are goals so how did
we do this again we had a mobile
platform team so we had about about five
to eight engineers for about six months
practically well for three months locked
himself in a room and they started to
protect everything like they took the
core part of the app requesting a trip
and a prototype but some some things you
know how can we do like think of a
building to do app just for uber seeing
does this work is this look good some
were really experienced engineers and
and then they came up with a core
architecture like alright we can build
on top of this then in about so this was
in January in about June we had the
first team who's building this kind of
core experience that the driver team
come in and for them to actually test it
like I build this core flow which is
requesting an app and then they came
back and said aha
they started to do that and they
realized like this this is terrible this
is missing we need to do this so for
another a couple of months we iterated
on it and made it better and then the
rest of you burst so all the this is
like I just put about 20 engineers the
other 80 engines joined in and we told
them you need to this is where I
actually joined uber a bit earlier but
but that this was my first ever project
as an Android engineer and and yeah we
in about four months we just rewrote the
whole app like we literally froze the
existing app we rewrote everything in a
in a pretty quick pace and I'm released
to the App Store and that's a different
story because we did a hashtag Yolo
release we replaced the iOS app with the
new one and we thought we thought there
would be like the adoption was was
really fast so and without we have like
one percent of people on day one we had
like 20% so there's a pretty fun and
exciting launch and scary and at some
points and that's rewrite done well that
makes that seemed it really simple it
wasn't and entirely I'll and I'll get
into like what what we've learned but
what I did learn from this one is when
we said like hard deadline for
deprecating in app it's it's nice it's
also a bit stressful what did we build
in the end so we build two things we
build a ribs architecture and I'll talk
a ribs is this architecture that we
built and I'll go into details about it
and we'd build an application frameworks
our tech chure is the the thing that
that like we have pretty generic things
that anyone can use things are in
testability about how we do routing
cogeneration components an application
framework is more specific to about our
monitoring infrastructure how we how we
use our networking some of our UI
components we open-source the rhibs
architecture because it should be usable
for other people for the applications
framework we might open source parts of
it but some of this will never be useful
for anyone like we have a custom
monitoring system so that component will
talk to our api's and all that so you
won't it's not going to be very useful
for you so that's that that's the the
motivation part let's let's get a bit
more kind of hands down on on
architecture and then when I say hands
down like not in the street all the way
to the code but we'll have a bit of that
as well so how do we approach our
texture and before I talk about how and
why it is that we designed ribs I want
to talk about two really important
things on architecture that's really
important for every client application
and you might not I we learned this the
hard way but the this this is I I
believe every when we think about our
texture we should always think about
state and we should also think about
dependencies we should take these into
account in the past I didn't so let's
talk of a state in state management
problem we did a diagram of the old uber
app which was again built by 100
engineers or what state transitions
occurred and it was horrendous I no
wonder no one understood the app it was
a lot of these transitions in the middle
there and when you go on trip when you
accept so many things can happen a trip
can end the price can change you might
get notification so yeah it was it was
not great and we're like all right so we
had a lot of states going back and from
like how do we simplify this but make it
easy to understand and easy to modify
and then of course like when it comes to
graphs and all those things one of your
simplest data structures is a tree so we
asked like can we just represent our
taste like a tree something like like
this and so we starts to sketch it out
and like a simple tree like ideally you
know making it and it's it seems that
everything that we did here we could
just map it to a tree so we just kind of
the most important part of the app which
is for which I'll talk to to this one
like you know you're logged in or you're
logged out and it kind of seemed that it
won't work so or like alright let's give
this a go so how you know what is those
days mean or how does this work so let's
talk is a specific example let's say you
know sure you start the app you have
this root component whatever that might
be and you're logged out you see like
alright you need to login you you enter
your username and password this
component that makes a request to your
back-end which then returns a response
and then this component says like cool
you're no longer logged out you're
logged in I'm just gonna show another
component like I'll replace you and I'll
get rid of you and not that's kind of
the idea it's not nothing rocket science
this is very generic nothing to do with
mobile so like cool let's let's use this
model let's just have these like pretty
simple components and then we can try to
break it up into logical pieces so this
is what we did we built the app based on
on state we know what can happen and and
it map pretty well tur to our UI is
actually so this was before we built the
new app but we already mapped it there
so for example all of these that I'll
show where they map but one thing we
noticed is in the past app we only
thought about screens every single
components had a UI these no longer all
hats so there were some parts that
didn't have any UI so for example we
were thinking it makes sense to have
something called a request which is only
job is that if it listens to our network
saying are you on a trip or not and if
you're on a trip it shows this part if
not it shows that part and we felt it
kind of feels right that it has its own
thing instead of just being part of this
like logged in say because it makes
things a bit more clear and like our UI
parts like our menu is there we have a
location editor we have a feed card
shortcuts but again we felt that this
should these three should be owned by a
home component because it's only shown
when you're you're there and it should
have some business logic around
manipulating these expanding them what
not so we're like okay well that that
looks pretty ok let's let's let's go
with this so we thought we have a
solution for the same problem so what
about the other big problem we had was
scope
so I mentioned that like we had this
thing where in our previous app we had
this the school that everyone knew about
like every single that the whole Avenue
about and we're thinking that caused a
lot of issues so that was the problem of
why whenever you made a modification one
of those components need to know about
the state of a whole application sort of
like can we just limit that can we do
this thing where let's say when you're
logged in like this this root component
knows that you're logged in and it
shares this scope with only the the the
logged in child and of course itself and
let's say that you go you you go to your
home settings so you're not logged in
you know we share that scope with all
your children and then let's say that
you go on a trip and we share this kind
of scope only with that children and so
on so and whenever let's say you know
you switch between like I'm no longer on
a trip but I go back to home you kind of
get rid of it and what we saw is is with
this we would have lost short-lived
scopes which would simplify our state
which would lead to simpler components
and I'm gonna show you a demo when what
this means this whole components mean
but it seemed this model would work
pretty well and make things pretty
simple so so these are the two things
that we took is like we wanted to have
some architecture that can support this
tree structure with a non visual kind of
state like nodes if you will and we
wanted something where we could we could
have this hierarchical scope where a
parent can pass on kind of informations
as children that they can use and modify
but it will only be used for that part
of tree and it will disappear later if
they there kind of died so before we
jumped into we said like let's not
reinvent the wheel what is out there you
know like iOS and Android world give us
what you got so we went through all
these things and I saw some some people
put up their hands they're not COBOL
developers I'll just go through a few
things that it should be familiar from
other things so in mobile we have MVC
MVP MBI mvvm and then Viper and evite
for and I'll also just just do a quick
run-through of what these are MVC who
who knows about MVC put your hands up
great all right let me talk about mobile
MVC it's
I guess is similar to NBC so and mobile
it's or client-side development you
won't know you know where the input
comes from it goes to the controller the
controller the menu plates the model and
updates to view it's kind of the brain
of everything and then the model the
view also usually subscribe to changes
on the model so your observables usually
it depends again this is like really
rough outline but that's roughly MVC and
if I'm terribly wrong pull me aside
afterwards and tell me that I run but
that's my idea and with MVC by the way
there's so many flavors so it can be
different in in the mobile world we we
have something called MVP Model View
presenter this is especially popular on
Android because on iowa's for some
reason MVC actually works more like MVP
but that's differently so instead of the
controller we have a presenter and the
difference here is your inputs go
straight into the view so when you type
on a text box you know it goes into like
the view part the view world then the
presenter will will subscribe the
observables to changes to this view so
it'll have a sum of dependency it starts
update the model again it listens to the
model being updated like if everything
changes and it manipulates the view so
the dependence change it's a bit nicer
and and responsibilities are a bit bit
better defined and you know the the
direction of data flows is again a bit
more straightforward then we have
something called Model View intent this
came from the JavaScript world and it
became an very popular in Android for
certain applications and the idea here
is like with MVC there there was a bit
of a master controller did a lot of
stuff and it just became this huge
bottleneck but it was a nice idea so
what if we still had the input going to
this thing called intent which
manipulated the model the model then
actually manipulated the view and the
view updated the intent so like whenever
you whenever you would have any any
events go on it would and it works
pretty well it has things like reducer
so on the intent you would have a lot of
the idea of reducers again from from
JavaScript and it works well for some
applications so there's that part as
well and then there's mvvm you put your
hands up of you know of mvvm yeah so I
imagine I I started wcwc app WPF
you know it's I grew up on this but I
first loved mvvm and because of because
of the the very the fact that layers
only similar so again you will know
input goes into the view the view knows
about the view model add update set the
the view model knows about the model but
on the way back it's just kind of a
binding or salt dependency so you know
with with these I'm pretty sure there
might be a few more permutations but you
get the idea
all of them are a little bit different
but they share some common things and
then it only comes to mobile most apps
are built on these and they work fine
they work great for some bigger apps
some people said like wow this is this
is difficult and the most difficult part
in mobile is rounding between screens
almost every time these views are either
a screen or a controller but how do you
do routing and the at a platform level
routing is weird and I was compared to
other client-side things and like in
Java so if you don't even in what you
don't need to be too worried about it so
some people came up on an iOS with this
comfort of Viper and and this is taking
MVC or MV whatever to the next level
it's got this thing called interactor
which is kind of the brain it's got the
business logic so the inputs will
actually the emphasis will go into well
the interactor decides all right I'm
gonna I'm gonna manipulate the data my
data source yeah my entities it then
also talks to the presenter where the
presenter is is this kind of layer
between between the view it it done
manipulates a controller listens to
chase re the the view and listen to
changes on the view it will tell it will
tell the the interactor what kind of
stuff to do and then finally there's
this thing called routing which is where
all the screen transitions happen the
big idea behind this this model is
really the the routing and it kind of
splits the view the view and two parts
there's a presenter and a view
controller it works pretty well for big
apps because you have you move your
routing logic out you make it clear what
your business logic is and you split
your view Model View logic into two
parts so it's it's nice what all of
these share is they all have a view tree
like every single thing you do have
you there and I mentioned that in our
case we're thinking can we not have a
view also the business logic and the
beauties are tightly coupled so your
apps structure will be whatever your
views structure is pretty much and then
finally we start to experiment so again
what I said we wrote part of the app
we're thinking like how can we share
this kind of States like so that it's
only short-lived which we call deep so
hierarchies and you can do it you can
you can have this short clip States but
they need to be based on your views
again so there was consistently we're
coming for every single one of these
architectures there was this limitation
that we it was a problem for us and it
seems it was say a problem of if we
stuck to this so going back to Viper
this component this Viper Oh surging
published as a code example and an
article and then some people start to
really use it and like to use especially
big companies with lots of developers
it's the science of creative but someone
came up was said like hey it's not
really usable let's make it reusable
let's add a builder that turns the whole
this whole thing into module so we we
actually we actually kind of like this
this whole idea of Viper and it was all
separated but some some things felt off
but this was the architecture that
inspired us the most and so we built
ribs and what ribs are is again the
names will be different but the function
will be important ribs are are just an
inn tractor or router and a builder so
like business logic routing logic and
then in some cases well a lot of cases
but we have a presenter and a view
similar to to Viper and some of the
others but these are optional like you
can I have it without this and so the
way ribs works is if the end tractor
again is kind of your business logic it
will make some data requests represent
or hey you know present this data or do
whatever with it the presenter we
actually make it optional we often don't
have presenters we go straight to view
because usually these this later doesn't
do much actually so we just skip it but
it will if needed it'll translate to the
view to understand you know what what to
show the view will via some UI events or
some binding you know let the presenter
know like hey what's happened and then
the presenter will also make some some
business logic calls to the interactor
and a final
when things are done the interaction
says i route the big difference with
ribs is we have routing does not happen
between screens they happen between
components and I'm going to show them
all of what this is so i with the demo
well I'll go into a bit more details on
how these work but ribs are just sounds
for a router interactor builder and yes
you can have a presenter interview so
how does this you know let's go back to
original example of like what we planned
hey let let's have this kind of estate
tree with with visual and non-visual
parts where we have that menu component
location component feed curve component
and short kamon ins so what we build it
with ribs every single one of those is a
rib router and tractor builder and it
might have a presenter of you so how
does that actually work in practice and
I'm gonna instead of doing a live demo
I've recorded this we have we have this
pretty neat tool where we can we can see
the our rip tree on how it changes and
I'm just going to show how when you use
the app how these components or ribs
change all the time and first we'll just
go back and forth and you see that
whenever you change things like that the
rip tree updates all the time and so
here what I'd like to to show is let's
go on a trip so when you want on a trip
suddenly we throw away every other
previous kind of tree and and we have
that that thing is called the trip
router a trip component there so once we
we go on the trip I will see some new
components pop up on the screen there we
go we're on the trip so I'm just gonna
pause it for a second so as you can see
as as I say changes we kind of you know
it's like a if you do it's like a Dom
inspector like we are we add and remove
elements and the difference the
difference where the Dom inspector
potentially is that these elements also
have scopes so so this this parent what
will pass the scope down to its his
children so whatever this is removed
that state is destroyed which is awesome
because a lot of the bugs happen when
you have come left over stain and things
happen in the background and what I'm
gonna show here is is when we cancel
that trip like yeah you can see we go up
and down we have new elements come in
and they typically we add it and then we
remove it for a while we could remove it
for a memory optimization what happens
when we cancel the trip is this whole
tree is gonna be torn down so let's
cancel it yep let's it's confirmed we
cancel it and our tree has completely
change we go back to our previous tree
that was there so that that's how just
the kind of visual representation of how
the trip actually do work in practice
pretty well all right let me go to the
next slide I have to go through the
whole video it seems sorry about that I
am stuck
all right so that's how the components
up to update and work one thing I didn't
talk about and I kind of just kind of
left it on the side is this is the part
issue at ribs just go into it understand
and this is what the Viper looks like a
big difference that Viper and every
single one of the architectures had they
had like a model or something about data
I didn't talk about that why is that
well with with ribs we we didn't make
the model part kind of per se part of
this we're not subscribing where you
should or should you shouldn't use it
you should probably use it in the
business logic by the way with the
interaction what we didn't subscribe but
in practice what we do with ribs is as
well specifically for uber and a lot of
mobiles do the same thing was we have
this kind of stream based data approach
and you can do something different so we
don't subscribe but this is just to
share what we do and it's a nice
practice
so the interactor will make like your
Network West to service you know like
hey fetch me this and this is most of
the mobile apps are online driven so and
that's that service will will send a
response saying hey I've started you
know but it's not the result but they
can we can show the loading indicator or
whatnot and then that service toxicity
so your services it gets the response it
doesn't get the response traits the
interactor it gives it some model stream
which is typically on our extreme
immutable and this interactor listens to
those data models it gets updated and
then it's it starts to tell the
presenter hey you know update yourself
it updates the view the view might
return a UI event which might turn into
some more business logic calls going
back to the service or not and at some
point it just tells the router alright
you know navigate or do something so
that that's how this whole thing fits in
there but that top part is not it's it's
where we're not trying to be opinionated
about it you can do whatever you'd like
there if you want to a plain old common
object you can have a plain old common
object and finally on the arty tries to
write one big difference with ribs and
with all the architecture is we do
specifically think about viewless states
states that don't have any views and why
why would you have have that state
because you just basically take away all
this stuff like why would you have a
good
like that it's only two classes well it
it actually in this case all that this
the main responsibility on doing some
sort of business project is attaching
and detaching children and does that
make sense and I'll show you why it does
make sense in a demo with this inspector
so so here you will notice that when you
have new barracks or uber black those
are all things that I believe you can
schedule but you cannot schedule in
Verve an because we have so few of them
that that they don't work so right now
uberx is selected and now when you're
selecting an uber van like that
something happens so well we'll look
we'll look at that again
so inside Bieber van that little
scheduled right thing disappears but
then it appears and as you can see
that's tighter component right there so
there is this this component here that
is responsible for laying out all of the
the child components it has an extra
responsibility this is a viewless
component that doesn't show any view
it's got we have a couple of UI elements
here but it has a business logic to show
or hide this thing based on the
selection and it works pretty neat you
get by having these viewers ribs and
Google Sites failing on me again so see
if once we see it we can go to x1 but by
having these viewer strips you can you
can make your business logic a lot more
clear and we have a lot of them in our
application and again your your mouth
might vary alright cool so that's the
architecture part and I now I'm just
gonna close with what some of the
lessons I've learned scaling in
architecture so we build this really
cool architecture with these like four
or five different classes we have some
ideas on how to use them how not to use
them how these viewless things and a
team of the wall when I say we a team of
about five or ten people built this and
we had under people to use it so how do
you adopt this how do you make sure
people use it and they use it the right
way don't use it like like you know and
don't use it like MVC that your user
don't use if I can
P use it in the correct way and when I
talk to the guys and I also saw it
firsthand it adopting any framework or
any new idea or any architecture pattern
it's it's a bit like like this like you
know you have here you do your best to
herd cats you do your best to tell
people but you know every one of the
developers they're you know really smart
they know what to do they're they're
opinionated they'd love to do
workarounds that they will not tell
other people and so other people will
discover so it's hard I we did find a
few really important things that you
should do and like next time any company
open source in architecture I'd love to
see some some some more of this or not
even open source but just use a first do
cogeneration like best way to make sure
your code looks and feels the same have
it be generated the same second you know
think about your onboarding have your
onboarding people and then finally think
about how you can force these pattern so
I'll go through this one by one code
generation when this team came up with
this idea the reason I think it was so
successful is when they kind of gave
access to the other hundred engineers
after initial thing they they had some
coal generating templates on Android
studio they said like if first day one
install this thing or we had a pre
installed you know generated component
it throws out all the all the code that
you have all the boilerplate and it's
it's kind of it with a lot of comments
you know add your business logic here do
not do this as etc and we did this for
iOS and for Android actually it's a lot
less work than it seems I talked to the
guys like oh wow you're so cool you
build this how long did it take well
yeah it took it's like an hour plus you
know you need to know how to do this you
need to look it up but I I ended up open
sourcing this part of the application I
never did cogeneration on either Android
or iOS I just did it and in any any
modern ID it's easy to do so next time
you want off something to a code
generator people thank you for it and
it'll make it easier and we open sources
this one second was onboarding whenever
you have this new architecture you kind
of assume like it's easy people get it
but how long does it really take to
learn a new architecture and I I think
it takes a lot longer than you think now
when you have a hundred engineers you
start to notice these things but but
actually like when we had
you guys join our team which showed him
explain to him you know I we didn't talk
for an hour it's not for two or three we
thought he knew it and a week later it
came back with questions then we
reviewed his code he wasn't doing stuff
it took a long time like a couple of at
least a couple of weeks like a month so
that he really knew how to use this so
what do you do well you know if you have
a bigger thing definitely do some
documentation especially like we are
wearing a team in Amsterdam and based in
Amsterdam we work with the people on SF
like you need it might be easier if
you're local but then you're kind of
just shielding the problem from when
that person cannot talk to you so do
good documentation and then one thing we
start to do after a while because the
trooper we had people join literally
every every week and we had assumed I
get him again we start to do tutorials
how does this work we put together
example apps now we did this because
we're big enough and we had Tom but
again we all were at least fifty or
hundred engineers on this last year and
it was tiring to do the whole sessions
and then we ended up encouraging
contribution at the end of the tutorials
we said like hey does this make sense
your first task is to fix this tutorial
because it's probably outdated so we can
have got a little bit of loop and then
we also open source at all of our
tutorials that we so as part of open
source architecture we're giving the
code generation and there's tutorials
and it takes a good while to go through
it like if you properly want to invest
in it and it'll take you like I don't
know like from a couple of hours to like
a week depending on your pace cool code
generation good people can onboard how
to make sure they actually do what what
we want to do you know and that's a
tough one and uber we start doing
something really early in the company
which is lint rules initially we did use
Blin for you know spacing and all that
turns out you can you could code like
artists or patterns in there as well so
this rule says that for example if in a
view controller if it if in a view
component you've invoked this a child
controller but don't do that you get a
warning it's like and we have tons of
these and and it's pretty easy to add to
our linting rules so I people whenever
we have an architecture discussion and
we have an agreement or disagreement and
we come to a conclusion we haven't just
add a lint rule hits when you try to
check in code at uber
it's so hard to mess it up it will
literally tell you cannot do this and
then sometimes you
agree with that so I'll get to that at a
point the other super powerful thing we
have how many of you have used a tool
that supports blocking code reviews like
fabricator see some some hands up there
so suddenly you don't have it
fabricate it well blocking code reviews
are awesome everywhere we use fabricator
so what this means is you created a you
create a pull request or an fabricated
we call it if teams can kind of specify
if you took in for every file or every
folder you can say if this code is
modified I want to know about it I want
to be blocking code reviewer being a
block included means you cannot merge
that pull request until that person says
yes so in this example would screen so
did you see I I i created a change for
like the payments and immediately which
touched some cork android code and some
payments code immediately to blocking
viewers are added and i can i cannot
proceed without them and this is all
automatic
of course it's part of this your culture
needs to change because now i can't wait
for those for like a day and they need
to respond but it's really cool the
experts are reviewing your code but only
when you change that part of the code it
also encourages you if it's not think
about it do you really need to change
the like oh whoa I did not realize I'm
touching some really like sensitive code
here like maybe I thought that was just
like you know I was refactoring that
part maybe I'll skip that for later it
works very well and it skills very
natural with the team if a team stops
doing these blocking code reviews they
just get taken off after a while like
it's it kind of this only works and
until you have a team developing things
so it's nice and then finally like what
if you disagree with a lint roller or
something we're trying to make it easy
for people to change the process change
the architecture and we're following
something called an RFC the IETF does
this for the World Wide Web it's a
really long and difficult process but
we're doing a super light conversion you
have an idea or you want to make a
change or you want a little product you
send a summary like a one page or two
pager to all of your engineering you say
like here's what I'm doing here's my
plan that's it it works like a charm so
it's like a fire hose of information
people start comment again and you
sometimes that approvers and so there's
this discussion going on and if you're
you know if you work like
and you're really big about I don't know
dotnet you will read and you might have
a filter for anything that has dotnet
and when someone talks about dotnet
you'll want to jump in and you'll want
to give your two cents and sometimes you
can say like what we should not do that
and you know it goes offline so we have
a pretty good way to and we've changed
our architecture and things a lot with
this and we're now working on a new one
so you let let's say you do this you
have cogeneration you have onboarding
you enforce your patterns like does this
mean you can adopt your framework yes
and no you're missing one really
important thing is ownership whatever a
new thing you do framework architecture
methodology whatever if it doesn't have
an owner
it'll die like like people will follow
all these things and then they'll care
about it so in our case we do have a
team who owns this thing which which is
why I honestly think it works otherwise
it would not work they're driving this
they're you know they're they're
interested in this being a success in
being developers making it involves
productive so yeah just just make sure
that team yeah and you have a long term
owner if you work at a big company this
typically means talk to you know your
manager your management just saying like
hey this is our responsibility we can't
just do it on the side it's gonna die
that's how a lot of company open-source
ends up going to alright so how the
drivers work out for us this is just
closing it up we have three apps with
more than 200 developers using this
architecture one of them is is a writer
app some and some I can't be too
specific about them but will like we're
in the process of getting them out there
but we're about 200 developers using it
we have more than 600 ribs like these
components and a lot of them are reused
within the app or else or between the
apps which is pretty cool almost all
classes are less than 300 lines of code
which is nice now a Reb does have like
four or five components so like you know
in total it like fifteen hundred but
it's pretty cool that it's a small class
because it's so small and kind of simple
almost all of our business logic is
really well unit tested you know like we
measure percentages but it's it's just
more the important stuff is tested which
is cool and we open sourced the rhibs
core architecture so you can check it
out if you're interested so we use this
for a year we open source at about two
months ago
what
Engineers say after a year using it so
this is I'm not going to take the
positive feedback I'm gonna take about
what the the criticism that we got and
that we're working on the number one
thing is we had this really cool we can
split the app into pretty deep
hierarchies well turns out number of a
feedback is like it takes so and it's
coupled with dependency injection
whatever you want to add like a new
service or something for that your
component to use like let's say you need
I don't know you you need a calendar
service like down to like add your
calendar thing you have to add it
through the whole tree and it takes a
lot of manual work and it's just
annoying
so that's number one thing is it takes a
long time so add or remove these
dependencies partially it's intentional
like don't just add random stuff but
we're thinking of maybe adding some
tooling for that developers is saying
we're generating a lot of boilerplate
code like even with like we don't have
to have a view or a presenter but it's
still a lot of code and it's the code is
memory footprint code is unnecessary to
read so we're thinking how can we get
even more lightweight like can we make
it a bit more configurable for some
cases you know you build something
really complex you need a lot of boil
page you're gonna use every bit of it
but for a lot of times like we have
classes are almost empty and then like
from app from iOS iOS has a scene called
view controllers which is like this
heavyweight views and we don't support
the lightweight views and exists goes
back to our own things to be more
lightweight and anywhere we care about
the app download size because we see it
affects how many people add it so again
it goes back to just allowing things to
be simpler so the main feedback is it's
good but it could be more lightweight so
we're working on that for for a next
version so is a is is it an artist or
like ribs for you and I'm you know if
and I would say like does your does he
if you have an app or even a similar
approach if a client-side application
has lots of non visual state you should
think of you know either doing some like
ribs or thinking about does your teacher
work well if you have a fast-growing
team or an app again you you want to
invest more in architecture our texture
does not matter for small or it matters
so much as for small teams it matters to
big teams and especially if you know
you're going to grow for sure you might
want to invest early and
finally do you have the bandwidth like I
I'm not gonna pretend this is this is a
simple architecture buy it by bringing
this architecture instead of using some
existing thing we need to do onboarding
it still takes a bunch of time people
you know don't understand necessarily
they they will make mistakes with it
they don't know it's a lot of extra
extra extra bandwidth on the team that
built it they get a lot of questions on
the developers so we're asking a lot for
people to is it worth it like if you're
doing something that's you know similar
to what your competitors are doing it
might not be maybe talk to them ask what
they're doing and yeah and so wrapping
up with that so in this talk we just
went through like our motivation why we
why we had to rewrite our app and that
was a pretty cool opportunity just as
closing I think uber got lucky in that
sense we're a big company that that grew
and we had an excuse to rewrite her out
I've I some companies that have similar
challenges include Facebook maybe
Twitter some of them they I don't think
they had this opportunity so from from
from talking and and and this this is
really interesting because when you have
this you look at things very differently
we had an opportunity to look through a
different lens and have the excuse for a
couple of months to just rewrite and I
talked about architecture how we looked
at their architecture why why we were
looking for something specific something
that supports these kind of non visual
states something that supports nice
state management and how we came up with
ribs which supports all of this and then
finally what we learned by taking this
architecture having a hundred engineers
200 and having them use it and you know
do do tooling do cogeneration do linting
and do documentation think about
tutorials and make sure someone owns
that thing to make it a success so wrap
up with that thanks very much for your
attention you can you can check out this
architecture and again even if you're
not a mobile developer you might get
some ideas on how to approach our
texture how to drive change how to how
to decide when is the right thing to
select the things to a new lens you know
you are all working in different
businesses some sometimes you get into
this point when you're building
something very different that's out
there a lot of times I used to assume
everything is already done you know why
should we we am on the wheel and
sometimes it's not about gremlins in the
wheel but just solving your problem in a
in a way when you take a different trade
off so with that thanks very much for
your attention I hope this was useful
now I'll be sticking around for
questions hi can you tell something
about the flow and management of
information between the Ferrari sign and
the product management and development
groups how do you coordinate that so was
the question between product management
and offense if the product team decides
that we have to need these new features
yep science you need to come up with
some suggestions and development teams
know how to go in it between each
other's yep yeah so yeah we're because
uber is growing we a lot of things we do
goes back to this idea of sharing
information pretty freely and having
this these kind of proposals shared so
what we do is our product team they
typically work with engineer saying hey
we need to do this this business request
let's say we need to support and own
this new Chinese payment type workers or
something they they might talk with
their development team initially they
particular a plan proposal saying here's
what we're gonna do here's a high level
they work with this developers designers
and maybe data scientists particular
plan and then we circulated to the whole
company saying Kira's over applying to
do developers also see that and then
once people are great like yep that's
the right thing to do
developers often come in and say like
well that's the avatar are we are we
think of the SDK have we talked about
this vendor they're using that etc and
once we have a sign-off then it goes to
developers and developers particular
architectural plan like how are we going
you know we do have a brainstorming
session we write stuff on the wall and
then we send our own document again we
might get feedback but if analyzed in a
really fast-paced project that is
tooling you know on knows about this you
know you saw with a product team they
stand out a paper people don't care
people don't know your team goes on they
stand here so we're gonna do people
don't know you just do it really quickly
if
something where everyone is opinionated
about for example Kotlin we had this
idea which is not a product one but
someone said let's do Kaplan and it went
down and so many people jumped on it so
many people had as some people worked at
Facebook some people were on the
Coughlin team before and it became this
like really long argument it turns out
like it would have been really risky to
do it so rush of the answer is it's a
mix of spreading information we don't
necessary drive to consensus the product
manager can make a decision to move
forward people can voice very publicly
saying I think this is a terrible idea
and we have had that it's pretty funny
sometimes in these documents you see
directors comment saying like I think
that's a terrible idea we should stop
this right now and we should have a
meeting and you're like and then someone
says like alright let's have a
discussion and you see like as an update
of discussion we're still agreeing to
proceed so so yeah that's it it works
you know it works pretty well sometimes
you still make decisions which in hinds
a person still has a lot of influence
and the team still has a lot of vision
which i think is good you know if you
think of from from having sign off the
ever has the information and not
everyone might agree so it's we have an
opportunity for a disagreement and we
don't usually address that that answers
alright alright with that I suggest we
wrap it up I'll be around if you'd like
to have some questions thanks very much
for your time enjoy the rest of the day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>