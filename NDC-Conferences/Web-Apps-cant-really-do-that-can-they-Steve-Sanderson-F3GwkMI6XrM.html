<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Web Apps can’t really do *that*, can they? - Steve Sanderson | Coder Coacher - Coaching Coders</title><meta content="Web Apps can’t really do *that*, can they? - Steve Sanderson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Web Apps can’t really do *that*, can they? - Steve Sanderson</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/F3GwkMI6XrM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's get started then all right it is
wonderful to see you all here today it's
delightful to look out and see your
shiny happy smiley faces I'm sure we're
gonna have a lot of fun I hope so anyway
it should be interesting to many of you
I hope so my name is Steve and I work at
Microsoft I am on the asp net team and i
do a fair amount of work for back-end
server side code but I also tend to
focus probably even more than that on
client side stuff and I expect quite a
lot of you deal with client side stuff
as well
hands up if you write any code that runs
inside a browser like JavaScript
typescript that sort of thing
yeah almost everybody all right so if
you are like me then when you are
writing those kinds of applications that
run on the client you probably spend a
bit of time thinking about what is it
that's actually possible to do with a
web application anyway what are the
boundaries of that possibility and how
is this changing over time what is going
to be different a few years from now
what will I be able to do then that I
can't possibly do now well I think about
that quite a bit and I'm very interested
in how the the browser's are changing
what IP eyes are available on what
features we can use as web developers
and if you want to know about what's
going to happen in the near future one
really good way of doing that is to go
and ask the people who make the browsers
and in fact they're so kind that they've
all set up their own websites that tell
us what new features are coming to the
browsers in the coming years
so each browser maker has a platform
status web page this is the one that
Mozilla has put up to tell us about
Firefox and that's got a very big long
list of all the features that they're
working on and what state they're in
whether they've shipped and whether
other web browsers have shipped them
that sort of thing if not only Mozilla
also Google have given as this one for
Chrome chrome status com
this is quite nice because it tells you
for each feature which actual version of
chrome the feature is going to go live
into it also gives you details about the
level of consensus that's been
established with other browser makers so
you'll get a good idea of whether or not
a given feature isn't really something
you can rely on across all browsers and
not surprisingly there's also the same
thing for the edge platform which tells
us so
fascinating and exciting things as
there's going to soon be an ambient
light sensor API which means your web
browser your web application will be
able to tell whether the user is in a
light room or a dark room which is
brilliant right that's just what you
need to do I don't know what you'll do
with that maybe you'll have a sort of an
automatic night mode that comes on on
your web page or something I don't know
but it sounds a lot of fun to me okay
so where do all of these specifications
really come from what's the underlying
source of truth who's really driving
this process of what goes into the
browsers well if you want more
information about that go to the
underlying source which is the w3.org
standards list there that is a massive
massive list of many many web standards
that are being worked on things that
have been proposed things that have
actually shipped by now I think there's
about 900 items in that list it's very
detailed and for each item you can find
lots of information such as you can find
links to the official specifications you
can find links to the mailing lists
discussions and if you're really into
this sort of thing you can even go and
start arguing with people on the mailing
lists about what these features should
actually be and what they should do but
like I said there's a lot of them
there's about 900 items on that list and
you probably can't be bothered to read
through all of them wouldn't it be nice
if someone else did all that work for
you well that's what this talk is about
so I've been through that list of 900
items and I've picked out four things
that I think are particularly
interesting to talk about four things
that might change the way that you build
your web applications or at least give
you indications about how a web
application might feel different a few
years from now so that's what we're
going to do in this talk we're gonna
walk through four different major new
features that are coming in to web
browsers that you as web developers can
make yourself to build different kinds
of applications now the first two things
on this list are quite big important
deep feature areas that I'm going to go
into a lot of technical detail about
when I demonstrate them to you you might
have heard of them but hopefully I'll
still be able to show you something new
finally the three and four items on the
list they're much more small niche
features that you might not have heard
of but they also provide a sense of how
web differ how web applications are
likely to change in the coming years so
let's get started with
we'll start with item 1 on the list
which I think a good proportion of you
will probably have heard of but might
not be using that and that is service
workers how many people are using
service workers in your current web
applications hands up 1 2 - ok - so very
very few people are using these yet and
I'm not surprised about that because
although this concept has been around
for a couple of years people have been
talking about in arguing about the specs
and so on you've not really been able to
use it until roughly now because it's
not been supported in browsers but it is
supported in browsers roughly as of
about now and we'll talk about that
later on
but what is service workers and what do
they give us how do they change what
kind of web applications we can build
well they change one very important
limitation of what scripts on a in a web
application can do right from the very
beginning of the web it's only been
possible until now for your code to run
when the user is actually on your web
page because your web page is the thing
that delivers the JavaScript to your
user in the first place and as soon as
the user navigates away from your page
the browser will stop you running your
code or at least that's the way it's
always been until service workers
service workers are different because
they allow you to register some
JavaScript with the browser that exists
outside the context of a given web page
so it's not limited to the lifetime of
your page the browser can keep running
your code whenever it wants to even when
the user is not on your site at all and
that allows for some interesting new
types of feature the most well-known of
these features that this supports is
offline the ability to use your web
application even when the user isn't got
any network connection at all but also
some other features that I mentioned a
little bit to do with receiving push
notifications and so on but in order to
understand this best I think we should
probably have a look at a little demo so
I'm gonna build a small web application
with you now and we'll put in some
Service Worker magic so you can get a
sense of what that's like and how that
works now the web application I want to
build it's going to be this now I've set
it up as a news feed that looks a little
bit like Twitter or something like that
but it's not specific to social media
you could imagine that this is a feed of
any sort of information at all that
might be relevant to your business maybe
a list of deliveries that drivers need
to make or so
else like that some set of information
that changes over time and the code that
I've got in this application right now
is incredibly simple because in fact
it's just a bit of static HTML it is
this file here index.html there's not
even any server-side code it's just got
this hard-coded static content plus it
references this page jeaious file and
what does that do almost nothing all it
does is it waits until the page is
loaded and then it does nothing and what
we're going to do is we're going to put
in some code to register a serviceworker
and then we'll do some stuff with that
serviceworker now the way to register a
serviceworker looks a little bit like
this so what I'm doing here is I'm
saying okay browser I want to use your
serviceworker api's to register a
serviceworker in this javascript file
here now a serviceworker is a JavaScript
file that is how you deliver the
serviceworker to the browser and I'll
show you that in a second this stuff
down here at the bottom that's
technically optional I could have just
deleted that and it would work the same
but I just want to display a message to
say whether or not the registration
succeeded or failed so I'll save that
you are probably wondering what's in
this file serviceworker dot yes so let
me show you inside there we have got a
little starting point okay let's just
tidy that up a bit okay so firstly
what's this first line self dot import
scripts this is a way of loading one
javascript file into another this is a
new api and it's specific to service
workers normally if you want to load a
javascript file with a regular web
application you do so with a script tag
as you all well know but you cannot do
that with a serviceworker because there
aren't any script tags there aren't any
tags at all there isn't even a page the
serviceworker is not inside a web page
therefore obviously you can't use a
script tag so there has to be a separate
API for referencing other JavaScript
files and that's that and then we are
listening for an event called install
now the only thing that a serviceworker
can do is listen for events it's
entirely up to the browser to choose
when it wants to run your code and so
you have event listeners for different
things that can happen and in this case
I'm just logging a message and then this
very strange and confusing line of code
there what that is doing is it's saying
well there's various ways that you can
programmatically control when your
serviceworker is installed and in this
case I just want it to be in
all right now without waiting for
anything else but otherwise just ignore
that it's not very interesting okay so
let's see if this works and it registers
the service worker I'm gonna open the
console and I'll reload and we should
see that indeed the page gets the
message to say yes the service worker
was registered and then the service
worker install event also fires now that
install event only fires once for any
given version of your service worker so
if I reload it shouldn't install the
same thing again I'm just gonna get the
service worker registered but no
additional install events now and in
fact it's not until I change the code
that I've got here that it's going to
install a new version so now I've
changed that when I reload the browser
we'll see that the code is different so
now it's gonna run the install process
again so that's how we can update the
service worker okay but what can we do
that's actually useful with them well we
can listen for other service worker
events and there are a few different
ones but one we'll start with which is
the most easy one is this fetch event
okay now the fetch event is fired
whenever your application tries to make
an HTTP request to your domain and you
can use that to programmatically control
how you interact with the network so
here I'm just logging a message and
doing nothing else really yet let's see
if that works
so I'll reload and it will first install
the updated version of my serviceworker
with that fetch listener in it and then
when I reload again you'll see that my
fetch listener fires for every single
HTTP request to the server and we can
use that to change what happens in terms
of network access for example I could
say all right I'm going to change the
responses I'm gonna say for every
request which is for a PNG file instead
of fetching it from the network I'm
gonna fetch this other file instead and
respond as if that's what the server had
returned so now when I come back and I
hit reload it will first install my
updated Service Worker
then when I reload again you'll see that
all of those images gets replaced by
this silly face type thing which is
great now why would you want to do that
obviously this is a really effective
technique if your goal is to do pranks
on your co-workers but that is not the
only bit of functionality that is
possible using service workers we can
use this technique
you enable offline access which I will
now demonstrate you I'm gonna go through
three different ways that we could do
offline support ranging from they're
very simple and not very clever to much
more sophisticated so let's get started
with the most basic way that we could
enable offline support in our
application and that is to simply
precache every single resource that your
browser might need to fetch from the
server so what I'm going to do is I'm
going to delete this install event that
I've got there and I'm going to add a
slightly different one and what that's
going to do is it's going to have a
hard-coded list of all the different
resources on our domain that the browser
might want to fetch and I want to
proactively cache them all up front so
I'm going to use this new API to say
okay I want to delete any cache that's
already got this name my cache and then
I want to create a new cache an empty
one with that name and then I want to
fetch all of those resources from those
URLs and I want to store all of the
responses in this cache and then finally
we'll say that this serviceworker is
ready to be counted as installed and
then instead of this messing around with
PNG files think I'll have some slightly
different logic that says okay let's
just assume that every single thing we
try to fetch is already in the cache so
we can match the request against the
cache and respond as if that's what the
server sent to us so we no longer need
to rely on there being an internet
connection because we will just serve
everything from the cache let's see if
it works shall we I'm going to come back
and I'm going to reload firstly to
install my updated serviceworker and
then when I reload again it will now be
serving everything directly out of that
cache that were set up when we installed
and to prove that is if I go over here
onto the network tab you will see that
all of these requests are being served
not from the network but from the
service workers own cache and I don't
even need there to be an internet at all
anymore to show you that I'm going to go
into offline mode and that is going to
prevent the browser from making any
network requests at all not even to
localhost so if I go to any web page
right now I'm going to get the site
can't be reached there is no internet
connection and if I try to go to
localhost instead of getting that
message my Service Worker event fetches
will fire and it will just return the
content directly from the cache
without even needing there to be an
internet connection so my page is still
going to show up even though I'm offline
and I'm preventing network access right
now okay so that's good basic offline
support but that's very basic and naive
and doesn't really cover all the
scenarios that you will want to deal
with for example what happens if the
content on the web server actually
changes so let's say that there's a new
news item this has meant to be a new
site right so let's have a new item
let's give it some class it doesn't
matter what it is and we'll say breaking
something happened okay very good right
save that I'll come back and I'll hit
reload now am I going to see that
breaking news item well no I'm not
because firstly I'm offline so obviously
I can't talk to the server to see yeah
but even if I'm online I still will not
see the updated content from the server
because the application is hard-coded
to just serve everything from the cache
it's not even making any connection to
the server it's got no way of knowing
that there even is new content on the
server right now so I want to make my
logic a little bit more refined what I'm
going to do is I'm going to say okay if
we do have network access then we'll use
it and we'll only use the cache if we're
offline so here's a simple
implementation of that I'm gonna say
right firstly we're going to try to make
a neck request to the real network and
if that succeeds then we're going to use
that as the response but if that fails
for any reason then we'll fall back on
serving stuff from the cache so now come
back and I'll reload first time it
updates the serviceworker then when I
reload a second time you'll see it
actually does fetch stuff from the
network because I am online but if I was
to be offline it will still work because
now it's falling back on the cache okay
so that's an improvement but it's still
not a particularly amazingly clever
solution because still bad things could
happen what happens for example if the
user does have a network connection so
they're technically online but it's just
unbelievably slow so it's gonna take
hours potentially to return the content
it's just not even practical at all
well let's find out right now I'm gonna
simulate that by pretending that I've
got typical play in Wi-Fi speeds there
and I'm going to see how long my page
takes to load so I'll go to about blank
and then I'm going to try and load the
page now the initial HD
mal comes up pretty quickly but we're
still waiting for those images still
waiting and they're starting to appear
now but this is taking too long
and finally it's done all right so it
worked but it was very very slow and I
users don't want to wait for that long
so we could refine our logic a little
bit more than that so what we'll do now
is we'll say again we'll try to fetch
stuff from the network but we're only
willing to wait for a certain amount of
time if it takes too long then we're
going to get stuff from the cache so we
try to make a request to the network if
that succeeds then we'll use that
response from the network but we're only
willing to wait 200 milliseconds that's
1/5 of a second because anything longer
than that is just too long and we don't
have the patience for that sort of thing
so if it times out they were going to
serve the content from the cache ok
but as well as that well also even if we
serve the content from the cache will
wait until the original network request
completes which might take ages but when
it does eventually complete then we'll
use that to programmatically update our
local cached content so the user will
eventually get updates even if they've
got a very slow network connection so
let's just uh throttle this for a minute
so that I can get the updated
serviceworker into the browser which
i've done now and then i'm going to turn
the throttling back on to the same thing
that it was before and now I'm going to
change the contents on the server so
we'll have breaking - something else
happened ok now when I come back and I
reload am I going to see the new
breaking 2 story well I should not do
because it's going to take too long to
fetch it so when I hit reload the page
comes up almost immediately after 200
milliseconds it's being served from the
cache so the user is not waiting but in
the background we're updating all the
cached data so if the user reloads a
second time then they will see the
breaking to new story so they get the
benefits of immediate page loads while
they also get a new content eventually
right so what's the point of me showing
you all that it's not particularly that
I'm saying that this is the one true way
to do offline access or anything like
that
the point is I'm saying that service
workers are very powerful and they give
you the ability to exercise whatever
kind of control you want over how your
page interacts with the network so you
can set up what
sort of trade-offs you won about whether
the network access is mandatory or
optional and when the timeouts are and
how are you going to deal with cash
content all that sort of stuff is
entirely up to you with service workers
but they're also other Service Worker
features as well that deal with that
relate to having your code running
outside the contents a context of a page
for example you can send push
notifications from your back-end to
somebody's browser and that's going to
fire an event inside the Service Worker
even if the user is not on the webpage
at that time similarly if the user does
edits while they're offline you can use
service workers to synchronize those
back to the server later when they are
online even if an hour on your page and
in the future it should be possible to
do schedule tests as well but none of
the browser's have actually implemented
that yet okay so that's service workers
as for browser support well it's pretty
good news on that because Firefox and
Chrome I've already got that shipped
live in production it's also fully
implemented in edge but it's behind a
flag that the user has to turn on at the
moment but hopefully that will be on by
default soon and finally really good
news from the world of safari until a
couple of months ago they had not
confirmed that they were doing this but
they have in the last couple of months
said yes we are actually working on this
so that is going to be a universal
feature pretty soon okay so that is
service workers let's move on to item 2
on our list
now item 2 is another very major feature
which I think you'll have heard of but
hopefully I'll get to show you some cool
new stuff that you might not have seen
and that feature is web assembly so what
is web assembly well it's quite a major
change to the way that we can write code
inside a browser up until now we've
always been implementing code in
JavaScript which is a human readable
text format which in various ways is not
super efficient so web assembly is a new
low-level form of code that you can
deliver to a browser so it's a binary
format for what you can think of is a
particular subset of JavaScript a
particular subset of features that are
very very fast for the browser to get
compiled to native code very fast for it
to execute very fast for it to verify a
safe and because that's still not fast
enough it's a binary format for
representing all that so it's extremely
compact on the network as
now it's not expected that you will
write this by hand yourself the idea is
that you compile to webassembly
from another language and the easiest
language you can use to compile to it
right now is C or C++ so I would like to
show that to you okay so I've got a
little bit of C code that I want to
compile to web assembly and run inside a
browser and here is my C code Fibonacci
Darcy now the mathematicians among you
will probably know what Fibonacci series
is it's just a sequence of numbers that
are defined in a particular mathematical
way now what those numbers are is not
important at all for us in this talk so
let's just think of it as an example of
an arbitrary algorithm that could be
implemented in C and the implementation
that I've got looks like this this
little block of code down here is just
reading parameters from the command line
and then it calls this function print
Fibonacci and then print Fibonacci goes
through the process of calculating all
the values and then just logs them all
to the console normally if you want to
run C code you compile it to make a
native executable using a C compiler
such as the GNU C compiler and here I'm
saying okay I want to compile Fibonacci
C and I want to execute a native binary
called Fibonacci
so we'll run that and very quickly we've
got the binary we can run it and then we
can say give me the first 10 terms and
it will print them out to the console
okay pretty straightforward but can we
compile that to web assembly and the
answer is of course yes we can and quite
easily but we don't use GCC I'm instead
going to use EMCC MCC is the Emscripten
C compiler and that is going to take in
this C source code and it's going to
output web assembly in this particular
case it can also AB output Assam Jas
which is a particular type of JavaScript
but I want a web assembly binary so
that's what that flag does and it's
going to wrap it all in a JS file called
Fibonacci ojs so I will run that and
when that runs is going to produce the
following output it's going to produce
these two files here Fibonacci jeaious
and Fibonacci don't Watson the wasum
file the web assembly file is the actual
binary so that's the very compact binary
format for this code
you might be thinking hang on 48
kilobytes does not seem very compact to
me because you only had 20 lines of
source code why is that now a 48
kilobyte file well the answer to that is
it's not just our application code
that's in there
there's an entire C runtime in there as
well and that's what's taking up 99% of
that 48 kilobytes so you could build a
much larger application of this and it
wouldn't necessarily get too much bigger
than that 50 kilobytes size we've also
got this Fibonacci J s which is a little
wrapper around that and that deals we've
been able to bootstrap that code and
make calls into it from JavaScript and
get calls back out and all that sort of
stuff and that gets generated for us so
if we want to run this we're going to
need to embed it into a web page and
that's what I've got here I've got an
HTML file and all that contains at the
moment is this script tag that's going
to load Fibonacci yes and it's also
going to set up some arguments that are
passed into it which is equivalent to
command line of parameters so let us
start that running and we'll see if it
actually works
we've earned that in my browser and we
will look in the console and we will see
that indeed it actually does run that C
code but now in the form of web assembly
and it's printing out the Fibonacci
sequence but how does that work anyway
it's quite hard to make sense of it if
you're just looking at these files on
disk we've got this wasum file here but
like I said that's a binary file format
it's not really human readable but we
can produce a human readable version of
it sort of by produce it by passing this
debug flag - gee and when that runs we
will see that we now have this West file
web assembly text file and that gives us
a kind of human readable version of the
contents although I admit it does depend
on what kind of human you are whether
you can read this it's not easy to make
sense of it's quite low-level it does
look like assembly code but like I said
it's effectively a kind of subset of
JavaScript and if you look carefully in
there print for Bonacci you can even see
your own code and you can see things
like which line numbers different bits
of the code correspond to ok so we can
compile some C code to web assembly
which is nice and there is also work
going on on being able to compile other
languages to web assembly for example
it's possible to compile Swift or rust
or
go to webassembly kind of it's a bit of
a hard process at the moment but
theoretically anything that uses the
clang tool chain which Bruce LLVM byte
code can be compiled to webassembly
so that's really nice and if you think
about it theoretically it would even be
possible to do something like take a
dotnet runtime and compile that to web
assembly and if you could do that then
you would have a full dotnet environment
inside the browser which means you could
load an X cubed on assemblies which
sounds like it would be pretty awesome
maybe you think that sounds a bit
implausible maybe that you know ten
years from now maybe we may not be able
to do that but probably not today right
well how about we have a go shall we see
if we can compile an actual working
dotnet runtime into web assembly so that
we can run dotnet code inside a browser
so in order to do that I want to show
you something I want to show you
something called DNA what is that anyway
well I've got this directory here full
of C source code quite a lot of C source
code deals with things like JIT and heap
and generics and all this sort of stuff
what's all that then well this is a
dotnet runtime it's not the regular
dotnet runtime it's not dotnet core or
the full dotnet framework in fact it's a
third-party implementation of dotnet
called dotnet anywhere or DNA for short
now this is not very widely used very
few people have even heard of the fact
that this exists but it does exist and
it actually works it genuinely can load
and execute regular dotnet assemblies
and the performance is quite decent and
it's got almost all the sort of
functionality that you would want to run
regular dotnet code it's not designed to
be compiled to webassembly by any means
at all in fact DNA predates web assembly
by several years so certainly that's not
what it's been designed for but because
it's just written with fairly basic C
code it doesn't take very much to get it
to compile through the M script and C
compiler so that's what I did and when I
did run that here's what I got out of it
I've got these two files DNA a s and DNA
dot wasum and that web assembly file
there which is quite a bit bigger than
the one we had before contains a fully
working dotnet runtime and that can deal
with all the stuff
need for example being able to load and
pause danette assemblies it deals with
all the JIT compilation it deals with
memory management garbage collection all
that sort of stuff is in there and then
we've also got this wrapper around it
that knows how to interrupt with a
regular JavaScript code so let's have a
go at running that then shall we I want
to run that again inside a web page so
I've got another HTML file here this one
is going to load the DNA JS file and we
probably need to pass some arguments to
it but I haven't figured that out yeah
let's just run it first and see what
happens so let's start up a web server
in that directory and then I will be
able to go to this application on port
8080 and see what comes up and we will
see that it is in fact working look it's
trying to run the DNA runtime and DNA is
saying ok please tell me which dotnet
executable you want me to execute sounds
pretty promising okay so we need a
dotnet executable to feed into it and
that's okay because I've got one right
here
I've got everyone's good old friend
console app one that we know and love
okay console app one as you all know
does the very wonderful thing of
printing out hello world to the console
and we can build that using vs or
command line so I build it and that will
produce a net binary a DLL and if we
have a look on disk for that we'll see
that it's in whereas a bin-debug net
core app blah blah blah and here it is
console app 1 dot DLL is 5 magnificent
kilobytes of compiled dotnet code and I
want to feed that into DNA so I'm going
to go to its config here and I'm going
to say alright then what I want you to
do now DNA is I want you to load console
app 1 DLL to execute it now because this
is running inside a browser it can't
read files directly from my disk it can
only make requests to URLs so when it
wants to load console app 1 DLL I'm
configuring it to say ok you can get
console app 1 DLL from this URL here and
also you're going to need to be able to
load this Kolob DLL which is another
dotnet assembly which contains
implementations of all the low-level net
stuff like strings and lists and that's
all I think ok so given that we
configured this now come back over here
I'll hit reload one more time and indeed
it actually works we are now actually
running guard netcode inside the browser
and to prove that that really does work
and can run arbitrary c-sharp source
code I'm going to come back over here
and I'm going to drop in this time a
c-sharp implementation of Fibonacci
they're quite simple stuff and I'm gonna
say I want to print Fibonacci first 10
terms please I'll do shift f6 to reload
and then I'll come back and when I run
it again you'll see it does actually run
the c-sharp Fibonacci stuff okay so I
think that hopefully illustrates some of
the pretty awesome power of web assembly
we've been able to bring an entirely new
language and runtime in the back into
the browser with very little work and if
you're anything like me you probably
look at that and you think ah that is
interesting isn't it running dotnet
inside the browser wouldn't he be
interesting if there was some sort of
framework for being able to run
client-side dotnet applications because
then to write a web application I could
write all of my code in c-sharp both the
backend code and the front-end code I
could share code between them and I
wouldn't have to deal with JavaScript
and typescript and you know web pack and
NPM and all that stuff it would just be
darkness everywhere I wouldn't that be
cool so that's what I thought too and I
thought all right well let's have a go
let's see if we can make a little
experimental framework that runs dotnet
inside the clauser
inside the browser and and we'll see how
well that actually works so I want to
show that to you now and give you a
sense of what that could be like now I
will caution you that this is not a
shipping product this is just an
experiment no-one's promising that
anything like this will ever become real
but it's interesting at least and I want
to know what you think about it so I'm
going to create a new project now and
I'm gonna choose to build a blazer
application so what is blazer then ah
it's a rich client-side application with
C shop and razor running inside the
browser okay
well let's give that a name my NDC app
ok let's start that and so that's going
to create a new project for us and
hopefully it's going to restore all the
packages and get ready to run and
everything like that and I am going to
launch that in a browser before I show
you any code so when that comes up you
will hopefully see that this looks like
a fairly typical single page
application and here it comes round
about now okay so it's got the usual
kind of features that you'd have in a
single page application like I've got
navigation client-side navigation that
is I've got the ability to render
components that can be nested inside
each other I've got an example of a
component here that fetches some data
from an API back-end and renders it I've
also got an example of a component that
listens for clicks on buttons and just
counts the number of times that you have
clicked okay pretty straightforward
stuff but what's the code for this like
I mean we could obviously build this
sort of thing in a JavaScript framework
like angular or react or that sort of
thing but what have we got over here
well this is quite different because in
this application there is no JavaScript
whatsoever all we have got is c-sharp
we've got some CS HTML that's RAZR pages
and we've also got a little bit of HTML
and CSS that are used for layouts and
styling and as for the actual component
code themselves well let's have a look
at this counter component here and
you'll see that this arrays a page
raiser combines both HTML and C shop and
in this case I'm declaring a variable to
track the number of times that you've
clicked a button and then I've got a
method that increments that count I've
also got some HTML that displays the
current count property and then a button
that when you click it is going to
increment that count so pretty basic
stuff and it seems to kind of work
doesn't it but would this really work
could you genuinely build a non-trivial
application like this well I'll need to
try building something so that we can
find out now as you know as a very
important matter of professional ethics
I need to demonstrate to you an example
of a to-do list application so I'm gonna
do that right now I'm going to add a new
item here and that's going to be a razor
page so I'll call it to-do list dot CSS
HTML and I'm gonna put a little bit of
content in there to-do list okay now I
want some way of navigating to this at
the moment I've only got these three
links over here so I'm gonna go into the
component for the nav menu there and I'm
going to copy and paste this list item
here and I'm gonna have another one that
links to to-do lists and then I'm going
to not do that
I'm going to change the text on it to
display to-do list okay and then as soon
as I say hit save in my idea here we
will see the browser immediately updates
and we've got to-do list on the menu
there and I'll click on that and that's
now going to render the to-do list
component in the main part of the page
okay very good
let's add the actual to-do list
implementation here and I'm going to
start by putting in a bit of c-sharp
occurred because it's c-sharp I want to
model to-do items as classes so I'm
going to have a class called to-do item
and each to-do item is going to have a
couple of properties I'm gonna have a
string called
text and I'll also have a bulb property
called is done and I want to model a
list of those things so I'm gonna have a
list of to-do items called to-do items
and I'm gonna make that a new list okay
very good and what can I do with that
then well the first thing I want to do
is display the number of items in the
list so I'm gonna display to what is it
to do items dot count and I'll hit save
and we'll see that there are zero items
in that list initially like you'd expect
and I also want to actually display the
list contents so I'm gonna do a bit of
razor code here to say for each item in
to-do items I want to display the item
dot text value surprised I'm not getting
into sense there okay well okay at the
moment the the list is empty so before
we can do anything else I want to add a
button that adds items to that list so
let's have a button with add item on it
there and you can see that initially
clicking that button does absolutely
nothing because I have an associated any
behavior with it if I was writing some
very old-school JavaScript I could put
on click equals and then I could start
writing some JavaScript in there if I
wanted but because this is a client-side
razor I can put some c-sharp code in
there I can say okay let's get the to-do
items and we will add a new to-do item
and I'm going to set the text on the
item to whatever okay so I'll hit save
now and then when I click on this button
you will see it displays the item text
or
but for some strange reason it's
displaying item dot because I did not
put that important symbol in my source
code so let's try that again and there
we go now it's displaying the actual
property from my item okay very good
I don't really like the fact that I'm
embedding all this code in an HTM
attribute I think I would rather be
having c-sharp method so I'll have a C
shop method called add item and I'm
gonna take my code from there and I'm
gonna put it into that method and in
order to invoke that I'm gonna use a bit
of shorthand to say on click add item
that looks a little bit better and it
should still behave the same as before
right that's good but I don't want to
hard-code this string whatever that's
not very useful in practice I want the
user to be able to type in some text so
I'm gonna have a text box
I'll give it a placeholder type here
okay and I want some way of capturing
whatever the user types into that text
box now there's a few different ways
that I could do that but one simple way
is I'll have a string property called
next item text okay and I'm going to
bind the value of this text box to next
item text so we can see whatever the
user has typed in and then instead of
using the string whatever I'm going to
use next item text also when the user
presses the button I want the text box
to get cleared out so they can time the
next thing again and I'm gonna achieve
that by setting next item text back to
null or empty string all right let's see
if that works so now I should be able to
type in here and indeed it does actually
work it puts my text into the to-do item
there and it clears the box out
automatically so that's pretty good
what else do I want to do well two more
features I firstly would like to be able
to edit these things after I've typed
them in because I might have typed it
wrong and I also want to have a checkbox
for marking items as done or not and I
can do that by modifying my razor code
up here so let's have a input that is
bound to the item text value and I also
want a checkbox that is an input type
equals checkbox and I want to I want to
bind that to the item dot is done
property like that so now the user can
come along and they can type in some
items and they can mark them
done that's very good but you can't
really see anything happening when I
check these boxes nothing meaningfully
seems to change so to show you that
something is actually happening let's
say that instead of displaying the total
number of items in the list I want to
display the number of remaining
incomplete items I can do that with a
little bit of link code up here I can
say all right I want to display the
remaining count and that is going to be
the count over all the items where the
item is not done so I'll hit save on
that and now when I type stuff in here
I can check off these items and you'll
see that remaining count goes up and
down in the way that the user would
expect all right so that's pretty cool
we have written what is it roughly 30
lines of very simple c-sharp and we've
got a straightforward but functional
list editing application there and you
could go on building something much more
sophisticated than that if you want to
but I know some of you are probably
thinking well that looks kind of nice
but it's not really practical is it
because there's gonna be all kinds of
problems with that for example you can't
seriously ship an entire dotnet runtime
inside a webpage can you like an all the
standard libraries everything what's
that gonna be that's gonna be hundreds
of megabytes there's no way you can do
that so let's have a look let's see how
big this application actually is I'm
going to do a hard reload on the network
tab and you'll see that this whole
application there has currently come out
at 332 kilobytes and that is including
everything that's including the dotnet
runtime that's including the core
libraries that it's using is including
our application code it's even including
the bootstrap CSS that we're using for
the page layout so that's entirely
reasonable quite a plenty of other
single application frameworks will
produce applications that are bigger
than that and that's without even
shipping some kind of managed code
runtime in there so that is eminently
practical okay that's good but you know
I know that you may be also thinking
well that's all very well but you know
only the very latest web browsers
support web assembly you know I need to
support older web browsers that don't
support web assembly it's not going to
work on those is it well let's find out
shall we I'm going to open up Internet
Explorer 11 which very much does not
support web assembly in even
the most slight kind of way and I'm
going to paste in our application URL
there and we'll go to that and what
happens it works
the application just comes up and it has
all the same identical behaviors as we
had before so how on earth is that
possible how is a web assembly
application running inside a browser
that doesn't even support web assembly
and the answer to that is that basically
web assembly is a really cool technology
it's been designed so that it can fall
back easily on regular JavaScript so
when the own scriptum compiler produces
the web assembly version of the DNA
runtime we can also with a single
command compiler flag make it generate a
awesome.js version of the same thing
which behaves identically and that will
work on down level browsers now it's a
bit larger and it doesn't run quite as
fast but it does work it's certainly
fast enough just to display user
interfaces and it produces identical
behaviors so it's a it's better if your
user does have web assembly support but
it's still gonna work even if they don't
okay so that's pretty cool we've now
been able to build an application with
not now in there but we could go even
further and that a couple of months ago
I showed this demo to some of the people
on the asp net team and they got quite
excited about that trying to think about
ways that they could make it even better
and we had a little hackathon on the
team a few weeks ago where people
implemented a whole bunch of different
and interesting cool features for
example the ability to do interrupts
between dotnet code and JavaScript in a
really friendly way with entire suns and
everything that was great but another
thing which I think is the best thing
that was implemented is debugging
support now a few months ago I had no
idea if or how it would be possible to
make a debugger work with this sort of a
runtime but a couple of people on the s
Bennet team Stephan halter and David
Fowler who some of you may have heard of
got really into this and started being
determined that they were going to find
some way of getting decent bugger
support for that and they actually did
it so I want to show you that now you'll
be the first people to see this it is
pretty cool so I'm going to switch over
to a different blazer application here
it's very similar but this one has been
split into three projects we've got a
server-side part which is a regular
Espeon application we've got the
client-side part which is the Blazer
application and we've got a shared class
library which was just a way of
that we can share things like domain
classes in between birth server and
client and it all works as you'd expect
but that's not really what I want to
show you what I want to show you it is
this debugging thing so I'm gonna start
that running inside browser right now
and when that pops up you'll see it's
got quite a few other little tech demos
that people have put in just to prove
that different things work for example
the ability to invoke third-party
JavaScript libraries in a friendly
intellisense driven away from c-sharp
that's what that button is doing it's
calling the bootstrap modal dialogue
code ok that's nice but it's not really
what I want to show you what I'm gonna
do is add debugging support to this so I
am going to get another browser window
doing a little bit of rearrangement of
my browser windows here and I am going
to go to a special URL and when I do
that the chrome debugger shows up but
it's not just showing JavaScript code
now it is showing the JavaScript code
but it's also showing our dotnet code so
you can see we've got the dotnet dll's
listed down there and if we expand this
we can see all of the c-sharp source
code that's in them so we can explore
all of our dotnet implementation here in
the middle of the chrome debugger and
not just the CS files as but also the
razor pages as well for example here is
the page for the component that I'm
displaying right now the bootstrap
component and down here you can see the
event that fires that causes the modal
dialog to actually get shown and I can
even set a breakpoint on that and when I
hit this button now you will see that it
hits that breakpoint and we can then
start doing things like stepping through
all of the dotnet implementation so let
me just show you that one more time just
because I really love it so I've hit the
breakpoint and then I can hit go and the
modal dialog actually pops up so there
is a long way between what exists in
this little demo here and anything that
you could use to build a production
application but I would be very
interested to know if any of you would
really find that compelling so if you
want to actually try this out yourself
you can go to this repo on github there
and you can actually download a visual
studio extension that gives you the
project template and you can actually
start trying it out for yourself now if
you do that today you're going to get a
version that's about a month old and
doesn't have the debugging support but
hopefully over the next week or so
a merge two different repos that we've
got and add all the leg stuff into there
and debugging spot and everything like
that but once again no promises that
this is gonna be a real thing it sort of
depends on your feedback on what people
really want to do with them okay so that
is webassembly
as for actual browser support right now
pretty good news on that Chrome and
Firefox have already got it live and
shipped but it's also fully implemented
in edge and Safari as well in edge it's
currently hidden behind a flag that
users have to turn on in settings but
hopefully that'll be on by default quite
soon and as far as Safari is concerned
as far as I understand it depends on
what version of the operating system
you're on so I think if you are on iOS
11 or later or whatever the
corresponding version of Mac OS is then
you've got webOS herbally on there but
it's certainly fully implemented and
ready to go there so that's a great news
for everyone and wants to do webassembly
but even for older browsers like I said
we can fall back on awesome Jas and get
the same behavior right then that's
webassembly
let's move on to the last two topics now
like I said these are a little bit more
niche you might not have heard of them
before but they give you a good sense of
how web development might evolve over
the next couple of years and the first
one I want to show you
it's called credential management it
sounds unbelievably boring but it's
actually quite useful now since the
beginning of time as web developers
we've always had to deal with
credentials that is we've been
implementing login screens and user
registration and sign out and I forgot
my password and all that kind of boring
stuff that you have to do over and over
again and up until now browsers have
done almost nothing to help you with
that but credential management is a new
set of api's that allows the browser to
actually understand the concept of
credentials and do something useful for
you specifically it allows you to do
things like automatic sync automatically
synchronize login States across a user's
devices so that if they register on a
desktop with your application then as
soon as they open your site on their
mobile they're already logged in and
they don't have to do any steps at all
they're just sharing their account
across two devices automatically it also
allows the browser to do things like
display native UI for account pickers
and and other stuff that I won't really
have time to discuss in detail but
again I think the best way for you to
understand it is for you to see it
so I'm gonna switch over to our final
demo application right now and this
gives me an opportunity to show you a
little business idea that I've been
working on in my spare time I'm hoping
that I'm going to get extremely rich out
of this I think there's a lot of
potential in it and it's a new
software-as-a-service startup called CEO
portly now the idea with CEO portal is
that it's for company CEOs you know the
big powerful titans of industry who are
very very busy people and they've got
lots of important work to do and the
idea with this website is that they can
go to this one website and it gives them
the ability to do all the stuff that a
CEO needs to do in their normal line of
work so if I bring that up in a browser
you will see that we've got some pretty
good corporate web design going on there
I think CEOs are into that sort of thing
and it allows them to do all the stuff
that they need to do on a day to day
basis now as you probably know CEOs are
very very fussy about IT security stuff
they might not know what it is but they
know they want it and so we need to have
a very very robust and streamlined user
registration and login system and so
that's what I've got here and I've
implemented it using the credential
management API so let me show you what
the application is actually doing using
the debugger so when I first load this
page this is what code runs I'm using
the credential management API to say
write browser I want to use credential
management I want to know have we got
any credentials stored for this user
already and the browser is going to say
well here's what I've got for you
undefined
no we do not have any credentials stored
for this user yet and so my application
is gonna display this logged out kind of
stay that you can see right now and the
CEO is going to see this and they're
gonna think yes this is exactly what I
want I need to register myself with that
right now and then I'm gonna click on
the register button and they'll type in
a username and they'll pick a password
and they're going to click on the
register button and when they do that
we're going to run this code I'm gonna
first instantiate a new password
credential object there are various
different types of credentials that
exist within the credential management
world for example federated credentials
other things like that but the simplest
one is a password credential and that is
just a username and password and we can
populate one of those using data that's
been entered into an HTML form and
that's what I'm doing right there so
when I step over this line we'll see
we've now got a password credential
object and we can see we've got this
user named Steve and we've got this
password password one that I always use
for everything don't abuse that info
please and then we are going to store
that in the browser so I'm saying
browser please store this credential and
when I do that it's gonna pop up a
little dialog do you want me to save
your password for the site and the CEO
is gonna think don't know what that
means but that button is blue so I'm
gonna click that button and they will do
that and the browser has now stored that
credential for them okay and so now the
user has got a stored credential and
they're registered we can switch over to
a logged in view so now the application
is saying welcome Steve which of these
popular executive activities do you want
to perform today and the user can go
ahead and do whatever stuff they need to
do okay so that's pretty good but
there's more that we can do than that
for example what happens when the user
comes back later I'm gonna keep click on
this reload button and then this time
it's going to behave a little bit
differently when we go into this getting
saved credentials we'll see that instead
of undefined we now have the same
password credential object as we got
before because it's been stored so we
can automatically bring up the signed
interview without having to ask the user
to do anything and in fact every time I
reload you'll see that this little
message appears in the top corner
signing in as Steve okay because the
browser understands the concept of
credentials now and it can prompt the
user in whatever way makes sense for the
particular type of browser or device
that the user has got and also the user
can deal with things like having
multiple accounts so if I register a new
user right now I'm gonna have Bert and
I'll register that do you want to save
Bert yeah sure now when I go to signing
in you'll see that some native UI
appears this time this would provide if
I the browser and it allows the user to
pick which one of the safe credentials
they want to use so they could say okay
today I'm going to be Bert
then I can sign out and then today I'm
gonna be Steve and life continues as
before but they've got a fairly
straightforward way of dealing with
having multiple accounts okay let's
clear away Burt and we'll just have
Steve now all right so that is the
credential management system that is
available now or becoming available soon
if we think about the actual browser
support that's available right now it's
a bit early days I'm afraid to say so
like I've just shown you this is already
shipped in Chrome now
edge and Firefox they're a little bit
behind on this they have acknowledged
that it's a feature that they might be
interested in implementing but they have
not necessarily even started they've not
told as they have slightly better news
from the world of Safari they have at
least acknowledged that this is a
feature that they are actively building
support for so hopefully it won't be too
long until we see this become a real
thing okay so that is credential
management and like I said there are
some cool things that this allows you to
do that wouldn't have been possible
before
for example the browser can
automatically synchronize the knows
credential objects among all the devices
that is owned by a given user
now as for how that actually works how
it knows which user has the same devices
and deals with actually transferring the
data that's not our problem okay as long
as we're not the people who imprint in
the browsers we don't have to care about
that we can just benefit from the fact
that that does in fact work it does only
work within the devices from a single
vendor so for example if the users got
an Android phone it will synchronize
with Chrome on the desktop if they've
got if they're in the iOS world it'll be
synchronizing with Safari on the Mac
maybe at some point in the future we
might deal with some sort of cross
browser across a vendor synchronizing
thing but I don't think there's any
specific plan to make that work right
now okay that's credential management
finally let's get on to the fourth and
final thing that I want to show you
which is another very valuable feature
that I think you'll all benefit from and
that is payment requests the idea with
this is that since again the very
beginning of web development there's
been one thing that web developers have
desired above all else and that is to
get money from people who come to their
web pages obviously but up until now
it's been a really horrible experience
both
and for visitors because in order to get
money from someone you have to do awful
things like ask them to type in their
credit-card number manually and type in
their delivery addresses manually and
all that kind of stuff and it's awful
and you end up with these like 20 staged
checkout processes and 90% of users
don't even bother to complete the
process and then you don't get their
money which is a tragedy and I think you
deserve better than that
you deserve that money and that's what
payment requests is hopefully gonna make
happen compare this experience with what
happens in a native mobile app if you're
in a mobile app and it wants some money
out of you it does not ask you to type
in a credit card number it just says
please confirm that you want to send $4
to whatever and the user presses their
fingerprint on and the money is sent
that's as simple as the user experiences
wouldn't it be nice if your web
application could do it in just as
simple a way as that that's what payment
requests is supposed to do it gives you
the ability to have a similarly nice
user experience as a native mobile app
the actual way that the user confirms
the payment varies from one type of
device or browser to another for example
if they're on a mobile it probably would
ask them for a fingerprint on desktop it
might some use some other way to confirm
who they are but you don't have to ask
for them to type in the credit card
number it's gonna use the information
that the operating system already knows
about this user so let's see this
actually working then shall we okay this
brings me to how I want to monetize CEO
portal and how hopefully I'm gonna get
very rich from this so imagine the
scenario the CEO has registered they've
signed in they've started doing some
stuff and what would what kind of thing
two CEOs like to do well in my
experience the sort of thing that CEOs
are into is reviewing key financial
documents I don't know why but they love
that sort of thing
so they're probably going to click on
this button review key financials and
what are we gonna do we're gonna say AHA
that's a premium feature if you want to
see your shareholder value report you
can unlock it now for just 50 gems and
the CEO is following a thing yeah that's
a that's an excellent deal I definitely
want to see my shareholder value report
but hang on oh no I've got zero gems I'm
gonna have to get some more gems so
they'll click on the get more gems
button and that takes them into the gem
store okay so they're gonna think hmm
how many gems do I want to buy well
for whatever reason I don't know what it
is but somehow subconsciously my
attention is being drawn to this 50
million gems option it is the most
popular one after all so it's probably
rational that I would want to buy that
one okay so the CEO is obviously going
to click on the 50 million gems button
and when they do that we want their
money how are we actually going to get
the money out of them well let me show
you the code that we are going to run
okay so I've got this method down here
called buy gems and what's that going to
do well firstly it's going to start by
computing how much money we're going to
try and get from them this is an
important thing to understand about
payment requests it does not calculate
stuff for you it's not working out taxes
or delivery prices or anything like that
it's completely up to you to do all the
calculations that you want so here I've
got this particular shipping amount I'm
adding on a mandatory 20% tip which I
think is fair and I'm hoping that that's
going to catch on in e-commerce
generally and then we're going to work
out the total price that we're going to
take from the user and then we
instantiate a new payment request object
and that allows us to configure a few
different options for example we can
configure which payment methods that
we're willing to accept in this case I'm
only accepting credit card payments but
you could also accept things like
Android pay or Apple pay or whatever
else you think a given device mind
support and configure that in various
ways we also set up which line items are
going to appear on this order so we've
got the number of gems shipping blah
blah blah blah blah and then finally
we're going to say we want the user to
give us shipping details so we know
where we want to deliver this to which
might not make sense in this case but
obviously in other cases it might make
sense
and finally we tell the browser that we
want it to show that payment request the
way that the user interface actually
looks depends on the browser and the
device that's not up to you as the
developer that's up to the device but
you don't need to think I'll care about
that all you need to care about is that
at some point in the future you're going
to get a call back and it might be a
success with all the payment information
or it might be a failure
maybe because thing is a cancelled or
something like that okay so let's do
this now I'm going to click on the big
flashing button and it's going to run
that code and it's going to hopefully
show a payment request so I'll click
that now and this is what is going to
appear this is some user interface that
in this case is supplied by Chrome and
it's going to display the order summary
we can see what we're actually buying on
what we're paying for we can see
shipping address where the user can pick
from their existing saved shipping
addresses or into a new one if they want
to
we can choose a shipping method such as
in this case online delivery as if
there's any other way to get virtual
gems and then finally the user can
choose their payment method or enter a
new credit card that sort of thing
and when they've eventually done all
that stuff they are as always going to
click on the blue button because it's
the brightest one and then we're gonna
ask for confirmation the way that
confirmation works again like I keep
saying it's going to depend on what type
of device it is in this case Chrome is
going to ask me for the cv2 number CVC
number to confirm that and when I do
confirm it the browser is going to
return all the payment information to
you it is not actually making a
transaction for you it does not contact
a bank in some way it does not somehow
get money into your account
automatically all it does is it supplies
the payment information that you can
then pass through to whatever payment
provider you already use we've got the
billing address we've got the shipping
details we've got the credit card number
and all that sort of stuff and hopefully
you know how to use that to get some
money from the user okay all the
browser's may display things differently
this feature is already available in
edge right now as well as Chrome I've
just shown it to you in chrome it's also
already available to the public in edge
but it the user interface looks
different it brings up Microsoft Wallet
in that particular case it's coming soon
to Firefox we don't know how they're
going to make this look or what they're
going to do for confirmation but
hopefully I'll be there soon not quite
such great news from Safari this time
they have at least acknowledged that the
feature exists until a couple months ago
they were just complete silence on this
they didn't even acknowledge that there
was a thing called payment requests but
now they have acknowledged it and
they've said they're considering it so
you know hopefully they're going to put
that into their browser pretty soon and
then it'll be another thing that you can
use of course they're always gonna with
people that use older browsers and you
don't want to necessarily give up on
their money so you're probably still
going to have to implement a traditional
checkout flow with manual entering
credit card numbers and stuff like that
but the users who do have browser
support for this will probably have a
higher conversion rate because you know
the user just has to click a button
they're getting
me too you there's going to be fewer
opportunities for them to get that wrong
right then so that is as much as I've
got time to show you we've gone through
four of the major new features that are
coming out and making available to web
developers in the immediate future many
of which were already available in
browsers right now so let's finish off
by imagining what your next mobile or
desktop web application might look like
and what it might do well you could use
service workers to make your application
load immediately even if the users
offline or even if they've got a very
slow network connection you could also
use service workers to deal with
receiving push notifications from your
back-end server and doing stuff even if
the users not on the page and similarly
if they did something while they were
offline then when the network connection
comes back up later even if they've
navigated away you can still do stuff to
synchronize it back to your server
that's all Service Worker features you
could also use webassembly
in order to bring your own choice of
language and runtime into the browser so
that you can implement your application
with whatever technology you choose you
could also use the credential management
API Stu ensure that your users are
always logged in across all their
devices without having to manually
remember their passwords and type them
in on tiny little mobile phone screens
and finally you could use the payment
request system to get money out of users
with a very simple justice such as
fingerprint confirmation so I hope some
of that is of interest to you and has
given you some ideas of how you might
like to add some cool new stuff to your
next web application we don't have time
for anything else but I hope that was
fun to you please remember to evaluate
this session as you go out through the
door and otherwise just really enjoy the
rest of your conference thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>