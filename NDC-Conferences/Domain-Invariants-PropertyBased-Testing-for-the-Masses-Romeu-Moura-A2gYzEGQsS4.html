<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Domain Invariants &amp; Property-Based Testing for the Masses - Romeu Moura | Coder Coacher - Coaching Coders</title><meta content="Domain Invariants &amp; Property-Based Testing for the Masses - Romeu Moura - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Domain Invariants &amp; Property-Based Testing for the Masses - Romeu Moura</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/A2gYzEGQsS4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we're here to talk about property by
testing okay the people on the back can
you read what is written here and read
this yes fine thank you
so what is a property who here doesn't
test today
who here raise your hand if today you do
tests in your code okay to everyone else
this will be a little bit awkward in the
beginning but do stay what is a property
what is the one is a property someone
had a predicate afraid all that's the
first time I have the answer a predicate
for that will be titles there is
something in the for the purpose of this
talk I'll use the very false definition
that a property is something that is
always true this is a lie but let's go
with the life for now okay when I might
say this people is risk okay so what is
an invariant and what is a tautology Oh
is something that is always true right
the other pens on context a tautology is
always always true there is no context
to it you you you descend towards the
downwards that's a tautology that's
always true if if you were not going
downwards you would not descending
that's by fired so this seems useless
now but I'll go back to this later into
the presentation so
the whole idea of property based testing
is testing things you think are always
true into your code okay so it's kind of
a bet property based testing is kind of
a bet it's like insurance you bet that
your apartment will be on fire this
month and the insurance company bets
that it won't and you happy to lose that
net okay property based testing is
exactly that
okay the whole idea behind it is that
you try to push something it will try to
describe in the formal way we will see
this together a little bit further in
code you try to you try to describe
something that you think is always true
in your code and the framework tries to
find a counterexample price to proves
you foes okay so hi everyone I'm Romeo
you can find me on Twitter multimers and
I also happen to organize a little
conference in Paris that you should come
to I'm this dude here this douchebag
here that you can find in Twitter so
most of you have ever done guys who have
ever done a cutter here you know what a
cutter is okay so everyone else a cutter
is a small really small exercise that
you do and doing read you again
so for it to become kind of a base
movement towards a larger movement built
upon it when you do the small thing so
there is a cutter here I will not go
into the solutions just to test for it
with the bowling cutter which I'm using
this presentation who here has ever done
the bowling cutter okay who he has ever
played bowling
most of you that's good that that will
be quicker so if I were to do the
bowling the bowling cat is just
calculating the score of a single person
playing bowling for a whole whole
playing of bowling and if I were to go
towards this isn't easy everybody see
what this dee dee dee dee dee dee
test-driven development okay I will
start with a test
so my first naive test would be well a
fluke
I played bowling and I had no points at
all and this score is zero which
incidentally is a scored I already have
me realize so you do the zero and if you
do in tdg what we will do at this point
is your solution will just be returned
zero right and you try to me iterate
over that and you go through okay I have
some points and the whole point of
playing bowling is that you have like 10
frames in a in a bowling play and each
each frame you try to throw your balls
and you have like at maximum two balls
in a frame and each time is right should
go make go down 10 pins
alright it will score is the number of
pink scarf or a frame is the number of
pins you went down so here we have a
frame I have two pins in another frame I
have one pin and a lot of frame I have
one pin and the score is the Sun above
that and you have special case if all
the pins go down I'll have a spare three
and seven all 10 pins window so my score
is the next ball should this frame so
three seven one and again for the next
frame one and zero okay and I have a
strike when all the balls went down
while the pins went out of a single ball
so the frame is finished because I can
have no pins left to go down and the
next two balls go into my score and you
have the perfect game where is it only
for only perfect throws and everything
always was a strike which incidentally
the score and never had and realize so
thing is you have that best coverage so
raise your hand if you're pressed to
they resemble this you liars I know
you're lying I know you're lying your
test today resemble this right be honest
with you your test today are way way
near this than they are to this okay we
will go back to this test later for for
the moment here less good just remains
in this paradise land here where we are
really primitive missed and now the eyes
can be very simple and I'll go back to
this a little bit later in the
presentation okay but I want you to be
able to do PBG with real tests so this
is the end goal all right so it's
remarkable here then we have this whole
situation of my test adjust input and
outputs these inputs give this output
this input if this output this input is
this output we only doing this from this
point on but in this kind of tests here
and and this is the same thing input
output input output who here has ever
done parameterization testing you know
it okay so everyone else
this is parameterized icing I just took
those tests here and say hey those tests
here the same really
we just think test in the nominal case
and actually those those jus Tice ears
are the same and those two tests treat
us here's are the same so I kinda have
only three tests really and I did not
want all them to be
sparsely oh all the name sucks that's
that that is a reason behind it
I only did awful names for my tests in
this whole presentation we'll go why
later and thing is I started to put them
together I said I can pass these inputs
here as parameters to a test when I when
I do this I could I could just pass as
parameters my my throwing my balls
thrown and my score right but if I do
that then easily I could put all my
tests in a single test and then it's not
very useful anymore I just would just
compress all the tests together and they
lose meaning I'm losing something when I
do that it's just putting everything
together in a single test so what I
usually do when I do parameter is
testing is that I only pass one thing in
parameters 8 are 1 of the inputs of me I
leave I leave at least one thing fixed 8
one of the inputs or the output it's
fixed in this case I'll parama ties the
inputs but left the output in the test
itself so when I do this what I have to
write here is a behavior
I went from input output to input
behavior and the nature itself for the
test just changed okay the NATO just
change this test is not the same anymore
because in this test here just pretend
you never played bowling how much time
would it take to infer the rules of
bowling just by reading those tests it
will take time it would take time
because you would have to read this and
try to understand what does it mean that
what does this example mean and that's
why I wrote
very bad best names because usually when
I say these people say whole you just
have to have better test names right but
the thing is you cannot rely on your
names all the time there is a
subjectivity to those names and your
good name is the bad name to someone
else that's why I put you in the
situation where the name was bad already
okay names are good I'm not saying you
should not name things don't take as a
kid as a takeaway from this presentation
that you should not name things in the
best way you can you should we totally
should but you cannot rely completely on
names and as well as you accept that
then this is archeology and you're doing
that archeology all the time if you do
code for a living you doing their
archeology all the time who here really
thinks you know all the business rule of
your code right not a single hand up
that's always the case
nobody is crazy enough to think that and
so at some point it's not a matter of if
is when at some point it will do
archaeology you try to find your
business rule by reading your test if
you have tests and and it will begin by
looking Oh what those inputs have in
common what they have different what
does this mean and here I try to help I
could have put four right my best
I tried to put the Sun to show people
there was something going on right so
people still have to read these and try
to understand what was happening here I
went from input to output from into
inputs to behaviors what's happening
here is that in this line I describe it
the business rule
you don't have to infer anymore what is
the business world is just describe it
in the test itself and that's neat
that's very neat the this is you have
problems do you see problems with this
test here there are several problems you
see any sorry okay it's not exact
why oh it's only for the nominals right
it's just one of the logical branch is
not to try to put everything there right
and readability yeah yeah I mean it's
not very different from before but
readability - sucks right because I
still have this problem the problem of
finding what those these have in common
right this is to a problem and and well
this core is between for a nominal
strike for a sudden something as nature
a strike not a spare between 0 and 90
not rear-ended it runs in support the
preferred strike and also I had to have
this problem before word 10 is the
maximum number of pens not 12 and the
problem was there before which doesn't
this not very big visible and and also
it sucks writing this I am lazy and very
laziest person goes and I don't like
writing this those are the kinds of
problems I have with this approach so we
can give another approach which is I go
from here to
now assuming you never have never seen
property-based that this is a profit
basis assume you'll have a never seen a
property-based best part of you right
now you just think it's just a familiar
with it don't don't confound a
familiarity with this sucks okay that
there's a very human thing to do I mean
you can search confirmation biases and
something like that but don't don't
don't confound the two of them give the
open your mind a little okay there are
several unfamiliar terms here for you
and this I this is the point where I
explain I'm doing all this in Java six
not because I like Java six I'm not that
messages I is because I want usually
when people talk about property based
tests they they tell themselves all this
is just for FB people right so I'm
trying to prove a point here no this is
for everyone no matter what language
you're doing today
you can do this today in your legacy
code base my goal here for you to start
doing this Monday ok and so I'm doing
this with Java six to show that even
language tests ugh you can still do this
I have done this in bash it's possible
with every language ever okay I put the
bash into the presentation because it
becomes great after that and the second
thing I want you to believe today to
show you today that people when they
usually see tutorials about property
based testing they stop at mathematical
properties I mean usually you have that
those example horrible ways I hate those
examples where the try to put property
based sets around the sum the addition
operation and tells you okay you can
test for associativity and commutativity
and so awesome
and usually people at this point stopped
reading the tutorial and say well I
don't do this in real life well fair
enough I think you should I've been
testing for associativity is awesome and
you should try to strive for it in
everything you do but fair enough you
don't do this today in real life what I
want you to understand today and we will
not go oh put those mathematical
properties as much as I love them will
not go into them today what I want to
show you today the study of business
domain is filled with properties and you
should at least test those ok that's the
goal here
and here what I must say when I say is
that put random inputs that obey these
assumptions those keywords here is pure
g-unit X unit I mean no matter what
you're doing with intestines today you
have them you have some form of
assertion and some form of assumption
this is not spin particular to property
based testing they just exist and this
one is very rarely used but exists on
your framework today if you do X unit
and unit etc you have that you already
have that an assumption when it's false
the test does not fail it is ignored an
assertion when if false the test fails
okay so we're doing here is i'm doing
like parameter testing but i generate
the parameters randomly and then i do i
give assumptions about them as soon as I
read this prerequisites if they are
through then I should have those those
invariants and post requirements have
you heard about contract programming
okay
I fell and other things like this if the
idea is very similar you try to describe
a little bit of formal reasoning saying
well when this is true in the beginning
they should be true in the end
but in contract programming you're doing
this with your code here you're doing
this with your tests and even if they
are never showing the code for the
bowling is that actually all faux code
we don't care even if you love code
never took this in consideration you can
still do property based testing okay
so when I say I'm here and this is an
awful property and the whole goal here
is to do best better than today not to
do the best thing ever this is an alpha
property it shows a weakness but we have
a serious weakness that we have we are
very primitive this into in our solution
to this problem and because we're very
primitive it is very hard to describe
all the cases where then where we are
not a strike or spare I mean it's very
easy to describe it but it would end up
putting a little bit of the solution
into the test and you should never do
that there's also the problem here with
when you are not in a nominal case when
you try to test spares and strikes you
cannot really put the rule of a spare of
striking to the test without putting the
code of the solution to the test itself
you have our like our weak property you
cannot just do this beautiful thing like
we did here and compress all the example
based testing together to do a property
based test it's not always possible
that's the only drawback of property
based testing again fingers you cannot
use it everywhere to do every test you
have to compose it with other kinds of
testing and weaker kinds of testing why
why should I never put the solution into
the test itself
yes because now I have a tautology I'm
testing that the program has the same
behavior as itself well friends the
program will have the same behavior as
itself you can trust that you don't need
to test that one so you don't want to
put the solution code into the test test
should never roam in the domain of
solutions it should only roam the main
of priam of problems code can roam in
the domain of solutions and problems I
don't care about that but tests should
remain into the domain of problems
you're describing a problem a behavior
in not describing how to do it because
as soon as you start describing how to
do it you finished
you totally Jocko is always true and to
avoid that we'd end up creating those
tests that ok just describes a a
behavior here and what expert seen here
is a pattern every time I try to do my
test I say oh I want things between
these and this size and the size and I
want to have it at this number of balls
thrown and it appears all my tests what
what I seen here is the property based
testing showing me that I have a value
type that is not created as that's the
golden denunciation every test help you
reason as the goal of testing helping
you reason about code and to test is to
reason when I when I try to convince
people to do tdj I not hoping that TDD
will be a miracle and will give them the
Bell the best code ever or will given a
good design by itself or if a sound
design by itself it won't
but just by doing normal tests just by
doing this test here just if the person
does this justice there are huge amounts
of problems with codes that will become
harder to do we become a the lazier path
would be not to do them and so people
will stop doing them have you ever read
cold that it has a single class that
should be 50 classes I've ever had that
if that person gggg will be so boring to
do this that the person will end up
creating several classes maybe will not
be perfect maybe we should be very bad
cold mess but it won't be that bad that
that extreme is not will not be done any
more because we be the harder thing to
do you change the economies of what is
hard to do and what is easy to do when
you do that so when you do property
based tests primitivism itself becomes
harder to do becomes a more expensive
because you end up having to repeat all
the constraints of all your value types
all around your tests and the partner
keeps are merging and you keep saying I
have a problem with my design we it will
not solve all the problems of relative
ease ever but several of them will
become more expensive and that's a good
thing
that's influences design and and I
always have people saying oh yeah but I
don't want to change my designs just for
my test but thing is the goal of design
is to making code reasonable and the
goal of test is to reason about code so
the duality of test design
is always there something can make our
code more easier to test is something
that make the code easier to reason even
if the reason afterwards is just reading
okay so why do you add up say is okay
that's fine a nice and all but my code
is not like this Romeo it's a need the
beginning yourself this is not my test
those are not my tests my test all right
like this now I assume every one of you
have has understood just by reading it
should be obvious to everyone the single
line that has any importance in this
test is this one right right I mean it's
obvious all the other lines are there I
just needed to create a needed to test
is just single boolean and testing and
you to call tested a prescription I gave
is lateral right so I create a lateral
prescription for a patient okay
and to test a little eyetality I just
created those a very high dosage and
everything else
all the other inputs are there just
because to create a prescription well
there are several military feuds and it
helps you put something on those feeds
right does that sound familiar
okay thing is some of you may say oh no
Romeo but I can do this more I can do a
prettier version of this right I can
have fixtures I can do a list a beautifu
turn right it could be less ugly than
this I I agree I agree completely you
could do this less ugly but would not
make the problem go away I'm not trying
to diss on beauty
I'm not saying beauty this sucks and I
really don't take that as a take away to
beauty encode is awesome built-in code
like in flowers is there to ensure the
ways of reproduction the the beauty is
awesome and all I do every coat that you
touch the try strives to do it as pretty
as you can but it will not make the
underlying problem go away it's not it's
good but it's not enough
and I want enough not only good so so
the thing is what I'm saying when I
creating this test is I don't care about
most of these values well let's take a
bet on that if you really don't care
about those values then they could be
random right or else you do care about
them somehow is it either one or the
other there is no third option either
you don't really don't care about them
and it could be random or somehow is not
really I don't care about this value
there's something about it right so if I
translate that to property based testing
either
I have no assumption about this value or
I have an assumption about this value
fair fair well so there is a problem
about this I cannot really make I mean
you feeling there is a problem here here
as I say give me lists of integers
well the framework has a generator to
generate random integers so I don't need
to worry about that but we are doing
Java 6 here right any Java 6 when I did
this
I create several objects myself this is
my codebase objects there is no random
generator for those objects into my
frameworks the frameworks don't even
know those objects so who here does
f-sharp or Haskell in production I hate
you I I don't really hate you just a
view but to everyone else
those three persons here are not that
part is not for them but to everyone
else to all the heads of mankind
you kind of need a way to generate those
objects right yourself by hand
fear not I have you covered so so let's
let's have this test that assess here in
Java this is enough like almost
everything in this codebase I created
here is just alpha cold over alpha code
over alpha code this is an awful awful
Java 6 code to test GPS coordinates
right there are several problems with
this code can you can you find me one
okay I'll give you one as a gift it
takes any big decimal as GPS coordinates
and in real life you cannot really have
that your GPS coordinates is minus 90 to
plus 90 minus 100 the H each post 180
that's all you can do because if you go
further
you just modulating again or RF or you
cannot just imagine a new blend
elsewhere so if I were to test this I
end up having secret like I said before
like you end up discovering all your
invariance of your of your values
they end up appearing in your generation
part because ha you don't want for the
generator to give the invalid value so
you end up putting this everywhere and
the sex what I would really like to have
it is not to generate latitudes and
longitudes in this and then give create
a coordinate that I think tests what I
want is for the framework to give me
those properties those coordinates just
generate me random valid coordinates
right so the first thing to do would be
to correct my objects and then people
would say now Romain lost me I cannot
really correct all my objects and paid
all my techno depth to start doing my
test today and my goal here is for you
to do this Monday right so let's go
awful you just use every every language
has a framework for property based
testing just search on the internet your
language and quick check and we will
have a framework for your language it
has even for bash your language will be
covered okay so in your language you
just have a way to creating generating
your value object value and it's just in
you with randoms on it it's not a very
complicated thing as a matter of fact
you can then use that generator right as
a matter of fact if your test resembles
this you already have the code of the
generator you just copy and paste this
into the generator class and the past
random to every one of those that's it
okay
today is not as expensive operation or
you can use F sharp or Hesco but okay
anyway and what I have here is this this
becomes this I make it on purpose I mean
I really don't need to do all the huge
violation of the matter here
I really didn't on purpose there are two
lines very important for me here this
should be high means this is little okay
that's my whole test so what I said here
is well generate me prescriptions and as
long as the as long as the dosage in the
prescription is high I should have this
problem
this is blatantly false I am wrong when
I do those tests because I have a low
dosage and I tell you take this 40,000
times in a day I will still kill you
right but I had a bad assumption about
the test itself in my test wearing the
bad assumption and you are doing this
today
you don't understand fully all your
business rules everywhere that's
impossible
nobody does in your whole enterprise
nobody has the whole science of all your
business rules in their head so at some
point you will have that kind of bug the
bug that is not in the code that is just
in your head the bug about
misunderstanding the business rules
themselves this will happen ok ok so
when I execute this test strangely it is
green yay
when is a good business sadly it will go
red that's it
so it could go green that is the first
point
people usually dealt property based
icing because they say hey that's random
right you asking me to test with random
improved you are a crazy man I I don't
want it I want I want things to be
static and have always the same behavior
right fair I'll try to convince you that
it's better to test with random but
there's a fair fear to have about this
approach this says if I execute it
enough I could come to a situation where
the random inputs were all valid the
inputs in a testiment green okay and
that's the first real takeaway I have
for you today
in property based testing when a test go
green it doesn't mean you're good it
just means I did not have you today but
I may have you tomorrow yes it is I'll
get to that I will get to that but thank
you all the test is saying is I will
when it's green is I do not have you
today but I will have you tomorrow
at at some later date when I'm defending
to you today is that it's not only
property based test that I like that
every test is like that even this this
test here when you go goes read what it
says haha gotcha
any when it goes green what it says I do
not manage to have you today but I can
have you some water day that's all any
test say ever it's just that this test
here always tries the same thing that's
all that's the only difference
it so this here is crazy
where as well this here is pretty sane
it writes you have different inputs that
you respect your assumptions and see if
they pass okay so like my friend here
said I have a male patient that is
pregnant well I mean I respect your
transsexuality so that's possible that's
not my problem here okay my problem here
is this should not be possible this
number of weeks of amenorrhea week since
your life inspiration this should never
be possible the this is a strange man
this is very strange and and also this
test fails because I'm not entering to
the production code but as soon as I do
the archeology behind this this test
fails because this rule is false for
every pregnant person okay even if that
was not the case that rule will be false
because my assumption was wrong in the
big to begin with I wanted to care of
dosage when the number of doses per day
is also important okay so when you have
a red test in property-based testing all
you have is a counter example you have
to if you have to find why it is a
counter example okay if you have to find
if you have to to see keep this so you
have to slice it down to lehre
assumptions and not try to put
everything into a same test which you
also helps you not you have your
solution to the test itself but there is
a very important word rear shrinking can
you can read it differently shrunken
well
most if you have a choice between two
property based testing frameworks for
our language and one of them do
shrinking in the other doesn't pick the
one that does shrinking okay what is
shrinking is that as soon as the
framework finds a counter example it
tries to find a smaller one it takes
this content tip say okay if I cut half
of it and less the other house you read
and tries to find a smaller one that is
to read and that's very useful first
time I ever did property based testing
was in integration tests you can do it
at all level of testing in attire
integration into and etc etc set and
what integration does and I was actually
calling a rest frame rest api with my
property based test framework and it
just exploded everything with any food
the input has several Chinese and
Japanese Wars in it and I say aha
there's a shower cold problem right it
wasn't that as was noise when when I
teach shrinking I have a very small
string that is to failed my test and the
real underlying problem is was when I
have characters where they were not
printable we would explode everything
okay that's the thing when it finds a
counter example it finds a random one so
if it does shrinking it tries to find a
smaller counter example you can to help
you help you help yourself okay okay so
thing is
what I show you here is to users I have
four property-based eyes I have four
main users myself for beta testing when
I do code and I just use those a lot and
I try to convince you that you should
use them my first one is this one is the
one I show in the beginning I compress
test together I try to compress them
together in order to end with that test
explains a business rule maybe the rule
explains is that we a real domain rule
babies very technical I don't care I
just trying to compress tests together
that's one approach one of my four
approaches to doing PBT PBT okay just
compressing tests together the test I
can compress together I do compress
together that's the first my second
approach to PBT is to take a domain rule
and you have several domain rules just
the example I gave you have a little
icky truth booth is a is a real problem
a real domain problem it'll have real
ribbon problem every time it is could
discuss with on domain expert and your
domain expert tells you I'm sure this is
the behavior I have I have this rule
here it is behavioral health you have
something you can test with property
based testing actually who here has ever
done bgg behavior driven development a
few of you so when you try to do it it
try to push your domain expert to do to
do examples it is very good and I saying
you should do that you should do this
because those are things to have a
discussion that make the domain expert
to discover things that was not in the
discussion beforehand but no domain
expert ever really wants to give those
examples right away right because it's
boring what they really want to give you
is a business rule but in here you want
to give this a human view of the
behavior that would be the application
should
I cannot fold them for heaven that that
need but I push them to give you
examples but they well you can test the
business rules themselves using property
based testing in issued now if you start
by that and it when I have a business
rule given by them by domain expert I
start by that eyes write a property
based test for the rule I have a pest of
it will be read a long time that's fine
I just do my normal teach inside it up
to the point is green and until I see
which are the test that I keep and which
are the tester I don't you should never
be afraid just you do scratches - dude
rests with your code code is a perfectly
valid way of doing drafts people don't
do that enough you should not ask
yourself to write code directly in the
perfect way you can't use code to help
your own understanding and you should do
more of that is it's like asking people
to write a book and not not never do a
draft that's also right the same is true
for code so my first usage is
compressing test together my second
usage is I have a business rule I put a
test to it at a property-based edge to
it and then I try to live my life
normally inside this do a double loop
okay my third usage of it is to ask
questions to my code base the thing is
like I said earlier your you do not know
of your business rules and your domain
expert don't know all their business
rules - you think they should but they
don't and if you have a old code base I
just ask this question who here has a
code base that is older in the job thank
you or your domain experts right some of
you if you have an old code base you
have people have programmed the solution
to problems that would never really
stated in the code base
and there are several edge cases in the
code that nobody else remembers now
today maybe there are bugs maybe there
are just real-life usages that are
forgotten in the whole forgotten in time
because everyone what everyone there is
more recent than the code itself
well we from AG based testing can ask
questions to the code well I bet you
have this behavior
I see the code says though I don't
entitle just anything you can add to the
discussion to code itself for example
this this case I gave here of the
pregnant people was a real life case I
had in a client and the nobody had a
rule in mind at all that pregnancy
changed the levels of lethality nobody
had that and it became we were really
afraid there was an alpha bug and I said
it so that's a third users asking quest
about the codes as asking our code basic
questions
my fourth and last users of property
based testing is to do a
characterization testing I want to
understand what one class does so I try
to put out a potassium out that class
about the behavior of the class that I
know what may be true or false and I use
those little by little choo-choo to try
to draw what is the behavior of this
legacy code base that the legacy class
that I don't know or loosened before I
started really reading it and with those
four together you have a tapestry are
you strepa states of property based eyes
and usages that it really benefits you
from doing studies and doing that today
and you should a question that I usually
have at this point is
well Romeo is fine and all but my tests
are really slow I mean each time and
execute approach based test it tries
allow about 100 times run at 100 random
inputs my tests take like 30 minutes to
execute if every one of those value is
equal to 100 times it would be awfully
slow right and the real answer is the
answer that doesn't help you at all your
test sucks and you should change your
tests but it doesn't help you because
you don't want to pay the test depth
right now every the whole test depth of
the application right now right so if
you don't I
let's meet halfway okay do a PBT and you
can configure it in every framework how
many tries it does worst case scenario
if the test again half an hour to
execute put it to one it will take the
exact same time that today but between
two different executions of our test
cases and which in two different days
for products maybe they will try
different things it was to end up
winning something see my point
and that's pretty much everything I want
to discuss you today do you have any
questions yes it's not really fixed yeah
yeah yeah that's a question I usually
have to which is what does it his
question is one as I have the red light
to do it do I create a test for it and
yes there are three yes you should
create a test for it
maybe we raise it somehow afterwards and
not religious against a raising test I
raise test a lot but some people who say
no you keep forever that's a choice each
purchase their own but
a question I usually have is well what
is that I have continued I use
continuous integration right so we
continues delivery each time I push a
new version a metal is acute and the
diversion goes into production or into
another scope where there is a new
version that is done with my tool or
something like this what is it a random
if what is I'm building when I doing in
my machine is green and it when it goes
into the pipeline towards building a new
version it becomes red what do i do then
right in my usual
answer to that is what would you do if
it did not do PBG you know it would be
green and while it is building this new
version someone from QA comes and say
hey I have found a bug well it can do
only two things at that point every
stopped everything and say we have to
correct this or you say well let's put
this into our backlog and deliver and
it's the same thing for PPG right you
acres say okay let's correct this or you
put this in your backlog and you deliver
it only louder any other questions yes
of course it's very hard to know what
the minotaur are but that's my issue
someone else give you gives you the your
domain rules but that's why I have this
four approaches that's one of the four
no into the main road you can always try
to at least compress the test together
and something we go out and try to
recognize what it is
sorry yeah what we haven't we mapped it
right but you have the same level of
blindness to it that you have today you
know we want to show you more oh yes
that's a problem right yes if you if you
really don't want to test them within
passive profits base testing then you
have a clear separation there where
things go into assumptions right assume
I don't have this oh yeah that's a very
good question do you have any tools to
create the fixtures automatically from
the contour examples I get it all
depends on the language itself okay one
of the things I love about closure and
Lisp really is that the error message I
get from my property based test is
already my test so I just copy and paste
it and yeah of oscillatory you don't do
lists right who here does list oh I love
you guys know for everyone else it
really is really language dependent I
don't have that for all languages at all
so for some people for a lot a lot of
people
it remains that boring part of okay
transform this picture into a test case
right or some some a very small number
of language haskell on things like this
do memorization so they they enhance the
probability of half the something went
red you have a higher probability of
having again the next time you execute
this is just
to spare you the bother of what is I
found easier to do in real life
is a Israel try to just transform it by
hand in language like Java or C sharp
and but sometimes I have quick wins that
is just I can when I see the problem I
can play with my assumptions to enhance
the changes I have to have this contra
example without another test itself all
right do I have any other questions oh
thank you people</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>