<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Pushing C# to the limit - Joe Albahari | Coder Coacher - Coaching Coders</title><meta content="Pushing C# to the limit - Joe Albahari - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Pushing C# to the limit - Joe Albahari</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mLX1sYVf-Xg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everyone
well done on making it to the 9:00 a.m.
session I'm still them on Perth time so
for me it's 7 a.m. so the main reason
I'm at this session is because I'm
giving it I said I set three alarms this
morning you know just just to be sure
so I set my iPhone and I set my wife's
my phone alarm and then just to be
really sure I had a third alarm so for
that I run a limp a link pad script hang
on it's not working here it is there is
I ran this link pad script to wake me up
in the morning just in case the iPhone
alarm didn't work I have once had an
iPhone alarm fail on me I missed a
flight and what had happened is of
setting the minutes on it you know with
your thumb you flick it down and I
fat-fingered the am/pm so I flipped it
to p.m. and it didn't wake me up so this
is my backup and I thought this was
pretty pretty foolproof because I tested
it and it worked when I tested it but
this didn't work this morning there's
nothing happened and it's not what you
think the laptop didn't go to sleep
because I disabled that right that would
have been a rookie error but what had
happened was when I looked at the laptop
this morning the the media player had
opened but instead of playing that song
it had popped up a dialog asking if I
wanted to try a groove music I'm past
unlimited for one month before
proceeding
so yesterday so I gave us I gave it a
soft talk and some people asked me if I
would make up for it by giving an extra
hard talk today and the answer is yes so
I'm going to talk about a problem I had
a couple of years ago writing a new
feature for link pad and how I solved it
and start with I made some soft slides
which we won't spend too long with but I
had made some slides on and you know why
I think she shops liquid language and
the slide on the reach we've got now for
for c-sharp on the cross platform and so
on but this is probably the thing I want
to spend a bit more time on which is
what which is what makes c-sharp quite
unusual in that most languages say that
they tend to be either kind of low level
or high level or medium level but the C
shops it's got quite a broad reach so
you most people when I start programming
that they'll use loops variables methods
most kind of basic possible constructs
and then the other thing which is pretty
much the bread and butter of c-sharp and
also of java is classes object
orientation so this is the level that
most people were really comfortable at
and they work at but C sharps also over
the years it's shifted somewhat towards
the right because we have all these
other things - which are very expressive
features so they let you achieve a lot
with a little bit of code right it takes
a while to learn really get comfortable
with using these features but they do an
awful lot with a small amount of code
now most people I would say that they
use some of that there's somewhat
comfortable with that people though have
that come from a functional programming
background if they go to C shap they'll
straightaway start with all that stuff
on the right
they'll reluctantly use a little bit of
the stuff in the middle classes object
orientation and they will really try and
avoid loops mutable variables now this
is not the end of the story there
because sous-chefs also got something
wrong there on that on the edge there
which is ability to do direct memory
manipulation with pointers and that that
kind of raises a question like why did
they have that in there do we still need
it is that is that important and if
you're going to use that are you also
going to use that stuff on the right
hand side and this this comes back to to
this session which is that you know I
had a problem and I ended up
needing this whole range point us and
direct memory manipulation you don't
often need it but when you do it's
really really useful to have and the
great thing about having it in c-sharp
is you don't have to go to another
language to do that because how many of
you are confident using C++ nowadays you
could bring up you know not many honey a
few people right and the problem is that
you it's you know you've if you're
working in another foreign language
you're very unproductive and then you
don't have all the good stuff on the
right so having that in c-sharp is great
so we're going to start with this this
problem I had and this is a link pad
writing link pad so if you're not
familiar with it I'll close that down
we'll start with something like him one
plus one probably all use link pad so
it's it it's like code scratch pad bring
up another query and we can put a loop
in there we'll write 100 dump that out
now the way that link pad used to work
is everything ran in one process and so
the way it would keep you queries
isolated is it would put them into
separate application domains and that
actually works surprisingly well because
the separation you get through app
domain boundaries is quite good but a
couple of years ago I wrote a feature
which required that I isolate every
query into a separate process and that
feature was the integrated debugger so
now you can you can single step through
your code and watch your variables
change but that means that it has to be
running your code has to be running in
its own process and you have a look at
that and see go to task manager will see
it running in there
maybe we go to details now to say you do
it here we are so there yeah you've got
link pad host process and then you've
got a user query for each of the queries
that are running in there right and the
reason there's three and not two is that
link pad creates it speculatively
creates another container all warmed up
and ready to go so if I create a new
query that it avoids the startup cost so
that this created a problem because when
I move from app domain isolation to
process isolation I need a way that the
domain queries the process of your that
your codes running can talk to the link
pad host process and vice-versa there is
some lot of elaborate communication that
goes on to make link pad work because
it's quite a rich environment so before
I was using technology called dotnet
remoting and and that works has been
around since the beginning of c-sharp it
works incredibly well when you're
talking between application domains in
the same process incredibly fast rich
robust reliable no problems at all but
once you start using it to try and talk
between processes it doesn't work so
well because you now you need to create
a communications channel and until you
can use an inter process channel or a
TCP Channel and it's a process Channel
uses dotnet pipes TCP uses tcp/ip if you
want you can even use this to talk to
processes on a different machine on the
other side of the world in fact this is
what people did before we had WCF you
would either use remoting or web
services as a as a way to talk between
processes but what I found was that when
I switched to doing that the performance
went down and it would periodically
disconnect and I could not get to the
bottom of why that there seemed to be
some bug in the RPC channel so I thought
well maybe what I need to do is write my
own remoting from scratch how about that
now how hard can that possibly be now
when it comes to writing your own
libraries it's a bit sometimes it's a
bit easier than it sounds because you
only need to write the features that you
need
I didn't there's a lot of stuff in
remoting I didn't need so I thought
about what I did need to be able to call
a method in a class in another process
right and I don't there's a lot of other
stuff I don't need so I started doing
that and then I thought well what am I
going to build on top of what's the
basic weighted from one process to talk
to another and that in Windows you've
got something called pipes which is a
low-level way of doing that and so I
started using pipes and what I found
pipes if you use it in a simple way it
works really well it's fast reliable but
I was needing to use it in a fairly
complicated asynchronous way and I could
not get it to work at all the way I
wanted so I realized what if I write my
own pipes from scratch how hard can that
be so I thought let's do it let's so
let's start by writing our own pipes and
then on top of that we're going to write
her and remoting and it won't be that
many that much code either we're going
to do it in a simplest way so to do to
write the pipes we need something even
lower level and how to work with and the
thing we're going to use you can't get
lower than this is shared memory and
we're going to allocate shared memory
between two processes where you can both
read and write that same memory that's
how we're going to do it
so what I'll do first is we'll go back
to PowerPoint and I'll show you how how
we're going to do this so that's the
basic architecture so we're going to
design our own remoting channel and
proxy on top underneath we're going to
make our own pipe using shared memory so
they'll be an abstract pipe class or
than input pipe and output pipe so
here's the requirements now got four
pipes we need to descend byte arrays to
another process that's it
send byte or another process has to be I
want it to be extremely low latency
right for performance I but I don't need
high throughput so I need lots of
messages per second I don't need a lot
of megabytes per second it has to be
completely asynchronous because if it
crashes for some reason like your
process crashes I don't want the link
pad UI to crash and the fourth direction
the fourth requirement it needs to be
bi-directional but then I thought well
that's a really silly requirement
because that would
make it way more complicated and we can
easily create a bi-directional pipe by
creating two pipes on each way which is
what we're going to do so let's design
it so here's a block of shared memory so
we've got a I've nominated the first
five bytes as a header four bytes
represent an integer 32-bit integer and
this is fifth one represents a boolean
value so the first thing we're going to
do we're going to send a message now
into this into this buffer and a writer
message to the buffer so the message we
want to writes three bytes long so I'm
gonna first length prefix three bytes
I'm doing this big endian but just to
make it a little clearer so you know
this the least significant byte comes
last
so we write the the length prefix and
the message is two bytes one two three
we write that next thing we do is
increment that that number at the top so
that now that that shows we've written a
message and then we flash the
inter-process signal so this the other
now the other process is reading this
it's waiting on that signal so it gets
that signal it's gonna then read the
header it's gonna go back it's going to
read that header it's going to see that
there's a 1 there which is greater than
what it's all before which was a 0 so
now it's going to read the length prefix
3 and we'll read the 3 bytes and we'll
basically sent the message 1 2 3 to the
other process right the next thing you
to do is sort of go back and read this
again say is this now - no we're still 1
it'll would go back again it'll spin a
thousand times waiting for that to go up
in case there's a series of messages
right now if there's nothing else after
a thousand spins it will wait again on
the interprocess signal right then we
want to write another message we want to
write a second one so what it does is
will now write a five point messages
time so write the length of prefix will
write the 5 bytes will increment the
header now so that one now will become 2
and will flash the inter-process signal
we'll set it so now what we'll keep
doing this the other process will read
it and eventually we're going to run out
of space in that buffer right so at this
point what do we do
now you'll notice that what we're doing
there are no locks here we're not using
any locks now normally if you've got two
processors or two threads sharing memory
you would always use locks to
synchronize that but remember we want to
make this super low latency so I'm
designing this completely lock free
right now
that means we have to be really careful
because if when you're doing lock free
stuff you want to keep it really really
simple because it's so easy to trip up
so one thing we cannot do is reuse that
buffer not easily because we need some
coordination then with the other process
so what we're going to do is very simple
when we run out of space for the next
message we're going to set up a protocol
where we're going to simply create a new
buffer right so we'll abandon the old
buffer create a new one so that buffer
had a suffix of dot 0 the next one will
be dot 1 the next one be bot dot 2 so we
always know how to find the next buffer
so all we do if the message won't fit is
we write 0 4 zeros in there that
indicates now we'll finish with that
buffer were gone to the next one so one
more problem that we've got we've got to
deal with is that eventually we're going
to use up all the memory because we need
some way of releasing these buffers so
that the process that's reading this the
input pipe that's reading this and see
that yellow that yellow square in the
header when it's finished reading it it
will set that to one and that means now
that periodically the other process of
writing to it keeps track of all these
old ones and when it sees that that's
changed to one it knows that the other
process is finished with it so it can
release the the buffer when both
processes release the buffer then
windows will release the shared memory
sounds simple
so the next thing we'll do is is we'll
write that
so the first what I'll do is I'll show
you how shared memory works first how
you access it because dot necks actually
got a wrapper for this an API so what
you do is you use this static method
creating you to create a shared memory
buffer thousand bytes give it a name and
if two processes correct one with the
same name
they can talk to each other so this
creates a called a view excess so which
lets us read and write to it so what
that does it writes that the 500 index
writes the byte 1 2 3 so let's run that
now and then another process what we'll
do is we'll do the same thing we'll
create one with the same name and now
we'll read will put reading 32 at the
500th offset so we should get one two
three at this works which it does right
now the only problem was doing it like
that is it's it's really slow to do it
fast we need to use pointers is where
the pointers come in so this is how I
would go back to the first one let's
stop that this is how I would do that
this at pointers instead of using these
this right method which is slow what we
can do is get a pointer and we are you
call accessor dot safe memory map view
handle dangerous get handle to pointer
that incantation gives you a void star a
pointer to the unknown so we can cast
that to a pointer to anything we like so
I'm first casting it to a byte pointer
and then we can do pointer arithmetic by
adding 500 we're moving jumping 500
bytes ahead then I can cast it to an int
pointer so now I can write an integer
the one two three so that'll write four
bytes one two three zero zero zero we
will be a little endian and so we'll run
that and I'll go back to the the one
that reads it this one does still does
it the slow way and that still works so
that's that's the basics on on using
shared memory so let's go ahead and
write the pipe now so here's the pipe
now the first thing we need to do we
I've written a class called safe
disposable because one thing you need to
be really careful of with pointers is
not getting dandling pointers dangling
pointer is when you release the
underlying memory resource by disposing
your object and you still got a copy of
that pointer around if you write to that
pointer you'll crash the process the
problem is it can be very very hard to
like knows that kind of bug because
sometimes the it doesn't show up till
later so we're going to that there's a
lot of different ways of doing this with
various degrees of robustness but I've
chosen a nice compromise which is this
safe disposable class it's a fairly
simple way of making it much more
reliable not 100% but more reliable so
we have a public object dispose lock so
we're always going to look around this
object whenever we access the pointer
and I've got a dispose method gain which
locks around that and cause their
dispose call which is the one will
override and I've got a search safe
method which locks it and says if I'm
disposed throw an object disposed
exception so the pattern to use it is
you'll obtain that disposed lock and
you'll call a search safe and at that
point you will know that that buffer
that that pointer is safe to use so it's
the first thing we do now next thing is
I've created a wrapper for the memory
mapped file which is that shared memory
it's called a memory mapped file without
a file right so it has a there are
fields for the file for the accessor and
the pointer which I'm also buffering now
this is the constructor so we're setting
all this up there dispose call we clear
all those things to dispose them fairly
straightforward so this is the abstract
now base class for the pipe so what I'm
doing is creating a that's the minimum
buffer size so what we'll do is is you
can make this that the size of the
buffer dynamics so it can look at the
history of how big the buffers were in
the past and automatically size it which
is what I've done in link path this
one's a little bit simpler so it just
comes up with a fairly simple heuristic
from working out the length of the
buffer that's the the inter-process
signal and this is where we create it we
create the buffer so one of the parties
throughout both of them open the buffer
one creates it and then the other
connects to the existing buffer that's
the proof that the the suffix of dot 0
for the first buffer the second one's a
dot 1 then it's a dot 2 and so on and
that the event we correct the event wait
handle as a signal and that's pretty
much it for the for the common base
class so we look at the output pipe now
that's we keep a list of all of the old
buffers right these are the ones that
haven't yet been read and this is how we
write a byte array out we lock that
dispose lock assert safe protect against
the dangling pointers and then we see if
there's enough space to write that
message if there's not we do a
continuation with quite the new buffer
otherwise write the message and signal
the cross process signal so this is how
we write the message now since we're we
given to the pointers right so till we
do the point arithmetic to take up the
running off set add that to the pointer
we cast it to an int star and then we
write in the message length the brenth
prefix and this is how you do a
low-level blit right in in the CLR this
does a low-level memory blip very very
fast much faster than doing it using the
view accessor using this is just that
you've with pointers and then we write
the latest message number to the start
of the buffer that's to that blue bit at
the top so then at this bit here
it seems we don't have enough space to
do it so allocates a new buffer in there
it writes zero message to the old one to
indicate its it's not there anymore
and it also adds the old buffer to a net
to that list so that we can monitor it
to make sure it's we don't delete it
before it's been read and that cleans up
the old buffers that one looks so that
looks reads that that boolean flag and
says if that's set to one then we're
going to remove and dispose that old
buffer so let's look at the input piping
at the other end so this is asynchronous
so it runs it on another thread and what
we're doing is the constructor takes an
action of byte array
so is this is this tells it what to do
whenever it receives a message it's kind
of like an event but a lot less verbose
than an event right you could also do
this with an eye observable so here's
the loop it does spin cycles to zero
does a while true gets the latest
message ID guess this reads the message
ID again locks locks to dispose lock and
if everything's good it returns it takes
the that the pointer to the buffer and
then casts it to an int star and
dereferences it so that reads the reads
that blue that blue header that number
there reset number and then we look is
this greater than the last message ID so
if it's greater than the last one
received then we then read that message
okay I'll tell you what this does in a
moment so then if we've got a non zero
length message it will then call that
function on messages like the event so
fire that event whenever we get that
message and then it sets the spin cycles
to spin a thousand times so we're going
to and the reason we do this is that the
ODE that there's an overhead on waiting
on an inter process wait handle right
into process signals a way way way
slower than ones you use inside your
application
so for instance a lock as well a lock
and a lock that you use in c-sharp is
very quick whereas an inter process lock
a mutex very slow so signals not quite
as bad but we still want to avoid using
it if we can sir so while we spin a
thousand times so if the spin cycles
gets down to zero well then only then do
we wait on that sig inter-process signal
otherwise we increment we decrement the
spin cycles so that's pretty much the
the interesting part of the pipe so the
only other thing I need to point out is
that because we're doing a lot free
implementation we've got to be really
careful because the way that most
computers work nowadays the processes is
they do lots of really cool
optimizations to make things run faster
take advantage of the fact you
multiple calls and one of the things
that can do is it can literally reorder
reads right so that means that we could
run into trouble we could end up reading
stale data so there's two places that we
need to put a memory barrier in here
it's basically it's that it's that
optimization where we're reading the
so it's in here where we're we're
finished reading the go back a bit we're
finished reading a message and now we go
straight back and check that header
again to see if there's another message
we spin right at that point there
we need a memory barrier to ensure that
that reads can't be reordered around
that point so we don't read the header
the root of the header and the read to
the data block aren't switched around so
that's why we've got we've got the we've
got two memory barriers one in here and
one in here so that makes our lock free
implementation now safe so let's test it
now and see how it works so first thing
I'll do is run a demo in this demo we'll
create a new pipe called test and a
number after it create an input and an
output pipe with the same name and I'm
telling the input pipe whatever you
receive a message I want you to dump the
message out that dose and then I'm going
to write two messages the numbers 1 2 3
and then the numbers 1 2 5 so run that
now and there it is they come through
there that numbers 1 2 3 the numbers 1 2
3 4 5 so that's that's fine that's it
that works in a simple case let's run a
more rigorous stress test the stress
test now this context sends a constant
stream of messages between twenty and a
hundred bytes long which is how link pad
will be using it so we're going to now
um go to that current stress test and
this now it does a comparison to make
sure that the messages are identical on
both ends so we're getting now hundred
and forty thousand messages per second
but most of the the overhead there is
actually interest testing to make sure
the message is correctly transmitted and
sent so what we want to do is just we'll
get rid of of the of the test so what
one that I'm going to do is get rid of
here where we're creating a hash let's
get rid of that and get rid of this so
we'll just assume it succeeds
that stress has received press to send
again I'm gonna get rid of the hash
there yeah so let's run this now and now
we're getting five hundred and almost
six hundred thousand messages per second
on the laptop so we've got very low
overhead very low per message overhead
doing this by virtue of being locked
free so we've done it we've created our
own pipes in just a few pages of code so
the next the next challenge is to create
the top level we need to create a
channel and a proxy so what this is to
remember we want to be able to not just
send by to another process I want to
call methods
I want to instantiate objects in another
process and call methods on the other
process so just like you can with
remoting so we're going to do that by
creating a channel I'm gonna call it
fast Channel and that we're going to
create proxies a proxy of T is the way
that we're going to do the remoting
that's it that's a proxy for the remote
object we want to access so these are
the requirements I want client
activation right that's a really really
good feature of remoting that I was the
only person that liked right so it used
to be considered a dirty word client
activation client activated objects and
remoting the reason is that people were
using remoting mostly for things like
web services right for loosely coupled
applications you're talking to your
thousands of clients talking to a server
you're a scale to thousands of clients
now in that situation client activation
is inappropriate this situation is
absolutely perfect for a tightly coupled
system same assemblies on both ends so
what is client activation it's that it's
that the one process will instantiate an
object in another process and that
object will stay alive as long as either
process as a reference to it when both
processes drop the reference then it
gets GCD right now the reason it can go
wrong is if one of the
Crash's right this the the process that
sponsoring it crashes it's going to stay
alive potentially forever on the other
process but and they came up with some
really complicated nasty ways of dealing
with this and remoting but we won't have
this problem because in link pad if the
process crashes what we're going to do
is we're going to scope all of the
proxies to the channel itself right
we're not going to be static they're
going to be an instance of the channel
so all we do is we recreate a new
channel new process new channel and all
of those old proxies die with the
channel right we don't have to code
anything at all it's all automatic so
client activation will work brilliantly
if as long as we scope the proxies to
the channel now when you do to call
methods with parameters and get a return
value back we're not going to support
refs and outs
that's way too complicated we're not
going to let you create generic types
and we we do need to support complex
types I do want to be able to to
serialize complex types and what
exceptions to be propagated
transparently again that's quite easy
because exception is just a return value
that you throw I want it to be
absolutely fully asynchronous and I want
automatic marshalling and unmarshal
right that's a really cool feature
remoting so what that is if I'm if I'm
calling a method in another process I
can pass a reference to an object in my
process right I'm Wendy and then the
other process can call methods on that
and it will automatically call back to
my process right that's automatic
marshalling it's really cool and then
even that even more callers are
marshalling right so then you can send
an object from your domain to the other
domain and then it can set that object
back to you and then you can call
methods on that but it realizes that
that's a reference to an object on
another domain which is a reference back
to your domain so to automatically
unwrap it to a local object right that's
some marshaling so I thought be really
cool it's not essential but if I get
that working it's gonna make it really
really smooth to use I want it really
super fast
and it didn't write it in less than a
week so there's some things that that
kind of contradict each other they're
like being able to be fast and being
able to serialize complex types I don't
have the time to write a full
serialization engine that's gonna take a
year that right to do that so I've come
up with it with a really good way to
compromise on that though so let's let's
sermon let's start with it so what the
first challenge we've got is in being
able to call a method on an in another
domain what does that look like in the
code like one way to do it is we could
just describe the method and the object
we want to call in a string and all the
parameters in a string but that's
incredibly error-prone and clumsy but
we're in c-sharp there's a much nicer
way we can do this so in this example
I'm good a method foo which takes an
action it's a delegate so we can call
foo with a bit of code I can say foo I
want you to execute console dot write
line hello world right and when we call
this it's going to execute hello world
right line hello world right so that's
that's how we can use it a delegate for
interaction but we can change that
action into an expression of action and
now that's slightly different so instead
of now getting a delegate we see shot
builds us an expression tree which
describes this code so this now a is now
a description of that code there so when
I dump out that a that expression of
action what I get is a description
saying this is a lambda expression the
body of it is right line hello world
it's a method call and these are the
arguments to that so this allows us to
this is really powerful so we can expand
this a bit so what I'm doing now I'm
saying if a body don't know type is a
call a method call then cast it to a
method call expression dump out the
method and dump out the arguments so
I'll run that now
and now we've got here we are that's the
console.writeline and now that's the
parameter hello world in there so this
is the basis we can use for being able
to execute something in another domain
so let's just flush that up a little bit
more so what it looks like now we're
invoking the remote method so I'm going
to create a class called fast channel
that's that manages the communication
give it a name and then we're going to
have this class proxy which is a generic
class of remote class remote classes
something is an example of a class that
we want to remote so here it is this is
the class I want to instantiate on
another domain and I've got a method
called some remote method I'm gonna call
which takes it in turn string so I call
channel don't activate all right that's
that's the method I'm going to use to
create an object in the other domain so
I want to I want you to instantiate an
instance of remote class in the other
domain and then I want you to run on
that remote damat on that object some
remote method with these parameters so
this is that this is a shell of what
we're doing so the the fast channel will
have two pipes input output pipes that's
bi-directional that's the method to do
the activation so it will create a new
proxy for us which is the handle we can
use to call methods on it and then it
will we need to write code to serialize
that instantiation to describe it we
want to stand state the object and send
it to the out pipe so let's have a look
again in that proxy we need to write a
run method in there so that run method
will take an expression of action of T
remote so this describes the remote
method that we want to run so we'll say
if it's not an expression call we'll
just throw an exception saying I don't
know how to do that so we're only going
to allow you to call simple methods I'm
also going to allow you to get
properties as well we're going to allow
set properties we won't allow other
things like you know custom operators
and things like that so now we can dump
out the method and dump out the
arguments and then what we the other
thing when you would need to do is to
serialize that method call
into some payload binary payload and
then send it down the wire so that's
pretty much what we need and I can run
that now and we should it should just
get as far as just describing this is
what we're trying to do we're trying to
run this remote method with these
arguments so here we are running that
from some remote method int 32 string s
and these are the arguments that we
passed in so already halfway there
really right few more things minis one
is we need not just a run but an eval we
need to be able to call a method and get
a return value back that's very very
similar to what we already did in there
so except that it's we now have a Tia
results as well we have a T result eval
T result and the it's the type is an
expression of a func of t remote comma t
results so it takes the t remote that's
the object on the other domain and the t
result is the return value would get
from there the other thing we need to do
is we need to provide an asynchronous
version of that because I want to be
able to call asynchronous methods on the
remote domain as well so asynchronous
methods return a task alright so here's
what that what it with the signature
will look like some mouse is not very
good on this surface so here we are so
it would sort of taking a T result it
would take a T a task of T result that's
the return type and it returns a task of
T result that's gonna require a little
bit more wiring up it's not synchronous
so it has to keep track of that remote
method when it's complete and send the
result back so as it turns out when we
actually implement this this one here
the synchronous one will also return a
task of T result even the activate
method will return a task everything
will return a task the reason for this
is it's possible that the remote process
is crashed in which case even
synchronous our methods will never
return I don't want link pad UI to crash
into fries because a process
we're processes crashed so I've actually
going to make everything return tasks so
we can now go to the to the actual
program this will go now to the fast
channel this is all of the code now by
the way if you want if you want to get
download this code go to link pad
samples and hit download input more
samples and if you go out to the end you
hear the samples for NDC Sydney so if
there's nothing if you have understood
absolutely nothing in here you can
download the sample i've kept off
stripped everything I possibly can out
of it that isn't essential for this so
it's simple enough that you can sort of
figure out how it works and you can hack
it and change it and you can use this as
a basis for any other communications
library you want to write very
high-speed communications library
between processes so I'm gonna run
through it now how it works this is a
little bit bigger than the last one so
it's the demo we're going to look at I'm
going to look first at the fast channel
itself and things I'm going to point out
here is he rolled the proxy's these the
client activated objects so we need to
keep track of them in a dictionary right
this is not a static dictionary it's an
instance of the proxy so that we avoid
the memory leaks by doing that so that's
the dictionary and this here this
dictionary is whenever we send a message
to the other room to the other domain we
need to get a response at some point so
we need to keep track of what to do when
we get a response if I you know call a
method on the other domain it's going to
send a return value or an exception at
some point so what do I do when I get
the return message so the way we do this
is every message has a number we keep
incrementing the number so unique number
so what I do is I create a dictionary
and the key is the number of the message
and this tells itting what to do right
so rather than putting the information
in there what I'm putting in is I can
actually put the code and I can say do
this when you get the reply you
replies so these are the different kinds
of messages right that activation means
instantiating an object on the other
domain deactivation is when the GC
catches up with it and we want to pass
that message on method called simple
method call that's the return value from
a method and that's the return exception
so if it if the method that you called
through those are the only kinds of
messages so we create we start by
creating the two pipes right so this is
bi-directional so there's one impart one
out pipe and let's have a look at the
send messages probably activate here's
how we do an activation so how you
activate or instantiate a message on the
other domain so this creates in
increments the message number and then
to serialize that to describe the
activation I'm using a memory stream
with a binary writer
that's quite a fast way of doing it so
we can just write some byte series of
bytes in there the first thing we do is
we write the kind of message which is an
activation and then we write the message
number and then we need to write the
type of the object that we want to
instantiate so I've got a method called
serialized type which does that and
we'll look at that later flush the
writer and now we want to know we're
going to have to wait oh wait until we
get a response all right so what we do
is to call this method here get response
future that returns a task right which
we return to the caller so we'll have a
look at get response future all right so
what this does it creates a task
completion source which lets us drive a
task and then it locks a pending replies
right that's that dictionary that
contains integer comma delegate right so
one of the things that you do when you
start getting more comfortable with with
functional styles of programming is
you're willing to use functions pretty
much everywhere you would use objects so
we use you know objects in lists and
dictionary so why not use func
anna-san dictionary so this is a
dictionary that contains in Tacoma
function so this pending reply so we're
adding to that we're saying when you
when we see a reply with that message
number run this code here right and it's
fairly simple what's in here there's two
kinds of things we're going to get back
it's either going to give us a return
value in which case we just set the
result to that value of the task or it's
going to give us a fault and exception
in which case we need to throw that
exception by calling set exception in
here all right that this code above here
this help preserves the stack trace
right that's a little trick you can do
to preserve the stack trace the original
one so it looks like it was thrown
locally now the other thing like what I
did was serialize the we needed to
serialize the here the type so how do we
serialize the type okay this is again
fairly simple there's two paths a fast
path and a slow path so this is a slow
path where this will work for anything
it writes rights either one or two one
for fast two for slow the slow one it
simply writes out the fully qualified
name of the type very simple this is a
thoughts about that long right puts the
assembly name and then comma in the full
type net but I want it to be really fast
so what I said as a compromise is is I'm
going to we're going to nominate we can
nominate one assembly as being the
assembly which contains all the types
I want to serialize really fast that
works for link bad there's only one
assembly that contains everything that I
need that fast serialization on so if it
happens to be that assembly then I write
the called the method artha toke and
that's integer and as long as the
assembly is identical on both sides
that's a really fast way to communicate
which particular type you want to
activate so what we can we can activate
objects now so the other thing I'm were
to look at now is how we how we call
methods so let's have a look at that so
we'll go to the know BM they'll be in a
method on here to send method call here
it is
so this is a send method call
let's find that
like I did I closed it and that yes till
early in the day for me okay here we are
synthetic or so food we do the normal
thing of getting the lock and asserting
safe we get the unique message number we
serialize the method called and get a
response future so pretty simple really
so let's have a look at what's in there
because that's that that's the
interesting stuff is that it's
serialized method call
so in here this is where we this is the
expression tree that we need to
serialize so we look to see whether this
is a method call expression because
there's really only two ones that we're
going to serialize a method call or a
simple property get accessor so though
that extracts the method and the
arguments from the method call
expression and this one here gets the
details that the method from the
property that we want to get otherwise
as only method calls of property reads
can be serialized now this is what the
message looks like we first write a
method we like to indicate that it's a
method call then write the message
number then we write the object ID so
I'll look into this in a moment so the
prot every proxy again has a number but
keep incrementing for all the proxy so
you have a proxy number to identify the
proxy this indicates whether it's
asynchronous or not the method were
calling then we serialize the method and
in the arguments okay so we'll look at
serializing the method first again
that's the fast path right if it's the
recognized assembly it will just write
the method data token otherwise writes
the assembly qualified name and then the
method metadata token now we'll go back
and look at how your serial I see
arguments alright because this is a
challenging thing we need to be able to
serialize absolutely anything I mean
needs to be really quick alright so I
came up with a really easy way to do
this so cool we serialize each one in
turn see realized value
and what we do is we check is it know is
it bull is it bite is it char so we have
these are the types I need to be able to
serialize really quickly to link that
simple type so we can obviously add to
that list if you want but these are the
simple types so we have a fast path if
it happens to be a simple type we're
just going to do this very simple code
write out the the type code and then
we'll write the object out using binary
writer simple and fast but the thing is
what if it's a complicated object
complex object how do we do that well we
do down here is we use the the binary
serialization engine we thunk down to
that now that's kind of slow but it
doesn't matter because what I do is it's
very simple if if I need performance
I'll make sure all the parameters are
simple types but if I happen to need a
rich object serialized and I performance
it's not critical then it still works so
we get so we get the flexibility and we
get performance you don't get the both
at the same time but that's not really a
problem very easy to work around that so
the only other thing we need to be able
to serialize are proxies so remember
when I talked about automatic
marshalling and I'm marshalling it's one
of those things is easier to code than
describe so this is the code
automatically Marshall and this is the
code automatically unmarshal so it's
really not too bad it's it's probably
easier easier to write than describe so
that's pretty much pretty much it for
the interesting stuff I should probably
look at these and do the proxies as well
there's a few more things that we need
so with these proxies and because they
automatically unmarshal it's possible
that a proxy might actually refer to an
object in your own domain so then you
need to be able to invoke that as well
so again I've got a fast path for doing
that so this is the fast devourer and so
I check is it a simple a very simple
kind of method call I've got a shortcut
for doing that otherwise I call the M
the invoke method on the
on the the reflection object which is a
bit slower so with that let's I think
that's enough for showing of code now
because I will go across side soon for
9:00 in the morning so we're gonna demo
it now so here's the demo that I've got
demo server and demo client so the demo
server sets up a fast channel name of
test true so it owns it and demo client
sets above channel with the same name
it's not the owner so this is the one
one party is the owner which creates the
buffers and the other ones not the owner
but they're both client-server really
there's no such thing as client-server
because that's really peer-to-peer they
can call each other so we're going to
wait channel to activate folks we're
going to instantiate a remote object
called foo on the other domain and
here's this is the remote object we're
going to instantiate we've got a
property to get the process ID we've got
an ADD method adds two numbers together
and an asynchronous version of that that
awaits for a second and then answer
numbers together so listen we're going
to demo that so first we'll activate the
through object we're going to ask for
its process ID and then we're going to
add two numbers together I'm going to
call the remote add method foo add two
and two and then I'm going to do the
async version of that right you notice
they both returned tasks they're both
async so we have to await each of them
and then we'll run that now and one
thing I want to point out is that this
is actually pretty much ideal when it
comes to the extra ceremony we got in
here because in order to call the remote
method we have to call we have to add
this extra stuff here onto there rather
than just calling food or add I've got
to put a weight through proxy eval foo
alpha Tara that's a bit of extra clutter
but it's extremely welcome clutter
because I remembered the problem I had
with remoting which was where there's no
clutter at all is it so it's so
transparent you don't know whether your
remoting or your locally right and I've
had I've had problems accidental
remoting right where I thought I was
locally and I'm actually remoting with
this it can't
this is really important because this
tells you everywhere in your program
where there is a potential remote method
call where you're crossing a boundary
and so this is actually a blessing to
have this bit of extra clutter in here
let's run this now see what we get and
it works a remote process ID is same as
our process ID because we're running on
the same process at the moment the sum
we're adding a two and two together and
then three and three to get that all
works so and that that's the code that's
running on the other end the other
process ID so to really test this
properly we kind of need to run it in
separate processes so let's let's clone
this a couple of times
so the first clone I'm going to just
demo the the demo server all we need to
do is put a console dot read line in
here let's do that so that's going to
run the server and then in the other
process now we're going to them at the
client and here we are so that all works
in the same way now so it's running now
on a different process ID write Fu's
process they've got to process IDs
happening now so good that all works and
final thing I want to show you is the
automatic marshalling and I'm
marshalling in there so now I've created
not just a foo but a bar as well right
so we've got class foo and we've got
class bar all right so the the bar the
bar class has a method that returns a
foo proxy right this is automatic
marshaling so all we need to do is put
new foo in here and it will
automatically convert it to a proxy of
food or Marsha it for us and I've got a
through print foo method takes a proxy
of foo
and we can call these methods seamlessly
now using this here is Marsha Lee so I'm
going to activate now Abbar and then I'm
going to call the method on the bar to
get a foo so I'm going to end up with
another food proxy and then I'm going to
call the add method on there all right
so we're going to go back to ourselves
so let's run all that and make sure that
runs to automatic marshalling and I'm
marshalling and that all works fine yet
this that's that code here so that all
works fine so here it is so you got all
the code you can download it it's not
too big and complicated and hopefully I
haven't I haven't you scared you too
much for a 9:00 a.m. talk so any
questions on that
okay the performance improvement was
over remoting was it was several times
oh somewhere five to ten times faster in
terms of latency which is the one I
wanted
so I programmed entirely I wasn't trying
to make it fast through plus four make
fast late it's you know someone got five
to ten times because of that underlying
lock-free pipe that I'm using and the
fact that there's a fast path in the in
remoting code but simple simple
scenarios if you're is returning a task
why bother having a synchronous version
at all because the difference is between
the synchronous and the async is that
you still need to be able to call the
different there's a difference between
calling a synchronous method on the
remote and an asynchronous method on the
remote end so the async method it has to
handle the reply differently so the row
at the remote end the synchronous one it
will get the reply straightaway whereas
the async one it will come back when the
task completes
just for the for the pipe is everything
you destroyed memory instead of reusing
it after it's done okay that's a very
good question
so what you're suggesting is that you
could like have a pool of yes you
definitely could so if you were very
careful on how you coded it the lock
free stuff will make that challenging
but you could certainly have a pool of
buffers that you recycle and that was
something I thought about
but because the design criteria was for
low latency and not high throughput that
wasn't a design criteria so I never had
I never got around to doing that because
it wasn't necessary for the performance
criteria but if it was if you wanted
high throughput as well then that would
be an excellent way to go is look at a
strategy for recycling the buffers
rather than creating new ones all the
time
okay well that's all the questions so
thank you all for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>