<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Seif Project   Douglas Crockford | Coder Coacher - Coaching Coders</title><meta content="The Seif Project   Douglas Crockford - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Seif Project   Douglas Crockford</b></h2><h5 class="post__date">2017-03-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lVezcdfjWis" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">afternoon I'd like to share with you
on the safe project the safe project is
solve a problem that we have there a
problem with the web you all heard of
the web I assume a web so the web is an
amazing thing it's really wonderful it
it has scaled to serve the entire planet
which is amazing and it's providing a
lot of value to humanity which is also
amazing and it's completely open so that
anybody who wants to can create a
website and that's amazing so
unfortunately there are problems one
problem is a web programming is slow and
unreliable which maybe is good for us
because it means full employment for web
developers but it could probably be
better than that the web is a document
retrieval system but it is not a secure
application delivery system which is a
problem because that's how we're using
it we're mostly using the web as a
secure application delivery system and
it's not working
it's not secure it's problematic and
we're securing the web with passwords
and passwords don't work for people
passwords are easily guest forgotten and
stolen they're not an effective way of
securing systems the original computers
were secured not with passwords but by
men with guns and I was really effective
and that style of security worked until
we began networking when it became
possible to access a computer without
having physical access to the computer
and security suddenly became a big
problem and the first time sharing
system that encountered this problem
solved it by adding a password it was
unlikely that anybody would have more
than one time sharing account and a
person can remember one password so that
worked pretty well when personal
computing started again there were no
passwords and that worked fine until we
started networking there personal
computers together and then that became
problematic so then we see passwords in
our pcs and we repeat the same thing on
the web originally the web doesn't have
passwords but later it acquires them
and good security requires that every
relationship that we have has a separate
password how humans can't remember that
many so security was not considered in
the design of the web so the first time
we see any mention of security with
respect to the web is in the RFC which
introduced the concept of URLs and that
document included the description of the
syntax for a URL which contained a
password which would be sent in the
clear at least one of the authors of the
RFC recognized that this was a really
bad idea and he added the sentence the
use of URLs containing passwords that
should be secret is clearly unwise which
is an amazing piece of understatement
but lacking a better alternative that's
what they published and there were some
people who tried implementing this
that's RFC and quickly discovered in
fact why it was so and wives so I want
to fix the web but in order to fix the
web we first have to look at what is
wrong with the web and the things that I
think are wrong with it are its
insecurities and much of its insecurity
is due to its complexity there's a lot
of unnecessary complexity in the web and
whenever systems get too complex it's
likely that they're going to be insecure
as well so I want to look at some of the
major systems in the web and critique
them and look at what's wrong within
them how we can improve them but in
order to do that we really have to look
at the web and look at what's wrong with
it and this is going to be shocking and
upsetting to many of you that you've
spent your whole careers doing nothing
but web it's what feeds your family it's
how you define yourself and I'm going to
say terrible things about the web I'm
not talking about you okay this is not
about you this is an objective view on
technology so let's start with HTTP the
hypertext transport protocol you can
view HTTP as being several things first
it's a format a text format
for expressing key value pairs it's a
rather fussy format I think there are
much better formats available for doing
keys and values it's also a negotiation
protocol the early web browsers were
incompetent in terms of media types and
other assets so you might a browser
might ask for a picture but the picture
might come up in JPEG or ping formats
that that browser didn't know how to do
and so there'd be a negotiation that
would happen between the browser and the
server so they can try to figure out
something that the browser could it
could accept and that negotiation still
goes on even though it hasn't been
necessary for maybe a couple of decades
now it then ultimately the most
important thing that HTTP is is a
request response protocol because it was
intended to support the delivery of
documents so a user agent will request a
document it will send a URL and the pain
it'll wait and the response will come
back to the server and that's ready to
do the next thing and if all you're
doing is simple document retrieval
that's completely adequate but that's
not how we do things today because we
might have dozens maybe hundreds of
assets within a single page and using
the HTTP protocol we would go and ask
for a script or an image or a stylesheet
or whatever and we wait in a response
comes back and then we can ask for the
next one and we wait and so on and so
this can be really really slow so
browsers mitigate this by opening up
multiple HTTP connections to the same
server so that we can have some
interleaving going on so that we can
bring the assets in faster but that's
adding more unnecessary complexity then
there's DNS the domain name System DNS
was created with good intentions to make
it easier for people to assign names to
IP addresses because expecting humans to
use IP addresses to connect to computers
had serious problems and so if we could
assign names then users can use those
names and we have them
that are trying remembering that kind of
stuff unfortunately domain names have
turned out to be equivalent to
trademarks but the domain name system is
extremely incompatible on a legal basis
with trademarks and so there are legal
problems that go on constantly
they're also DNS is subject to security
problems there is domain squating and
similar names which caused confusion
attacks and also there are problems in
DNS itself with DNS poisoning and other
exploits there is SSL secure socket
layer this is something that was
developed by Netscape because they
recognized that they needed some form of
link encryption and authentication in
order to do electronic commerce
unfortunately the scheme that they came
up with is way way too complicated very
very difficult to implement we are still
finding serious drastic problems in
implementations of SSL and its
successors 20 years after the thing was
introduced if it had been a well
designed thing then we should have
converged on something that's correct by
now and we haven't as it sells much too
complicated the thing I like least about
SSL its its dependence on certificate
authorities certificate authorities are
private agencies which for a fee will
generate a cryptographic certificate
which asserts that some thing is
associated with some other thing usually
the name of a company or domain with
knife with a public key or something
like that
so I don't trust this system the
principle company behind this stuff is
Verisign and should I trust Verisign I
don't know I don't know what goes on in
that company I don't know why I should
believe that that company should be the
root of all trust but even if I trusted
them there are hundreds of other
certificate authorities which your
browser trusts equally many of whom have
been corrupted and
and who knows if the others have been
corrupted yet we just don't know so I
don't like having to depend on things
that I cannot possibly know
then there's HTML the hypertext markup
language is HTML a good thing or a bad
thing well it depends on what you're
trying to do if what you're trying to do
is to create a simple technical document
and be able to present it on someone
else's screen it's really not very good
it the HTML language is fussy and and
difficult to write it's why we invented
markdown languages Wikipedia works
because it accepts markdown languages
which are much much easier for people to
deal with than HTML now on the other
hand if what you want to do is create a
container for the delivery of secure
applications it's really awful
because it wasn't designed to do
anything like that and a lot of clever
people have figured out ways to try to
make it do that but it's not really fit
for that purpose and that's why a lot of
the things that we do are much more
difficult than they should be
we've spent a couple decades now trying
to figure out what's the best way to
write applications that are delivered in
the form of HTML and the thing that
seems to work the best is templating and
I really don't like templating
templating is the attack vector of XSS
attacks and while it's possible to do
templating without subjecting users to
XSS attacks nobody seems been able to do
that yet XSS seems to happen almost
every day it's also a trap that if
everything is directed toward HTML
everything becomes HTML you know the
server has become dependent on HTML
database has dependencies in HTML
everything is HTML we're never going to
get rid of it then there's the Dom the
document object model this is one of the
worst API is ever imagined it's just
really difficult to use it's really
fussy it's not nearly portable enough
it's at the wrong level of abstraction
it's way way too difficult it's also
horrendously insecure because every node
is linked to every other
so if an attacker can get access to any
node they get access to everything and
there's CSS crappie style sheets I don't
think I need to tell you what's wrong
with CSS and then finally there's
JavaScript JavaScript is a hot mess
javascript was designed in ten days it
turns out you can make a lot of mistakes
in 10 days but there is some brilliance
in this language which is surprising and
amazing remarkable but in fact there is
some goodness in it so I'm not the first
person to have observed that there are
these problems in the design of the web
and suggested that we could do better in
fact Microsoft Apple Adobe Oracle and
many other companies large and small
have all looked at this as an
opportunity that they could create a new
platform that could displace the web and
turn it into a proprietary system or
replace it with a proprietary system in
most cases the technology that they were
offering was clearly a superior
unfortunately in most cases the
solutions they were proposing were not
open they were trying to capture the web
and so I'm glad that they all failed at
capturing the web because the fact that
the web is open is the thing that I like
the most about it that anybody can
create a presence on the web and do
stuff and they do not have to make a
deal with any other company they can
just do it and if they can get attention
then they can be successful with that
they don't have to share their revenue
or pay fees or taxes or guarantees a
tribute to anybody else and I really
really like that
so whatever else happens with the web or
attempting to replace the web I hope it
has that same property so the reason the
other systems the other neo webs or web
replacements didn't succeed wasn't
because they weren't better because I
think all of them were better it's that
they didn't have an adequate transition
plan so later on though I'll show you my
clam and
and hopefully you you think it's a
better plan than what they had their
plan was to convince you if they can
convince the developers that they had
better technology than they would win
and that turned out not to happen so my
plan is to upgrade the web I don't want
to replace it I don't want to capture it
I want to keep it doing the things that
it does well and in fact there are some
things that the web does extremely well
and I don't want to change any of that
in any way what I want to do is to fix
the things that it doesn't do well so
that brings us to the safe project the
safe project is a radical minimal secure
open system its arcs architectural II
very different than the old web but it
can be delivered through web browsers so
the user experience should not change
customers are not given passwords in the
state system which eliminates one of the
biggest sources of insecurity because if
you don't have a password you cannot be
tricked into revealing your password and
so we get much greater convenience and
and much greater safety instead of using
passwords we're going to be using public
key cryptography for authentication and
we're not going to be using certificate
certificate authorities because they're
not trustworthy
so we're doing the safe project in five
steps five parts I'd like to show you
each of the parts so part one is safe
node safe node is a module and encrypted
graphic services to no js' it provides
it's not a complete general-purpose
cryptographic library it's only
providing the services that node itself
needs which includes elliptic curve 521
which we use for authentication and key
exchange
AES 256 which we're using for block
encryption and sha-3 256 which we're
using for secure hashing we're also
providing a very good source of random
at one place where many secure systems
have fallen is that the quality of their
random numbers we're not good enough and
so we're taking a lot of attention to
make sure that we get sufficient
randomness way we're doing that is we're
providing entropy collection services so
we're going to harvest entropy from the
operating system if it if it has some to
provide but I don't trust operating
systems to provide us with enough
entropy and so we're also going to use
your microphone so with your permission
we'll open your microphone for a few
seconds just to listen to noise we're
not going to record it we're not paying
any attention to it we're just going to
take all the noise that we see and hash
it and try to produce some entropy from
it
we'll also do the same thing with your
camera with your permission we'll turn
your camera on we'll observe a couple of
frames again we're not even looking
we're just looking for noise and the
signal and we'll take that noise and
we'll harvest it and then save it and
that will become the basis for the
random numbers that we're going to
generate we need that randomness because
we're going to be using a lip to curve
521 public keys as unique identifiers
and the way that you prove that a public
key is yours is that you have a private
key which corresponds to it and we want
you to be able to generate that key pair
yourself I don't trust anybody else to
give you a key pair I don't see a secure
way of doing that so instead you're
going to make your own key pair and
we're going to give you the tools which
will allow you to do that securely and
in order and we want these keys not just
to be unbreakable and unguessable we
also want them to be globally unique and
521 bits with sufficient entropy I think
we can do that there's a very smart guy
named Zuko as a theory about means you
identified three useful properties of
names and thinks that you can get it
most two of them in
name so um uglies the web decided to go
with human meaningful at least to the
extent where you think a URL is human
meaningful I'm work concerned with
security so I'm taking the other two I
want to have names which are securely
unique and that's why we need the good
entropy in creating the keys and also
globally decentralized which means that
you make them yourself there is no
global registry which will assign these
numbers you create it on your own but
the consequence of that is that they're
going to be huge things which will not
make sense to humans part two is the
safe protocol the safe protocol is
secured JSON over TCP and unlike HTTP
which is design designed to do document
retrieval the safe protocol is designed
to implement efficient sessions so it
wants to send messages and receive
messages and a message doesn't need to
be responded to and messages do not need
to be requested you just if the server
has something to say it'll just say it
and say as many things as it needs to if
the browser has something to say
it will just say it and not necessarily
wait for a response
so cryptography is used in the
implementation of the safe protocol and
to review we use two forms of
cryptography there's symmetric
cryptography in which the same key is
used for both encrypting and decrypting
and we also use a symmetric or public
key cryptography in which a different
public key is used to encrypt any
private key is used to decrypt so this
is the handshake that we use to create a
secure connection on the safe protocol
so at the beginning we have Alice and
Bob who are about to connect to each
other
Alice has a public key and a private key
Alice knows her probably key because she
is Alice and we hope that nobody else
knows Alice's public key Alice also
knows Bob's public key maybe because she
got it from a directory or or some other
source then bob has his home public key
in his own private key
he has his private key because he is Bob
Alice then generates a random handshake
key this will be a completely random 256
bit key which were going to use for
handshake and she creates a message
which will get sent in the clear it's
just a JSON packet first identifies
itself as a safe message and the version
of the protocol that we're using at
first is version 1 eventually we may
discover problems in in something you
know maybe in the cryptographic
algorithms or something and we'll have
to upgrade to stronger crypto in that
case we'll become safe 2 then we also
send the handshake key encrypted with
Bob's public key and we use the
handshake key to encrypt Alice's public
key and that gets sent to Bob Bob
receives that message and because he has
his private key he's able to decrypt it
and recover the handshake key and now he
has a handshake key so he's able to
decrypt Alice's public key so he now
knows who is trying to connect to him if
he has already a relationship with Alice
now he now knows this is Alice and so
there's no additional login needed so
Bob now generates a session key this is
another 256 bit key and he uses that to
create another message so he creates a
method or he creates a JSON message
which will contain his session key
encrypted with Alice's public key
and that entire message will be
encrypted with the handshake key that
will then get transmitted to Alice Alice
has the handshake key so she can decrypt
the package and she has her private key
so she can decrypt the session key that
session key will now be used for all all
remaining messages in this session we
have just set up a secure authenticated
connection in one roundtrip which is
pretty close to optimal so it's a very
very little overhead it has very nice
security properties for example a man in
the middle cannot see what's going on
unless he has access to both private
keys the safe protocol is a full duplex
protocol meaning that either party can
send at any time and they don't have to
wait for the other to respond before
sending the next message this will allow
us to take much better advantage of the
network and they have higher performance
applications we provide two forms of
message send there's the normal send
which will have automatic persistent
retry so it's it's not guaranteed
delivery but as good as we can make so
if there's a network partition which
happens fairly frequently in and mobile
applications we will persist those
messages and we will attempt to resend
them when the connection is
re-established there's also a status
send which is provided for telemetry and
gaming which will just send the latest
version of this message and if it fails
to go through we don't care or if we
start to get behind we'll throw away the
old messages we just want to send the
last one this was most applications
don't want this but games and control
panels and things like that really want
to see the current value and don't want
the current value delayed for values
which are no longer of interest
part three is safe resource management
so this will be a system for accessing
resources by hash codes the initial
motivation for this was secure delivery
of programs but we're going to use it
for everything
so any big any blob that you want we'll
take the cryptographic cache of it and
that becomes the name of the blob so if
you ask for that then we will deliver
that thing and the thing that you
receive has to match that hash code
otherwise you know it's been tampered
with one of the nice things about this
is that it doesn't matter where you get
the blob so they're really interesting
opportunities for for caching and
distribution so it's a very efficient
and very safe way of distributing
resources part four will be safe apps
it'll be an HTML free JavaScript based
application delivery system built on
nodejs
and cute and you guys know cute cute is
an application system that was developed
in Norway it was part of Nokia for a
while it is now an open-source thing
it's brilliant it's a really nice way of
making apps and we're going to be using
that in order to make things in the node
system so here's the block diagram so
say zap has two parts
there's the mode part where we do logic
and connection and persistence and the
cute part where we do user interaction
and display and we have very strict
separation between those two aspects so
the node server that we're using here
where we're using node as a client here
and we've stripped it down considerably
so we've removed almost everything from
node except for the event loop and the
HTTP stack I'm sorry the TCP stack we
removed almost everything else including
NPM
because we're trying to make this very
very secure and so in order to do that
we're trying to make it very simple and
NPM doesn't match our security level
because NPM wants to allow anybody to
load anything from anywhere that can do
anything and if you're concerned about
security you really don't want that so
we're going to have a different way of
loading stuff based on the es6 module
manager each of each half of the node
half in the Q calf will both be running
JavaScript engines each will have its
own adventure on its own thread so both
be running simultaneously and they
communicate through adjacent channel we
can post messages from one to the other
even more interesting we can allow
presences from other parties other
companies to be running in the same
environment interacting with them so I
can have I can do mashups and I can
finally do them securely so I can have
another site involved in the application
with confidence that it can't corrupt us
and we can't corrupt them but we can
communicate and cooperate in order to
serve the user I think that's going to
be one of the most important aspects of
this system we're also going to be
providing crust management because we
know that humans cannot manage 521 get
keys and so we allow them to assign pet
names to them and we will store them for
them will allow them to put them in the
cloud but they'll be properly encrypted
in the cloud so that no one can get
access to them except themselves and
that they can be shared over all of
their devices so if you have any device
all of your devices will be able to
share all the relationships that you've
had in the safe system then part 5 is
the safe helper app this is where we
take the safe app and turn it into a
helper app that can be run in
a web browser anybody remember help her
apps maybe I even the old guys so when
the first when Netscape first came out
Netscape didn't know how to do a lot of
things so that they had a concept of a
help wrap like if you want to display a
JPEG and that scape didn't know how to
display JPEGs um you could say when you
see a JPEG open my paint program and my
paint program will display the JPEG it
turns out that interface is still in all
the browsers it still works you can go
into the control panel and you can find
it so we're going to use that initially
so um so this will allow you as
developers to download our helper app
and integrate it with your browser and
then you can see what it's like to run
safe in your browser now I don't expect
normal people will do that in fact I'm
pretty confident normal people won't or
can't do that but it's um that'll be
sufficient to allow you to get an early
look at this eventually we'll want the
browsers to integrate it but there are
some things we have to do first so
here's my transition plan this is why I
think the safe project can be successful
so step one I need to convince one
progressive browser maker to integrate
the safe helper app into their browser
it should be an easy thing for them to
do because we don't need to be tightly
coupled to the browser all we need is a
rectangle where we can put our pixels we
need access to UI events and we need
adjacent channel where we can talk to
the browser and send messages back and
forth that's all we need so it should be
pretty easy to do that I don't know
which browser maker will will do that
pretty confident won't be Apple and
probably won't be Google it might be um
Mozilla Mozilla used to be the
technology leader in the web but they've
fallen way behind in recent years just
because they can't afford to compete
with these other really rich companies
but this might be a way for them to kind
of leap ahead and they might want the
opportunity might also be Microsoft
Microsoft was also a technology leader
in the web and they also fell behind and
recently they've been doing they've
gotten back up in terms of technology
you know they're like the edge stuff is
really really good and nobody cares
it just doesn't count it's likely they
didn't do it so they might be looking
for some way to get some credibility to
get some recognition for what they did
so maybe you don't want to do this too
so hopefully we can get one browser
maker to integrate then we have to
convince one secure site to require its
customers to use that browser so it
could be a bank or financial institution
or a healthcare institution or a
government or somebody who is scared to
death of doing business on the web but
is having to do it because that's where
everybody is who are looking for a safer
alternative and if we can convince one
of those to try this then you know we'll
have completed that step then risk
mitigation will compel other secure
sites to do the same thing and I liken
this to penguins so you know penguins
are on the ice and they get they've been
out there all winter and they're getting
really hungry and they're looking over
the edge and they know there are fish
down there and they want to jump down
and eat the fish but they also know
they're leopard seals and sharks and
things down there but eat penguins and
so they're really cautious and they all
walk up to the edge and they're all
getting closer and closer and pushing
pushing and eventually one of them slips
and falls in and then everybody looks
and if he comes back up then they all
jumped in so I'm hoping this will go
like that if we can convince one company
or one project to do this and if it's
successful I'm hoping them others will
want to do that as well if that succeeds
then competitive pressure will move the
other browser makers
to do that as well not everybody wants
to be first but I don't think anyone
will want to be last so if this turns
out it's actually going to go I think
everyone else will want to implement it
and then the world will follow for
improved security and faster application
development so everybody who's doing
applications which could benefit from
the security that SAF provides will want
to do it as well also they might want to
do it just because it will be an easier
application development model but
nothing breaks so we're not suggesting
that anything which happens now stops
happening in fact the way that the web
works for providing introductions is
brilliant
and they don't want to change that the
way the web works for searchability is
brilliant and I don't want to change
that either but once you have
established the relationship once you're
committed and you want it to be secure
and secure then safe is the way you want
to go so whenever you're talking about
software security there are obviously a
lot of difficulties involved you have to
make it do what it should which is
always a problem with software we rarely
get that right it shouldn't do what it
shouldn't that turns out to be even
harder and that's below that the big
things we have to do with secure
software so making boasts that yeah
we're going to knock this thing out and
solve all the world's problems it
usually doesn't work that way no
software is initially secure and I don't
imagine ours will be either even though
we're working really hard to try to make
it so I expect that we will be very
embarrassed when the stuff comes out
because there's stuff that we'll have
overlooked or screwed up and we're
hoping that you'll point it out very
quickly and pleasantly and then we'll
fix it and I'm hoping eventually we
converge on something which is secure
enough I think only a minimal approach
can do that up until this point we've
been seeing maximal approaches and the
maximal approach does not seem to
converge on security
so there's nothing new here there's no
new science no real invention much of
our model is based on object capability
theory which has been around for many
decades
we're just factoring it and turning it
into something which we think can work
practically in the modern web so this is
where we are we finished part one so
part one we published a couple years ago
we unveiled it at oz calm safe protocol
we introduced in 2015 also a different
house con and so those are both open
source and freely available and you can
go out to github and look at our stuff
if it makes sense to you you can adopt
it I'll use it for any purpose you know
it's a completely open and unrestricted
license if you'd like to help us we'd be
very glad to have your help we're
currently working on the safe resource
management system and hopefully we'll
have something to say about when that
will be available and then we'll
continue working with the safe apps and
the safe helper app so if you want to
see the stuff you can go to safe place
and that will direct you to github so
the goal of the safe project is to
provide safe and effective relationship
management on the web and because of our
particular approach I think there's a
chance it could work so please check us
out thank you very much
so we have some time for questions if
there any questions yeah so how will we
know if we succeeded um you know and
when we don't let us plan B I think that
well my end goal is to build the whole
thing but I think the safe protocol
could have applications immediately you
know I think maybe the Internet of
Things wants to be connected over safe
and not over HTTP so it may be that that
you know we can salvage one chunk out of
it and get that fully deployed before we
can get the rest of it done and you know
there may be other spin-offs of the
project which are also beneficial even
if the entire thing doesn't find it
option
yeah he's asking why didn't we go to
mobile roots of making the safe Apple
mobile framework because the the mobile
environment isn't as open as we like and
we're going to try to push for the open
thing first if we fail to get an option
in the open thing then maybe we'll try
to go in to the marketplaces but that's
the way we're going right now
yeah we're not religiously focused on
anything we're just trying to be
pragmatic and so that's why we're going
if it turns out plan a doesn't work then
we'll certainly look at Plan B and then
C and E however many letters are cakes
yes but if I understand it correctly you
could also implement a protocol using
other languages
sure state protocol is completely
language agnostic you know it's Jason on
TCP so yeah we could do that with with
anything and so we're working on
bindings to Java and iOS because we want
to enable exactly that yeah it um yeah
the javascript is dependency doesn't
happen until you get up to level 4 so
levels 1 2 &amp;amp; 3 are JavaScript
independent that's implementation but
basically it's just a crypto library and
you could have most of the crypto
libraries taken from other open-source
sources and so you could very easily in
fact we're doing that we're implementing
it for other platforms we're starting
with node because that's where we live
but yeah ok yeah
so we're going to be instead of using
CSS we're going to be using the
presentation capabilities that are built
into cute have that stuff's problem or
programmatic and I think it'll just be
an easier thing for us to deal with CSS
was not designed to do the stuff that we
do is designed for document formatting
and it's really a struggle getting all
the rules to line up and CSS was
designed with the assumption that there
would be a single author or designer
responsible for the entire document but
that's not how applications work we've
got lots of things from ups of sources
and what they all have to get integrated
and doing that in a way where the Styles
don't conflict with each other it turns
out to be way way too hard so we think
we can back off of that and come up with
something that's much more
straightforward
yes yeah so we need to be able to
upgrade the encryption in the future I'm
not confident that the quantum computing
thing is going to work out but if it
does where if there's some other problem
and we find that the algorithms that
we've selected are not going to be good
enough then we're going to have a
transition plan so using the safe flag
and the initial message servers we'll be
able to say you need to be coming to us
at this level or not oh we're going to
be much more coarse than SSL has been
SSL has a negotiation framework built
into it where both parties can agree on
what level of cryptography they want
which serves the man in the middle
because the man in the middle can say I
want the weakest thing available and so
they can dictate that we're not going to
be doing that so we're going to be much
more brittle so I think we can manage
that I don't anticipate that we're going
to have to change crypto levels very
awesome I'm hoping it's going to be a
like a once in a lifetime event not
something that happens every year yes
so I think moving away from HTML that I
think that's been a trap and so how it
would get rid of that having to of that
loops I think is going to to be
interesting so you don't have to worry
about as much about stuff blocking in
either loop because all the stuff is
independent of all of that stuff and
because we have enforced separation
between state management and
presentation it's going to force cleaner
application architecture than we see
currently where you see logic somehow
getting into the display layer and all
of that stuff so we're going to force
separation there and so I think that
will also lead to better development yes
so of who I have in mind to be the first
application that runs yeah I have
someone in mind but how I got it would
be unrealistic for me to ask them or
anybody to commit at this point because
we're still vaporware and so until we're
much further along it'd just be
irresponsible for me to even have that
conversation so you know ask me in some
unspecified time in the future and love
maybe I can give you a better answer
anybody else okay I think we're done
thank you
oh and don't forget to drop a green card
on your way out</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>