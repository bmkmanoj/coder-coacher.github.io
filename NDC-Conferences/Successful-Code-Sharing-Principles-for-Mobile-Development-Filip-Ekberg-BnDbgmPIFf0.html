<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Successful Code Sharing Principles for Mobile Development - Filip Ekberg | Coder Coacher - Coaching Coders</title><meta content="Successful Code Sharing Principles for Mobile Development - Filip Ekberg - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Successful Code Sharing Principles for Mobile Development - Filip Ekberg</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BnDbgmPIFf0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">one enjoying the conference so far we're
just looking forward to the party I see
some of you already have gotten your
beers some really jealous the Tilden I
wasn't allowed to grab a beer here on
stage so I'll wait so we're going to
talk about some successful code sharing
principles for mobile development how
many of you are doing stammering most of
you are doing salmon that's great
because we're going to talk about salmon
and how we can build better apps
when using salmon as the technology to
target all these different platforms so
I've been working with salmon for a
really long time and I find that I
always struggle to appropriately
architecture my apps so that I make it
easier for me to share codes across the
platforms so I'll talk about a few
things in this talk here around how we
can make it easier for us as developers
to share more code across the platforms
and some of the pitfalls that we might
fall into and I tend to do all these
things incorrectly a lot of the time so
I'll talk about this from my perspective
and things that I've learned when
failing to collapse so before we do that
let me introduce myself I'm Phillip
Ekberg I'm a c-sharp actually I'm a
Microsoft and salmon MVP pretty much
means that I go around to conferences
and talk about all these amazing
technologies doesn't really mean that I
know how to build an app I just talk
about how to do it but yeah I leave the
building apps to you everyone in here so
what I'll do since there's so many
handsome people in here how about you
snap a photo sometime in this talk you
tweet that and I'll give you a free copy
of my book a digital version sounds fair
and also remember to put a green thing
in the box that'll make me really happy
all right so now that we got that out of
the way let's talk about successful
co-chairing principles the idea of
sharing code across the platforms can
seem easy on the paper but when we start
building these salmon apps you know it
can start to grow in the plot for
specific projects and we end up having
code bases that are really fragmented
across the different platforms and we
just want to make sure that we can take
our code base and make the best off out
of it so I was thinking about this when
I started preparing this talk and I
think a more appropriate you know title
for this session is more or less how to
build unsuccessful apps because from my
point of view I try to build the best
apps positive
and I try to apply some patterns and
principles to make it easier for me to
do that but even if I use these patterns
and principles I end up sometimes
failing to share a lot of code across
the platforms and most of the teams that
I visit and talk to about stammering I
see the same patterns and behaviors that
we fail in sharing code across the
platforms because we try to focus too
much in actually building an Android app
or an iOS app and we don't think about
what's common between these two apps so
for those of you that don't know it's a
- the the short sales pitches that we're
allowed to build an app that's running
on every pretty much any platform we get
a native binary that allows us to access
all the native API to get native
performance but that also means that we
need to learn about the native platform
it sounds like the room next to us is
having a lot of fun they're just
cheering for me they were watching the
livestream that's what happening there
all right so salmon is all about
allowing us to build apps for all these
different platforms right and it allows
us to do that by splitting it all up
into nice little boxes so most of you
has probably seen some of this before so
we have these platform specific projects
that allows us to build the app for iOS
Android and maybe Windows and hopefully
in the future even like a toaster or
your your refrigerator or whatever we
want to build the app for as long as it
allows us to build an app for that
platform we can probably use salmon for
it especially if there's like UI so the
promise is that we can share a lot of
code across these platforms in this
shared application logic layer and we do
that by introducing PCAs and shared
projects and maybe we get a nougat
package into our solution to make it
easier for us so this talk isn't an
introduction to stammering it's more
about how do we go back to the basics
and learn about the patterns that make
it easier for us to share code across
the platforms and when I find happening
in the apps that I normally work on is
that we end up with an architecture
where you know there's a larger portion
of iOS code and maybe there's a little
bit less Android code and the Windows
one is pretty much non-existent unless
we have a manager that owns the Windows
Phone because then we need to build a
Windows app right but sometimes what
might happen is that we have an iOS
developer that's very keen on building
for iOS and knows all about building
widgets and all the cool things you can
do in iOS and then maybe we have a
c-sharp developer that just learned how
to build an Android app and they don't
know how to do all the cool things on
Android so that means that we do a lot
of work in the platform specific layers
so what we want to end up doing is kind
of avoid putting too much code in our
platform specific projects so normally
me myself I feel the urge sometimes to
just add things into this platform
specific layer or code that's not shared
across the platforms just because it's
easier sometimes it feels like I'm
taking a task to start building a new
view in my app and I start building that
for one of the platforms and then when I
go on to the next platform at the lit
again and I don't go back and look at
the code that I just built rather than
just you know breaking that code out so
are you all familiar with the red green
and refactor practice so you build a
test first like in test-driven
development the test fails you fix it
and then you refactor the code so I'd
say that we apply the same principle
here that if we start building the UI
for Android when we go to iOS and be
able to save UI there go back and look
at the build for Android break out the
common things for for the UI logic right
what happens when I click the login
button now the logic if this person has
entered a username and password that's
the same on all the platforms so we can
make use of these really simple
practices to make it a lot easier for us
so if we take a look at a current state
this here is going to be an application
that I started out of Visual Studio for
Mac so I simply set up a totally blank
application and this application is
allowing me to build on iOS and Android
app it's built by using a shared library
which allows me to write code that's
accessible in all these different
platforms now since this is an
out-of-box application you'd think that
they applied all the best practices
right
well if they did I probably wouldn't
show the code right so we have this code
example here it's son Android
application and an iOS application and
then we have this shared project up here
at the top now the shared project is a
way for us to share logic across these
different platforms
a shared project is simply a way for us
to say that well when it's compiled
bringing all the files and compiled that
as a part of our project that gives us
the capability of building code in one
place that compiles for that particular
platform so for instance if we're using
sequel I'd I want to have access to a
database I want to have the you know the
common pattern of a repository pattern I
build that inside my shared project and
then I tell my iOS project and Android
project to bring in the libraries for
sequel Lite and then my shared project
is just going to know how to talk to
sequel Lite that's super simple right so
that's the idea of a shared project and
what we can see in here what they've
done is that they've broken this up into
smaller pieces which allows us to follow
a pattern called mvvm even though the
native platforms like iOS and Android
aren't really using those patterns if
you work in Java or Objective C but the
idea here is that we take that UI logic
we bring that into the shared code so we
have these things called u models right
so we'll get into that a little bit more
later on but looking at this structure
here it feels like well this is the holy
grail of the architecture of an app most
of us probably don't work in an
application that's layered like this
here I know that I've been in a lot of
projects where this has been like the
goal to reach this shared code here so
most of us might work in project first
there's a lot of code in our native
projects and the idea here is that
they've built an iOS app this is a an
Android native init and native iOS
application they've rebuilt the UI for
each platform and then they simply broke
out a little piece of the UI logic and
put that in a shared project but most of
us might not have that luxury we might
work in applications that have a lot
less share code on this year so the
reason that I'm showing this example
here is because it would probably be
pretty hard to follow a demo where I
wrote a lot of crappy code right even
though I probably write practically
pretty easily
it will probably be hard to follow so
the idea here is that we use this shared
project and things like if we look at
one of the activities here we'll see
here that in this activity all they've
done is that they say well if you're
logged into the app
to show this screen here if you not like
then go over here so I find it that well
why didn't they apply the same
principles here because this part here
is something that's probably common
between those ios and android and would
be coming if we build this app for
Windows as well so this is where I find
that well I'm as I as a developer might
find the urge to add this type of code
because it's just a few lines right but
I start adding these few lines for each
platform and then well what happens if
well we need to go in here and when
you're logged in I also want to you know
add something to the database and then I
want to ping google analytics and so
forth right so this thing here starts to
grow and this is where we start to have
a little bit of problem so once we start
not breaking out our code even though
it's small samples we need to think
about how we can make it better if we
want to expand on the code later on
right because all of this could grow out
of proportion
all right so this is the current state
of the app let's just run it and have a
look what it what's currently looking
like and we'll add a few patterns and
practices to this app throughout the
talk and we'll see how we can make it
better and how we can add patterns and
practices to make it easier for us to
add functionality and do it more
testable and maintainable so here it's
now running on it on our Android
emulator I'll I can click here that
don't want to login it will bring up
this app here and this here looks like a
beautiful app and hopefully they've
shared a lot of the logic like where do
we get these names from how do we add
things what's the data store all of that
is hopefully shared code right so let's
just have this as our current state our
application is pretty good but we know
that we can make it even better so let's
start to talk about how we can do that
and the reason that I'm talking a lot
about why there's a problem with the
current app that we're looking at here
and the reason that we talk about how
hard it is to share code is because
that's a really good way for us to
understand the difficulties in code
sharing appropriately across these
platforms so why is it so hard for us to
share code across the platforms
now this thing here might seem a little
bit impossible to solve and so is
co-chairing the reason that it's so hard
for us to share cut across the platforms
is because iOS and Android and Windows
Phone and hololens and all of those
different platforms are totally
different right but then if we go back
one step from the UI and think about
well there's still some logic happening
on all these different views we have
different representations on all these
different platforms we might have the
surface hub which is an 80 inch big
monitor allows us to do touch on the
screen that one might have a particular
UI but if we think about how we approach
the problem which is the app that we're
building we might find that we can
follow some common practices across all
the different platforms so if we're
working with hololens and you know the
Android watch and iPad they might have
different UI but then again they might
have the same logic behind that UI so
even though it might seem like it's a
very hard way or easy way in this case
here to find our way through this maze
we know that when we start the project
we're going from point A to point B and
we simply want to get out of this and
any given project we we face problems we
need to go back and take a different
turn to make it easier for us to build
the app but when we're building mobile
applications what I find happening quite
a lot is that we end up with a maze
pretty much looking like this here I
don't even know where the end is so this
might be a little bit difficult for us
to simply solve and there's so many
different paths that we can take when
building apps as an example when we're
building Android applications to rebuild
the UI using Android XML do we go into
the activities and simply build up all
the controls ourselves some might seem a
little bit easier to just build it using
XML so let's jump over to iOS how do we
do it on iOS well we'll keep snip file
we can use storyboards we can use code
behind in our view controllers and I
promise you I've seen projects where we
you know do all of them at once we have
some nib files over there we have some
storyboards over here and then we have
some code here in our view controllers
but that's UI code right but we also in
that
case if we have a bad architecture for
the UI we probably have a bad
architecture for how we share code
across the platforms so when we working
with salmon it's alright to feel like
this sometimes especially when we're
building apps because remember we try to
target so many different platforms we
try to build an app that works really
well on Android iOS Windows hololens and
our watches and all of those different
platforms so you know you might find
yourself wanting to add a little bit
more code to the platform specific
layers but if we think more about how do
we solve this for all the platforms
that's when it starts to get interesting
so we talk a lot about now what the
problem is but how do we sold it how do
we make sure that our apps can be better
and that we can share more code so we
can do abstractions now I'm not going to
jump around like Steve Ballmer and
screaming abstraction abstraction of
abstractions even though that would
probably be a bit funny but what happens
here is that we can introduce abstract
classes we can introduce interfaces that
we can make sure that we can share more
code across these platforms we can go
back to the basics and look at patterns
and practices that have been around for
a long time and just think about how do
we apply this in salmon now I know a
dependency injection inversion of
control might not be available if you're
working Java on Android out of the box
but we can still use frameworks to allow
us to achieve the same thing so one
thing that I find happening when we do
this so I want to introduce a shared
project and one thing that I find
happening is that we end up in a
situation looking like this here so for
as I mentioned we might have UI code and
storyboards the nib files for iOS and
then we have something different for for
Android and Windows and then we try and
our bests in building these shared
layers we have a shared project that
compiles for the platforms and then
inside the shared project I just want to
do something specific for a particular
platform on Android I might want to do
something different when I talk to the
the keystore keychain right so then what
happens is that we leak information
about our platforms inside the shared
projects and then we're back at square
one
so what happens here is that we try to
build UI
specific logic inside the shared code
our shared code logic layer grows but
that doesn't mean that we shared more
code so we end up in a little bit of a
mess here as well so we look at how we
can avoid this as well and one way to
achieve the goal that we want is by
looking at introducing different layers
so we can introduce a native layer which
is the iOS Android Windows app or if
you're you're developing applications
for the Samsung TV so you can introduce
the Tizen app and then we have a shared
UI layer I'm not saying that the salmon
forms is the answer to everything but we
look at later on how we can introduce
Ameren forms as a small part of our app
where it makes sense so we can try and
share our UI but we also in that layer
with the shared UI code we bring in the
view models so view models is everything
from what happens when I click the login
button to how do i display this pop up
when when something happens or how do I
communicate with the UI all of that
lives in a view model and then we have
shared logic which could be a different
shared application layer and inside this
layer we could have things like how do I
talk to sequel Lite how do I do how do I
do a repository pattern you can leave
that in that project there because if we
have a PCL then that may be shared by
our asp.net back-end or an old windows
forms application or any other type of
dotnet app they might bring in
interfaces and abstract classes that we
want to use inside our code right so if
we're bringing an interface and a PCL
then we can build the implementation for
that either in the native layers or we
can do that in our shared logic layers
if there's a similar across all the
platforms so I'm not really saying here
that more layers is going to be better
but I like to divide my applications
into these four different pieces because
it kind of forces me to think more about
where do I put my code for all the
platforms of course I can go into the
native applications and build things
into the Android app and the iOS app but
if I layer it like this here it becomes
a little bit easier for me to
appropriately approach this using
one or two patterns so there's plenty of
patterns that we can use to solve these
different problems right we can use
inversion of control and dependency
injection we can use a service locator
we can use a bunch of other different
things that I could just name drop right
but just adding a pattern doesn't solve
the problem might just make it a little
bit harder so I've seen projects where
we add patterns like service locators to
make it easier for us to not have to
worry about creating new classes and
injecting dependencies and so forth and
we look at that as well soon but you can
end up shooting yourself in the foot
even if you do that you can end up over
engineering your architecture as well to
make it even harder for you to share
code right so why do we want to do this
why do we want to bother just not doing
it like we did before you know if we
want to build an application in c-sharp
and we don't really care about
co-chairing like why do we bother using
salmon at all if we just want to build
an app why not just hire a Java
developer iOS developer the idea here is
that we can add more platforms and
access more API as they are available
so the code I showed you earlier how do
we test this like if we think about
testability and maintainability how do
we write a test for this here now if you
are an Android developer you probably
cringe a little bit in you you think to
yourself like well we don't really write
a test for an activity but I want to
test this part here saying well if if
you're logged in if there's something
telling me that you're logged in
something's going to change in the app
in this case here is just a transition
but it could also be try to write this
thing to the database if it's not logged
in in my terminate the app like I want
to find that out I want to run a test
that tells me that this code here works
and do that here it's kind of hard right
this here access either it's a static
thing or it's living as a property on
the class it's just hard for me to write
a test for that so the way that we sold
this is by decoupling the app and I kind
of just mentioned is that we could break
it out into things like a view model but
how do we do that and what would that
look like
decoupling our absolutes that we take
some of the dependencies that we have in
this case here that we we have this
settings thing here which is a really
hard dependency on something that we
can't really control this here I think
is breaking some of the solid principles
well so what we can do is that we
introduce this these patterns to
decouple our applications and make
everything loosely coupled an example is
how about we introduce a view model now
this is a lot of code to simply get rid
of that if settings its law then thing
right well as I told you this could grow
out this could mean that we can write
things to the database we can access
things in here that we maybe didn't want
to do in the native code so the idea
here is that well if you're navigating
to this page here we we run this on
navigated to function and then this
thing here checks if the setting is
logged in but this here poised to an
interface which means that I could
inject that if I wrote a test right
makes it a lot easier for me to test
this this logic and then of course I can
use things like an event aggregator or
the messaging Center which we'll also
look at in a bit to tell the native
project that will something's going to
happen now and then all that we need to
do if we introduced a new platform would
be to subscribe to the different events
we have to go in here and say well if
you now get this I'm logging completed
event what do we do then so we don't
want we don't you know over-engineer the
apps but what we also doing here which
would even greatly improve this here is
how about we inject an eye navigation up
here then I could say down here that
we'll just use our navigation to
navigate to that particular place
another D couple the navigation as well
so that's pretty cool so how about if
you really want to run platform specific
code there's a lot of cases out there
that kind of forces us to talk to the
native API we use stammering because we
want to get the native performance we
get access to all the native API but how
do we do that if we're doing everything
in the shared code so I'm not saying
that we want to approach 100%
co-chairing because this is not crew
dov'Ã¨ or PhoneGap or whatever library
out there that shares all the code this
just allows us to build a native app
that performs awesomely and
allows us to access all the API where
it's appropriate so we could think about
NFC for instance so Android has had the
capability for forever pretty much to be
able to talk to the NFC chip so a funny
story about that is I don't know how
many of you saw the the Apple event in
Apple Keynote they just released the
capability for us to talk to the NFC
chip but what they did was that they
only allow you to detect if your
blipping against attack and that's
pretty much much useless most of us want
to be able to take our phones and blip
that to something and that that terminal
that we were bleeping our phone against
we want that to detect that we did that
with our phone right but we're not there
yet on iOS but when we're building the
apps we want to say that well we have
this shared code that knows how to talk
to NFC if our app does both reading and
writing we just toggle it for four hours
just turn one of them off and then when
it's available on iOS it should be super
simple for us to just turn it on all
right so how do we do shared code but we
want to be a little bit specific so one
thing that we can do is that in this
case here this is an example from a code
base that handles an HTTP message so all
that it's doing is that we are
requesting some g-sibs information to
make sure that we transition a little
bit less data over the wire so we want
to make sure that we compress all the
the data that's passed to the app but
the problem is that Android doesn't
support or at least through xamarin the
libraries don't support gzip out of the
box so we need to manually decompress
our content which is a bit nasty but we
still need to do it but it wouldn't make
any sense for us here so we can say if
it's on Android I want to run this
decompress method and then we decompress
all the data right so it wouldn't really
make sense for me here to break this out
and build that thing inside the
platform-specific layer I could just do
that in my shared code so sometimes it's
appropriate for us to break out remember
I talked about earlier that we get this
idea we have a shared project layer but
then we kind of leak
from specific implementations this is
one of those cases but in this case it's
fine this is really hard to make the
distinguish between when is it okay not
but if it's just a few lines of code
that's different for one platform I
think it's okay we could have solved
this by injecting an interface we could
have but this is alright as well so if
we want to take this one step further we
want to use patterns that allows us to
inject platform-specific implementations
and one way to do that is by introducing
something like an ioc container so
tinyeye you will see is a way for us
it's a OCS file you bring it in from
from github and compile this as a part
of your project and it allows you to
register implementations for certain
types so what's pretty cool here is that
I can say well I have an account service
that implements the interface I account
service and then I have an i preference
service which is implemented by
preference service and then the cache as
well right and the cashier is marked as
a singleton which means that you'll
always just get one instance all right
so I have some I can configure this a
bit to be accustomed to my needs
now what's cool here is that maybe the
account service takes a preference
service that takes a cache and what
happens when I ask this container here
to give me an I account service it'll
just automatically start the integrator
instances for all these different types
so just simple inversion of control
right so this makes it a lot easier and
then we can introduce a pattern call a
service locator pattern which is you
know pretty much an anti-pattern because
it doesn't really make our code easier
to test it makes it a little bit Messier
in my point of view but it's available
to us to use on all these different
platforms and it's pretty much the only
way that we can do dependency injection
on Android iOS please do I know of so
what I'm doing here is that I'm saying
well when you use the service locator
and you ask for this account service
it's going to use this panel you see
container to resolve that type which
means that's going to create the cache
is going to create my preference service
it's going to inject that into the
constructor and then give me a
full-blown account service so let's look
at how that works
and maybe whites making everything a
little bit harder to work with so I have
the the same app that we just looked at
I'll just stop this here so we get the
solution and what's happening here is
that inside my android project will go
into our splash screen activity we'll
see here that I'm using the service
locator to get the the an instance of
this account service and then I can use
my account service to create and save a
new account called demo I inject some
properties that I have on that type so
this thing here if we look at the
account service will simply see that we
have this contract here allowing us to
set the identifier for the account then
inject a few properties super simple but
then what we can do here is that we can
use this here in our splash and then
somewhere else in my Android app I can
request this this thing as well so if
this is a repository or in this case
it's a service I imagine that it doesn't
matter if it's a singleton or not it's
just going to go ahead and grab me the
data from some storage so if I'm going
to our login activity here maybe you saw
this earlier when I pulled up the
application said login as Phillip and
that's because what happens here is that
inside the inside the login activity I
also say well give me the service and I
can load my demo account and then share
the account name so you know if we start
the app we'll see your that we get the
instance off the I account service it
uses that to save something and then
when we are inside our login activity
we'll get the same data so this is a way
for us to kind of D couple that thing
right and then the implementation of
this account service can live wherever
maybe the implementation lives in a
platform specific layer because frankly
what I could do here is that I can say
well I want to use the service locator
do the service locator that instance
that register and this here would allow
me to register any interface towards any
implementation so if I'm running this on
Android if I'm running this on iOS I
could inject platform-specific
implementations
so this is a way for us to work with the
contracts within our share code in our
PC else and then inject that from the
platform specific layers and one thing
that we'll see here in this application
is that there's something called the app
dot CS file the application dot CSV file
kind of bootstraps the app it sets all
these dependencies up link starts so
this is being called inside our
application delegate and on Android we
have an application that's starting this
up so what it's doing is that it's
registering all these types with our
service locator and we can see here at
the bottom since this is a shared
project it's saying well for iOS I want
you to register the I messaging dialog
as an iOS dot messaging dialog right
these two different lines could have
lived inside the platform-specific
layers instead if we wanted to do that
right so the service locator pattern
allows us to to get our interfaces and
have them in PC LS and shared projects
and then we can inject those
implementations from those plots from
specific projects and of course we could
inside our PC LS or inside the shared
projects we can work with those
interfaces in those contracts we don't
have to care about the actual
implementations so that's one of the
things that you need to think about but
the problem with the service locator
pattern is that well sometimes you can
feel like well what have I done because
you end up using the service locator
pattern everywhere and when you call a
method you want to be very explicit
about what that thing is doing and if
it's simply asking for implementations
of something it's still going to be
impossible to write tests for it all
right it's not impossible but to be
really hard because you need to register
those things inside your test project in
order for you to be able to to run the
tests so imagine that we have a method
we just call it let's call it load we
call loading on our tests and then
inside our load method it uses a service
locator to get our account service but
we don't know that when we call this
method so we need to think about when we
were actually using the service locator
pattern but then we want to go back to
thinking about well I don't to repeat
myself and especially when I tell myself
they say I'd be the idiot part because I
tend to repeat myself quite a lot so we
want to make sure that we're not
repeating ourselves in our plot for
specific layers right so we can use the
service locator pattern to bring out the
interfaces and contracts and put that
inside our PC else but that's just a
small part of our code right one of the
things that I've found lately is that
well I want to stop reimplemented the UI
for each platform how many are using
salmon forms yeah the rest of you using
semi native maybe so
salmon forms is really great but the
problem with salmon forms is that up
until now you've had to choose well do
we build an app using salmon native or
do it build an app using salmon forms so
if we're working in a greenfield project
which is a totally new project we can do
and choose whichever technologies we
want then maybe we choose salmon forms
but maybe we don't right it really
depends on what type of application
we're building but what's really
interesting is that now we can kind of
use these technologies together to make
it easier for us to share even more code
and if this year if you recognize this
background this is from Windows XP I'm
not saying that Windows XP is the best
project in the world to look at but it's
a nice background but if we work in a
greenfield project everything looks like
these blue skies and you know big green
feel that we can just run over and
everything's paradise most of the time
though I don't know about you but
personally I end up working with
spaghetti code and most of the time it's
my own code better last week I still
feel like I don't know what I wrote but
sometimes you jump into projects that
someone else built maybe you had an iOS
developer building the Android app using
salmon and they try to implement
everything like it was an iOS
application right so taking over someone
else's code might seem like a bit of a
struggle so we want to make sure that
even if we get into these really bad
applications that are really bad badly
architecture we can use things like the
service locator we can do things like
event aggregation using version of
control and
out of our platform specific projects
for new things and what we can also do
as I just mentioned is that we can
introduce a marine forms so the idea
here is that what about if we takes a
marine forms and we simply inject that
into a little part of our application so
imagine that you take over an
application from someone else and I've
done this recently I've worked on an app
that's built using semi native and we
want to introduce a few different
screens in the app that simply gives the
user some extra information it just
asked for some input it's not only the
most graphical application or the most
graphical views in the app we don't need
the full GPU power whatnot so we could
have used salmon forms we don't have to
repeat ourselves when it comes to the UI
so what you can do is that you can use
something called salmon forms and
bedding which allows us to build forms
use and then just use them as fragments
or view controllers inside the apps and
that allows us to do even more cool
things that allows us to share more code
and allows us to follow these best
practices we can do things like
dependency injection in Windows forums
which you cannot really do on iOS and
Android so use the dependency service
you can use the messaging Center you can
use all the navigation that comes with
salmon forms and when we do this we kind
of embrace ourselves to build better
apps and more easily architecture these
types of apps and I think maybe what
happens here is that we're still leaking
to our share code because we try to
write a lot of you know UI specific code
inside the shared project layers as I
showed that little part that registers
the I messaging dialog for iOS and
Android
I've seen places where those stores grow
out of proportion
so in an ideal scenario what happens is
that we we try to maybe we introduce
this UI layer here and the salmon forms
layer could be our view models we can
have all the view logic in this layer
and we can clean up our share code and I
think this makes it a little bit easier
to work with hopefully at least so how
do we do this well with salmon forms we
can simply create this new main page for
instance so now we can say well give me
the fragment
or give me the viewcontroller and that
gives me those things for a particular
platform so in this example here what we
have is that we have an Android activity
we have a login activity and what it's
simply doing is I've displaying the
username and then a login button all I'm
doing here is that I'm injecting this
fragment here by simply creating an
instance of the page and then saying
that well you should be displayed here
and it all looks pretty nice right and
for iOS to do the same thing we can say
well give me the view controller and the
way that we inject the view controller
is a little bit different especially
with this demo application but we can do
the same thing right so let's just have
a look at what this looks like and what
kind of possibilities that we get out of
this so one thing that I find is that
looking at stammering forms is a great
way for us to understand how we can do
proper co-chairing and looking at how we
can share the UI kind of gives us an
idea how do we share the logic because
fundamentally Semmering forms embraces
mvvm and mvvm it's a pattern to allow us
to break out and loosely couple our
applications alright so enough talking
about that let's find the solution or
just close all these windows
all right so here we're going to look at
salmon from some bedding so I have the
same application and what I've done here
is that I've introduced a new layer
introduce the PCL a PCL is a way for me
to write code that's share shareable
across different types of applications
so a PCL allows me to say that well this
library is accessible from Sam rain it's
available for Windows and WPF and I
don't use it in silver life but that's
legacy anyways so what I can do here is
that well I've defined a page that
simply allows me to bring in a button
and when I click the button something
happens all right super simple example
this is like the the fundamentals and
the examples that you get out of Sam
rain forms when you just create a new
project so I have this thing here just
imagine that it could have been a lot
more complex it could have a really
complex view that has a lot of nice UI
and it's bound to a lot of crazy
properties but what we what we can do
now is that I can go into my Android
project and I can say well when you
click on one of the things in the app so
maybe you saw this earlier that you had
this little tab bar that allows us to
tab between views those are actually
fragments and the way that we can do
this is that I told you before is that
we can create a new fragment so I have
my main activity here and it has
something called a fragment page adapter
and I'm simply initializing cerumen
forms I'm creating a new page and then
asking you to give you the fragment it's
pretty cool right it'll be more awesome
will actually run the app to see that it
works rather than just looking at the
code so what this allows me to do here
is that I'm saying well I have this
Android application have the full power
of using salmon for Android and the
native stammering and I can bring in a
shared UI where it's appropriate and
then maybe I have view models that live
in a PCL or our view models that live
inside my share project and I can make
use of things like tiny ioc to do
inversion of control I can use prism to
do a lot of mvvm crisis and I'll show
that as well in a little bit so let's
run the app
you know properly architecting these
apps is pretty much going back to the
basics looking at how do we write
testable code how do we approach our
applications just think about that iOS
and Android are very different but the
things that we do in the apps for
instance here we have two buttons what
happens when I click not now here should
pretty much do the same thing no matter
which platform right maybe please to
check something of the platform and it
could be living inside a shared project
you also saw here that it's taking a
little bit of time to get into the main
view here now it's because it's
initialized salmon forms and this here
is a very early preview of salmon forms
embedding they just announced it on
build like a few weeks ago and it's
hopefully available as a stable version
later this year so now we have this page
adapter here and I can see that if I
click about here this here is a salmon
forms page embedded inside my android
app and I think this is pretty awesome
and now what I can do here is that all
of this code in here can use mvvm and
you can use all those dependency
services and messaging services that are
available in salmon forms so that just
allows us to share even more code so if
we just run the iOS app as well I'll
show you the iOS code first
so the iOS app it's pretty much the same
thing I'll start this off and we'll see
if it boots up in the background already
have the emulator here so let's run that
and on iOS what's interesting is that
it's a lot faster so when I click not
now here it's super fast to get in here
then I can look about here at the bottom
and you'll see that we get this salmon
forms page as well right it's pretty
cool so it's a way for us to work make
sense share a little bit of the UI so
this is one of the principles that I'm
really trying to approach in a lot of
the projects that I work on because a
lot of the time UI is similar across the
platforms right even though it compiles
into looking like it's a native iOS app
and into an Android app on Android the
structure is pretty similar so when we
run this or create these things on iOS
what we need to do is that I'm doing a
little bit hacky here so what happens is
that I create a navigation page which
gave me this navigation bar on top and I
just create my salmon forms patient
injecting to that I set the tin color at
the top and then I simply say well give
me a creative you controller out of that
and this allows me to then again embed
salmon forms in my app and I think this
is quite powerful so allowing us to do
this means that we can start sharing the
UI and if we try to approach this using
the principles of inversion of control
and you know dependency injection and
how to write testable code get our UI
logic into view models I think we're off
to a pretty good start so one of the
things that I'm trying to do in most of
the projects that I work on is to find
out what common UI logic do we have on
the platforms so a lot of the times we
build apps that are totally similar on
the platforms the UI might be a little
bit different and look different and
perform the same of those platforms but
we've located all the UI logic and that
doesn't really make sense right so one
of the things that we can do is that we
can now if we use salmon forms and bring
that into our solution we can use
something called the dependency service
which is kind of like the service
locator pattern but it allows us to
register types a little bit differently
so here I can say that well I have this
I account service that lives in a PCL
somewhere and this here is in fact
implementation and then we register that
in our entire assembly by just
introducing that thing as
top there so what then happens is that I
can use the dependency service like this
here to access this dependency anywhere
so we imagine that they have my salmon
forms project and inside my salmon forms
project I can say well give me the I
account service but the salmon forms
project has no idea about the Android or
iOS project so this is where we start to
get separation of concern right we have
our interfaces in a PCL we have our UI
in the salmon forms project wherever
implementations living somewhere and so
start it's all starting to get pretty
good but then you probably think well
I've got the login button in my app for
instance that I showed you earlier or
the increased numbers button that we
have how do we notify Android or iOS
that something happened how do we
communicate back to the native layer
that something's going on we can use
event aggregation or in examines case
it's called the messaging Center so fun
fact here is that the current version of
the messaging Center has a bug so it
doesn't really work well on iOS but
what's pretty cool is that when you
create a new project we would stammering
if you use a semi native project
structure it will actually give you a
messaging Center implementation that
works because it kind of built that for
you I'll show you that in a bit but what
happens here is that I can say well when
I click login I want you to send a
message back to the native layer and
that's using event aggregation so that's
a way for us to separate our concerns
and lose the couple the apps so the
example of how we actually implement
this is by in this case here I'm simply
registering for a certain event so I'm
saying here well when there's an event
from the login view model and the event
is log in completed I want you to run
this particular code and then what
happens inside Samer informs is that I
can say well tip send this event here
and whoever listens for it can can do
whatever they want and this here also
allows us to what we can abuse this here
because this allows us to cross
communicate wherever we want right you
might have a view model that listens for
this event you might have view
controller you might have something else
listening for it and then you just have
events right
all over the place can get a little bit
tricky to debug but it allows us to
write more testable code so let's look
at what this looks like let's make use
of the dependency service and the
messaging Center which allows us to
write more shareable code so pretty much
the same solution and we have a project
that allows us to do these things so in
this project inside my salmon forms
project I have a new view here and of
course when using salmon I can use
salmon form sorry when I use some forms
like a nice angle so here I have a view
here that allows me to click a button
and when I click that button I'm going
to race or run a thing called the login
command which is then inside my view
models right so if using mvv aminal I'll
show a little crazy demo in a moment of
that so what happens here is that we are
simply saying well I want you to give me
the I account service dependency so here
we are asking for a dependency using
this dependency service and this thing
here like seven forms has no idea about
where the implementation of this is if I
f12 into this here we'll see that well
this is just an interface it's
implemented somewhere else so what I'm
doing here is something will give me the
the implementation and then save a new
account using these preferences and then
we'll go and send a message using this
messaging Center which I've brought into
the app we don't have to go through the
code here but this is simply allowing me
to send messages to whoever calls or
subscribes to a message pretty simple so
I'm saying here send a message from the
login view model and then we send the
event login completed and then if we
take a look at what we have in the
Android project we can have a look at
one of the activities that is using this
here and I had to add a login fragment
activity here because what I'm doing is
that I'm grabbing a fragment that allows
me to display the salmon forums page but
simply have a new view here that will
see you soon it says well I want you to
initialize salmon forms then subscribe
to this message create a view and show
me the view here
and whenever there's an event inside
this view here that's living inside
salmon forums I want you to run this
code here right so we pretty much
totally just decoupled those two
different dependencies which is pretty
cool and if we look at the shared
project and the services we'll see here
that we have the I account service the I
account service implemented implements
the interface account service which
lives inside the salmon forms project
right so what actually happens here is
that we inject the implementation for
Android or iOS into our salmon forms
project and that's no idea about what
those two things are really right let's
run the app so I think this is pretty
powerful like it allows us to write more
testable code and I think that's the the
goal here right testable and
maintainable code and hopefully it's a
bit more fun to work with
maybe not fun for our co-workers to
debug but at least we wrote some good
code and noticed get rid of that
of course for some reason it's not
working so let me go into our let's run
it on iOS instead so what should happen
here is that we were now allowed to log
into the app I'm seeing that release you
all to get the beers so there's a lot of
lines now anyways because someone finish
a bit early so it's not now here
hopefully alright so I shouldn't click
not now that's why it's not working demo
gods
let's click login which is what I should
do click login here we get this
beautiful wide screen here I'll click
I'll right fill it I'll do login here
and then I look about here into Silicon
here as well so a few things happen few
things happen in here first of all we
embedded salmon forums and said well
this view here is now salmon forums we
injected the implementation for one of
our interfaces which was implemented in
one of our native layers and then we
have a different stammering forms of
view here which is using that if we take
a look at my page here it's saying well
give me the account service and this is
a totally separate salmon forms view
it's asking for the same dependency and
then we're using that and showing that
in here as well that's pretty cool right
allows us to separate all our concerns
and write more testable code I think
that's the end goal here right so one
last thing to talk about and I just want
to talk a little bit about mvvm mvvm
allows us to build applications that are
separated into a few different types of
layers we have a model that represents
our data we have a new view model that
allows us to do operations on that data
and then we have the view that simply
displays the data and we write tests
maybe for the view models and services
and so forth and the idea is that we can
break all of these things out to make it
easier for us to build awesome apps and
there's a few frameworks out there I'm
not saying that there's one framework to
rule them all
you have things like mvvm light we have
fresh mvvm and i'm going to have a look
at person here in just a little moment I
think Christmas we're doing a really
great job in allowing us to use a
framework for the MVD and pattern so the
goal of one of these frameworks is to
allow us to do things like navigation
events aggregation and dependency
injection we saw that we can do this out
of the box with salmon forums and the
you know the dependency service in the
messaging Center but let's have a look
at how we can do this with something
like prism so prism is a pretty amazing
technology that's been around for a long
time and at this project here and what I
want to show you here that's pretty cool
is that I want to make it even easier
for me to say that well this is the view
here it's the view model here just
figure out how to title together so what
I'm doing here is that I'm using I have
a person reference inside my project
it's a prism application and we're
simply doing is that this is where the
mind might bogel a bit but it's using
auto FAC internally so we're setting up
a new container I'm registering an
instance of a type so what I'm doing
here is that I'm doing something a
little bit crazy I'm saying well give me
the instance from the dependency service
for I account service and add that to
our auto FAQ container which is used
inside prison inside the salmon forms
project right which means that whenever
I navigate to one of my views
it'll just know how to create an
instance of an icon service everyone
with me so far let's have a look at some
more code so what I have here is to have
a view called login view this here is
using the MVVM pattern so the end of the
in pattern allows me to say I want to
show this view here and on a few places
let's bind to the username for instance
and then let's also allow me to bind to
a login command this view is now totally
separate from the view logic that
handles these events right which is
pretty good that means that I can I can
work with the view model and do a lot of
logic and don't care about the view
itself we never want to go into the the
code-behind of
you and write code in there right so
inside the view model this here is now
bindable base which is a thing in prison
but then we can see here that we have
our constructor which takes an eye
counselors that's pretty cool right so
how do we inject that how does our
application know how to put in an eye
account service in here well if we look
on Android we can see here that in the
activity that is in fact using this
thing here always doing inside the login
activity is that we are saying we'll
load our application this here sets
everything up with person it loads
everything into the artifact container
it just bootstraps all of those things
and sets up the dependencies and so
forth but then here at the bottom simple
thing will give me a new login view and
creative fragment how does this thing
here know how to bind to the view model
well this is where the magic happens so
inside the sample itself I'm sick
actually saying that we want to
automatically Auto wire this with the
view model so prism is going to look for
something that called view model so it's
going to take the name of this view that
we're navigating to it's going to find
the view model it's going to create an
instance and going to know that it's
taking a dependency of the I account
service it's going to inject that
because we register that without a fact
that's where the mind blows it's from
the app hopefully this works so the idea
here is that we now have a much more
decoupled app and we're using
technologies that we might have used in
salmon forums projects we were using
prism that you might also have seen in
like Oh WPF applications so when I click
sign-in here now if this works I hope so
take a little bit of time because it's
setting up stammering forms now what's
happening here is that it created an
instance of our view here it created an
instance of the view controller it bound
us to you together which are loosely
coupled it just found that by the name
it automatically created the I accounts
service injected adding to the view
model and then when I write still
appearing click login we want to set a
breakpoint in here as well
and see if that's going to work I'll
click login here and we can see here
that we have the username which is
Phillip and of course we have an IEEE
account service which was injected into
our constructor just magically by prism
and then we can send off the login
command here and now what's even more
interesting is that if we go into the
login activity and put a breakpoint on
Android inside the event that's
listening for someone completed a login
will release the debugger here and we're
getting here I can check the object
that's being injected into our event
here we can see that well here's the
user named Phillip right so I can use
that view model inside Android as well
so all that's showing us that it's
really easy for us to separate all these
different concerns by using common
practices that we probably be using in a
lot of other applications before so all
that this is pretty much giving us it's
a way for us to write more testable apps
the end goal is pretty much right
testable maintainable and apps that are
more fun to work with right so simple
patterns and practices to make us feel
more like this here we want to be more
happy when we're building apps right we
want to feel more like these kids that
are super happy and proud of their apps
by bringing our UI logic into view
models avoid having too much platform
specific code inside our shared projects
and avoid writing too much code in our
Android and iOS projects that allows us
to write more shareable code and it is
okay to do platform specific code where
it's appropriate right we might end up
having an application that's pretty much
layered like this instead we might have
a little bit larger iowa's project and a
little bit smaller Android and maybe a
little bit bigger windows but that's
totally fine sometimes we build features
in the platform specific layers that
won't ever be available on different
platforms maybe we use touch ID on iOS
and we build that into the app itself so
that's totally fine but as long as we
try to reach more share code across
these platforms by using principles like
a service locator pattern
version of control using the event
aggregation and so forth that will make
it a lot easier for us to build these
better apps so pretty much to wrap all
this up we want to look at patterns that
helped us build better applications we
can look at service locators and kings
event aggregators and all those
different things that we probably seen
in a lot of different types of
applications before so before you head
out to the beers I want to remember ping
me on twitter my twitter handle is at FX
the same as my company name just send me
a ping if you want a digital copy of my
book don't remember to vote on your way
out and if you have any questions I'll
be sticking around for a few minutes
here and thank you so much I'm syllabic
words</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>