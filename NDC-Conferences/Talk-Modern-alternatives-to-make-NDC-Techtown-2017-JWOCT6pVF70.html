<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Talk: Modern alternatives to make - NDC Techtown 2017 | Coder Coacher - Coaching Coders</title><meta content="Talk: Modern alternatives to make - NDC Techtown 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Talk: Modern alternatives to make - NDC Techtown 2017</b></h2><h5 class="post__date">2017-11-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JWOCT6pVF70" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone my name's Mike I'm a partner
with a company called pragma we help
software organizations with development
tests and operations automation so
continuous delivery and DevOps basically
so today I want to talk about belt
systems I've spent a lot of time with
build systems a lot of my professional
background is in embedded systems the
very first project I worked on after
university was actually it was a an
embedded system a control loop for a
product that was to go down down deep
down into oil reservoirs and on that
project with that my first experience at
professional software development the
build system was actually an ID and I
pressed the build button on the ID and
that was the software I shipped to to
the customers that went down and oil
reservoirs shudder when I think about it
now but there was absolutely no process
no control over anything that came out
of that there was no reproducibility
definitely it was all based on whatever
configuration and environment I happen
to have on my laptop thankfully I
learned a few things since then but
slowly industries have changed the
second project I was involved on was
much much better we had a version
control system but because we were a
very very big company no version control
system and the planet was good enough
for us we had to build our own and guess
what we also built our own configuration
management system and our own build
tools so that was an interesting
experience too and but the thing is in
that case there was some real business
drivers for having made those decisions
the the build systems back then you
didn't have a lot of choice other than
make and make was in essence very very
slow if you had a very very big codebase
and back in those days builds could take
more than a day
so we built special build tools to
enable us to have what was called
line builds where we built only the
things that were different between us
and what the server's had built
overnight and nowadays more and more of
my work is working with embedded systems
as well still but we're starting to use
things like docker and so on capture the
environment but we're also using tools
like artifactory or nexus other kinds of
artifact management tools for the
binaries and where the where the build
kind of fits into this world is kind of
tricky we've started exploring different
tools to use more and more often we're
using Gradle but then suddenly I kind of
came to the realization that maybe it's
time to spin up the helicopter maybe
there's more out there than than meets
the eye so we started a project and
certainly in the company to start to
look systematically at all the native
build systems out there try them out
give them a go and evaluate them against
the others and see whether what they're
good for
so this is still very much a work in
progress but I want to share with you
the things that we've been looking at
and what we found so yes why do we need
an alternative to make there's actually
nothing wrong with make make is actually
very good at what it's designed for the
thing is that the the context of
software development has changed a lot
since where since make was designed yes
we need dependency analysis to be able
to figure out what to build but there's
much much more than that we need so a
lot of the I'd say that there's two main
drivers for for picking and tool other
than a very simple make or see make or
one of these variants of tools one is
that you want to interact with artifact
management systems packaging systems and
so on you might want to resolve the
pendants ease from from some binary
repository you might want to produce
versions artifacts you might want to
interact with the world in a different
way it's not all just happening on your
laptop these days
the other main driver is coming from
organizations with very large code bases
because they have they have many more
challenges so optimizing that bill
throughput is very very important for
them developer efficiency and large
enough organizations is a big driver so
they're looking to do things like either
be very very smart about what is built
basically only only building what
absolutely needs to be built and being
very strict about package management so
that you can avoid building things and
then the other side is if you have a
very very good understanding of the
dependency graph then you can be much
more aggressive in parallelism so that's
really the two main drivers artifact
management systems and the builds now
there's another desirable feature that I
would like to have eff that I was going
to pick a tool and that is a strong
community I really want not to be
picking a tool that has that's a dead
end
because our build systems last for a
long time
we really don't want to them to be very
clever we don't really want to have to
update or publish them we want to be
able to rely on them like we can rely on
make so we want to have a very very
strong user base and we want it to be
open source so that if there's something
we want to add to it we have a chance of
doing so good that being said so far
we've had a look at five contenders to
make we're using I can mention we're
using a lot of Gradle and our company at
the moment and that's very interesting
but there's many other choices out there
we've looked at Conan we've looked at
basil we've looked at s cons and we've
looked at buck so there's many other
many other options out there there is
ninja there's pants we haven't we
haven't gotten through the whole list
yet but we this is a work in progress
and it's very interesting how these
tools what they're similar and how
they're different out of interest is
anyone using any of these tools at the
moment what are you using once ok
Conan ok very good so I'm going to start
with scones because I think it's
probably the one closest to make and
farthest away from what I'd like to see
and something to replace make maybe
that's related it's an open sore
tool that came out of I believe company
called
software carpentry or something that's
where it got its name and at its it's a
it's maintained by the community at this
stage that's I think around fifteen
years old so it's not I would say it's
not a very modern alternative to make in
that sense but still much younger than
then makers so what does it look like I
mean if you ask me when you start to
write your build files with scones that
starts to look pretty ugly it's
basically it's basically Python you can
you can actually write Python this is
actual Python and it's it looks very
imperative it does build a model of
dependencies much like make so that's
where it is similar but it's it's not
super intuitive to figure out what your
build looks like through going through
this at least in my in my eyes so some
of the the features that the the build
files are Python scripts so if you know
Python you have a strong Python culture
in your organization this might be a
good place to start it is better than
make at doing parallel builds it has
some automated dependency discovery
built in I'm not actually sure if that
can be trusted on larger projects I'm
not sure in terms of incremental builds
and so on f you can really trust it but
it is there and it feels very much like
so it's not it's not so it's not a big
leap to learn it's not it's not a
challenge on the development environment
has some implications it does mean that
you will have to have Python and it's
not so declarative so that's this is a
common a common tool you'll find in code
bases that are around ten years old or
maybe this was a tool that was chosen
ten years ago this is something that was
a good choice ten years ago it was like
that was this time for it
but I think now that we have we have
much stronger contenders for tools in
this space okay the next tool is the one
I probably know the most about is
because it's the one I have actual
project experience with and it's called
Gradle it is open source but it's there
is a company behind it also great a link
so Gradle in essence is based on it's
based on groovy it's a DSL over groovy
so it has a domain-specific language
that you can create a model of your
build and and it can be quite rich it
has elements of if you're familiar with
tools like ant we have these this idea
of concept of tasks so I think it at
least initially one of its goals was to
try and kill ant
and mavin but keep some of the concepts
so for people and especially in the Java
world who were familiar with that I kept
a lot of those fundamental concepts but
brought that brought the build system
into a programming language rather than
a file format because those were the
weaknesses with maven and ant is that
you were defining everything in XML so
if you wanted to do something a bit more
clever it was really hard you had to
break out of the the build definition
and start to execute scripts so they
found that this was the this was what
they were trying to achieve here at the
native build support came later a few
years ago the native build support
wasn't as rich as it is today and it's
much much better now
but also what is very common is to use
Gradle as a wrapper and to your build
system so if you're already using make
or whatever your your build system
actually is you can call call into that
to perform the build but use Gradle for
the other aspects of the build such as
the packaging the dealing with the
binary package repositories and so on so
it's not a one or the
quite often these are mixed together and
it's especially useful if you're making
embedded systems where you've got you've
got very integrated development tools
where you would like to like for
instance the tools generate to make
files and you really would like to use
those make files but on the other hand
you would like to have some tooling
around dealing with packaging so this is
a very common solution there some of the
features Gradle does have a very very
large user base most of them are not
doing native software of any kind
most of it is Java people but there are
some very large projects using Gradle
and Android has very good support the
Android community works together with
Gradle to make sure Gradle works with
the Android that has quite good native
support has a DSL for describing the
typical C and C++ concepts that you
would want to define in your build like
shared libraries static libraries
executables and so on and like I
mentioned you can you can use it to wrap
your actual build if you would rather
keep make as your build commands it has
a large plugins ecosystem and this is
actually very useful being able to
create Gradle plugins reusable plugins
that you can use in different kind of
build contexts is very very useful in
some instances it's so in that case it
makes it very easy to extend the
language it's got support for
incremental parallel and continuous
builds it it does that is core since
it's coming with this Java heritage have
very strong dependency management and
built in it's very much influenced by
maven and you can use it to talk to
maven or IV or artifactory or any of
these typical binary repositories one of
the nice things about Gradle is that the
way you the dependencies you need to be
able to run it as the JVM and what you
do is you put in a couple of wrapper
files into your your source control
so those rapper files are only like a
bootstrap for downloading the version of
Gradle that you're supposed to have on
your in that build system so in that
sense you don't need to really can
control very much of the environment you
just need to have a JVM and the rest
will kind of take care of itself and has
support for assembler C C++ objective-c
C++ so it has a lot of the features you
need out of the butt and it's probably
the there's probably the one of the the
tools that is good at both artifact
management and and build it's the one
that's come the furthest there I think
maybe cone on is it an exception because
it really is designed with that in mind
so some of the implications about Gradle
is that you need the JVM like I said and
that's not a big deal but really what is
a bit of a big step for most as that you
kind of need to learn groovy you can you
can learn Gradle by going through the
docs and the docs are quite extensive
but to really understand what the docs
are telling you you have to understand
groovy you have to understand the whole
concepts behind the language otherwise
it you end up just typing in a bunch of
stuff into your editor and praying that
that's the right thing so it's a if you
are going to pick up great oh it's
really worth taking the time to learn it
properly so the next one I want to talk
about is basil
Basil's coming out of Google it's the
it's not the actual build tool that they
use in Google much like kubernetes isn't
the actual runtime for containers that
Google uses but like kubernetes being
influenced by what they learn from bork
basil is exactly influenced from what
they learned inside Google with their
build system so what look like well it's
actually quite simple you have you
define rules and
you have different types of rules but
because it's really set up for a C C++
it's very very natural you don't have to
tell it a lot of things to be able to
build your software you say ok this is a
C library or C++ library here's where to
get the sources dah dah dah dah please
make it happen I mean you can tell it
more things you can give it more
instructions if you need to if you need
to go further in your definition but in
general this is all you need to do to
produce your artifact and here you have
an example of fetching the binaries from
the internet and here where we're
downloading the Google test framework
and taking in the dependency on a
fixture so we will be sure that the
version of the Google test library that
we're using everybody is using the same
so one nice features is it's really
designed based on what Google have
learned about making large build systems
so the the design is is really well
suited for large code bases it has a
built in query language which again is
very useful because normally what
happens in big build systems is you can
never figure out what happened why why
doesn't it pick up that dependency why
does it pick up that dependency why is
it rebuilding that when I changed that
understanding these things is actually
quite a challenge
so basil has a built-in query language
you can you can ask it these questions
much like most things with Google it has
a defined style guide so there's there
is a right way to write a basil file as
well so in general there's not a hundred
different styles on the internet
generally people follow a convention
that's consistent so it makes it easier
to learn there are some new concepts on
it you have this concept of a workspace
you have concepts of packages and labels
so you do need to take the time to
understand it's not just figuring out
how to call the compiler there's more to
it than that but the concepts are quite
clear as well and there's really really
good documentation so it's it's
quite easy to get started with basil it
has support for nice things like
transitive includes so if you pull in a
library that also pulls in a library and
let that transitive includes you need it
will sort that out for you the other
thing it has is oh no sorry I'm mixing
this up with book it doesn't have what I
was about to tell you but it has support
for incremental and parallel builds and
its really really designed for speed
like how fast can we build this thing
and that adds about making very very
clear definitions of inputs and outputs
of rules one of the things that is both
good and bad about basil is that it's in
better so the good thing is Google are
honest enough to tell you that it's not
1.0 yet which maybe some other tools are
not so good at telling you these things
we've especially found some of these
tools have got very poor documentation
or the documentation is out-of-date or
they changed things but there are some
things that could still change but there
is a there is a road map online and it's
very very close to becoming 1.0 so I'm
actually quite impressed with with basil
and I'm gonna keep an eye on this one
the next one I want to talk about is :
this was made it was an open-source
project to begin with but I believe that
the the group that was developing it we
were acquired by Jeff Rock the people
who make the artifactory artifact
management system so konan is it looks
like this it's it's based on Python so
you you create a cone on file and you
specify a bunch of things and about how
to do the build and packaging and so on
but there's a lot more to it than than
just build it it has this kind of very
very strong influence from the world of
package management and dealing with it's
actually a distributed package
management system
so one of the special things about Conan
is that it is not a belt system it
doesn't do build it defers the bill to
something else like see make or make or
Visual Studio or whatever your build
system happens to be it's not really
concerned with the build system so it's
a bit of a special case here and call it
a replacement for me cuz not really
telling the truth it's not it's it's
orthogonal to the build system so it and
it claims to be compatible with any
build system - and I don't see any
reason why it shouldn't be but where
it's really doing its thing as its it's
a decentralized package manager and that
means much much of the design is
influenced by get so they have this idea
of remotes and the idea that you should
be able to fetch and publish to
different remotes just like you could do
with commits and get obviously with them
being acquired by artifactory or jay
frog they have very good artifactory
integration there is a client-server
architecture so much like yet actually
the idea is that you push and pull from
from a package MANET server sorry
there's also support for a building
offline so you don't need to be
connected to the to the server so that's
kind of where some of this other get
influences are coming from and yes it
does require a build system so it's
never gonna if you're building with make
then it's probably going to you're going
to continue building with make you also
need Python one of the things that's a
bit frustrating just now is that the
documentation is quite slim and it's
example based but many of the examples
in the documentation are out of date and
I think that they're changing a lot in
their design just now so it's a little
bit hard to know exactly what you're
supposed to do and why it's chosen this
way or that way on a given page so I
think you I think Conan has a future and
I think is very interesting I think it's
it's got some really really interesting
concepts
but it's I don't think it's ready for
production use just yet and the last one
I'm going to talk about is a tool called
buck buck is coming from Facebook but
that's not actually quite true because
the the people and Facebook that built
book are actually ex-googler
so they were very much influenced by the
way the google build system was so buck
and basil they are they if you step back
a bit and squint your eyes they look
kind of the same there are some
differences differences though but you
can see it looks the file format looks
quite similar there are some important
differences but you know it does look
kind of similar so just like basil buck
is used in production and a very large
company making a lot of bills it's very
similar to basil and it's focused again
on performance and reproducibility the
ideas that I mean you should have no one
dependencies and that the inputs and
outputs should be no one so that if
something changed I know what to build
and it's really focusing on this
correctness correctness principle there
is strong support for Android so if
you're making Android applications then
this is probably something you might
consider it has this thing for a it's
like a design for include collisions so
basically when you include a dependency
or a package what it does is it gives
those header files its own directory so
you have to be explicit on which utils
store H you're using you can't just
include you toast or H and have all the
other packages on the on the include
path because you really don't know which
one you're going to get so what they do
is they they make sure that they're kind
of given their own their own path and
you have
be explicit about which one you want and
that's that's a good thing in my opinion
I think it's quite useful and it has
also this concept of private headers so
when you're publishing a package you can
say okay well these are my public
headers and use my private headers so
don't only only export the the public
ones it runs on the JDK and it requires
Python I think most of these tools seem
to be using the JDK or Python or both
but they're all actually really smart
about how they use the JDK as well they
they have the JDK running all the time
as an agent in some ways so it you don't
have to wait for the JVM to start every
time you're in a build so these builds
can be very very fast ok so that was
that was the five build tools I've been
looking at so far but there's many more
out there we're not done yet
and if there's any build tools you would
like us to look into I'd really or if
you think that we should look into I'd
really love to hear more about it we're
trying to build some kind of
side-by-side comparison of all these
different tools trying to make some not
necessarily a feature matrix but at
least one place where we can see them
all side by side where they go where
they don't go and understanding all the
the places all the different features
they have and we also have set up a
bunch of basically a repo for each of
these build tools and we've implemented
a project use a build system for a
project with the tool created docker
images for to contain the environment so
we can all try and share the tools
environments and set up CI CT pipelines
for them so in all these cases this is
all open source and if you're interested
in getting involved please just jump in
send us a pull request create issues if
we've got something wrong if you want to
add something if this is interesting to
you jump in that's all I want to say
so thank you yes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>