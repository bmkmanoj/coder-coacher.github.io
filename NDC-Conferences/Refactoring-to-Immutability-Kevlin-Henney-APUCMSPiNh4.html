<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Refactoring to Immutability - Kevlin Henney | Coder Coacher - Coaching Coders</title><meta content="Refactoring to Immutability - Kevlin Henney - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Refactoring to Immutability - Kevlin Henney</b></h2><h5 class="post__date">2018-02-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/APUCMSPiNh4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right good afternoon so what I'm going
to talk about is refactoring to
immutability and I'm specifically
bringing these two words together
because there's no shortage of sessions
that will urge you how wonderful making
things less mutable is so I will clearly
start with that the problem that most
people encounter though is that they
already have stuff and it turns out that
that stuff the only way it's immutable
is the sheer fear of having to change it
okay the wrong kind of immutability and
it is filled with mutability that
becomes the problem so there's kind of a
from here to there how do we do that how
do we reason about it so there's more a
little more of a cookbook element to
this in the sense of trying to make
things possible because it's all very
well people coming along go ah there's
this beautiful land we can reach it or
you know if you're there you're there
but everybody else is here how do we get
there
so that's where I talk about my name is
Kevin honey I'm do various bits and
pieces I talk about some of this stuff
in one form or another and I have a very
strong interest in code the way people
express themselves in code the
challenges that they find there and I
quite like words I think words are
lovely things and I love wordplay this
is one of my favorite titles
it's from communications of the ACM a
couple of years ago immutability changes
everything I love that just as we have
this challenge of refactoring to
mutability it's just there's this notion
of we're constantly dabbling in change
and not change now for many people when
they think about immutability these days
they tend to think about functional
programming which i think it's kind of
sweet welcome to the club everybody nice
of you to join us with the idea of
immutability that's kind of been that's
quite old
it's it's a very mathematical concept
based on platonic solids basically
there's a sort of an immutable truth out
there beyond our universe functional
programming is kind of a it joined the
game late in the 1950s so all those
people are really getting into 1950
programming well done so but there is a
nice way of thinking about this that
Michael feathers tweeted a few years ago
and I think his rationalization that
funnily enough it was the way that I
explained this to a colleague many years
ago yes without the brevity of
old-school tweeting it's this idea of we
are constantly focused on how do we
organize state how are we how do we got
our heads around this stuff and each
discipline each paradigm that comes
along offers us a new way of reasoning
about the relationships between behavior
and state and it does so in a way that
ultimately we can fit it inside our
heads and we use various excuses like
better hardware and so on to justify
this but ultimately it's about what can
we do
whoa makes code understandable the
operative word here is not executable
but understandable it's about you hence
the challenge or the desire to refactor
it's ultimately about you it turns out
the processor doesn't really have a
strong interest or a strong care about
this stuff makes code understandable by
encapsulating moving parts which I
thought was a lovely way of putting it
what we're doing here is rather than
having kind of spaghetti spaghetti state
management what we're going to do is
we're gonna organize things ravioli
style and we're gonna bring things
together and say sure there's some state
change but it happens behind closed
doors we can reason about it clearly
through a method boundary but it is
isolated is the notion of isolation that
allows you to reason about it functional
programming makes code understandable by
minimizing moving parts notice that
these two desires are ultimately about
you and your ability to reason about
things but I like that idea of here's a
different road we're going to reduce the
number of moving parts that we have so
if you've got a turntable given that
vinyl is coming back into fashion if you
got a turntable I used to have an old
jewel deck and and you pay so much more
for a turntable that has fewer moving
parts because why why is that
it's just there's none of this auto
tracking press a button things happen oh
no you have to move the needle into
position and you pay for the privilege
okay but what you get is reliability
there are fewer moving parts therefore
there is less that can break and it's
exactly that kind of reasoning so yeah
there are other things that people value
about functional programming why do you
like functional programming so much what
does it actually get you I just love
that tail recursion is its own reward I
think it's just that it says everything
if you don't find that funny then I will
go to one of the functions of
programming sessions function program
combines the flexibility and power of
abstract mathematics with the intuitive
clarity of abstract mathematics is
another way of looking at it however the
bit that concerns us it's functional
programming typically avoids using state
and that is I think that's a very
moderate statement actually because
given that it comes from the haskell
website because house how scallions
would normally say it completely avoids
but they realize they need to speak to
people and they you know so therefore
they compromise typically I like that
yeah so let us start with a very simple
observation Bertrand Meyer who wrote the
book object-oriented software
construction many moons ago asking a
question should not change the answer
this is philosophically interesting and
valid but clearly he doesn't have
children
but nonetheless it gives us a starting
point asking a question should not
change the answer so that means if I can
frame my code as a series of questions
asking things about other things then we
can have a very rare very nice property
it is the idea that that thing that you
left you walk away you come back to it
is still there there's no surprises at
the principle of least astonishment more
importantly and likewise no children
here and nor should asking it twice
idempotence which is one of those
glorious words that means nothing unless
you know the latin EDM meaning same
potens meaning force it has the same
force no matter how many times the same
effect every single time you call it so
there is this idea we can rely on an
expression having a
not just a particular intention but
actually having a particular value we
can repeat that there's less to worry
about so a number of years ago I edited
this book 97 things every programmer
should know I was around 2010 and what
is nice is that there's about two or
three items in there as it were we're
ahead of the current trend for
functional programming that we're really
sort of urging you start thinking like
this it's valuable ed garsten
in apply functional programming
principles makes a point about
referential transparency very desirable
property implies that functions
consistently yield the same results
given the same input irrespective of
where and when they are invoked and and
this function valuation depends less
ideally not at all on the side-effect of
mutable state so ultimately what we're
after here is a very simple desire now
this is this is not exactly a
groundbreaking statement your code
should be reasonable yeah it might even
be understated because I mean we often
talk about your code should be good it
should be clean it should be awesome I'm
just saying it should be reasonable
which sounds it sounds like a complete
lack of ambition except that I want to
draw your attention to the fact that the
word reasonable has more than one
meaning okay you should be able to
reason about your code
your code should be both reasonable and
reasonable okay you should have the
capacity the ability to easily grasp
grasped it and understand it loaded into
your head and be unsurprised by the
outcome
so what stands in our way
so John Carmack sort of Gaines
programmer extraordinaire made this
observation in a functional programming
in C++ article a few years ago a large
fraction of the flaws in software
development are due to program is not
fully understanding all the possible
states their code may execute in and I
think this is quite important because
what we end up with was sort of a
failure to understand the consequences
of the simplest choices in our code
um Sony does anybody know where this
comes from
yeah well games excellent you if you
don't know what wargames is you have
between now and the film release of
ready player one to figure it out
because otherwise you won't get anything
yeah okay
so I was I grew up in the 1980s and this
was this is what we worried about
nuclear war
so hey no change I'm you know I'm really
glad that my kids can get the same kind
of experience of like the threat you
know it's just like hey sons this is
what it means your imminent apocalypse
you know the world is on the edge here
so it turns out I have watched this with
my oldest son the minute we were able to
cut me back to three years ago and it
was so funny after after we watched it
he said dad can we program an AI it's
just like okay that's a little ambitious
but let's just start with some Python
here so how to get kids into programming
I want to create a malevolent or you
know no amoral I so the reason I
introduced this here because things
could get out of control very rapidly
you end up with global state problems
you can end up with global thermonuclear
war and the observation that John Cox
furthermore and this is another concern
that people have suddenly discovered
they have in a multi-threaded
environment the lack of understanding in
the resulting problems are greatly
amplified almost to the point of panic
if you are paying attention now I love
that sentence if you are paying
attention if you are not panicking you
and everybody else around you is
somewhat concerned you have missed
something you're either in a very happy
place and you it all works for you or
you have missed something
now I'm not a I'm not a gambling man but
I'm gonna put my money on you missed
something okay if you are paying
attention so um as I said I was a child
the 80s this is this was a there was a
we just out leverage context here
threats did anybody see that so for that
yeah just a handful you have to be of a
particular age and have to have grown up
in the UK and been of a telly viewing
age appropriate age this was horrific
this was a TV prat well a docudrama
about a bomb drop over Sheffield and
there an air boast over Sheffield it was
utterly horrific it came the year after
an American film about nuclear war it's
called the day after it made nuclear war
look quite moderately Pleasant it was
sort of like sort of Dallas or dynasty
with bombs this one pulled no punches it
was utterly utterly horrifying I'm going
to school the next day and we just sat
there kind of like slack jaws Wow
that is scary stuff but the program is
called threats that's what I want to put
in your mind okay threads this is how
you think about threats okay this is
this is what you need to be thinking you
know ultimately atomic war or lack of
atomic war normally what happens with
this is when people think threads what
they think of is locks there's a kind of
a built-in Association in many people's
minds you say threads they say locks
okay and what they're doing is why don't
we why do we have this association
people often say well I want to use
locks for safety okay
let's pause a moment why is your code
unsafe what line of reasoning calls you
to create code that is unsafe so I drew
up during a workshop a few years ago I
drew up a simple quadrant diagram and
given that it's the afternoon and your
brains have gone in to carve oh slump
this is about as far as we're going to
go here this is what we need a quadrant
diagram it's nice and easy to reason
about and basically we can divide up the
relationship between behavior and state
in your program very very easily
your state can be shared between threads
simultaneously or it can be unsure okay
that state can be mutable or immutable
now that gives us a rather interesting
diagram here of where we actually need
to lock stuff all so let's just make
this really clear as with any quadrant
diagram normally one quadrant is very
very good or one quadrant is very very
bad in this case it's very very bad okay
and just so we're there's no there's
doubt I've used the universal color for
danger here this is red and you know in
some cultures red is the color of
celebration that's the consultants and
this is the synchronization quadrant I
want you to I want to point out that one
quarter of the diagram is bad the other
three quarters all is good and life is
simple because if you if you are not
sharing data you can do what you want
with her if this thread has this data
and nobody else ever gets to see it
then we're good or if they get to see it
it's only after it is handed off
explicitly in other words it's only one
thread at a time we have unique and
exclusive ownership you can make it
mutable you can make it immutable the
point is that no change will be visible
to anybody else alternatively you make
everything unchangeable immutable
therefore you can share with impunity
and that's great you don't need to do
any locking now there may be locking
when I say you I mean you as a developer
you don't need to take this stuff into
account if you are using cues to hand
off relationships from one place to
another then clearly there will be locks
at some level but I'm saying those are
commoditized locks that's not something
you as a developer have to be concerned
about or put it another way you are not
given the privilege or the ability to
get it wrong okay you are not given that
degree of freedom you hand something off
to a queue and it's just like no queue
I'm going to mess with your locking
strategies you don't get that option so
this is the curious thing why do we end
up with you know we seem to be like
moths drawn to the flame of the top
right hand corner how do we end up with
all our code in the red zone in the
synchronization quadrant the quadrant
where we are most likely to make the
errors most likely to struggle with our
reasoning and also the area most likely
to slow down your code it is always
remembering that the point of a lock is
is to stop concurrency yeah as I noticed
on the wall here admiring the traffic
because Westminster Bridge has been
closed so there is a point how do we end
up in this quadrant why we why why is
all the reasoning in our languages
gravitated towards that why is it
reflect
in our languages so once upon a time we
did not have all this stuff so let's
just pick on C for a moment okay C does
not have any primitive constructs for
threading it eventually is eventually so
basically all the API is ultimately end
up in C and the constructs like locks
mutexes to acquire and release those are
built into libraries so then we have
Java coming along in the mid-90s saying
you know what we can have a built-in
statement to synchronize block and then
c-sharp reflected that with its lock
block so these these were initially seen
as an improvement we have the ability to
synchronize built into the language
along with if statements but if we pause
from home we realize it's actually a
step backwards or rather step in the
wrong direction we can monetize the
wrong thing because what we've ended up
with is an encouragement that hey locks
are easy you can stop your program
really easily you can slow it down
that's what these are that's what these
constructs are for they are the
elimination of concurrency so
historically there was actually very
simple answer let's go back to C once
upon a time all your code was naturally
on the left hand side because you
couldn't you couldn't share between
threads because you didn't have threads
that was easy yeah so all the code
gravitates to the left-hand side and for
reasons of history in other words
programming languages growing out of an
imperative model assembler as well as
resource constraints and I know people
are always complaining about resource
constraints and I did have somebody
complain about some of the techniques I
was proposing for a particular project
was a couple of years ago and he said
yeah I don't know if we can do this on
our project cuz it's embedded and we may
not have the memory resources and I said
so what what what kind of memory
resources are we talking here
what kind of constraint what kind of
hardship are you working on her and he
said 128 megabytes and I said get back
to me when you have a problem yeah you
know this at this point I'm gonna start
saying you know when I was a lad you
know you're lucky if you got two bits to
rub together ones and zeroes no no we
didn't get both yeah so the point here
is that that naturally drew all the code
and a lot top left hand side when
threading became commoditized it just
opened up this new territory on the
right hand side so we naturally wandered
over hey look we've got procedural
thinking let's just add threads to it
and excitement followed so let's talk
about the idea that this is
architectural it's not many a language
construct architecture represents the
significant design decisions that shape
a system where significant is measured
by cost of change it turns out taking a
code base that has an assumption of I
can change anything and turning into a
code base where that's not the case is
non-trivial it's not just simply a case
of creating new code in an immutable
style there is a genuine challenge here
and the appreciation it's not it's not a
new appreciation the term technical debt
dates to 1992 that was Ward Cunningham
Meyer layman wrote this in 1980 as an
evolving program has continually changed
its complexity reflecting deteriorating
structure increases and less work is
done to maintain or reduce it so what
we're dealing with is the problem that
somebody said immutability is really
nice but what we have here is a legacy
system we have the past being an
incurable romantic I took my wife and
kids to Stonehenge last year on
Valentine's Day you know why wouldn't
you and yeah I took I took this shot and
the kids were impressed by the size of
these monoliths monolith us coming from
the as a monolith comes from the Greek
monolith us meaning one stone big stone
hard to move stone so you know it makes
it makes that experience of your legacy
system feel real you can't move these
easily or you're wondering how people
move them at all and this becomes the
challenge so whence comes somebody comes
along and says you know you need to
refactor we look at this and we say a
change made the internal structure of
software to make it easier to understand
the cheaper to modify without changing
this observable behavior how much change
is that to change something that
naturally assumes everything is
changeable into something that is more
local based on data flow objects is
non-trivial so some of these may end up
being big refactorings so what
focus on here is the developmental side
you can kind of look at any software
system and break in along roughly it's
an approximate right-hand rule given
that my fingers are not at right angles
I don't have any problem saying that
these axes are not perfectly at right
angles either but we can break it down
functional behavior operational behavior
execution use of resources performance
all this kind of stuff and developmental
qualities refactoring concerns itself
with the developmental dimension in
other words you keep the functional
behavior the same you preserve the
semantic behavior when you refactor that
is preserved developmental quality
hopefully improves and the operational
can go one way or the other if you're
optimizing something the goal is
slightly different you keep the
functionality the same you improve some
aspect of performance but the
developmental quality may suffer so this
is kind of an important idea the
preservation of functionality and
functional behavior there's no good
having an optimization that breaks so
I'm looking at you
specter and meltdown people are saying
oh that's Hardware fault no it's
actually a software fault hardware it's
software okay the way that those are
structured so how do we do this we have
a bit of a problem because it's not that
when you walk away you don't have
knowledge of a number of techniques and
functional ideas or immutable techniques
for your objects the problem comes that
you may find yourself working uphill or
working against the grain as observed
here many programming languages support
programming both functional and
imperative style but the syntax and
facilities of a language typically
optimized for only one of these styles
and this is the most important social
factors like coding conventions and
libraries often force the programmer
towards one of the styles so it turns
out programming is a very cultural thing
and many of the cases where I've seen
coding problems in existing legacy
systems it is not because people have
been stupid or evil it is simply because
the code much as they want to go that
way the code wants to go this way all of
the libraries all the conventions say no
you need a default constructor here no
you need to expose these as public no
you need to do this to go against it is
to basically have a system that does not
build which on the other hand is not
because then you don't have any bugs and
people can't complain about bugs in
production it's just you have no
production people might complain about
that instead so there's a challenge here
that said people do often have various
habits not all of which are healthy
looking at you singleton so that's my
singleton that's actually quite a good
singleton it's far better than the kind
of single since people put in their code
but people get into this habit of
putting the stuff in so let's deal with
this kind of idea listen management we
have some kind of clock concept we're
gonna have an instance make it global
and so we've got clock dot instance
there's a singleton there and from that
we can get the time of day now and that
that's great so everybody universally
accesses the clock and there's only one
true clock in the system okay what's the
example code look like well it looks a
bit like that which is anybody come
across the law of Demeter Demeter okay
not a lot of people it's a slightly
obscure Lea named thing it's not nothing
to do with Demeter is a clatter who's a
figure in classical mythology it's
actually to do with the software system
that was developed a research system
developed in the 1980s and the system
was called 2 meter Carl liebherr and
others observed that there was a
practice that they had adopted which is
basically don't create well we would now
call it as don't create method chains or
train wrecks don't end up with stuff
that goes thing dot thing dot thing dot
thing we're not talking about fluent
api's here we're talking about digging
into an object structure I'm gonna get
you then I'm gonna dig into something
else then I'm gonna dig into something
else and then somewhere at the bottom is
the value that I'm after problem with
that is there is an immense amount of
coupling through the intermediate object
structure and people's it's a little bit
like long URLs to many components their
eyes start glazing they very rarely
reach the end of the train wreck it
turns out that any use of singleton
automatically is a violation of the law
of Demeter
so that's just a minor observation so
that's where our code looks like now and
so we have the simple question that
people often have well you know why
should I replace the singleton it makes
my code convenient look that's how I get
the time of day yeah you know it's
really easy now you have a bit of a
problem um first of all I'm gonna I I've
got I gotta put really good money on the
fact that although I've got three time
devices I've got one of these I've got
phone and I've got a laptop I'm prepared
to put money on the fact they do not
tell the same time it turns out that
clocks have different times I have
worked on an embedded system where we
actually had two different clocks and
you had a choice of where you got your
time from it was to do with granularity
and purpose of the clock so first of all
we said there was only one universal
clock now that may be true for your
system but we do have another
interesting question how am I going to
test this how am I gonna unit test this
I can't unit test it oh that's fine run
it as administrator and change the time
for your unit test at this point you
will discover that the answer to the
question are we alone is no because
there are other things running on your
machine that may have a strong opinion
about you messing about with time you
are not a Time Lord okay oh well within
a certain constraint you are but but
this convenience what have we done
we haven't actually made anything that
much more convenient we've maybe saved a
cup of character so let's just change
this a little bit that's amazing how did
you do that did you actually pass in the
clock what we've done is we've changed
the idea of time being a universal which
it isn't
we knew this in 1905 so why it's taken
us till 2018 to acknowledge this time is
not a universal what we've done is we've
passed in a concept of time here you're
a piece of code I want you to use this
time series or other this this source of
time time is a resource just like a file
I don't want global files I don't global
database handles and most things that
people think I can just access time out
of thin air that's a programming
convenience I wish did not exist in most
api's time here we have I'm going to
pass you a clock use this one it's that
one or this one
doesn't matter you don't have to worry
about
comes from and we now have a very simple
concept there it's face clock and we can
go ahead and have a clock in pull Wow
now if you're a dotnet person you're
probably struggling a little bit you
probably can't read the first line
you're going like what was he done there
that I can't read oh he's missed out the
letter I that's what he's done oh I knew
I couldn't read it because it doesn't
have that weird walks that I put all
over my coat
and yeah those people who do click who
do the import thing god they're so
stupid look if we do I o'clock then we
can use plot the same problem okay it's
the same problem what you've done here
as well is a failure is it we can
clarify the failure of abstraction
there's a refactoring here so first of
all we factor out we move the things
that are global to be parameters the
second thing we do is we decouple the
parameter from a concrete type the next
thing we do is we accurately describe
the concrete type and unfortunately both
the import and the I approach have this
habit of allowing you to be lazy with
names you have what you've done is
you've accidentally missed the
opportunity to name the concept what
kind of clock is that it's a clock clock
Wow
thank you for that it's a local clock
it's a mock clock it's or whatever clock
tell me what it is okay you you have you
have this you know you've got you've got
autocomplete you've got I'm not even
using up loads of names here I mean
given that most of your codebase
probably has abstract controller Factory
singleton clock then this is quite
simple economy okay so then we can mess
about with whatever naming conventions
we like okay so that's the first bit the
next thing is you might realize the only
thing you're ever going to get from the
clock interface is one think at the time
of day or you can actually narrow the
abstraction you don't need an interface
for that so we don't actually need to
introduce an intermediate abstraction if
our language such as C sharp such as
Java supports the ability to pass
through a simple direct functional
abstraction so yeah give me it give me
the time of day so now what I've done is
I've reduced my source of time to a
simple function I can simply call it
when I need it and then the most
mind-blowing thing is why don't we just
pass in the time
and what we've done is instead of making
this a higher-order function we've
simply said example is a function of
time that is actually directly stated we
haven't hidden a dependency in the
original example we had the idea that
there was a hidden dependency which we'd
obscured it we have made something
convenient by saving a few characters
typing but we actually lost the
explicitness of this is time dependent
behavior now we just turned it into a
pure function this is much much simpler
so one of the things where people are
passing around controllers and factories
and and provision provisioner type
objects it's simply a case of like well
what's the result that you want let the
person who calls it make that decision
okay
this code is far simpler to test to
reason about and so on of course there
is the possibility as Alan Perlis noted
in the early 80s if you have a procedure
with ten parameters you probably miss
some so clearly you cannot just keep on
abstracting and adding extra arguments
that tells you probably that you've got
too much behavior but it tells you can
also group the behavior okay so we can
see there's a bunch of things reducing
scope of variables eliminating the
second sign which I haven't covered
Global's as parameters replacing long
parameter lists with parameter objects
which I haven't covered and replace
resource passing would actually give me
the value that you want so let's explore
that time-of-day thing a little bit
further so in this book they covered a
few years ago we talked about the idea
of immutable values defined value object
types whose instances are immutable the
eternal state of a value object is set a
construction and no subsequent
modifications are allowed so the idea is
that your object has a value and it
retains that value many ways this is
unsurprising but for a lot of people
they don't think about their code in
these terms so they end up naturally
shoving in setters so we can actually
take some examples I have some currency
in my wallet and I have a choice of
currency so I'm going to choose
something a little more stable than the
pound I'm going to choose the Euro I
have no idea what the pound is doing
probably falling who knows
and what we have here is I've got 20
euros here and this is 20 years it will
retain its 20 Uranus for all of its life
I'll have another 20 euro here they are
they differ only in their identity Weiss
make that bold statement let's just
check they're not yep they do actually
have a reference identity that's a
serial number they are different so
they're although they have identity
that's not how we use them their their
usage is anchored in the value that they
can present
that's all very logical that's all very
nice and we know that and we suddenly
find ourselves inside an IDE and board
before we know it we've got setters
everywhere why have you got setters
because my IDE allows me it just
automatically puts them in I've got a
really good shortcut it puts getting set
in every single time yeah I can do the
wrong thing faster at speed
look at this automated bad code
generation yeah and it we fall into this
little trap because of the an accident'
quality of English that getting set they
rhyme a share most of the same spelling
they feel like opposites they're not to
get is to ask a question although it's
actually a slightly rude way of asking a
question get is a very raw English verb
get implies side effect in case you were
wondering this is often a concern often
a surprise to people who come to English
via the road of development yeah get
means query no really it doesn't
disappointingly when I got some cash
from the from the machine in the wall my
bank balance went down side-effect okay
you get money there is a side effect you
get married there is a side effect okay
yeah so these are the word get in
English means the following will change
the world it will have a side effect
okay so we've been lulled into this kind
of convenience because the words have a
certain you for me get set and we do
this I often have this in classes when
I'm running a test driven development
classes where somebody will quite
happily be writing good tests and then
I'll say what's that setter doing oh
yeah we it was just there
yes sir seminary wasn't just there
because the co didn't exist ten minutes
ago didn't just appear or rather it
appeared through the power of fingertips
but there's no test that car so if I
delete all the setters the care the
tests will still run yes
okay let's delete all that but don't we
need a little uncomfortable with this
kind of loss of perceived symmetry so
let's go back to our time of day concept
okay we've got hours we've got minutes
I'll skip seconds and we've got this
idea of I can change the hour I can
change the minute I presume there's
going to be appropriate bounds checking
on that and I can also ask it please
move to the next hour please move to the
next minute and many people will arrive
at the solution perhaps without
realizing this and then they'll go and
build an implementation like that yep
good I believe it works I think I wrote
tests that's fine okay so let's go back
to this how are we gonna make this
immutable without breaking all of our
code well the first thing we can do is
obviously get rid of the setters now
that how'd that that only does half of
it that's the how do I make this
immutable I'll get to the next bits in a
moment but without breaking our code
I've got stuff there that did actually
end up relying on those setters then
I've broken the bubble I've broken the
illusion is no longer it's not a good
refactoring because it no longer
compiles so I'll just shorten that so
we've actually got hours and minutes
okay what we're gonna do is we're gonna
recognize that setting is a different
way of looking at something what we're
doing when we're setting instead of
saying I'm going to change the value of
this object we start from a different
position we say given this object in
this particular state what I would like
is an object that reflects the following
change it's a quick it's it's a it's a
polite request rather than a forceful
request okay
please give me an object that you know
if the time is fifteen thirty five
please give me an object that has the
hour as 16 okay so what I'm doing is I'm
asking for a transformation I'm asking
for a diff
and I'm gonna say if you've used a
version control system before you might
be familiar with this approach okay so
therefore that's what we're going to do
we're going to change the sets to widths
we're going to say given this when I
transform it then give me that it turns
out we we are already familiar with this
I don't know maybe you were four maybe
you were five maybe you were six but
when you were taught to add numbers this
is how you were taught the teacher came
along and said okay you've got two and
you now add three and you get five
that's great and you're able to use the
same to the same three in the same five
the next day they haven't changed the
addition of three to five the addition
of three to two did not change the two
okay there are programming languages
where you can you know do serious
violence to the concept of such numbers
we do not recommend that but what we're
doing here is we're saying two we've an
extra three that's what we're saying is
that that's great so the problem that I
find when many people do that they say
right we've got rid of the setters yeah
but you haven't happened now you broke
on my couch how do I do this without
creating too many without creating too
many changes in my code well it's just a
simple transformation to a width we also
say next hour so the next hour is now a
query although you may be what may want
to go via renaming and to avoid some of
the surprises because it turns out a
point of call these both look identical
or can look identical and you may
discover that this is not going to work
out for you very well
why is my code not working I've still
got calls to next hour so there is a
scope for making it actually actively
incompatible and then reverting to the
most convenient name so what you do this
let's put in a constructor so that we
can actually see that we start off so
the most important thing is you give an
object a good start in life and one of
the things we're going to say is
actually in many cases with value
objects we don't support the idea of
default construction now this is a
problem I just want to clarify when I'm
using the term value objects I'm using
it correctly
unlike dotnet which mean
passed by copy objects it turns out the
string is a value object that's not a
value object which is confusing in
vocabulary so when I'm talking about
values I mean things that model values
like currency like time of day and so on
not the struct types okay um you want to
make if width is not enough for you you
can add in a builder so think string
string builder so you know through
progressive changes so we now got the
code it's about the same amount on the
slide
we haven't actually changed the amount
of code it usage it's about the same
amount so this is the interesting things
we've ended up with the same amount of
code just phrased differently this is a
relatively simple thing to do will your
object creation costs go up or down yes
it depends how you're using it it turns
out if we're sharing this then that
means I don't have to do defensive
copying there's a lot of code that has
defensive copying I'm going to give you
a copy of this because I don't know what
you're gonna do or alternatively it has
defensive comments hey I'm gonna pass
you this but please don't change it
because there's another object currently
sharing it so it'd be really good if you
just didn't call any other modifies
thanks bye comment server and not
perhaps the best way to guarantee these
invariants in your code so I treat that
as a separate issue but it's a problem
that you need to create if you want to
solve it rather than I'm not going to do
it because I might have a problem no you
already have a problem okay so um we can
have this simple idea remove modifies is
the simplest but how do we actually
replace our modifiers replace
modifications with constructors move so
construct new objects move modifiers to
a builder kind of style replace the
side-effect with a new object make void
methods fluent so there's a kind of a
series of things that we can see in
moving from one style to another now I
want to talk about objects and
psychoanalysis it turns out
psychoanalysts psychoanalysts are
utterly obsessed with objects slightly
different objects but i think it's kind
of nice that's a snack of verse like
therapy books my mother was a
psychotherapist and it has had no effect
on me whatsoever yeah do not trust me as
software developers your kids will grow
up from way less screwed up
it did give me an introduction to
objects from a very early age our book
is simply a container of an idea like a
bottle what is inside the book is what
matters we will see that the content is
there however the reason I've got a book
there is the gratuitous fact that it is
in fact a stack of books which means
that I am going to talk about stacks
that quintessential labrat of computer
science is shift language hearing a
shift to Java because I was told guess
what NDC is broadening out from the
darknet world so here you go and it
looks no different at this level but no
matter you know if you ever struggle
with porting between the two there are a
few differences but mostly it's case you
know change main the case of main so if
you know where the case shift is on your
and your IDE you're sorted that might be
a little flippant but it's a good
starting point okay so let's actually
put some stuff into these Java so I've
got a I've got a structure I've got a
number of things I can do with it I'm
gonna keep the the objects API very
simple you've got the depth I can ask
I can query the depth I can ask the top
element pop is what we might call a pure
pop in other words it does not return a
value it just pops it is a pure
imperative operation in that sense kind
of curious to hear the words pure and
imperative in the same sentence there
but there is the idea this is a
procedure in a classic sense it does not
return a value it merely changes the
state and then we've got push it's for
operations I've wrapped an ArrayList on
the inside and this does expected things
if you try and pop or take the top of an
empty stack you get an illegal State
exception okay
now to make this immutable there might
be an initial sense where you might go
alright so I need to create new copies
of every time I do something to a stack
I need to create a new copy of the stack
you know this is going to be quite
expensive to copy a collection every
single time you're going to use it it
was okay to create a new money object in
new time of day object whatever because
these actually it's not going to make
much difference we will end up with
similar amounts of object creation but
we're not talking big objects
collections have a very different role
we're actually talking at the collection
level and whilst this is a toy example
and you know the number of books in the
background is relative
small when you start dealing with
collections or millions of items and
somebody says yeah I'm gonna add an item
I'm going to push an item onto that so
let's create a copy of it all million
items and then add one that's clearly
going to be an expensive way of going
about stuff and it's not merely a case
of don't worry the memory the memory on
your machine will catch up eventually
this we've we've we've have actually
created a problem here so a problem
which we can respond to using persistent
data structures in computing a
persistent data structures the data
structure that always preserves the
previous version itself when it is
modified again I refer you to version
control systems the reason I'm making
that point is because I had this
experience a few months ago I ran a
workshop for one company and I talked
about persistent data structures and I
introduced how to implement them and one
guy said ok I get all this this looks
really cool but I can't see how I'm
going to use it in my day to day job and
I said do you use git and he said yes
and I said you use it in your day to day
job ok this idea of retaining the
previous version it doesn't actually
have to be immutable let's be very clear
when all of software development is
ultimately about maintaining a series of
clever illusions when people say that
executing a pure function has no side
effect that is an illusion of course it
has a side effect you can actually sit
there and measure the amount of
electricity used you've changed the
entropy of the universe I think that's a
major side effect ok so if you're a
Haskell program you'll think you're not
changing the universe in the way that
you intended for good and whatever you
are changing the universe it is a
measurable effect but that turns out to
be not the effect we're focused on the
code so as long as we maintain an
illusion then that's what it's about
that isn't ultimately what any
optimization is about it's about
maintaining an illusion of something
else but doing it in a different way so
what we need such data structures are
effectively immutable as their
operations do not visibly update the
structure in place but instead yield and
you update a structure we will make it
look as if we have lots of fresh new
stacks in memory but actually that's
just an illusion don't confuse this with
the idea of persistence in sense of data
storage okay so let's let's look
his favorite default data structure the
array and I'm not gonna get fired to do
persistent data structures that is
really a topic that you can for which
there was an awful lot of very
interesting research but let's start
with the simple stuff and a right so an
array referred to as a okay that's how
am I going to make this if I make this
as stack so I've got a cup or items okay
how do I pop from it well that's easy
first of all I'm gonna say B is equal to
a so we're now pointing at the same
stack than I ago okay B is a dot pot at
this point I've now got a referring to a
stack of I got a referring to a stack of
four items and I've got C referring to a
stack of three items which happen to be
the same as the ones that a is referring
to but that doesn't matter there is yeah
it's a little ushion we haven't actually
had to copy this stuff and this is great
it doesn't work push though so let's
shift that to a linked structure which
point we can recover this okay a B is a
C is a pape we can move through and then
the clever bit which is where we do push
okay and we can have the sneaking off
into memory I can quite happily say e is
the push of a different value there and
we end up with a tree going off into
that so we've got a shared data
structure if you try and do this in
systems without garbage collection good
luck to you it's non-trivial it's a bit
of a pain to be precise but what we've
done there is maintained an illusion as
far as we are concerned if you look at
those three roots a D and E we've got
three stacks up there but you're only
seeing one data structure that's linked
we got three stacks up there
there is a which has four elements there
is D which has five elements the top of
which is X and the other four are
identical to a there's E which has five
elements the top of which is Y and the
other four are identical to those in a
so that is the essence if you like of a
persistent data structure however to
maintain this illusion there are some
rules there are some house rules and we
also recognize this is not a new idea
I mentioned 1950s what I was really
referring to was Lisp which is kind of
similar age to Fortran although the
first proper implementations didn't come
about till the early sixties but it was
all there
is a very very old idea and that is the
essence of the illusion that lisp offers
people so we can go back to our stack
and we can offer a very different world
view on it instead of thinking of a
stack as being a thing that you change
it's the thing you go to ask questions
off so we're going to change there we go
we've got depth top no difference there
pop is now I would like I'm not going to
pop a thing I'm going to basically say
given what you are what would you be
without your top element yeah
with pop or without top yeah
what would you be with this extra top
element so it becomes a much more
serious as much more polite conversation
based on leading questions admittedly so
we have a very different way of looking
at this because things never change what
I'm going to do here is I'm going to
recognize that the stack has very simple
state model and it turns out that all
empty stacks are equivalent and I can
actually describe the behavior for them
so I'm actually going to implement the
interface say empty I have a class for
empty stacks and there are there we go
the depth is always 0 the top that
doesn't have one so it always throws
illegal state exception pop it always
throws illegal stay exception and when I
come to push something it returns a non
empty stack I'll factor out a few things
here just a bit tidier so we've got that
and then when it comes to the non empty
version then the death is always one
plus the depth of whatever it was if
you're concerned that this leads to
linear a linear cost you can also cache
the lengths because it will never change
that's the benefit here and the top is
always the top is never an if and so on
so it turns out this is surprisingly
simple stacks can be empty or non empty
the behavior for empty is always the
same behavior for non empty is always
the same and what we've done is we've
eliminated if statements indeed there is
indeed a thing called the anti F
campaign absolutely slightly
tongue-in-cheek but unless you know puts
in an import point the goal of the anti
if campaign is to raise awareness the
effect
use of software design principles and
practices by first are all removing bad
dangerous ifs yeah which is all of them
branching code confuses people yeah we
are we are merely mortal and we are
human we struggle with ands and ORS and
ifs analysis and these are where bugs
come home to roost so the difference in
usage between our two different stack
models is previously we said we've got a
stack now I'm gonna push something on it
now I'm gonna change it again here what
we do is we say well I'm going to start
with an empty stack and then I'm gonna
want it's the stack that results from
empty having NDC pushed onto it having
London pushed onto it so if you like
there's a much more much more obvious
data flow going on in this we've
replaced a sort of like then do this
then do this then do this with a flow of
possibilities a stream of changes or a
stream of application now for this to
work there is an illusion we must
maintain the type that you put in there
so string works nicely there's to be a
type that is immutable or you must
guarantee the only instances that will
never be changed there because we have a
shared data structure if you put inside
that collection objects that can be
changed you will break that illusion now
you're already doing this without
realizing it particularly if you're
using things like mapped or dictionary
can collections because you're always
told if you look at the small print
please don't change the key you're not
allowed to please don't change this
value because you will actually blow the
encapsulation of the data structure
apart because if a data structure is
carefully either by hash code or by sort
position put and a value in a particular
location and you change via a different
route via a reference to it it's hash
code or its salt position it will never
find it you've actually undermined the
encapsulation of another object so
there's no me a polite warning but that
is enforcement by comment or enforcement
by MSDN which is pay for it's printed on
so here we have this idea of replaced
mutable collections with persistent
collections either an actual persistent
collection or using something in a
persistent manner I replace musical
collection values with immutable values
make sure the contents
unchanged when we kind of dealt with
that before and replace state based
object behavior with polymorphism
because they never change now a final
bit that I want to cover is this
question of control flow so there's a
really nice example in 97 things every
programmer should know from Birkhoff
Naugle put the mouse down and step away
from the keyboard now this is just
generally good advice okay if you are
struggling with a problem you think that
the challenge is to solve it okay that's
kind of obvious yeah I have a problem I
should solve it and what you will do is
you will dig will dig into it and you
will dig further what you will
ultimately achieve if you've not solved
it is a very big hole you'll find
yourself at the bottom of it it turns
out that it's very difficult to solve
certain kinds of problem at the level at
which you failed them you need to do
something different so the advice here
is put the mouse down step away from the
keyboard and he uses a particular
example to motivate this I have a
different way of looking at I've always
recommended that people do something
that changes the situation there therein
you need to think differently if you are
stuck in something and you are thinking
the same way then that is your problem
and so I often tell people if you've
been if you've been mainlining coffee
all morning and you have a problem and
you are you're just filling yourself
with more coffee to solve it then I'm
going to I've got a radical suggestion
for you try some chamomile tea
because clearly coffee is not the answer
in this case if you're sitting there
virtuous is saying well hell I don't
drink caffeine I drink chamomile tea
then my recommendation to you is drink
some caffeine because the thing that
you're doing you need to change you need
to think differently and trust me if you
don't drink caffeine drinking caffeine
will change your behavior if you are
sitting down stand up yeah it's kind of
there go home go for a walk whatever it
is it's gonna look at pictures of cats
unless you do that all the time ok so
the point here and he gives a specific
example maybe was that he said he was he
was wrestling with this code and you
know you look at it it's very procedural
okay we've got string with a parse it as
an integer if that fails then clearly
the thing was not in
integer format and then and there's a
dot dot dot here which is operative in
other words this is quite long code and
this is kind of brute force its way in
now if you're writing enterprise code
this is what you do for a living okay
but if you want to do something
different then put the mouse down and
step away from the keyboard but she did
and you came back the next day and said
what do we do I recognize this is a
different problem but there's a regular
expression that does this now there is
always the standard joke you know I had
a problem I solved it with regular
expressions then I'll have two problems
which I I always think shows a lack of
appreciation for regular expressions
I now have star problems you know on the
other hand this goes right back to what
we're doing here is we are replacing a
very explicit decision structure with
something that is far far more
intelligent we are using an intelligent
data structure and I look at this and
again I use my kids as sort of a sort of
simple way of thinking how would I
explain this to my kids
it's as bad as trying to explain public
you know public class blow our public
public static void main
you know I've talking Python it's a lot
easier this is just like putting needles
in your eyes but without the fun so the
point here is that I can explain the
time format very easily to somebody who
is not a developer in comparison to this
this is a painful way of walking through
this this I can say you might not be
familiar with the notation but let me
show you what's going on yeah the one
thing it doesn't I did actually get a
bug report for this in the book it said
it doesn't account for leap seconds and
I said if you can properly account for
leap seconds then file a bug report
because I've met very few people
problems in the front row know enough
about leap seconds to be able to file an
accurate bug report so let us just work
with something we know works most of the
time so I close with a different
different example and some want to talk
about this idea of moving away from the
explicitness of code that we we get
become comfortable with the idea after
after many years and become comfortable
the idea
we have become program counters which i
think is particularly demeaning from a
human point of view you're very good at
going through code and going if and wile
and you know structuring it all together
there is this idea that perhaps we don't
need to spell out every single loop and
decision but I'm going to focus on loops
for the moment we don't need to spell
out every every loop you have written
all the loops you will ever need to
write in your life in fact you've
written more than you know the kind of
loops that I mean you know the one that
goes through everything and does the
same thing to everything in a collection
and then there's the accumulation loop
and then there's the loop that does
something on a condition and then
there's the you've got this all in your
head it's all lovely and you know it
doesn't take much program experience and
then you probably encountered with the
kinds of loop that you will ever need
and yet you have to repeat them yeah
it's something profound and self
referential in the repetition of writing
a loop and perhaps there's something
calming and kind of like there's a sort
of a yogic feeling to it so it's a
mantra that you chant every time you're
trying to get some work done
by avoiding the work and writing a loop
instead that somebody will then have to
come along and interpret because the
loop is all about bookkeeping it's all
about how I'm going to set up this very
I'm going to do this like a dis and then
and somewhere inside it is what you're
actually trying to do so we see that
there is a trend in many languages that
did not start there to embrace forms
that look like this so Java has ended up
with a collection pipelines model
c-sharp has ended up with link embodying
a more sort of a predicate logic type
thing and whichever way that's the
direction that this is heading and so
rebel labs publish this begin last year
I think no the year before and they had
an example here I looked at the example
it's the one middle first stream example
I looked at the example I thought that's
wrong they've implemented it incorrectly
so I tweeted this at them and they
corrected it which is still wrong so I
don't think it's correcting it it's in
correcting it they took a wrong thing
and made it all so wrong but differently
wrong so okay I'm not expecting you to
understand
what's wrong there so let's let's let's
build this back a little bit so what
we've got is their their objective get
the unique surnames in uppercase in the
first 15 book authors that are 50 years
old or older okay so we take a library
which is some kind of collection books
we stream it we mat and take a book we
get the author we filter filter in
select select will be a far better word
we've filtering we look at the author we
get their age if they are 50 or over
we're having them and then we limit that
to 15 then we get the surname we shifted
to our case we Uniqua fie it and we
collect it to a list that's brilliant
but it unfortunately doesn't actually
meet the spec why not okay because I
have books I have multiple books by the
same author so if by first 15 books for
example by the same author then I
haven't actually got the first 15 book
authors that's the that's the that's not
the that's not the same thing so okay
let's try this one again so this is
their correction or in correction what
they do over 50 shift get surname
shifted to uppercase
uniqua fire limits 15 ah unfortunately
that is the first 15 unique author names
which is not the same you may have
authors that have the same surname but
are actually different so again this
this fails and actually it turns out you
need to new an equal fire in two
different places get all the authors
that are over there 50 are over get the
unique authors limit that to 15 now do
your case shifting and all the rest of
it and that actually matches their
requirements so what is interesting here
is again if you're not familiar with
this API you can actually walk through
it and understand it with the level of
explanation I have just offered you so I
did this example a couple years back and
Tricia G ventured to me she said you
know that's really good but wouldn't it
be more interesting if you showed what
the original control flow looked like
that would be compelling you know she's
right so I did that so this is the
original example as you can see it goes
on off the screen so let's just shift
the so first thing more code
next thing how much of that code is
actually about what can you see that it
is use one can you see what it's doing -
can you see that it's wrong you've got
an awful lot more things to do of course
you're intelligent you're not going to
admit this is harder Jam programmer I am
at NDC of course I'm smart enough to do
this I'm not questioning your
intelligence and question the immediacy
of this and we should move away from the
idea of hey it was hard to write so
should be hard to read we should move
away from that philosophy and the point
here is that yeah that's not as
immediate I'm having to do all of that
yeah okay remember that piece of state
this isn't a kuhmo do this this is the
in corrected example that they put up
and this is the correct one none of them
looks more or less correct or as easy is
easier or harder to read than any of the
others but when you compare it to the
pipeline version the dataflow centric
version then there's a difference so one
of the great pieces of advice given by
the author Elmore Leonard is try to
leave out the part the readers tend to
skip okay this is good for life as a
guideline
you know documentation whatever cut
things down and most of what we write is
mechanical background noise we can
refactor it away either by using
existing libraries or by learning to do
the same thing ourselves hey there's a
loop there I keep repeating it why
didn't I factor that into a method that
does that for me and there are a number
of different approaches that we can take
so what I want to end with here is it's
very simple observation that we've got a
set of our motivation here is we're not
trying to make things immutable because
people said it's good to be immutable
try to make things immutable so we can
understand it and we can change it more
easily it's it's to do it goes right
back to what John Carmack was saying
about the struggle that we have
understanding the states that our code
can be in by definition a system that is
a legacy system has these problems and
so therefore how do we dig ourselves out
of that particular hole is there a nice
simple set of transformations that gets
to a thinkable reasonable model it turns
out there are I have not covered
everything I've not talked about larger
architectural changes but what we've
done is already targeted some of the
noise and some of the very common cases
in the code and move started moving code
in a direction to the point where we
might actually say that's an emergent
style of the code system if we recognize
that many coding practices and coding
issues are actually social there's those
forces that people go on if that becomes
the normal way of doing things
eventually people start questioning the
bigger picture how do we make this more
of a dataflow architecture how do we
separate things so that their state is
more isolated we can minimize moving
parts we can hide moving parts how do we
do that but it starts with the little
stuff there very simple habits that we
have and so I am with a quote from
Lucy's Carey which is relevant given
that we are across from the houses of
parliament outside the houses of
parliament is a statue of Oliver
Cromwell who was responsible for well
Lucy's Kerry is on the wrong side of the
English Civil War but he did leave us
with a good quote which is you know all
that matters a few hundred years after
the event when it's not necessary to
change it is necessary not to change and
we should actually seek that in our
object models and our type systems thank
you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>