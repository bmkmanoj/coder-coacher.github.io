<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Consolidating Services With Middleware - Christian Horsdal | Coder Coacher - Coaching Coders</title><meta content="Consolidating Services With Middleware - Christian Horsdal - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Consolidating Services With Middleware - Christian Horsdal</b></h2><h5 class="post__date">2017-03-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DkG76TgntBQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so right let's quit going I love the
talk obviously consolidating services
with middleware and what I'm going to to
argue here is that if you're doing sort
of HTTP based
micro services then really many where is
it's your friend and and you kinda want
to use that you're gonna want to
understand what that is so we're going
to talk about that
my name is christian as SS s up there i
I'm freelance so I get to sort of go
different places and see people's
different systems and we're going to
sort of start out talking about some
examples drawn from from different
client systems so it's not exactly
taking from one exact system but it's
it's kind of stuff that it's pretty
close to to to what I've seen and and
and I'm going to talk about how in those
situations we've used middleware to to
make things easier really and make
things things nicer so so it's not drawn
from run one project only but experience
based still right so yeah I'm going to
talk a lot about middleware and and then
well why really well
middleware gives us some some different
stuff it's it's really flexible so it's
it's a quite flexible way to sort of get
some building blocks that you can put in
the order that you want and you can
reuse sort of across different
situations and and being sort of well
used in different ways it's nicely
component size so you can really get
into a situation where you have like
just one little thing that does that
well and then one other little thing
that doesn't that well and you just have
these nice little components as I said
they can be quite reusable especially in
sort of a micro service setting which
we're going to talk more about
and lastly they're quite testable at
least to the point where sort of it's
kind of your own fault
if they're not that testable so from the
outset you can they're small and easy to
sort of spin up in a test environment
and you can just have them there which
is also really nice
so these are seasoned some some some
really nice sights of of middleware and
and lots of the reason why I I liked
mill aware so I promised you sort of
some stuff from the real world
based on real systems I've I've I've
worked on so first of all these things
here are sort of micro service systems
and well hooray
while doing micro services today because
that's seems to be the thing that we do
right have to do that so everybody does
it well maybe there's more reason than
that isn't there so so it's just sort of
to touch a little bit on that
why do micro services and and sort of
why why do it in the systems at least it
these examples are are based on well
sort of micro services I'd like to say
that they sort of enable continuous
delivery but it's sort of a two-way
street I I'd say so the micro services
you have lots of small things which just
is unmanageable if you don't if you
can't really automate things and you
can't do continuous delivery we really
and then on the other hand setting up
all the automation needed to do
continuous delivery delivery gets easier
if this thing's you're trying to deploy
are smaller so it's I sort of a yin-yang
thing going on there
one makes the other one easier to do and
on the other hand sort of one needs the
other one too even you even be good so
those go hand in hand um you can get
highly maintainable services with micro
services again it's just really the fact
that they're they're kind of small so
the small enough that you can fit them
in your head and you can actually sort
of reason about them thinking about them
and and know what they're doing so
that's a nice point as well and quite
closely really to that is that you can
get a really efficient sort of developer
workflow compiling as fast spinning of
them up as fast
the deployment can be fast and so on so
forth so you can get the feedback and
you could get into a good rhythm with it
do another in the situation where it
sort of open up issues to do in the
morning and then go have a coffee and
half an hour later is your studio and
resharper and everything is sort of
loaded because you have 7,000 projects
in your solution just like a couple of
projects in there and it's fine yeah I
wrote this robust up by design so micro
services can be robust by design as with
anything thing else you can shoot
yourself in the foot quite easily but
but but you can make you you make sort
of communication between the different
services quite explicit and and in it
and quite sort of in-your-face and and
you can put sort of robustness around
that communication and how that works
and if you're sort of good at designing
how those how the collaborations go
about and you can get then you can
really design some some highly robust
systems and that's really nice as well
and lastly again things are sort of cut
into two smaller or smaller bits and
pieces so you can get some some
flexibility around the scalability so
you don't have to sort of scale the
whole system to the same level you can
sort of find the bottleneck and scale
that out instead of scaling every single
a little bit of a of it out so I these
are sort of I guess more or less things
that that that people will often
highlight about micro services and these
has definitely been reasons why we've
chosen micro services and some of the
systems I've been wor involved with that
we sort of wanted these kinds of things
we wanted to wanted the system to be
easy to work with robust and be able to
deliver quickly and so on so that's sort
of why even do it and then sort of
through the talk we're going to talk
about well it comes at a price and
middleware can help us sort of pay that
price
again let's put some examples in here so
this is this is yeah I can based on a a
real system a system where it's not
supporting is important what that one
says really the the the middle one there
is the important one is the system where
sort of end users can get notifications
about stuff in this case what I've drawn
here is so imagine it's some kind of an
ek ecommerce site you can come up with
like special offers for this or the
other like buy three get one free stuff
like that and then you want to then you
want to sort of notify it uses about
about that and it in the system that
this is sort of loosely modeled on we
did it more liar and more or less like
this so we sort of have the special of
offers up here and so this this guy here
is supposed to be sort of in something
publishing events yeah so it's sort of
like okay I create a a special offer and
that gets offended out to the world and
whoever wants to sort of react to that
can and in this case the sort of this
loyalty program thing that wants to
react to this and say oh I have some
customers register it in my database and
they have different interests and so on
if the special offer match is that then
I want to notify them now I have a
service for that I haven't no
notification micro service for that and
that what doesn't actually do the the
the notification it's sort of just knows
about users and knows about again sort
of their preferences and some want an
email and somewhat an SMS and someone to
push notification and then we have sort
of other micro services out here sort of
handling the the integration towards
whatever systems are needed to to send
the SMS through a gateway or or whatever
you need there so so this is this is
quite fine-grained um but but but but
with the system that the disassemblers
is modeled on we really got eye
say at least most of the the the points
of the bullets on the previous slide
these each of these were quite small
easy to work with efficient workflow
they we were able to do continuous
delivery with these because they are
quite small and if there was like a bark
with the with the integration to the as
a mess a gateway it was just this guy
that needed to to be redeployed and not
not all of the rest of it and it was
quite nice now so you have sort of
direct calls some of these places but
the thing triggering or all of it was
this event based mechanism and sort of
by design there's some robustness up
there because the events are stuff that
have happened and it's okay to look at
them again and sort of if it fails we
can just try a little bit later it's a
background thing it's okay that you get
the push notification half an hour later
if there's a problem or half a minute
later or or or whatever like that so so
this actually worked quite well in there
in that set up now all the communication
here was was HTTP so the events up here
that that's like an RSS feed basically
so so the initiative is down here and
that guy's all of us do you have any new
events for me I have the last event I
saw was number 100 so we have it to have
any about that sequence number and I
don't know it was okay wait a while and
then do you have any now oh yeah I have
ten new ones for you fine
I will do that and then you can sort of
just go through and then the rest of
them there's sort of pretty standard
just HP calls do this do this do this so
so there's quite a lot of HTTP
communication going on here
another example sort of taking from the
same application same system so it's a
system where so I'm at in a system where
where people can classify its site and
that classified ads can come from
different
relate places one of them is so what
what was called a a dealer application
in this case so sort of companies that
wanted to list things in these
classified now like private people just
normal people could do it could do it
all so so there are different channels
that could do this same kind of thing
the dealer went into the app created
this the the listing to go onto to the
site and and there was just there
resulted in an event it comes out of a
feed now that we also come from sort of
other sites out there sort of other
partners that wasn't directly built from
here same kind of mechanism with the
event feed that goes into sort of a
common store with all the listings again
and that sort of it has events as well
oh there's a new listing that's new
listing and then this is that that
there's a search index that gets updated
based on that and then there's a site
that actually uses the year and these
search engines so you can go to the
front page of it and sort of search for
blue cars and then you get the blue cars
so by dealerships or some other sites
and whatever and as turned out they were
actually sort of several different
classified sites some were sort of for
selling everything in there under the
Sun and some were sort of for selling
specific verticals and specific things
and they shared the same data so you had
sort of a a and and as it is with will
with slice and architecture and slide
right it it's it's simplified compared
to - to the real world but I do think
that you sort of get the picture that
again this is all HTTP and there's quite
a lot of HTTP communication going on and
and you could sort of say why do all
this over HTTP why isn't it Q's why
isn't it something else pick your
favorite and in these cases it
was really very much a matter of the
fact that HTTP is there right and HTTP
works we know how HTTP works sort of
quite good at monitoring stuff on on on
HTTP and any stack and kento gate should
be it's quite ubiquitous so it's sort of
a it's a good it's a good place to sort
of just go and and at least start there
and and to be honest
coming into the systems that this is
based on I sort of had the reaction of
HTTP that sounds very sort of
synchronous and it's going to not be
very robust that wasn't the case I say
after a while and and specifically
because you can sort of design how the
communication works and you can you can
think about who sort of has the
initiative and in this sort of oops this
sort of case here like these lines this
guy up here is just sort of stores that
there's a new listing now it's fine and
then the initiative is down here he says
okay I need to find the new listings and
so he's responsible for retrying after a
while it doesn't have to be a fast retry
this is eventually consistent it doesn't
have to be like milliseconds later so
just sort of just sort of it a
background task
wake up ask for Newman's sleep wake up
as for Newman's that's actually quite
well robust and quite simple it's really
not that complicated
to do so turns out actually quite nice
to work with the with with HTTP for
these things now does that mean you
should use that ACB for everything oh I
don't think so but it can be a good
option right so sort of along with with
with micro services comes a few things
and and now we're sort of getting into
the the cost of doing micro service it
was all like oh these small things and
they're nice to work with and it's all
been good this far there are things that
you need to master and all able to be
successful with micro services you sort
of need to be this tall so
you need to have a good relationship at
least between sort of dev and ops I
think people have been talking quite a
bit about this for a few years but it
still holds true that having all these
small things getting them up and running
being able to update each and every one
of them sort of quickly and not sort of
in a big orchestrated way but just one
this thing one thing one thing here it's
just not going to work if it's a oh I've
developed my thing in our throat over
the wall and see what happens sort of
have to be working together okay it's
pretty basic and then you also need to
be quite good at sort of logging and
monitoring and this sounds really basic
but I don't I think a lot of systems are
good at this but they're also a lot of
systems that aren't really good at this
and so but it's really necessary in
these situations to have some insights
to how the system is doing you have all
these small moving parts you just can't
afford to sort of to be to do something
ad hoc for each of every of these
services so you have to sort of know how
do I monitor your service how do I know
if it's up you can't sort of just kind
of test each of them a little bit here
and there because you'll have if you
follow the these micro service
principles you'll have hundreds of of
micro services it's just going to be too
difficult so so sort of some
standardized uniform logging and
monitoring across the services is
invaluable to have and that's actually
some of what we're going to to focus on
today and then sort of moving up you
read to be quite good at also made of
tests and automated bills so so you have
to sort of have that set up you run your
tests you run your bills and you can see
if it's successful or not so that's the
CI continuous integration part and then
sort of a top of that you probably also
need some some some automated
deployments and along with that sort of
fast provisioning of things because if
you do something like this and if you do
something like
this not only do you have many services
but you will also find that that you
need to create new ones on a regular
basis maybe not a daily basis sort of
depends on your scale but on a regular
basis quite often you'll find that oh I
I don't know in this vertical down here
there was sort of a a specialized store
and then the search index the first
approximation would probably do be to do
both of these the same way and just have
the search index talked up there and
then you sort of figure out no I need
another micro service in there you need
to spin that up that's a normal thing so
you need to be able to get up and
running with them fast and at the same
time you still need them to act like the
other ones with regards to stuff like
logging and monitoring your on them to
be well-behaved other things that can
sort of come into this being
well-behaved could be things around
security so you might want to make
certain that that only the the service
that are allowed to talk to each other
allowed to to do that so you have
certificates allowing stuff like that
whatever you you sort of decide um your
needs are and this is where malware
comes into play because when you're
doing everything over HTTP then
middleware in the sense of asp net core
malware which we're going to look at and
in the sense of owen middleware which
we're going to look a little bit at as
well is is really good place to
implement these things right so let's
sort of turn away from micro services
from a four bit because this was sort of
the motivation for four for doing these
things and then then talk about what
middleware is so first of all what any
web api or HTTP based API does really is
handle its DP requests Wow big surprise
so what does that kind of mean in an HP
net core since M basically doing this
you have a pipeline at the one end of
the pipeline that's the kestrel web
server so every request comes in to this
guy
and sort of off the wire and and and
Castro looks at it and turns it into
something that you're done netcode can
they can understand and your dotnet code
is over here in the application so
Kestrel sends the request in here you do
whatever application logic you need and
the response comes back
Kestrel knows how to serialize that and
put it out the way it sees B that's what
is a web server does not not too
complicated here now that pipeline can
be longer than just the two bubbles I
have there and the pattern behind it is
is pipes and filters so request comes in
and they get piped through a number of
filters m and the way the the requests
gets piped through it through what's
called the context we're going to look
at the context optic as well a bit later
in the talk and and the context holds
everything regarding the HTTP request
and everything regarding the HTTP
response as well and the middleware are
like the filters in the pipes and
filters pattern and it looks like this
and you can sort of go on and have more
complicated scenarios in there so in in
in in this one we just have Kestrel here
at the one end we have the application
still at the other end and then we have
two pieces of middleware there and first
one a throttling middleware so one could
imagine that we set up limits such that
any customer that isn't a paying
customer can only make a certain amount
or requests per minute or a certain
amount a request per day or whatever I
think some of the Google API is does
stuff like that and then sort of already
at this point if the client is above the
limit you just return a suitable status
code that tells them that they're not
alive to do this and if they are you go
on then you might have some some
authentication middleware looks for an
OAuth token and chics weather looks
valid and so on and then you go into the
application
we're using middleware here to push some
stuff out of the application and it's
sort of technical kind of stuff that you
don't really want in the application
code it's not really business-related as
such and what these pieces of middleware
can do is they can transform the request
and the response so on the way in they
can do stuff to the year to request a
lot of the time it's really just looking
at the request but you could actually
sort of do stuff to it and then on the
way out it can transform the the the
response and sort of as a as a important
bit is that that each that each piece of
middleware sort decides whether the rest
of the pipeline gets to run so not only
can they can they transform the response
they can just sort of short soak in and
say I'm going to create the full
response and be done with it so that's
what that FRA telling middleware might
do your own were your limit I'm not even
going to call those guys I'm just
returning here right so each piece of
middleware it takes in this context and
then it can call the next step in the
pipeline if it decides to or it can
decide not to and the trick really is
that that's a uniform interface so at
each of the arrows between the bubbles
it's the same it's the same thing
flowing there it's that it's that
context and that means that you can that
you can rearrange and that means that
you can plot more things into it like
when we have kestrel at one and it
doesn't know if it's talking directly to
an application or if there are a bunch
of middleware pieces between in there
because it's the same interface the same
goes for for your middleware you don't
know if you're talking if you're the
last one at the pipeline or you're
somewhere in the middle or if it's been
switched around so it's it's quite sort
of composable in that sense I have these
small components and you can compose
them up as you want you get that
flexibility so things you can do in the
pipeline
so and in sort of open and dispose of
resources in a general sense that could
be database connections if you want to
do the per request thing you might want
to consider being more precise than that
but there could be other resources that
you sort of need you can push that out
of the application logic and get it into
into middleware you can do logging and
we're going to look a little bit of that
into authentication you could do
authorization you might want to do that
more some of that in the application as
well but you could do authorization in
the sense of are you even allowed to
interact with this service at all you
can do you can do monitoring endpoints
again as I said you don't want to do
ad-hoc monitoring for every of the
hundreds of micro services and your
system you just want them all to to sort
of react the same way so having a piece
of middleware that this response to a
well-known endpoint says I'm alive
that's actually really valuable and
really easy to code you can sanitize
input you could do country negotiation
you could do course you can do a lot of
stuff in there in these pieces of
middleware and the thing there's sort of
the overall overarching theme here is
that these are cross-cutting concerns in
some sense of the other the sort of they
cut across the the the business logic
they're not really business logic and
they cut across many of our services
these are not not just about one service
they're about most or all of our
services they're reusable across the
services at least as long as you want
your services to behave in a uniform way
which I'd argue you do you can separate
them and test them nicely just one of
them and and be confident they're based
on those tests hopefully and they can be
updated separately that you sort of
don't have to put everything in one in
one package again because the pipeline
composes and sort of along with that you
can destroy
freedom separately and by distribute in
this case I I mean put them into the
different code bases of each of the year
of the micro-services so really what I
mean is put them into a nougat package
and you can sort of have a nougat
package with a middleware in it or you
can probably you might sort of want to
put a meta package on top of that that
has your entire sort of standard
pipeline but then as needed you can go
in and update one of them and you can
get moving right so an example of a sort
of a platform for for for building these
http-based Micra services would be
building up a pipeline like this and
just making it easy to to get up and
running again because we are going to -
we're going to spin up new micro service
quite often so we don't want to do this
again and again just want to do the same
thing so it this is an example you might
want to put them in a different order
you might want some more some less some
specific to your organization but this
is an example so Kestrel in the one end
then you might want to attach a
correlation ID to every single a request
that comes in the idea of the
correlation ID is to identify where
things come from
so at the edge of the system you will
you just create a new quit we have lots
of wits so create a new one attach it to
the to the request and then every time
anyway every time the service locks
anything it also puts that correlation
ID on the year on the log and when it
makes calls to other services or when it
creates an event that event has the
correlation ID in there or that call to
another service has that correlation ID
in in a header so it follows through the
entire system and all locks has that one
that becomes really really nice when you
have problems
then you go to your Locke store and you
can search for a correlation ID and you
can sort of you can track what happened
here and what why was this course you
have this problem over here there's a
correlation ID find out where did that
come from in the system that's really
nice you could do request locking so
every request coming in every spawns
coming out what's going on here you
could maybe do that sort of on an
information level locking so you have
the ability to turn it off so it's not
too noisy but you can turn it on when
you need it
performance looking kind of the same
thing in the pipeline here just time
everything because it's one of those
things that most of the time you're not
going to have to look at it but then
sometimes something is too slow and
really nice to actually get to know how
much time does this guy spend and how
much time the this guy spent so you just
have it in the pipeline and then it's
easy to turn on north you could have the
monitoring endpoints that I talked about
so that all your services respond to
something like I don't know slash
monitor and it says 200 okay if it's
alive or you could be more advanced
about it and do something more than just
returning that actually checking
something more meaningful about whether
that's alive or not and you could have
authentication down there look at is is
there a valid token on this request are
we allowed to is there identity here
otherwise we might not allow anything
and then at the end of that that's the
application these things we only want to
write like once in air quotes because we
don't get things right the first time
but we don't want to write them every
time we spin up a new service okay so
time to actually look at some cold
yes so um so I have prepared a little
bit here and it really is a little bit I
have an empty web application and it
really is quite empty it's this is it
this is all it does it's really not much
there so it will just respond OOP
hello world - anything down here
ooh brilliant little service so that
really doesn't do much but that's a nice
starting point something that doesn't do
anything really and let's see let's see
if we can run it so it's in this folder
and I probably have to restore packages
seems okay and let's see if it can
basically run dotnet run to that so
compiled and it seems to be running on
port 5000 so let's check that let's go
there and oh hello well and what we
might sort of the interesting a bit here
is not in the browser that's never
interesting that's just for users the
interesting big sort of cross the locks
so already out of the box here we
actually get the request logging part so
that's kind of nice so that's already
done with and you can see that we got
yeah we got a request here for a get
request for localhost 5,000 and and you
get that request sort of the whole
pipeline finished in a certain amount of
time and a you got a 200 back from that
so that sort of just comes out of the
box with I spin it kind of nice so let's
look at this middleware thing
oh that one staying in the same file so
if we want to do something more if we
want to do some of the middleware that I
talked about so there was the so there
was already something about the
milliseconds out there and that's quite
good to have that sort of under very a
very outside of the pipeline and so
that's from kestrels perspective how
long did everything anything take I
think it actually makes sense to also
have your own performance logging in
here that only sort of looks at when I
have taken over so how much time I spend
in my code so we're going to set that up
also serves as an example so in order to
create a piece of middleware we go into
this app here so that's the I
application builder that we get in this
configure thing and this configure thing
gets called by it's been a core on
startup that's how core works for a
spinet core works em so and we will say
use and that means what we are going to
use a piece of malware and we sort of
just say yes please give me the
signature needed here and the first
document here is it's a context and the
next one is a function which I'm going
to call next and that context is the
HTTP context which describes the request
and response so that's so this is the
uniform interface I talked about between
each of the pieces of middleware you get
everything about the request in here and
you get everything about the response in
here as well and then the thing called
next is the next bit of the pipeline so
that's the thing we can decide to call
or not based on whatever we want to do
so I have you have flexibility here in
the middle where as to what you want to
so let's get going and let's just get
that a little bit up for everybody see
and we can just do stuff like a
whatever boom boom boom
or watch equals new don't watch go and
and we take that watch and say start and
then we call next there boom and then
after this we just do our performance
logging here as a console.writeline
right now
right right right line and sort of do my
pipeline pipeline and we'll just say
that that took some milliseconds and
it's going to be just watch what sorry
watch dollar elapsed I'm gonna second
that sort of fine okay
so and this is sort of almost it there
are awesome squigglies there I think one
of them is just semicolon and then sort
of the other one what's going on what's
going on let's try to have a look if I
can find the mouse okay blah blah can
resolve and candidates and I don't know
well I do know actually and the problem
is that that we're supposed to return a
task so this whole pipeline is is a sink
so everything is just tasks and kestrel
at the very end of it will await the
tasks that come out of the pipeline and
that's where everything will well be
waited for and will it really executed
right so and moreover if we're just
calling like this and not awaiting we're
actually not measuring what we want here
because I want to do something before
and after so I have to make sure that
it's actually after so we will wait here
and yes we'll make that a saying and I
guess we should I'm not going to do this
every time but I guess I should put the
configure wait false in there so don't
have to configure back to the same
thread context and there is still a
problem
either that or writers just confused
um let's save let's see if it feels Oh
running stop darn it build and I sort of
see ok compiled successfully so writers
just confused with this Quigley's yes
lovely and we can dart now run and it's
up and running again and it's not going
to be overly surprising I don't think we
get in here boom and you can see
actually after the initial one which
sort of does somewhat some warm up our
pipeline is quite fast so it turns out
saying hello world is quite fast because
0 milliseconds because really what's
left in our pipeline after that piece of
middleware is it's just this guy let's
this context response right async and
then that's actually the same context
you see so this is how you just write
something for the for the output so
that's good so if we but in this piece
of middleware we didn't really do
anything with the with the request or
anything so it's sort of ok fine but it
doesn't do much so let's do a little bit
more in here and we use again we do sort
of the kind of kind of thing same thing
doom the context the next guy and we are
ready so now I want to look at whether
they say there's a correlation ID in
here or not so now we're going to use
the context and I'm going to try to find
a correlation ID in there
and that's in the context dodge request
so you have a strongly typed object here
that that describes both request and
response as I said so you see you have
the request and you have the response
down there and then sort of you can dot
enter a whole bunch of other things in
there so it's an easy way to get to to
find things on on the request and I'm
going to specifically look at headers
and so now I want to look for my
correlation ID whether there is already
one so that's not a standard I think so
of course the type doesn't know about
that from the get-go so I'm just going
to define my own header here my
correlation ID and since headers can
have more than one value you get don't
you yeah you get you get an array of
values out of this and that I'm just
interested in the first one I makes it
going to say first a default because I
don't know if there's a one there or not
and then if there's not I'm going to
create one where your grid did you do
and just ring on that so the types match
so now I so if if this is in a service
sort of inside of my system it should
have a correlation ID already because I
want to at I want to put the
correlations ID on at the surface of the
Year of the system and then pass it
along on every request coming through
but if we want to write this piece of
middleware in a way where I can try to
reuse it everywhere in my system we'll
check if it's there if it's not there
we'll just attach a new one or well
we'll just create any one and then you
have to do something something with it
I'm not going to go really into details
with this because of time but sort of
the thing that you'd probably want to do
is first you'd want to attach the
correlation
IDE to a log context to the log context
so if we are using a sort of modern
logging library like Siri lock which I
very much recommend there is a concept
of a logging context and it's and and
you can put extra metadata there so if I
put this correlation ID into that
logging context then wherever in my
application code I say log dot warned
something is wrong then along with that
something is wrong message
my correlation ID will also be there in
the log message going to my log store so
so so you make sure that everything
inside of this mmm this service locks
the correlation ID now the other thing
you also probably want to build which
I'm not going to build here because
we're concentrating on middleware is
that that that you also want to make
sure that the the correlation ID is
passed on to the next guy in the chain
to the other services coming along so
you also sort of you want to store the
correlation ID in in in something like a
it's the P client factory so so what
I've done before is yeah create a
effects with class that can create a an
HTTP client for me and use that HTTP
client to do calls and then you just
sort of on this level inject the the
correlation ID into that Factory and
then the factory sets up the client such
that it has the my correlation ID header
on every request and put the right
correlation ID in there the next guy in
the line has the same piece of
middleware he'll file the correlation ID
put it into his lock context and you'll
get them on all the locks so it's one of
those things it's it when you have a
production is
- and it has to do with something that
spread across these microservices
it just feels magical so have the
correlation IDs it's just so much easier
to follow what was going on and it's
actually not that hard to code right and
once you have this set up then this guy
would also call next and in this
situation we actually don't want to do
anything after the next so I don't have
to await I can just return the task that
that that that next returns so I just
pull that up no reason to await if you
don't want to do anything afterwards
just sort of pass it on through the guy
before that and then when somebody
actually needs to a weight thing they
should await if you don't just return it
and it's the generated code is simpler
right let's save yes and I've just
checked the time mmm good yeah I guess
we could sort of try to prove that both
pieces of middleware actually run here
if we just do a right line of
correlation ID and I can't spill that's
okay we do but I should I need that go
so we're just going to log that log that
out as well and did I save I save now
stop that rerun here and it should
compile there we go do a request and yes
so obviously it got a new correlation ID
and they'll get any one if we do one
more request
no big surprise you get new quits we can
create kits yes right so this is so
I guess no let me I think I'll create
one more piece of middleware and then
I'll show you how to do it with classes
instead of with these lambdas because
that's easier once you can want to want
to package them up and share them across
things so move this up a bit again so
everybody can see and so I we talked
about the monitoring endpoints so it's
really the same thing that you can just
do context next and then in this case we
just we again want to look at the
incoming requests so we just say if
context don't request dot path you have
the path in there and we're going to say
I guess we're going to say equals
something like slash money money tour so
if we hit the slash money to our
endpoint then we will then we will then
we will and we'll just do what what that
guy down there does actually we will and
we will actually return return a context
context not able to type apparently no
okay typed out response done right I
think and you could sort of write the
version of the of the service out here
is again one of those things kind of
nice to be able to get to know where
which versions of the services are
running and I'm sure you can imagine
instead of hard-coding and reading it
from from whatever conflict that you
have so you get a build number in here
or something like that so it's quite
easy to figure out why is the service
behaving differently than I thought goes
to the monitor endpoint see which
version is running compare that to your
repository maybe you have like the get
Shah output it here as well so you know
what's running and this is an example of
short-circuiting the pipeline and with
deciding not to call next in some
situations and in other situations
deciding to to call next so yeah so you
continue to our hello world application
down there if it's not the monitoring
point of is the monitoring point then we
do that thing okay let's just check that
it runs don't think they'll be shouldn't
be too much surprise here I hope well
I'm running so we can do the hello world
request still and we can go to slash
monitor and we will see yeah you get the
version one Oh back there and we well
it's the same pieces of middleware that
run before that okay so I think you get
the picture you can do stuff in the in
the pipeline
thanks for this guy so I am going to
cheat a little bit because I want to
show you how how looks if you if you
actually want to share this across
across stuff so I'm going to check out
my library branch here please come into
our stash that's okay we will just get
rid of everything check out
- - so got good so I'm on another branch
it's mostly the same thing now let's see
if Ryder got confused okay Ryder is
reloading and restoring packages and
stuff you can see that in the solution
Explorer thing and now it is back and we
have something kind of similar to what
we have before we have the same sort of
performance logging middleware there and
then we have something that looks
slightly different here so it doesn't
say users use middleware and the thing
it's using is monitoring endpoints
middleware so now separated that out -
something up here in my middleware
library let's just a standard class
library
well dotnet core class library with a
project Jason filed there and a single a
CS file nothing complicated there I just
didn't want to do that live because it
takes a few steps in it's boring but it
was just scaffold with the with a dotnet
command-line and then in this file this
aptly named library that CS I have my my
middleware and again it's more or less
the same only if you do it this way
you sort of split the things it's the
same argument really you have the next
here so that was the second document
when we did it as a lambda now you get
that in through the constructor it kind
of makes sense it's when you're
constructing the pipeline that that you
instantiate the thing and you set up the
whole pipeline so you can add
construction time know what the next
parts are this gets passed in just
saving off and then in that invoke
method you get in and HDB on pre context
and then on each and every request that
one will get called if we set it up and
that's what that use middleware that we
saw in the start up it does that's what
this guy does
so instantiate this guy monitoring's
endpoint middleware with the next
and then it calls invoke so at this
point I mean this is just a class this
is just just code the other one was also
just code but now you separate it out
and doesn't even have to look in any
kind of way weird and we still have the
monitoring endpoint and sort of a as an
aside here you can get more stuff in
here than just the request delegate the
request delegate is an HP net core type
which is well just describes the the
function that you can call which is the
next one it's just a function type but
you can get more things injected here so
it's been a core out of the box comes
with the concept of the of dependency
injection and sort of its own services
is already in that container so we could
depend on some of those but we can also
have our own stuff in here so we could
imagine sort of if we wanted to do some
better monitoring endpoints we could
have sort of a like and I a monitor
thing here and maybe I don't even
implement that here maybe that's maybe
that's up to each of the services we did
that in one of the systems I've worked
on define this interface it just has one
method which we call deep and that was
supposed to be to implement something
that made sense to each and every
service so and then that's just a
different endpoint if you hit like / -
that's less deep or whatever it calls
that I - that are deep and if that's
successful it says 200 if not it it
gives back some other status code based
on that and then you can sort of have
some of it just be standard behavior and
then you have a hook and it's quite easy
to just set up and have it be
application specific so it's nice that
you can depend on other things up here
and you just get them a dependency
injected easy enough right
so back to the start of CS looks like
this um let's make sure stuff runs let's
see
donít run compiles it's up and running
and so it's quiet it's slightly
different this one it had an underscore
Mon it's a letter code here and it get
the version and it's all the same so
that's all nice and good so a five
minutes left it's good so all the code
we've seen so far is for a spinet it's
been a core you can do similar stuff if
you're not on core but on asp net but
but it's this sort of kind of a step
more to it you can you can have the the
the concept of middleware you just have
to use Owen so Owen is an open standard
developed by by the community it's open
web interface for the net and it's
really awesome in many ways this is sort
of the and and it's really really nicely
put together and really has a lot of
focus on not depending on anything
specific so there's no sort of
you don't need sort of an O in DLL or
something like that there's no sort of
common type in there but the downside of
that is that that things get kind of
primitive so where we have the context
that requested headers then with Owen
you just have a dictionary from string
to object that's that's the context but
the trick is there's a library that you
can use if you want to sort of your
decision and I'm just going to quickly
show that so we're going to going to
check out another branch and this one
lip Owen um go back into Rider it
yes
reload again and now we have one more
owen middleware here is this and we can
do some
things similar we have this one so this
kind of looks similar and this works on
HP knack or or it works on on a spinet
today if you use the katana library so
so if you're also if you're in a
transition area then Owen is probably
the place to look to do these kinds of
things so how this one works
more or less the same again I have a
constructor that takes in the next guy
now it's not a request delegate is
something called an app funk and the app
song is this guy up here blah blah blah
you just copy this off the internet and
you're fine
and then the Evoque takes in a
dictionary from string to object and
that that's a bit cumbersome to work
with because then they do something like
a lookup the string if I remember
correctly it's something like Owen :
request headers and then you have then
that's an array of strings so you cast
the uptaking than you're looking and
maybe I'm even remembering this wrong
the point is it gets there's a lot of
sort of it gets to work a lot with
primitives so there is a library called
a lip Owen which you might want to use
it's sort of a source only library so
don't get a DLL from that library you
can install it as nougat package and
then you get a huge CS file here called
Lib Owen and you don't have to look into
that what it does is it gives you an
Owen context here and then you're sort
of back to be able to saying there's and
there's and and it looks very much like
the other thing so you can do the same
thing today and you can sort of have it
across there to set that up in NHP neck
or you say like it's been a core that
now I don't want to use your kind of
middleware I want to use Owen so this is
sort of a bridge between the two worlds
and then you do something like this so
yeah so again everything is functions
with with own so this is a function
you call that function and then I knew
up the middleware and give it the invoke
method which has the correct signature
to fit into the pipeline and the node
built it up and you're are good to go so
you can do the same kind of thing
right one minute left back to the slides
and so as I said and as I hope you sort
of accept it's quite flexible what you
could do in in middleware and you be
there quite componentized they can be
reused reorganized and since you just
have these small classes that do simple
things that you can easily new up from
your unit tests they're quite testable
as well so go use middleware yay and
here's the contact information if you
want to get hold of me and I'll be
around for questions and stuff 51 but I
think time is up and we have one minute
for questions if there so anything
before the break it's not but I could
yeah I will that's fine yeah and I will
tweet the link yep good okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>