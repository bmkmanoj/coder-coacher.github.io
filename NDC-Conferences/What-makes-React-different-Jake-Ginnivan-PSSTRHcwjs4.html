<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What makes React different? - Jake Ginnivan | Coder Coacher - Coaching Coders</title><meta content="What makes React different? - Jake Ginnivan - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What makes React different? - Jake Ginnivan</b></h2><h5 class="post__date">2016-10-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PSSTRHcwjs4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">morning everyone thanks for making it
here after the attendee party 9 am-4 is
always a bit of a hard slot what I
wanted to talk today about is just what
makes react different in my mind it's
really interesting JavaScript has
changed so much over the past even yeah
it's completely I'm like we've seen
before you go into sort of angular 1
projects and they're not using they're
using gulp or grunt as a build system
probably not transpiling angular has its
own module system we now have one that
standard compliant in the browser some
browsers but yeah reactors kind of one
of these libraries which I just find in
it really differentiates itself in the
way it makes you think and today is
going to be going through sort of the
basics of react and sort of some of the
shifts and mindset that it'll it'll sort
of uh it'll change the way you think
about buildings these larger JavaScript
applications so there seems to be this
trend of we want to reinvent everything
as a single page application the problem
with that is most of the time we end up
something like this where you don't
understand what's actually going on in
your app anymore
you don't understand where data lives
how it flows through the system if your
performance problems it's hard to trace
where they come in that sort of stuff
and this is pretty typical so what I'm
not talking about today is why you
should build single single page
applications and comparing react to like
MVC or server-side technologies that's
another major discussion but I just want
to make cover sort of what what react is
and how it can if you are going to this
single page application road or building
desktop apps using electron or something
like that and using new web technologies
how can actually help you build an app
and understand flow data flows through
your application
a bit about me my name is Jake in urban
I work for ratifying Perth I moved back
about a year ago from London and that's
actually where I got introduced to react
day to day I do a lot of net and
depending on the client JavaScript or
MBC or anything react ratifies a
consulting company so get thrown into
all sorts of situations best way to
contact me after the talk if you want to
get in touch as either Twitter or I've
got a lot of sample code and examples
and things up in my github but where I
actually found out about react and I
started getting into it was a very cool
conference called code on the sea this
is the best idea anyone's had for a
conference so the idea is you go fly to
Florida you jump on a cruise ship and
Jacksonville and then the first day of
the conference is while you're cruising
down to the Bahamas and then you've got
three days in the Bahamas and then the
second day of the conference is when
you're cruising back why are there not
more conferences like that so that was
us on their little dinghy going to one
of the islands it was a really great
conference but one of the the presenters
there Rob Ashton was talking about the
way he builds JavaScript applications he
was the same guy that introduced me to
browserify and at the time they it
didn't have like web pack wasn't out and
and it wasn't sort of this the es6
module system wasn't out and had been
doing building apps like this for sort
of a couple of years now using browser
of fire which uses similar the sort of
node module system but it brings it to
the browser we'll talk a bit about that
later but this was the first time I'd
sort of really got excited about web
development it just made sense to me I
often find that uh I can't I go into a
project that I haven't been touching for
three six months and I just start
struggling with where the data is going
how it actually works
and with reactant and sort of using
browserify and these newer sort of
techniques it just made sense to me and
one of the things that I think helps us
with react it's sort of it's modeled
after well actually I think this quote
describes the tenant in react very well
so this is quite by Dykstra the
interesting part here is our powers to
visualize processes valving in time a
relatively poorly developed so when
thinking about like async code or a
single page application that has state
distributed state changing over time we
have a really hard time tracking that in
our mind that's why things like MVC and
server-side applications are so easy
because it's stateless request comes in
we build up our model we throw it over
to the view that does the render and it
returns super easy to reason about what
is going to be sent back to the client
so when facebook we're building reacts
they're kind of like well if we can
model get a sort of similar flow to what
we have on the server or even in game
design where we just throw away the
frame we don't bother trying to update
pixels we just re render the into the
game at 60 frames a second based on the
current state of the world we'll have a
much simpler programming model so that's
where react sort of the the basis of
reactors and if you start thinking about
that you've got state and then you have
your application projected from that
state you can reason about what's going
to happen with your application quite
well so if we have our application state
you then simply render that to the
application it's a it's just one pretty
much a a pure function that takes
application state and you're rendered
application comes out the other side
much the same as if using razor in SP
net MVC you just pass your application
state to your razor views and then you
get a rendered application out
the difference is unlike the client
unlike the server we have to deal with
user input and like this state changing
over time so the way react does that is
you simply have events events are
attached to Dom so this includes input
like typing it could be push messaging
if you've got a server-side likes signal
our connection or any sort of external
state and then the in the event handler
we produce a new application state which
then we re render so it's a one-way data
flow there is no data binding in react
and this actually if you just let go of
the fact that I love my data binding I
love being able to put these tags that
make no sense and then suddenly all of
this stuff magically happens if you let
all that go and just embrace the fact
that I can just not worry about syncing
up my application state to the Dom I'll
just throw away the entire Dom every
time my applications state changes you
can sort of really understand what's
what will happen based on the changes of
state makes it easy to test as well
let's do a bit of a react 101 we'll just
dive into some code so one of the
biggest problems with react is that you
have this huge ecosystem it really
embraces Mon JavaScript tooling so to
start today we're not going to we're
just going to write es 5 in the browser
not using any fancy extensions or
anything
so the initial let me just bump that up
can everyone at the back see the code
we're good no I saw it no okay
pump it up one more that better cool
so in react you've got an entry point to
your system you've got react Dom render
you need something to render it into so
here we're just going
document.getelementbyid grabbing a
container element which is this div and
then we want to rel this hello something
into that that's the starting point of
our application we need a point that
reactors going to render itself into
this is one of the interesting things we
don't own the Dom so things like jQuery
don't work with react because if you
mutate the Dom and react doesn't know
about it things start getting weird
because react is expecting to for it to
control the Dom so we'll start off and
the first concept we need to understand
is an element so because we actually not
react we just stay in JavaScript the
whole time we don't worry about
templates we don't worry about having
these HTML strings we need some way to
create Dom elements the way we do this
is with a create element call so I'm
just going to create an h1 element we're
going to ignore the second parameter for
now and then I'm just going to go hello
in DC cool I'll save that so if i
refresh now I've got hello NDC if I open
up the browser dev tools you can see
that I've got my container and then
hello NDC has been rendered out that's
pretty cool we're now actually putting
something in the Dom but that's not very
useful what we can do is also we can
start creating an HTML hierarchy so if I
want to wrap that h1 in it
if I want to wrap it in a div
I can just pass down children like other
children I can either use strengths or
elements pass them and compose them
together so if we refresh that you can
see under here we've got we've got my
div and got the h1 we can also pass
multiple children so I can just go react
create element
and refresh now we've got hello NDC
reactors awesome so this is how we build
up the Dom we just have this javascript
representation of elements we tell react
to render them and then it goes and
renders them that's pretty cool but not
particularly useful yet so we'll have a
look at this second argument here and we
need to be able to put attributes on our
elements so if I want to give this div
an ID so I can I can style it I can just
go ID equals hello react if I save that
and have a look at the element again you
can see I've actually got ID
hello react so once again we've got a
JavaScript object representation of how
to create these elements attributes so
we just here creating JavaScript object
the key ends up being the attribute name
the value is the value of the attribute
this is kind of not very useful we've
just reinvented HTML so what we want to
do is create something that's reusable
and this is one where reacts power
starts coming in we've got it's a very
component driven system so the next
concept we need to understand is we want
to create a reusable class so if I go
react dot create class I then pass it
what's called a class specification so
this tells react what my component does
it has one function on it which is
render well one required function the
result of the render function needs to
return a collection of elements of
actually a single element so we'll just
move all of like rendering code into
this component naming conventions will
now change that to hello because it's a
constructor like a representation
similar in c-sharp you have classes and
then you
have instances of classes react create
class allows us to create a class
definition which then we need to turn
into an element so we can render it so
we'll wrap that with react dot create
element cool so we've now got our
application still rendering and we've
got a reusable component just to sort of
show that it is reusable we could easily
go react dot create element wrap it in a
div and then we get two of them so we
can see that we've actually got reusable
components also not very useful we you
can't build an application with this so
the next thing we need is some sort of
state our applications not useful unless
it can track state so what I want to do
is I need some way something to like
trigger this state so I'm going to do is
make this div clickable
so the way we actually do event in react
is just passing attributes so I can say
unclick function and then whenever I
click that will call me back so it will
just go console.log high for the moment
I clicked there actually jump over to
the console we can see that has been put
out to the console so react as a
synthetic event system on any element we
can attach any event handler and react
will make sure take care of all of the
browser inconsistencies and things that
we used to using jQuery and other
libraries for react normalizes all of
those things you'll notice the naming
convention is also not the same as
JavaScript react because it owns
everything has taken the opportunity to
just normalize all of the naming so for
all properties and events you can just
use pascal casing and it's all happy so
now that we've we're doing this on click
I want to actually I want my component
to have some sort of state so we want to
start with our hello component having
some sort of initial state so we just go
get initial State this is another
function and we need to return an object
so I'm just going to track the number of
clicks that has happened in my
application we then need to update the
state so the way we do that is using a
something called this get statement oh
sorry set state can anyone see a problem
with what I'm doing right now with the
callback handler here yep exactly
so JavaScript has funky scoping so this
function here is going to have its own
scope that's what we want to do is raise
this up to our class level and just have
a click handler
which is our function and on-click just
calls back clickhandler
so now click handler we want to update
our state now we could do this state dot
clicks plus plus but this is going to
cause us no end of problems because
react wants to own the state it wants to
understand the state and as I was saying
before we want to create a new
application state not modify the old
application state so that's what this
set state thing does we can just specify
what parts of the state we want to
update so I'm just going to use the
existing clicks and add one I then want
to render something so I'm just going to
go plus put a space after there and go
this start States State clicks
cool so I'm now rendering I'm using the
state in my render and then when I click
I call set state which then re renders
the entire application essentially so
that's Hillary react that's most of the
components you need to understand
there's a couple of things we haven't
covered like props which we'll cover
right now
so with this create health element hello
if I want to say okay I want hello to
say who I'm saying hello to so I want to
replace this in DC with I passed that in
as of a parameter so I'm gonna go hello
name I'm sure you change that to this
stop props dot name calling set state so
the question was what causes it to
re-render when you call set state react
will basically cue up the fact that some
application state has changed and then
it will rerender it you're not in
control of when it rear Enders so react
does some nice things with batching
changes to make sure it only does one
rerender pass question up the back
the question was what who calls the
initialized state reactor does so we
have this class definition and there's
particular life cycle methods in there
I'll cover that in just a minute but
reactor takes care of initializing that
class for you and calling the different
rare life cycle methods so here I want
to pass in name and I'll put make this
NDC so and then when i re-render i've
got hello mbc so if i pass attributes to
when i'm creating an element those are
available on the props collection so
that's how these different components
interact you simply have one prop what
are one component which initializes a
bunch of children child components and
it this parent one normally has state
and it passes the state down as props so
you get this nice data flow state exists
at the top and then just flows down
through all of these components it's not
immediately obvious why this is useful
but we'll we'll get to that so it was a
bit of react 101 with that you
understand how reactor works essentially
question
so the question was if I have hundreds
of components and I need to pass down
hundreds of props I'm gonna it's
obviously going to be quite large
there's some patterns that we will see
lit towards the end which will cover
that so there's a couple of concepts
that we've covered a react element is a
representation of what we want to render
a react class gives us a class
definition we can create an element from
a class we then have props and state and
we've also seen the synthetic event
system so the building blocks have react
there's this is the part that everyone
when they first see it everyone there's
this concept called JSX and it's first
time anyone sees JSX they're like oh my
god this is horrible so we've got our
hello world component here which we we
saw this is pretty nasty really I
thought if you've got a hierarchy of
different function calls you end up with
this close close close close close of
presence JSX is the solution to this and
it's completely opt-in so you can
continue writing your react code like
that or we can turn those function calls
into pretty much XML elements so react
create element we can just replace that
with a div tag these two are exactly the
same JSX is just a compilation step
which turns the code on the right into
the code on the left transparently XML
is really good for a hierarchical data
because it's balanced it works well it's
easy to scan you can see the different
levels of of sort of how deep your
nesting is going and that sort of thing
so JSX simply allows you to work in a
familiar way but still be writing
essentially JavaScript it's just a
compilation time helper and it really
makes your code easier to understand yes
I will get to that in just a minute so
one of the things I like to think about
is when you get to JSX
it's kind of the weird al' kind of weird
not the jar jar binks everyone hates
kind of weird I thought this was a good
analogy because when you first start
you're like not so sure I like this but
it really does grow on you the next
thing is sort of that comes up as mmm
that's really ruining my separation of
concerns I kind of like my mvvm style
architecture where I've got my my view
model and I've got my view and I it
makes it easy to test well the thing is
that those two things are always really
tightly coupled majority of the time
you're chair making changes to a view
model because you want to display some
more stuff in your view and you're
nearly always making those changes at
the same time also with web we've been
forced to like keep these things
separate because we have different
technologies we have HTML 4 markup we've
got CSS 4 styles we have JavaScript for
our application behavior those technical
that so we've been forced to keep them
separate reiax gone well they're all
kind of the same thing they all want
I've got I just want to show something
on the screen I want to apply some
classes and styles to it let's just
represent all of that in JavaScript and
there's some really cool side effects
that that has so when everything is
JavaScript you can just sort of go we
don't need a templating language you
don't need to go learn what like round
brackets the square brackets are in your
templates you don't need a sort of have
to translate between sort of the naming
of directives and the in when you
declare them verse attributes and then
you don't need to sort of go okay well
in angular 2 we're using sort of the or
Aurelia we're using the es6
string interpolation style but in
angular 2 it's like a the squid double
squigglies
all these different templating languages
we're just inventing a new way of solve
problem so we're creating these dear
cells to specify bindings and when they
don't have enough power we add more
features and that sort of stuff we can
just with react everything is JavaScript
we don't have to worry about learning a
new templating language add language and
because it's a programming language if
we want to refactor our render method
because it's all just JavaScript if I've
got a bunch of JSX I can just pull that
out and assign that to a variable and
just use normal refactoring techniques
pull it out to a method however you
normally clean up your your code you can
do exactly the same thing to your
rendering code now there's also with
react because we're already in
JavaScript when there's no pausing step
so we don't have any chance of sort of
cross-site scripting issues everything
is automatically encoded if we have
strings that are in JSX
there's no way that we can just
accidentally execute stuff so react has
one way of allowing you to say just
render this block of text and it's like
dangerously set inner HTML and then you
passed that that's the only way to tell
react okay I actually don't want you to
encode everything it makes it pretty
clear that you shouldn't do that so the
heap of advantages to having everything
in JavaScript and then it's up to you to
how you separate your concerns you can
just break out more components do
similar to in your JavaScript or
whatever programming language is your
favorite when something gets big you
refactor it into smaller classes use
composition rather than rather than
artificially separating these two things
that are separated and a lot of people
have found value in this you can see
that with angular 2 now the recommended
way to do templates is you just have a
decorator and you have your template
attached to the component so they're in
the same file that adds a lot of
complexity because then you don't get
syntax highlighting and
intellisense so what the angular team
are doing is they've written their own
parsers to sort of give you intellisense
in HTML in time in a string and that and
then you have to like turn those
templates into code so now we need an
offline compiler to compile our angular
templates into javascript so they can be
executed by angular 2 or we have to ship
a template compiler to our application
and do that all in the browser react
simply just keeps it all this JavaScript
let's just if we declare everything as
JavaScript we don't have these parsing
steps to answer your question JSX is not
react specific it's just an extension to
JavaScript it's not a standard but it's
just an extension to JavaScript which
gets transpired so if we have this bit
of JSX here div class name this is I
wanted to call this one out because it's
a bit different class and for a reserved
keywords in JavaScript so you have to
have HTML 4 or class name they're the
only two but we've got this bit of J's
sex so if we have a react flavored JSX
when it compiled trans files it will get
react create element if we use say the
hyper Script flavor
we'll get h div class name foo high so
it's just a way of turning XML tags into
JavaScript so typescript also supports
JSX now and they you if you want it you
have to say flavor react and then it'll
actually transpile it it's just been
made popular but it is being used in
other languages how does this how does
this actually differ from something like
handlebars where I've got a template
which I compile to a function and then I
just passed my model and then HTML comes
out the other side re-rendering your
entire application in every time
something changes seems really expensive
and slow right so in handlebars we've
got our application state or our model
when we've passed
handlebars Dom pops out the other side
say that changes the entire Dom gets
rear-ended this has a number of problems
one say yes you've got a scroll position
or you focused on an input the browser
trashes the entire DOM and then
re-renders it so any sort of transient
state that is in the Dom like key
presses like focus and typed like data
that's in inputs if we're not careful we
lose all of that react has something
called the virtual Dom so instead of
rendering directly from our model into
the Dom react has an intermediate state
called the virtual Dom the virtual Dom
react takes care of turning that which
is a JavaScript object representation of
the Dom all of those elements it takes
care of rel rendering that into the real
Dom so what happens if our model changes
same scenario bit of state changes what
react will do is just render a new
virtual Dom because this is all in
JavaScript really fast it's just
building a object hierarchy that's super
super fast in react that virtual Dom has
one node which is different so what
reactor do is then it will diff the old
virtual Dom with the new virtual Dom and
create a patch that patch is then
applied to the real Dom and this is the
magic that makes react fast the diffing
algorithm to just diff to object
hierarchies is a well solved problem and
now there's a number of libraries that
do this super super efficiently the Dom
manipulation is quite expensive so this
part here where we're figuring out how
to apply the patch smarts can be applied
like okay if we use this like append
element or if we've got to remove and
then add another one well we can
actually reuse that same HTML element
and just modify it so the patcher
can actually do some really really cool
stuff and we don't have to worry about
it
so other other libraries like angular
and knockout they use data binding to
solve this problem you have the template
that gets parsed and it understands okay
this the value of this div is this
property over there so it has event
handlers so as soon as this thing
changes it needs to then go out and only
update that it's a different way of
looking at it like this but the
performance benefits and the simplicity
is I think really really compelling so
then the new virtual Dom becomes the old
virtual Dom that becomes the new status
quo and then the cycle just goes round
and round and round again one thing to
note is that the virtual Dom does not is
not the same as the shadow DOM shadow
Dom let's say you've got a input type of
range in different browsers you get a
nice slider or little plus and minus
arrows that's a complex input there's
actually a bunch of HTML that comprises
that makes up that range but we don't
see it if we could try and go to the
child element of the input range we see
nothing even though there is a bunch of
HTML under that that's the shadow Dom
that's been in browsers forever
we just have access to it now so if we
want our component can not show the HTML
inside it and also you can scope CSS to
a shadow Dom so this is kind of the
shadow Dom's the technology that
underpins web components and that's very
different to the virtual Dom technology
that react users to be very very fast so
next sort of part of react that I think
is just awesome is how explicit the life
cycle is so when you initially render
your application you get a bunch of
state initial state from creating this
hierarchy and props that are all flowed
down so you build this
this hierarchy of those classes then
react will tell all of your classes if
you define component will mount hey
you're about to be mounted into the Dom
you are becoming a thing after reactors
actually created that element in the Dom
it will call component didn't mount so
this is useful to create like
autofocusing text boxes you hook into
this and then you can get the real HTML
element and call focus imperatively and
then finally when your component is
going to be removed because the new
render has removed your component
reactor will actually tell you hey
you're about to be removed from the Dom
so it gives you chance to hook into that
this makes lifecycle really explicit you
can unmount you can create like
WebSocket connections or hook into event
handlers when you unmount you can clean
all of that stuff up makes it really
easy to understand what's happening then
we see state changes which then causes
props to flow down when that happens if
any of those attributes change values
react will call component will receive
props so when you go that you make that
class definition react uses that to
build an instance of your component when
it's going to be rendered into the Dom
now this is when you do a complete re
render what you're saying to react and
what you're returning is a bunch of
elements they aren't instances so if I
have that hello world component when I
say create element hello world that
doesn't create an instance of my hello
world it's only at the point that
reactors turning that virtual Dom into
real Dom that all realize that element
into a real instance so that means as we
do multiple virtual Dom murray renders
it can keep that same instance alive
over multiple re-renders of our
location and then simply say you're
going to be removed when it gets removed
from the virtual Dom it makes sense to
everyone cool getting some knots so
because we've got one instance that
lives over multiple render passes props
can change over time those attributes so
that says component will receive props
we then have this should component
update this is one of the amazing
performance tweaks you can sort of get
into when you have performance rendering
issues which while I was working in
London were working for a finance
institution and we built a
proof-of-concept which had a large grid
of ticking prices and the institutions
like well we sometimes have a burst of
prices we want to make sure that your UI
handles it so they wanted us to handle
about 300 prices a second when we first
built this grid there was about a four
second lag between when you clicked on
something and you'd actually get that
event handled that was how far we were
behind rendering so we did is the data
we version dat rose and it sells we use
this should component update for our row
component and we simply saw that when we
got the new data we just check the
version property on that data if it was
the same we return false
then react just stops re-rendering that
entire subtree and just says nope that
the result of a rerender will be the
same as if i caught like re-rendered so
this is a massive performance
optimization because we could just every
row that didn't have a price update
would just go nope nope nope nope nope
and then we would have a really really
fast rerender and we went from having a
four second delay on clicking to
rendering at 60fps in about an hour I've
had similar performance problems in
other applications and it certainly
takes a lot longer to to sort of get
through after you've said yes to that or
if you haven't implemented react we'll
say your can
opponent is going to update and then it
will call render after it's finished
render it said component did update so
this sort of if you do need to do stuff
to the Dom like you want to control your
component so you have a jQuery control
you can actually use this lifecycle to
go and basically tell react
I want to own the Dom under this and
then you can use jQuery to update bits
and pieces so you can use these life
cycles to sort of interrupt with the old
way of doing things if you really really
want to state changed is pretty much the
same thing when we call set state it
will call should component update
component will update render and then
component did update so this is what
causes the re render cycle either pre
props changing or state changing react
version 14 or 15 I forget what it was
introduced something called stateless
components so we saw that when we
created that react to create class we
had to create a class definition this is
kind of heavy
because react has to track that
lifecycle for that component when is it
going to be created when it's going to
be destroyed takes care of letting you
know when stuff is going to change they
introduced these stateless components
which is simply a function that takes a
bunch of props and then it returns a
virtual Dom this makes it really easy to
refactor your application if I want to
create a new reusable component pull it
out to a function give it a name and now
I can just use that I can compose that
in other parts of my application I'll
show you a more complex example of that
pretty soon
react also has something called prop
types reacts debugging ability and sort
of dev helpers are just amazing it took
because it owns the DOM and it's
rendering to the Dom if you say put
elements out of order so use a table but
you just put a excel and don't have a
row it'll tell you hmm I wasn't
expecting that particular hierarchy you
probably missed this we can also use
something called prop types so if our
component is expecting you to pass down
props we can declare what properties we
want so down here you just say hello
world dot prop types
I expect two things click and clicks I
think I actually said yeah clicks
clicked and clicks that's wrong but
anyway clicked should be a function and
clicks is a number if I get that wrong
react will actually throw out a warning
into the console that says failed prop
type required prop click was not
specified in hello world it then gives
you the hierarchy of who created that so
that allows us to sort of get runtime
typing and that's not too bad we'll see
how typescript can actually make that
better a bit later but that's
essentially react you've learnt pretty
much the entire library I think it's the
fact that you can learn it in that
amount of time just shows how simple it
is the problem is the rest of the
ecosystem so in terms of the pluses I
find react super fast it's really
flexible simple there's a heap of
reusable UI components now because
everything is componentized there's
heaps of components on NPM just go
searching there's like grids and all
sorts of stuff if you love your data
grids it makes it really understand data
flow because we're flowing props down
we're then raising events back up
everything is quite explicit it's just a
library and I find this less framework
learning everything is JavaScript it's
pretty cool the downsides are it's not a
framework reactors just a library it
doesn't take care of the entire
application that you need to build so
you have to make more decisions yourself
it's also less opinionated they really
wanted to keep the opinions out you can
find plenty of those there's lots and
lots of blog posts but Facebook
themselves wanted to kind of stay less
opinionated but the biggest downside is
it embraces new tooling and this raises
the barrier to entry
you massively the angular to talk
yesterday talked about this because
angular 2 has exactly the same problem
one last thing I wanted to cover in
terms of react itself before I go into
the touch on the grater ecosystem is
data flow so one of the patterns you
tend to find in react applications is
something called container or smart
components and you want to have one of
those quite close to the top of your
application that contains all of your
state and business logic but it contains
no JSX that actually is HTML elements
it's all about your logical the way your
app works it then shells out to
stateless or dumb components and passes
props so those dumb components are
basically responsible for rendering so
you've two sides you have these
components which are all at your
application level they're smart they
understand your business logic you then
have a bunch of these small reusable
components everywhere that don't know
anything about your application but are
responsible for rendering so you've got
a a massive tree of those props are
flowing down so you can see exactly how
data is flowing down through your system
and then you want to be able to handle a
click event but you have no state in
these components so what happens is you
just bubble those events up passing it
through the different layers back to
your smart component and then that
understands what to do with that that
might execute an API request
might update some state and in the case
that it updates the state the props just
flow back down again so it's very
explicit dataflow I want to show you a
bit bigger example of that so I've got
this application called urban plate my
brother quite enjoys doing cooking and
things and wanted to me to build him a
bit of a recipe site so I wanted to just
go into one of these and show you what a
reactor II looks like and how data flows
through so we've just got a Hawaiian
Hawaiian pizza recipe so I want to just
go recipe view view recipe so react has
because we've got the virtual Dom you
can install the react dev tools and
actually see what our component
hierarchy is not yet they're rendered
HTML so I've got this view recipe
component here bump that up for everyone
and you can see that it's got all of
these props that are passed to it it
also has some state because I can click
here and modify the number of Serbs and
then that all flows back down so under
here
I've got recipe headlines which are all
the things at the top and I have the
recipe if I go into the headlines I've
got these components which represent
each of these things and you can see on
the right the props are just flowing
down so all of these are all dumb
components I just have this new recipe
up the top it understands what a recipe
is and then it just passes props down to
everything so it gives you a massive
level of composition the code for that
is really simple
so if I'm having fun there you speak so
you can see here this is my render
method I can just directly each of these
things I import that component and then
I can just use it
that's composition in react I'm just
composing these components together I
can have a hierarchy of no there's a
apart from the h1 there's no real Dom or
rendering responsibilities in here I'm
keeping a tall application level the
rendering side of it is just a dumb
component somewhere down in that tree
means you can really understand what's
happening in your application and how
how the data flows how it's structured
makes it super easy to refactor as well
so the problem comes and the hard where
it makes it hard is the es6 modules and
the modern JavaScript tooling it
embraces modern JavaScript and so you
see nearly every boilerplate and every
sort of sample is using es6 it's got
webpack in there it's got all of these
things that if you're coming from
angular 1 its massive learning curve so
the other thing is modern web dev
actually has some really really cool
things so there's a reason they're
embracing it I want to quickly show you
back to this recipe list so the recipe
list here we go back
you can see it's not styled very well
I've just got some hyperlinks and
everything sort of smashed together so I
want to fix that remember I was saying
that everything is JavaScript we've
bumped that up for everyone
everything is JavaScript so recipes is
simply an array which I'm enforcing with
the prop types here so if I want to
render a list I just go array dot map
and then for each recipe I'm rendering a
link so what I want to do is I'm not so
happy just having a link so what I want
to do is actually just go okay I want to
create a new component which
encapsulates that that doesn't exist
notice here I've got es lint telling me
this is not defined pretty cool because
everything's JavaScript we can just use
JavaScript linting so I want to render
the recipe using air six here D
structuring
so I've created a new stateless
component that has one prop which is
recipe which is then being used to
render that if I save that jump back
nothing really happens because that's
not very interesting I want to wrap it
in a div just so at least they're on
different lines
I'll tab back and then you'll notice
hopefully helps if I start things
cool let's refresh that I remove these
dibs again cool so you can actually see
I've got no they're both on one line
I'll put the divs back in and save and
then a halt tab by the time of alt
tabbed it's already applied those
changes that's keeping all my current
application state something called hot
reloading what it's doing is that module
has changed so it recompiles that module
because I've got babel recompiling
things ships that updated file to the
browser using WebSockets and then
replaces the lake anytime you were
calling that module it's replaced that
javascript code so now it's executing
the new code but we can also do cool
things with styles so I'm actually
importing here I'm treating a CSS file
or it's sass file as a stuff as a module
so here I've got a recipe class and
notice I'm actually importing a
JavaScript object what I want to do is
just go class name equals Styles recipe
then I'll jump across and have a look at
these and you'll notice there's a class
name with a generated big generated name
that's something called CSS modules so
that gives us scoped CSS for our
components that's pretty nifty we also
get hot reload so I can go background is
green because that's how you do bug in
CSS and then you get something that's
horrible like that but we get also hot
reloading there is to ship the CSS to
the browser so these are the sort of
things that modern JavaScript tooling
actually give us this was a quite a
funny tweet I found yesterday and saying
modern web dev is a tire fire post ball
endeavors where it's at and it's kind of
true because at the moment getting all
of this set up is painful you need to
know so much web pack is a
amazing tool but configuring it as a
little bit of a pain there's now a lot
of stuff going on web pack too is just
around the corner they're trying to
simplify a lot of the configuration
there's tools which wrap all of this up
but
well you just end up having to know so
much so because everyone's sort of
aligning with all of the new versions of
typescript didn't Babel and ACMA script
we've got all we've got es6 we've got
typescript we then have all these
bundles you kind of have to know we then
also because we're grabbing all of our
packages from node and NPM you kind of
have to understand that we're not using
Bower anymore those package managers are
useless you then need to use like yeoman
to scaffold out your application and
then we've got sass which builds up and
it just keeps going every time you talk
to anyone they're like oh my god you
should be using this framework or
library that was created two minutes ago
but it's actually people who are putting
a lot of effort so under one of the guys
on the jaw and they're working for
Microsoft or pay's created these this
JavaScript services project so we can
actually use the yeoman as v-net core
spa template to bootstrap an asp net
core site which spins up web pack behind
the scenes with hot reloading so and
ship either angular 2 or react single
page applications via asp net core and
it just sets up all this hot reloading
it also allows us to like call node
modules directly from our MVC stuff so
it's just trying to bring these worlds
together Facebook have create react app
which is a little CLI tool that allows
us to just call out and it scaffolds us
an application with all of this
configuration hidden away there's a
couple of things you need to focus on
modules and modular module bundlers I
think everyone needs to know this at the
moment it's not going away and you're
going to need compilers it's just the
by a JavaScript tooling is going to be
there's always going to be new stuff
coming out and you're going to have a
heap of pain if you don't sort of get on
board with these new tools learn the new
JavaScript yes yes 2015 plus use Babel a
typescript as a pre compiler and
understand the tc39 process which is the
way we're getting language enhancements
or doing just a sec and then start
simple don't start with these huge
boilerplate just go to the docs getting
started and start with something simple
and then add things so in over time as
you understand them thought I'd quickly
talk about the tc39 process because this
is the way we actually get new features
in JavaScript now essentially we've got
five stages when something hits stage
for there tc39 committee meet once a
year and everything in Stage four ends
up in the new version of JavaScript
that's why they've moved to es2015 es
2016 yes 2017 so like as an example if
you follow there's a it's all up on
github async and await just hit stage
four last week in JavaScript so you can
now actually use if you use async and
await in dotnet es 2017 will actually
contain a sink and a weight as a start
standard in JavaScript so it's cool
staying across this stuff and
understanding what's coming because
there's huge amounts of cool stuff in
the pipeline modules we're getting close
to the end guys modules pretty cool so
that's the new syntax for importing a
named module or importing a default
module so with react we're exporting a
default it's got a but it's like a
namespace with lodash we're exporting a
bunch of functions so defining them all
and then exporting each of them as a
named function you can also treat other
things as as modules which is kind of
cool
config templates Styles react
you can actually use classes and it's
encouraged we can use things like static
properties to just reduce the amount of
boilerplate code but it also works
better with typescript so if I've got my
hello world I can actually just specify
what my prop types are and then I get
compile time safety on my props I get
full Intelli sense because everything is
JavaScript I can also do stateful
components and use a generic base class
where I can specify the type of my state
and the type of my props if I if I type
something wrong I get a compiler error
we've moved all those runtime prop type
warnings to compile time so many
advantages by just staying in JavaScript
we pull it all together with something
called web pack which I'm not going to
go into a huge amount of detail on but
it essentially takes these JavaScript
files and then outputs a single
JavaScript file or multiple if you want
you can configure it to do that and
basically any assets that are you're
tracking so images CSS that sort of
stuff a basic config
you have an entry point and you have
some loaders loaders when it sees a
module of that type it uses a loader
which is basically a transpiler it tells
typescript what to do with it and that's
a basic web PAP config go to a
boilerplate and they're normally about
ten times this size but you should be
able to start with something like that
we've seen hot reloading there's a few
like other things I just want to let you
know that you can do so isomorphic
rendering is another one so this is
rendering universal applications another
example of why it's called that we have
a JavaScript representation on the
server we can actually take that virtual
Dom that we've rendered we can run our
entire node app our react app in node
because it's actually not tied to the
browser and then we can render that
virtual Dom into a string and then ship
that to the browser as static HTML so
you could almost you could actually
right a MVC application using react it's
it's pretty cool pretty powerful stuff
we didn't really we didn't cover testing
because that's a massive topic in itself
but once again just because you're not
tied to the browser you can actually use
things like jeaious Dom if you want or
shallow rendering and do UI tests in
nodejs
so you don't even have to fire up the
browser you just trust that react will
render it properly to the real Dom a
library if you're looking into testing
is called enzyme it's by Airbnb
so the Airbnb team have been switching
everything over to react and they've got
an amazing testing library for react
there's quite a few things that we
haven't actually covered I wanted to
give you a sort of a foundation of what
why the fundamentals of reactor quite
simple and they allow their great
building blocks for building really big
complex apps and there's some patterns
that really allow us to to build
large-scale applications so things like
higher order components they allow us to
they're basically a component factory
that we can say okay say we want to
authorize component we can just say here
are the roles that I require if you
don't meet those it just won't render
its children otherwise it will pass down
sort of your other credentials to the
children so you can do some really
wicked stuff with that to really reduce
the amount of boilerplate things like
forms as well you can use higher-order
components to make the like assigning
the value and then listening to the
input events make all of that
boilerplate that everyone calls out with
react just go away
and then finally patterns like flux and
redux they're they're a whole talk in
itself so I can't go into that but
they're worth once you understand the
basics look into them but don't choose
something like Redux as default because
set state will get your really long way
so just wrapping up things I love about
it dataflow is explicit it
from top to bottom events go back up
react itself is super simple we saw the
first sort of half of the talk we
actually showed you pretty much the
entire API surface area of react whereas
a lot of these other like frameworks is
just so much more involved and every
because where everything is JavaScript
most things you're learning are
transferable so there's a bunch of
really cool libraries like like cycle
Jas and whatnot which which take all of
these patterns and they're just done in
alternate ways you can move to these
other libraries all your knowledge is
transferable I'll take questions offline
because we're pretty much over time
here's two links the urban plate is one
and then I've got another repo here
which is the web pack react starter and
the idea of that is I've got sort of
eight or nine commits which introduce
each concept one commit at a time so
whenever I make changes I rewrite
history and fix the commit I introduced
that into so I found that really really
good to see each step introduced thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>