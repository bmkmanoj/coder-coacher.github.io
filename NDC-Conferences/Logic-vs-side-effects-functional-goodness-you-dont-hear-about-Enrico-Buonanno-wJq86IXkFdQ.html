<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Logic vs. side effects: functional goodness you don't hear about - Enrico Buonanno | Coder Coacher - Coaching Coders</title><meta content="Logic vs. side effects: functional goodness you don't hear about - Enrico Buonanno - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Logic vs. side effects: functional goodness you don't hear about - Enrico Buonanno</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wJq86IXkFdQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good afternoon and welcome to
this talk this is the last
facture program in the conference so how
fried is your brain by now crispy on the
outside a bit deep-fried by the end of
this so in this talk of basically
discuss functional programming from the
perspective of how to think about an
isolate logic from side effects and some
pretty basic techniques that if applied
to this judiciously can help you to
write programs you know in a very
different and more maintainable way my
name is Erika Bonanno and some of you
may know me as the author of this book
functional programming in c-sharp
published with Manning this book was in
early access for over a year and just
recently has been finalized both both
the e-book and the print edition and I'm
showing the screenshot here at the
bottom left you can see that there are a
couple of free chapters so if you're
interested just download those brief
outline for this talk I'll just say a
couple of words on our problems as
software developers and my take on
functional programming and then we'll
delve into side-effects and see what
they are and why you might like to
minimize the scope of side-effects and
separate them from the logic in your
applications and we see how to a certain
effect to some extent we can do that
with dependency injection and with
another technique called free monads and
everything I'm going to try to explain
with some with some real code that is
some kind of simplified version of the
of the code that most of us write day to
day I take it so what is the software
crisis so we don't know exactly but I
suppose most people think of the
software crisis as our inability as
developers to deliver software according
to our clients expectations right so it
it takes too long it's not good enough
features are scheduled and then they can
sort and so on and I think the other
aspect so disappointments from the users
effective right and as users we all know
this we walk onto a website and we can't
do things that should be easy right and
then from the developers point of view
the crisis is that we can't we can't we
can't work with pleasure right with
enjoyment very often so you go for this
job interview and looks okay and then
you're hired and then you look at the
codebase and you say no again the same
problems over and over right and I think
some of these problems are our own fault
in the sense that we don't prioritize
things right so I estimate we invest
about 75% of our time and energy into
development tools by which I mean the
development tools the language features
frameworks frameworks very important
right
and we we spent so much time on this and
that's part of the problem right because
if you think about maybe five years ago
ten years ago would you say that your
tools today are a lot better would you
want to go back to the tools and the
frameworks you were using ten years ago
probably not but the products that we
use or the web application that we use
are they so much better than there were
five or ten years ago it's not
interesting when people have this messy
code base and it takes forever to add a
new feature because there's been all
this technical debt they say oh if only
we could rewrite this using this great
new framework and then they do we write
it and they end up with the same
problems as before right and and so the
problem is not with the tools I think
the problem is mostly with the other two
points so the ideas and the processes
and with ideas I mean the software
architecture how do how do you name
things patterns and of course paradigms
like functional programming so yes it
does make sense to be right things it
does make sense to migrate to new frame
works but only at the same time you also
keep developing your your knowledge of
the ideas of the practices of the
conceptual tools if you like and I think
the processes we use are also highly
ineffective and we don't question those
enough so when was the last time you
were asked to write a proof of concept
for a new technology it happens pretty
often right worst case scenario you
throw it away you've wasted two weeks
and but you know that this product is
not for you and when was the last time
you did a proof of concept for different
process all right let's invest two weeks
doing mandatory pair programming wahala
percent of the time right there's no
there's no experience on that front we
just sort of put our hands up and say
yeah I just go with what the team does
but so this talk is about the second
part so the ideas and a functional
programming in particular and the
benefits it can give us which to me our
power safety and clarity and when I talk
about functional programming I mean a
style of programming that emphasizes
function and avoid state mutation but
today I'm going to look at it from
slightly different perspectives so as a
way of thinking about code that helps us
to understand an isolate logic from
side-effects so when I say power safety
and clarity power I mean simply you can
do more with less code and this is
because in functional programming you
treat functions as values and this
raises the level of abstraction and as a
very simple demonstration you can see
for example link in c-sharp link is a
functional library and it uses
higher-order functions all over the
place so this is a very trivial example
right we have this get percentages
function it creates a sequence of 100
numbers and then it only takes the ones
they are divisible by 20 change the
order and then it renders them as
strings as a be the percentage sign so
when you call get percentages
you get 100 percent 80% and so on and
this is very simple but say if you want
to parameterize this now say instead of
every 20 number every 20 percentage
point you want to get every X percentage
points it's like a 1 second refactor
right it's really easy and if you say
well ordering shouldn't really be here I
want to effect to this order out that's
that's also really easy right you just
you just remove that line and you move
it somewhere else and if you were coding
in the in the pre linked world in
c-sharp this would have been completely
different you wouldn't you would have
used for and if and then all these
operations would have been a lot more
difficult and time-consuming so this is
just an example of how an API that's
built on functional programming
principles such as nink
can actually be very usable and very
powerful
the second point safety what do I say
what do I mean by safety is just that
the code simply does what you think it
does and this is basically because in
functional programming we avoid state
mutation so I think of safety not so
much as a virtual vex of functional
program but rather as a pitfall of
programming with mutable state and let
me give you a couple of examples what I
mean so the examples in this in this
presentation are in c-sharp but the
contents are complete in language
agnostic so here we have a class order
with the list of order lines and then
you have a property total and the total
gives you the you know the total cost of
the order and it seems obvious what the
code does right I mean it goes through
the order lines and it adds up all the
prices but now let's look at this list
of ordinance this is actually a mutable
list so what could happen is that
potentially there's some business rules
that the order lines need to be sorted
by some criterion and while you're
asking for the total some other thread
is sorting the list so you told me
completely off right and so it's it
seems so simple what God does but in
reality when you take multi-threading
into account it's not so you go through
all your order class and you see well
let's see where is all the lines being
accessed and it's not that's accessed
anywhere oh wait it's public so actually
anything in your application and in any
code that could be written in the future
could actually go and change this code
under your feet and break your total
method so that's just an example another
example sort of runs along the same
lines so you have this method process
sales so when you sell a certain number
of items you update your inventory and
then you have this simple business rules
that if temperature is less than five
then you set this boolean that the item
the product is low on inventory again
simple but if you take multi-threading
into account then there's this where you
have the comment with with a question
mark what happened there then now your
object is sort of halfway through this
transition so from the point of view of
another thread
you've now broken this invariant that
you're trying to maintain that this flag
should should be related to the imagery
and if the business rule for setting has
low imagery was a bit more complex had a
bit more latency then you would start to
see the effects and with functional
programming this what this all goes away
and we'll we'll see examples of how to
program state transitions like this
without using mutable state and the
third aspect that that's the more
important for the purpose of today's
presentation is clarity so functional
programming is a very simple paradigm
because it relies on functions and
functions are very simple things right
functions are just inputs and outputs so
we can we can relate to this you know I
give you a dollar and you give me an ice
cream
it's
give and take right and that's it so
this may sound obvious but the nothing
else
that's the tricky bit because we tend to
do other things that can break this
clarity of the of the function as a
contract so there's a lot of terminology
in functional programming the only
terminology I'm going to introduce today
is this and so it's two ideas but it's
actually the same idea from two
different sides so what are side effects
and what are pure functions these are
the side effects that we're going to
look at today these are the side effects
right so mutating function arguments
foreign exceptions reading and writing
formidable global state and when they
say global State that's any state that
is not local to a function so a private
instance variable is considered globe of
state and performing IO so these are the
things that if you think about it
introduced in the terminus see in your
functions right so if your function does
these things then you're not really sure
what the result of the function will be
and at the other end of the spectrum you
have pure functions so pure functions
have no side effects so in a sense it's
the same concept viewed from the
opposite side and as a result their
output is determined solely by their
inputs so after if the named pure
functions sounds a bit scary just think
of them as deterministic functions and
most mathematical functions are pure
right so the square root of four is
going to be two no matter what state of
the world is it's always going to be two
if you call it twice it's always going
to be the same so pure functions have
some very interesting properties because
of this deterministic aspect they're
very easy to test
so you give some input and you assert
that the output is as expected
they're easy to understand they're very
easy to optimize particularly you can
memorize so cache the results right if
if I've computed it once why compute it
again and they can be parallelized you
know without any special effort right
whether you take the square root of two
hundred numbers sequentially or in
parallel it doesn't really matter it
doesn't affect the result on the other
hand few functions cannot be monetized
right if you paid to write code or if
you pay for a product it's because of
the side effects right if you buy a
device if you buy a product it's because
it does something right pure functions
only compute stuff they don't do
anything
so obviously we need both and the idea
is that our program will have logic and
it will have side effects and we're
going to want to separate these two so
we can take advantage of these nice
features of pure functions and we're
going to want to avoid unnecessary
side-effects isolate logic from side
effects and encode our logic with pure
functions so what I'm going to do now is
we're going to go through these
different types of side effects because
the way we can we can avoid these side
effects goes from easy to not possible
and how to deal with those so so so we
now go through these and we see how how
we can avoid them basically so mutating
function arguments is something that is
still done quite often but should be
avoided let me give you an example so
say you have a shopping basket and you
have these little errors that allow you
to increase and decrease the number of
the quantity that you want for an item
right so when you change that the
quantity the the value of the order
changes right so you have this function
called recompute total that computes the
new total for the order and that
somebody comes along and say oh wait but
if the if the if the number of items is
changed to zero then I need to delete
that order line completely because the
customer doesn't want any so let me just
pass in this list of order lines
leads and since this method has to
traverse the other lines to recompute
the total it's also going to populate
this list as a side-effect right so this
method computes the new total of the
order and as a side-effect populates
these lists of lines that you want
deleted and I've been programming for
many years and I see some code like this
and you know this it doesn't quite feel
right right but well what exactly is
wrong with this I mean how do you
explain to somebody else how do you
explain to your colleague who wrote this
that this is not a good idea and the
reason is that now you've effectively
coupled logic in the calling code with
the logic in the function so what ends
up happening is that for example this
line that's commented out lines to
delete not clear so it clears the the
given list should you should you do that
if somebody calls you and and in that
list is not empty well what does it mean
if they call you twice with the same
list do you delete the roles twice right
so it's not really clear right if you
say well to maintain this code and make
changes then the only way you can know
the impact of changing that line of code
is to actually look at all the places
where this call is being it's being
called and this is what makes the
application difficult to reason about
because you're effectively coupling the
function with its colors and it's very
easy to refactor this so effectively you
have to acknowledge that the function is
calculating two things it's calculating
the new total and it's calculating the
lines that you want to delete so you
acknowledge this that this function is
doing two things these should be two
outputs so now this is
c-sharp certain tuple syntax so the the
type of the output is a multiple and
additionally c-sharp set me you can have
names for each element in the tuple so
the input is simply the order that's not
mutated in any way and then that's the
implementation which is still fairly
trivial
so in summary keep your function honest
and just have inputs and outputs and
when you mutate function arguments
you're actually modeling the waters
because this this function that's being
mutated it's it's on the input side and
it's on the output side so it's like you
know I give you a dollar and you give
you an ice cream and at the same time
you do something with a dollar that
somehow changes it and I still have a
reference to it and I can see that
change and it's it's very unclear right
I mean you wouldn't want to enter into a
transaction like that so we've seen that
you can actually completely avoid this
side-effect of mutating faction
arguments and it will make your code
cleaner and easier to maintain now on to
the second side effect which is throwing
exceptions and this may sound surprising
what
so never throw exceptions yes never saw
reception's there are indeed programming
languages that do not have exceptions so
let's bring up some code and if you code
in c-sharp for living you've probably
seen code activists quite often in fact
so often that you think you know why do
I have to write this so often you know
isn't this duplication if I have stuff
like this all over the place and so what
happens if I uncomment this the throw ax
should have we throw it exception should
I swallow it as in this case how does it
affect my application if I uncommented
line well effectively it's a breaking
change isn't it because
all old all the codes that was relying
on this function not through an
exception now needs to change because
now the function does throw an exception
so it is a breaking change but the
compiler doesn't doesn't tell you that
it's a breaking change right it thinks
it's okay and also if the exception
occurred in live dangerously does it
matter that we skipped regret the early
part
so in factual programming we completely
will use this approach at all and
instead we follow the approach of making
the possibility of failure explicit in
the function signature
as a result an error doesn't throw an
exception which is going to end up
somewhere in a in some catch block up
the stack but it's just data
you know it's an error and you have some
data that represents that ever so let's
compare these two functions signature
the first one create take some string
and it returns an email so I don't know
what the email class is exactly but you
know you can kind of guess that the
string is a string representation of an
email and the email type is a more
structured representation so maybe it
has some property what's the domain
what's the local part but what if you
pass a string that's not a valid email
what what if you pass it the empty
string what happens do you get an O do
you get an exception write the signature
doesn't tell you that you know if you
look at the signature just below we're
still taking an email a string as an
input but we're returning a validation
of email and you don't know what by
addition is exactly but you know you can
assume that it has to do with
validations so if if the string is valid
and this email generic parameter is
going to be somehow you can query this
validation and get
the email or you could get some
validation errors right it's even if
you've never seen this the the signature
is telling you something about how
errors are going to be handled and
indeed in functional programming we have
a number of different types that are
used to represent errors so the classic
that you find in the old style books is
either so an either is a type that can
be in a left state in which case it
means that something's gone wrong and
you have some data of type L that is
data about the error or it can be in the
right state which means that yes it's
all right and in this case there's an R
which is the type of your results or
your successful result and then if you
don't want to be so you know to have
these funny names then you would call
these results instead with failure and
success but basically the same idea or
if you're like me and you like to
separate validation errors from
technical errors then you can use
exceptional to sort of wrap exceptions
that may have occurred in lower-level
components that do throw exceptions or
violation for more business-oriented
validation now I don't have time to
discuss all these types in detail
they're all described in my book of
course but you know functional error
handling is a wide area so I I just have
time for 404 this short introduction
dotnet doesn't really have these types
so you can either use a functional
ribéry or you can use a type that does
exist in dotnet and it represents that
can represent success or failure of an
operation any ideas you use it every day
tasks
yes exactly so tasks as a result
property so if it was successful than
result property we've populated
it has an exception property so if it
failed then that will be populated it
has a status flag that tells you what
happened so for example this is the
object-oriented version that you tend to
see all over the place we have an
account with a balance and then when you
debit the account with a certain amount
if the amount is too big then throw an
exception otherwise mutate the account
balance so notice we have two side
effects the exception and mutating state
and if I reflected this to a functional
style now okay so for one thing in
functional programming we separate data
from logic so you see that the account
class at the bottom now only has data
and it's immutable right so there's only
one property and it already has a getter
which means it can only be set in a
constructor and the logic is in phase
and colony functions so now if you look
at the debit function it says okay if if
my business rule is is violated then I'm
going to create a task with an exception
but except the exception is not thrown
right it's it's wrapped into an object
and otherwise I will return a result
which is a new account which is
obviously a representation of the same
account but with the with the modified
balance and how can you do this how can
you use this approach so this would be
your typical server-side stateless
server side workflow where you get a
request you load up some data from the
database you change the data and then
you receive it and of course everything
can fail potentially so you use tasks to
represent these various types of failure
so you get account get account could
fail in which case the weight keywords
because of the weight keyword the rest
will be skipped and likewise if debit
fails then the following line is skipped
and so on
so we're kind of using the weight
keyword to do monadic composition on the
task moment right so I'm not saying
write code with using tasks everywhere
but but but it is a possibility so in
other words again keep your function
honest that's that's the mantra right
only inputs and outputs and if a
function can fail this can be
represented in the type you use for your
output so we're doing pretty good
because we've just found out that of
these four possible side effects the
first two we can get rid of and we can
we can make our applications safer and
more maintainable by doing so now onto
mutating global states can we write our
applications without ever mutating
global state and one reason that mutable
state is bad is because it doesn't work
well with the multi-threading these are
the examples that I showed in the intro
and then the second reason which is just
as important for me is that it tends to
introduce coupling so say you have these
two objects being see that both have a
dependency on object a but they don't
have any reference to each other right
so you'll think that they're not coupled
but in reality if B has an interaction
with a that causes a to change its state
and C has an interaction with a that
relies on that state in fact these two
objects are coupled and I think that
couple coupling is really one of the
biggest problems in our in our software
so let's look again at an example so
this would be a typical object-oriented
version you have again this list of
order lines with the total method and a
function to add a new order line right
so the user adds adds a new item so you
have state mutation because you're
changing the list of all the lines how
would you do this in a functional style
again order would be an immutable class
and it would only have data so remove
the add function out of the other class
and I've made lines an immutable list so
when you build an order you give it a
list of order lines it has and total is
just a read-only property it's computed
so it could stay there or it could be a
doesn't matter but if we look at add
what does add to add does order dot
lines and that's an immutable list so
add the add method creates a new
immutable list with the added element
and then we create a new order that
represents the order with the added line
so essentially what we're doing is
rather than modifying an object we are
creating modified copies of an object
and this is where most people say but
wait how do I represent the current
states of my order and the idea is that
well first you might not need to
sometimes you do need but in that case
mutating the thing in memory is it's not
the best way but the key point is that
these are separate concerns so
representing state is one concern and in
functional programming we do this with
data objects so these are completely
anemic objects that just have data
state transitions are these functions
that give you modified versions of these
objects and that's again a complete
separate concern and for this we use
functions and then there's the much more
complex a question of associating an
entity's identity with its current state
so what's the current balance on my
account
right and for this you really need a
different abstraction so maybe you
choose to model this as a stream so
using I observable or maybe you have
some other primitive like an atom or a
grain I'm not going to get to get into
this but the key point is that these are
separate things keeping the current
state of something that changes through
time is really a separate thing than
representing the state of a thing okay
so so far we've seen some some some
simple some simple logic of you know
avoiding state mutation so instead of
instead of modifying stuff we create a
new copy but now you say okay but what
if I need to have some state in memory
that changes in other way words can we
write stateful programs without mutating
state and how so this is an example of
an interaction with a very simple
program so the white text is output by
the program and the gray text is the
user input so would you guess this is a
stateful program
stateless okay let's see
so you give it your USD eur/usd is the
it's it's euro dollar right so it's the
rate from yours two dollars and it says
okay now I need to fetch the rate and
then at some point it prints one point
twelve and then you give it your a you D
so you're a euro Aussie dollar
it says fetching rates 152 and then you
give it you USD and oh now it's
different now it just gives you 112 so
it doesn't fetch the rate so it's
remembered that it already fetched at a
couple lines ago and so I don't need to
fetch the rate I can just reuse the rate
area I fetched right so the program has
memory right so it's a stateful program
and so incidentally this is also this is
not just for programs where I so when
scientists test to see whether an insect
has memory or whether plant has memory
that's that's what they use right if you
deliver the same stimulus twice and you
get a different response then it means
that the thing the thing remembers
things right so how could we write a
program like this that keeps a cache of
the currency rates that it's already
retrieved without mutating state because
you know stateful states with mutation
we all know how to do this right you
have you have a cache somewhere and you
add stuff to it so there's a pattern in
factual programming so a normal function
has an input and an output and a
stateful function or a state transition
if you like has an input and it also has
some state along with the input and then
along with the output it also returns
the new state and then it's up to you as
a developer to
to sort of wire these functions up so
that the new state is is fed into the
function next time it's called
so let me show you an implementation for
the program you know that retrieves the
currency rates so the cash that we need
we're going to use a dictionary so we're
going to map the names of the currency
pair is like euro dollar that's a string
we're going to map that to the rates so
that's the first line and because
because we don't want to use mutation
I'm going to use an immutable dictionary
and because that's kind of an ugly noisy
name and immutable dictionary of string
to decimal I'm just going to alias this
as rates and then if we go to the very
bottom that last line that's the
function that given the name of a pair
returns the rate so this is a stateless
function right and this will actually go
to the internet and say okay go to some
service online and do an HTTP request
and Paris the result as a decimal and
return it so the details are not
important the point is it takes the
string returns the decimal and now if
you look at the function just above it
look at the signature it's the same but
in addition we have the rates so we have
the state both on the inputs and on the
output so it's basically the stateful
version of this function and what is it
does it do it says well if my cache
which is the state if my kasia really
contains this currency pair then just
read just retrieve it from from the
cache and the state so the cache remains
unchanged otherwise go to go to the
internet to fetch the rate and return
the rate as a result and then the cache
with this rate added to it as the new
state and then if we go to the top to
the main function main just Cosme req
meaningful for me recursive with the
initial state of the program
is just an empty cache and then the
program just reads the input gets to
rate with with the current value of the
cache and this returns the rate and the
new cache it prints the rate and then it
recursively calls itself so notice no
mutable data right we only have some an
immutable dictionary and the way this
changes through the life of the program
is that it's complete it's always fed
back into this stateful get rate
function another way to look at this
problem is through folds so I assume
many of you know what all this but in
case you don't let's just review it's
really easy so a fold is an operation we
have three things you have a list in
this case we have a list of oranges you
have an accumulator in this case it's
the glass and then you have a reducer
and in this case that's the orange price
so a reducer is a binary function that
takes the accumulator and one element
from the list so you take the glass one
orange and you use the reducer to
squeeze the orange into the glass and
then you move on to the next orange so
by the end of the fold you've squeezed
all your oranges and you've got your
glass full of oranges and if we look at
it more more diagrammatically you have
the list of M's so this will be your
oranges and then you have some
accumulator s and then the reducer kind
of squeezes the s with the first M to
get a new s s one and so on and you can
view a stateful program as a fold so you
have an initial state of your
application that's s0 and your program
receives a set of messages or a stream
of messages to a time that's M zero and
one and two and so on and the program
itself is a reducer function so it will
take the mess
with the current state and it will do
some processing and then elaborate the
new state and and this is not just you
know that just just a nice idea you can
actually turn this into code so in
c-sharp
you would turn this into code like this
so if you start at the bottom this is
the same state full get rate function
that we've seen in the previous example
so returns the currency pair along with
the state and then we create a sequence
of inputs these are the inputs that are
read from the command line and then the
main function does a fold so fold in
c-sharp is called aggregates aggregate
so we aggregate the list is our list of
inputs so the the values that we read
from the command line the initial value
for the accumulator is an empty cache
and then the reducer function is this
this lambda here that takes the cache
and a single input it gets to rate it
outputs the input and it returns the
updated state which will be used as a
new state in the following call to the
accumulator function so in summary we
can use this pattern of having the state
both on the input and in the output side
in order to write stateful programs
without any state mutation and the
advantage is not only that we reduce
side effects but also that it's a lot
it's a lot easier to test right how does
this method affect the state of my
program well it's easy you know give you
the state and then you see what state
comes out and you can you can assert
what states you expect so you don't have
this problem my app went into a weird
state anymore because you can just write
tests in a given States and given an
input what's the expected what's the
state expect
and in a way you can think of this as
dependency injection funnily enough
right your what is the dependency
injection your dependency injection is
when you kind of make it explicit that
your function depends on something well
in this case you're making explicit that
your function depends on the program
state and on the output side you're
making it explicit that you're your
function changes the program state so
we're doing really good because we've
seen that out of four side effects
four types of side effects we connect we
can actually get rid of most of them so
with the mutating global state it's it's
a bit harder right it takes it takes
practice
the other two are be easier so we're
only left with IO and can we get rid of
IO no right because I always a
requirement you can't just say no I'm
not gonna persist stuff to the database
because I want everything to be pure
because you know you're paid for the
side-effects you're not paid for the for
the pure functions so what we want to do
is have the separation between logic and
side-effects but now we've seen that a
lot of side effects
we can avoid so hopefully the proportion
will lean more towards this so more pure
functions and a smaller footprint for
the for the code that performs just the
IO of course if a function calls an
impure function then that function
itself is impure as a result we need to
find some way of combining logic with IO
that doesn't sort of pollute the logic
with the side-effects of VO
and how do we do this and there are a
few candidates that I'm going to discuss
the one that's best known is dependence
injection then there's this idea of
dependency rejection and finally
another approach that's called free
monads so let's go back to this to this
function that we had in our in our
application that fetches the exchange
rates so if we look at the the part
above we've seen that we've with kated
for the for the state mutation so
there's no side effects in terms of
state mutation but there's a side effect
in terms of IO right because when you
call the the other get rate the one that
that is stateless that goes to the
Internet all right it goes to the market
to get the exchange rate so you couldn't
really test this function right in unit
tests for example so what do you do with
dependency injection in this case I'm
using a completely functional approach
so I inject a function to get the rate
so this is a function that takes a
string and returns the decimal and I
call that so in the in the real
application I would inject the get rate
function from before that that goes to
the Internet to get the rate and if I
want to test this function I will
instead inject a function that just
returns a pre can't answer right and
this is a more functional approach and
then of course we have the
object-oriented approach of injecting an
interface into the constructor of an
object but basically it's the same idea
right you you you inject behavior so you
can then choose to wire up these
functions so that you get a testable
version or a real live version then
there is this idea of dependency
rejection and this is this is a term
that was coined by Mac Simon he's a
frequent speaker at NBC so I definitely
think
to check out his videos of previous
prevent presentations and what he says
is well we want to isolate logic from IO
which is what I've been preaching so far
so we're going to have all the logic or
as much as possible in pure functions so
these can be testable and then we're
going to have I owe in impure functions
and these are not going to be testable
and then for a sort of top level
workflow we need to compose this tool so
we will have sort of a high-level
workflow that takes the input from one
of these functions and feeds it into the
next and so on well of course because
these high high level workflow use the
i/o functions these are also impure
these are also not testable so a lot of
three things you see that only one thing
is testable so it's not very testable
and the other thing is it's also not
very general because if you go back to
this code and if you look at the top
part how do you take that that impure
get rate function and sort of extract it
how do you call that
without side-effect without actually
ending up with exactly the same as with
the pendous injection
so in other words I think the idea is
valid and it works some of the time but
as I said it's not very testable and
it's not very general and the last and I
guess most innovative approach I'm going
to describe is three months
now three months is a topic that
deserves talking itself so this will be
only a very brief presentation so don't
worry if you don't get everything but
just to get a feel for this free model
is is much more radical than dependency
injection in separating logic from
side-effects and it basically consists
of three steps so you use data objects
to represent instructions this is
somehow the same as in the
object-oriented command pattern right
rather than calling something I'm going
to create an object and this object is
going to contain the data that I might
then use as parameters to code to call
this thing and then I will have on one
side the logic that produces this list
of instructions so this doesn't have any
side effects it's just logic right and
on the other side I'm going to have an
interpreter they will take those
instructions and translate them into
side-effects so this is a bit like the
idea of having a shopping list so you
can compile your shopping list and
that's just data just for writing the
shopping list doesn't mean that you go
shopping so you can write this shopping
list that's just data and then you pass
it to your errand boy that he's the
interpreter right who goes out and does
the shopping for you so he does all side
effects you only deal with the data or
you could choose to pass that list to
your accountant and he could check to
see if you know if your budget is okay
so you have a variety of interpreters
for the same instructions and let's see
how the previous program could be
refactored to use Freeman odds so
instructions as I said are simply data
objects
so you have a class represent so DSL
stands for domain-specific language so
you have a DSL for communicating to the
to the standard output and two
operations ask which is when you read
from console and tell which is when you
print to the console and then you have
DSL for HTTP and I'm just going I just
need to read from the console in this
case if you're doing more you you might
have other instructions for post with
more parameters and so on so basically
you just have some data that somebody
else can then use to perform the side
effects and this is an example of the
interpreter so this is your errand boy
he just takes an instruction and it's
basically switch so what's destruction
if distraction is to ask then I'm going
to read line from the console if the
instruction is tutele then i'm going to
write the the message that is part of
the payload of the of the tail object
I'm going to write that to the console
and this return unit which just returns
the empty tuple because it's it's a bit
like void right because this is this is
data doesn't return any any data so I
just use the empty tuple and in the case
of a get I perform an HTTP client get
string on the given URL so I only need
to care about these three types of
instructions for the given program and
then this is the the trick where there's
a bit of magic right because I don't
have time to really explain about three
months now but you have these these
helper methods so it's it's called
Factory so this is a factory for
creating not exactly instructions but
this creates three monads
that contain these instructions so let's
look at the first one it's a free of
string so a free of string is a workflow
that when you run will produce a string
and in this case I'm producing it I'm
putting on a skin to it so this is a
workflow that consists of exactly one
instruction and instruction is to ask
something from the command line
and then likewise I have a tell a
function with a message and this will
create a workflow of one instruction
that when executed we return unit so it
will return no data and similarly for
get and now we have the logic so we have
these functions for creating these
workflows and then we use linked
comprehensions to glue up these
workflows so remember with a shopping
list if you just have a list of data
then I can give you very autonomous
extractions you know like I get some
bread get some milk
but I can't really say you know get a
basket and then what I want to say is
then get some milk and put it in the
basket but I somehow need a reference to
the basket which have but that basket
doesn't exist yet right because it's
it's not been interpreted yet right so
the Fremen is what exactly what
basically here allows you to say ask
which is work for that will ask from the
command line
and then from pair in ask that variable
pair will be the result of executing the
ask after it's been interpreted so some
program some interpretive in the future
will interpret this logic it will run
ask and it will end up with a string
that is read from the from the console
and I'm gonna call this pair now and on
the on the second from Clause I cannot
refer to pair so you can see in the in
the URL we have the pair we pass this as
part of to the URL and we and we use
this to create our second instruction we
I want to the next thing I want to do is
I want to get the data from this URL and
I'm going to call it rate and then my
third instruction will be to tell that
rate so to print it to the console and
then I'm going to recursively call the
main logic so this goes on forever so
this is the logic for the stateless
version of the of the program that reads
currency pairs from the from the console
and retrieves the rates from the
internet and prints it out back to the
console and if I want a stateful version
it's just slightly more complex so we
should start from the bottom so where it
says return we see the first times it's
the same so we still have asked as the
you know the first operation is that
you're going to read what's what's been
input and I'll call that input and then
I have this cache that's that's given as
an as an input to the main logic and if
it's a cache contains it then retrieve
it locally otherwise which we've it
remotely and then you have these two
cases again so the retrieve locally is a
very simple workflow that just returns
that value and which we've remotely is
more complex for a workflow that firstly
prints fetching ray to the console and
then gets the rate from the internet and
then parses that rate as decimal and
then returns the pair rate and the
updated cache so what this illustrates
is that with free moniz you can
basically have conditionals right
if-else but you use the the ternary if
with question mark :
you have loops but you use recursion but
recursion with free bonus is stack safe
because the free monitor exactly
actually creates a it creates a
structure right
the free mana is just data that is then
interpreted but most importantly you can
refer to values returned from previous
instructions so I can refer to input
before that input is ever evaluated and
finally to put this all together you
need to wire up your logic to the
interpreter and interpreter remember it
was this function that we saw at the
beginning with the with the big switch
statement and main logic is the function
we just saw so we we call main logic
with initial state which is an empty
cache and then we run it with the
interpreter and you have to sort of take
my word that this really works but I
would also pass you the gate lab repo so
you can actually run it and check it out
for yourselves
so in summary pure functions have some
very desirable qualities that you should
take advantage of you want to limit your
side effects for possible and isolate
them otherwise so you want to try to
always avoid mutating arguments and
exception based logic and also try to
avoid global mutable state and you want
to separate logic from i/o and use pure
functions for logic and make your i/o as
as limited as possible and you know the
mantra of keeping your function honest
remember it's always about inputs and
outputs
if in doubt this concludes my talk so
thanks for coming yes this is the one
you need to take pictures off the top
URL is the URL for these slides which
are already online
the second URL is the repo for all the
code that you've seen so you can look at
it in your own time you can run examples
you can see that even with a million
recursive calls the free Mona's are
stack safe and finally of course a
reminder you know if you're interested
in this topic there's a great book
called functional programming in c-sharp
written by myself
and thanks for Manning who is offering
you today 50% off the purchase of the
book by using the the deal of the day
code that you can see just there at the
bottom you can see my Twitter handle and
have exactly one minute for questions
quite possibly yeah I don't know what
implementation you've used I've written
my own implementation and I haven't
profiled it but yeah check it out and
let me know any other questions all
right
thanks very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>