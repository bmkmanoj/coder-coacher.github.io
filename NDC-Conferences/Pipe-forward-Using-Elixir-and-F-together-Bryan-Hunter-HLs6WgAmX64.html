<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Pipe forward : Using Elixir and F# together - Bryan Hunter | Coder Coacher - Coaching Coders</title><meta content="Pipe forward : Using Elixir and F# together - Bryan Hunter - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Pipe forward : Using Elixir and F# together - Bryan Hunter</b></h2><h5 class="post__date">2017-02-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HLs6WgAmX64" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right well welcome to pipe forward
using a lick sir an f-sharp together my
name is Brian hunter co-founder at
graphene software we're startup we're
doing edge analytics and so what we're
we're pushing like kind of the queries
upside down so that we're querying
against mobile phones and IOT devices
from the data center instead of the
other way around and so this topic is
relevant to what I do so I'm excited
about this topic I've been thinking
about this for a long time and one of my
sort of missions and here is to get you
all excited about it too so I'll have
people to play with and so we can all do
this together so the ordinary world I'm
curious out of the folks in here what's
the normal language that using
day-to-day is it C sharp okay okay and
then F sharp okay and elixir okay
awesome awesome couple
great so the ordinary world for a lot of
folks has been and this is the ordinary
world I came from was well back in the
90s was C and Visual Basic
so these two opposite in you know one
was incredibly productive and the other
one was was fast and wouldn't just crash
on you all the time so you had to be
pretty bad to actually be more crashy
than C and that's what Visual Basic was
and so it was not reliable but it was
you could not step out really quickly
and that was that was cool
and then I started doing net development
when when in c-sharp when I came along
and that's been the path I was on up
until 2007 when I ran into Erlang and
then 2009 ran into f-sharp and then you
know is elixir came on ran into it and
so one of the things I've realized that
you hear these sort of language Wars and
that folks get really excited about and
a lot of times it's about arguing like I
like my hammer more than this hammer and
it's all about a bunch of hammers
because they all do exactly the same
thing and they're kind of
indistinguishable and so arguing about
which is better is a little silly so
it's really nice if you start saying
about your toolbox and you can have
tools that are actually quite different
to put in the box and I think that F
sharp and elixir can fit the bill here
and so here we all on our call to
adventure here so awesome elixir an
awesome F sharp this is kind of drive
off the github pages you see that have
the list of libraries awesome elixir and
awesome that sharp but it applies to
both these languages some of the things
that seeped like awesome JavaScript and
you know I you know it should be a 404
but it's you know but here we have two
languages that really are awesome
I can't spend a whole lot of time where
I'll run out of my hour talking about
the basics of elixir but if there's
something that I run across that you're
like what are you talking about I don't
have a clue what that is stop me okay
and then another thing you can do is go
here to Vimeo and I gave the talk last
June called whatever you know jest
developer needs to know about elixir but
primarily it's a really good
introduction to elixir in it you just
pick the context of node people because
I think that they're they're in need of
salvation there has need of an escape
hatch and so this talk really proud of
of the job it did on this intro to
elixir there so that would be want to
follow up on and this idea of fly
functional programming for me anyway is
based on lean manufacturing so the
Toyota Production system is really the
core of why I got into functional
programming and it's because of this
these sort of safeties that are that are
in the language the the mistakes you
can't make because of the languages and
this applies across all the functional
languages they have quite different
approaches and how they they hit this
goal but I think it was really line up
and so if you if you enjoyed this please
go out and check out this talk it's
another one I that I'm really happy with
the way it turned out alright so rather
than me give a big list of what I think
about a elixir in F sharp stack here I
think they nailed it here I mean the
community nailed it and so we've got
elixirs this dynamic functional language
design for
they scalable and maintainable
applications and I can't think of a
better sort of tag than that and the
same thing over on the F sharp side
strongly typed functional first
programming language for writing simple
code to solve complex problems so you
can see you've got you don't have two
hammers there you've got like a hammer
and a saw so if you need to take one
board and turn it into two boards you
could use a hammer to do that but it's
probably better to take a saw to do that
and so we start seeing that we've got
this differentiation here concurrency is
the top top reason to look at a lick sir
and we see all sorts of good reasons
over on the F sharp side as well that
will hop in and look at some of the
quotes on here so with a lick sir or
with F sharp there's a transition you've
got this hybrid language where it's
functional first but you can do o stuff
if you really you know if it's you can
keep the training wheels on for a while
if it's your first go on this it is
terse concise a really really tight
language where your code bases will
collapse and shrink you get your dotnet
interoperability which we're not going
to get over on the elixir side obviously
because it's a totally different VM and
the one at the bottom the support and
xamarin is really interesting this
applies to us at graphene because we
again we're targeting mobile devices and
so you don't have a lot of functional
you have some functional choices but the
obvious one is using F sharp in xamarin
to target mobile devices the the elixir
things the things that people point out
ends up being about dev joy so a lot you
know there's these things that come from
the ER lengthy em the stunning thing
this operating system Erlang VM that
gives you all sorts of things you just
can't get in other languages but a kind
of a key core bit is what was added on
elixir on top of the Erlang vm and a lot
of that has to do with developer joy and
productivity and making taking a
language that was created in 86 Erlang
and bringing it into making it really
modern and so
the the this is one of the things I want
to talk about towards the end is about
how we can sort of steal each other's
culture not just how do we make the Glen
WA jizz talk but how do we how do we
borrow the best things from the other
culture how do we take the tools that
work really well the things that can be
stolen so some things can't be some
things can be so that'll be kind of the
thread that we look at here so just to
just to start off just what functional
programming is because these are both
very functional languages not pure but
but they're you know they're not they're
not just sort of you know playing it's
not a play date it's they're really
functional languages and so a goes to B
so we see here so this would be another
way of kind of a bigger word for this
would be referential transparency but
where you have arguments come in and you
have outputs go out and that's it the
output is only dependent on the input
you're not depending on like what you
variable you set on your class
constructor or what happened to method
calls ago and you wiggle state around
inside of your class and so this makes a
same same place to be and we can we we
can get into the weeds a little bit with
with elixir but not so much we can reach
out to the outside world talk to
databases and things and of course that
is you know you can depend on things
like that so you can break you can
violate that when you're doing i/o with
F sharp you can violate it when you
touch C sharp and you touch the net you
know so that it's a this is a F sharp
there are things that are more
treacherous than f sharp than they are
and in elixir and then vice versa
really this is again a series of trades
mutability elixir it's just nailed in
you can't change things it looks like
you can and it's again a def joi thing
you there's a shadowing is basically
what you have but rebinding and but but
you don't have mutation variables aren't
being replaced and elixir it can't be
done F sharp you can do it but you have
to do the walk of shame by tagging with
mutable on
so it's it's good that it makes it hard
to mend embarrassing you know it makes
it embarrassing to mutate but we know
that this is really important as far as
building systems that can scale and you
can maintain so another bit here is code
is data we can take code and serialize
it out we can look at code we can modify
the code as it were data and then
rewrite the code and rerun that new code
and so this is a common thing in NFP and
these are you know these are big and the
languages we're talking about then data
without code so the idea of a class is
just such an abomination because you
have this again you set the table with
all your state and then everyone can
wiggle with these method calls and a few
method calls in you have no idea how you
got the current state you're in you
don't know so you have to have all these
guards and checks functional languages
we tend to have data structures and we
push those data structures a goes to B
again they come into the function and
then the some new value comes out of the
right side we transform we're not
actually modifying the thing in place
we're just coming out with a different
output on the right side and so that
ends up creating this funny thing of up
is down and and I'll describe that with
the pipeline operator and so both
languages have the pipeline and it's not
that they both Josee when he created
elixir he looked and he saw all the
great things that every other language
did and he stole them and and so one
that came from F sharp was the was the
pipe operator it actually had a little
bit different of a a symbol before but
it you know normalized on basically F
sharps because it looks great it's neat
and so there's one slight difference in
elixir of the pipe line operator
basically takes the value from the
previous function and shoves it in as
argument of the next function and F
sharp it's just the opposite it goes is
the last argument of the following
function but let's describe what we mean
here so if we have a transform and we're
wanting to say drink your Ovaltine
it's our input string and we're going to
transform this into a string that has
talked
Oh's on each side so we're going to wrap
it in tacos and we're going to uppercase
at all and we're going to put snake into
the spaces and so we could transform
that like this we could yell rap snake
space drink your Ovaltine comma taco
clothes clothes and it's kind of
horrible right you know that's that is
not a lot of stuff going on it's ugly
but this is what happens when you're not
you know grabbing variables and mutating
them in place you end up having this
sort of chaining of functions and so it
can be kind of hideous so this is where
the the pipe operator comes in in both
cases and so this becomes very readable
and clean and so it gets us out of that
nasty spot at the top so we both
communities there's just an incredible
amount of love that you see like you see
people grumbling about their tools and
languages the people in the elixir
community and an abstract community you
don't hear so much as that they're out
there just evangelizing they're out
there just you know just making everyone
else feel rotten that they're not doing
F sharp and elixir and that's that's a
good thing that's another reason to look
at both of them they're both exciting in
that way and my this is my my brother
he's actually my older brother even
though he looks he's nine years older
than me and he looks like nine years
younger than me but anyway he got me
into programming but he's sort of stuck
in this still in that C sharp land and
he hasn't been able to move around and
get out of it yet and so I kind of look
at him as is the canary of like you know
where are things you know what's the
environment like and so he was asking
about this talk and he you know have a
few questions from family here he's like
which language you'd use for each tear
and that just sort of tells you he's in
the context he's coming from it's like
this sort of regimen standard you know
tiered architecture kind of view and so
we'll talk about that but we can kind of
pick the pieces and kind of glue them
together wherever we will be gluing them
in different directions and you know
what we can do to talk to the databases
and so these are again we need to be
able to do this from every
component if we need to because
databases is just like any other kind of
i/o so you hear these questions and
there's always this concern of like can
I move forward into this you know you
can see that hesitation like will I be
able to actually talk to databases will
I be able to write UI so I'll be able to
do this and then you get it from the
from like at companies where you have
this sort of forbidden you can't you
know we can't use FP here where we were
a c-sharp shop or whatever and it's sort
of a toxic place and it becomes the
thing that's toxic about that I want you
to be able to try to resist that about
the polyglot of being able to use F
sharp and elixir together because it's
just a different degree of that if
you're at your shop and you're able to
use F sharp
that's brilliant here believes elixir
that's brilliant but you need to push
and be able to use the right tool for
the job and and if you don't you know
you know get out because you know the
things that is about what happens with
these communities is the best of the F
the best of the sea shark developers
become F sharp programmers the best the
best C sharp people become F sharp
people and people that were the best and
other stacks like Ruby or node move over
to a lick sir and that's a migration
we're seeing Erlang people you know they
generally say are like people I'm one of
the few or line people that became an
electric programmer but that seems to be
a migration so let's let's see who we
have to thank here so on the Left we
have Joseph's aleem and on the right
half down time and I think that they
both did a pretty pretty remarkable
things and so you have to fellow the
sort of transformation that they took
from what they built on so elixir is
built on the Erlang VM this crusty you
know language that the world depends on
but everyone but no one programs in it
there's no Erlang developers like you
know you look around and in Nashville I
was standing next to this other guy that
is a knurling programmer it's the one
pointed and said hey look it's Erlang
user group and
because that was all that was in town
you know and the whole city of Nashville
there were two of us and it was actually
correct there were only two or lane
developers and so went from that and
brought in this this thing where you
have this language is moving towards
being a top ten language it's like you
know it's going to be one of the
mainstream languages for the next 15
years in the same way that you could say
that Ruby or that VB was the Ruby of the
90s and you could basically say that
elixir is the Ruby of the next 15 years
and in this way it's like this very
productive place where a lot of people
move and so that's happening right now
and that was built on top of this crusty
kind of land from the dawn sign side
you've got think about Microsoft when
when F sharp came about you've got this
this environment where it was the most
depressing thing ever I'd been a
Microsoft developer my whole life and
everyone was fleeing they were jumping
out and I was starting to hate
programming you know and and in the
middle of this dark dark time when it's
like the company's lost they're going to
go they're going to go out of business
Don Syme is off doing this brilliant
work and and he's got something that I
think is one of the things that the
company should be the most proud of that
they've done it's not but it should be
they should be more proud of it and then
anything else they have running but so
but why together so there was a
conversation on this is in 2010 on in
foq there's an interview actually there
was also Scala in there but I went ahead
and sort of removed it because we don't
want talk about Scala today where
they're talking is just an interview and
the conversation about Interop kept
coming up over and over and it was sort
of like this demon-haunted kind of part
of the interview you know how they were
both you know everyone was focused on
this but this is in 2010 it was a I was
also this is the first time I was in the
middle of a larger length project I
picked up the language 2007 and be
played with it more or less for three
years but I was on a big project as a
bank income banking project
lots of transactions and they were
needing help scaling their c-sharp and
so I saw this at the time and it really
rang and and that's actually why I guess
this talk got created you know you know
seven years later and six years later
but in it Jones says you know how should
we talk to each other let's agree on how
we talk to each other and it's funny
because to have a language it's not it's
not automatic and it's not easy and it's
not as the obvious ways are it feels
awkward really the interoffice was
between Erlang and c-sharp was always
awkward back in those days and I have to
say it's about the same now which is
weird because Erlang connects everything
so at Ericsson you have this language is
built for fault tolerance concurrency
and distribution and now you over half
of the world's mobile traffic goes
through Erlang so everything is
connected I mean right now if I'm I send
an email to to Thomas back there it's
going through Erlang if I took if I call
home it's going through Erlang
everything is you know going through
this language so obviously it connects
well but why don't we see it connecting
with the.net ecosystem and I think it
has more to do with cultural heritage
then than other things and so we'll talk
about that a bit just don't think we
figured out how to make come on it's
connect so in this conversation if you
look this up it's interesting because
Don he's thinking well they do connect
you know we use these industry standards
to connect and Joe was actually wanting
something a little bit deeper and he's
wanting this idea of being able to pass
lambdas across from one side to the
other and be able to like s-expressions
he's talking about and basically having
you know we've got your abstract syntax
trees near passing back and forth and
he's wanting to have this sort of
protocol level of having languages that
are good languages that play by certain
rules to be able to to do more
interesting things than XML you know and
so so let's go into our special world
here so we've got different VMs
type systems concurrency models
different cultural heritage now this we
saw this will start coming up with that
answer of like which one do you take for
what kind of problem and so these are
based off of this top level thing of the
static and dynamic thick F sharp is
really good when you're dealing with
complex things like you've got a domain
object you've got business rules you've
got like these like watchmaking kind of
complex things and elixir really is good
if the problem isn't so much about the
thing but it's about the orchestration
of all the things if you have millions
of things that are interacting and
different timelines and all that I don't
know of a better place to be than on
elixir for that sort of problem and so F
sharp focused on raw throughput and
performance on the elixir side about low
latency about having deterministic
scheduling we have correctness on day
one as an F sharp goal so when you
compile the static type system it's it's
most valuable the minute the compile is
finished and every minute you get away
from compilation time the static type
system is not really helping you off in
the future so much and eventually you
end up having sort of like code rot
kinds of problems or DLL hell I think
you think you know the DLL that's been
it's checked into the source control
it's been there for 10 years and you
don't have the source to build it and
how are you ever going to be able to use
this thing again and that kind of
problem that probably everyone has been
in and that's what you have would you
can have with static tight systems on
this other side we can do hot code
loading we can have a system running
even if we release with bugs
we have supervision trees if something
dies you can restart it bring it back up
and and if it dies again because there's
truly a bug that one part of the system
fails even though the rest of the system
runs so you could have a system that
part of it is crashed but at the end of
the year you've had close to a hundred
sent up time but
a majority the system ran and just had a
part of it that failed in the developers
fix the bug you HOT code loading to that
one part bring it back up and it you
know and you're running without bringing
the rest the system down which is
powerful
then this cultural heritage so with
Microsoft you've moved from this sort of
crusty enterprise company and f-sharp
has a sort of stem mindset like the
science technology engineering and math
or even maybe even steam like the
science technology engineering art and
math because there's this real creative
side this nerdy creative thing that
happens on that sharp side and this
culture is really important as far as
how we use these things together as well
on the elixir side you had Krusty
engineers at Ericsson that yield and
turn this is like the sort of Ruby dev
joy you know hug each other you know
functional programmers which is kind of
an interesting thing so it's about using
together in the shared ecosystem so we
we don't like this options top left we
don't like just being just c-sharp and
we also have this option next to of F
sharp or elixir and you know that's
that's not so bad
you know you get to pick one of those
that's not bad and that's where a lot of
us are but you know if we look to the
third box about the F sharp and it looks
for both in the same company that's
that's a bit better we get into
interesting territory down here on when
we're over here on our F sharp touching
right against the liquors this we're
going to be doing like Interop and we're
going to be sending messages back and
forth we're going to be driving one from
the other and then this box in the
middle is kind of what joe is talking
about it's like where we were where we
can make the things hook up a little bit
better in an elegant way now if that
goes too far you there's some sort of
weird cell division thing that goes over
here and this thing at the right and it
can get really creepy you know we can
have this kind of unholy thing that
happens whenever two things are kind of
closer than they should be and and so we
we don't want that right we want to be
in this place like one of those the
middle for right the three
the really the the bottom two on the
left here are good spot so we're going
to insert just a bit of current events
we had our Trump Putin thing but we've
got a little bit more current events
here so there's a blog post that is kind
of raged on Twitter for the last week or
so and so uncle bob has this post about
the dark path and we look over and we
have this fellow philip Wadler that is
all about types and Uncle Bob's over
here all about tests and Uncle Bob is
all upset about how house he was talking
about two languages really and so so
swift is one of the ones who's talking
about and he was banging on it because
it was forcing him to be correct instead
of him having discipline himself and so
you have Wadler over here with
propositions of types so this is the
thing to Google here there's a brilliant
talk that he gave it Strange Loop called
propositions types and it will if you've
ever sort of felt like I don't really
know what all these people are talking
about about type systems this is the
talk to ground you it's actually
stunning and over here he's basically
saying if you if you don't write tests
and if you count on your tools to
protect you from problems and just you
know quit your job you know is the the
sort of the take in there and actually
that line was in there you need to quit
your job and quit being a programmer and
a lot of people this is the part that
people were really disgusted by so we
bringing up another character in here
you got John Hughes I am dinner of click
check
and so it's a quick check in a talk that
John Hughes gave at NDC Oslo a couple
years ago called testing your car with
Erlang he's talking about quick check
and he one of the statements in there
was like if you're writing unit tests
your human your writing unit tests
you're really wasting your time
which is completely opposed on this side
over here and so it's interesting how
these people that are really smart and
have all helped a lot of people and
you've got such a disagreement here and
we'll add one more of the mix of Edwin
Brady here and so it brings like one
more dimension of the conversation about
what dependent types behavior can be
specified precisely in the type and this
is one of the things that Uncle Bob was
complaining about about type systems is
that you know they couldn't replace test
well in this case with Idris you sort of
have the type system replacing the need
for tests in certain cases you so with
the Society of dependent types if you're
not familiar is you can so you could
have a type checker check and most
languages and say oh this list or this
function it's going to take two lists
and we can guarantees it's a list or
both full of ents so that's good well
what if your code needs both those lists
to be the same length well that's kind
of weird right you're going to have to
write a test for that you're going to
see some like well it would depend on
type so you can have that cooked in to
the type signature basically where the
guard that basically keeps that from
having you can get a compilation if
you'd if the list weren't the same links
and so that's it's kind of kind of
stunning what's going on there so you
have this sort of union of all these
different ideas in these different ways
of looking at this problem tests and
types which is of course the big gap
between elixir and f-sharp and it's in
DC conferences it's really been a treat
to have this mix of elixir developers
and an early developers on along with
f-sharp and Haskell people because this
is the conversation about types or tests
this is one of the places where as
you're using these in a shop culturally
will be the biggest sort of thing and of
course to be fair Uncle Bob is
functional programmer as well he's a
closure programmer and so he's over
using this dynamic language on the JVM
so and we're back to that conversation
about the you know do we want a bunch of
hammers the one thing I would say is the
powerful part about functional
programming is is about the do not
require constant diligence when our
tools you know when they require that
we'd put this in a rotten spot and the
tool vendors should be ashamed and this
is the case Uncle Bob is just wrong in
the post because the tool should protect
you from everything a tool can protect
you from you know they don't need to gum
you up and it's maybe they did a poor
implementation of it just need to be a
better language but the problem wasn't
that it protected you from making
mistakes it was it was written it was
executed poorly in a language design so
I think that would be the thing to beat
instead of all right make them work
together so protocols interrupts and
gaps we're going to poke around and look
at so we've got our three four different
kinds of adapters here the one on the
ride is not safe obviously because it
doesn't have a ground we're not safe so
Alan Kay absolutely brilliant everything
he's ever said you can just listen to
over and over but he basically wagging
his finger at what happened with oo and
you know it's like you got it wrong you
know the idea was about messaging it
wasn't about objects it was about
messaging and model of so the biological
cells was the model he had in mind and
the part between is what he thought was
interesting the key is making great and
global systems is much more to design
how its modules communicate rather than
what their internal properties and
behavior should be and so he's saying
this is actually the primary bit of
importance where it always becomes sort
of the afterthought in languages and so
it's a place for us to I think to maybe
level up our tools
and we've got a good playground here
with elixir and a sharp to try to do
that so what is it when we stitch things
together so we've got an app and an app
so this could be you know licks or an
f-sharp so there's the hedgehog
hexagonal architecture idea of the ports
where you can have things coming out but
got that stuck on there but you can
think of the area where we're going to
talk to the outside world in our
application you can think of it in DD
terms VDD terms it's like the boundary
context are there any corruption layers
or however you want to think about that
interface to the world and you want to
be able to play
idiomatic inside of that and you want to
be able to play in some sort of you're
not necessarily worried about the idioms
inside of that box but you don't want to
deal inside of that box you want the box
to be written written once and therefore
you and handle the mapping back and
forth that mapping is going to you know
you're going to have your pipe going
between the two objects and unless
you're talking about you know net-net
you're going to have some serialization
involved or even if you have dotnet and
dotnet but you maybe you're worried
about like versioning of types and you
don't want to have binary compatibility
between things so you're going to have
this serialization up and down and if we
have network involved you've got all
sorts of crazy in there that we're going
to have to deal with we're going to have
to think about like all of the weirdness
that could happen and what failure means
on that wire alright so let's hop into
some demos now so I'm going to show one
here these just take different
approaches we're going to look at
different demos that are just looking at
the problem from from different sides
okay so I've put together this thing
called f-sharp X and so it's using
it's using idea of early imports to do
what it's going to do here and so if you
were curious about the mechanism this is
it so let's go back in here so here
we're going to say we're going to spawn
one of these a process up so we're in a
lick sir the elixir shell here and I'm
going to store off this process ID
that's going to come back to this thing
okay and from there I can start doing
interesting things I can say enough I
can say so that's in my first argument
here
okay so our result came back from
f-sharp over here so we're in the middle
of our elixir repple and we made mass
happen over on F sharp which is nice you
know and it's just kind of nice right in
the middle of the repple to be able to
do to do things like this and so I'll
pull a few it's off the clipboard so you
don't have to watch me type and so our
line port is just mapping up so we
basically just have an instance of
f-sharp interactive on Mac or FSI if
you're on Windows and we're just using
ports talk back and forth between the
two and so there's nothing really crazy
about that and is you know in one way it
seems a little hokey but the
implementation here is possibly a little
hokey but the idea is pretty powerful
because I we're going to do a lot of
times and this ties in with systems that
I've built where I am doing Interop
between the two a common thing is I have
Erlang or elixir as a supervisor it's
I'm distributing work I've got a series
of nodes different servers out there
they're spun up running they're all have
our line nodes running on them they're
communicating however they're handling
the communication because Erlang is
amazing at routing and that distributed
bits and handling lots of things okay
it's not necessarily great at some of
the computation the libraries aren't
there to do graphic bits or video bits
or whatever and so let's have you shell
off and do things this is a really nice
way of doing this there's one part
that's missing and that's that we're
coming back with strings here off of our
print but but just not to you know beat
it too much but uh yeah so I think
that's kind of neat
and we can do ooh ah
run away here
and so we opened up a window into to
something else and that's that we can
start to tie into infrastructure
and so we just tied in here and we're
going to pull back from f-sharp type
provider and we're calling that from the
elixir side now this is a this is kind
of the the prototype of this component
this f-sharp X the thing what we need to
do next with it is we need to return
types and we need to be dealing with
where we can send types that go through
a mapping and we get types back and at
that point we've actually got something
you know we've got something that's not
a bad story really because you're if
you're talking about or constriction on
the same machine and you're going to use
Erlang to distribute across a cluster
and in you're basically doing worker
back and forth that's you know that's
what we need right there and that's what
we got all right so that's that's one
take on this problem let's see let's
look at another another angle of that
and
and this is really just our same problem
but in Reverse so we're again just this
instead of using an early import
obviously because early imports aren't a
thing on the side we're we're using
process and so we've got this kind of
ugly code up here but this is the sort
of thing you'd want to wrap up and again
become the template for how we we
marshal our bits back and how we're
going to you know or do our good work
yeah could I just do oh yeah
okay so here we are inside of FSI and we
have this text going back about the
Interactive's elixir shell which is kind
of nutty so there's one thing that
tooling wise already that we're seeing
it's much easier over on the F sharp
side of tooling of being able to send
commands I had that awkward copy/paste
thing that I was having to do there F
sharp has had this thing from the
beginning of being able to whatever set
of tools to be able to send it
interactive this is the thing that
elixir needs to steal so this is the
kind of this is a kind of space it's not
like we need the nut that goes on this
bolt kind of thing it's like we're in
this experience of working with these
tools together how can we borrow
tackling borrow so we sorted illusive
numbers so this is a pretty interesting
thing so over on the this is another
thing that's be stolen so I just said if
you saw the line but I told it to H
anoon just a help
it's what I'm saying I'm saying give me
the help for the ANU module and so we
get this nice in repple documentation
back about a noon this provides a set of
algorithms that enumerate over numerals
according to the normal protocol gives
examples of usage and so on that needs
to be stolen this needs to be inside of
F sharp we need to be able to find a
sharp interactive to be able to get help
on any of the things that we're working
with needs to be there
okay so that's enough of that one if
anyone has any questions about things
don't let me run past if something is
not clear what we're actually doing okay
let's look at let's go to do some rest
because this is one of Don's answers to
Joe as far as like how you should
communicate and so you mentioned rest in
that talk and so I went ahead and not
together a little bit of a I think here
for us too of all right
okay and so we're going to do here is
we're going to spin off a Phoenix
application so if you don't learn more
about Phoenix than sunny is right there
the fellow with the beard and he'll be
talking about the Phoenix framework is
actually one of the core contributors
the Phoenix framework which is elixirs
web framework
all right so we have our our Phoenix
application running serving up
rest goodies and so let's talk to that
from f-sharp why don't we see what this
thing has to offer
okay we're going to have some f-sharp
here we're just going to basically do
this no more rest and we're going to be
talking back and forth we're going to
get to JSON from JSON we're going to
have a function that gives us a list of
orders that goes off and requests off of
that URL that we had the year the
localhost four thousand two orders and
it's going to list our orders and we
have one's going to take an order okay
so we look at let's make so we can
actually see that code instead of hiding
at all
so so pretty standard you know just HTTP
stuff here and so there's nothing
remarkable about what we're doing here
other than we've got you know our squid
tacos from Scott and our fish tacos from
down on and Mattias is going to order
goat seven go tacos and so we've just
you know we're communicating here
between f-sharp and elixir again and
this is the way that Don would recommend
and it's we can do this in a nice tight
way and we're all good there so a big
surprise
okay this one is kind of fun so let's go
let's spin up another Phoenix server
that's over in this thing called feeble
but let's look at feeble so people were
looking at our Phoenix application here
in this code so we see that we've got
our mix exs file this comes out here at
the root level of an elixir project and
this is a Phoenix web application that
we're looking at and it has all of its
you know channels and controllers and
templates and views and all this stuff
but it has this unexpected folder in
there called fable and so fable is an
f-sharp to JavaScript transpiler and so
we can serve this right out of Phoenix
so we can do our good work inside of F
sharp here instead of having to write
god-awful JavaScript and and we can host
that up inside of our so we're looking
at hope so this application that we're
going to look at is one that's just out
on on github under fable so let's go and
look at the what that looks like okay so
we have
so we have Phoenix serving up and we
have this canvas that's being drawn by F
sharp here and here's our code for the
canvas just basically filling rectangles
you see we've got two rectangles and
what we
why don't we uncomment this one save
that and then
PDF
okay so he saved our code offer where
you added that extra one in there and
we'll just say fable right here so it's
going to compile it and then basically
poke it in the right place inside of our
Phoenix application so that we serve it
up and then we get our our nice you know
three boxes there and this is another
one in the same thing of where we're
playing Pac Man you know which is pretty
cool all right
oh it really is just serving your
JavaScript at that point yeah because
it's being kicked out but we're you know
we're all in the same project together
and we're handling to automatically
pushing it out and in all those
automatically updating and and all that
and that's handled by Phoenix but we're
kind of in we're nothing is about the
tooling this is nice so we're in ini
here or well no we're we're a night on
the F sharp side but we're in Visual
Studio code you could do the same thing
in Adam we've got the same tool here and
we're editing this f sharp code and
we're editing this elixir code and it's
pretty seamless as we're moving back and
forth so we're not far from this really
nice place I mean when I started trying
to make this Interop stuff work like
everyone in Erlang was all Emacs and so
I had to learn Emacs you know I like as
I want those that was those months back
you know and I like the amount of time I
wasted poking around in Emacs v files is
just stunning I made a new year's
resolution a couple years back where I
would not allow myself to use Emacs for
a whole year because it's burning weeks
of playing you know just tweaking and so
here you know I'm not tempted to edit
visual see the code I'm not tempted to
edit atom because it's JavaScript you
know I'm not going to touch that and so
it's a so I can get out of the business
of mucking around with the tools and but
this is all this is seamless the way
that we're useable easily together even
in the same project structure you know
we had our just stable down below it and
it played nice with Phoenix which is
really good now there's a bit of work
that needs to be done on there this is
going to require someone to do some
JavaScript work because there really
needs to be a brunch plugin that handles
fables there's one the handles elm and
so there are a lot of people using elm
inside of phoenix applications for that
very reason and so that's just a little
bit of work that someone that doesn't
mind javascript could actually do and do
really great great things for the
community since
yeah so yeah yeah that's a funny one I
mean I don't I don't know I mean it's
like you're using them both together
you're targeting the front end with with
with f-sharp you're the back end you're
serving it up with Phoenix elixir you
could have web than the channels
basically tying the front to the back
where they're the the JavaScript was
getting emitted could be talking back to
Phoenix and doing WebSockets and so you
could have the interplay happening
between the client and server but I
guess the part of the idea is that
you've got this correctness so
javascript is a terrible place to write
code you know their UI is the chair will
apply police to write code right and so
we've got this place where we've got
correctness and we're able to push this
you know able to write this thing an F
sharp in this nice language it's concise
and we can make sense of and all this we
don't have to know all the pitfalls
because it you know it won't compile and
like I you know I know that like if
every time I have my pitfalls well I
don't compile here you know that's
something you want instead of just like
you know what is I'm going to shove it
down to the pipe and it's on someone's
browser and it's going to crash you know
so I maybe it's the one where they kind
of bump up against each other it's not
it's not it's definitely not the Donald
Trump one all right let's see how close
are we okay so we're not we have some
time good good okay so let's look at
phoenix channels and this is a square so
let me describe phoenix channels sunny
we'll be talking about this summon it's
in a phoenix talk a bit later but this
is where we have our web server running
an elixir and whatever thing is
connected to it we want lots of
communication just to be like hey send
me a request and then I'll send you some
response and we'll play it that way
we're going to be two-way communications
and so it's a wraps on top of web
sockets or the implementation could be
replacing is the long polling it could
be chunked response it could be you know
whatever because there's a there's an
interface there this
protocol is defined in this way and you
can implement these in different
languages and have different strategies
and so let's let's hop in dump don't
dump
so to get our two-way communication I'll
show you a really crude
okay and let me also start up Phoenix
yep that's the truth because I've got
another Phoenix application running on
the same port so wait close that one
down
I knew I'd forget that alright so there
we are
Phoenix is up and running and so we
could talk channels to it and so let's
see what's involved in channels just did
a really basic level let's understand
kind of the protocol here okay so we're
going to use a framework here it's a
WebSocket framework this would be nice
if the whole thing was built up from the
ground just where it's just straight to
f-sharp but but what we're going to do
for now is we're going to play off of
that nougat package for WebSocket sharp
we're going to open that up okay and
we're going to have a new WebSocket
we're gonna set up a log message bit
here and we're going to open we're going
to set up some event handlers here off
of that WebSocket thing this could be of
course done 100 different ways but or
Scott blush and we'll talk about 13
different ways he's going to be saying
13 different ways of looking at a turtle
as a talk he's going to be giving and
one of the things I would love if so
each day this week we're going to have a
functional programming lab our basically
so it's assets at 3 o'clock each day I
think and it's where all the speakers
that fee track come together and they're
there for you for you know whatever
questions you have if you want to code
on things together with someone you
having just architectural eyes just
whatever the conversation wants to be
and it's really organic and free
free-flowing but we could make a stab at
if one table of people want to get
together and work on implementations
with Scott on on different ways we would
code the F sharp client for phoenix
channels but because this is obviously
not what you want to do you don't want
to come in here and use this nougat
package and say connect and then but but
anyways what this does is it gives us
our of our protocol information
so we know that we're going to be
sending and we have a ref that's going
to count up the first message to join a
channel so you can think of this model
is kind of like a chatroom kind of model
or you can look at it as like topics on
message queues that kind of thing so
we're going to join this topic and so
this code could be like I'm well I won't
get into that sidetrack that maybe
they'll come up in a minute about why
you would use Phoenix maybe with Phoenix
channels with mobile apps but let's talk
about this just what we have in front of
the Traynham okay so we sinned we have
this wrath which is just a unique ID it
can be a counter it could be grid it
could be whatever the string but we have
the event we're going to be using this
is Phoenix join it the first one we're
going to pass this topic of rooms lobby
and then payload we're going to send
this so let me go over here and open up
a browser just so we can see what this
thing is all about like why are we so
here's the GUI that was built up by
Chris McCord on this Phoenix application
that we're actually hitting right now
and so I'll say
okay
all right so a timed out is why I had to
reconnect there so let me go ahead and
after so many heartbeats is not doing
anything if we don't respond it'll go
ahead and say you're out here so I send
my joint and you can see immediately I'm
getting information back I'm getting
this payload it's got a okay response
from my join and I get a ping coming
back from server from basically from
from Phoenix there okay I'm going to
send a new message to the topic my users
boo and I'm going to say howdy so let's
go over here and see see that everyone
saw us and sure enough we see that
they're say okay we are over here with
our two-way push that happened there
which is pretty neat other than its
console output let parts not exactly
neat but I got our woo hoo and we're
going to go ahead and say you know we're
out of here okay so we hop out okay so
that's you know that that functions and
that gives us an idea of the raw view of
this it's not it's not look not what we
want this is not having our tools
protecting from from what we're dealing
there we got strings and we got quotes
and all this horrible stuff so we could
implement this thing about the 13 ways
of looking at a turtle posts bye bye
Scott
and you know he has this o is
object-oriented view of things and so we
could have Phoenix model the type of
channel and we we have these make
messages and so on we could also go off
and you know start thinking about types
on this thing we could have our socket
commands and our channel events and all
this and so we could build up and have a
mailbox processor handling and this is
the way that feels most natural to me
for this but
but anyway this is I think probably the
path to build on all right all right
and we're getting kind of close early
about 5:00 okay so we could look at a
RabbitMQ demo but but all I'm doing is
just proving that rabbit works so I'll
have the code up on github and so anyone
can play around with rabbit there so
let's jump back into into what we're
we're doing here I have in the code
you'll also see this thing called the
elixir circus and it's basically showing
you a lot of kind of cool neat things
that are built into akshay one sorry I
want to show you something inside the
elixir circus
so here it's a fizzbuzz implementation
so this is Baz and we see our
implementation down here we see pattern
matching which will look similar to
something you might see an f-sharp just
kind of a different syntax for it but
this is a cool bit is this demo is less
about fizzbuzz and more about what we're
seeing here so in the middle of our
documentation see we have two examples
and those two examples are doc tests so
what do I mean by that and so CD circus
so if I say mix test so right off the
you know I just hop into the root of
this thing I say mix test and I see that
I have two tests and one failure and one
of them is failing saying says let's
play ten to sixteen failed where it
expected a fizzbuzz there but it got a
fizz instead and that is here now that
is that test that actually ran is right
here in the documentation f-sharp needs
to steal this we need dot tests we need
documentation in the repple we need we
need to pull these things over to have
sharps it's just a brilliant thing
course they sold this from Python it's
what josÃ©e included I believe but it's
a lot more relevant sort of a functional
language because doc tests are basically
testing things that don't have side
effects really because otherwise you
don't have teardown and setup inside of
a doc right so this is going to be much
more relevant to us as functional
programmers than it ever was where it
came from and so f-sharp needs this okay
so that was the main thing I want to
show you in the circus there are bunch
of the cool things but but you can see a
lot of those inside of the elixir talks
that I've pointed at the beginning of
the session so I'll jump back in here
and we're close to our wrap-up time okay
to create front ends so
this is not good right we don't we don't
enjoy this as you know after we've been
down the past we don't want to go back
in and work in JavaScript and so we have
this good story on fable there same
thing on mobile apps mobile apps are
really it's horrible I mean the work is
just really crap and so if you're able
to come in and so we have a haiku here
mobile code is hell right as little as
you can have sharp for the wind and so
this is I think the most compelling
thing about xamarin is that they support
f sharp and they brag about it the thing
I would love is everyone put Microsoft's
feet to the fire and say you need to
invest a lot more in your f sharp story
because that is the reason you're
relevant like the reason that we are
using xamarin for what we do instead of
Swift or going down isn't because of the
cross platform we used because it's
functional programming because we can
use F sharp to target mobile devices you
know it's not about I don't want to have
to write two screens sort of thing and
that's the zamars story but the F sharp
story is I think a much bigger a bigger
win so because you get this place where
it's just a horrible place to write code
maintain code once you've deployed code
that has bugs in it you're screwed
because you have the Apple review
process it's like a week long and you've
released this bug and all your customers
hate you and they move on to something
else and they never look at your app
again well you want to get it right at
compile time and that's the thing that f
sharp can help you with and once you've
built this concise correct code so
there's not a whole lot of code on the
device that you're having to deal with
and it's correct
you can have your gazillion users and
you can then have it talking Phenix
channels back to the back what we're
doing is actually a bit different than
channels but but I think channels is
actually the go forward way this is what
needs the story needs to be developed I
think but we're using a little bit
different imitation of what we're doing
but we'll probably migrate to channels
all right so let's think about what
can't be ported basically things in the
Erlang VM can't be
okay and so we're about to wrap up the
erling vm is an operating system you
can't steal parts from the operating
system and bring and f-sharp so those we
just have to leave and we have to use
them as they are there's an attempt at
this with akka and so akka just blind
you know just straight out says yeah we
basically are stealing ideas from from
Erlang and that's what akka is all about
and and it is a way of actually
smoothing the experience is you're
moving back and forth just having your
head being less yanked if you're going
between elixir an f-sharp so you could
use akka net with f-sharp and there's
actually a naka tot going on right now
so you might want to watch that after
the conference in the video but that's
that's one way of where as the idea was
ported over but you know you can't
really steal all the good stuff that was
implementing the VM there how do we get
these dev joy bits like the dot test and
all that you know we're thinking about
some of the things about how we get
types coming back off of that f-sharp X
and the eval
we have f-sharp compiler services and we
have a looks and metaprogramming those
are the places for us to dig in and do
our community work so so we have a
different view than we came in here with
we probably had the view of just the
fire-breathing now in fact nice
bratwurst to go along with it so we can
start thinking about how these problems
tie in with just everything that you
think about like in your architectural
decisions now we can start plugging in
like how would that work if so we've got
another lens to see the problem with now
whichever community came in from we've
got a new lens not to look so a bit
sourcing how would that work if you had
f-sharp consumers but you know how would
it all play full-on CQRS like which
components could you break out which
ones would make more sense this is where
these ideas of decouples what
architectures are just beautiful because
we get to do this work
whereon become better the tooling
lessons call to action so here are the
things you know this is what we all need
to go off and build be beautiful to have
type-checking
and elixir
and just basically call off to f-sharp
and have it create a like a model of
your code that you're passing it in
touch check that could be that could be
done it's a basically compile step that
called off to f-sharp pretty cool the
ideas type providers to pull those back
into a lick sir would I would really
appreciate that and you know these are
things I'll be working on but you know
ideally we'll have the whole community
kind of poking around this dot test for
f-sharp needs to happen this is one that
Robert birding one of the inventors of
Erlang we've got him sort of interested
in this and this is idea of a porting F
sharp to the Erlang PM in the same way
that you could look at is elixir being a
port of maybe a ruby sort of thing but
here we have if we have the statically
typed language targeting Erlang TM
that's a pretty interesting thing
because there's not one right now and
there's kind of reason that there's not
one but it's a nursing project types
coming out of F sharp X thing we're
looking at make this thing solid the
phoenix channels and now with the spot
of this is where you all need to be this
week because this is this is where the
fun is
so in this today we'll be in room for
all day sony's coming up the adventures
coming up scott blush of the day the
workshops will be off in a workshop room
you can ask for directions there but
this is the lineup and so i hope to see
you all in FP track this week because
there's just absolutely brilliant stuff
catch me on twitter and both on your way
out and next up is dave Fancher and he's
giving the human version of this book
right here and so he's he's back there
and he's going to give a 60-minute human
talk version of that and so is there any
question if does anyone have any
questions or we ready to go ahead and
just break for lunch because everyone's
probably pretty hungry after all that
talk of tacos
all right well thank you much
Oh was there one no okay all right thank
you much appreciated</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>