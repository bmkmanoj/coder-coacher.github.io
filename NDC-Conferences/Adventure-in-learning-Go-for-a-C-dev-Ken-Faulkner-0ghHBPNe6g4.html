<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Adventure in learning Go for a C# dev! - Ken Faulkner | Coder Coacher - Coaching Coders</title><meta content="Adventure in learning Go for a C# dev! - Ken Faulkner - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Adventure in learning Go for a C# dev! - Ken Faulkner</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0ghHBPNe6g4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi welcome to adventure and learning go
for c-sharp dev my name is Ken Faulkner
and for last 10 years or so I've been a
predominantly a c-sharp developer but
I've lost 2 years I've been doing more
and more go I just like to share some of
what of what I've discovered in my
journey
these are personal observations only I'm
not going to be stating this is how you
should definitely do it and go this is
something you should never do and go
this is just one person having a plane
getting fairly decent at it so I'm
assuming everyone's a dev so pologize
for the speed of all this first off the
basics it is native it produces native
binaries there's no more MSI oh there's
no java byte or anything like that
everything's pure native wide OS support
so you've got a bunch of official ports
and then you've got various community
one so chances are if you want to run go
somewhere your platform will be
supported simple syntax now as much as
I'd love to use the right tool for the
right job language wise I'm getting the
stage where I can only remember maybe
two syntaxes in my head with any level
of decency
gos syntax is just really simple it's
got more chances sticking in my head
which is definitely benefited it
produces a single binary so if I was to
write a command line tool in c-sharp for
example chances are I'd end up with an
executable a bunch of DLL sort of pulled
in from you get and they'll also have
other dairy levels that I'm assuming
just so in the case of Windows the
assuming that the OS is providing in the
case of go you get a single executable
so you know if you've copied that one
faster you do an ex-cop in one part
you've got everything you need
it's not a case of did I copy everything
am I missing anything not everything is
there obviously there's a trade-off
hello world in go can be quite large so
it really is a case of just what you'd
prefer and I have to say being able to
copy one file and just know I've got
everything very beneficial personal
opinion it's best used for systems
development so if you're doing it
writing an API or you're writing a
website using a framework behind the
scenes obviously or you're writing
command-line tools this is where it
really excels
you could in theory I suppose white a UI
application and go I've heard of people
messing around with it trying it but I'm
not aware of any that are sort of is go
for the UI maybe it exists maybe not
this one's a bit flame Beatty
it's traded trendy for practicality now
I copper Beus from a couple of friends
goes ignored the last twenty or thirty
years of language development theory so
it doesn't have this new feature that
new feature like whatever um yeah that's
that's that's true but it is simple it
is really practical and so that was a
very conscious decision and so for me
personally being able to have these
simple building blocks to work to build
my software with maybe there's a bit
more boilerplate but it's just for me
extremely productive so yes doesn't have
the latest and greatest hello world of
our identically right the words hello
world there if you don't know syntax but
you do know see ish languages this
should make sense so package main
everything's in a package ignore that
for now import we import something
called FMT so we're using so using some
library I've got a function called main
it's my entry point a cooperative
there's my string it sort of it should
be fairly obvious what it's doing I'd
like to go through the good the bad the
ugly with the language so I worry
touching this small syntax awesome for
my brain at least great concurrency
model now if you've any vaguely heard of
go Chan societies due to the concurrency
model which is called go-go routines if
nothing else from this talk go away in
if you're interested in go good go and
Google go routines it's just worth it
but I'll touch on this in a second
interfaces now we all hopefully know how
c-sharp use interfaces we go it is
different and it's really powerful you
define your interface so this is my
interface here's my method signature
method signature and so on I've got a
concrete implementation this concrete
implementation is said to implement this
interface as long as the signatures
match you haven't actually said I'm
specifically implementing this as long
as it matches it's good which means that
wherever this interfaces reference
throughout the code you can drop in this
concrete class it might seem like a lot
but it's really beneficial when you want
to start extending other classes while
the Struck's very very useful
garbage collection sort of no-brainer
these days okay runtime performance with
the stuff that I've done again personal
observations only I've written C sharp
tools and put either port of them to go
always like not okay let's just rewrite
it and go
the go tour for me the go ones are
always from a CPU point of view
absolutely better sort of using it using
less resources and so on but the real
differentiator is memory usage so my
c-sharp version of a tool that I'm
writing might take two or three hundred
working set memory the go version you
might use 3040 Meg
it's a really big difference you know
maybe I am crap at c-sharp
but I'm a go programming god I don't
know I don't think it's but just
everything that I've written that the go
one is definitely using less memory and
CPU is definitely better
going back to go routines think of them
as c-sharp tasks with hues fair into
task communication so you've got your
main execution thread you launch a go
routine and there is a cue it's called a
channel you put a this will put
something on the channel this process is
that this might also have another
channel just return the result a here's
the results so that's how it works you
can have hundreds of thousands of these
things without any problem I've heard of
people going sort of upwards of a
million just they use very little memory
in comparison so that's how you can get
away with so many of them just because
you can doesn't mean you should please
pull please reuse your go routines if
you can just don't go no don't go nuts
but at the same time if you want to
start or every request every request
that comes into my server put on a go
routine as long as it makes sense what
you're doing and you're not just going
nuts yeah it can handle it it's very
very useful think of green threads ish
but done right in my opinion here's the
super quick example I've got a function
main it goes off and does do
a complex calc after that it goes off
and does more other complex work then we
finish then it dawns me oh they do super
complex hell should already know there's
something else I could actually do that
concurrently to the other complex work
that's later on how do i execute that
concurrently in go to make something you
go team literally put go in front of the
the call so having actually had to
modify the function and just modifying
how you call it now we see sharp-eyed
start breaking out the tasks the async
awaits and so on you could absolutely do
it but the thing I want to emphasize
here is how simple it is and go to be
able to do this so you might have heard
of the phrase async all the way down
you're not necessarily going to have
that problem in go okay that was the
good
that's the perceived as bad there are no
generics so if you have a list of it's a
list of short you want to write a
sorting routine okay maybe you've got to
write two versions of it you can
actually get away with that by using
interfaces but generics as we know and
love them in c-sharp nope
don't exist that initially wasn't what
the hell were they thinking but to be
honest now after a couple of years it's
not an issue at all but when you first
get into it it's like well I think this
is the one that impacts me knowing you
get we are so spoiled
in visual studio to be able to do you
know right-hand click bah-bah-bah here
we go got Jason but Annette in go
everything is reversed for this
everything is referred to by source so
before when the other one where I had
him fmt I was referencing that library
in there I could actually put github
coms flash as well as slash as their SDK
to go that is how you pull that in you
can handle versioning as in making sure
I've got a specific version but it's not
near near as nice as just you get click
click bang it's there I so hope they
figure out how to get something similar
there is no link link is a memory peek
it is a CPU hog but god is useful just
being our butter sauce oh okay let me
filter this list by name and in salt
wire age in go no there's a lot more
work to do
the cliche truly I think it's safe to
say that most co-developers a UNIX based
and the UNIX guys of quite frankly more
comfortable with the command line a lot
of the real good go tools are commando
based so if you're going to get into it
you're going to have to get used to the
pain line editors and IDs the list of
supported editors definitely growing but
sometimes it's a hidden miss sometimes
like I use this code a lot sometimes
you'll be wanting the intellisense
experience and you're waiting for it to
have your function of here or something
like that
yeah sometimes you'll be answered all
the time to be yeah waiting open up
process explorer you've got twenty
instances of go processing something in
the background trying to figure out what
does he want next it's improving but the
tooling isn't really isn't perfect there
are no exceptions so in this case I'm
calling do something I return an error I
have to check whether doesn't equal nil
think of nihlus null so if it's if it's
not nil oh got an error let's go from
processor otherwise continue on a merry
way again it sort of is what what are
they thinking it's good me to think more
about my error structures and it's a bit
more boilerplate it's sort of some more
ifs but it's really not the end of the
world object-oriented according to the
golang faq but the answer is yes and no
it is they're not sure there are no
classes there are only struts that means
there are no there's no inheritance
everything is via composition so you can
have this struct and you can sort of
embed this struct embed that struct that
there is just no object-oriented as as
we think of it and to be honest in
c-sharp over the last few years
we're doing less and less like okay
maybe a little bit of a heritage but not
like I did ten years ago so it doesn't
impact me too much I think we shall
think of methods as c-sharp extension
methods so everything is having an
instance passed into it so here's an
example
either struct called calculator and I
have a total which is an INT of two
methods
add to total which takes an int but I'll
have that C star calculator that's the
instance that's getting Auto
automatically passed through so in this
case I get that C total I add X Jordan
same with the display total I'm just
referring to the C version there again
conceptually if you just think of
extension methods you're fine over all
thought bringing episode were brilliant
for tools being able to get become
really productive in this it took about
a couple of weeks to really start
cranking out some really decent code and
really performant code very helpful
community not just the go people
themselves but most of my work is to do
with Azure and the community they're
just really really helpful there but
it's missing some nice-to-haves you get
and link a mighty big bug there's Hajus
wish they'd have something anyway that's
it for me thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>