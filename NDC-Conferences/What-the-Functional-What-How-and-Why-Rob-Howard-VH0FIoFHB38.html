<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What the Functional? What, How and Why - Rob Howard | Coder Coacher - Coaching Coders</title><meta content="What the Functional? What, How and Why - Rob Howard - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What the Functional? What, How and Why - Rob Howard</b></h2><h5 class="post__date">2017-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VH0FIoFHB38" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi I'm gonna talk to you about
well today's today's topic is is what
the functional is about functional
programming and it's about the what the
why and the how my name is Rob Howard
I'm on known around the traps as Dan
cabbage as well and I sometimes scribble
on a web site the Rob Howard idea a you
there and so so far I've made a career
of mate using using the nice piece from
different programming languages I've
started with PHP and what have you
noticed patterning a ruby and eventual
ism Haskell and stuff in there so what
I'm intend to do today is to try and in
the same way that I pinch the nice bits
from various programming languages I
want to try and pinch the nice bits of a
functional programming to give ear to so
you can use it in your own code in the
only in your own languages now all the
illustrations today mostly illustrations
today well with JavaScript but pretty
much all this stuff applies to pretty
much most programming languages I mean
hell you could probably do most of this
in COBOL maybe not bash but you know if
you try really hard maybe but some so
let's talk about the talk a little bit
first
first up jargon I want to address this
first I will be using jargon I think
jagat is important and useful and I'm
but I'm gonna go out of my way though to
make sure that I introduce the jargon
and make sure I reintroduce it over and
over so you get it so it sinks in a bit
because I finally jar are giving a name
to a fuzzy concept is very useful not
only if so you can keep track of with
yourself but so you can do your in
further looking read other people's
writing as opposed to having just serve
a general idea giving it a name giving
something a name I think is powerful
this talk is about a bunch of different
tools that much like every other sort of
technique salesmen is like a bunch of
tools to help you try and make the code
less more maintainable less likely to
break etc as you heard it before so I'm
not gonna dwell too much on that I also
want to introduce this before I start
I'm gonna call this the functional
programming period but functional
programming pyramid I actually stole
this from a chap called Lucas to
Churchill and it's actually the Haskell
pyramid but we're just gonna pretend I
didn't steal it
so if we assume that
you know your level of functional
programming ability or familiarity stay
at the bottom and start some works
upwards there's sort of a level which
you start become productive using fun
using functional programming
unfortunately it's about there like so
if you've already seen some of the stuff
before you may already be past it like
fantastic unfortunately this is what
tends to get such disgust in social
media or in slack or in Twitter or
whatever and so you've got this barrage
of terminologies incredibly unfriendly
and a bunch of discussions amongst
people who really familiar with this
stuff already so something to keep in
mind but if you if you push on through I
think you're gonna get some use out of
it so this talk is a little bit like
Disneyland not in the in the sense of
you have to go through Main Street to
get anyway interesting so there's gonna
be one bit at the beginning we've got
six major sections but one bit at the
beginning that if you've seen any intro
to any FP stuff you order very seen this
and then I'll try and head off into more
interesting areas giving rationales for
things some examples etc etc so why the
hell do I care about any of this stuff
for me personally the answer is I want
to be able to look at a small piece of a
codebase and understand as much as I can
around it without having to zoom back
out to look at different areas jump back
jump back and forth etc etc to
understand a piece of code you do need
to get the context of sin and it's gonna
that's going to be required regardless
how you write it but I want to reduce
the amount of looking around you need to
do in order to understand what's going
on so I've got here's an example I'll
come back to at the very end of the talk
but it's basically a function and what
I'm looking at this I want to try and
figure out what's going on such that I
don't I I can make assumptions how about
how pieces of this code works so in this
particular case this is from something
called a blocker which is he goes and it
just goes through and connects to
Twitter and unblocks people from your
block list like when it counts to get
taken over apparently like sometimes
Dave like they block scatter loads of
people and this is a way to try and
recover it it's an interesting piece of
code I found and it's like hey
you know he's an example whatever but
moving on what is functional programming
well
functional programming is basically
existential or quality module
unimportant externalities it's also
known as moral equality which is defined
as I'm so very sorry and I'm not gonna
do that again I'm gonna come back to
what functional programming is in a tick
first we need to tackle our first bit of
jargon referential transparency yeah
it's good I really I hate all the names
for these so I've chosen this one and
I'm gonna stick with it for the room a
remainder of the talk here's an example
of a bit of code it's really simple
we've got a function called double it's
going to take an input it's presumably
gonna return something and for the
moment we're not gonna care what's going
on inside and then we're gonna use it
twice down here so referential
transparency is like a property of code
it's sort of a test you can apply to a
chunk of code so if we can make the
following refactoring if we can take the
two with one a dry upper code don't
repeat yourself if we want to only write
this once then if we make we can make
this transformation like so we pulled up
to a variable so we in doing this this
is our test and so if if this holds for
every instance of double 100 across the
entire program we and if we can make
that transformation everywhere and we
are not able to notice a change in the
behavior of the program for whatever
metric we care about in terms of the
result the computer results at the end
so stopping printer to the console or
whatever then it can be said that this
double 100 is referentially transparent
so it's all about this transformation
and we'll see how this this cause is
gonna build from this very basic player
building block so the same applies for
the arguments like let's take 100 and
this is pretty much obviously
referentially transparent but you know
we can pull that to a variable and it's
gonna be the same as if you know as if
we had made that transformation so if
double is referent
as referentially transparent for every
and everything you if dole behaves in a
referential transparent manner for every
argument you give it that is also
referentially transparent there with me
here we can say that double is pure this
is where's pure pure function thing
comes from so a sample definition here
is just returning x times two and said
to be pure and we've got a result here
and this decomposed this pulled apart
version is the same as if we'd stuck
with the original so big quote time an
expression is referentially transparent
if in a program all occurrences of that
expression here a replace with the
assignment to that expression without
observably changing the program
paraphrase from a functional programming
scholar by polio Sano and ruin our
pianist n' so all occurrences of that
that expression like that double 100
across the entire program can be
replaced by a reference to it like
saying you know using the variable
instead without being out without us
being able to tell from the outside we
don't care what's going on inside double
we only care how it behaves it's that's
where I made the joke about existential
equality like this is it you can tell
like externally observable behavior is
all we care about for this rule so yeah
it's so that again this is known as like
pure functions or purity and unfortunate
reminds me that preserving the purity of
precious bodily fluids who's seen dr.
Strangelove in you it's I hate the term
I hate referential transparency because
it's a mouthful one who's gonna say RT
now cuz it's easier but it's a concept
so onto some more examples things that
may or may not pass referential
transparency so a second one with same
function and we've got console.log
sitting in the middle here we're saying
at this console that log is impure and
we'll be able to be noticed by things
both inside and outside the program it
can be said that has a side effect on
explain immediately what that means so
we've got double and we're gonna load it
up in the record we've got this consult
log which spits stuff out to the console
in the process of getting us a return
value the the the with the console that
log doesn't have any value which
represents the printing to the console
it's something that happens off to the
side and then it return
undefined this is what we call the sort
of a side effect and then the function
also happens to return a value because
because console.log is not represented
in as a value at all it's just just
happens and you'll see that the
repercussions this has in a moment so it
has a side effect and it's impure which
unfortunately means that it makes the
thing that's inside impure as well as in
because it sort of leaks out we can tell
when you do this rearrangement so we've
do this thing
we've got printing it twice or print it
once will we make the transformation
it's not referentially transparent sorry
try again another example where we're
referring to a counter from outside the
pro from outside the function it relies
on state it relies on something external
something not in the function arguments
something that can change at any time so
if we make this transformation that what
we're talking about
suddenly the result sorry the result is
different
we've got 200 as opposed to two or one
no refrigerant referentially transparent
see why I hate the name okay so another
one for example we're also McCarron with
state we're bumping a counter so and
make a transformation and suddenly the
numbers change so it's not only just
reading the state it's also it's also
setting the state as well it's mucking
around with it either of these things
mucking around with things outside the
function he's gonna lead to you know
unrightfully transmen artie code so
another one for example we've given it a
little give n' append a list and it's
gonna added one to list and doing so
it's changed it we call it twice and we
get a list that gets and well it ends up
with an extra element on the end and so
we make our transformation and suddenly
it's different so all these things lead
to ears are impure and I'm not certain
oh so saying impure is bad it's just
giving you a give me categorizing the
code so we can then analyze it later so
this push this mutation is impure but if
we take this code if I were to take the
the variable or yeah the list we get in
and then we copy it and then we push it
and return
result it's now pure we can't tell from
the outside whether whether it's doing
mutation or frankly we don't care we
only care about the the black box and so
this is the basis of a whole bunch of
optimizations so you get a functional
pure pure interface of things that is
efficient internally because it's able
to muck around with state like immutable
jeaious which we'll see a little bit
later on for example MUX run with the
state internally to be fast but presents
a pure interface so what is functional
programming back to this way this old
chestnut the bedrock of functional
programming is referential transparency
and all this purity thing functional
programming is programming a pure
function says really I'll be honest
inand that's the last I'm gonna quote in
a quite room in this presentation as
well so we've got the concept of like
these functional languages um if
functional programming is a thesis or an
idea like this referential transparency
then functional programming languages
language is sort of fall in a spectrum
in how easy they make it to achieve this
thesis how easy it is to work with
things in a pure manner so you've got
languages a one end like a Juris and
Haskell and whatever that make it
working with pure function your values
and functions natural as in is the
easiest thing to do and you've got so
javascript which is also on this
spectrum which you know yep and then as
bash all the way all around which makes
working with pure stuff really really
hard because there's no return values
like besides numbers it's it's a weird
thing don't don't learn bash if we can
avoid it um but what does purity get us
specifically if we ignore all the
subsequent things we're gonna look at we
can if we only care about the pure
functions themselves then it gives us
this the behavior of pure function is
independent of where and when it is
evaluated
whereas app a very impure function is
intrinsically tied to its execution
order so if we take our existing code
and just expand it a little bit it's
almost like we've got so this dependency
graph the things use so if you 201 here
depends on the result being calculated
and 400 depends on this result being
calculated and in turn result depends on
100 being calculated and so on so and so
we know with a tree that kind of looks
like this and so it doesn't matter this
stuff is
separated across the other side of the
codebase or whatever or if it's classes
calling classes or whatever it's or in
if you sort of pre evaluate stuff it's
it can be a black box and it's still
going to behave in the same way because
we all care about the external behavior
as opposed to the guts of it and it
means we can the nature of these things
because we can evaluate things when we
want to we can then so for example if
you were to evaluate in parallel we can
evaluate it twice and it's the same as
evaluating once so in doing two
different threads two different two
different processes or what have you
where you can do things at the same time
and all you care about is the end result
all four tests like pure things are
really easier tests in the sense of you
can just sort of focus on a little bit
and it can't tell the difference between
you doing the entire calculation or
you're just giving it the result for the
next step in the pipeline like you see
there is like a tiny piece of the full
thing but you just sort of feed it and
pretend it all happened and then you
check the output it's not saying all
code should be pure but when it is these
sort of qualities happen so modularity
of evaluation aids a few things it aids
in refactoring because we can split
things out put it on the other side of
the codebase rearrange them within a
function so long as we've got that
dependencies the the dependency tree
intact it means we can rearrange or pre
evaluate or whatever it helps with
testing for the same way for the same
reasons we can pre evaluate stuff I can
currency in parallels and we do it twice
we do it once we do it three hundred
times we don't care composition
decomposition you just glue these things
and pull them back apart it just makes
it aids in this process so speaking in
composition let's talk about composition
or Lego bricks composition is like
you've got so Lego bricks and you've got
a few different Lego bricks for example
and a particular combination is rather
useful so you stick them together in
advance so you can then use it with
other sets later I'm gonna pre stick
together a bunch of Lego bricks so I can
use it to build bigger creations you
come up with a new piece a combination
of two other pieces and you can reach
for that kind of piece now anytime we
need it it's more efficient effective to
recognize and use this
compound sort of piece or element
separately think about accepting things
every time a composition is combining
things in a way that allows you to
further combine them and you can't
distinguish the combined thing from the
atomic one so if we've got for example
the strings a a B and C D when we
combine them together with a composition
of those is ABCD so composing to pull it
down or and then decomposing to split it
back up you lose the information as to
what the original form was but you can
split it back up into different things
give me a plus B C D or you know
whatever rearrangement you want and the
same deal with functions you can get
calling bar and giving the result of foo
is the you know it's like having a
function which does that internally you
can't tell the difference this is this
function composition and decomposition
etc etc like JavaScript a pet NPM
JavaScript dependencies the NPM version
too that's sort of naively composed he'd
like you just had trees and trees the
dependencies you sticking together and a
bunch of things compose but I really
need to kind of move on to the next
session so expressions expressions got a
quick mention in that first we're not
quite Hasmukh sorry
so I forgot a function here well this
expression sorry we've got a value which
can be things like strings and numbers
and objects and lists of whatever or
whatever or whatever and then we've got
a function here for example where it
takes arguments or whatever and where we
put we can evaluate them to equal a
result this case is for when I say
evaluator and means substituted for
example we've got our X and we
substitute week you know substitute the
x equals to do the replacement
everything fades away then we've got our
two times two and multiplication is a
function so it's got two arguments we're
going to substitute it internally
regards to the language somewhere to get
for evaluation is simplification and
surprise this is reference to
transparent this particular one
because we knew all that substitution
not notice so expressions are made up of
values and functions and I kind of
fibbed a little bit because I said
values or strings and whatever but you
know functions are also values in a
number of languages including Java
Script and also if you're interested in
going down a particularly large
rabbit-hole values values can be
represented with only functions this is
also known as lambda calculus not doing
it this talk moving on
functions are also values which gives
rise to this sort of stuff where we've
got plus we've got a function value here
or gonna sign it to a variable and then
we'll get a list which is we're going to
give this function to another function
map like so and so this map is known as
a higher-order function because it's a
function that takes a function as an
argument so when we've got all these
paint let's put some pieces together it
desire for referential transparency as
well as like the helpful feature that is
her functions as values and abstracting
a common behavior with function
composition and decomposition gives us
these things which are kind of familiar
to or it might look familiar if I phrase
them like this they're just so building
block accommodators because these aren't
necessarily inherently functional this
is kind of functional style but that's
fine it's basically this the the
building blocks settle in push us in
this direction to end up with coming up
with these little combinators these
little functional helpers that we can
glue together with first with function
values and whatever to make to make
these things and we've got you know a
bunch of other ones that are a specific
JavaScript but this stuff applies to a
whole bunch of different data types as
we might see in just a moment so we're
going to function a function here that
we've written in very muchly imperative
style which is fine and basically it's
going through all the birth years and
it's getting the ages for each one and
if their age is over 20 then we're gonna
add those together it's a bit nonsense
but you know are you going to do I get
to make up the examples cuz I'm here
right
but mr. code when given in using his
more functional style common air stuff
is birth years and then we work for each
of the birth years we're gonna map over
it we're going to map is a function that
will write it will apply this function
this birth year taking birth year as an
ayah this year - birth you thought it
that it's gonna apply that function to
every element in the array it's gonna
preserve the shape preserve the length
and that's how map is designed to work
we've got filter which will will take an
array and reduce it down in size
depending on this the work with the
evaluation of that functional we giving
it and then reduce which can go from
list to anything reduces also known as a
fold it's one of the base building
blocks if you want to you can build map
and filter in terms of reduce but that
is an entire thing in its own so I'm
sorry this codes getting getting
gradually smaller and smaller it's gonna
stop now but you know when we we've got
that because the correspondence here
we've got the the the for loop which is
showing up in terms of the map and also
the filter and also the reduce like it
is basically this is all these three
combinators have all these helpers have
them doing the loop over the array in
their own right and then you've got the
functions themselves which are doing do
it's like we're basically pulling some
pieces out of the the Sasori imperative
style stuff at the bottom to hopefully
make something that is more
understandable this is entirely a
subjective judgment I personally find
this easier to read some people may not
that's fine but yeah we serve pull bits
out to give us the result and finally
return the the top one is returning an
expression which is going to evaluate to
a single value and we've got the bottom
on which is returning the value that is
being calculated based on a bunch of
mutation anyway so hey I bet someone's
noticed that I'm looping over the thing
like three times and that's really
annoying yeah it's it and that not of
this code by itself will loop over the
array three times and it's like oh yeah
okay it's look looks a little reader
more readable to me but at the expense
of it's traversing it so there are
different ways of doing this jumping
over to Ruby
I did it for four years I got to put one
example in here come on where I've got
birth years which is an array and then
I've got this a little dot lazy thing
now the Ruby that this could very easily
happen in JavaScript I can go and write
one in a rec ball afterwards if you
really want to but it's it's part of the
Ruby standard library well we want a
lazy version or something that when were
you go and apply its versions of map and
select and what have you work in such a
way that it will apply all the functions
for a particular element as it goes
through it all in the traverse the array
once and it will apply things
it sets up some computations and then
goes bang for each element does you know
all of them one go all in one go it's
like basically building up with a bunch
of instructions to then go bang when you
actually want the real result out at the
end it's a way a transducers enclosure
is a I think a way of doing this fusion
high school it's all very much a system
or concept you're building up sort of a
lazy sort of things to apply later so
some languages are entirely expression
based I'm gonna blaze through this thing
one because I don't really want to go
into a much detail but we've got you
know main is a he's a function this is
sort of pseudo Haskell but we've got
main that's some you know a value which
is made up of a bunch of expressions we
get users with which is a function that
takes a couple of arguments or they're
hackers which is sort of effectively a
constant and so it's an expression so we
can simplify it we'll just sort of you
know pull pieces in just keep pulling
pieces reducing reducing reducing until
we're left with basically telling the
Haskell runtime in this case that we
want to print a value that is two so it
says this is not like hey he's a
practical thing you can do it's like
here's an idea of how some other
languages operate expression based vary
FP ish kind of languages can work like
this so speaking of languages language
affordances you if everyone remembers
that functional languages spectrum
chestnut I introduced earlier so this is
this is kind of like the the previous
example we had where the list of things
and the map filter and reduce so if I
were doing this only in terms of
functions and values then it would
probably end up looking like this which
is I personally find this a little more
difficult to read cause you have to go
to the map
it's like it's backwards to start with
then you do the map with the thing and
then take the result of that and give it
to the filter and then take the result
that give it to the reducing it's like
the all right got a staircase down and
then work my way up to understand what
the hell happened
so some languages have affordances have
make it easier to do certain kinds of
programming Elm lets us for example do
this just work with functions but we've
got this this pipe operator thing and
when I say operator I mean it's a
function it's a function that has a
funny name basically and so there is a
forces within elm within high school
with a bunch of languages to let us come
up with these operators to let us work
with these function pipelines more
easily we don't have that option in
JavaScript so which gives rise to and
same with Ruby in Python and PHP and
what have you and so it gives rise to
something with Gary Bernhardt calls for
Gary Byrne had calls fo o so it looks
like oh whoa but it works like FP so
food to inventor an array thing you know
you make a new my array and give you
some items and we've implemented map for
this I'm using the class syntax so just
in case you don't really know JavaScript
but you know Ruby or c-sharp you know
it's a little more familiar than dot
prototype dot but anyway so we're
constructing new one and we go to map
function and internally that's going to
go over it's going to look at sort of
the objects kind of state we set it up
and it's Co is being populated with some
state in this constructor here and then
in the map we're gonna look at that
state we're gonna iterate over it and
we're going to apply a function that way
it's been given to us because it's map
and we're gonna take the result of it
and stuffing it in a new array and then
we're gonna return a new my array with
those items it looks like oh whoa but we
feel if we use it like this we've got
this transformation that we love to do
we pull it out it's referential
transparent but it looks like oh yes
best of both worlds so we get a little
bit of a UI we sort of use take
advantage of the JavaScript saw Tobias
kind of UI to produce this kind of code
so we can get
we can make entire libraries of this
stuff like functional Combinator's and
things and that's what sanctuary
folktale and Rand are all about
basically sort of photo
kind of kind of sort of functional
helpers and values and whatever and
there's jeaious friendly in its user
interface as opposed to big compositions
of functions that are really hard to
follow what's going on so alright cool
so alright I'm gonna keep going
immutability this will be quick I wrote
a function I'm really proud of this
function I'm so proud of I called or
twice it's big list it takes about 40
seconds to run and it produces the
numbers 2 through 12 or something or 1 3
12 so because it takes ages to run I
want to you know who seen this before I
want to try and pull it up here and it
totally works the same right new new it
doesn't something went wrong so it turns
out that even numbers is a terrible
function and I should be ashamed of
myself because some you don't don't send
the details of this but somewhere in the
middle of it it's stuffing around with
you right now we saw this said earlier
in the referential transparency examples
so because it's it's stuffed around and
we've given it a list and it's like you
know it's like a you've learnt your
lawnmower to your neighbor or something
and they've gotten mowing the lawn and
they're taking out the engine giving you
back site thanks this fantastic way so
similar deal here we've given something
and it's like it's changed so let's try
and imagine a world where this doesn't
happen and we can try and achieve this
through a few different ways one is the
quality or sort of property of the codes
so if it's something is referentially
transparent then it won't be doing this
or there can be a language restriction
for example Haskell Elm reason I think
please correct me if I'm wrong we'll
basically enforce this at the language
level we'll say it will not provide a
way unless you use you know an escape
hatch somewhere will not allow you to
mutate a variable which means you can do
it go and do other things like optimize
the hell out of stuff so it seems
immutable but is actually move under the
covers as an entire rental thing or
through a PR restriction not really
providing a way to
without throwing an error or not
providing away at all so sort of unified
em you take the data so if you've got
seamless immutable JavaScript library
what it will do if you wrap it around
the list if you try and do something
that's mutating it'll throw an exception
to run time just fine and says no no no
no something went wrong here it's true
in an effort to try and catch this
sooner than later
catch this sort of error sooner than
later object or freeze is another way of
doing it except it's got limitations
where you know if you've got if you're
dealing with objects and doesn't quite
do it so you've got a couple of
different options for doing this via the
API restriction route one of them is
seamless immutable which is like
preserving all the UI for working with
lists and a bunch of other things but
there's also immutable J's which is
strange alien beast when you try and use
it but it applies you have you know maps
and sets and lists and but it's got a
very different UI and doesn't expose
away in the UI to actually change stuff
mutable it's like it's taking a
different tack it's not like I'm going
to open a door and then slap you if you
try and walk through it it's a case of
there's no door so anyway but it's also
like some people find it really
Byzantine difficult to work with so
whatever try it out works you fantastic
if it doesn't yeah so effects these
values next major section affects those
values is the idea of representing
impure actions as values that can make
them pure I start representing impure
actions impure actions as values you can
make them pure or representing impure
actions as instructions to be later
interpreted can make them pure so bear
with me because I have a silly example
and full of these we have if we have
something that so we've got the idea or
we want to represent the idea of
printing a message out to the console
we're going to function that will
construct a value which represents
printing something out and we have
something which will one of put many
potentially many sort of interpreters
that will actually will take this thing
and then do something as a result of it
this could be one thing that prints out
to the console could be another one that
could be pure and although one which
sends it over the wire to a radio
transmitter like whatever and then
finally the bottom here we're going to
make high
which is value representing the idea of
printing out a message trying to make
this less long we did so gonna squished
it up and keep going so we've got high
but there means we can make an array of
you know we can start treating this like
a value like other sort of pure values
that we already have so we can stuff in
an array and say hey this represents
printing out high four times so squish
that up and then so we can have and then
file a Terron we we can then a separate
area of the code base maybe have this
thing where we go and loop through the
messages and we evaluate the message
evaluate each each of the messages in
that list we're going to we had the
instructions and separately later we're
going to interpret them to be something
there's actually effect for something
has side effects like consult or log so
this fits pure this bits not and the two
shell on meat or whatever so they could
be right above each other they could be
other sides the code base as I'll saying
before modularity you have a lot more
flexibility in terms what we put this
thing now I'm aware that this particular
example seems really ridiculous but it
is real I use this stuff every day and
it's really nice once you get the swing
of it but it's utterly alien when you
haven't seen it before so here's another
library another example um a flu char is
an unfortunately named library that
doing Fantasyland in future funny name
it's all good whatever but it's a beta
or there's other ones like dart or TAS
but there also represent these things
that will happen in future is almost
like promises except we'll come all will
talk about promises in a tick but this
is something that is doing the fetch and
returning a future value and so you know
we can do stuff with as a result of that
we're gonna have values that use use the
earlier pieces that we defined or
whatever and I'll step through this in a
minute but we've got a pure piece here
that's all about the instructions for if
we were to do something kind of
asynchronous what would we do separately
to the we're actually going to go and do
it now so I got the again keep
separating the pure stuff from the
impure
so if we create a future here and then
we dot map map being a generic name here
as in we with the contents of the fit
with the result of the future it's all
it's a dot then for this it perhaps
should be called dot in but you know
with dot map we're going to get the
result and then we're going to pass the
HTML app using the response we've gotten
back from the URL and then separately
we've got linked pages which will use
the idea of fetching the thing for and
pay and parsing the HTML out and we're
going to use that to scrape a bunch of
stuff and do it in parallel this is all
just the idea of doing it as opposed to
an actual it's going into it like even
the dot parallel bit is still values
representing potential computation stuff
and then we're gonna fork it and we say
that you know if it throws an error if
there's an error in the in the thing
that we want to bubble up the error
otherwise we're going to take the result
and save it to the database or something
you know it's very made up but yeah it
basically we've got the means we have
flexibility like a so promises
unfortunately as soon as you can create
this stuff will its promises as soon as
you you write it down you as soon as you
execute it the horse is away and over
the hill and you're furiously like oh
wait a minute
I'm just gonna try and close this gate
it's it goes and does stuff it just you
know fires the missiles it just goes as
opposed to well or I want to do some
stuff I want to mainly muck around with
this first before I go and do the thing
and also it's got the idea of this sort
of resolved value in this case I have
got the links pages in linked HTML that
are using eventual HTML twice and it
will evaluate it twice which is either a
good thing or a bad thing depending what
you're after and if we want to catch
this and we can chuck an extra cash
wrapper around this the future provides
where the flexibility saying evaluate
this multiple times evaluate it once
with the flexibility there so for this
very specific example sorry
yep so the question was is this a
deferred execution uh it really has to
say something else a sharp
unfortunately I I use C sharp a full
link existed so I'm not the right person
but it's the idea of yet defer a
deferring the execution but it's it's
also in this case the idea of
representing something that is effective
as a value it just so happens that async
is the burning question on most years
devs like their minds including myself
and so it's a somewhat relevant example
but this as I said with a messengers
thing you know you could equally have
something that represents so the impure
stuff um
for example actually no I'll come back
to that but yeah future and data dot
task of examples of this particular
async thing but it's a very general idea
that applies to a bunch of different
contexts so now on to the potentially
controversial bit which depend on the
circles you movie could be yeah this
could be nuts and you know a bad thing
or it could just be business as usual I
depends coming from different areas I
came from a PHP background via way of
Ruby and other sorts of things some
people come from like entirely c-sharp
or Java the entire way and this is like
of course I want types you know but
we're gonna get through it regardless
probably a little quickly but we will so
I again I have this probably there's
this problem where I write code on our
write terrible code this is one example
I've got you know my utils and it's
going to reverse a string and of course
it's going to explode because undefined
is you know not a string it's also going
to exploit if I feet at seven you know
so this is going to explode
whoa I don't know if it's going to
explode
we don't really know we've got no way of
telling the only way we really have it
telling is sort of the name sort of
guess the name then go read and dig into
the code to try and figure out actually
doing to see if it lines up with what
the names saying is or what the
documentation says etc so let's look at
this string of us function itself I've
got a parameter X and given the name and
what we're doing with the function we've
dug into it it looks like it's the
string anyone calling with this number
you know a bad person they should feel
wrong you know that's what she'll feel
bad or whatever but it'd be really nice
if we could tell the computer what we
mean if we give them the computer more
information to help us and so there are
some tools that let us do things like
annotate things with you know string or
whatever and you know if you use in the
right way it'll pass if you don't it'll
explode
etc etc so I'm using flow for this
particular example but there's a few
competing ones flow and typescript and
if someone knows Google closure because
I don't I'd like to speak to you
afterwards it can be across this stuff
but um for example gonna I've got my
chunk of code example jeaious I'm gonna
check out the flow and I got no errors
yeah I'm gonna run the code and it
produces hello backwards fantastic i
Chuck a wrong value in and has a big sad
exactly as I expect great so you know
you've got strings you got you know
arrays numbers you've got their punching
holes where you've got like it Julie
like George generics or is also known
usually FP Landers parama tricity where
your jargon sorry where you basically
this function is not allowed to know
what T is you can't do reflection on T
in most languages
it varies as to whether like the
stronger the stronger the some type
systems don't let you do it
intentionally
I think c-sharp is one of the ones that
don't let you look at T Java is the one
of the ones that lets you look at it I
would love to all such out with some
c-sharp people a picture of my
assumptions are correct but basically
it's is the t's determined by the person
who's calling it by the code that's
calling it determines the type and the
function itself is not allowed to make
any assumptions at all about what T is
it can't add a number it can't add one
to every element and list or anything
like that it's not allowed to know
intentionally it's you know got blinders
on so this works and this works and you
know fantastic we can go further we can
have things that are particular object
shapes we've got this thing here that is
a way of saying you know this thing is
intentionally a string or potentially
undefined whereas usually be a string
and only string and no numbers no
undefined no no no nothing we've got
ways of saying you know a type is this
thing or this thing here in the room
uses Redux at all
yeah okay well this might look a little
more familiar sort of a redox reducer
we've got we've defined this particular
shape and I say it could be either this
this thing or can be other that thing
and so the computer will help us in this
case flow will help us check that we are
using h1 croco properly so if we go into
if we end up with a logged in thing then
before letting us into action letting us
use action dot user we need to have
chair it proven that action dot type is
logged in we need to make sure it's the
first option before we allowed to use
the guts of it otherwise if the second
branch called don't use it it's not
there like it's undefined what's going
wrong sorry oh what's going on it's it's
just basically broken whereas if we the
code here is checking flow here is
making sure that we've verified we've
proven to the compiler all the type
checker that we've we're able to get
down a certain path and this is all
decisions made by the different type
checkers it's not inherent to type
checking it's just something I've chosen
to do so back to our first example I've
got the string there but these tools to
varying extents can infer some of these
information for you such that you don't
need to write the things sometimes you
write it only on the outer edges flow
makes you annotate every external facing
module whereas it will infer inside
typescript I still trouble figure out
the inference rules sometimes it will
sometimes it won't
I gotta get better at that but anyway so
these are sort of small family tools
like flow and typescript glue the
closure as I said earlier so what's this
doing in a functional programming talk
why am I talking about types god so it
all comes down to expressions consider
language where everything is a
composable expression we saw one of
those earlier where everything including
effects because remember we can express
effects in terms of pure values things
that stand in for it for values if
things are expressed in return values it
means that we can suddenly that there
are tone values of the function describe
a lot more about how the code works
because we're it's the type system is
describing more about how the program is
put together suddenly you can rely on it
a lot more you can have it do things
like checking
something is referentially transparent
or not this is basically the idea behind
Haskell if you're ever being curious
about what the hell that thing is this
is basically it everything's pure
affects his values really strong type
system chuck it together fantastic so I
kind of jumped over my my bio at the
beginning deliberately because I want to
explain some motivation stuff here I
went through bare basic and PHP for like
a good no I did pay to be free with
seven years or something with you know
JavaScript throughout their time as
JavaScript evolved which was an
interesting process and you know and
then I had troubles with the community
in terms of making sure my stuff worked
I it's not inherently problem with PHP
but at the time the PHP community was
not very interested in anything like
testing I was really I really cared
about making sure my stuff did not break
I wanted to use the computer as much as
I can to help me with that I asked the
PHP made up like who here in the room
has used PHP unit before and I got three
hands
you know he's used to work no hands like
it's gotten a lot better at the time it
kind of it kind of sucked for that and
so I ended up moving to Ruby because of
the strong testing culture I really
wanted to make sure my stuff didn't
break and so the of course you write
tons of tests to make sure your stuff
works how you think it is was sort of
natural for that for the Ruby community
and so I really enjoyed set I really
enjoyed doing that for a while I want to
make sure my stuff didn't it make sure
my stuff didn't break and so over time
though I found myself doing uh writing a
lot a lot of tests to make assumptions
about my code it's almost like you
trying to prove a negative like you sort
of you to contests and positive cases
and some select negative cases it'll
probably break if you caught this thing
but you can't possibly test everything
because you can feed anything anything
at any point you should be writing tests
and tests and tests forever and
particularly when it comes to
refactoring I found that I'd either had
to take tiny mincing steps where I write
tons and tons of tests to do like a
larger scale refactorings or I'd
basically do the leap of faith across
the gap and write tests fail aside and
hope to god it kind of made it it was
unsatisfactory for me in that regard
I loved the rest like the the rest of
the Ruby experience but that
particularly bit really got me down to
the point where I ended up
jumping straight to haskell so this my
entire my entire experience with the guy
my motivation for this business is
entirely been about types and the
functional program but it sort of
happened as a result of that the
stronger the types strong type systems
seem to naturally lend themselves to
functional program now rust and stuff
exists with zone strong typing system
and that tight typing systems fantastic
and describes a set of behavior and the
Haskell type systems some other things
described another set of behavior and
that's fine I ended up jumping to the
Haskell side of things to get strong
types FB kind of happened and then I
started to introduce FP sorry I
appreciate FP overtime as I got more
into it as community to the point where
I'm now using something called pure
script on the front end if I was
starting in JavaScript I would this is
much later after the Haskell I would
probably starting with Elm instead as a
as a way to try and get more familiar
with this stuff and I encourage anyone
is interested in vaguely interested in
like experience who has stuff to try out
Elm it's really interesting alright I'm
going to wrap up this talk shortly with
a couple of things the competent
programmer I really like the tone in
this quote but I really like what he's
getting at the competent program is
fully aware this strictly limited sky a
size of their own skull and God do I
feel it I'm fully aware of how many
stupid mistakes I make in the process of
writing code so I want to try and reduce
the amount of things I need to think
about at once I want the computer to
help me as much as I can and I want to
reduce the amount of context that I need
to focus on a particular piece of code I
want to zoom into a piece of the code
and try to take it try and try to block
out the rest as much as is practical so
like I was loyal looking at this chunk
of code and because things have been
written in a referential transparent
manner I know that just evaluating this
won't launch the missiles it won't send
the horse bolting or whatever
immutability means that the values I
lend to other functions I'm gonna say
lens because like I please don't mock
around them I need to use that like you
know client or all details and things
they're not changing because of
immutability and again they were
filtering
referential transparency that affects
those values that are building up
preparing for something in this case
we're just returning the instructions
that are later gonna turn into something
and then type so I know what my inputs
are and so I know the word that I'm
using the rest of my application
corrected without having to go look at
it we're only going to dig into the
implementation details of these things
so further things to look into I did a
functional program talk and I didn't
want to talk about recursion because I
write Haskell as a day job and I don't
do recursion very often it's like
everything FB is recursion will
technically under the covers but I don't
really notice a great deal of the time
so occurring I didn't do that either
continuations a ways of representing
sort of stepped computation things like
things you partially evaluate if anyone
knows about generators continuations are
kind of like the functional version of
that where you want to stepwise
represent things asynchronous stuff is
very nicely mobile with continuations or
lazy trees and things it's just there
are a bunch of things that were
represented by this idea of
continuations you've got pattern
matching which is the decomposition
thing I was talking about for values and
other things it's some some it may
eventually end up in in JavaScript
there's a stage one proposal I don't
know if anyone does anyone know if it
stays zero stage one if anyone nope okay
but there's a pattern matching proposal
hope really it'll be interesting if it
gets through I hope it does things like
pass the Combinator libraries when you
want to consume and understand a sort of
particular string a different way
instead of reaching for a regex particle
many libraries are basically building up
building up their source string
processing things our little functions
instead and it's something to get into
there's a library called you lately that
eul a at the very end I'm going to I'm
gonna putting something on my blog after
this with a bunch of reference links to
as jumping off points and this is one of
if you want to dig into maybe something
that isn't a regex is like more
interesting sort of as an experiment to
learn about perhaps even using real code
it's up to you
Elm Haskell and pure script I
if your if this is all completely issue
my new to your I highly recommend Elm as
something to muck around with there's
also the Haskell book or has called
program from first principles if you
really want to deep dive because I mean
it covers some of the little bits like
you know the little depth of lambda
calculus that's useful it it's a chapter
long it's a short chapter but the idea
like learning about that helps you
understand all the bits you know sort of
more like it's an abstract way of
describing a whole bunch of things and
so it's useful to be aware of it even if
you'll never actually write some
production code that basically that I
mean you cut you don't use your lambda
calculus in production it's just a tool
to help you understand how some things
relate to each other that may not seem
to previously seem related and lastly
functional call Imperial imperative or
effectual shell is the idea that Gary
Bernhardt presented in his his talk
boundaries as basically a way of it's
saying that I'm with when we're writing
functional programs and things like Ruby
in this in this talks case equal applies
to JavaScript Python PHP LC sharp it's
it's trade-offs between making things
pure and making things effect for and
you do really want to touch the outside
world sometimes but the idea is to try
and centralize as much to have as much
the pure functional stuff doing the
business logic and really having this
sort of thin shell on the outside doing
the web handlers the cue wrappers the
effect interpreters and that sort of
stuff interacting with the outside world
there and he's the idea was eighty
percent functional is better than zero
percent you don't have to get to 99
percent it's you know it's just kind of
it's useful to try this as a trade-off
between the two different styles and see
how it works for you cool well thank you
very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>