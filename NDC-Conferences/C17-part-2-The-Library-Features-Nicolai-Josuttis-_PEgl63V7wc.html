<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C++17 part 2: The Library Features - Nicolai Josuttis | Coder Coacher - Coaching Coders</title><meta content="C++17 part 2: The Library Features - Nicolai Josuttis - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C++17 part 2: The Library Features - Nicolai Josuttis</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_PEgl63V7wc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everybody
this is after the break this is a tough
part for you to stay waiting after
talking this morning about the new C++
standard and it's coffee features I want
to talk this afternoon about the new
library features we have in C++ 17 again
for those who are just joining and
didn't hear the first talk this morning
my name is Nicola azusa's I'm
self-employed
I'm part of the standardization
committee for 20 years now and so
partially it's all my fault but
partially it's your fault if you don't
like anything you were not there we are
community driven and everybody who's
there has influenced so I will usually
say that your fault not my fault if you
ask them for something and yeah memory
maybe that's it for the moment most
interesting things I want to tell you so
we talk again about C+ for 17 and a set
before we have a three year schedule
right now to come up with new supastarz
versions after c plus 11 was a big
improvement and gained a lot of momentum
we now have sleeper for 14 which had
only some minor extensions and now after
expecting more
we have Cetus or 17 which I would
categorize as a medium improvement and
the next improvement is already are
there we are already working on C++ 20
which will hopefully and probably be
again and major improvement it might be
even become bigger than C++ 11 because
it it will really change the way people
program in CSS
um so and again the hint that there is
already support four-seater 417 we have
support in GCC and C++ in especially in
version 7.1 which came out some weeks
ago and claim for also supported and
then we also have would wish to use 17
which also supports some of the features
and will have updates also this year so
at the end of this year I expect that
you are will find on all major platforms
more or less support for C++ 17 maybe
not completely but for the main cases so
here we talk about the library and the
library means of course new data types
but not data types which fundamental
data types data types we define in the
standard in the standard library as an
application of the language and the
funny thing is that the library in C++
always are pretty often extends core
features which we for some reason things
should not be come coffee just but
library features although you can could
argue that they should be coffee
features so some of these basic data
types we also started to standardize in
C++ 17 so the first thing is string view
we have now a new string class so after
STD string which owns the memory for the
data it holds either by arm allocating
memory on the heap or maybe for short
Springs with some optimization
implementations use their own memory
they have on the stack now we have a
data type representing strings but not
owning the memory owning the memory they
refer to which is of course a dangerous
string to some extent this is a string
reference but with an API of the string
and it should be cheap to copy but as I
said pretty date pretty dangerous but
there are enough application of that for
example I was working at a company which
created a new database which should be
filled with big data so you couldn't
keep all the data in memory so you had
to keep it on a file system and what you
usually do is then you map just the file
system into your database with a map
calls or something like that and then
instead it would be far too expensive to
copy all the strings in the map just
refer to them and use them as strings
that means that string views have not
all guarantees normal strings have the
most important guarantee which is
missing is the string does not necessary
end with null termination so with a null
terminator because here you see on the
right side we refer to data in some
memory and after data there might not be
a 0 of excellent 0 character it could be
but then it's organized that way by
those who provide the data for the
string and it might also happen that
that such a string suddenly has a value
which is not pointer which is nothing
referring to nothing that's also
different from traditional strings
traditional strings don't have this
state they have then if you don't pass
anything for initialization they
represent an empty string which is a
different thing so that means always use
size and check the size before you
access element or the data or pass the
data around there's some support but not
support in every direction regarding
string view it came in pretty late for
CTF 1217 so we have something like
spring view for different character
types but we for example have no support
for the interface reg X interface to
also deal with string use
and we have a literal now allowing
easily to create a spring view just by
adding the suffix sv after spring
literal spring these are cheaper than
strings and a pretty easy example is if
you declare a function to take a spring
a traditional string of traditional in
the sense of C++ and so an STD string
and and now if we now declare something
to take a string view it becomes cheaper
to pass a string literal because in the
first version you have to allocate
memory for the string holding the data
and in the second version taking a
string view you have no allocation at
all you only have to compute the length
of the string so that makes passing
string little cheap and that in general
raises the question a string views the
better string API that so should what
should we do with the existing code
should we expect to have a string or
should we expect or to have a spring
view and the answer is it depends the
point is if you for example pass your
string to a c function expecting a null
at the end then you anyway need an SE d
string so it's probably not worth it to
change it but there are other examples
for example here you see an example
where we have two string method taking a
perfect and a time point and a time
point is part of the sibyl's of 11
library to compute x and there's a
conversion function taking this time
point converting it to a time T and then
with C time converting it to a visible
string and then because this string
contains a new line at the end when you
call it created with C time then we
remove the new line and then we return
the prefix plus the string if you take
this provisional code for additional
since see the source 11 then you can
think about taking a string view
because you don't need a zero terminator
at the incoming string and note by the
way that string views are usually passed
by value not by reference because it's
cheap to pass them and we can even
inside take see time takes a string view
which also saves some some memory
because the see time value is available
until the next time see time is called
which by the way is not not concurrent
safes or thread safe but it's anyway not
thread safe to call see time so so it's
a little bit less thread safe than
before so in commercial code with
multiple threads view anyway needed
mutex is here and then there's a the
spring view is a read-only string but by
definition you can change the size well
you can reduce the size you cannot
extend it but you can reduce it and
therefore there are some methods saying
I want to skip the last character or the
first character because then we just
refer to a different location to a
substring of the string we had before
which we do here so there are some ways
now to change your API to the modern
modern style but beware we are ourselves
still trying to find out what exactly
the guideline is to switch to string you
said it's a cheaper API but it has some
constraints so be careful to use it in
general we will find out over the next
year then we have some data types in the
standard already which more or less
counters core database called data types
like pair for example and we have now a
few other more or less card types which
are able to hold the value and if you
see the terms and you know booth you
might know them already but we were they
are slightly or significant different so
they have the same idea but we were a
little bit so we have optional variant
and any
and all of them solve a specific problem
you want to get you might have if you
deal with values in general so the first
problem sort of the first solution is
optional and optionally it's just
resolving the problem that you might
have a value of a certain type but you
might also have no value of that type
which is different from a special value
so that for example for STD string
beside the empty string you also have no
string and which means semantically you
you give this value type a reference API
and that's that's optional of int and
here's the example that explains how to
do that optional just take the type it
represents and it adds an additional
state you can set and you can check so
here for example we take a string and we
try to convert the string to an integer
but if the string is not convertible to
an integer as 2i throws an exception and
in this in that case we return a null
optin and I love is saying well I don't
have a string and I don't have an
integer here so I we return either the
integer or no integer at all and that
means we don't have to to take one
special value like like minus 1 as the
value representing no integer which is
usually a bad interface so here's the
loop then taking and calling this as in
function and for different values and
here you see how you test it if it
converts to true then you have a value
of that type and you can access it by
the star Baretta otherwise you can do
whatever you want if you do have no type
helpful in a couple of places this is
pretty by the way this is pretty near to
the existing boost interface of boost
optional then we have a second type
taking which is a variant variant is a
kind of the Union so that means an
object that can
have multiple types no it's a it's a fee
need amount of types it can take when
you declare very and you declare what
kind of types the object might take and
if you know C and C++ then we have this
language keyboard Union which allows to
say I have I can use my my bytes in my
object as an integer as a character
array and some people even use that to
convert integers to byte sequences this
is not the same this is different in a
way that there is no different
interpretation of the of the bytes it
has this object knows which type it has
and only allies loves to deal with the
type it currently holds so either the
object holds an integer or the holds of
string but if it holds a string you
can't ask for the interval it's integer
value of this object that will result in
a runtime exception so this object knows
what it holds and it's type safe but it
only needs memory for the maximum of the
size of in and the size of string that's
a big advantage it has so we have here
variable taking on being either an end
of an LCD string it is initialized by 42
so that means that the compiler can find
out because 42 is an end that it's
initialized as an int but later on we
can assign a string or something that
converts the string which of course has
to be not non-ambiguous so if there are
two types where a string literal could
convert to this would not compile and
then we can access the data with get you
can access the data knowing the type and
then you can can have to pass a type
alternatively you can pass the index so
the the type interpretation you want to
have so because if you say get 0 you get
the first type which is an int it
if this if this is detectable at compile
time that there's an error so if you
pass in an unknown type or if you pass
an unknown index that's a compile time
error but if you don't know what it
holds currently and both is valid this
might result in an runtime error so in
an exception a couple of interesting
things here the first thing is this is
this allows to hold a types several
times that means semantically we can
hold two different integers one integer
representing some semantics and some
integer representing other semantics so
if you have different situation you want
to represent different situations the
first in might have 42 and or the second
end might have 42 but they might
represent different situations different
states and of course then it's not
possible to say I want to get the end
because that's ambiguous then you have
to use index to clearly say which in you
want to have at everything else's as
before and if you're no boost and boost
variant there is a significant
difference in boost variant such an
variant can become our empty end because
it can become an T you need heap
allocation heap memory to be exception
safe and this drawback was fixed or boss
well this we discussed when we
standardized variant for C++ 17 so now
we have a situation where we say this
type that's no longer need heap memory
so it simply allocates again the maximum
of the possible types and said before in
boost you couldn't do you also could do
that but to keep a copy of your current
data if an exception falls then you did
the data type still needed heap memory
and that's gone now but the prices
that you might come in an interesting
state the status I'm not really empty
more or less I I don't hold a valid
state because an exception happened
during setting a new value with a new
type and that's a very rare case that
can happen but it can happen so we have
no November function calling type the
member function is called valueless by
exception and you created by saying by
doing something like this you see here I
have a variant aching afloat on end and
I have it it can't be has a float and I
in place inside the variant and in but
with a conversion to an end so I changed
the value but while I assign the integer
this conversion throws an exception and
then this object is in this strange
state which usually is anyway a state
where you would not use the object but
if you ask the object you have this
strange state very less by exception and
as set again the goal the benefit we
have we don't need heap allocation for
this type and that makes it pretty cheap
compared to boost variant and there's a
visitor interface if you have different
types and it's tedious to check for for
which type it holds and then have
different functions called there's a
general way to provide an operator a
function call operator for each and
every type and then you can simply pass
this visitor to a variant and that means
if it count Li holds the double it calls
the first function if it holds an
integer it calls the second function etc
which might also be generic template
called or lambda or something like that
so it can be pretty flexible okay the
third type we have is any-any is also a
new way to hold it type a value um the
first thing was to make the very
optional the second boss that the value
might have different but a Phoenix
any number of types and now we have type
saying my value might be any type at all
I have no limits it can be any type even
a type not known when I compile this
code or when I use a template in a
header file it is compiled when the
types are clear which are used and this
is the trickiest that any takes the
value and remembers the type of the
value so if I assign 42 it remembers
inside the type idea of 42 which is an
int I PI D if I later assigns a string
it remembers the type idea of the string
etc so it simply saw the type ID of what
was assigned there and then later when
you want to access the object you can
only access as if you double check that
the type idea is wrong or you might get
undefined behavior so here you see some
examples I can ask do I have aware you
so this type can be empty or the the
values of this step can be empty and
then I can ask is the current type as
doing as an STD string so that's the
type has a type idea of the string and
then I can any Casa cast it to the
corresponding type and use it and as set
this will work with any type even with
types that later come from any other
source or any other library you have so
but of course this because you don't
know how how big data might grow this
needs a heap memory to allocate
corresponding storage a feature we have
here is you have boost semantics would
be any type which was not supported yet
in boost with the any type I think as
far as I know but I might be wrong here
arm so we have some semantics from them
I recently tried to compile it it didn't
work this code didn't work so I have to
double check it so there's a question
mark on this slide currently
yeah and we have a fourth basic data
type which is a totally different type
this is a type called STD bite and it's
representing a bike by definition a bite
has the size of one so that means it has
a size of character so that means that
it's open how many bits it has it
depends on the platform there are
platforms that have 64 bits so where the
character has the size of 64 bits so a
size of 8 and on that platform the bytes
would also be 8's I would it would also
be 64 bits have 64 bits so the idea here
is and there was a lot of fight when we
standardized it the idea was that that
that got the interface was to say a byte
is not an integral data type so you can
use it as an interval data type but it
isn't it's just a bite and that means we
have operations like bit operations like
left shift right shift exclusive or or
etc so all the bit operations but we
don't have plus or minus or something
like that so this should not be yet
another character type or something like
that and the idea is to make clear if
you use it in your program that this you
don't use here this type as a very small
integral value but you use it as a byte
as a representation of eight bits
usually so that that's the design of the
API and in the interface note that the
definition of byte is just an enum so we
have extended the language that now we
can initialize such an enum with the
curly braces which was not possible
before with some conditions
and but any other initialization is not
possible and there is no implicit
conversion to buoy so you can't test
whether the bite is true yeah a bite is
not an integral type it's also not a
boolean type
it's just representing bits so you have
to convert it to the corresponding idea
or you can't have to compare it with a
bite with full of zeroes so that's
possible so there is a function to
integer for bool and then two inches
that you pass the type you want to
convert this the integral type you want
to convert this by two and that way you
can use in an integer expression or you
can assign it to any integer or some
other types okay that's a fundamental
data types we have what else do we have
we have a really new library it's called
the file system library the file system
library comes from booth also also it
has some modifications so the idea of a
file system library is to be able to
portable program with file systems it's
not creating fights we have that already
but it's more something like creating a
directory or iterating over a directory
recursively go through a directory find
out whether a path is a root something
like that so all these sizes and
operations I think the best example is
if you just see code and you see here
the the general idea if you include file
system then you have the data type file
system path with represents a path in
your file system you can check whether
this exists so whether there is
something and if this something exists
you can double check about it this is it
a regular hire and you can ask for its
size you is it a directory then you can
use the directory iterator to iterate
over this directory and you can do other
things a couple of other things
including printing out the path this
more or less has no change to boost I
just had to change the the the namespace
from boost to STD and the include
statement and it did recompile here's
another example which shows a little bit
that you can create things so you can
create a directory you can create a
symbolic link you can concatenate paths
with the slash operator or flesh equal
yeah things like that are supported the
specification says that in case there is
no equivalent upper operating system
support for example if your operating
system does not have symbolic links you
have to do do things as somebody
providing this library on your platform
you have to document what happens
instead and you have to be as close as
possible so if there is no symbolic link
you have to double check on your
platform what this call means and just
to ensure in Windows we have symbolic
links some people don't know that again
no change in API we try to abstract
operating system that's that's a
nightmare I can tell you I learned so
much I had learned a lot of a lot about
symbolic links and where and where am I
when I traverse through symbolic links
it's really a nightmare and so we
abstract something so we say a path can
have a root name can have a root
directory a directory separator and then
a file name and the file name connects
connects can exists of a stem and it's
extension so stem is the part without
the extension and then we have try to
map this on different operating systems
so here is another example and you see
how it behaves under UNIX and Windows we
have a path declared there in the middle
fubar data.txt and then if we print it
out we use we have the
general format the general POSIX format
and but if we make it preferred as a
preferred syntax of the operating system
you see that on Windows the slashes are
replaced by back slashes and then we
have again api's to get a lot of
information about this path look at the
last line here if we ask is this an
absolute path or not it depends on the
operating system because UNIX in UNIX
this is an absolute path because we
always start with root but in Windows we
have the drive so C colon or something
like that so in Windows this is not an
absolute path so so we are not we are
not standardizing more than we can so
this there will be differences and you
have to deal with the differences if you
deal with a different operating systems
and said this is a library we had in in
in boost but we made some some changes
and sorry I have to I disabled showing
those users slides I wanted to show now
so I have to enable them again where is
it then this gives me a movement so
so yeah sorry so I give you some
examples what we would change for
example in boost we have defined that an
extension always starts with the last
dot so if you have a fi called dot git
and you ask about the the attributes of
this fire the answer is this file has no
SS only the extension and no file name
no raw file in which we call a stem
which we think is not valid
I mean dot dot git is f it has a dot to
not be visible by default but it's not a
file without the name and with the
extension dot git so that's that's not
the right semantics we think but you can
have C different solutions for this
problems in different fibers and
libraries and different languages so we
change that behavior for example and we
change a couple of other minor things
there yeah I think I said that already
there and that has consequences just
this little this little tweak my chains
and I guess there was another thing
saying that if you have food bar slash
dot it was more or less the same as foo
bar slash so it's right in the middle
there of the slide and so foo bar slash
without a following file name was
implicitly converted into foo bar slash
dot so if you ask is there file name yes
there was a file name and the file name
was dot which we also changed now and so
we said no no there's a difference and
we have different behavior if there is a
dot after the after the path separator
or not that will change the API so a
little bit so if you if you convert from
boost to SC d Phi system
please adopt your code it will not
behave exactly like before and we
decided not to not to change not to
provide a new API there are different
API so you will see that the code no
longer compiled we use it used because
it uses a different header file
but don't just change the header file
and expect everything to work and there
is a third thing that drove us crazy
like nuts it's it's symbolic links so
look at look at the example here you
have here part and every red arrow is a
symbolic link so this refers to another
location in your file system and if you
go to a de look at that where you are a
de refers to a B so if you if you go to
the directory a de you are actually in a
B now things get worse if you have a
UNIX shell and ask where you are the
UNIX shell will tell you you are an a de
that's a lie that's all convenient
function of your shell you are not there
you can find it out if you ask PWD so
print working directory - capital P then
you get the real place you are in and if
you go up with CD : : in a shell you are
back in ad but if physically you are
really in a B then you are then : :
would move you to a so we had to deal
with these problems and to standardize
here something yeah so here are some
rules and why did we need that because
we decided that we could provide a
function computing the relative path
between two paths and that become
incredible crazy if you if you have to
deal with these situations so the
outcome is we have a physical relative
path and electrical relative path so
electrical relative path doesn't take
the operating system into a
count so not dealing with any symbolic
links but but the relative of not not
lexically might consider symbolic links
so we have not just one API to compute
relative path we have multiple API to do
that and yeah now you know why booth
didn't have a support for something like
for the computer relative path between
files because it was very tricky to do
that but with it and that's it that's a
good news
so what else let me talk about some
other libraries so minor libraries file
system is certainly a big library in a
very helpful library the first thing I
want to show you is that we paralyze the
existing STL algorithms so that means
whenever you do something for each and
every element in your container for
example transforming it or computing I
don't know the square of the elements
etc you can now benefit from the fact
that we have multiple CPUs or multiple
costs multiple threats available so we
have threat multi parallel support for
the implemented algorithm and for more
or less every others and we have
unfortunately things become tricky
sometimes then so you have to beware
what what is possible and what not so we
have to ask for some guarantees for
example if we process with multiple
threats three different elements of a
vector and the first step is to acquire
a global lock then you run into a big
problem because the first threat gets a
lock and then the next threat is blocked
etc so so we have to deal with some
ideas of how to be how much guarantees
we give and here you see the a general
try to explain what we what we guarantee
we have different policies you can apply
them to the to the algorithms the first
policy is sequential execution that's
the way things are handled now you have
one threat do we
all the steps for the first element then
all the steps for the second element and
all the steps for the third element so
the steps would here ABC for example
parallel execution means that you can
use multiple threats but each thread is
sequentially processing one element so
three different threats might take three
different elements but for each element
they for example in a lock something do
something and then unlock something and
the third thing is to say well we have
even not a guarantee that the elements
if they are taking are sequentially
sequentially are possessed so a threat
might take first do the first step of of
the first element which is a for the
left part then do the first step of
another element and if this step is the
good is taking a lock then you have a
problem then you have a deadlock then
you are out of order so you need some
additional guarantees to be able to do
that but if it if it helps it can be
even better which is usually called
vectorization in big crane machines
etcetera say well we come in parallel do
with threats the first step of some
computation of the elements but you need
some guarantees so here's how you do
that how you deal with that each and
every STL algorithm has now a new first
argument and here you select the policy
you say you are not allowed to use
multiple threats that's on the bottom
execution sequentially that's what we
had before
only it's only option and the other two
options I explained already so parallel
or powers even not sequenced and no
guarantees at all which is usually fine
if you only do local processing like
here but at the moment you have a lock
got used which is shared among the
different elements you can't you see the
flexible policy on top here when we did
that we
added new STL algorithms because it
turned out that we get some drawbacks or
some things we're missing for example
and accumulate accumulate the element of
a container but we guarantee the order
and that's that's a certain a big
drawback when making this parallel
because then to keep the aura you have
to compute the order of the results the
different threads give you and to to
deal with it with the order so we
introduced a new algorithm reduce which
that's no longer guarantee about the
order the the operation like plus also
is applied which means that for example
you can't do that for floating-point
values because different results might
might occur but it's fine for adding
integers for example it doesn't matter
how in which order they are added you
compute the Sun and we have other
examples like that way where we do to
the parallelization introduce some
tweaks of the existing algorithms with a
new name and we have a two or three
other things so clamp is just combining
a minute the max call to say I want to I
want to constrain a value between the
lowest variance also and the highest
various also and we have sample samples
also interesting so for people who do
need random numbers or random sub
subsets of set it's a it's the ideas if
you have a set say of 1 million values
of 1 million customers or 1 million
objects of certain data and you need
just random extraction from that so for
example 100 of them but you want to you
want to have it randomly computed which
hundred you extract from them this is
called sample this interfaces that using
one of the in the standard predefined
random number generators
and we also have new searches hoya
mobile mu and hospital circuits I am no
clue about the details here in the fact
what they are doing better than before
I'm not an expert in that area but the
whole idea is if you have a large string
so it's not like this example it's if
you're if you really have a lot of
string say a complete book or even more
and you want a fast search sub strings
then they they internally create hash
values etc and by this trick which you
can find if you search for these three
names there are three different names of
authors of these algorithms you can a
lot faster find sub strings in such a
string so for those people who do text
processing of large strings this is a
significant improvement couple of other
things we fix some gaps we had in some
containers are tryin place was missing
fourth for maps and place back in front
was missing or it's now returning
something we added data a non-count data
for Strings and etc and said other I
think the vectors and forwards lists now
support incomplete types by the way you
see on the right side a so-called paper
number every proposal we have in C++ is
driven by a paper and these papers have
different numbers you can see that the
scheme of the paper numbers change over
time so in the past we had n numbers now
we have P numbers if you look in the
internet at the Internet to these
numbers you will find the original paper
I'm saying what was the intention and
and what should change understand that
so here's one example which was a point
here close to the end we we extended the
interface of associative containers to
make it cheap to move the elements into
another container of the same category
I should say or to modify it somehow
here's a example that explains it if you
have a map of three elements and each
element has a key one two three and then
a fruit so mango papaya and guava and
you probably have the situation like
here listed so now you want to change
the value of one of the elements namely
the one with index two and the problem
is normally you have to remove it and
then change the value and then you add
it again and removing Freesat memory and
editing it again allocates memory again
and that's expensive of course so here
we have a cheaper way we can extract
this this note this value from the
container and we get a handle which
still reserves the memory for this data
then we can in this handle we can change
the key to four and then we can move
this back into the container and this
all happens without any memory
allocation or the allocation which of
course makes it cheaper to handle things
so this is just this is not only to to
be able to change the key of a value in
such a map it's also possible to move
for example a value cheaply from one map
into another or even into a multi map
and yeah that's supported now oh yeah
here's another example we have a soft
value a map of one two three and in the
destination value and then we want to
insert this new value into the
destination map which we extracted and
here we can for example we get again we
get the note handle to find out if it's
fair what was wrong what went wrong I
need some clarifying graphics here for
this slight bubbling
so a few minutes left let's see we still
have some things the first thing is the
scope block this is the third lock god
we have in C++ I apologize for that
we have laka which is a simple guard
it's not the underlying mutex it's just
an object that uses the mutex so that
the constructor locks and the destructor
unlocks and the first thing the first
inter API was a la la carte which could
only lock in the constructor and unlock
in the destructor then the second one
was eunuch lock unig lock and lock guard
came together with C+ or 711 and the the
second one is can more than just
constructor and destructor lock they can
in the middle they can do even during
its lifetime unlock and lock on you need
it in some places it turned out that we
made a mistake or something unfortunate
and the point is sometimes it's it's
necessary to lock multiple mutexes and
if we do that we have a function called
lock that's coming from C++ 11 this is
not an object this is not a constructor
call this is a function called lock and
it locks to Moo Texas with a deadline
deadlock avoidance mechanism so it means
instead of guaranteeing how the mutex is
are locked it finds out which is the
right order to lock the mutex is to
avoid a deadlock not in general your
program can still have deadlocks but not
in this place that's the point and so
the problem was we had to unlock both
Moo Texas and for that case we had to
adopt the lock mutexes by a la carte
that was interface we had to use and
this this all became because the scope
lock the the trivial lock guard was not
very attic so was not able
Tulloch more than one mutex and be fixed
set which we you might ask why didn't we
succeed in lockhart the point what would
have been it would break binary
compatibility so it would mean that you
have to recompile your whole program and
your whole source code with using
lockers
when switching to c++ 17 and that was
not acceptable and so we introduced too
bad but we introduced the new class goal
block which can take multiple move texas
you see also how we work we have
compiler vendors there we have people
from from every major platform compilers
and also those who write libraries and
we discuss things like that very
seriously binary compatibility is is
it's a good thing sometimes we we don't
support it if there are some workarounds
but for example i can tell you that
visual c++ 17 is the first visual c++
version with business civil platform
which was studio 17 so the newest visual
studio compiler has a compiler number
called 19 dot 10 because it's a binary
compatible to the code from Visual
Studio 15 this has never happened before
in the past from switching from visual
studio 13 through 15 was not binary
compatible in any sense so but now they
have it so and one reason is that
compiler vendors fight for things like
that but you see you pay the price we
have the problem of being backward
compatible a problem you all know and we
have the same problems like you we have
to support staff we standardized 20
years ago and we really would like to to
change things looking back that that's
the way it is so a few other things for
Atomics we now have support
to find out how to deal with your
caching I'm not an expert in that area
and how how locks are used in the
platform so the first thing is for any
atomic data type you can find out with
C++ API
whether it's locked free or not block
free implemented so if you have a an
integer or your own data type which is
possible in C++ and use it as an atomic
data type you can find out whether if
the code generated will use lock so
create its own mutexes or will be pretty
cheap by the underlying CPU and that's
that in the past you had to use a C
interface there too bad and now we have
C plus off interface for that and we
have some portable information to have
to deal with the wizard with a cache
line size of the level 1 data in your
platforms if you know what that means
you can probably explain it to me I
can't explain it to you what it is
determines some new mathematical
features we have we have adopted a whole
sub library for mathematical purposes
dealing with elliptic elliptic integrals
polynomials Bessel functions etc arm and
we have greatest common divisor and
least common what is M I only know the
German words for that so and we have a
three argument who put into this for
whatever purpose you need that if you
are mathematic fishing you know that and
again yet again we have another API to
convert integers to integral values N
and numeric values and the otherwise we
have had a lot of approaches the highest
that the most cost the approach which it
costs the most was to use string streams
which is very very extensive so for that
reasons a lot of people still were using
printf and scanf and then the next
approach in c++
eleven boss to use to string on
functions like s to ll for example to
convert a string into a long long but
they were still dealing with for example
internationalization so with located etc
so this was also pretty expensive if you
didn't meet localization so now we have
a low-level interface locally
independent simple and fast which does
convert an integral number to a sequence
of characters you have to provide the
buffer where this function writes in and
the other way around and the interesting
thing is as a single single side-effect
we have the following we can convert we
can guarantee round-trip ability for
floating-point numbers here which is not
a trivial case floating point numbers to
become rounded tables they these
floating point numbers can have hundreds
of digits if you write them out and then
read them in portable so that's now
supported here with this API so a
low-level really something for usually
library writers but which really now
finally replaces printf and scanf for
the different formats like % s &amp;amp; % e so
I think that's it we have a couple of
bug fixes of course maybe one
interesting thing cons expert everywhere
chrono
the the library to deal with timers and
time points and durations is now a
complete library of constant except one
or three chords so every computation can
happen if needed at compile time and the
only thing that's not possible in
compiler is to ask operating system
which time is it and to convert to tour
from time T everything else can have met
compile time which makes programming
sometimes pretty fast
okay new type traits for those who deal
with template code and do fundamental
programming with template code there are
also new things provided I think I don't
go into details here now and we also
removed some things we remove for
example operator plus plus for bool yes
this existed when we introduced this in
C++ people thought this is a cool idea
it turned out it's not a cool idea and
we remove the keyword register so we
don't longer support it but it's kept
reserved for future use so like Auto we
might in future give register a new
semantics and we changed exception
specifications so the deprecated
exception specifications without no
accept are no longer supported but
beware there's one thing what we
deprecated or remove in the library or
in the under standard in general the
other things is when compilers no longer
support that day we usually care to be
backward compatible even more than we in
the standardization and sometimes we do
crazy things for example code convert
which is a code conversion of Springs
and characters according to different
code sets or character sets was just
introduced in C++ 11 it didn't work well
to be honest we have nobody caring about
it and knowing enough to do with it so
we removed it already and we still are
looking for people proposing a very
useful thing for example to convert
utf-16 to UTS 32 which is very common in
java but we have no api for that and as
I said before it's your fault that it's
not there because you were not there
proposing a corresponding library for
the standard and we temporarily
discourage things and it's it's for
memory reordering that's it's very low
level where CPUs has guarantees when
they can reorder statements and cache
line
we we have we had a value there that
really didn't work so we really have
something like temporarily discouraged
so for the moment it should not be used
become beg later when we find out more
details so so that's it the highlights
of C++ in general even combined with the
part 1 features are a lot of new
language features and libraries and as a
significant part I list here everything
with the structured bindings fold
expressions in line variable compile
time is class template argument
deduction and that's probably not
complete and you now saw the the
libraries in new libraries and help us
we got and of course have each and every
where we added concepts but wherever it
is possible so to be able to support the
wish to move runtime computation to
compile time computation just if you
don't know where it's good for this is
using the chrono library to to compute
with different ratios which are the
units like seconds and milliseconds also
and there we do compile time ratio
computation to find out without in units
and which otherwise would have to be
done at runtime and would cost time what
was not voted in C++ modules modules as
a lot of people wait for modules because
this will solve the problem of large
code bases taking a lot of time to
compile because each and every time with
every translation unit you again insert
header files even if you have
precompiled headers which go a little
bit along the staff it takes a lot of
time and we are working on the new
console and a new strategy and to deal
with that I didn't want to say the word
concept here because concept is a
concept we have in C++ so concepts which
is a way to specify template api's
let's see what happens that it's a long
story what happens here a lot of people
are frustrated a lot of people are not
happy with what is currently provided
anyway they might mean sooner or later
hopefully come something useful ranges
is a library you can in betar test
already it's a solution of coming from
the begin end nightmare to something
more useful in more modern so in when it
comes in sequence of 20 we will no
longer pass begin and end of containers
we will pass the containers or sub
ranges of it and we will have to deal
with them like in UNIX pipes so where
you can say in parallel we can compute
that we take all the elements of water
container do one transformation the
other transformation the other
transformation and then in parallel by
multiple threads the elements will be
computed one after the other if that's
possible so we can pipeline computations
and not using beginning and anymore this
will change see this was dramatically
let's see whether it comes in C does
plus 10t coroutines is in threat
environment to define what shall happen
under which circumstances when something
is ready the problem here is we have two
different companies proposing api's
Google and Microsoft and they still
fight hopefully there is something they
can both think about and agree about in
near future and reflection you might
know from Java etc so that we at runtime
kind sign out what members for example
the data type has and then deal with
that so we could provide serialization
etc like that so that that will be a big
change and a few minor things so again a
summary here I'm a little bit over time
two minutes so it's time to finish I
think C++ 17 is a significant
improvement I now had two hours to
explain to show you what is coming
still the need to explain all the
details and they are a lot of details we
still find out what we standardized this
to some extent and we have the compiler
cut support so I would say there's some
data this is a medium new version it's a
pretty helpful version but not a
revolution and there will be books
coming out and one book I can announce
here again is a book the next edition of
C++ templates which was written 15 years
ago explaining all the details of C++
templates and now we revised it after
three years work we always propose
postpone it because we had better things
to do but now it's almost done we'll be
out in September it will have 800 pages
only explaining the template features of
Cetus plus 11 14 and 17 and that's a lot
that's all I'm here around only one hour
more then I have to go back and go to
vacation haha so I can't stay here
and so please contact me if you want
here or just via email and looking
forward to see you somewhere else and I
thank you for attention and have a good
conference thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>