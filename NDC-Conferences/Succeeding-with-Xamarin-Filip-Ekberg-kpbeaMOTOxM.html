<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Succeeding with Xamarin - Filip Ekberg | Coder Coacher - Coaching Coders</title><meta content="Succeeding with Xamarin - Filip Ekberg - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Succeeding with Xamarin - Filip Ekberg</b></h2><h5 class="post__date">2018-02-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kpbeaMOTOxM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I reckon and this is the best room in
the building I'm gonna try and stay
focused on the talk and not look too
much at Big Ben it's funny I brought my
wife here and she said the only thing I
want to see in London is Big Ben and
it's under construction so we went over
the bridge and we're like oh let's go
see London i under maintenance good
stuff so let's talk a little bit about
mobile development and hope that we can
be a bit more successful in this topic
then we were in sights to London so is
everyone in here doing salmon a few of
you does everyone in here seen a bit of
salmon code that's excellent so if you
came in here thinking that I'm gonna
give you this one thing to succeed
building your apps well there's
unfortunately not one thing that will
allow you to build the best app and
become an app millionaire but I will try
to talk a little bit about some failures
that I've experienced when using salmon
and how we can build apps a bit more
successful by applying some principles
and practices and c2c tool that we can
build much better code bases so before
we get into that my name is Philip
Ekberg I'm a Microsoft MVP which
basically means that I'm not employed by
Microsoft I go around to conferences I
generally do talk on the better side of
the things with Microsoft I don't know
if it's because I just turned 30 but I
am becoming a little bit more grumpy it
could also be because I've done
stammering for so long but yeah let's
blame the age so I wrote a book called
c-sharp smorgasbord and I'd like to give
everyone here a free copy of the digital
version just ping me on Twitter if you
want a copy and I'll make sure to send
it out after the talk all right so let's
talk about failing with samory so I've
been doing salmon for about twenty three
and a half years now and I've been
looking at this technology since the day
the day they released this and I've
found that I've done projects where I
really succeed with using stammering and
then I've done other projects where it's
just utterly fails so this talk is a
little bit of a mixture between how do
we apply good code principles and how do
we attack our applications to build
really successful apps it's all about
the team
it's about the codebases and tying all
these together so we try and talk a
little bit about how we can avoid
running into the same pitfalls that I've
done and see to it that we build better
applications so you know the promise
with salmon is that we can use our
c-sharp developers and just get them to
build an app for us
I've been in projects where we've
experimented with either just taking
developers that know c-sharp and just
have them write applications using
stammering and deploy that to iOS and
Android now in theory that's what should
work and that's probably the cheapest
option out there right so I've seen many
projects fail this way we hire a lot of
c-sharp developers because there's so
many dotnet developers out there and
then we get an app that's built by dot
the developer that don't really have a
lot of experience with mobility and
mobile apps so the other end of the
spectrum is that we've tried to hire iOS
and Android developer and just have them
learn some c-sharp and that's just as
much as a failure as just taking a
c-sharp person and teaching them some
stammering so you kind of need the
mixture off we need to know a little bit
of iOS and Android we need to know a
little bit about c-sharp in order for us
to use a marine as a toolkit and it's
not just about you know the numbers we
don't want to say that we want to share
ninety to a hundred percent of our code
we want to make sure that we share the
right amount of code in our apps so
using salmon it's not only about getting
the dotnet developers capable of filling
these apps it's also about educating our
teams in how do we share code properly
across the different platforms so how do
we really succeed with building one of
these applications well kind of the
first obvious thing is to build
something that's really great and that
kind of obvious we need to have a good
idea for application unless like if we
have a bad idea that's not gonna work
out anyway so why spend money on that
but given that this is kind of obvious
we need to share the right amount of
code in our applications so I've seen
projects where we try to focus on we
need to share all the code because what
happens if Blackberry is gonna release
the next big platform and we want to
introduce this platform as well if we
try not to focus too much on we need to
share all the code but think more about
share the right amount of code
the apps and we'll see some patterns
that makes it easier for us to share
more code but also patterns that allow
us to use the native platforms and build
things in the native layers as well as
sharing a little less code and still be
successful with the apps and then we
want to make sure that we can minimize
the app size so when you download an app
in the App Store or Google Play you
don't want to download a hundred
megabyte application if it's only
allowing you to do like one thing so
there's tools in salmon that allows us
to do this we can apply ahead of time
compilation we can use LLVM and we can
use all these things that we have on the
native platforms as well we just need to
make sure that we enable these different
flags and we'll take a look at a few
examples later on and then we need to
optimize for speed so that means that
well if I start up my application it's
built using dotnet which means that it's
also going to use mono right so when
this application starts we don't want it
to delay too much before we get into the
app so I'm working on application right
now for public transport back in Sweden
where I'm from and one of our problems
is that we have people using phones that
are five six years old
and the other problem is that I'm
working with a codebase that's almost
three years old and it's a losing salmon
so the problem here is that well I'm
testing the app using my latest Galaxy
phone and it's everything super quick
starts up in less than a second and then
we get a customer coming in to us
showing the app and it takes 10 to 15
seconds to start the app and a lot of
those things in the app is it's
bootstrapping xamarin it's where we do
things in the dotnet frameworks that's
slower on the mobile devices so we need
to think about how do we optimize the
apps for all the different platforms and
you know the promise with salmon is that
a bit most of you've seen some somewhat
of this picture before we have this
platform specific player where we have a
little bit of code and then we have a
larger layer where we have all the
shared logic in the applications and
this here is a great promise but most of
the times what happens is that we end up
with something looking like this here
especially if you have like a product
owner that's on an iOS device
the focus is on building a really great
eyeless application and Elias experience
and then I don't I'm sure why I still
have windows in my examples because no
one builds Windows apps anymore
unfortunately I was a Windows user for a
long time but you know with stammering
you have to go over to either iOS and
Android and you need to use a Mac so you
kind of leave that behind so what
happens here is that well you know we
focus a lot on building the iOS
platforms or the iOS application and we
introduced really nice animations and
storyboards and all of that really nice
things that makes the app really
excellent but then we get over to
Android and well you know the product
owner said why didn't you just share all
the code well because that's not really
how it works
so what happens is that we want to
leverage Sam ring to share more code
without actually making the applications
worse but that kind of brings us into
this question why is it so hard for us
to share code the problem with sharing
code is that will we go down to the
lowest common denominator in most cases
not really with Sam rain but if we use
react native or if we use PhoneGap or
other tools that allow us to share code
we kind of bring ourselves down to a
level where well if we have this feature
it's available for all the platforms so
fundamentally it's hard to share code
because these platforms are so different
there's such a big fragmentation between
all the different devices that we have
on the market so we have everything from
this 80 inch surface hub from Microsoft
to this little watch here from Apple and
if our code base is going to be
targeting all these different platforms
and form factors and presentations of
devices and Android versions and so
forth we need to think about how do we
properly share code across the platforms
and sometimes it's actually okay to
build more in the native layer than
sharing the code in our applications so
something that I've found is that it's
not always about trying for the team's
top net dotnet developers to share all
the code but we need to focus on how to
get the app quicker to market especially
in these days where we try to do
continuous deliveries and continuous
deployments and testing the app quicker
and just getting it out there
if we focus too much on sharing code
across all these different platforms we
won't really do anything
but sitting our code base and trying to
think of ways for us to share code so
when someone brings up all of these
different platforms and permutations I
kind of feel like I just want to scream
at my monitor and this is kind of me
whenever my product owner tells me to
introduce a new feature because we need
to figure out how do we properly share
code across the platforms and one
solution to allow us to share more code
is to think more of abstractions and
this is kind of obvious I think if
you've been a developer for some times
you've seen interfaces you've used the
inversion of control and dependency
injections and you've seen a few
different patterns that allow us to
abstract more in our code and be more
abstract when we define things in the
apps we're in any code bases for that
matter but one of the things that I've
seen happening when we think about
bringing things into share code is that
we end up with a situation looking like
this here so we still want to focus on
leaving the UI code in the native layers
we have maybe an iOS or Android
developer focusing on the interfaces and
then we have dotnet developer sitting in
the shared code down here so what
happens if I start to write everything
in shared code but I just want to do
something slightly different on one of
the platforms that's when you cannot
start to leak into these native layers
so your share code might have like if
this is running on iOS or if this is
compile for iOS just run this little
small code piece differently and what
I've seen when we do that is the code
base tend to get really hard to work
with so I'll show an example later on
sexually and out of the box example from
salmon where they tend to do that
approach and I'm kind of against it so
what we want to do here is that we want
to have a layer in between here to just
make sure that we can afford ourselves
not to leaking to the share code but we
make it possible for us to share more
code across the platforms because you
know ultimately what makes an
application successful is getting it to
market making it easier for us to add
features and making it easy for us to
maintain the app so I kind of have these
four different layers that I'd like to
divide my applications into and actually
these two at the bottom here could be
same thing so let's start from from the
bottom one here we can now introduce a
dotnet standard library which introduces
services and interfaces and abstract
classes and kind of common logic across
the different platforms what's really
cool here is that previously if you use
the portable class libraries they were
just allowing you to use the
capabilities of whatever that portable
class library was allowed to use so in
some cases what happened was that we
couldn't do certificate pinning for
instance in a portable class library we
had to introduce a shared project which
just brings in the files during compile
time and that's a horrible development
experience because the editor isn't
really built for it like this it's this
hack inside Visual Studio that's not
really the best so what happens with the
darknet standard libraries is that we
can now build things in these in this
library that we couldn't do before which
means that we can share more code and
then we can have shared logic which is
common implementations let's say that
ios and android has one shared
implementation for something we could
have that in a shared logic layer and
then higher up you could have the
implementation for Windows and then I
want to introduce some share UI so as
everyone in here heard about salmon
forums yeah almost everyone so some
reforms is a way for us to in an
abstract way say that this is how we
define the UI it's now up to salmon to
figure out how this is rendered on that
a Navy platform everything is still a
native application it's native
components but we are sharing a little
bit more code so if you asked me maybe
two years ago I would never say that you
should use salmon forms but I'll show
you a way that you can combine using
salmon iowa's and salmon Android
together with salmon forms so you can
kind of get the best of both worlds and
then of course we have the native layer
so I hear people say all the time that
just avoid adding code to your native
layers and avoid touching the native
projects do everything in samory forms
but I think that's not really the best
approach you should do what's right in
the native layers and then do what's
right in the shared projects and a way
to figure that out is to talk to your
teammates if you have an iOS developer
or someone at
experience with iOS and someone that's
experienced with Android if they just
talk to each other and they could come
up with a way that's best for for both
platforms that's great so if it's harder
to do the in salmon forms don't do it do
it in the native projects but you can
still think more about how do we share
the common implementations like view
models and the logic behind navigation
and so forth on the different platforms
so I'm not necessarily saying that more
layers is better I'm just saying that
this is a nice approach for us to
structure the applications and most of
you have probably heard of a lot of
patterns that we can just throw out
problems if you're a Java developers
there's patterns everywhere more so than
in at the dotnet world I would say but
we can introduce things like mvvm and
I'll talk more about that later on and
we can introduce dependency injection
inversion of control
just to make it easier for us to build
better apps
so what do we want to do this why do we
want to just throw patterns at the
problem well if we take a look at an
example coming from one of these a
murine out-of-the-box examples is that
this one here it's a splash activity on
Android and my question is how do we
test this the first question it would
probably be why would you test this well
if we look at the middle here there's
this section of a little bit of logic
where it's checking well if the user is
logged in I wanted to transition
somewhere and if you're not logged in
show the login screen well obviously if
we like this little small expression
here it's not really worth testing but
in most cases what happens is that we
tend to then add later on in the
development process you say well if the
user is logged in and it's an admin show
this view here if it's user that's
logged in and it's a super user show
this one and so forth then it tends to
grow right and you tend to have this
same logic across all the different
platforms because most of our the apps
that we build are the same on all the
different platforms is this different
code so what we want to do here is kind
of think of a way that we can break this
out we want to decouple the applications
which means that we want to pull those
pieces out that are common across the
different platforms if we think more
about this as an abstract way we can
define this as
think all the view model so what I have
here is a way for us to define that we
have something called settings we can
check if if the user is logged in and if
they're logged in we can do something
depending on that and this here it's not
really depending on the platform itself
we could have the implementation for I
settings on Android and iOS and then we
could handle the navigation or listening
for an event happening on the native
platforms this way we can now test this
view model if we wanted to and we have
this same logic for both of the
different platforms does anyone not
think this is a better approach good so
everyone agrees with me so what about
the platform specific code if we want to
do something very specific for one
platform how do we do that if we're
bringing everything out to these shared
players think about NFC for instance I
don't know if you heard but about six
months ago Apple finally allowed you to
interact with the NFC chip on iOS
devices but it's only one way so you can
only tap your phone to something in the
phone can detect if you have the app
open it can detect whatever tag you tap
on on Android you can do both way so you
can say tap on something and it can both
read and write to that particular system
so they kind of did it half ride on iOS
which means that if we introduced some
features that use NFC on our
applications we'd have to do a little
bit differently
on the different platforms you could
argue that you say well if it's running
on iOS just disable everything that has
to do with NFC if it's Android you are
allowed to do everything and one
approach to solve the platform specific
code is to of course introduce compiler
directives so in this example here we
have shared code but it's going to be a
little bit specific for a particular
platform so this method here is simply
going to get some content out of an HTTP
response message the message itself is
using deflate or gzip so we need to
decompress that in order for us to read
the content on the platforms and
unfortunately on Android that's not
happening out of the out of the box so
we're saying here that well if this code
runs on Android we need to decompress
the message first if
running on any other platform it just
works out of the box with using this
free reader now I mentioned earlier that
I don't really like this approach here
and a better approach would probably be
to inject the way that we do this on
that particular platform we could say
that we have an ID compressor or an IE
deflate interface that's implemented by
that particular platform which is
probably a little bit more testable and
a way that we can do that is by
introducing something like tiny ioc into
our applications there are other ioc
containers like auto fac and and a bunch
of other ones out there but this one
works really well you bring in one file
into your project and you have all the
capabilities that you need from an IOC
container so what happens here is that
we register something called an account
service and we map that to this
implementation we have an i preference
service and map that to this
implementation and I cache map that to
this implementation and say that this is
a singleton so whenever you ask for a
cache you just get one and what's
interesting here is that if you ask the
container to give you an I account
service if the I account service depends
on the preference service meaning that
if the constructor of our account
service wants an eye preference service
is going to automatically create an
instance of that and inject that into
the constructor so if you think about
this in the broader sense we could have
an ID compressor in here and inject that
into our HTTP handler or whatever we use
on the platforms so this means that we
can register implementations on the
native platforms for things like NFC and
for things like checking flight mode and
so forth so someone once told me that
you should just interface all the things
because that makes everything a lot more
testable and then you start to work with
Android and there's no way to actually
inject anything into a constructor so
you have to relay on something called
the service locator pattern so the
service locator pattern is kind of an
anti-pattern which means that it's not
really the best thing so the way that
this works is that we were saying we
have this class which knows about all
the different services in our in our
solution and it's in
uses our container to resolve that
implementation so let's have a look at a
little bit of code that's using the
service locator pattern is anyone in
here using writer yeah if using driver
so obviously you still need to to have
access to a Mac to work with salmon
they've done a lot of improvements in
the way that you can now use a total
like a Windows machine on a different
network and it can remotely compile your
iOS code on a Mac but you still need to
have access to a Mac and the fact that I
think all the development is a lot
quicker using a Mac I've swapped over to
writer because I think it's really great
so writers built by JetBrains which
means that it has all the resharper
shortcuts and I can do all my
refactoring and it's just I think it's
great and I don't work for JetBrains
either I just like the idea so what I
have here is that I have this I have
this solution with my first demo project
here it's giving us an iOS and Android
project I have a shared project up here
I mentioned earlier that I'm kind of
allergic to these shared projects but
they still come with the the demo
solution that you create using salmon
and what we're getting here is a way for
us to define the application so what we
can see here is that they're actually
using this if it's iOS run this code
here which is that the iMessage dialog
is going to be an iOS message dialog if
it's compiled for iOS and it's going to
be this here if he's running for Android
I would argue that you could probably
move these two lines over to the
platform specific projects we'll make a
lot more sense because then we could
take this shared code or shared project
and convert that to a dotnet standard
project instead and have it available on
nougat which means that we can share the
code with our backends as well if you
wanted to do that so I think that in
general is a better approach so here we
can see that we're registering something
with something called a service locator
it's grabbing the instance of our
service locator and saying well for an
IEEE account service I'm going to
register this implementation which
doesn't matter what it's doing but it's
going to to introduce that and then of
course inside our splash activity for
since we could at the bottom here after
we do this code here that I argued we
should move over to a view model we can
then say well I'm gonna save something
into my account service which I can then
of course use inside my application so
I'm just gonna run this here and show
you what it looks like it's nothing
fancy but it's a starting point for the
other demos that I'm going to show you
later that's showing some better
patterns and practices so the problem
with this here is that it's it's asking
for a dependency inside a method and if
I'm writing a test for this part of the
code here it's really hard for me to
know which dependencies or is it relying
on it's hard for me to mock the data
it's using it's hard for me to know
anything really so let's see here if
this is D so you see here it says
signing as Phillip here so it went
through the splash it went into this
login view here which we could probably
see in in the Android project so we
probably have an activity here called
the login activity we can see here that
it's it's saying get the I account
service sign-in button text should be
sign-in as the account name so it's
using that here as well and then this is
just a simple simple Android application
it's super quick it's native it's using
salmon it's sharing a little bit of code
with the iOS project the iOS app looks
pretty much the same I'm not gonna
bother showing that but what happens is
that if we look at the code that we have
in here there's a lot of folders with
all these activities and assets and
fragments and whatnot
which is all Android specific and the
same goes for iowa's we have view
controllers and helpers and so forth
that allows us to build a UI for iowa's
and then what they've done here in this
shared project is that they've
introduced view models but they haven't
done it for everything in the project I
would still argue that you'd have a
splash view model here but they've tried
to do that for instance for the login
view which then allows us to say things
like this is shared logic the title for
the login page is gonna be login no
matter which platform you're running
this code on so even if we're not using
Samer in forums and we're using this
shared project approach we can still
reuse a view model
and we can still use commands which we
could set or handle on those different
platforms so we can still try to apply
to these different patterns no matter
the platforms so so that's a starting
point for the demos that I'm gonna talk
more about later on but we kind of saw
here that we have this idea of a way for
us to retrieve dependencies in the
projects I can ask for a my account
service in wherever in my code but I'm
not really in control off
what's injected into the method a better
approach would be to say well this
method depends on an I account service
but since there's no kind of native
support for that it's really hard to to
build something like that and I've been
in projects where this kind of grows out
of proportions in this case here it's a
very small piece of code it's very you
know it's it's it's just this small demo
but I felt so many times that I'm like
damn what have I done with my project
using the service locator everywhere all
the code is really hard to test it ends
up being this mess of spaghetti code
which means that it's really hard to
maintain especially with code bases that
are 2 or 3 years old I don't know if
anyone here is using or working in a
project that's 5 10 15 years old but
once deprived few are actually working
with the older projects so you probably
know what I'm talking about like if you
end up with a a really bad situation
from this start it's really hard to
rescue that project without just
throwing out and rewriting all the code
so one way that I want to kind of fix
this and make it a little bit better is
to add something else to the project
that's not that hasn't really worked out
that very well in the past I'd argue
that salmon forums has been this thing
that I know both Microsoft and salmon
before the acquisition of salmon really
wanted to work out but I think it's it's
at that point right now where it's
starting to be really good so what we
can do is we can add salmon forms to the
mix which means that for new views and
for new controls inside the app we can
say this here is going to be pretty much
the same on all the different platforms
imagine a login view or an about page or
something in the app that's kind of
generic it's not
the core function of the app we could
introduce a shared UI and it's still
gonna render as the native platform or
the native components but it's shared
you use an abstract way to define what
the UI looks like and Facebook is doing
this approach inside the Facebook app so
they're heavily focused on they're not
using several forms by the way they're
using something totally different so
what they're doing is that they're
heavily focused on performance in the
app so the app is probably written in
C++ but then they have this nested page
like five levels down that's building
react native so because it looks the
same on iOS and Android and no one
really goes to that page so those people
that do they they don't really have to
worry too much about spending too much
time building that page so they're kind
of it's the same thing applies here so
if we're working on application it's not
really performance heavy or there's not
a lot of graphical things that we need
to do we could introduce Ameren forms
and hopefully we'll eat up all this
shared code that leaks into the share
code and we can have our dotnet standard
product down here we can have a little
bit of shared UI code or a lot of yet
shared UI code depending on the project
and then we can have the platform
specific layers which still allows us to
be really great on that particular
platform so how do we do this well we
can use something called salmon forms
embedding which was introduced or is
introduced in I think it's the next
version of salmon but it's been in
preview for about six months so here I
have this thing called the main page
which is a salmon forms page and now I
can simply say give me a fragment of
this view here or give me a view
controller on iOS which means that we
can combine for instance an activity to
say well this up here is actually the
native activity and this part in the
middle here is using ceremony forms
embedding so I can combine these
different paradigms in these different
ways to create my UI and I don't have to
choose if I want to go with Sara and I
was an ad I an Android or do I want to
go with salmon forms I can combine them
as I go on and they've just announced as
well speaking of something something
totally different that if you're working
on an AI with an android project in your
using Swift or Kotlin you can in fact
reference dotnet dll's
using salmon as well
so you don't even have to use xamarin
anymore it's a total project which i
think is pretty cool I think it's the
way to go to provide us with options in
a way for us to share the right amount
of code in our applications and of
course we can do this same thing for iOS
we can say give us the main page here
and create a view controller and we
could add that to a navigation view
controller or a tab view controller and
this would render I wouldn't say nicely
but it would render on our iOS device
here but what's cool here if we have a
look at the code is that this Semmering
forms embedding allows us to define the
UI in kind of an abstract way for a
particular platform or for all the
different platforms actually so the same
project I have a shared I'm going to
close all these other tabs so what we
have here is that I simply have this
code here saying create my page I've got
a button that you can click it's going
to be centered in the middle when you
click that it just updates the text
super simple and then I can use this
page in both iOS and Android so let's
have a look at one of the activities
let's go to the main activity assume
this in here we can see her at the
bottom so this here is using a tabs
adapter which is a way for us to create
a tab control that you can click two
tabs in Android and one of the tabs is
going to be a salmon forms page so we
have to call some reforms in it and then
create fragment and that's allowing you
to just embed this as you would inside
salmon for Android and I think this is a
good approach so if we run this here and
of course we we can have a look at the
iOS code as well just to give you an
idea that well if we change anything in
here we have this share UI that's living
inside our stammering forms UI project
it's totally separate it's compiled
separate and I think that's great
and this is just like the first building
blocks on the madness that we can
achieve by introducing a shared UI
project
because if we introduce Ameren forums
that allows us to use other components
inside salmon forums and we'll talk a
little bit about the messaging Center
which is an event aggregator we'll talk
about how we can use a dependency
services to inject dependencies
automatically and we'll talk about prism
and how we can use mvvm extensively in
the applications something not now here
and hopefully the about page here is
gonna say click me so this is Semmering
forums it's showing up here and one of
the problems that I've found so we were
pretty early on using this in the app
that I'm working on now and on iOS this
works really well out of the box it's
it's really performant like you can't
even notice that you're using salmon
forums but even on newer Android phones
this tends to be a little bit slower
like startup times and loading loading
wise it's a little bit slower and lag
--is-- but once it's loaded it's super
snappy and it's super quick and it's
really great and I think it's I would
argue that the way that I can share the
UI and like the benefits kind of
overrules the the the what I have to pay
in performance this for the first time
you start the app so let's have a look
at the iOS app as well so if we look at
the code the iOS project have a view
controller of a tab bar view controller
here which is what handles the tabs on
iowa's it's a little bit more code here
because I want it to look a little bit
nicer I'm initializing Samer in forums
I'm creating my new my page here inside
a navigation page to get the nice
navigation bar at the top I'm setting a
few colors I'm creating my view
controller here with salmon forums and
then I'm just setting the view
controllers on my tab controller so the
code isn't really important it's it's
less code here then I'd have to write my
iowa's project to achieve the same thing
and I think it's pretty cool that you
don't have to spend too much time
working on all the code for the
different platforms you can build this
in one place and once you have that in
place it's easier to test and easier to
change of course the problem with salmon
forums is if you want small differences
on one platform that's not supported by
salmon forums you have to introduce
custom
verse and that's when it becomes really
expensive so this is the app for iOS I'm
not sure you knew this but the new
emulators you can resize them just uh
side note because they're not now here
I'm gonna click about here at the bottom
and we have the same thing here which is
click me and we have the same code for
the difference platforms notice at the
top here I couldn't get that in color
right I'm not sure the projector is
showing this correctly but it it's a
little bit more blue on the on the about
page it's because I'm choosing that
inside salmon forms so graphic wise it
might be a little bit hard to get it
exactly as it would do if you do that
the storyboard or a new file or if you
did did that code behind on the iOS
project but again I think the benefits
are really great so salmon forms
embedding allows us to start sharing
more code that's common across the
platforms and this kind of brings us
into the next thing which allows us to
do something called dependency injection
and do this a little bit more proper I
would say so
with salmon forms we'll get this way of
defining an assembly or defining a
dependency on the assembly level to say
well here's a dependency for the account
service and then it understands that
well this is the account service here
it's implementing the I account service
which then means that we can get this
dependency by saying get the I account
service and that would work anywhere
inside the app still it's it looks like
a anti-pattern but if you use this
properly it'll still be a lot better and
when we introduce the person it's just
gonna hopefully it's gonna open your
eyes to how we can do this really nicely
and share more code so this together
with something called a messaging Center
which is a way for us to communicate
between the native layer and our salmon
forums layer is a great way for us to to
make sure that if I click the login
button and I want to navigate somewhere
I could could listen for something
inside my activity to say well when you
click the button here I want you to
transition somewhere right so it's kind
of like an event aggregator and it's not
only for talking between activities and
things inside salmon forms
you can also talk across different view
models and so forth
and the way that we use this is it's
pretty simple we subscribe to a message
from a particular view model to say well
when log in completed is fired from a
login view model I want to run this code
here so I'm going to transition
somewhere inside the Android app and
then we simply say well inside our view
model we simply say we'll send this
message for the logging completed and
then it sends the view model itself as
well so we could grab all the data that
the user entered inside that that for
instance that text field when they click
the button we can get that inside our
native layer so let's have a look at
that because this is where it starts to
get interesting and this is where you
start to share more code and hopefully
it'll be a lot better so kind of the
same application I've just added to to
the project but in this case here
there's a little bit more code inside
our demo 3 UI project so we'll see here
that I have a view model call the login
view model and we can see here that what
we're doing is that I'm defining a
property called user name I have a
command these are triggered from my view
itself so when you enter your user name
and click login that will fill in the
username text field here when they click
the login button it will run whatever
command you have in here and that
command is in fact grabbing our account
service saving some data into the
account service and then it's
distributing a message using the
messaging Center and I'm using our just
a local version of the messaging Center
because at the time I wrote the demos
the messaging Center was broken for some
reason which isn't that rare when you
work with samory it's a fun story we've
actually had to bring down the salmon
Android project and hotfix some code in
this hammering tool chain and deploy
that to our build service because
something broke in xamarin that's a bit
annoying and that's one of the problems
when you choose to add another layer of
abstraction between you and the native
platform even though the app is native
there's still this tool chain between
you and getting that app that could
break anyways so this here
it's over a message from the login view
model embedding the the view mortal and
whoever listens for the logging
completed command or the logging
completed message will retrieve this
here so what happens is that inside our
android project i've set this up for one
of my activities i have a log in
fragment activity and we'll have a look
at this code here and this here is
saying well initialize salmon forms
listen for a message so we subscribe for
a message from the log in view model
whenever logging completed is fired we
get the view model which is called
object here and then we run some code
and so this is just sits here and
listens and then it just shows our log
in fragment down here I'm gonna put a
breakpoint in here and gonna run this
with the debugger and we'll see if we
get that view model in here so again
this is where it starts to get a little
bit interesting because now we can write
more code that's shared inside a view
model and we can do more logic if you
click the login button and it's empty do
something if it's the admin user name
give them admin privileges and so forth
you can do a lot of cool and crazy
things so I'm gonna click sign in here
and this will allow me to write my name
like login and you'll see here that sure
you can see that at the bottom here but
it says Phillip here at the bottom which
is the username so we're now inside the
activity we got the object here and
that's our view model that was passed
from the view model itself were inside a
message that was distributed from from
salmon forums we were listening for that
inside our native layer and then we
transition into the app and if I click
about here it's gonna say Phillip here
at the bottom and this here is another
salmon forms page so we've kind of
totally decoupled functionality in the
app and we can get the same experience
if we run this on an iOS and Android
which is kind of the the benefit of
using salmon right if you share the
right amount of code
I don't have to share the code that
tells me how I create a new view like I
don't have to share the code that says
this is how you navigate I can still
listen for this message but this here
lowers the amount of code and the amount
of problems that I can have when I touch
my native projects but it's still okay
for me to bright code in the native
layers so one thing that I find is
people tend to be scared of adding
things or writing too many things to the
native layers when they're using salmon
forms so I think that's pretty cool then
the same would of course apply for for
iowa's as well all right so I have two
more demos I'm going to first talk a
little bit about mvvm is everyone
familiar with the MVVM pattern right so
not everyone knows to MVVM pattern it's
a way for us to kind of split up even
more inside our applications so we have
something called a model which is the M
that represents the data that we could
get from either the database or an HTTP
call and then we have the view that
represents how is this all presented on
our screen and then we have the the last
part which is the view model which says
this is how you display things or this
is what happens when you click a button
for instance you might have a text field
that's going to represent your user name
and the view model knows how to kind of
append your your full name together if
you have two fields in the model that's
saying first name and last name the move
you model might add those two together
to give you a full name does that make
sense
good and then you have a way for you to
handle what happens when I click a
button and and so forth and inside an
mvvm framework like prism or mvvm cross
or there's a bunch of different mvvm
frameworks out there you get things like
navigation you can say I want to go to
this view here I want to show a Model
View dialog where I want to navigate
somewhere you can have event aggregation
which is the messaging center that I
talked about and then you get dependency
injection so all of these things
together allows us to build more loosely
coupled applications and they allow us
to build hopefully better code bases so
I like to show code instead of just
talking so let's do that instead kind of
the same code base I've just added a
little
a bit more so inside our in this case
we're inside the salmon forest project
what I'm doing in here is that I have my
app dot Samuel dot C s which is a way
for me to define the application and
here I'm saying this is a prism
application and a person application
just means that they handle a lot of
cool things behind the scenes for us
they do dependency injection so forth
internally prism uses something called
artifact which is an other ioc container
which allows us to register dependencies
and so forth inside prism itself so what
I'm doing here is that I'm saying well I
want to define a few dependencies and
what I'm doing here is that I'm saying
this is a mouthful but I'm saying
register an instance get the instance
from the dependency service which is
using stammering forms we're gonna get
an instance for the I account service
and we're gonna register that instance
within within prism itself that just
means that now person who knows how to
act whenever it sees an I account
service and just to show you what I mean
is that I have a view model in here
called a login view model the login view
model has a constructor that takes an
IEEE account service so when I create an
instance of the login view model I need
to know about the account service but I
don't want I don't want to create this
myself so what I'm doing is that inside
my view I have a login view here which
simply says I have a username a login
command it's binding that to my view
model so this field here is bound to
whatever I have in but in my view model
and I'm telling prism to just
automatically wire up the view model for
me and that means that it's going to
create the instance it's going to create
an instance or get instance for our
account service inject that into our
view model and it'll just solve all
these things magically for us so our way
for us to just illustrate that is to
have a breakpoint in here and then have
a look at how we initialize this from
from Android so I have this activity
called the log in fragment activity that
we saw earlier and what I'm doing in
here is that if we simply say
create a new logging view that's gonna
create this thing here it's just gonna
do a new login view and then create a
fragment out of that I don't set the
view model I don't do any anything at
all in there
it's all handled by prism so I'm gonna
run this here with a debugger attached
and hopefully this works it's gonna
build the application first and then ask
me where I want to deploy this it's
installing that into my emulator and now
hopefully when I when I go to this view
here and click login it's going to
trigger that login view model breakpoint
that I had because that's when it's
supposed to create that for us so I'm
gonna click sign in here that's going to
go to our login view and this here
triggers our login view model so that
was created by prism for us so in
injects our rki account service we can
see here that it gets this instance here
at the left and then sitting everything
up for us and then I can log in as
Phillip again click login and everything
works as it did before but in this case
here what happened is that I don't have
to care about how do I create the view
model I can say well this view model
depends on on this interface here and
that means that I can now say write a
test for this code here that injects a
marked version of my account service
which means that I don't have to specify
exactly the same account service and
this is really important if you're
writing a lot of tests unit tests for
instance if you do integration tests of
course you're gonna test entire
application but it's really helpful if
you want to increase the quality of your
code and the quality of your your tests
so this kind of puts us in a really
great spot because now we can write more
code in here that's shared across the
platforms I could say that well I have
the IEEE account service and that works
in one way on iOS and a different way on
Android that means that I still have
shared code but I can still go to the
native layers and introduce things that
aren't shared
so this here kind of means that the code
is more testable and it's more
maintainable and I generally say that
it's more fun to work with because I
like to use products and things that
help me be more productive and I think
person is one of those things that do
that and the fact that I don't have to
just create a new project that you
stammering forms for everything means
that I can choose small pieces in the
app that I want to make better and then
we can like start to face out older
parts of the application okay so one
final demo that I want to talk about is
ahead of time compilation on Android so
one of the things that we found with
with the Android applications is that
they use just-in-time compilation which
stammering they deploy all the dotnet
and what's inside your packaged binary
that means that when you run the app the
first time you need to compile for that
particular platform and that's not
always the best case because that means
that on older phones that's gonna take a
lot longer to run the app and we're
gonna have unhappy customers telling us
that we're doing a bad job now as I said
I work in public transport two people
blame me for the buses being late anyway
so I'm used to taking a lot of bad
criticism so what happens is that I want
to tell my Android application to just
compile everything to native code but
before we turn on those flags I'm gonna
show you here with the first project
we're gonna set this to release mode and
we're gonna do release x86 for the first
android project i'm gonna build and
package this here first it builds
everything for us it builds all the
dotnet dll's
and that what happens is that i can
package my application to say well now i
want to create the package that we
deploy to google play it does take a
little bit of time to do that but it's
it's really it takes a little bit longer
when you turn on the flags for out of
time compilation but it's totally worth
it especially if you only do this when
you when you're deploying the
applications so if you're using writer
you go to advanced build actions you do
package selective projects you'll take a
little bit of time but we can go ahead
and
check revealed at him finder I'm going
to the binary folder release we it
should display an apk up here as soon as
it's packaged you'll notice because one
of the top things there will be very
much larger than 10 megabytes it's kind
of interesting right because we see here
that will mono Android is ten megabytes
which is kind of a lot for is bundled
with an app so now we'd introduce this
APK file here it's 21 megabytes I'm
gonna rename this did you know that an
apk is just a simple zip file you can
say you sip we can unzip this is anyone
deployed a Simon application to Google
Play few of you did you know that all
your assemblies are available groups
inside the inside the apps so we have
all the assemblies here it bundles
everything that we have in our
applications we can see that we have my
demo one or droid DLL so if I bring that
down to my computer I could inspect all
the code if you try to reflect or any
other tools like that before it allows
us to just browse the code pretty much
the same way that we wrote that in our
in our environment so I noticed this
when we were talking about how do we
appreciate the code in our applications
I was looking at all these different
obfuscation options which is a way for
you to kind of hide all your logic it's
a way to be you know if your your hat on
you're like I'm afraid of everyone
stealing my logic so what we notice is
that well if bundles all the dotnet
dll's there must be a way for us to say
well I just want to compile everything
to whatever native code there is there's
a folder here called lip which includes
all the different platforms and all the
code for those different platforms so
for instance we have the code for x86
and all that's available in here is a
native code for mono so I want to grab
all my code and I want to somehow bundle
that into the native code and get rid of
all those dotnet assemblies and the way
that we do that is by simply changing a
few things in our project so I'm gonna
edit my CS proj
and I don't know these by hand so we'll
explain them the first one is going to
say well I don't want to use a shared
runtime because you always want to turn
off turn on turn off the shared runtime
for your production applications we're
going to turn on multi decks which is a
way for us to allow us to write
applications that are a little bit
bigger you see a little bit more
references in the app especially if
you're using dotnet standards gonna
bring in a whole lot of dependencies if
you don't have multi decks on you'll
have problems compiling the app it also
allows you to turn on things like
ProGuard which is a way for you to
protect your code anyways you also want
to turn on packaging of the application
so I don't have to do the packaging
myself so I'm gonna put that up here in
the first property group and then
there's one more thing that I need to
add there's a little bit of more code
here it's going to say that we want to
link all the SDKs it's going to say that
we want to embed all our assemblies into
the apk it's gonna do it ahead of time
compilation which basically means
everything is gonna be native code and
then there's a few other options as well
that allows us to be even more strict to
say no debug symbols remove everything
that has to do with the debug and again
turn on multi decks for that build so
I'm gonna copy all of that code and if
you're interested I can just give you
this later on I'm gonna put that down
here in the release part and then we're
gonna build the app and you'll notice
that what happens is that it's going to
take a little bit longer because it's
going to do I'm gonna zoom in a little
bit here because it's going to link
everything then it's going to say that
it's gonna do a full out of time
compilation which means that all the
Assemblies that I bring in from
Microsoft and dotnet standard and so
forth it's going to compile that into
native code as well so this process is
going to take a little bit longer maybe
a few seconds longer with this kind of
solution and remember this is a very
small solution right so if we have a
larger project it'll take a little bit
longer than this we had a problem with
our build server I think we ended up
having builds taking 80 90 minutes which
is a long time to wait for an app to
build which is something that we hadn't
noticed when using native
development before so one of the other
interesting things with salmon is that
even you can write the best code in the
world but finding the right people to do
this is really hard so one of the things
that we found in the project while this
is building a little story it's really
hard for us to find people that know
c-sharp as well as now all the small
things in gotchas about the different
platforms so we have iOS and Android
developers that are really good at
building apps for the native platforms
and we have dotnet developers that know
everything about the dotnet framework
but finding the samory people is really
hard so sometimes the way to be
successful with salmon is just not to
use it I'm just joking all right so we
see here that we have the apk it is a
little bit larger than we had before
which is because it had to compile
everything into the app it had to link
everything it had to make everything
native code so I'm going to this time
I'm going to rename the signed version
to the SIP and I can't use the built in
zip tool tooling for for that so just
use another app extract that the same
way I did before and you'll notice that
there's no longer an Assemblies folder
so all the assemblies are gone I have
this library folder here which now shows
us all the difference assembles for the
app and you might see that it says Lib
alt there it's then it's out of time
compiled all of these are called dot SL
files which is the native natively
compiled binaries so with iOS really we
always get this out of the box because
it's natively compiled they don't have a
just-in-time compilation it's good to
have just-in-time compilation on Android
because that means that it can be a
little bit faster in general for the
apps or for the platforms but when you
turn this on it's going to drastically
improve the start up times which is one
of the most annoying things with
applications that take a long time to
start so this here is probably gonna
make your users a lot happier okay and
you don't have to pay thousands of
dollars for obfuscation because it's
really hard to read the native code I
asked someone at salmon if you can
compare this
process here - obfuscation he said well
it's really a poor man's obfuscation
because it's not rewriting any symbols
it's not doing anything weird it's still
the same assembly right so it would look
the same if you look at the native layer
but reading this as c-sharp code is
pretty much impossible at least we can
be happy about that so when you tie all
these things together you talk about the
way that we can share the right amount
of code we talk about finding the right
people and enabling things like ahead of
time compilation that's when salmon
starts to feel really great is that's
when you can build apps faster the apps
are really working as intended and they
work really good on those different
platforms so hopefully you end up with a
situation looking a little bit more like
this here it's still ok that one of the
platforms has a little bit more code
than the others you might have someone
working or loving iOS more so they spend
a little bit more time just fine-tuning
the iOS UI and then you have someone
that doesn't really care about Android
but he's still doing the Android app
right so this way here we can see that
we can still work a little bit in the
native layers it doesn't really matter
just try and share as much code as
possible using these different
principles so how do we succeed with the
app well it's obvious that we need to
build something great we need to have a
good idea of what we're building and we
need to have a customer base that wants
the app and we need to share the right
amount of code which means that we need
to apply patterns that makes it easier
for us we want to try to avoid things
like the service locator and the
compiler directives because that's a way
for us to kind of run into messy piece
of the code and want to minimize the app
size in the demo I just show you showed
you we kind of doubled the size but we
can turn things on like optimize P and
G's on iOS which lowers all the file
sizes of images which is one of the
biggest culprits of our applications and
I think that Google Play in iOS and app
stores they do their best in minimizing
the app when they deliver to the phone
so don't worry too much about the apk
size and of course want to optimize for
speed as well so just to wrap this up
there's a lot of things that we can do
with salmon it's a great tool kit if
you're frightened the right people to do
the job and you know sharing the right
amount of code is really hard but one of
the easiest way to share a lot
code is to talk to each other in two
teams and make sure that you understand
what you're building for those
particular platforms before you leave
here I want you to leave a green thing
in the box HP up on Twitter if you want
a free book right thank you so much I'm
Philip Ekberg</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>