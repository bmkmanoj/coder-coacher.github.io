<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C# 7.1, and 7.2: The releases you didn't know you had - Bill Wagner | Coder Coacher - Coaching Coders</title><meta content="C# 7.1, and 7.2: The releases you didn't know you had - Bill Wagner - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C# 7.1, and 7.2: The releases you didn't know you had - Bill Wagner</b></h2><h5 class="post__date">2018-02-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IF1aPR6da3A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">see a few people still kind of streaming
in just a little bit so I will go ahead
and kind of start with a little bit of
the introductory stuff and what we're
looking at with 7.1 7.2 which you
already have and if there's time I'll at
least list the proposed features for
c-sharp 7.3 know what I said proposed
and I'll show you how to track those so
you know what will and won't get
delivered and if there's really time I'm
gonna give a brief preview of one
c-sharp eight feature that we're looking
really interested to get some feedback
on which is non nullable reference types
so if we get that far we'll go into that
part important thing here if you have
any questions later anything just hit me
on Twitter and I will be happy to try to
answer them I'll show you where our repo
is and you can write issues there the
really big thing that we're looking at
in terms of the language and this is the
latest Stack Overflow it's a website or
something you may have heard of a job I
don't know if you heard John recently
became the first person with 1 million
points for overflow and so I've given up
completely but one thing we like c-sharp
is in the top 10 of the most popular
technologies thank you John
another thing that we're very very proud
of is c-sharp is also in the list of
most loved technologies c-sharp is one
of two technologies that appear on both
lists c-sharp and typescript are the
only two and our mission is to keep C
sharp on both of those lists do
everything we can to make it as useful
as it can and do everything that we can
to make it as enjoyable to use as we can
so let's talk about the idea behind
c-sharp point releases is this was
controversial and still to some degree
is the short version is why wait to ship
cool features so there are three buckets
that we're going to put all the point
releases into c-sharp 7.17 - which
recently shipped 7/3 which is proposed
and you'll see a 7.4 other things that
may ship before 8 so we've got
improvements to local features inferred
tuple element names so John talked about
tuples I'll show you how
inference rules get a little bit better
leading underscores in numeric literals
John just requested that an hour ago and
we've already delivered I think I think
we're do being very responsive a couple
long requested nice-to-haves
the default literal so if you've ever
written expressions default of whatever
you can abstract default and async main
because everybody doesn't wrong so now
we can just write async main and it'll
do the right thing we have a couple
smaller two themes that go into the
point releases reference semantics with
value types which is kind of a catch-all
for a few different features that are
performance related for those times when
you want to use Struck's because you
don't want to deal with the garbage
collector and so on and so forth but you
don't want to copy them because that
takes time too so we'll go into a little
bit of how that's going to work and how
that shift with 7.2 and the kinds of
things you should look for opportunities
when to work with those that's probably
going to be the biggest part of the demo
here we don't have it yet but is John
kind of alluded to there will be more
opportunities for pattern magic may
possibly introduce new content or
introduce pattern matching into new
statements new places where you can use
it and we will almost certainly
introduce new patterns of new ways to
check a sum variable for some pattern
with that let's look at the big idea
that we wanted to do around the point
releases because this means more
effectively shipping a new compiler with
new features in it on a much faster
cadence c-sharp 7.0 came out last March
I think it was we've had two releases
since then right you may not want to
move your codebase that fast to a new
compiler and we understand that so first
of all it's going to be off by default
no matter what by default when you
upgrade Visual Studio you have seven
15.5 15.4 c-sharp seven point always
still how the language is compiled on
your machine ok unless you explicitly
change it
you can configure it in Visual Studio
using property pages I'll show you in
the IDE supported on all project types
whether it be net cord Web projects
console apps or whatever it's all there
or you can just edit the CS proj file
I'll show you how to do that as well
because there's a one kind of ugly bit
we have in editing it through the
property pages that there's a request to
fix but we haven't got there yet
we'll use the line version from the
command line
and finally what you can do is what
we've done to kind of guide you into
where things are changing if you happen
to use one of the newer features that
you haven't turned on in your project
you'll get a little light bulb that says
you can turn this on if you'd like and
upgrade your project to a new version a
big thing about this is that now which
version of the parser and the language
rules that you use is on a
project-by-project basis in your build
file so you can upgrade your machine
whenever you want to or whenever you get
to depending on your work environment
and you can work with projects at
different levels so if you work on an
open-source project and maybe you're not
ready to upgrade to 7.2 yet you can
still continue to compile and work
against a certain language version or
you can work forward whenever you want
so upgrading your machine is different a
different step than upgrading your
projects all right so what's in here
alright one more little bit on just what
we were thinking in terms of this
numbers don't work this way the way we'd
like to but what you should really think
of for seven dots like if you're John
and you're working on c-sharp in depth
is 7.1 and 7.2 our c-sharp 8.0 - - and -
- - what we're doing is we're building
c-sharp oh and shipping it a little bit
faster so the standard which John and I
both work on the stage
it's committee John is the convener
c-sharp five has been submitted to equi
so it's going to be the next official
standard we're going to work on the C
sharp six official standards doc any day
now whenever John reconvenes the
committee seven point one seven point
two seven point three however many we do
make will not be official standards
documents we will do a 7.0 standard and
then the next standard will be seven or
will be 8.0 everything that gets
delivered in 71 72 73 will be in the
official standard four eight do we think
seven point three is going to be the the
last point release I do not have any
information that I can share on that so
the the reason that bill gave sort of
reasons of small bug fixes to features
and small minor themes he forgot to
mention the main reason why they're
doing is is to make it really awkward
for anyone writing a book on c-sharp
seven because you never know when it's
going to be done but you know that was
just I would treat that as su-sure of
eight - - so you can just stop at seven
and then pick everything else up but at
least you can look at it and make sure
your guidance still works that's what
that's what I would recommend now of
course I write for the web so I can just
like whatever I want a bit late now yes
all right so the key thing here is we
want you to choose your own cadence
we're going to ship when it's ready take
the point releases they do have full
support they are releases they are not C
TPS they're not betas they are not
previews they are releases the same
guarantees apply we intend to not make
breaking changes or if we do we intend
to make them extremely carefully and
they're completely totally supported
they will not stop being supported just
because we shipped a new version stay
with the whole numbers if you prefer it
depends on what your your cadence that
you want if you like writing default
cancellation token then you view the
point OBU
but you really really want default
literals right okay so what shift in
seven point one okay does anybody
upgrade it already - seven point one
other than Steve who I know has
okay about 7.2 okay so what we saw on
7.1 async main so we can now declare a
task returning or task of intra turning
main method so then you can await inside
that which gives language support for
async console applications why did we do
that we found a whole lot of things on
github where we would see people do some
async method dot wait or something like
that and it's like cool when I just make
this easy default literals as John
mentioned if you really like typing
default cancellation token or default
cancellation token of T that's fun if
not just type default inferred tuple
element names we found a lot of typical
uses for tuples would construct a tuple
and go a colon a b : b c : c some kind
of dumb we knew the names why not just
just use them 7.2 which will be more of
the demos reference semantics for value
types primarily performance-based so
there are two big things about this
feature first of all if you're using
asp.net core you're gonna love this
feature even if you never use it because
the asp.net core team did a lot of work
to speed things up inside core by
leveraging these features for a lot of
the things when they're copying between
layers and the network stack they're not
copying anymore here's a reference to a
hunk of memory look at it differently
move on so we minimize copying with
reference semantics where necessary and
where it works will do things like you
can do things like stack allocations and
so on and so forth to make things run
faster non trailing named arguments
we'll go into this in a little bit more
detail in the demo it works like you
think it should but effectively what it
means is once you've named the first
argument to a method you don't always
have to name the others it just depends
so you can use named arguments purely
for your sake to make sure that you
understand what that argument is meant
to mean which is a thoroughly good thing
in terms of understanding you're making
your code easy for someone else or you
in six months to understand yay and then
leaning under scores of numeric literals
as John showed we
binary hexadecimal and others we cannot
have a leading underscore to separate
the zero b or the zero x or to get them
to a line however you would like
and a new accessibility modify our
private protected which everybody loves
the feature but three releases on no one
likes the name and no one came up with a
better name either so it was finally
kind of a let's just shift this and get
it over with
although an vb they did come up with a
friendlier name it fits the vb syntax
but private protected basically means if
you declare a method as private
protected it can only be accessed by
methods that are from a derived class
and declared in the same assembly okay
whereas normal protected internal it can
be accessed by any method in the same
assembly or by any derived class this is
some of the CLR supported since 1.0
didn't have language syntax for it i
always find the and and all odd because
if you say it can be accessed by x and y
if my credit card can be accessed by me
and my wife then that's less restrictive
than only by me but private protected is
more restrictive than protected internal
although it does work with written
checks in america you get a check
written to you and your wife you both
have to endorse it too casual he's moved
on from checks we have to we try to as
well it is only american banks and
insurance companies heaven alright so
let's actually look at primarily what i
would want to do is and when we talk
about these features being kind of small
is let's take an application and let's
just upgraded from 7.0 to 7.1 okay so
we'll start by just you can see that
what I have here what this program does
is it's a small console application that
calculates or generates 20 random points
in space roughly few thousand units away
from the origin and then finds the
closest one to wherever you are starting
at the origin go
there and then finds the closer one
where your art goes there until you
visited all of them okay I made it a
sink just so I can show this feature so
I'm gonna delete this code know a little
bit because there's really nothing
anything going on here but the main
method this would actually be the
correct way to make a main method in a
console application wait so we're gonna
call the waiter and then get its result
which then goes through the state
machine correctly and ensures it doesn't
block what we found looking at a whole
lot of code out on the web or out in
github and other samples is we would
find people do something like that which
can deadlock so I I'm confused about
this because all right I might use
result if it returned the task rightly
so there's no synchronization context in
a console app so isn't if the task needs
wood not gonna go on the would not in a
console application before a saml-based
app there we go right and you have a
main method in example based app so only
sometimes which is really cool
so what we can do now in c-sharp 7.1 is
I can declare that this main method
returns a task and because it is we
returns a task I can await I mean do
that and if I'm going to wait I have to
declare it as an async method and now I
get that now if you look I already
upgrade this upgrade this so we'll just
slide over to our
property pages I think our last practice
Rd I may have already upgraded it's all
right no one can tell with that phone
telling me that's right believe the
magic we will leave the magic so
normally what you have here what you can
see here is or what you can see here is
it says C sharp latest major version
which is the default I can't read it
from here either
I've memorized the order my eyes are
worse than yours you can pick either C
sharp latest version minor so you would
pick anything that you want you can also
pick anything all the way back to C
sharp one if you wanted once we
implement this I don't recommend that
you know but don't expect it to apply as
if it were using a C sharp three
compiler or whatever so there are some
aspects it uses the right grammar but it
may apply a slightly different overload
resolution or there are some things that
don't quite work so don't assume it will
behave exactly as parallel why don't the
demonstrate this and I keep forgetting
it all right so this is legal C sharp of
course even with C sharp 7 oh I go build
it I will get an error at compile time
which is in really tiny fact fine but
it's important it's this program does
not contain a static main method
suitable for an entry point because I
compile the 7.0 okay this is the only
place where the tooling doesn't really
help you in the way we'd like it to
because this is perfectly valid C sharp
even before C sharp 7 1 it just isn't a
valid entry point before C sharp 7.1 ok
so we don't have an entry point so if
this is the one feature that you use
this is the one to look at turning on
now we can also do it as I said just
inside the by editing the CS proj file
so I just made it 7.1 and now if we
compile it should compile cleanly and we
now have an async main method awesome
okay so that's the only one that you
won't get intellisense for to tell you
hey you're using a new feature please
try to do something different well now
I've already upgraded to 7.1 one nice
thing that shows up right away is those
this right here in the Select statement
I have one of those where I'm saying you
know I'm grabbing these three points as
they generate my random things that's X
is equal to X Y is equal to Y and Z's
equal Z and I had to do that in 7.0
because it's the only way to get the
semantic names I wanted for my x y&amp;amp;z
coordinates briefly are you other ways
done with async main I am otherwise
nowadays anyway what happens if we you
know having an async method that just
awaits is kind of boring what happens if
we just have you work a sink that should
work mm-hmm that would work
cool I did not know that
hmm this is still returning it out it's
just returning a different test instead
of a waiting wait so I I can so often if
you're writing a console app that has a
main method and it's just gonna do async
stuff in this word you're gonna write
that and this would especially be true
if you already have an async method
there's a console application yeah okay
right so here since I'm not using this
feature one of my light bulbs now says I
can switch this to just using x y&amp;amp;z and
I will still have the same semantic
names down below you see where I'm using
x y&amp;amp;z it's still perfectly valid code
because we have those literals anyplace
we can infer the names of tuple member
names we will do that okay okay that's
he's still using anonymous types under
the hood for all the let X let Y let Z I
think it's probably doing a select and
building up stuff I would have to look
at the IR yeah it's a shame if say
when we look at the ILO right an issue
if necessary all right
two out of three there and then finally
the default literals which is a seven
point one feature one of the methods I
have down here that we'll get to in a
little bit more detail as we do some
performance here I'm just passing saying
well as I calculate the distance my
default would be the origin because the
default for a struck type is zero zero
bit pattern that's the default I no
longer have to write the type so cool
and that's not just for default premises
optional parameters right can do int x
equals default or past default as an
argument something it's kind of cool yes
anywhere any place you previously needed
needed to write default of some type
just write default life is good so long
as it can infer the type you're good yes
all right seven point two I'm gonna do
this one last cuz it's the one that
takes the longest not on trailing named
arguments this is one of the things that
I truly hate in terms of trying to get a
standard write and I still don't know
how this one slipped through but
argument null exception and argument
exception have the message in the
parameter name and opposite orders which
is incredibly dumb I don't know how that
happened so I always specify the names
just because then I always get them
right so now with now named arguments if
I want to I can no longer specify the
second one I only need to say all right
name all this first that's a parameter
name and I'm gonna guess that's probably
the message I think I must have put it
in the opposite order then oh now I'm
getting my intellisense that says you
know what you didn't need to upgrade
this project to 7.2 so we'll go ahead
and do that that make sense now I've got
72 because by the time you know which of
the two arguments means the parameter
name it's pretty obvious that that is
going to be the message and now this is
one of these features that we have a lot
of fun documenting and describing the
very short version is it works the way
you would expect
okay yeah the slightly longer version is
here what the rules are as long as every
named argument that you give is in the
correct position and the right number of
arguments follow after words that match
the proper types then I can omit the
argument names on any future arguments
okay
however if I switch the order of these
and I did message first I would have to
specify the second one because it's not
in the right position anymore okay if
this had multiple overloads and it could
be multiple different methods I would
have to specify the names so you can
only use this feature if you are using
pretty much only for clarity on some of
the argument names as soon as something
is not in the right position then you
need to specify names everywhere okay
the good news is that the bit of the
specification for overload resolution
that will need to handle this is already
broken even without this extra feature
in both the Microsoft spec and the atma
spec because we couldn't get it right
you clearly haven't read this suspect
for a bestest betterness yet have you
don't know so one of the c-sharp seven
three proposals is to make that a little
better okay so that's that's named
argument so again what it means is when
you're using this just for clarity you
can simplify it and only specify some of
them leading underscores pretty simple
you can just specify I can put
underscores in here if I want to make
these all on four bit boundaries yeah
cool nobody ever applause that feature
except for like I asked for this at
mocks boarding house which is a play
board games and have dinner at the same
time I ideal place back in Seattle a
couple of years ago yes Oh doesn't it
work oh well make sure it doesn't
finally it does yeah okay
and then probably protector don't even
get a devil all right so now let's get
on to ref
reference semantics with value types
because what we want to do is try to
write code this more efficient now I
need to preface this demo by going this
is a demo this is kind of small really
showing syntax if you want to go down
this road start doing some benchmarks
because you will either make your code
faster or you will make it slower which
it is depends on sizes and memory
pressure and a whole lot of different
variables so you are going to want to
measure this or you may make it faster
on 32-bit since it's lower than 64-bit
it is indeed possible as well so you
want to do a lot of measurements on this
so suppose we did some measuring and I
look at this this method here in this
point 3d structure is a struct there so
it is a point with three doubles doubles
are how big John 64-bit 64 bits so this
is 124 bytes
24 bytes so more than I really want to
throw on the stack all the time
especially I don't need to and I'm not
modifying it so I have this in here now
what I would have to do before if I
really wanted to make this faster and I
said you know that that whole stack copy
thing is really really annoying so what
I want to do is I want to pass this by
reference so I might say something like
like in earlier versions I could pass
this by Rath okay and just promise you
know it's Kelvin said in his talk that
I'm going to promise that I don't modify
that in my comments and that should be
good but if I wanted to do this where I
have a default value I could not do that
because you cannot put a ref modifier on
a default value because the compiler has
to create something and do something for
it
well the new modifier is in so I can now
pass both of these by reference as in
arguments
and bypassing them as in arguments what
I've told the compiler now is I am NOT
going to modify those values inside that
method but please pass them by reference
which is either 32 bits or 64 bits so
smaller than my structure and I promise
I will not modify them in fact the
language will enforce that I will not
modify those values inside that method
presumably if the point 3d that you pass
in is actually on the heap then
something else another thread could
modify it so you could observe point 1
changing its values that is even
impossible yes because it would be a
reference to that other thing scary
action of this distance but yes they
don't do that okay so now we've got
those passed by reference now if you
notice this code up here continues to
compile even though it's passed by
reference here or I call calculate
distance I don't need the in modifier at
the call site ok because we said you
don't really need to know that it's just
a lot semantically it would be just like
passing by value nothing can change ok
so you have not had to change the source
code of the calling right what if
they've been in different assemblies and
this have been a patch release that you
put in modifier in this is a very
important thing as you read any of the
specs in the documentation when we talk
about these features we are going to
talk about a binary breaking change and
a source code breaking change this
feature can introduce a binary breaking
change if you add in on your public
methods deliver a patch and ship it
anyone that uses that assembly has to
recompile because their call site is
going to be passing by value and your
method now inside your assembly is going
to be expecting pass by reference ok but
it is not a source breaking change
recompile anything that compiled before
will compile now ok
so we're gonna make that distinction but
now that's not a language breaking
change if you don't change any of your
code it's still gonna work right so
we're not gonna do anything by default
pass things by the reference okay
but a great question and thank you for
documenting it I expected you to ask
something more interesting about this
feature down here
go on I conquered divine witch so so
there's an interesting finger these are
now passed by reference right inside
this I could call member methods of the
point 3d type and you're using a
property already and I'm using a
property now I'm using together so
there's a high probability that the
getter doesn't change the structure okay
but the compiler can't absolutely
guarantee that you could write evil code
to change state inside a proper together
or inside any method and instruct so I
am still copying both points here
because I am calling member methods of
it so it's going to make a copy of it
and then pass it by value inside here
because it can't guarantee that it's not
ever gonna change okay and this this can
have a real performance difference I
noted this in notice I'm where I have a
bunch of fairly large structs and I have
I use compositions so local date/time
consists of a local date and the local
time and I had to make those fields
writable fields even though I never
wrote to them to stop the compiler from
doing the copy and I'm I feel so happy
that the bit on github the page that
explains the purpose of the feature that
bills about to explain and refers to the
blog post where I talk about doing that
it's like yay directly responsible for
feature so the way I would fix that
correctly now is if I go to this public
struct and if I say it's a read-only
struct I have now said that this is
immutable I mean it already was but now
the language compiler can say you have
promised that there is no method in here
that changes state it's not allowed okay
so if I were to write a new method here
go on a sling to this cuz that's always
fun
you need actual braces yeah thank you
there needs that that way there we go
okay the error now says I cannot assign
to this because it's read-only I could
also not assign to X or Y which right
now I couldn't even see but if I added
another instance property or instance
field in here I could not modify that
either because I have declared that this
is an immutable type no member methods
modify it so we're going to make our
design intent more clear this structure
is immutable it never changes and now I
can pass it using in by reference to
methods because I never modify its state
therefore we can pass it by reference
save some allocations save some stack
space save some copying hopefully we get
some performance improvements out of
that in different conditions okay just
to be clear without the in so you see
you saved one copy in total because
before you had in it would copy it when
you call the method mm-hmm but then
wouldn't copy it when using the
parameters because we haven't claimed
that the parameters aren't going to
change value so if X happens to assign
to this then hey so be it so it's not
that there are two orthogonal savings
there's one saving that requires both
pieces correct in this particular
depending on your usage right so if I if
what comes in is all immutable you're
already all right okay so that's the
first part or if you never call member
methods on something now let's get
the part that really gets to be fun here
so I'm gonna take out some of my icing
stuff because we really don't need to
worry about a sink right now so I'm just
gonna do this noise like that void again
I even saved you having to remove a sink
yes and now remove that so this is now
all synchronous because we're really
because some of the features I'm gonna
show now can't be used in a sink methods
because they pin memory they do some
things there safely
so that we can work with memory and work
with it as though it were reference
semantics even though we're looking at
some value types called opposed it's
quarter past perfect this should work
then I may even get to show the really
fun feature all right so now let's say
instead of this innumerable 3d of points
I'm going to use a new type down here
I'm going to use span of 0.3 D span is a
struct type so now my entire collection
is a struct okay I don't want to copy
right now it's only 20 points because
this is a demo but let's say this was a
thousand points I don't want to copy a
thousand points that's ridiculous that's
really gonna be slow so I'm going to say
well this is clearly an in parameter
because I'm not gonna muck with it so
now I'm passing a reference to this
memory that's declared somewhere outside
and this is a span it's now we don't
it's now effectively read-only copy of
this struct but it's not a copy I'm just
looking at it and aliasing it different
I can't use for each anymore now but you
know I can use a for loop I'm good with
that
that and this now is points so index
well it's a struct so I don't really
need to check for null anymore there we
go now I need to somehow change this up
here to deal with the fact that I've now
got this ban and this is the part that
would actually get faster even than the
small program you look at the way I
wrote it originally
I made this select statement I copied
them to a list so that's a list of
points and then with each iteration I
remove whatever point was closest so I
just shrink the list by one reallocated
do some compaction the garbage
collectors working like mad and then go
through the loop again with size one
smaller since I'm now working with this
span I need to start with an array so
I'm going to start with some fixed
storage that I know how big it is and
then instead of removing items out of it
I'm just going to sort them the first
time I find the point closest I'm going
to take whatever's in the zero width
element and whatever I find is closest
swap them and then I'm going to start at
the first index and move forward and
just do the remaining 19 find which one
it is swap them and move on so the way
I'm going to do that is I'm going to
save our start index it's going to start
at 0 my while loop now is while start
index is less than once that length it's
still a list of moments I know I'm gonna
change that to an array here
and then here we're going to declare a
new span normally I just use var and
we're gonna say my slice is a new span
and I have to give it some storage that
I'm going to span my span is going to be
using points and then I'm going to use
the overload of the constructor that
says where do I start
so I want to start at start index give
it a type argument oh thank you there
are other overloads that would take a
sub span of only you know slice 5
through index 10 or whatever I want so
I'm now taking this this look into this
array so this array is this big and I'm
taking a look into it of whatever I want
on each iteration and now I'm going to
pass a reference to this structure
that's looking at the internal storage
of the array but not copying it and now
I'm gonna work inside with that internal
copy with that internal view of the same
variable so I need to change a couple
things now obviously I can't since I
can't use remove at here that's bad
now I have to do that swap well I've
already figured out where the start
point is it's from that closest point
dot index now what we need to do is I
need to say that slice so 0 is start
before I do that I need to go that
points this is how going to say slice
and I'm going to say slice so closest
point dot index is now equal to slice
sub 0 all right and then slice of 0 is
there boom so I've just done swap and
then since I finished that now we're
gonna do start index plus plus oh ok
you're currently still passing in points
to point closest and it's not
complaining
is there an implicit conversion from a
raita so and actually there is and thank
you because that would make an infinite
loop really bad things happen because
I'm passing the wrong thing so this now
needs to be my slice thank you for
catching that there we go
let's G on over my shoulder there we go
I have another question yes so you're
taking in a span of point three D and
you're taking it in yes is there any
difference if you accept a read-only
span instead of a span because you're
not using the fact that you can assign
two values within that you should still
work capital oh I think Apple oh yes
sort of feels like we're specifying this
right not matter of modifying the span
either cool so the theme of that is
we're gonna try to get things a little
bit quicker hopefully do some stuff that
enables you to do high-performance
things in c-sharp get c-sharp closer to
native where we need to this is going to
be this is already being fairly
extensively adopted inside asp.net core
where you measure it should be cool in
your your applications as well related
types we saw span and span of T or span
and read-only span there is also memory
and read-only memory which lets you look
at things as a buffer and the same
syntax applies conference being that
memory isn't a stack only type whereas
Bonnie's I believe that is true right
yes I'm were you going to mention that
span you can't have a field of type span
connector thank you this actually the
other thing so span is a new special
type of syntax called of ref struct
which means it cannot be a member of a
class because it's meant to refer to
some other storage that other store
should be on the sack so I can only span
things I can only spans something that I
already have allocated so I can't assume
we can be a field within another ref
struct yes you can
right so so I can pass to please must be
on the stack and that so I can pass
tuples of spans if my method were
written in such a way it could do that
this tuples are structs but I can put a
struct on the heap structures inter
sorry a couple isn't a ref struct so I
wouldn't expect that to work if I've got
a field of that type that should go back
surely a field does yeah but I think it
is but it but a field of I feel the ref
strike let's see now you're making me
think this through again I never get I
never get these hard questions
not here well you do but sort of from
down there normally instead of out here
yes and it's 22 minutes passed all right
and I would want to get to the other
stuff so we pass in definitely make it
return
nice - so I'd expect that to be okay but
you couldn't have that type that tupple
type as a field in a class or a regular
struct correct but it could be a field
in another restaurant yes because that's
making sure it's right ways on the stack
right okay so well one thing that's
interesting to note sort of meta
discussion is Eric Lippert the great
Eric Lippert once wrote a series of
articles called the structure sorry the
stack is an implementation detail and
basically that's not true anymore
because a lot of language semantics are
about when is something on the stack
versus when it might end up on the heap
and so it becomes really front and
center in the language if you're doing
performance ii kind of thing so I
suspect I may never use span what's that
doesn't that feel at one time what a way
would it Oh what I just did right now
yeah what's a default yeah that's going
to be bad it's a default of because you
can read so long as you don't put that
tupple on the heap yeah that's fine the
type itself makes sense
but you can't use it as a field in a
class you could use it in a field in
another ref struct because that's never
gonna be on the heap you could use it as
a local variable of added and non
iterator method so the very short
version here is as you experiment with
anything with spans and memory the
compiler will tell you when you're doing
iraq which is one of our big which truly
is one of the big features we want to do
here this is all about performance it's
all about doing some things that might
be dangerous and providing some language
syntax to go it's a lot less dangerous
than it would have been earlier where
you would have had if you use pin memory
and remember it all yourself and do
those things and occasionally it's more
conservative if I am if I remember
rightly envisioning more conservative
than it has to be when I was talking
about local methods before I mentioned
that in various cases you can capture
local variables of the enclosing method
and the compiler just does stuff to
avoid ever having to allocate on the
heap I believe you would still have
trouble using a ref struct in that
situation because okay it's sort of an
implementation detail that it makes a
another struct and passes that by
reference since we do you I'm gonna do
this one really briefly because the last
slide I just want to read them off so
this is a preview of c-sharp a we're
going to talk about nulls we think he
really low-balled this number of Tony
Hoare Lord Tony calling it his billion
dollar mistake of adding nulls to
alcohol in 1965 it's been with us ever
since so let's think about our design
intent in the code bases that you have
that you work with right now we really
have two cases that we really want to
support either a reference is never
supposed to be null so therefore I
should always be able to dereference it
safely and that should be fine but I
should never be able to assign null to
it or never be able to let it be
observable in all anywhere else in the
code base or a reference type is welcome
to be null in which case it's all right
to assign null to it or let code observe
it in a null state but I can never
dereference it unless I check first if
you look at nulls in the c-sharp
language or anything in dotnet right now
it could be either one of those which
means we really can't express our design
intent the way we want so the problem
that we have here are the big problems
what we want to do is deal with here we
want to have an expression of intent so
your code expresses the design intent
should this be null or should this not
and then we want the compiler to do
everything it can to enforce that and
enforce that without just being so noisy
that you turn it off within an existing
language where there are literally
billions of lines of c-sharp code many
of them are well tested against null
probably because they've thrown all
reference
exceptions if you note the most
referenced exception type in all the
dotnet code bases on github is the null
reference exception by more than two to
one of the next net closest one so this
is clearly a common common thing which
now gives more diagnostics in certain
cases than it used to if I remember it
so very welcome one idea was what do you
do if you have one construct that could
represent two things
let's introduce two new constructs and
have them mean three different things
now
we threw this out because what this
would mean is the bank can never be null
and the question mark could be not nice
thing is that question mark looks like
nullable value types so that should be
easy the other one okay so it can't be
null
the problem with this is no one would
use it was what we felt you would have
to change all of your code everywhere to
be able to get any benefits so we've
decided to do something that we really
really never ever want to do which is
we're gonna say that every place you
have declared a variable of a reference
type you meant that not to be null you
really did you may not have known it but
that's what you meant and we'll help you
enforce it if you really mean for
something to possibly be null we'll put
the question mark there or you should
put the question right there to express
that intent now the problem with this is
existing code bases if we made this an
error type enforcement would just be
littered with errors and a lot of
problems and people would turn it off so
we're not going to do that we're gonna
make this a warning so let's look at a
code base I'm going to pull up the this
code so I have a friend up here I don't
know if he has a middle name or not so
I'm gonna make a new person initialize
it with his first and last name and I'm
gonna call this method called get length
of middle name
where I see I'm gonna assign a variable
to person got middle name and return its
length okay a small sample that looks
like code we may probably have elsewhere
in the world
and when I run this it does a null
reference exception because I'm trying
to get the middle name and I never
initialized it which is also something
we probably see in the wild in our own
code base on a fairly regular basis so
now let's look inside this name so I
have pretty much what we talked about
earlier I have this first last and
middle name and they're all listed as
they were not null so you see I have
these green squiggles under the first
person constructor which is telling me
that a non nullable string is not
initialized so therefore that's bad so I
get a warning well way I would fix that
warning is you know some people do not
have a middle name so we'll declare that
saying that that can be null
that's good now there's no warning here
awesome and now if we look in the
program where I was doing some nasty
things you see that now where I'm
looking at P dot middle name well that
could be null so I can't can't do that
so what I could do is if I say it's
either P dot middle name or the empty
string
okay now that got rid of my warning
because now it definitely gets assigned
to something that's not null right so my
warning would away there are multiple
ways I could fix this of course I leave
that here I could make this at that and
then I could say return either middle
name question mark dot length or 0 all
right so now I'm only do you referencing
that if it's not null so what we tried
to bake into the preview is in as many
ways as possible we're going to see if
you did actually check for null and if
so it's safe to you something if it was
a nullable thing there's a few that we
can't get go ahead I'm just so we've got
two references that we're dereferencing
here yes I know are you about
no no okay so what if I am so if date
time dot now dot minutes if we should
have finished then it'll be null
otherwise that yeah so now we have that
and presumably if we do this then the
does the call stop complaining hurry
yes so yeah it's not just at the point
of dereferencing it's waiting you pass
things in or I'm just going to do this
instead actually it won't let me do it
up there so yeah we'll leave that as a
question mark and then I'm gonna say
well I just no better get over it so I
like that this is all this is that that
exclamation point is colloquially
referred to as the damnit operator which
means it's not null damn it
and the reason we have it is as I
mentioned down here there are some
things we can't tell if we've checked it
or not so if I were to let's move some
of this out this and if I were to say if
not string or if there's no more empty
of PML lame this is an instance where we
can't really check okay because if you
look at this this is just a method call
the compiler can't statically know that
method call actually does check for null
this name is pretty obvious even if we
do it with the local so nope nope move
that well nope right there nope middle
name
yeah so yeah otherwise p-doped middle
name could have returned nan not on them
know if it's here it is evil here it
works fine because we don't get the
squiggles anymore because string is
declared locally is a non null string we
only get it on the assignment right
where the air is but we sorry
they're right so yes that's still broken
yeah and in fact this is where some of
this will catch up by the time we get
there that's now considered a knowable
strain the preview because it's taped to
strength which will clearly change by
the time something like this ships so
they'll fix the first quibbles but not
the second right cause the compiler
doesn't know that is no Lauren T returns
true if and so a couple things here if
you look there's a blog post here on
nullable reference types in c-sharp if
you just search for inaudible reference
types in c-sharp you will find
directions to install the preview if you
want what we're looking for here
primarily is feedback on a machine that
you're find installing a preview on try
to install something and just see what
it does on your code base and see if you
like the kind of guidance it tries to
give you we're trying to make this find
things that can fix places that I would
expect to find I'm sorry
there will have to be changes in the
framework for different any place where
a method expects or takes a reference
type and expects that could be null it's
going to need the question mark on it
yep yeah
yeah okay so here are some of the things
that are proposed for c-sharp 7.3 a
little bit more referee's features
you're seeing sort of a theme of
performance around here ref local
reassignment ref this for extension
methods right now you could write an
extension method this braf something
it's going to be standardized as ref
this and that would be the only one that
works in verses a bivalve tiebreaker in
my demo you saw I just changed the
argument from value to in right now if I
were to make a new method one which took
in and one which took it by value in 7.2
that won't compile because those are
introduces an ambiguity in 7.3 my value
will win and then you would have to
specify in at the call site if you
wanted that one okay more generic
constraints on the proposal list is an
enum constraint this thing must be
needham a delegate constraint this thing
must be a delegate type excuse me and
Abe little constraint which again is
performance related this thing must be
all value types such that if I copy its
memory I effectively copied that struct
so that's what they mean by belittle a
memory by byte by byte copy will produce
a copy tuples will support the equal and
not equal operator this is another one
that's really fun to dive in and
document the short version is it will
work the way you think it probably
should the long version is the only
conversions that are allowed is a
lifting conversion to a nullable type
either on the tuples themselves or on
the members of the tuples and the names
of the members of the tuple don't matter
and don't don't participate in the
Equality test so a tuple of a B and a
tuple of XY that are both intz they
could be equal if they have the same
values and then slicing arranges which
would allow pretty much the syntax for
each bar n in one dot 100
I'm sorry that was a spend
yes that was a span so that will work
different than this this is something
different I believe it might be two dads
it may be increase it I'm sorry span
implementing ienumerable I I don't know
of that that would be less a language
feature than span implementing
ienumerable
so be more of a framework feature or a
library feature but you could use the
for each as a nicer way of writing a for
loop than for int I equals 0 and last I
saw on Twitter the weather the weather
100 includes a hundred or not is still
open for vigorous debate right other
ones native number types again
performance if you look right now every
numeric type in c-sharp has a defined
size in the language this would
introduce a type an int which would be
the logical integer size for the CPU on
which the code is running ok similar to
C and such expression variables in new
context you'll be able to use expression
body members and expression initializers
in places you can't now things will just
start to work that right now the
compiler slaps you about that's a lot of
where this one comes in and finally
attributes and auto implemented
properties right now you cannot assign
and/or attach an attribute whose target
type is a field to an auto implemented
property this has already been merged so
this one will be delivered what this
allows you to do is you can attach an
attribute if it targets a field and you
attach it to an auto implemented
property the compiler will attach the
attribute to the compiler generated
backing field for that auto implemented
property which I think the mono compiled
is done for quite a long time
have accidentally every set of resources
this would be a reasonable place to take
a picture and see the things that you
would want to look at for this I'll
leave this one up for a minute and then
we'll show you just a couple ways to
track where these features are coming
and participate you just you were just
ready there we go I'm sure you can treat
to attack late right okay a couple
different things to look at on the DAX
repo there is a project which is one of
the links this shows everything that's
planned for c-sharp seven three and
seven vb 15.6 if it's in the to-do
column it's already been merged in a
master and barring something really
amazing will get delivered i'll probably
start working on this soon if it's in
the proposal column it is still being
worked on and may get some changes so
I'm not writing these just yet what no
just think I mean it yeah it's in the
open we're gonna do that no it's it's
fun trying to write about things that'll
set in flux if you really want to track
things carefully the c-sharp lang repo
is where all the discussions on language
features are going there are milestones
for each proposed release so these are
any issues that are being looked at for
seven-point-three and if you look at the
tags you can see how far they've gotten
along the proposal to implementation
process if you're looking to give an
issue you can see if someone has
actually started implementing it it will
point to the implementation of it on the
Roslin repo so this is a way to look at
the things that are being discussed
everything is open if you have opinions
please participate and with that we
pretty much made it so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>