<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>From Dependency injection to dependency rejection - Mark Seemann | Coder Coacher - Coaching Coders</title><meta content="From Dependency injection to dependency rejection - Mark Seemann - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>From Dependency injection to dependency rejection - Mark Seemann</b></h2><h5 class="post__date">2017-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cxs7oLGrxQ4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone thank you thank you all
for coming I'm really been looking
forward to give this talk so I'm
mean that so many of you actually made
it here welcome in if you want to stand
up there's room in the back but I'm just
I'm afraid we're actually out of chairs
two chairs there and you can probably
take them and then pull them down there
if you want to so my name is Mark seaman
and if you want to know more about me
they said you know you could go to block
and play the DK there's an about me page
there and you can read all about me so
I'm not going to spend your time with
that I'm on Twitter at Fleur and as you
can tell this talk is has the title from
dependency injection to dependency
rejection so like five six years ago I
wrote a book called dependency injection
internet and it was published in 2011
and since there is this word rejection
in the title of this talk you may be
expecting that this is going to be some
sort of talk where I finally realize the
errors of my ways and do you no
repentance here and we you know retract
everything I wrote in a 500 pages book
there it's not going to happen I'm
actually pretty happy with the book I
think it was a good book for the topic
surely there were things that I would
change today but overall I'm pretty
happy with this book and I think it
talked about dependency injection and I
think if you are doing object-oriented
programming in C sharp or even in Java
or something like that your dependency
injection is a well-known will
understood and will describe way to deal
with issues of coupling and code
maintainability and so on so I'm not
really going to retract you attract any
of those things but also since basically
that time frame I've become increasingly
interested in functional programming I
started with F sharp and I'm also now
looking into Haskell and other
programming in a functional programming
languages so sometimes people ask me you
know in functional programming how do
you do dependency injection in
functional programming so that's
actually what this talk is trying to
describe and try to answer that
particular question so there's going to
be some some you know back and forth and
I'm going to tell you what other people
tell you and then I'm going to tell you
that that may not not always apply so I
think it's safest to actually start with
the conclusion upfront so that there
will be no confusion so just to
reiterate if you're doing
object-oriented code you know the
Vintage injections is still a perfectly
valid way to deal with coupling
and maintainability issues if you're
doing functional programming if you're
working with a you know non strict
functional programming language like for
example F sharp that enables you to do
impure stuff just mixed in with with
pure stuff as well lots of people will
tell you that the appropriate approach
to dependency injection in languages
like that is something called partial
function application and I'll tell you
what that is when I get there so if
you've never heard about that before
don't worry I'll cover that as well and
it turns out that it's true these two
things are almost exactly equivalent to
each other it also turns out though that
it's actually not a functional thing to
do so just to be absolutely clear I'm
not saying partial application is not
functional but using partial application
to do dependency injection turns out not
to be functional so I'll tell you why
that is as well and then I'll you know
since I tell you that that's not
functional I'd also need to tell you so
what is the functional way and it's
basically just a way to compose
functions so that you keep the pure and
the impure stuff decoupled and still
talking to each other though and so I'll
show you how to do that as well
so that's basically the agenda for the
next 55 minutes and so I think it's it's
reasonable just to start to think about
you know before we get into the
functional stuff just do a brief review
of you know what does it actually mean
dependency injection in object-oriented
code so a rune of yonathan gave a talk
at the Scala conference a couple of
years ago he says well dependency
injection is really just a pretentious
way to say taking an argument and
there's actually quite a bit of truth to
that but I want to talk about you know
why on a certain level he's absolutely
correct and then also on another level
there's a little bit it's a little bit
more involved and then you can write a
500 pages book about how it's more
involved but I'm not going to do that
here it's pretty simple stuff actually
but it's we need to modify that
statement a little bit so I'll show you
that first just to do a review of what
do I mean when I talk about dependency
injection and then we'll look at how to
do this in functional programming
instead so in order to do that I think
it's important to start with an example
so we have some code to look at so
I'll look at the same scenario all the
way through but I'll write it in
different languages and different styles
and so the scenario is my favorite
scenario which is suppose you are being
asked to develop an online restaurant
reservation system and I know these
things already exist but just bear with
me for the sake of the example and
imagine that you have to develop yet
another one of those and you know what
what they work like you go into an app
or website or whatever and you pick a
restaurant and you pick a date and you
fill in a form with your information and
then you press the submit button and
what's going to happen then is that some
the application is going to post a JSON
document to some http-based web service
somewhere and your specific task right
now or our specific tasks you could
imagine is to develop a HTTP based web
service that accepts one of those JSON
documents and handles this request for a
new reservation so just to keep the
examples simple we'll go through five
steps so the first thing we'll need to
do is we we need to validate the
incoming document because it's JSON it
might be malformed but if we understand
what the JSON document says we can now
we understand which time slot is it's
asking about so now we can go and query
our database of existing reservations to
figure out you know how many
reservations do we actually have for
that particular time slot and once we
have that information we can make a
decision do we accept the reservation or
do we reject it if we accept it we'll
save it into the database otherwise we
not do that and then you know we'll
return an a response you know an HTTP
response back to the caller and we might
shortcut in various ways here for
example if validation fails we'll just
return the response right away and not
do the other things and also if we
decide to reject the reservation will
there's no need to say the reservation
if we reject it but we'll still need to
create an HTTP response so that's
basically what I want to do here so I'll
start with a little review of what would
that look like an object-oriented code
and I'll use c-sharp for my example but
I suppose the Java would be sort of
Center you know similar to this so this
example will sort of teach us a little
bit about you know why does dependency
injection look like look the way that it
does and why is it not just taking an
argument
it's taking an argument in a very
specific way so I'll start since this is
object-oriented you know Shashank code
I'll start with a class and using a
framework here call asp.net Web API and
if you have never seen that before this
not don't worry about that it's not
really important for this talk you can
just imagine that it's some width
framework and that's basically all you
need to know so the first thing I'm
going to do here is I'm going to create
a method called post and post takes
something called reservation request DTO
so d0 is a data transfer object just
like in martin fowler's you know
patterns of enterprise application
architecture and it's just the c-sharp
view on this JSON document so it's just
you know a representation of the data
that's coming in as s JSON it's just
turned into an object instead right so
the first thing we want to do is we want
to validate the input so if you do this
the object-oriented way maybe you have
some sort of validator objects and you
can call validate or validate and then
it'll return a message and in this case
the design is such that if the you know
there are these unless it is anything
but empty we consider that to be a
validation failure and we'll just return
in a 400 bad request and you'll notice
that there's a validator object there
that I'm calling and you wonder you know
where does that object come from and
this is what we need to figure out okay
what where does that object actually to
come from we'll figure that out in a
moment I'll just talk you through the
rest of the implementation it's pretty
straightforward now if you're into
domain driven design the next thing you
might want to say is now that I know
it's valid I'll map the DTO into my
domain object and you you know I was a
little bit lazy there so I just called
it art but a stands for reservation so
that's my reservation domain model if
you will and if you're really into
domain driven design you may want to use
this ubiquitous language where you're
talking the same language as your domain
experts and in the restaurant business
you know if you go into a real
restaurant and ask if they have a table
for four people you'll be interacting
with the person called the maitre d at
least in more fancy restaurants it
probably that was the American
pronunciation of a French word I so I
apologize to the French people in here
so you could have a Maitre D' object and
you could ask it whether it can accept
the reservation
and in this design here what we
basically do is we get an ID back so
that's the idea of the newly created
created reservation but if that's null
will return you to 403 forbidden so
there are various issues with this
design like it violates command query
separation and it uses nulls for real
values which is you know not a nice
thing to do but lots of people do this
into shops so I thought I'd just keep
the example realistic there but
otherwise if we get past that point as
well we can just return 200 okay so what
we have here is we have three
dependencies we have the validator we
have a matter and we have a Maitre D'
which are three dependencies so now
we're wondering you know where do these
three dependencies come from can we make
post the method post there can we can't
we just make them make the post method
take those three dependencies as
arguments to the to the post method and
unfortunately it turns out not to be
possible because the post method is
being told this is being called by
convention by our width framework and
you know most web frameworks are
perfectly happy to pull data out of URLs
so in this case the URL is just you know
slash reservations but if it had been
like slash reservations last one two
three and one two three would have been
some sort of ID you know web framework
would be perfectly happy to pull that
information out of the URL as well and
it's also perfectly you know happy to
give me the data that was actually a
part of the body of the HTTP request
there but apart from that you know you
can't really have any other you know
values or arguments that go into this
sort of method call there because
otherwise you know the web framework
wouldn't know how to wire those things
up so we'll need to figure out another
way to pass those dependencies in as
arguments and we can't pass them as
arguments to the post method so we'll
need to pass them as arguments to the
constructor because where else would
would we do that
so this is basically dependency
injection in a nutshell this is called
constructor injection and it's pretty
well described and it's not difficult to
follow at all it's fairly
straightforward but then you might say
but this is a special case because this
is where your code is interfacing with
the framework and our rules that the
theme were framework enforces or
restrictions so surely if we
d bye and look at just the maitre d
object for example now here we can
control what the you know the methods
look like so surely we can just pass you
know dependencies as arguments
or can we so I'll start with the
try/except method here and you'll notice
that it said it's a method that just
takes reservation as input and returns
and inaudible into this output so the
sort of the contract here is that it
returns the ID of the reservation if
that reservation was saved into the
database and if it returns null it means
that we couldn't accept the reservation
so the way we might implement this is
we'll say something like we'll call a
reservation repository read the
reservations for that particular date
and do some all the quantities and that
gives me a number of reserved seeds for
that particular time slot and then I can
make a decision and that's pretty
straightforward I can say well if the
number of already reserved seats plus
the reservation quantities that's less
than or equal to some capacity which is
another number I can accept the
reservation and I could call
reservations repository create and that
creates a new row in the database and it
returns the ID of that new row and I can
return that ID and otherwise I've just
returned null something like that so you
might say well alright so I have at
least one dependency their reservations
repository can can I just make try
except take that as an argument and it
turns out unfortunately I can't because
you know Maitre D' implements this
interface called a Maitre D' and it
defines 5 except to have this particular
shape so I can't just go willy-nilly and
add more arguments to that method
because then it wouldn't compile and
then you can say well but couldn't you
just add you know those extra arguments
to the interface as well and that would
be a leaky abstraction you know because
it's an implementation detail that this
particular implementation talks to a
reservation repository and I could have
implemented this in a lot of other ways
maybe I want to add a decorator that
does locking or I want to add a
decorator that does caching so if I want
to do caching for example maybe I want
to have a caching object that I've read
and write to so should I pass that as an
argument to the function to the method
as well so it's sort of like if I did it
like that you know the argument list
would just grow and grow and I've been
violating the dependency inversion
principle that divide
your clothes principal and a lot of
other things so I sort of need to be
able to say this is the abstraction you
know I take a reservation I want to get
an ID back if the reservation was
accepted
that's the abstraction and all the other
stuff is just an implementation details
so again you know I just need to do
constructor injection because that's
that's the only thing I can really do so
it sort of goes like that all the way
through and it's pretty consistent
pattern and you can ply it over and over
again and that's you know basically how
dependency injection works so so that's
just a little bit of review of you know
what does it usually look like in
object-oriented code and before I
continue on I just want you to remember
a couple of things because I'm going to
rewrite this code in different languages
now so this is a class called Maitre D'
and it has a first of all it has a
primitive dependency on the capacity so
you'll see capacity is just an integer
it's just the number of people who can
eat at the restaurant at the same time
and then I have this reservations
repository but if we break down the
interaction with the repository you'll
notice that I call two methods on that
repository I call read reservations to
get the reservations for a particular
date and I call create in order to
create a new row in the database so this
repository may have lots of other
methods as well we don't really know I'm
only using those two methods you know
some practice I'm sort of having you
know can you know conceptually I have
three dependencies the capacity and
those two methods that's basically what
I have to deal with here right so that's
the review of you know what it normally
looks like in in object-oriented
programming and you know this is what
you can read all about in the book that
I wrote and so on so I don't really have
any particular problems yes with that if
you're doing object-oriented code so how
do you do dependency injection in
functional programming you know how do
you this comic talks about Scala but it
could be anything you don't because
Scarlett's a functional language fine
it's functional how do I inject in
dependencies you write a free monad
which allows you to build a monad over
from any factor did you just ask that
you go myself
I believe it it buff yeah you will find
functional programmers who will actually
give you that answer
that you have to use a free monad in
order to do dependency injection in
function of programming and it's not
wrong it's you absolutely can do that
but you know when we get into monads in
particular free mode as things become
complicated quite fast so fortunately in
most cases I've found in practice that's
a much simpler much smaller
straightforward solution than using a
free moment I'm not going to talk about
free moments at all although it is a
thing you can do I'm going to tell you
how to do things in a much more in a
much less much less complicated way so
if you ask a lot of people who are
already you know expert or not if sharp
for example so if you ask them you know
how do I do to Bennett injection in F
sharp they'll tell you to use something
called partial function application and
then as we will see I sort of told you
this already at the beginning this is a
perfectly it's a perfect it's almost a
perfect analogy to dependency injection
in c-sharp there's a very near
correspondence between those two but it
also turns out not really to be
functional but it works and you know
that's what we wanted to do so if you
can live with it not being functional
it's a perfectly valid thing to do so
show you what that looks like first and
then I'll show you why it's not
functional and then I'll show you you
know what to do instead so now we'll
shift will go move away from c-sharp and
I'll start using writing some F sharp
instead I'm not assuming that you can
read a sharp already some sort of walk
you through the important parts of this
so here's the beginning of a function
this doesn't compile at the moment
because I haven't actually written the
function I've just sort of written the
Declaration of it and so so let's just
stop here and talk about it and so
you'll see that there are three lines of
code here the top ones the green ones
are just comments so the only line of
code that we actually have is the one
that starts with Lett and it has all
white letters for the rest of it
so try except it's the name of the
function and then there are four other
words capacity read reservations create
reservation and reservation those are
arguments to the function so this is a
function that takes four arguments which
is you know bid at the high end I think
but maybe we can live with that and then
I've you know tried in the comments to
describe what are the types of all of
these
things and the way that their job works
that once you've actually written your
implementation then the compiler in
first what the types are so at the
moment the card the compiler since this
doesn't compile it doesn't really make
sense to talk about the type of the
function as it is at the moment but this
is the type of the function as it will
be once I've written all the code so the
way that we read this you can sail on
the first on the first line there it
says int after the two slashes and
that's the type of the capacity argument
because you just read it by position the
capacity is just an integer and it
corresponds to that capacity that I
injected into the Maitre D' object
before if you remember the c-sharp you
know example now the next thing i have
there is brackets begin date time offset
arrow reservation this bracket end the
reason why it's in brackets is because
it's a function so this this is one
argument but the argument is a function
it's a function that takes a day time
offset as input and returns reservation
distance output and the same goes for
the other bracketed one that's this
reservation to int that's also a
function now these two functions
together play the same role as the
repository in that Maitre D' or in the
example that i showed you before
just instead of defining an interface I
just broke out it broke them out into
two functions because it's a more you
know lightweight way of you know
approaching the problem you don't have
to declare a new type I can just say
these are two functions and then the
last argument the last input argument is
the reservation we're trying to figure
out whether we can accept that or not
and then on the next time you can see
the return type of this function it's
going to be into option which is sort of
you can think of it as the same as an
honorable end but just options in in F
sharp which is a much more sane approach
to to model you know values that may or
may not be there because they're
actually type safe whereas nulls not now
doesn't have a type so it's a way to
stay sane and still think about values
that may or may not be be present right
okay so the implementation is pretty
straight for what is basically follows
the same steps as you saw in into sharp
first we'll try to figure out what's the
number of already reserved seats so we
do that by calling the function that was
passed in as an argument with the
reservation date
and then we do a sum over the quantities
now if you've never seen this vertical
bar and the greater than sign before
it's a pipe it works just like pipes
work in bash or in PowerShell so have
you ever done scripting like that it's
basically the same thing it means take
the value on the left hand side of the
pipe and use that as an input value on
the on the right hand side of the pipe
so in this case I'm calling Reed
reservation with the reservation date
that returns a reservation list and then
I use the reservation list as input
argument into list at some pie that's
basically what it means and you'll see
this over and over and over again in F
this is something you know it's
basically the the simple of F sharp
almost so that gives me reserved seats
that's an integer now I can make the
same decision as I did in in C sharp
where it's just say well you know if the
reserved seats plus the reservation
quantities that's less than or equal to
the capacity I can accept it so I've
just said it's accepted to true and I
call create reservation which is the
other function argument and that returns
an integer and I just type the integer
into sum which is one of the cases that
options can have if I decide not to
accept the reservation I've just written
none so that's an option and that's
really all there is to it and then you
may say well but that's not really
that's not really equivalent to the
Maitre D' object because how do we
implement or how do we tell you know if
we have a real application how do we
actually connect that with a real you
know some code that actually talked to a
real database so let's try to look at
what that looks like so if you remember
the interface the IMA 2d interface that
I showed you before define a method
called
try accept that takes a reservation this
input returns inaudible in this output
so I'm aiming for the same shape of
abstraction here I want to take a
reservation as input return an option as
output so what I want to do here is I
you know I write a new function called
try accept composition because it's just
a function that composes the other stuff
so first I need a read function so if
you imagine that I have a DB module that
contains real you know code that
connects to my sequel server or Oracle
or whatever that might be you know
that's that's actually a function and
that's the
function takes a connection string as
input it takes a date/time offset as
input it queries into the database
identified by the connection string it
queries my reservations table for that
you know all the reservations in that
date/time offset and returns all the
reservations that are in the table there
so you'll notice that this is a function
that takes two arguments and returns a
reservation list now what I can do is I
can call this function with one of the
arguments I can call it with the
connection string and the return value
of that is another function that is
waiting for the remaining arguments this
is function applicated that this is
partial application this is all partial
application is you just instead of not
this is not really possible to do in
c-sharp but here you can do this it just
call it with some of the arguments and
you just get a new function back that's
waiting for the arguments you didn't
supply so that's another function and
this function has the shape that we want
it to have and you can do the same thing
with the create function you can say you
can party the apply DB to create
reservation and you get a function that
takes reservation and returns the ID of
the new row that it created and it
actually talks to a real database and
now you have all the information or
almost if you're hard code the capacity
you have all the information you need
you can call try accept so I just
hard-coded the capacity to the
restaurant to be 10 because 10 is an
easy number to think about this would
obviously mean that it's a very small
and intimate restaurant but you know
that's besides the point so this is a
call to try except with all four
arguments passed in and this is the last
expression in my function and that just
means that that becomes the return value
of the function so try/except returns an
INT option which means that this
function also returns an INT option so
that's basically how i can compose those
things together now one of the things we
might notice though is that try accept
composition this function takes a
reservation as input and it passes the
reservation as the last argument to try
except now if we have that situation
where we have the same value or the same
argument on both sides of the equal sign
and they're both in the last position we
can perform something called an e2
reduction which means we can remove them
this is just almost like when you do
equations in mathematics you can also
sometimes you know
cancel things out if they appear on both
sides of the equal sign so now it looks
like the try composition is not really a
function anymore it looks like it's a
value but if you look at what the value
is
it's a partially applied function
because it's the function calling to try
except with only three of the four
arguments that try/except needs so the
return value of that is a function that
is still waiting for you to supply the
reservation so this is exactly
equivalent to what you saw before now
the reason why it's interesting to
perform an e2 reduction in this case is
because f sharp is a dotnet language and
it means that it compiles to IL which is
you know the intermediary language or
the intermediate language that net uses
and what you can do with the IL is you
can D compile it into c-sharp if you
want to understand what's going on so if
you do that you get something back that
pretty much looks like this I had to
clean it up a little bit because it came
back with the lots of attributes also
but basically what you get back is
something like this you'll notice it
composites it's a class the class has a
weird name it's actually not valid as
it's not a valid c-sharp name but it is
about the il name so this actually works
it's a class the class has class fields
that corresponds to the capacity and the
create reservation on the read
reservation functions the class has a
constructor that takes those 3 arguments
and assigns them to the fields and then
it has an Evoque method down then the
button that composes all of those things
together its constructor injection
you know partial application is the same
as dependency injection in dotnet it
even sort of compiles to the same sort
of code so the people who tell you that
in order to do dependency injection in F
sharp you just use partial application
are absolutely correct because it is the
same thing now the only thing that
remains - to investigate then is you
know it's a functional so you might stop
right here and just say well you know I
don't really care about that I just
wanted to work and this works so you can
absolutely go and just keep it at that
and then start using from you know F
sharp and do dependency injection with
partial application and all will be you
know in general as good as we you know
it was into sharper dependency injection
so that's fine but if you're really
interested in sometimes in learning you
know whether it's really functional
because if you want to learn you know
what does it actually mean to write
functional code we you might be
interested in investigating whether this
is the case or not so in order to answer
this question first and foremost we need
to establish you know what do we mean by
something being functional and it's sort
of like when you ask people about you
know please give me a definition of unit
testing you'll get all sorts of
different answers and some people will
always you will always find someone who
you know violently disagree with what
most people this you know agree on so
you can't really get any sort of
consensus and I think it's a little bit
the same with functional programming you
can't really get you know everyone to
agree on a common definition of
functional programming but I think if a
pretty mainstream one is that functional
programming must have an emphasis on
something we call pure functions because
pure functions have lots of good
qualities that we that we like them for
they are easily composable these reason
about the easy to unit test actually and
lots of other things so and so first of
all we need to talk about okay what does
it mean that a function is a pure
function and it means it has to need to
have two qualities or two properties the
first of them the first of these
properties is that it must return the
same value for the same input in other
words it must be deterministic and all
you know if you've ever looked at you
well all of you know basic maths so you
know that you know two plus two is
always full it's deterministic and two
plus three is always five and so on you
know madam at mathematics tend to be
deterministic but it doesn't have to be
constrained to mathematics you know if
you want to reverse a string you know if
you take the string through and reverse
it you always get back if we've strange
if sometimes you know something else
happened that's a deterministic
operation as well but just to be
absolutely clear when we're talking
about functions being deterministic
we're talking about that they always
return the same input or the same output
for the same input so if you imagine for
example that you have a function where
you give it a file name and then you ask
it to read the contents of a text file
and make you turn it into uppercase for
example that function wouldn't be pure
because even you disable that it's
deterministic because
know what's in the file but you could
change the contents of the file name
between two function calls and then the
output would be different so we consider
files to be external to the function so
such an operation is not considered to
be pure also if you read from a database
that is not considered to be pure
because it's non-deterministic for the
same reason the other quality that a
pure function must have is that it must
have no side effects a side effects are
all sorts of things that happen you know
as a well a society thing so you know if
you if you you know call a function and
it sends an email sending an email as a
side effect if you call a function and
it writes into a database that's a side
effect if it deletes a file that's a
scientific if it puts a pixel on your
screen that is a side effect so
basically what we cover now is that all
the things you'd ever want to do in
order to have a valuable piece of
software is impure you want to read and
write for databases that's important the
screen that's impure you want to send
emails that's impure you know basically
all the reasons why you would ever
develop some software you can't do that
the pure functions pure functions in
themselves are utterly useless and it's
one of the reasons why you know
sometimes functional programmers have
this tendency to be regarded as you know
I reach our astronauts that really have
no connection to the real world but you
know functional programmers are not
stupid we absolutely understand oh did
you notice how I said we and with the
functional program sort of including
myself in people who are not stupid well
anyway we absolutely understand that we
need impure stuff to happen as well
because we want to be able to put pixels
on the screen and send emails and all
that stuff so we do realize that we have
need to have impure functions so
basically the design ethos of functional
programming if you will is that we say
we want to maximize the amount of pure
code that we have in our code bases and
we want to minimize the amount of impure
code that we have in our code bases and
if we do that we are probably doing
something that is functional so that's
basically the design ideal now there's a
couple of rules that
then relates to how those two groups of
functions relate to each other you know
if you have a pure function you want to
call another pure function from that
pure function that's possible because
you know one function being London on
one function being deterministic and
having no side effect it's okay to call
that if you if you want to be
deterministic and have no side effects
for yourself also if you are impure if
you're an impure function you can call
another impure function because there
are no rules for impure functions and
that means you can do all everything you
want including also calling pure
functions so you can call pure functions
from impure functions that's not a
problem at all but you cannot go the
other way you know you can't call an
impure function from a pure function
because if you did you're just
hypothetically if you could that would
make your pure function impure because
either you would have you know had you
know invoked a side effect or you would
you know have introduced non-determinism
into your pure function so that would
not that's not possible so that's sort
of the rule so basically if you really
want to you know just have a high-level
idea of whether the whether the software
that you writing whether it's functional
or not you have to ask yourself the
question just my code adhere to that
rule that you can't call impure
functions from pure functions so so
people sometimes ask me you know how do
I know that I write functional f sharp
if Shaab is this multi paradigmatic
language that where you can write
functional code but you can also write
object-oriented code and you can do all
sorts of impure stuff and basically
unfortunately in this case the answer is
you don't really know whether you're
writing functional f sharp or not
because you know if char is such a
friendly language that it'll it'll nae
it'll allow you to do lots of things
it tries not to get in your way tries
not to be restrictive but it also means
that it doesn't really tell you whether
what you're doing is actually you know
functional or if it isn't functional so
sometimes in order to figure out you
know how to answer this question I need
to do a little bit of a sanity check and
I need to have some sort of tools that
can tell me whether or not my my design
is actually functional or not and if
sharp unfortunately cannot really answer
that question but Haskell can
haskell actually enforces that rule and
fortunately if sharp and haskell are
languages that are similar enough so
that if you avoid the object-oriented
passes of sharp and actually trying to
write something in the sharp that is
functional it's fairly easy to support
your Sharp code to haskell so we can try
to do that here so here's the try act
except function ported to haskell and
i'm not going to walk you through them
the implementation body of the function
itself but if you just look at the top
two lines that's the type of the
function and you'll see it looks a lot
like what we already saw before
it's just that daytime offset is now
called zone time and the reservation
list is not called reservation space
list it's just called it's just called
reservation with square brackets around
it and that means it's a list and it's
not called an INT option it's called the
maybe int but apart from that it's it's
basically the same thing
it's maybes are exactly the same thing
as options this compiles and and does
whatever we think it should do so so far
so good that's actually not so much a
problem but one of the things we need to
realize about this function is that this
function is pure how do we know that
well we know that because all functions
in haskell are pure by default unless
explicitly declared to be impure and
this one is not explicitly declared to
be impure I'll show you what that looks
like in a moment so this function is
pure not only is it pure but the two in
you know function arguments there are
also cure for the same reason that they
are not explicitly declared to be impure
and so those two functions are pure and
this is the only thing they could be
because if they were impure you remember
we couldn't call them from a pure
function because you know you can't call
an impure function from a pure function
so so they have to be pure because
otherwise this wouldn't compile so
fortunately they are pure alright fair
enough
so how do we compose this with something
that actually talks to a database now I
as always that's already covered talking
to a database is impure this is either
non-deterministic or have Scientifics
and may even do both things at the same
time so if we want to compose these
things together we realize that that
going to be one of those impure
functions that we know that we need to
have so that's fair enough so let's
declare our composition of these things
to be impure so that looks like this
try accept composition is a function
that takes a reservation that's input
and it returns IO of maybe of int as
output and that type I owe there that's
the way that you explicitly declare that
the function is impure in Haskell and
there's a lot of theories that goes
around that and I'm not going to bore
you with that but those details just
accept that this means it's impure all
right so if we want to do the same thing
as we did in in F sharp first define
read to be partially applied DP'd of
read reservations with the connection
string the type of that is sewn time to
IO of list of reservations IO because
it's impure likewise create is also the
partially applied DB create reservation
function and the value of that or the
type of that is reservation to IO of end
again IO because it's impure it returns
the ID of the newly created row in the
database but it's impure because it was
a side-effect
so we can try to call try except with
all the the arguments just like we had
before and we can do something like this
try accept n read create reservations
but if you if you recall and you
probably don't so I'll help you here
read ought to have the tribes own time
to reservation list create hat to have
the time had to have the type
reservation to int these types are not
the same you know a reservation list is
not the same as an IO reservation list
these are different types and you can't
really reconcile those two things this
doesn't compile it doesn't compile
exactly for the reason that I told you
that you can't pass an impure function
to a pure function because that would
make it into as well and Haskell
enforces that rule so it's not
functional you know yes partial
application is exactly the same thing as
dependency injection when used with
dependencies but it's not functional
again I have to stress that I'm not
saying partial application in general is
not functional but you
used for dependency injection it works
in an f-sharp and all but it's not
functional you can't make this to cook
you can't make this compile in Haskell
so let's try to understand why that is
in animal intuitive level if you're
looking at dependency injection what you
often end up with is a graph of objects
and the graph is always a directed
acyclic graph so in this case what I'm
trying to to picture here is that you
have a root object that has two
dependencies so the root object is the
object on the left-hand side and then it
has two dependencies and then the top
one of those has two dependencies in the
bottom one only has one dependency and
so forth and so forth until you have a
graph with leaf nodes now these nodes
are typically where you have all your
impure stuff happening this is where
these are the dependencies that actually
talk to databases and send out emails
and all sorts of things and there are
almost by definition impure so if you
have something that is impure and you
have a and I have another object that
contains and calls into the impure code
that means that that caller must also be
impure as well so impurity is totally
infectious you know dependency injection
makes everything impure and that's why
it's not functional okay so if we want
to be functional we have to reject the
notion of dependencies and sort of find
a different way to deal with the fact
that we have impure stuff happening and
we sort of want to decouple the impure
and the pure stuff that's happening in a
sane way but we can't really do it in
with the way that we used to do in
object-oriented programming so what do
what do we do instead so I'll walk you
through that as well
right okay so in order to understand
what to do let's go back to basic stuff
so back when you learn to how to program
the first thing you probably learned was
to do some sort of hello world or
something like that and fairly early on
into your programming 101 or whatever
whichever way you learn to program you
probably learnt that it's a good idea to
fact a common code out into some sort of
operation you know a procedure a sub
procedure a method a function whatever
you want to call it we'll just call it a
unit a unit of operation and such units
you know
operations procedures functions methods
they take they take input in the form of
an argument list and they return output
in the form of return values
so that's input and output everyone
knows that procedures or units have
input and output but if you start to
look at you know dependency injection an
object-oriented design you have
dependencies and you want to have data
in and out of those dependencies as well
so if you think about the Maitre D'
object that i showed you or you know up
until now you know the maitre d queries
its repository or create queries it's
you know a function argument to get data
from the database and in order to make
some decisions are based on that data
that's also input but we call it
indirect input because it's not part of
your argument list but it's still input
into the unit and also if you want to
put data out into your dependencies if
you want to save the reservation for
example let's indirect output so now you
have direct input now when you have
indirect input and output and basically
the problem is that we've now learned
the dependencies are tend to be impure
so we want to get rid of those so we
need to figure out a way to get rid of
indirect input and output so let's start
with indirect output now why do we do
indirect output in c-sharp a Java's of
things like that well why don't we just
return the indirect output as normal
output couldn't we do that and the
reason why people tend not to do that is
because often that interact output must
not always be you know put out if you
will
must not always be returned it's
conditional I'm sort of on some sort of
condition for example in the try/except
example that we're seeing here the
enteric output is that we save the
reservation into the database but we
only want to save the reservation into
the database if we decided that we had
enough capacities in order to accept the
reservation and otherwise we don't want
to do that and it's difficult in c-sharp
and Java to decouple the decision from
the effect because these languages are
statement based so you have if-then
statements and then you have more
statements that sort of you know
achieve some sort of effect like saving
into database so I'm not saying it's
impossible but it requires a fairly
sophisticated optic oriented developer
to you know decoupled decisions from
effects in c-sharp or in Java it can be
done but it's sort of not the easiest
thing in the world so most people just
resort to this thing where they say well
if I can accept it then I'm just calling
my repository and otherwise I'm not
calling my repository and then that
becomes indirect output it turns out
that in in functional programming
languages you're decoupling decisions
from effects it's one of the easiest
thing you can do so we can take that
indirect output and refactor to be
direct output instead and then f-sharp
it's going to look like this so this is
where we left off before I have my try
accept function there and it takes four
arguments now the argument that produces
direct output or interactive output
sorry is this argument called create
reservation here which is a function
it's a function that takes reservation
as input and that's actually the direct
output and then it returns int and then
we take that into and return that
instead what I want to do now is that I
don't want to call this function anymore
so I don't even want to pass in this
function as an argument anymore
which also means I can't return an int
anymore because I don't know what the ID
is going to be I just want to return my
decision and then someone some some
other function that composes this things
together can make the decision of you
know for example you know writing into
the database so instead of returning an
INT option I just want to make the
decision as returning and reservation
option like that by removing that you
know function argument all by itself and
just do this instead so I route I've
removed an argument so this is now a
function that only takes three arguments
and that also means I can move things
around because it's actually it can fit
on one line now so the implementation of
this needs to change a little bit as
well I start by basically doing the same
thing getting the number of reserved
seats from my reservations read
reservations argument function there and
then all sorts of other things but when
I decide to accept the reservation
instead of calling a function which is
no longer there I just take reservation
set
accepted to true and then pipe that into
some and that becomes a you know some
reservation and if I decide not to
accept the reservation that just
returned none so I pretty you know
clearly encoded my decision in the
return value and then you know someone
else a caller can decide what to do with
that decision so if we look at the try
accept composition that we saw before
I'll need to refactor this one as well
so you'll notice that the type is still
the same so if this is a true
refactoring I'm not changing the
behavior I'm also not changing the API
the these things stay the same but I'm
changing the implementation so what I
need to do now is I need I need to call
try except with the three arguments that
it now takes and get the value back from
that so I call it with their argument
the hard-coded document ten with the
partially applied function DB read
reservations with the connection string
and with the reservation that's all the
three arguments that it takes now and it
returns a reservation option and you'll
notice that I've surrounded that you
know function call would match with and
that means I can now do cat and matching
on the return value of calling that
function and if it's none I'm just going
to return none if it's some I can pull
the reservation that was accepted out of
the some case and then I can pass it as
an argument to DB create reservation and
that is a function that creates the the
reservation as a record in the database
returns to the IDE
you know the row ID of the new row that
was created and then I can take that ID
that integer and pass into some case so
that is why this function still returns
an option this behaves just like the
previous example that you saw but now
I've refactored it to not have direct
output anymore I will indirect output
it's only direct output so I've
decoupled the decision from the effect
which is a an easy thing to do in a job
and it's also easy to do in Haskell for
the same reason and this sort of
branching here is such a common thing to
do on an option that it's built into the
language or built into the F sharp
library it's just called option map so
this does exactly the option map is just
saying well if you also always map none
to none and then we take a function that
in the some case we can
vogue that function so this this is
exactly the same as before
and you'll notice now that I have are
sitting there on both sides of that
arrow and that arrow inside this lambda
expression has the same role as it's an
equal sign in the lit bound function so
I can do the same sort of e - reduction
as I did before it's not really
important but it just makes the code a
little bit nicer so it looks like this
and I can also take and move the
reservation around that's also not
really important but I yeah I just
thought it would look cool so move the
things around right okay so so that's a
refactoring that took that got rid of
the interval output now can we also get
rid of the indirect input that's even
easier in most cases because why do we
actually need to call a function or call
a method from within the unit why don't
we just say I need that information
instead of calling a function that
returns a reservation list why don't we
just say I need a reservation list in
order to make the decision someone else
you know gather that fetch that in
reservation is from wherever you want to
and give it to me so we for do that I
can just say well interact up input
should be directly input and you'll
notice what happened now there are no
more arrows between the unit and the
dependencies so now we have rejected
dependencies as a notion and this puts
us in a position where this unit can
actually be pure it's not quite there
yet but we're really really close I just
need to make this refactoring then it
becomes becomes pure alright so at the
moment where we left it off it's it
wasn't pure but I'm going to make it
pure by removing the indirect input and
moving the indirect input to Divac input
so the indirect input is in this
remaining function argument there and I
should say as just a society comment
here I'm not saying that passing
function arguments to other functions
it's not a functional thing to do it's
one of the most functional things you
can do you know in general in functional
programming but what I'm saying is when
the implied you know behavior of a
function is that it's almost always
going to be impure then it doesn't work
because that would make the other
function also impure
so in general I have no problem with
with function arguments but in this case
the problem with this one is that it's
implied to be impure so that's why we
don't want to have it so what I'm really
interested in in there that you know
read reservations function it's not so
much the input but the output that it
creates that reservation list so I can
get the reservation list if I just you
know change it from being a function to
just being a value that's just the
reservation list and if it's a value at
only the brackets around it also if it's
a value it doesn't really make sense to
call the argument read reservation so
I'll just rename it to reservations like
this all right so this version of
try/except now looks like this I just
take the reservations
I do sum over the quantities and I do
all the stuff that I did before and this
is also now simpler so that can actually
move things into one line so it just
becomes simpler and simpler the more I
move it towards something that is pure
which is one of the reasons why we like
pure functions because they're simple is
it's really difficult I should to write
a complicated pure function yeah well
that's a catch phrase that's and it's a
lie but never mind just believe me right
okay so we'll go back to try accept
composition and see if we can refactor
that one more time in order to still you
know keep the API keep the behavior but
do it in a different way so what what I
want to do now is I start with the
reservation date and I'll type that into
DB the read reservations so if you
remember DB we read reservations party
they applied with the connection string
is a function that takes a date as input
and I'm piping the date as input so
that's actually the same as just calling
it with the as you know as a second
argument now this returns a reservation
list which is exactly what I need so
I'll type that reservation lists which
is the output of this expression so far
into a new function in this case the
function is a lambda expression for now
anyway so you'll see the lambda
expression here is a function that takes
reservations a reservation list as input
which is the output of the previous step
and then I just called try accept ten
reservations reservation that's just a
complete call to try except the function
that I just refactored and you know that
if it returns the reservation
option so I could just do option map
just like I showed you before that that
hasn't really changed now the first time
you see lambda expressions in c-sharp oh
and which are the language you
originally saw them you think lambda
expressions are really cool and then you
know when you've seen like a thousand of
them you begin to think that they
actually look a little bit awkward so
you're looking for ways to refactor them
so that they look nicer for some
definition of nice and in this case you
may be wondering whether we could make
it look nicer so you'll notice that it
says reservations on both sides of that
arrow but unfortunately we can't do an
e2 reduction in this in this case at
this time
because reservations need to be in the
last position on both sides of the arrow
in order for us to be able to do an e2
reduction and reservations at the moment
is the second-to-last argument and not
last documents I can't really do that
sometimes when I encounter a problem
like that I just go back to the
implement the code that implements the
function and just change the order of
the arguments there because often it
doesn't really matter in this case I
think it actually you know it makes more
sense to to think about try accept as
having this particular order of
arguments so I'm not really I'm not
really interested in going back and
changing the function itself but there's
a little trick I can use now in Haskell
for example in the core library of
Haskell there's a function called flip
and it's not enough charcoal because
tons I'm doesn't like it but I do and
it's super super easy to implement
yourself it's just one line of code here
it is flip and I'm not going to try to
talk you through this because that's
typically where people's brains explode
but flip is a function that takes
another function as input and the
function that it takes as input is a
function that takes two arguments and it
returns a new function that does exactly
the same things but with the arguments
flipped around and this is what I need
to do I want to flip the arguments of
this but the only problem that I have is
try except it's a function that takes
three arguments and flip only works for
two argument functions that's not a
problem either because I can partially
apply try except with the number 10 and
if I do that I'll have a function that
takes two arguments and then I can flip
them okay so that looks like this yay
so now I have reservations on both sides
you know in the last position in both
sides and then I could do an e2
reduction and that looks much nicer yeah
this has nothing to do with dependency
injection or anything but it I just
thought it was cool and I have the time
so whatever alright okay so am so that's
this compiled in Haskell okay here's our
sanity check and you could sort of
probably sense where this is going right
so not going to be particularly
surprising but let's just look at it
anyway so here's the port of try/except
and again and I'm just I'm not going to
you know cover all the nasty Haskell II
implementation details but we see that
the the function is still pure because
it doesn't say IO anywhere in the
function type so that's that's good now
what about try/except composition that
composition where we try to compose it
well it looks like this and you'll
notice that it has all sorts of
weird-looking errors and dollar signs
and weird looking stuff but you can
probably see some things that a little
bit familiar like for example let's flip
try accept 10 there in the middle
actually looks like it didn't in them in
F sharp as well but the important
message here is that yay this actually
compiles it works this is the functional
way to do it and if we want to if we if
we try to extract some sort of pattern
out of what happened I've seen this
happening over and over again when I
play around with Haskell is that what
happens is that at the value of the
system I tend to have some sort of coal
of pure functions but then around the
pure function you know before and after
I have some impure stuff going on so in
this case you know I have some I prepare
some input data that I'd pull from
various impure sources and then I pass
that data to my pure functions and my
pure functions then return some some
pure data and then I do some impure
stuff with that data as well so Solomon
almost becomes like a sandwich I don't
know if you know the story about you
know how sandwiches was invented but
there was this nobleman here in England
called the Earl of Sandwich or was at
the Duke of sightly studiolo sandwich
right yeah and he was a notorious
gambler there's probably been more than
one or love sandwich but one of them was
a notorious gambler he was playing cards
and he was playing card so much that he
didn't want to break
for lunch or dinner or anything so he
asked his servants whether whether he
could come up with something that he
could eat while playing cards without
you know he wanted to be able to eat it
with one hand and he wanted to be able
to read eat eat in such a way that his
fingers didn't become degrees so that he
could actually still handle the cards so
they came up with this idea of giving
her two slices of bread with a piece of
meat in between and this is basically
you know how the sandwich was invented
because it's sort of you know for you
know addressed that problem and it's not
the same thing that happens here you
know just like the good part of the
sandwich exactly actually the meat in
the middle but it's greasy so we can't
really handle it so we put you know
bread around it it's sort of the same
thing that's happening here the good
parts all your logic all the business
starting or whatever it is that you're
trying to do is in pure functions it's
in the middle but you can't handle it
because you can't see the output of it
because seeing the output of a pure
function would you know require you to
print you know pixels to a screen and
that's an impure operation and you could
you can't put data inside your into the
pure function because that's I oh so you
need Sam to have some impure stuff
around in order to be sort of be able to
handle the pure stuff so so the Haskell
code always tend to look like this and
by the way I have another talk that
talks about why this actually turns out
to be the portal adapters architecture
all by itself it sort of enforced by the
Haskell compiler but if you ask a
compiler if you tell that to a Haskell
if you say let's don't ask a programmer
did you know that has two programs tend
to follow the ports in the adapters
architecture they look at you and say
what they've never heard about the ports
and adapters architecture because they
don't need to have a name for something
that it's the language does by itself
it's just it's just Haskell right okay
so we'll get back to where we started
I'll just reiterate this slide as you
already seen if you're doing
object-oriented programming and you want
to address you know problems of coupling
and you know code that's hard to
maintain dependency injection is a
well-known way to do that there are
other ways to do that and
object-oriented programming as well but
dependency injection is well described
well known and so on so you can guys
that still make sense but in functional
programming you know if you're in an
impure functional programming language
like for example
sharp but it might be I don't know about
closure it's it is him you know not it's
not employed non-strict sorry if you're
an anon strict functional programming
language like if sharp for example you
can use party application and I showed
you why that is actually equivalent to
dependency injection but also I showed
you why it's not functional so instead
in if you really want to be functional
you need to go with this sandwich model
instead where you say impurity or impure
and compose functions like that so with
that I'm pretty much at the end of the
talk and I'm also at the end of my time
so I don't really have time for
questions but I'll be happy to talk to
any of you who have who might have
questions you know either here or out in
the hallway or wherever I'm going to be
around today and tomorrow and if I don't
totally stressed out you're always
welcome to just you know come and talk
to me and ask me questions there's one
question that I predict some of you will
have and that is can we get the code you
can just stay tuned i have you know i've
actually already written full articles
that uses all of this and sort of you
know dives into the details of it i just
need to polish them off when i get back
from the conference so if either if you
should subscribe to Clark upload a DK if
you just follow me on Twitter you'll
know when it's published and I'll
probably do that late next week I think
I'll start doing that so you will be
able to get all the demo code that I
showed you here or this day if sharpen
they have school versions of it so with
that I'll out of time and I hope you
enjoyed the talk and you I hope you
enjoy the the conference and that you
have a good couple of days here so thank
you all for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>