<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C++ Unit testing - the good, the bad &amp; the ugly - Dror Helper | Coder Coacher - Coaching Coders</title><meta content="C++ Unit testing - the good, the bad &amp; the ugly - Dror Helper - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>C++ Unit testing - the good, the bad &amp; the ugly - Dror Helper</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EiN3cF_y3vM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay hi everyone good morning who was
hearing my talk yesterday okay so we'll
cover some of the things but not all of
them again because I don't want you to
get bored this is the sitter's plus unit
testing talk good bad and ugly and
before that she was about myself my name
is go helper I am a developer and
consultant working at code value I
specialize in unit testing TDD BDD clean
code how to write a code better kind of
stuff I also write quite a lot of code
in C++ Java and.net languages I also
have two courses in floral site both of
them in C++ first of which is a set of
fundamentals using catch and the second
is deep dive into mocking with Google
mock I have a blog at helper code calm
and you can reach me on Twitter using
the helper anyone here is also a.net
developer okay and have you checked out
there is code they're both down if not
Oh excellent
if not you should it will help you debug
your code so let's start let's talk
about C++ I love C++ I think it's a
great language it's an amazing language
it give me so much power it's in my
belief it's the only truly
multi-paradigm language you can write
anything from procedural code to
functional code with object-oriented and
Metapod meaning between on top of that
it's very positive it's a little foreign
language you have the ability to change
the way the memory works and how your
object works with a single keyboard you
can make your code moves completely
different you can access the GPU in the
CPU and the compiler on top of that
we'll do optimization we can only dream
of in other languages it is a
multi-platform language and then doesn't
matter what other languages starting
with the J cells they are not truly
multi-platform like like C++ and I have
worked in it
in a project in which we've created a
nightly performant multi-tenant
voice-over-ip project and the core of it
was it was passed and it worked
flawlessly on any single operating
system and platform from arm and Android
iOS Windows Linux Mac you name it
C++ will give you that if you can
compile your code you can run your code
and it behaves well with other languages
as well because we are not snobs we can
call Java and Java can call C++ and.net
can call or be called by c plus plus and
python can call c or c++ in a way which
make it really useful language to have
because we can rely on all code which
works to this day and use it within
languages and it has so much power we
can extend the language using macros and
templates in type deaths and other
capabilities and if you really want to
we can do low-level programming either
the GPU or writing line assembly or
decide whether or not that specific bits
of memory will be allocated or be
allocated which gives us a lot of power
and on top of that this is the language
in which the development world was
written compilers operating system were
written using C++ even some languages
which which has compilers that are not
written with C++ that compile of while
it in which it left us or the platform
or the runtime or whatever is Acosta's
although and that's really powerful
things to have because if we if you
think about it we can understand how
they walk because we wrote similar codes
unfortunately with this great power
comes great responsibility as well C++
is not an easy language to master it's a
language in which you can cause a lot of
pain and problem easily without
intending to you can take a junior
developer giving C++ code and say well
good luck because you will probably have
some memory allocation problem or
dangling pointer things and and they'll
create a big mess
then syphilis requires to know exactly
what we do and then understand how the
language behaves and if you've been to
the talks about sequester 17 so it's
completely over my head lay topics there
about when to use exs PR and other
keywords that change completely what the
language does and you need to know the
out of all the execution and whatever
happens in specific processes in some
cases if that's what you do and that is
a bit of a problem because we human
makes mistakes but the solution at least
I found that there's one good solution
to that a mistake and this is the topic
of this session and those are those unit
tests because unit has enabled me to
catch at least the simple mistakes which
tend to happen quite a lot unit has
enabled me to write code I have who
confident in it helps me to catch the
stupid bugs there I forgot to allocate
memory kind of dogs I accidentally went
over the boundaries of the array kind of
bugs because if that bug is missing the
code you will catch it with the unittest
it won't give you system-wide bugs but
it will help you the submit code for
testing that will not crash immediately
and that's a good thing on top of that
it will give me the early feedback when
I was beginning my C++ journey more than
ten years ago I would write my code
submitted for testing fault over defense
go home and the tester the protestor
will run my code and it will crash
immediately it will throw it back at me
and would unit as I don't need to do
that anymore
I get that early feedback I know that I
wrote the code the right way I know that
my code does not crash when executed in
a most trivial way on top of that it
helps me understand whether or not about
the right thing not just the right code
because some of time we are developing
something deciding to develop a feature
going in that direction but on the way
we think about something completely
different and
see gently or not intentionally we
developed something completely different
once I get to test that code
I'll find out I developed it on feature
I don't forget features with the seekers
pass as well but with unit testing as
well because all I need to do is to
write a test to remember that I forgot
to implement a specific feature and the
big selling point of any test our
regression but once I get a good unit
testing suite it means that if I
accidentally when fixing a bug create
another bug it will be killed by
existing unica's única scene is also a
good way to do design it will by doing
test-driven development or behavior
driven development writing your test
before your code or if you decide to do
it the other way around rather test
afterwards you have to think about
design loosely coupled design
object-oriented design how the
dependencies interact with one another
you have no other choice because you
need to test it
and you need to think about those things
and it helps you write very modular very
loosely coupled kind of code and on top
of that unit testing are good good
documentation when I go into a new open
source project sometimes the death the
commutation is not so good but most open
source projects these days have some
form of unica's and by leading the unit
test I can understand what the auto
thought about how you should use your
code how you should run it what you
should do with it what are the valid or
invalid inputs and you can debug those
documentation as well it's not like a
word document or markdown document which
we all probably use these days it's
something I can actually run and see
execute and understand how the
underlying system work and when I write
unit tests I know something that in two
months time in one in a field having one
year time when I go back to that code
and I forget above everything about that
specific piece of code I can run the
unit test and remember how I intended
other people to use it so you can see is
a cool thing to have now what is this
unit s there are many definitions by the
way this is my own and the unit is
essentially just a method that's it no
more nor less it's a method which
persists
other rules or similar tools that we
like other methods in our production
code and there are some rules that
change when you like unittest from when
you like the production code the first
of which that the universe tests a
specific piece of functionality a
specific piece of functionality is the
other way around from how we write
production code because this'll write a
method in my code that's supposed to
solve some problem and I'll just solve
one scenario one specific path is the
problem I'm not doing my job but in
Unitas is abstract it has too many
things I'll probably write an
unmaintainable unreadable test so it has
it has only a specific functionality and
it has to have a very clear path of fail
criteria and the reason I'm saying that
because I was in a client and they told
me they I'll do in unit s now
terminology may vary between companies
and what they mean by unit s is that
there's this huge script that runs on
two different big databases and does
something and in the morning the tester
will come in and about until lunch or
afternoon depending on how much work he
has it will read the result and decide
whether or not the test actually passed
and that's not what we want I don't want
to check the test I want the test to
tell me whether or not I passed or
failed and finally unit s question so
you finally unit s should run in
isolation what do I mean I don't want
any external dependencies in my unit s
that I want to call a server or file
system or a other external things out
outside of my control I do want to do
that in a different kind of test which
are at in a very similar way which are
called integration tests or scenario
test or acceptances and that's okay but
I'm good talking about unit test at the
moment and the reason I want to do that
is because I want those tests to run
fast I want to run thousands of tests
and I don't want it to call to be about
half a novel to run all the tests and I
don't want the test to fail because of
some external dependency I don't want
the test to fail because my database
doesn't have the right permission of the
right data right now when that happened
we'll start passing or failing without
any reason without any code change and
it has that passes and then fails and
then passes again and then fails what
usually happens is that the developers
will run the test again until it passes
and then quickly they'll get used to the
test bin failing from time to time and
then all the time maybe and at that
point probably does start noticing when
other test fails and when those they
start to sell and nobody care about
whatever runs there you can delete all
the tests because it does do not matter
anymore so you have to be be very
careful with those tests with sometimes
passes and then fails you should delete
them or change them because they will
only hurt you in the long run and this
is a unit as written with Google test I
will show you other unit testing
frameworks in the C++ world usually but
not always all there are many options I
need to define this method which is a
unit test and in Google tests I do it
using this guy this is a macro which all
signals plus returns it let us know
because it's in the upper case right and
that Mako does three things first of all
it defines that I am going to write a
method the method name is in Google test
actually this the name of the test is
the method test it will create a method
in the background it will also create a
class if it needs to and then all of the
class is this guy movie tests so in the
background what we essentially have used
as a class with the method inside and
the interesting part is over here this
is the test body which if we do about
correctly is divided into three parts
the first part known as 1/3 arranged
sorry is the part in which I create all
the dependencies and things I need in
order for the tests to run the second
part is the act well I'll run the actual
functionality I need to test this is
like a play button for the test and the
last one also known as asserts and that
is totally because these days some unit
testing frameworks does not have a set
as other words for it and in which I
test the result and if you know the
movie the good Abed and deadly you might
even know this
I'm destiny so that Google test and
that's fine
other than the unit testing framework I
might need other tools in order to
succeed with unit testing this has been
the only unit testing framework but the
secondly we in which is a mocking say
book a maken thermic is something we'll
talk about later on I will also need
some additional things that will help me
write my tests quicker and execute them
and maybe get some information not not
mandatory but very useful to other code
coverage tool that will show me what I'm
actually running and and this is the
class pass so I don't always have it
some form of development environment and
editor in which I write my code and my
tests and if I have that I need to have
my test form within if I you working on
Windows anyone here work in C++ in
Windows okay so we are Visual Studio
good for you if you work in Linux you
can use the clips or one of the other
options I've been to a company they use
the novel glorified notepad for Linux
couldn't run the test all the code and
that's a problem because you want to run
your tests all the time you want to make
a change in our let us see what's
happening one to debug a test that's
very important other than my own
development machine I also need a
continuous integration server a server
which will run all my tests whenever I
make a change whether committing you
change it's very important I'm not going
to talk about that today there but
without that succeeding with the
universe in is how to impossible if
there's no one else that runs your tests
your tests will stop working after a
while and every developer we all
developers we know we are time limits
and we'll have stressful times at work
and sometimes we forget to run other
code sometimes are better on the test
sometime we do it intentionally because
we don't have enough time and even if I
have it enough time and I run all the
tests all the time if you do that you
are better men than me
because I don't do that I forget even if
I do that this is my development
environment its dirty with dependencies
and all sort of stuff I need to install
in order to work with my machine and I
need a build server that will be very
similar
to whatever the client is running in
order to make sure that my code runs in
this close condition to what I'm writing
as possible so I need a build server to
add tests as well so what do I need for
my unit s3 things for my unit s first of
which a unit test will give me test the
ability to write tests and organize them
in some form a way in the past was known
in stitches very much there's a lot of
changes in C++ these days so a feature
is not a good name but I don't have any
anything better but the idea is to
organize all the tests in some form of
logical units and another thing I need
in formal testing some Okies assertions
the ability to check whether or not
something that I did just walked or
didn't walk and lastly some for some way
to run the test and especially in C++ I
want to run all of the tests I've just
created automatically I don't want to
create like a console application in
Windows and then write all the test name
in order to run them I wanted to run my
tests and most if not all unit test
framework will give me that ability it
will also enable me to change how the
tests are run using command-line
arguments and that's important
more than that there are some unit
testing framework that has integration
inside a you're developing development
especially in Visual Studio since
Microsoft abandoned the ability to do
that in 2012 so that's a cool thing I
can run the test form within Visual
Studio and that that is also very nice
capability to have yeah
so in the CSS world what options revs by
the way there are many many unit testing
framework in the C++ world with many
different kind of capabilities and
styles and that's one of the things that
differentiates C++ from.net or even Java
the styles of C++ munication framework
changes from framework to frame of
because people have been done do amazing
things and have been taking the language
to limit and do cool stuff with unit
testing if you go to the dotnet
framework the c-sharp
all of the unit testing framework look
exactly the same just like J unit
incision there are some changes some
minor changes between them but you know
one you know them all it's not the case
in sitter space in C++ I guess people
are more open to experimentation to try
things out so if you have a lot of
options and a lot of style to choose
from that's a good thing the best thing
is that you don't always have
documentation many of those projects are
open source projects and as such that
that someone who does his work late at
night after working for 10 or more hours
writing code and sometimes the
commutation is not a priority another
problem is that not all unit testing
frameworks are actively maintained and
we need to be careful not to type survey
choose some universal Cermak which we
can get support for or some of them
don't even have the source code and then
we can't even support ourselves and the
only thing about unit testing samokhin
set of tasks is that deployment and
luckily for us that's not always true
but deployment can be a problem and
another thing if you worked in c-sharp
or java you might know that those unit s
in some of those markings a mock use
reflection heavily there is reflection
in order to understand what to run and
how to do it and how to change the
objects and we don't have reflection in
c++ yet nor will we have in 2017
probably dunno what when we'll have it
but we don't need that because in C++ we
don't need reflection
we have so many other ways to do stuff
that we don't need reflection in see
justice a weekend we have metals and we
have templates and we have inheritance
tricks and we also can play with the
build pipeline and I was also involved
in a mocking framework for citiz which
used some projects from Microsoft that
enable you to redirect code running
right now in cyberspace Windows only
unfortunately natural about the state of
that specific project so I'm not going
to show it but you can do a lot of stuff
a lot of tricks is in C++ it's a very
powerful language so quick overview of
some of the C++ unit testing frameworks
there are many many many more the first
one I want to talk about is Google test
Google testing framework one of the
first testing framework created by
Google obviously and come bundled with
Google mock Google testing Samak require
you to build it in order to use it which
are some problems because you need to
compile and build someone else's library
and it has to be exactly like your
library it has to be the same
configuration the same platform the same
everything multi-threading compartment
whatever otherwise you get weird and
funny linking problems another thing
from the big companies Microsoft natives
unit testing framework Microsoft
natively intercessor milk is not
multi-platform it's Windows only from
within Visual Studio been around since
2015 and if that you have a today in
Visual Studio 2015 or 17 documentation
is improving let's say like that and it
doesn't have a lot of the capabilities
of other testing so more in fact I think
that there are recommended Google tests
at the moment but I don't know you can
use it and the good thing is deployment
because if you use in Visual Studio
windows only see past us just a matter
of getting new project so that's a good
thing
the third anomalies catch written by
filling our seats here
very innovative unit testing framework
very excited is here because it's my
favorite he has thought about things we
didn't know we want in a unit as in
thermo can now if that is completed
everybody takes is idea back and
changing them it's a head of only
deployment which means all you have to
do is include the header file and you
have a unit expert it you don't need to
build compile anything that's cool
CPP unit I need to the mind deal of the
granddaddy of them all Chicopee unit was
created in order to write a book called
the working effectively with legacy code
is a C++ unit testing framework it's
quite old I don't recommend using it
it's behind the times but you should
know it's out there and I have seen
people use it especially in the embedded
space because it doesn't use all their
cool sticklers plus 1114 kind of
features so can be compiled to that
space does boost dot test which comes a
part of the boost library which you can
use as well I find it to be very verbose
I don't like to hide too much code if I
can avoid that endows doc tests doctors
is the first catch derivatives they took
the ideas from catch and they did change
a few things as long as the CL as the
Centers but they have a different idea
the idea of doc tests is to write the
test as part of the code in the same
assembly in the same places the code and
dealing build you can use a flag to make
all that code disappear not compile and
that is an interesting idea natural what
I think about it at the moment I haven't
had a lot of chance to play with it
so I don't know but that is a nice idea
especially since in simplified we don't
have always have the ability to look
inside someone else's library and test
the same code so might be good for some
scenarios just left less is another the
catch derivatives it took the ideas from
catch and from for model unit testing
framework and site improve the runtime
and compile time but a few things got
lost on the way because in order to
improve that time the tests are no
longer automatically discovered nothing
really discovered were registered
and so you need to write it by hand and
it looks if you know catch or dog test
you will probably feel at home because
it look very similar
there's XE meat plus plus if you know if
you need from dotnet the idea was to
bring the same ideas into C++ and
socially seems that it's not maintained
anymore so but it's nice to have the
same syntax and finally this metal metal
is an isolated to scale the Java
developers I'll show you it but you
might like the syntax and it's a cool
generator since mo it's not bad but any
needs easier to compile it or use the
other only and then you have limitations
and in order to compel it in Windows you
might have to jump through some hoops
it's a more Linux in let's see a few of
those by the way this specific project
is in github and already helped duel
help adults my name and here I have a
few unit testing frameworks so let's
start with Google test because it was
the first and we are going simple first
this is a Google test test and here I
define the test I can define the class
the picture where the test runs and the
test name and then I write a test body
now Google test has an extensive set of
asserts there's quite a lot of ways to
ask to ask what I want to know the other
search any flow and death it also can
check that your application crashed
that's it left us remember and exits and
false and float and greater equal and
less equal don't equal to defy and
predicate you can define predicates and
strings equal for whatever collections
and there's also the way to use Google
mock matches which are essentially
predicates that you can either write or
use Google mocks in order to add even
more assertions I'm not sure if it's a
good or bad thing but we'll get to that
later anyway of a simple test I'm
testing the ball in Qatar the balloon
cutter was invented
bon mot even kebab and the idea is to
build slowly bowling games call
calculator Anil for example I check that
pistol roll several twenty times of old
and I just one pin then in the end of
that this call will be twenty
now this little if the thing here is
something I need to talk about this is
JetBrains C++ the shuttle for citizen
able me to run a catch and Google test
which is nice because the other option
is to run it from the command line and I
can take this test and run it and
hopefully if Susan compiles I'll get the
results it passes and if I'll mess it up
a bit and ask it for 21 I'll get a
different results which is should be a
failing and the nice thing the first
thing you want to do when you have the
new unit testing framework is to check
what happens when it fails when the test
fails because when that sells want as
much information as you can possibly
have I only write unit as in order for
them to sell if the pass I don't care
that's a waste of CPU if I had one way
to find out whether or not a test will
pass throughout his lifetime I will
delete the test I just care about test
at sales because and when they sell want
to know as much as I can and Google test
is one of the one of the testing some of
the give me a lot of information
remember that simple stuff you can get
the actual metal name running and the
result and the nice thing about Google
is that usually in other languages you
have to be careful which value you put
in the left side and which value on the
right side and it's usually backwards
you firstly tell what you expect to
happen and then you say you give the
actual result and I find it to be the
other way around I usually say I equal
five not five equal I although C++ some
people are used to the notation right in
order not to accidentally put the value
instead of comparing it and but in
Google test they don't care they'll they
give you they don't care which side you
care about will show you 18
very nice message moving on to Microsoft
Microsoft Anita since I mock will remind
you what you are familiar from the Java
world and the siege of old we have a
test class which a name and you can
actually see that as matter looks just
like that in a class and I can have a
films in that class again actual weather
like that's a good or bad thing and
every test method does something and
that's Microsoft that's not I'm
executing unlike the other unit testing
frameworks you can only run this a
specific test using Microsoft tools so
we W open the test Explorer from the
side and you can see all the tests and
random from you all in the command line
you need to run Microsoft MS test
executable with the test as a parameter
but it's really for those who like this
kind of syntax that's okay that's fine
we have initialization and method and
whatever and moving on to catch catch in
catch we can do a bunch of things first
of all the test called test case but not
in that's very similar but the cool
thing is this this I like I don't need
to write a test name that is actually a
method name and when you think about it
it wasn't that hard to do in Google test
as well but it shows the way that
everybody did it they do you think how
to make a life easier when I can write a
string as a test name it means I can
describe exactly what it has does and
when it has felt that the first thing I
see is that string so I know what failed
that is a very powerful capability to
have on top of that I have other cool
features in in catch and we'll talk
about them but the first thing is this I
don't have multiple asserts in catch I
have just one a third and that's it and
I can write code like the way God
intended it to be
I don't need to use the writer serve
because if I don't user the right assert
I'll get the wrong message when the
tests fail don't understand I need to
debug it and with my time I just write
code and when that test will fail and
I'll
cause it's to a you know what I'll take
actually a different test that I want to
fill here we go when the tests do fail
I'll run it is in the shop as well it's
nice to have few options petitioning
demos so much information expression
failed and this is the name of the test
that the thing I gave it here so I know
exactly what happened and shows me
exactly what I was trying to do and what
values wasn't not what I expected to be
and that's that powerful and you know
what there's no reason Java and c-sharp
won't have the same capability but they
are not there yet John the next version
of jail unit will probably feature this
kind of behavior but in c-sharp I'm not
seeing it happening yet and I don't know
why because the else reflection and they
can pass the code and they could get
much more information than super stars
and they don't do that they don't
understand the world I guess as well so
that's that's a shame but I did write
something like that falesha because I
was very frustrated with the need to use
assert equals instead of a search true
instead of a third now and so there's no
reason I can't write my test this way in
any language but we separate us I guess
it's also possible and finally metal
metal that that was the fun one this is
what metal tests look like here we go
go ahead and define a suite of tests
with some name we'll first I'll cough
copy that and I can use a lambda in
order to define the actual test and here
I have the first test and whoa if you're
comfortable with this kind of syntax
that's fine and they're using a string
based as well but that's easy that's
because they don't need to comment into
methods in the background it just landed
lambdas that they run and just register
the tests and hear everything and that's
fine
that's cool and it has the main in the
background that I don't need to write
and catch as the same capability I don't
need to actually write a main method
like I need to do for example in Google
test in Google test is something hiding
it I need to write the main method and
initialize Google test or Google Mach
depending which I use and then call a
notice which is okay because I don't
need to tell it exactly which tests to
run some unit tests and some local force
me to telling the testing some formulas
something but I don't like doing that I
always forget what to write and then I
need to copy from an old project or
Google for it and done like that as a
said catch as the same capability if I
go to Ted summer will be right the fine
catch config main that's the final main
method in catch you can do don't use it
so that was a quick overview of unit
testing framework in C++ now in the unit
testing world we have some dilemma
usually when starting to write unit
tests involved we don't understand the
problem but then something bad happen
whether or not to writing of the bowl
ourselves ever heard about the single
assault belt test wall anyone okay yeah
I couldn't find it I googled for it for
days and no one ever called it the
single s at all there is I guess no such
name but there is an a guideline if you
will that if you write multiple assert
in one test we might do in doing the
test along go and for good reason two
reasons actually the first of which is
technical in other frameworks not
talking about citiz a third full forward
exception in J unit or in immunity net
in a circle for an exception which means
that if I write multiple itself the
first one who fails will for an
exception leaving me would less
knowledge about that problem then I like
I want all the cell to tell me exactly
what happened
again ingenuity probably going to fix up
an immunity proposal about that because
that's a technical problem which should
be fixed but on top of that writing
multiple asserts could mean that I'm
testing several things it's a good way
to write a very complex and readable
test if I test for a lot of things and
it's very developers find it more to
their liking in the beginning to write
those kind of tests because that's the
way we write code we initialize
something but we don't want to do it
over and over again in each end of the
test and then we test everything
possible for that scenario everything is
glued in the word and that's not a good
way to that unit s remember Unitas
should be specifically shouldn't write
everything in single unit ups so that
the reason multiple cells are not good
but one assault Otis has its limitation
what if I want to test a complex object
I just got back it is one result and
testing one thing that my message object
I just got back as an ID a name in the
content and I want to test them together
but if I'll test them together again not
in C++ then I'll lose some information
along the way oddly enough in C++
I don't lose any information the reason
is that in C++ at least many of the unit
testing frameworks has the ability and
this is catch but Google test is the
same way to define two kinds of asserts
in quechua require which means the
minute this specific test fails stop the
test and we can see that in the test
result I'll run it again and here I've
created the better just to show it's
failing it's not a goodness but the
requirement failed but I don't know
absolutely nothing about the other two
requirement and that is a problem but in
a catch I have something else which is
very similar called check and check is
just like require the only difference is
that the test doesn't end one expel one
sick cells it continued to Denese
airline and Google tests
has the same tint it called expect
there's a set and does expect if I
assert that something is equal the test
will fail once that assertion fails if I
expect something it's equal the test
will still fail but only after they're
all tests will finish which means that
now when we when I run the same test
we'll give it a few minutes to the
compile then I have more information I
have two different checks that sells not
only I have only one object instead of
two but also I did this is the name of
that object and by the way there are
good were better ways to test for this
but I needed a good example so you have
to forgive me for that
so in C++ we have abilities capabilities
that fish of developers don't have and
that's the ability to use multiple
results if we choose to use them and now
it's our problem to decide with on that
that's a good idea
that's cool there are other innovations
in the simplest of all the size really
testing first of which is what I showed
you don't for an exception when an
assertion fails the second is that
usually we get better failure messages
better failure messages because the
mecco they require a certain echo
usually does a lot more then the city
shop or java does and in case of catch
and all the guys that copy it I have
only one assert in which are that code
another developer I find it to be so
relaxing writing code instead of
thinking about which are cell to use and
the last thing also bought by a bycatch
is sections and section is another cool
feature section gave me the ability if
those of you well deal yesterday I shown
a demo called ships Elvis I'm testing a
bunch of things and I noticed that
several things several things I'm
checking tend to happen a lot of times I
have duplicate code between my tests and
that's okay tests are allowed to have
duplicate code I posted it has to be
readable
then maintainable because the
maintenance of duplicate code intercept
should be easy because the tests are
supposed to be quite simple I'm going to
vote on the tester changing some small
King is usually easier than extracting
everything to methods and base classes
and then try to understand what happens
so in Google tests for example the way
to do it is to define the actual class
remember I told you that Google test
created class in the background I can
define that class it need to inherit
test testing test and then I can have
fields and I can add a constructor in
this Plateau but I can also have setup
and teardown methods which will run
before and after every test
so we found a Sperry test and initialize
the fake objects I need and set the
that's a singleton I'm playing with for
those of you yesterday you might
remember this example and then I'll add
the testing in case of Google test I'll
need to run it with the underscore s
that's my way of telling Google test
this class it was already created please
don't create another one and then those
tests become the methods of that class
and they came just like writing code
right I can reach the protected values I
can call methods which everyone who used
this class can use and I can use the
fake object this is the cyclic form
above and so on and so on I find this
solution this is the solution that every
single única since amok seems j-unit it
called test pictures I don't like that
solution that solution means that my
code the test code essentially is in two
different places
the source is appearing and the second
is down here and when that test will
fail and awfully it will because that's
why I wrote the test it will catch a bug
I need to go like this several times
until I understand what the hell happens
and if someone just wrote wrote a new
test with any need something different
to happen with the initialization and he
haven't thought it through it will go
and change something in my set of method
and accidentally changing my test as
well without any of us realizing it and
there are two outcome to this kind of
behavior either the test will fail which
is the good outcome it means that I get
to catch a bug or the fatality the test
will continue on working and there's
something completely different from what
I intended to happen that's a way what I
like the catch solution which is
sections and for section I'll just jump
ahead and the same test the same picture
make a new station a section will look
like this after Visual Studio will stop
refreshing so here we go
this case initialize whatever you want
and then you call a section and what
happens this is essentially is a
different test from the section below
they will run individually if one fails
that one passes and they won't run one
after the other they will run in the
different one this one will run well
maybe first a second and all really care
about the execution order and this one
will run in a different one it's not
like a whole method running method one
by one and this is I find it to be more
a trivial way because I can see what
happens in the test and then the section
runs so I have all my initialization
code in the same place and then I can
run my code essentially I created the
same thing I created with features but
now it looks logical which is there to
understand it easier to debug put a
backbone run on and you don't have to
break bone up cells in there in the set
up the one in silence very nice to use
and this is another innovation that is
missing commanded languages everybody
use tests pictures and that's not a good
solution and unfortunately I've yet to
find a good way to do that and see shot
but I'm still looking for it so that was
very unit testing frameworks let's talk
about mocking mocking objects are
something we need in unit tests because
one per unit has to be isolated I want
to create objects I can control those
objects are created usually by using
inheritance I inherit the class I don't
want to call the data access layer class
whatever and I change it with my own
class that does absolutely nothing and
they are called mocks usually I I call
them mock objects for one reason one
reason only for you to be able to Google
for them because personally I believe
they should be called fakes I find that
the term mock stubs test doubles by
whatever to be very confusing and turn
people away from using the
kind of objects essentially just the
sake object that does absolutely nothing
until I tell to Duluth to do something
else basically and those frameworks that
create those mock objects will probably
use inheritance although not sure about
all of them at most of them in order to
create another object that override all
the methods of that dependency and
create an object that does absolutely
nothing that's the first thing they give
me the second of which is the ability to
change the behavior in gutters just for
that specific test I want your object to
return this value of one exception or
whatever and I wanted to happen only in
the test and once the test is over I
want you to forget about it and that's
the real benefit of the mocking
framework because I could write that
those glasses by hand I could inherit
the dependency in other ideas in but
then I need to maintain classes in my
tests and I don't like to do that and
the last thing the last capabilities of
mocking thermic is to verify that a
method was called or wasn't called in
effect assert that method was called
just like we assert that the value was
equal 10 we assert that the database god
save method was called with specific
argument or not depending what we need
in C++ we have as some good news and bad
news
the good news is does they are mocking
framework for sequels plus that's good
news because that wasn't always the case
the bad news but it changes is that it
used to be only one mocking form of
Google mock any changes because people
are changing things and you need to be
careful a lot of the other projects are
dead project not maintain them anymore
won't work for you and if you
accidentally use one of them and find
out about it later on on the road then
you might have a problem because you
need to replace all your tests and
everything is that some of them require
quite a lot of code written as well and
most of them are not the change a bit of
the fritillary kind of the way of
writing tests but that's because seekers
pass so in sitter stop smoking some of
that's a shorter list there's not a lot
of them
there's Google mock comes with Google
cast okay same limitations some ideas
and then there's sample a we can buy
beyond sitting here in the front hall
which takes Google mock ideas and input
them it is that what I think the zipa
mocks and what I don't have a lot of
experience tell you whether or not
that's a good idea
I noticed that it wasn't released in the
last two or three years so might be a
problem and just take it which not sure
if it's a cool side project or something
I can actually use but playing with it a
bit it has limitations but it has some
nice ideas going there as well let's see
an example shall we
so mocking fameux comparison I have here
this calculator showed it yesterday and
I have two dependencies I'll read
something from the database and then I
send that information to the client and
what to do two things
I want to affect how the data access
return the data I wanted to attend to
that I care for and then later on I want
to check that the client was called so
with Google Mach and with Google Mach
basically the test looks something like
this
you write expect call you first need to
create a fake class the say class is a
class that inherited class I'm shaking
and then I use one of those knuckles
that will essentially create an
overridden method in the background
unity that method to be virtual if that
method is not virtual you should see the
session I did yesterday and then you
write the method name the return value
and the parameter the number here is the
amount of parameters that's a limitation
not that's bed and then going back to
the test I use expect call of that fake
data access when the method get data is
called I want you to return this
specific object that's it and I can also
heal I want to make sure that is a
client with this drink is called at
least once and what Google mock does is
that once the mock object goes out of
scope the method ends in this case it
will check that that class
is called at least once which is cool
moving on to trample a which I'll place
I'm pronouncing correctly it looks very
similar although because it doesn't have
integration with Google tests like the
forces of other you sketch but other
than that you need to create a portal
that will tell you their role because we
don't want to for an exception like
those c-sharp sigh box and then Eli use
the test case and I'll also create a
fake object just like Google Mach look
very similar its make on smoke better
than that very similar the benefit of
using Chappellet is that you don't need
to compile anything it's a single header
deployment just included here and that's
it and that's the cool thing to have
because compiled in Google tests and
Google mode can be a pain and then use
allow call there's a lock hole and
require code which is something I like I
don't want automatically every time I
set a behavior on a sec object like so
that the mocking Samak will go and check
that it actually happens for my good
reasons and by the way this is what I
think some other the unit testing
exposing the other way around
but I think that there if for some
reason some loops will extract this
method or change it or do something so
it calls from someone else all called
more than once I don't really care about
that and because this method is only
written here in order for the test to
continue execution and I don't want to
test to sell because of that so I'm
using a local and a quick whale call
back here where I do require that the
call will be call it exactly once so
that's something I like and going on to
fake it fake it outside because there
it's a bit different and that's why I'm
I worry a bit but in fake it you don't
need to write any classes you just
create a new mark of the type of the
class and that's it
you don't write any additional code and
that's well I'm not sure why I don't
know what they do
in the background and and it has
limitation they are documented it won't
work in any single scenario tyr's
problem with multiple narratives and I
think pure virtual methods so keep that
in mind you might not want to use it if
your code has those kind of things but
and the synthesis very very similar to
what you expect from a java or c shop
you have the when when i said the other
when method get data return data just
like before when this is called a turn
three and then other than going out of
scope like the other two it is an
explicit verifying to check that this
fake client was called at least once and
that's a matter of preference you get to
decide which one you like more but you
have to be careful it still been
maintained but their limitation you need
to read them before you use this
specific thermo so those are your
options basically and you have to be
careful with other tools just because I
haven't spoken about the specific tool
doesn't mean it's not a good tool just
means that I haven't used it yet and
they might be good but you need to go
and check when was the last commit and
when was the last week where the last
release if it was three years ago four
years ago five years ago don't use it
another good way to check whether or not
libraries maintained is read the
documentation if there is no
documentation you might have a problem
first of all you have problem understand
how the same walk other than that we
developers we don't like to write a
commentation if someone took the Esso to
write good documentation he cares about
this library anyone to maintain it and
since it was fast changing now every
three or four years it assess gains more
capabilities you want unit tests in
samarkand you definitely want your
mocking framework to change alongside
because things are changing as well so
if something haven't changed since 2004
you have a problem all the C++ 11
features might not be supported so those
are good rules to think about when you
need to
use your Universal and mocking framework
now if you vote about Windows if you are
a window developer that good for you you
have a nice integrated environment to
use but I have good news for Linux as
well Windows is supporting right now the
ability to debug code on Windows on
Linux from Windows you can run code on
Linux and debug it for Windows I'm not
sure whether or not you can run the
unities in this fashion but I hope it
will come if not so if it's not there
yet there are test funnels to run form
within Visual Studio so we use resharper
for c++ and Visual Studio as well has
the ability to run tests and you can
also use coverage and that's cool
because the coverage tools well very
helpful we need to understand whether or
not you forgot to test something for
example here you see all the tests here
does a Google test test those are not
Microsoft tests and they are pill on the
side because I've installed the castaño
for Google test and there's one for
catch and there's one for about anything
you need SM samokhin if there isn't one
you can write one yourself it's not that
difficult and not only can you run the
test from within Visual Studio you can
also run with coverage analysis from the
individual studio that means that if you
developing only on Visual Studio you
have the capital as long as you have the
right version it's always supported in
the high end version ultimate or
enterprise but once you do under
coverage which I did before it you can
go to your class open it up and find out
whether or not you pass all the pieces
of your code it doesn't mean that it
tasted everything by the way just min
around for the code it's more helpful to
find out what I missed not what I'm
actually doing and that's cool that you
added for within Visual Studio in C++
and let me tell you something Visual
Studio had the ability to run code
coverage on C++ since at least 2003 that
I know of but it was a command-line
thing you can only run it for the
command line using msbuild
and that's really unfortunate it's like
they hid that capability and now it's
widely in the open you can use it in
that school but it does not mean that if
you walk in in Linux you don't have that
ability first of all because you can now
run from Windows to Linux
second of all you might decide that
although your project is multi-platform
you want to develop on Windows and then
deploy Minho's I've been in several of
those projects and then you have those
tool to use so keep that in mind in
Linux you do have coverage tools some of
which even it's open source but you have
to pack it together you have to edit
probably from the command line in order
to use it so how do we choose unit unit
testing tools first of all your project
is it multi-platform project or single
platform project that will decide which
one you prefer
sometimes people I've been to a project
would they prefer to use Microsoft
native unit testing too it was easier
it's not well documented doesn't have
all the features that are the intestine
thermo cares I have to say that but ease
of use that's what they have heard them
but the other frameworks ease of use is
a theme how is it to write a test how is
it to write a book
do I need to compile all my dependencies
my modern form of my unit as if I'll go
just include the header file that's a
big thing to remember one hat what
happened when the test fails you want to
know if you have a good unit testing
framework run a simple test in their
self run two plus two equals five see
what happens how much information do you
gain out of it is are you how the test
names need to be valid method names or
just strings strings are better because
you get to write whatever you want just
make sure you don't write too much and
integration points I'm sometimes I
suggest using Google mock because it
comes with Google tests and they are
well integrated together and because it
there were no option before that before
two years three years ago but
integration points are important why no
support at all to run the test and how
is it to deploy infinite personal taste
some people like water sharing in metal
especially in super
plus all those templates and Landers I
can find the charm in it and some people
prefer a Microsoft way of defining the
class and then designing the methods
underneath some like features our next
sections it's up to you to decide but
the important thing to remember is that
I have a friend who hates simplify food
a passion a very good develop till he
told me in a lunch three days ago that
it doesn't understand why the language
just won't go away obviously that's not
going to happen it's a very useful
language you have it's a very useful
tool to have so the way I see it you
have two options and I've been there you
can once things go bad and crash and
unity the bad stuff in late at night you
might cause anyone you might be very
frustrated with C++ and what might blame
the language for it or you can write
tests and avoid at least half of those
problems if not more and that's up to
you take that investment and decide what
you do with it thank you for listening
if you have any questions I'll be happy
to answer if not I'll be around okay you
can check out the full site courses you
can see my details over there that's the
second QR code and definitely need to
check out called the if your C shop
developer as well thank you for
listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>