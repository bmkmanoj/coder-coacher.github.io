<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Web Application Security: Browsers Fight Back! - Christian Wenz | Coder Coacher - Coaching Coders</title><meta content="Web Application Security: Browsers Fight Back! - Christian Wenz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Web Application Security: Browsers Fight Back! - Christian Wenz</b></h2><h5 class="post__date">2017-03-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WJLVLd3Zy1Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good morning everyone hope you
had a good conference so far my name is
Chris Simmons and what I'm about to talk
for the next 60 minutes is actually a
tale of failure they started doing web
application security in about 2000 2001
and and I've told the story before so if
you have we seen it at previous NDC's
you may have heard that but every year I
think ok I do this for one more year but
then you know the problem will have
solved itself I was young I was cocky
and I was just wrong web security is as
up-to-date and as pressing an issue as
ever and therefore great that all of you
showed up today for a a topic that I
think is pretty satisfying we're talking
about well about the failures we as
developers had when trying to battle
attacks and trying to do proper web
application security and I proved this
by showing that now even browser
developers helped us because we are
loaned we messed it up but browsers
helped us so there are some built-in
features and browsers that are either
activated by default or can be activated
with little effort to immense the
security of our web application so
that's what this next well 60 60 minutes
will be about I have a I have a web
browser here and I have I have a page
and this page has a button it says do
not do this so what will I do
exactly let's click on that so it says
account deleted I hope you can see it
all right that's a bad thing so let's
just close this browser tab and hope
that this will never happen again today
I'd like to start with a pretty
interesting website which promises that
they they check the HTTP headers that
our web server is using and sending and
then analyzing it whether it's it's kind
of sound or not so let's just use an
arbitrary site so about how about NDC -
Londyn come and now that website is
retrieve and scanned and then we get a
mark well in that case it's red and then
F somewhere below further below on that
page it says well and F it's not you
know the end of the world but there are
some things that might be amended and
that's exactly what we'll do so we'll
talk about certain attacks and I'm very
aware that you hopefully know all of
these attacks and then we'll see how
there might be techniques in the browser
by default or not by default that helped
us battle those attacks so that's that's
what I'm about to do and then we'll
Emily come back to this at the end and
see what could be made better on their
website all right so I'd like to start
with cross-site scripting cross-site
scripting in the ovis top 10 the list of
the 10 most prominent security risks
which is released every three years more
or less the new edition is only a few
weeks away and cross-site scripting is
always one has always been in the top
three and I expect nonetheless in the
new edition so this is our website that
kind enumerates CVS and which kind of
security viability are behind that and
so this really shows that cross-site
scripting I mean you know it goes up it
goes down it goes down quite a bit at
the end but this is 2017 and if you look
closely that's more than zero right so
only three weeks in and we still had
across with scripting vulnerabilities so
it still is a major threat and for years
I've thought well a cross-site scripting
I mean cross shipping is really really
bad because I mean the idea is that an
attacker injects something in an HTTP
response most of the time it's script
code but also HTML for instance can be
dangerous and if it's drip code is
executed in security context of the
current page the origin you'll have a
look at the origin and in in a bit which
allows essentially the injected
JavaScript code to do anything that our
JavaScript code because it's our website
is about to do so very very bad
and so I know it's thought oka this is
very bad but B I mean it's so trivial to
defend against cross-site scripting
especially if you're in an HTML context
so we have HTML and then we have
user-generated input you know whatever a
search term anti on a web site in the
search field a term and the resulting
page says your search for XYZ has given
us these results so the XYZ is
user-generated content because it comes
from the user and if you're in the HTML
context the only way to inject something
like JavaScript code is to well change
the context how can we change the
context we thanked the brackets for tags
with single or double quotes for
attribute values and with the absent
character for entities if we escape
those five then we're good so this this
battle's most of the attacks also to
even further decrease the attack surface
we might want to secure cookies which is
something we'll talk about and we might
want to use something rather than you
right well it's not really new but
rather new called CSP and we will talk
quite a bit about CSP later today um so
actually defense is trivial but still
it's in the top three since I think the
first over top ten came about in 2004 or
even 2003 so almost 15 years now and
cross the scripting is so one of the
major threats why is that so well there
might be a myriad of reasons but still
we need to defend against cross-site
scripting and there are several ways of
doing so first I need to briefly discuss
the the actual impact of cross-site
scripting because it becomes important
when we talk about countermeasures the
idea behind the security model of
javascript is yes javascript does have a
security model and the security model
has a name it's the same origin policy
the same origin policy is based on the
term origin and the origin is defined by
ITF and
the rich actually means the protocol or
schema the fully qualified domain name
and the pork if all of these three
things match then two things have the
same origin the origin in an HTML
Javascript context is the origin of the
HTML page so if you load JavaScript code
on an DC - Lantern calm but the
JavaScript code comes from whatever
Google CDN because it's a JavaScript
library hosted there the origin of the
JavaScript library is an D salon.com
because any solana to come needs to run
the code and maybe wants to modify the
contents of the page thanks to Sam Rich
and policy well the originally salon.com
otherwise that would not be possible
this does not apply or the same written
policy does does not apply to the SRC
attribute you can code you can load code
from anywhere but the security context
the JavaScript code runs in is the
origin of the HTML page that loads the
code so just you know to make make super
clear what the same return policy means
the first three URLs they have the same
region because the using HTTP they are
using port 80 and the using example.com
as the fully qualified domain name the
seven down there those none of them
share the same origin because some of
them have different port like 8080 or
different protocol like HTTP or they
have a different domain name altogether
alright so that's why cross-site
scripting is extreme bad and extremely
dangerous so what can can we do against
it and actually the first let's say
development team that tried to do
something proactively against cross-site
scripting from a browser point of view
was surprisingly Microsoft ie8 and I
mean you know nowadays if you see I ate
at a customer site or your customer
tells you well we still do use I ate and
maybe you're not too thrilled let me put
it that way
however ie8 as as bad as it may look
today in comparison to modern browsers I
ate introduced a la
security features so it kinda was a
milestone especially if you compare to
IE 7 or even all the words and what I
ate introduced is a cross-site scripting
filter that was used for a reflective
cross-site scripting in order to battle
it
there is no setting in IE that
deactivates that filter so it's there to
protect users and well users cannot
disable that now what happens if you
kind of find out well the cross-site
scripting filter which turns up messages
like this kind of defeats the
functionality of my web application well
you know there isn't an honest answer
and let's say a more diplomatic answer
the honest answer is you do something
wrong please refactor your app but the
more diplomatic answer as well you may
use you may have found a very innovative
way of doing code execution if you
really want to do that you as the
developer can disable that filter by
sending an HTTP header X access
protection the value of 1 enables it but
well it's enabled by default 0 disabled
sitting there are other options too but
these are these are the basic options
right so you can disable the cross-site
scripting filter because thanks to the
same origin policy and that's why it is
so important thanks to the same origin
policy you as the person responsible for
the web server you're the one who is
attacked because injected code runs in
your original right so that's something
that's built-in in IE 8 it's now also
built-in in webkit-based browsers so in
chrome in Safari and Firefox is my
favorite cross-site scripting testing
browser because it does not have that
filter built it so whenever I try to
find an XSS vector I have to try it in
Firefox because the other browsers might
might block it you there are ways around
that filter because the design
principles of the filter was a the
filter has to be really fast so no long
analyzing of the input and B if possible
no false positives right because the
filters is a name
to give some additional protection to
users but the functionality of our
website should still be there so it it's
no excuse to not care about cross-site
scripting it's just an additional
safeguard I told you there would be
several headers today some of them are
quick wins this one is well it's it's
it's not even a quick win it's a win
that's already there because it's
enabled by default but the just that you
know but against cross-site scripting I
I think I have something better with I'm
quite quite excited about it does come
at a cost because the effectiveness of
that measure depends on how well let's
say well-structured your your web
application is but I think it might be
something very interesting for you it's
called concert security policy you you
may have heard of that before but let's
just have a look what that's about
there are three versions currently of
cotton security policy version one which
is a w3c candidate recommendation since
2012 so over four years ago there is a
version two which happens to be also a
w3c candidate recommendation from mid
2015 so it's 1/2 years old and there's
also version 3 which still is an
editor's draft stage so they're working
on that but nothing nothing is done yet
pretty pretty interesting it's a feature
that is supported by all major browsers
depending on the version number and
depending on your definition of major so
a con security policy one this well it's
supported by all relevant browsers also
by current versions of ie
which I think it's a pretty pretty
positive sign and toups sorry sorry my
bad is moved but it's just going there
we go
so consequence 1 is kind of supported by
all browsers sorry if I e 11 it's a bit
worse with content security policy
version 2 because con security version
version 2 is
offers really really useful new features
as we'll see however the IE support is
let's leave a little bit to be desired
as you know there will be another major
update to Windows 10 this year and this
will also come with the new edge browser
version 15 internal version number that
one will have support of CSP 2 so in the
not-too-distant future all up-to-date
browsers let me put it that way
will have content security policy
version to support up until now all CSP
2 features were best in chrome and
mostly in Firefox and Safari but not in
Microsoft browsers yet but we'll see
what but the what that actually means in
a bit and well version 3 is just you
know a draft so and nothing nothing
special to mention here the idea is this
the web server sends an HTTP header and
the HTTP header contains a policy a
policy that is telling the web browser
how - well handle content on that page
there were different versions of headers
especially when content security policy
was still standardization face and it
still is you saw CSP 1 &amp;amp; 2 they are
candidate recommendations they are not
recommendations so they never reach the
final status but they're already working
on the next version so maybe it's I
don't know something like Duke Nukem
right so you know eventually eventually
we'll it will be released eventually and
so there was the various different
headers nowadays all model browsers use
the content security policy header if
you see some you know blog post or
documentation with mom viola head us
that usually means that the
documentation is outdated one of the
interesting features of content security
policy version 2 is that in those cases
where you cannot easily inject HTTP
headers in in the response from the
server you can also use a meat attack
with the meta tag you can emulate some
HDB errors including set cookie and
others and what you can also do now is
do accept the content security policy
ahead as is shown here but only from CSP
- so in order to still support ie
if you're using CSP version 1 then
sending HTTP era is probably the best
way and this is how content security
policy looks like we have a header and
then we have several directives
directives are the keywords with the -
and directives can have one or more
values so we have two directives here
default SRC self which essentially means
well everything that is loaded from from
the web page using the SRC attribute
usually must come from self which is a
content for the current origin so
basically we can only load content from
the current origin everything needs to
come from our server so if someone
injects script SRC equals HTTP bad
server com slash bad script ojs that is
not loaded because the policy prevents
it and what I'm also doing here is that
all the images on that page they are
loaded from static dot example that
comes all the images must come from a
specific server actually it's have a
look how that turns out I have here a
simple MVC based application and what
i'm doing here is if i call a specific
page with a query string argument of CSP
equals 1 in that case I sent a content
security policy just default SRC self so
load everything from the current origin
and if I go to the CSP page what we have
here is we have a logos of an image we
have a beautiful orange colors bulleted
list with two links one two question
marks is people's one and the other one
not and what do we also have we have
inline JavaScript code here and we also
have external javascript code here's an
external file the inline code as you see
here alerts out inline and the external
javascript code does an ajax request to
an endpoint on
server which returns external and that
Texas then well printed out let's have a
look in the browser how this looks like
so we go to our CSP example and the page
is loaded and you see okay we get a
JavaScript pop-up in line okay fair
enough and then external worked we have
the orange list with the two links and
we have the NDC line and logo and what
I'm doing now is I click on the first
link and if you're sitting on the front
rows you can see very small in the top
in the bottom left corner that we are
calling the same page but with the CSP
equals one appended to URL so we load
the exactly the same page but this time
with the header and well you see the we
get the external pop-up we did not get
the internal pop-up and when I click on
that the page renders and somehow the
color is gone hmm something went really
really wrong here well you probably are
already guessing what's the problem so
what was deactivated the color which was
an inline style and the inline
JavaScript code so in line is considered
dangerous so by using a content security
policy that includes policy for scripts
you disable inline markup like inline
JavaScript and inline starts which is
well if you ask me it's a good thing but
it really depends on how your page is
set up and if we go to developer tools
and have a look we see that in the
console we have a couple of messages
refuse to execute inline script refused
to apply inline style so the content
security policy prevented us from
running that script and executing that
code and displaying that style and
that's a good thing because how does
cross-site scripting work usually there
are two attack vectors one is someone
injects script as our C equals bad
server calm as I explained but where
since we set our policy to only use
content from our own origin that code
will not be run if Kanta security policy
is enabled so that attack vector is
closed if the browser supports content
security policy
what's the second attack vector the
second attack vector is an attacker
injecting inline JavaScript code in LAN
javascript code is a bit trickier
usually right because it then seems to
come from our server there is no
additional HTTP request to another
server however as you see here by
default inline script code is disabled
when using content security policy so
that second tag vector is closed as well
so what's what's the only way to manage
to do cross site scripting now if CSP is
enabled for an attacker well you saw
there was only one bit of code that was
executed and that bit of code was the
file that resided in our server so if an
attacker manages to upload a JavaScript
file to our server
then yes cross-site scripting is still
possible however if an attacker manages
to upload a file to our server
cross-site scripting is probably the
least of our problems so I would say the
cross-site scripting issue can be solved
if we're using content security policy
so really consider using that I will
very very briefly guide you through some
of the features
real quick of content security policy
and then give you some pointers how you
can use con security policy because
there still is a catch I have to tell
you all right so there are several
directives we saw the default SRC
directive kind of the mother of all
directives there are more specific
directives which can be used to override
the setting in default SRC for instance
image' SRC for images script SRC for
JavaScript and style SSE for styles
there also some changes in CSP too I
just put them here for reference so when
you have a look at the slides later you
have a very good very good overview so
these are the directives that exist all
these know
the directors that exist and they can
have different values and those values
are I think noteworthy there is
something you haven't seen this from me
right someone else told you that you can
use you know the Stars and asterisks
this kind of means everything but you
don't want to use this right someone
else told you that you can use a region
as we did
starting with CSV to not only in the
region but also URI so you can have pass
in here and then we have a couple of
constants constants are delimited by
single quotes
we already saw self which means current
origin none is I think obvious and then
we have two more and you know usually
when you have a standard the standard
shouldn't be opinionated right then a
Senate should say what it is but the
Senate you know should not mock you it
does because we have unsafe inline and
unsafe eval so this is like the like if
the standard was saying okay you can
activate this and that but well then
essentially you are kind of stupid
so really this is a very I've never seen
anything like this in the standard
before ever constant like unsafe inline
so this is a bad idea in line and this
is a bad idea eval for evaluating code
so JavaScript eval function function
constructor and stuff like that so yes
you can activate inline styles and
inline JavaScript code if you need it
well and sometimes you do need it for
instance one of the biggest users of
content security policy around the first
users is Twitter and if you look at the
policy twitter is using because you know
twitter is loading so many assets and
has so many different sides and people
calling in from other domains and stuff
like that that the twitter secure policy
is extremely long and it's using unsafe
inline and if you're using unsafe inline
this this attack vector suddenly
reappears right so you do gain something
but so try to avoid it but it's not
always possible so maybe maybe some of
you and someone someone asked in another
talk yesterday who was still maintaining
web forms applications a spirit web
forms and some hands
showed s period reform stay out put
quite a bit of inline javascript code
and also inline styles so with that
called security policy is difficult but
we will talk about kind of a potential
potential remedy for that because if you
go to the to the browser again and if
you actually move this up a little bit
so you can see that tiny bit better what
you can do is you can calculate the hash
of the inline JavaScript code and put
that in the policy right so in your
build process you have a look at the
JavaScript code but you have to be super
careful you have to also take whitespace
into account carriage returns etc you
calculate the hash and then in the
content security policy you provide that
hash value so now the browser knows hey
if there is code that has exactly that
hash I can execute it and if you have
code that never changes you can also
just you know you Strohm have a look at
that error message and you have the hash
that works there are other options too
but still it's kind of complicated
and that's a content security policy
version to feature so if you are using a
browser does not support that then the
browser doesn't support the hash here
all the browser sees is oh I cannot run
any inline code and then your code
doesn't run so that's probably not what
what we want to do so that but that's
that's that's an option you can you can
consider consider using here for inline
code and there are other options too but
basically that's that's what what you
want to that's what you want to do now
the problem is such a call security
policies as you see here if there is a
violation of this of the policy there
are two reasons why there can be a
violation of the content security policy
one reason is you forgot something so
let's just imagine you said you're using
default SRC and you just say self and
then you are also adding the server name
of the add server where you display ads
from and off let's say Google Analytics
right because you're using Google
Analytics and that code is loaded from
another server you so you
need to put that in the list too but
maybe the ad server script is loading in
another resource from yet another server
if that's not in the content security
policy list that is not loaded your
users might be happy because less ads
but still you probably want the ads to
be displayed so you have to be careful I
need to enumerate which kind of servers
and which kind of origins you're using
on your websites that rule for that as
well but the problem still is if you
mess something up then you have a policy
violation and maybe your website doesn't
work as well there's only one other
reason for a policy violation you have a
security vulnerability and someone tries
to exploit it so actually there's a good
policy violation but how do you know
about this policy violation and that's a
pretty amazing thing there is a an
additional option called report URI your
report your eyes a directive where you
provide a URI and once there's a policy
violation and a TP request is sent to
that you arrive with all the info which
line which file which violation which
payload etc so you kind of get
automatically informed when your policy
is violated the browser sends that to
your endpoint you have to create the
Empire yourself or you can use a service
like report your I dot geo it's dot IO
sorry it's the same the gentleman behind
that this is the same one that also did
the security Heather site I showed you
at the beginning that's still very nice
but yet you have a policy violation
which means that something is blocked
which you maybe do not want unless it's
an attack so there is another thing
ahead are called content security policy
report only it's the same thing as
content security policy but the policy
is not enforced so the website runs as
before but if there's a violation they
inform you or the browser informs you to
be exact so once you have recorded
security policy and you refactor your
website that you do not use inline stars
and do not use inline JavaScript code
then set up the policy and send it with
the content security policy report only
header and then let it run for two
and NZ if anything is reported or not so
you can have a dry run so to speak of
that policy without any functionality
not working any longer on your website
I'm really excited about the technology
you should really consider using that or
at least evaluating that for for your
web application I've had a lot of
customers with implementing this and
really the attack surface just just gets
smaller which which really helps every
little helps
all right so that's a very quick -
through continuity policy but there's a
little bit more so one of the let's
assume there's a successful cross-site
scripting attack one of the attacks that
happen quite often when cross-site
scripting works is cookie hijacking
which means that cookies are somehow
stolen the cross-site scripting it's
easy another option is to steal those
cookies in open networks like here the
conference or the penguin show tell
you're staying but usually it's open
Wi-Fi which basically means that
everyone gets all the data in the
network but the driver on the network
heart just you know picks the data
that's for us and of course there are
other drivers that you know also have a
look at the data that's not meant for us
and also a little hardware dongle stead
enabled at I think it's previous
editions of the conference some some
even tried that out so be really super
careful when you're using such an open
Wi-Fi just just in general and the
problem with the stone cookie of course
is that quite often such a cookie
contains sensitive data usually a
session ID and that session ID is used
for authentication now we have to
protect those cookies and actually there
there are interesting ways cookies were
invented by Netscape HDB the protocol is
stateless so doesn't remember anything
but let's go out well it's sure to
remember something so in that
specification this is archived here
pretty interesting
the set-cookie header had an option
called secure secure means if we if this
cookie is sent from the server to the
client that the client
to store that cookie to accept it then
the cookies sent back with all
subsequent requests to the same origin
but with the secure header only if the
connection is done via HTTP this doesn't
help against cross-site scripting but it
helps against open wi-fi's because an
open Wi-Fi if we have HTTPS and
everything is configured correctly then
the data is encrypted the data is
encrypted before even HTTP headers are
being sent so we are we're safe there
the other thing is that again Microsoft
invented something surprisingly and the
other browser developers state chimed in
and we're also using that is another
cookie option called HTTP only HV only
says setting you see when you create
cookies with C sharp and asp.net it's
also an option in web config which you
can set for session cookies and I do
recommend you do that and what HP only
does is this cookie is only sent via an
HTTP connection and together secure only
via an HTTP connection what does that
mean well JavaScript has access to
cookies too and if you have cross-site
scripting and can inject JavaScript code
and those cookies well might be
accessible to the attackers JavaScript
code if we said HTTP only then
javascript does not see that cookies at
least that's what the specification says
it's not completely correct but it's
close enough
there is one workaround and I think we
have the time I will show you the
background I have here the tool I'm only
resting which is like you know like like
postman where you can send HTTP requests
and I have an is here on my local
machine and what you probably can see
here is I have a URL and I can set a
method egg I guess at header so let's
just say I am you laid a request to the
server and I send something with it
automatically cookie whatever session ID
equals ABC 1 2 3 and if someone manages
to a tear to inject dangerous JavaScript
code
they can do an ajax request to our
server right because that's what
javascript is allowed to do and instead
of sending a get request they may want
to send a trace request and if we sent
to trace request this is what we get
back the trace request is a debugging
feature so the trace request sends back
all the HTTP headers we have been
sending to the server including line for
the cookie header so even if a cookie is
secured by HTTP only if JavaScript can
send a trace request to the server
JavaScript we had access to that cookie
now why is this this is called a
cross-site Racing by the way why is this
an attack that's well not very common
and actually not very well known because
well I had to configure is that it
accepts trace requests usually trace
requests are disabled for most web
servers but you might want to check your
own web server if trace is disabled if
not disabled because well you don't need
it the only person needing trace for
HTTP is the attacker for that specific
attack vector so you can easily disable
so we can kind of protect cookies by
using secure and a cheapy only and this
aiming trace but there's something
better because HTTP is key and as you
know browser versions said I think the
the chrome version that comes out in a
couple of weeks kind of eras out when
you have for instance a login form
that's not using HTTP so using HTTPS is
more getting more and more important
so maybe you want to enforce HTTPS and
there are ways of doing it one standard
here is HSTs HTTP strict Transport
Security which works in the following
fashion
so we send an HTTP request to the server
with HTTP so no HTTP and the cell wants
to make sure that you never do that
again the server then can send a strict
Transport Security HTTP header there's a
couple of options and this is does two
things first of all the connection is
switched to HTTPS and secondly the well
that's that's one of the prerequisite
actually but what then happens is the
browser remembers that so whenever you
go to let's say NDC London come head
this header whenever the browser goes to
HTTP colon slash slash and the salon.com
and you type this in and press Enter
then the browser sends a request to
HTTPS and salon.com so no more attempts
of sending unencrypted requests to that
server as long as the max-age timeout is
not it's not met so so year two is I
think a good idea model browsers do have
a preload list so a list of domains that
kind of signed up for being preloaded in
that list and it's not just a big
domains and there are also smaller ones
too and there are there are several
steps involved in order to become part
of that list what you need to do is you
have to do a redirection from HTTP to
HTTPS you have to use HTTPS on all
subdomains and you have to send a strict
Transport Security header and add
preload at the end and once you've all
done this then you go to the special
special world website and on that
website you just put your domain name in
here check States and eligibility and
then eventually your domain if you did
everything correctly will be part of
that list right so everyone was using a
browser even the first time they try to
go to let's say HTTP any salon.com they
will use HTTPS because the preload list
instructed them to do so you have to add
the preloads
at the end until your part of the list
so it's impossible that some other
website or competitors are kind of puts
you on the list with all your knowledge
right so you have to actively do that
really great because then really zero
requests are being sent with HTTP to
your web sites any any longer and also
no mixed content warnings etc so this I
think is a good value this should be
approximately two years which
pretty pretty nice so that's a kind of a
new center but we talked about content
security policy already and there's also
a way of enforcing HTTPS with content
security policy there is a new a new
directive called update insecure
requests it's not part of a content
security policy stand out it's a
different standard but it kind of you
know joins in with content security
policy and what this does is exactly
what the name says it upgrades insecure
requests so let's just imagine you have
this policy and on your page there is a
link to http whatever any salon.com then
you if the user clicks on it it goes to
HTTPS and salon.com this is a feature
that's currently only supported by
Chrome and Firefox so it doesn't always
make much sense to send out that header
of the browser doesn't support it
however for instance edge has this
feature s under consideration so it
might eventually come but it will not
come with the next Windows 10 update
however browsers that do support this
that do support this feature when
sending an HTTP request they send along
as you see here a header with the HTTP
request upgrade insecure requests value
is 1 and if you get that header you then
as the server in turn could send out
call security policy update insecure
requests in order to facilitate
facilitate that feature for your web
application and finally since we've been
talking so much about secure connections
and HTTPS there's one more thing and
that's public key pinning the idea here
is the following just imagine you know
you buy a a certificate from some
authority and then that one gets hacked
that's happened before right so someone
might be able to issue a new SSL
certificate or TLS certificates in your
domains name which well is not that good
right what you can do is to use HTTP
public key pinning
the header is called public key pins and
public key pins then expects a list of
well of the hashes of cryptographic
identities which you trust so for
instance that could be the hash of your
certificate and well either you buy a
backup certificate as well so because
just putting in one usually so so either
by a certain certificate or you do a
sign-in request and use that hash so if
your certificate whatever expires or
something's wrong with that you still
have the designer request and then can
can set up a a new certificate so do
public key pins you provide the hash
value that's usually where I mess up
because I always have some issues you
know doing the doing the calculations
right for that hash but eventually I
succeed even I succeed and this is good
for I guess the one month and well then
you sent the the header and then the
browser refuses the connection if the
the hash of the certificate doesn't
match again the issue is what if you
mess up because then no one can use your
website any longer so there is also a
test note it's the same as Wisconsin
security policy the headers then called
public key pins report only and again
same is called a security policy there
is a report
URI option it will be renamed in a few
years maybe but currently it's report
URI and then well the browser sends if
there's a violation request with the
violation information to URL you provide
however still your web site continues to
work remember the report your i dot io
service i briefly mentioned before that
one works for this kind of reports as
well alright so these were all options
of you know getting secure connections
and there are other other attacks I
would like to talk about towards the end
and one very common attack is cross-site
request forgery cross request forgery
once again if we look at the numbers of
abilities by typing here
so I mean this is just kind of went up
pretty high and for some reason it went
down significantly in 2016 and well
again 2017 but we are far above zero
three weeks in but so so it's it's a
problem it's a problem that is not as
let's say prominent or widespread as
cross-site scripting not necessarily
because the issue does not exist that
much but cross-site scripting is easy to
find easy to detect or easy to prove
cross-site request forgery sometimes
again well requires a bit more effort
also for cross-site request forgery or
what we need to know is that many
frameworks now come with cross-site
request forgery protection sometimes you
have to enable it but still more and
more systems do have that now I don't
want to talk about trust request forgery
in particular because there is no HTTP
header that can protect us from that but
I like to talk about another let's say
version of that across the request
forgery usually means the user doesn't
do anything but there is also a version
of trust on request forgery where the
user does something and the version I
want to talk about is called
clickjacking so this is a screenshot
from Facebook and I didn't I didn't do
anything with that right so I censored
that word here but apart from that
that's a true screenshot and I know I
know that person and let me just say I
was I was pretty surprised that I saw
this right and of course I mean you got
to do what you got to do so I went on
researching so I had a closer look on
that the page referenced here and I have
to I have to page here with me actually
no I almost have to page here with me
but it's in a bit of a different fashion
so this this kinda is the page right and
so when you go to the page you see a
link here saying click here and again
front rows might see that's bottom left
corner this goes to google.com and there
is zero JavaScript on a page right so I
wouldn't trick you at least not that
cheaply
if I click here then it says account be
lead it remember it wasn't that this
this button do not do this what's what's
wrong what's wrong here well actually
let's let's have a look at the page I'm
a bit confused so so we have here some
CSS I don't know CSS very well and we
have here a link and well the scroll bar
is suspiciously small but but but still
I mean it's just a link right so let's
maybe change the CSS a little bit reload
that page and what you see now is that
on that page we had an iframe and the
iframe contained the page with the
button but you CSS that the iframe
doesn't show so we want to click on the
link but instead we clicked on the
button that's the you know that's that's
the layman's version of a click tracking
demo there are much more elaborate
versions out there that you know are
used by attackers where the JavaScript
code that moves the iframe to where your
mouse pointer is right so wherever you
click the button is already there and
what was happening with my friend
Stephan here is he was kind of informed
of the page and when he went to that
page he saw a button click here to
whatever get access but when he clicked
on that button and I saw that you know
when I loaded the page and had a closer
look he clicked on the facebook like
button which was hidden in an iframe
underneath that button and this is
really bad
it's called clickjacking and I mean you
know cross-site request forgery it's a
common attack come countermeasures but
here the user is actually clicking on
the button right the user is clicking on
that button what can you do you cannot
forbid people from clicking on a button
what's the prerequisite for that attack
the prerequisite for that attack is I
mean just made the the button is kind of
a metaphor for
any button that has consequences in your
web applications for instance add an
account delete an account make someone
an administrator buy something so it's
usually a different page that is loaded
in iframe so what's the prerequisite the
attacker controls the outer page and
tries to hack the inner page the
prerequisite is that the inner page can
be loaded in an iframe well the older
people in the room probably remember the
1990s can you well if you remember the
1990s you haven't been there as they say
but in general in the 1990s we had
frames and people were using frames to
steal content from other pages and load
them in one of the frame some of your
members you nodding and what did we do
back then well there were some
JavaScript snippets frame Buster's and
those frame Buster's try to detect okay
am I in a frame if so what ever redirect
so if you still have the code you wrote
in 1995 then you might you know go to
your archives and use that code again
but well it's 2017 so we have better
measures once again there was something
introduced by surprisingly I ate an HTTP
header called X frame options X from
options as ahead are telling the browser
and all browsers nowaday supported okay
either deny this page cannot be
displayed in an iframe or same original
this page can be displayed in an iframe
but only if the outer page has the same
origin as the inner page means we can
frame our own content
we cannot be framed by someone else have
a very very simple example here I have
two iframes here and both loads
the same page it's a page that just says
frame data or sub like that however the
second one use a set header equals one
and implementation on the server sends
the X frame options header with value
deny once set header equals one is there
so when I load that page we'll get two
iframes loading the same URL the same
document but the second the right iframe
will have the X frame options header and
that's how that how it looks like so you
see the second iframe remains empty if
you're using ie you even get one of
these pretty error messages so even more
embarrassing and that's what I call a
quick win right so if you have a page
where one click has an effect maybe even
two clicks if you do a good kind of
social engineering or the clickjacking
attackers executed well if it's several
clicks shouldn't be a problem but if you
have a page where one click does
something and you have a user that
authenticated and that victim does
something
just use extra options deny and you
close the attack vector and actually
there's no really there's a really good
alternative right because I mean you
cannot prevent the user from clicking
but you can prevent the browser from
loading quality security push policy
version 2 also has a directive that
prevents this that has the same effect
so eventually the X frame options header
as you see it's after the next so it's
kind of preliminary header will be
replaced by the content security policy
directive however as of now it's CSP -
there is no I support for it and so we
have to stick with X frame options
because that works back to ia and it's
actually the only difference all right
and well one one more thing it's it's a
smaller smaller aspect but still some
browsers especially I Ian Chrome late
they tried to guess what kind of file
type we have now there is an established
mechanism for that and the established
mechanism is having a look at the mime
type right so the server sends content
type HTTP error and that contact HP
error rules usually however I in chrome
sometimes want to be more clever
and then the web server so they have a
look at those files and ignore the
content type header if they think you
know oh that's that's not HTML that's
something else well if you figure out
you know drive-by downloads right or if
there is a way that users can upload
content and you give that content
whatever a file extension and that file
extensions trigger the content type
however the content of the file looks
like something else maybe someone could
for instance inject JavaScript code
imagine you whatever allow the upload of
text files and there's JavaScript code
in it and then an overseas browser
considers well it's JavaScript code
let's just execute it for good measure
this can be avoided with the X content
type options header not very well known
it only has one value no sniff right so
browser do not try to sniff the content
trust the content type setting of course
the prerequisite here is that you do
have a content type setting and that's
that's correct well let's go back where
we started and have a look at the scan
result for a conference website and so
what we're complaining there's no
content security policy and well content
security policy is great and effective
but it takes time and effort to create a
good content security policy and of
course the website needs to be prepared
to that so I mean it's marked as right
here but is this a problem I don't know
I would like to love to see a continuity
policy but well if you don't have one
consider using one but if your
considerations turn to the decision no
we do not want one then well that's the
decision we have extra options which is
missing here we do not have X XSS
protection as I told you it's enabled by
default but we can also enforce it if
you know there's a group policy
eventually still disabling that feature
so we can specifically send this and
also its content type options is the one
we we discussed last still it's just no
a problem because you know
conference website and conference
website has has an F well it really
depends the conference website is not a
let's say a it sounds the wrong way a
precious website what what I mean is of
course it's important website but it
doesn't process any user data there are
no actions on that website they do
something why because ticket sales is
done on another site right and the
ticket sales website has a better score
but really again on the on the on the
conference website you cannot do
anything so click jacking is not an
option it displays information since
this place information doesn't accept
user inputs cross-site scripting attack
surface is rather rather minimal and
there's also no need for security policy
more or less right so once again that
there is no 100% security right we
should try as hard as possible but at
the end of the day it's all risk
management and the risk management
assessment for conference websites as
well there's a real risk involved here
the risk is if there's a risk involved
it's where the conference tickets are
sold and so always take all of this with
a grain of salt identify what are your
risks and then talk about remedies and
as we could see here many of those
remedies may mean in many of those HTP
errors they extremely effective and many
of them are cheap to use it takes
minimal effort to use them but you have
Paxman game and with that that's all I
had thanks for coming in to our rest of
conference so good I thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>