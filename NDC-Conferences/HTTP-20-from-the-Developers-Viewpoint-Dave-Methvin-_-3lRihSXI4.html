<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>HTTP 2.0 from the Developer's Viewpoint - Dave Methvin | Coder Coacher - Coaching Coders</title><meta content="HTTP 2.0 from the Developer's Viewpoint - Dave Methvin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>HTTP 2.0 from the Developer's Viewpoint - Dave Methvin</b></h2><h5 class="post__date">2016-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_-3lRihSXI4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's built with a beautiful bunch of
images and tables this is the way real
people laid things out back then but
we're going to upgrade that protocol
with h2 it's going to to do a full
upgrade you need to have the browser the
server and any important devices in
between being able to speak that
protocol if any of them don't
you'll just be left with h1 this is not
so bad I mean you know how to deal with
that and you've been dealing with it for
20 years but h2 is really going to
change things it really started when
Google started looking at some of the
problems with h1 and they said we think
there's a better way to do this we we
can find a way to speed this process up
so of course being that they wanted to
come up with a good marketing name they
use speedy and I think that's an acronym
for something but it doesn't really
matter they introduced that in chrome in
2011 and it didn't take very long for
other browsers to see that it was faster
and included as well but there's you
know the major driver was that chrome
had it and that Google server supported
it and you can see today that it's
actually all that green it's pretty
widely supported really the only major
red spots that you might encounter are
Opera Mini and the UC browser for
Android which is primarily used in China
so otherwise pretty much all the
browser's that we're using on our phones
and desktops all support h2 already is
speedy already the the change with h2
was that all of the people realized that
speedy was kind of ad hoc it was it's a
Google experiment and they really
everyone including Google wanted to go
through a process to standardize this
and considering how long we've been
working with h1 it didn't take very long
by this year by last year they had
completely standardized the protocol and
here's when you know P things are
getting pretty serious speedy is
actually gone in chrome 51 which is the
currently shipping version of Chrome so
they said I think there's a there's a
way to turn it back on with a setting
but by default speedy is not there
anymore and that was that was Google
saying okay guys we're really serious
you know we're not gonna be supporting
speedy the rest of our lives so when you
if you've noticed things slowing down
for some websites it could be because
speedy support has been withdrawn but
we've got h2 and it's supported pretty
much as well as speedy was supported
there's some funny colors here in the
graph you'll see I 11 the reason that's
kind of a funny green is because in on
windows 7 it's basically IE support
depends on the network stack in the
version of Windows you're on and again
we see some laggards in China that if
you're if you have a heavily Chinese
oriented audience it's possible that
they'll be on h1 for a long time because
probably the Great Firewall of China
doesn't support h2 you can also see that
it's not just the server side I
mentioned that it needs to be the path
all the way through you can see that all
of the network plumbing out there
there's a lot of green on this list so
you can see that important devices
including servers like nginx now support
h2 nodejs has an h2 module so we're
looking really good there it's there's a
few a little more red here by the way to
focus on the last column there's there's
some other parts of this having to do
with TLS and security that is also
important for performance but looking
just at h2 you can see that the main one
that I would that I see as being an
impediment to people switching is Amazon
Web Services it they just haven't
finished there's a
of age too but almost everybody else
except for you see the chinese china net
center don't support it in EdgeCast
which turns out to be a pretty important
player as well they're just a little
slow on quite a few of the important
security issues h2 is being used by some
really big sites so you know there's
there's people who are kind of force
multipliers in in our world and you know
when wordpress supports h2 then all the
blogs that WordPress hosts are
supporting h2 same with blogger and
medium there's some ones like tumblr
that still don't support h2 mainly
because they're on edge cast and you're
going to see them running h1 rather than
they were supporting speedy but they're
going to really fall back so I expect
that that will be a prod for them to
speed up their implementation of speedy
of h2 so why do we need a new protocol
well the main reason is because h1 is
pretty dumb and it's something it's a
lot like internal combustion engines
we're so used to burning gasoline that
we don't realize how inefficient and
messy and you know just all the horrible
things that internal combustion engines
do it's kind of like h1 we're so used to
having to do multiple connections and
combining files and creating sprite
sheets and trying to tweak our HTML so
that things get loaded in the right
order we just you know we just think
that's the way you develop web
applications because we've been doing it
for so long and the reason we're trying
to do all those things is because we
need to fight latency latency is a real
the round-trip time between you and the
server is a killer and we just can't
improve the speed of light that means
that you know especially when you're
trying to go from here to the United
States or to Australia those times are
horrible
and latency is something that we can't
overcome we can only try to figure out
ways to make latency less of a problem
we've one of the other ways that h2
tries to fix our issues is it's a binary
protocol I love asking this question
because I always get a few hands raised
how many people use telnet to debug
their sessions all right there's the guy
right there I always say when's the last
time you did them there's also the guy I
do it all the time well not anymore
you're not going to do it because as a
binary protocol you really kind of have
to fall back to tools to do your
debugging other than just telnet you
can't just type text into a window but
there's already plenty of tools for this
you know the fancy or protocol analyzers
like Wireshark do it browser tools
inside chrome and all the others will
tell you whether you're negotiating a h2
connection h2 requires a secure
connection so you need although there's
nothing in the protocol itself that says
you couldn't do it unencrypted it turns
out that everybody got together and said
you know it really doesn't make sense to
do these unencrypted connection they're
trying to push the world towards
encrypted connections and probably the
NSA has something to do with that I you
know there's probably a lot of reasons
why you want an encrypted connection
there's a little bit of handshake
overhead I'll be showing you some some
benchmarks it turns out that actually
the improvements in the h2 protocol make
things faster to the point where it
overcomes this slightly increased amount
of TLS handshake overhead so let's look
just a quick schematic of what h1 does
and why it can be it can be slow for for
a single connection to a server
there's this delay I can send
information once I start once the server
start
sending a file to me though there's no
way to stop it it just if it's a big
image for example I'm showing here if
you look left to right our server is
sending things the first thing that sent
was this big image which is 500k there
was no way like even though there's
smaller files and you might want to try
to get them to you before the big file
it was too late once you start that
connection and send that data there's no
way to stop in the middle with h1 with
h2 it's actually possible to stop in the
middle so even though the browser on
this phone started asking for big image
JPEG it later decided that it really
would rather have these CSS and J's
files because it knows it really doesn't
want to do its initial render until it
gets the CSS and J's those are render
blocking resources in most cases so
fortunately with an h2 connection the
server can say okay wait a minute if you
need these things more I'll just stop
sending the JPEG file and I will send
you these more important resources
instead we'll come back to sending you
the rest of this big image in a minute
so that's an extremely valuable thing to
be able to do with h1 one of the other
problems that you run into is even
though you can do multiple connections
every time on every connection you send
this huge user agent and if you know the
history of the user agent you know that
it is really a huge pack of lies and
it's it's a large pack of lies
unfortunately so this is the user agent
for the latest version of Microsoft edge
and it says it's Mozilla but it could be
Apple WebKit but it could be like gecko
and it's Chrome or Safari but it's
really edge the the other aren't the
others aren't much better
I believe the chrome the latest chrome
is for Chrome 51 is about a hundred and
twenty bytes so we're talking about a
large number of bytes that gets sent
across the line
in every request it's just a waste of
upstream upstream bandwidth well we have
a solution for this in h2 it's called H
PAC compression there was actually a
more efficient way of doing this that
was in speedy but it also had the
ability to create more denial of service
and security exploits so they went with
a very very simple Huffman encoding
process for H pack and you can see over
here with request headers these are the
request energy would expect to see on
each request that was going across a
connection what we can do is first of
all in in an h2 connection there's a set
called the static table and these things
that knows already in advance everybody
is like in the static table as things
like method is get when you think about
how many characters that is that it
wastes it's Emmy th OD : space GE T
carriage return line feed that's a lot
of characters well instead now method
get' is - it's just - the number two so
it saves a lot of bytes for ones that
change it sends a dynamic dynamic table
so that huge long 127 byte user agent
it's sent once and then it becomes the
number 62 and from then on it just for
every other subsequent request it can
just send 262 knowing that's that
hundred and twenty seven byte requests
so you can see that H pack allows us to
really shrink down the amount of data
we're sending in the connection let's
take a look as a software developer at
the kinds of things that we do to try to
make connections work better and some of
these things still apply some of them
need to be changed we you know these are
things that are in Steve Souders seminal
things rules for good software
development minimize DNS lookups we use
HTTP connections use a CDN eliminate
unnecessary request bytes
assets cash resources there's a few more
there as well but I focused on some of
these because they need to be tweaked I
always pick on Huffington Post as a
example of a site that is a nightmare
this is actually pretty typical though
it's also very typical of WordPress
websites anything that has a lot of
framework to it and I would say even
frameworks like angular quite often end
up growing to being very big and having
large amounts if you're using something
like bootstrap most people don't try to
reduce the amount of bootstrap they just
dump it all in there so you end up with
something like this but that's not all
there's this but it's even worse than
that there's this two hundred and forty
requests 3.8 megabytes for one page and
again this is not unusual if you look at
I think the average web page size is
creeping up on two megabytes now so what
come what can we do that was done in
that huge two hundred forty requests
let's be realistic first we know that we
are not going to get the average app or
web page that you build down to ten
requests it just ain't gonna happen
so how can we change it so that when we
need to make 200 requests we can make
them more efficiently one thing we can
do is rethink domain sharding the idea
of domain sharding is that we can
request from the same server with
multiple connections in order to improve
our bandwidth to the server and we do
that because of that round-trip time
problem we have an h1 you can see that
with Huffington Post because they use
actually different domains
now this violates that rule of
minimizing DNS lookups so ideally if
you're using h2 you would get rid of
this entirely and just request from one
domain because not only do you have to
do another DNS lookup each connection
requires a warmup period where the
server and the client negotiates saying
I'm going to send you some data if I
start sending it too fast and
losing packets I'll slow down but in
that in the meantime it takes that warm
up to figure out how much data can be
sent over the connection the other
problem is I'm now I now have ten or
fifteen or twenty connections open at
once all of those are competing for
resources and that can cause congestion
and retries and even on each one domain
sharding is not a gimme as a performance
improve or in most cases the research
has been done say that two is the most
you should ever use well it shows here's
an example that shows that two is still
too many this is a look at
webpagetest.org showing our s HuffPost
comm and i dot HuffPost comm and if you
look here when I was busy s was not busy
so we weren't really even using the
connections in a way where we needed two
different domains but we paid this cost
of looking up the domain and warming up
the connection twice so we didn't really
want to do that when you look at
webpagetest at the bottom you'll see
that this green line ideally you want to
be using your connection maximally you
want to try to use all the bandwidth
that the connection is giving you and
you can see yes it actually took I think
12 seconds to load but between 3 &amp;amp; 6
seconds we were hardly hardly using the
connections at all so so we spent 3
seconds just like doing nothing and you
can see we weren't using the CPU heavily
either so we were really wasting our
bandwidth we had probably a lot of
delays in there on round-trip time
delays now it turns out that h2 has a
solution that is friendly to both h1 and
h2 if you have a certificate assuming
you're going to use the secure
connection and you should if you have a
ticket that's valid for two different
domains and the names resolve to the
same IP address
h2 will use the same connection for both
hosts now it requires some work on your
server side to make sure
that it understands its multiplexing
those connections but that's why you got
the TLS wildcard certificate for both
when you do that you can use sharding in
the in the case where it actually was
beneficial it wasn't here but you can
use sharding for the case in h1 where
you need it but you won't pay the
overhead in h2 so you really kind of get
the best of both worlds one of the other
tricks that people use to reduce their
their upstream bandwidth is something
cord and stream bandwidth as well is
something called cookie list domains and
so in this case if I set a cookie for
the main HuffPost comm site so that I
can send information back and forth
probably I don't need those cookies for
images and so the reason I may have set
those domains differently in the first
place was so I didn't need to send
cookies back and forth between those and
use up more bandwidth well with H pack
it really doesn't matter we don't have
to worry about those things so you can
get rid of the cookie list domains and
just use a single domain the other trick
that you'll see in this HuffPost is that
they were using a server-side script
combining program it happens to be in
PHP that was taking a bunch of different
CSS or GS files and combining him into
one big lump and that was a part of a
best practice especially for h1 that
said okay well you want to reduce the
number of requests so I'm gonna send you
this giant URL and on the back end it's
going to cache all these things
obviously but I'm only going to send you
one big file that's the combination of
all of these JavaScript or CSS files
however even though it reduces requests
think about what happens when any of
these files change in my case you know
maybe config dot JSON you know a config
dot Jas changes because I've changed my
configuration Ivan validated this in
tire lump of code now it's going to have
to put a new cash Buster in here which
is probably a new merit you know like
the date stamp now it has to put a new
cache busting thing in there Andrey
requests the entire thing even if it was
in cash just because one bite you know I
changed a number from ten to eleven in a
config file so combining files was a
best practice in h1 but not necessarily
in h2 it's a good idea when possible to
kind of spread your files out a little
more and don't make your files so big
that they'll take a long time to
download the trick you can use for that
is what I call a core then more strategy
a lot of you are probably using
something like this already you know
your render critical first render
critical resources your JavaScript your
CSS your initial HTML go there at the
head of the file top into the HTML file
and then everything else can be loaded
asynchronously tools like web pack make
this pretty easy to do with bundles you
know a lot of people use all kinds of
different tools for doing this but the
but the idea is basically the same just
just your render critical resources in
the file or at the very top and the head
everything else can come in
asynchronously as needed with h2 one of
the best practices you've used with h1
may be to inline resources with h2 don't
really need to do that it's actually
better to keep them separate just put
them up in the head and h2 will pull
those in because that initial scan that
the browser does to find resources it's
it'll find those pretty quickly and
request them very early in the process
if you use inlining the problem there is
you can get useless renders because it
will see the resources there you can
render a page that really isn't even a
functional page so that's kind of a
waste of the browser's time to do that
and it can cause kind of strange
artifacts on the screen
okay now here I'm delivering on
benchmarks this is an interesting
benchmark that engineer an on their
implementation so the blue is HTTP green
is HTTP - and this whatever color that
would be kind of a brown is HTTP the old
h1 over TLS and you can see that in this
red area that I've circled that's the
only place where eight unencrypted h1
beats h2 but it's still faster than
encrypted h1 so if you're running like a
site that's already encrypted for
example a comm ecommerce site then
you're still going to get get better
performance under h2 even with
encryption so you can see that as long
as latencies are less than 300
milliseconds you're getting you're
getting double wins here you're getting
better than even unencrypted h1 which is
you know how can you argue with that now
here's where we get to some really
mind-blowing stuff server push I'll say
in advance that a lot of this has not
been worked out that you're not going to
see all these benefits today with h2
because the people you know the
especially because it's server based
there's a lot of techniques that people
are still experimenting with but I've
talked to some people who are working on
this and there's some really interesting
and exciting things going on
so being ready means potentially just
enable the h2 in your own apps and your
CDN provider or other server-side
resources may just make it faster you'll
wake up one day and people will say gee
it's a lot faster here's an example
though the browser you know you go and
you click on a link that says products
that HTML the browser says semi-products
that HTML the server has seen lots of
people request products that HTML
it knows about those things maybe it's
keeping a statistical log maybe it's
been pre told in advance by you or some
tool you have that if you need products
and HTML
you're gonna need above the fold that
CSS it's not very big but I know you're
gonna need it so I'm just gonna send it
to you even if it's cached you know half
the requests for this page don't have it
cached so I might as well just send it
to you I'd rather send it to you now
than wait this can be done by predictive
algorithms so like whoa this this is the
kind of stuff that this is an example of
one simple app that somebody put
together saying look at all these
round-trip times these large green bars
when you get server push these disappear
into almost nothing they just come down
almost immediately there's no basically
there's no delay at all so you know this
is a somewhat contrived example but you
can see load time for this simple app
was reduced by 60% whoa this is the kind
of stuff that we want to see you know
where we get something kind of for free
and then we can just take credit for it
as developers there's some other
interesting work this is just one
example that's going on something called
a bloom filter if the client can
collaborate with the server and say look
server I've got a bunch of stuff in my
cache for this website for this domain
and I'm just going to tell you in
advance like the last hundred files that
I had requested from this domain and I'm
going to do it in a compact form
something like a serviceworker when we
start implementing things and service
workers on the client side would be
great for implementing this server push
can be made even more efficient because
basically you say here's what I already
have here's a list of requests I'm gonna
give you a list of priority requests as
I as I determine them here's why I
already have
server can look at that and say well I
can see you're saying you don't have
this in your cache I'm just gonna start
sending it now so like wow that's even
more more amazing I don't know what this
cat was looking at I guess a head dude I
just love cats so let me just give you a
little bit of a feeling for what it's
like to be a browser and and and deal
with h2 streams in an h2 put a
connection have a wait and they which is
basically a priority number and they
have a dependency so as use as the
browser sends requests to the server
over the connection it says here's how
badly I think I need the file and here
are the other things that I need either
before or after it basically it's
sending a dependency tree as its
requesting these resources so it can say
I need logo JPEG but while by the way
there's no use sending logo JPEG unless
I already sent me index.html because I'm
going to need that's you know that's the
place where it's embedded and the server
can deliver bytes based on the priority
and the dependency so it's going to
essentially on the server side be
maintaining this more complex data
structure about what you need as a as a
client this is a cool little napkin
diagram that the Firefox developer drew
about the way he they initially
implemented it in Firefox he had
something called leaders which were the
things that he knew that were needed
quickly so that would be like j/s and
CSS that were render blocking and then
followers would be things like images
that can be put in later and then things
that are unblocked by any other activity
on the page like a a synchronous xhr
request can happen whenever there's time
and then background stuff like the
beacons that might be on the page
so for best h2 performance here's some
things that are a little different you
want to minimize the number of
concurrent connections so we don't cut
you know in h2 you don't try shotgunning
a 100 canino or five six seven
connections to the same servers that's a
waste you have one connection you have a
really nice basket and you put all your
eggs in it so by minimizing those
connections now we can warm that one
connection up quickly we know how much
bandwidth it can take and so the
downside of that as an h1 user is you
want to delay the use of other domains
don't try to make simultaneous requests
to your server some other third party
CDN server an ad server you know if
there are five or six connections trying
to connect simultaneously then they'll
still be competing and that will make
your connection you probably what I
would consider your main connection to
your own server that will make it less
efficient because now when it tries to
warm up that connection there four or
five other connections that it competes
with this really changes the way that
you think about how to use CD ends you
probably don't want to use a public CDN
like Google or the Microsoft Ajax CDN
unless you're getting a significant
number of files from it so if you are
using jQuery jQuery UI jQuery themes you
know some other things all from there
and they make up you know a 500k worth
of your requests it might be worthwhile
but never never decide that well I want
to try to optimize by spreading my
request out across multiple CDN so
that's a real waste because then you're
making a connection to Google CDN
Microsoft CDN you know that's definitely
not the way to do it only use a public
see the end if you're getting a lot of
files and bytes okay so you're a
developer and you're like ok I think I
did everything to make it fast for Age 2
but
how do I know it's using it well it
turns out that there's some really good
things that the browser makers have done
when you get in chrome you press f12 you
look at your network connection tab and
last I looked protocol was not one of
the default things but you can
right-click on the header here and just
select protocol as one of the things
that you can turn on and you can see
here it shows h2 photos at google.com
you'll also see here it's negotiating
first an h1 connection and says you know
I can do h2 if you can and say yep I can
do it we're good
Firefox also in the detail view you can
see the version here h2 edge same thing
here the kind of odd quirk with some
sometimes with things coming out of
cache it doesn't know the protocol that
was used to get it into cache she just
knows it's coming out of cache so things
that are 304 you'll sometimes see HTTP
even though it was requested originally
with h2 from server so don't be alarmed
there's something called the HTTP 2 and
speedy indicator that's available as a
plugin this only tells you if the HTML
file that you're getting was h2 quite
often as you saw here you will see a mix
of here for example here this this photo
came out as quick plus speedy even
though the page was requested with h2 so
you'll probably for a while especially
from your ad networks ad network seemed
to be slow at this you'll be seeing h1
and potentially speedy on some browsers
for a while before everybody switched
over to h2 so the good news is h1 and h2
can coexist as a software developer you
can it's not like you have to abandon
optimizing for h1 you but you can think
about H 2 as
what you really should be aiming for now
if your back end if your servers and
your CD ends and the other things that I
showed on that list are capable of h2
you should be seriously looking at that
I'll always also do some testing like
you know test and see did it really get
better I hope it did I'd really like to
know if it didn't and know why I've got
some great resources of people who did
try some things and you can kind of see
what pros and cons they had during that
conversion process but primarily ensure
that your servers are see the ends are
supporting h2 if you are using if your
company is using its own CDN through a
provider make sure that it's enabled for
h2 and you can make it effective without
breaking h1 just think about things like
in eliminating sharding and you say a
wildcard certificate so that you can
charge for h1 and you don't have to
charge for h2 don't create a single
large J s or and/or CSS file try to do
that core and more strategy test once
you once you've experimented make sure
that you're getting the goodness that
was promised you know when you start
split splitting up your files a little
more make sure that it's really working
and also keep an eye open like I
mentioned some of the things that are in
server push those things are bleeding
edge but I think they're really going to
be exciting as we start seeing them come
out so please you know I think we're
going to find that as we as we
experiment with these things that h2 is
going to give us a lot of benefits there
that we can go yeah yeah my code is
really that good and really all we have
just throw a switch so that's my talk
again the green cards down there are
very important for you to use
I have we've got time for questions or
you know maybe we can go to a bar or
something I don't know we're this is
like say the final talk of the day so
I'm looking forward to your questions
though be glad
answer any questions you've got let me
show you here this is the resources page
that's at the end of the talk these are
some great presentations references to
h2 being used for all types of things so
and this is the link to the presentation
that I just showed you so thank you very
much glad some questions yes
the question was I mentioned HTTP 2
requires more resources on the server
side for some of these things like the
h2 header compression and essentially
just for tracking things like that
dependency and priority table that that
is a concern it's one of the reasons why
they use the simpler compression
algorithm I would point out though that
because all the browsers are using a
single h2 connection whereas before they
were using somewhere between 6 and 10 h1
connections the benefit we have there is
that we are reducing the number of
connections that are being made to the
server so as for whether that balances
out I don't know the server people don't
seem to have raised any alarm and I know
they were part of the process in
determining and defining h2 so I think
ideally it's no worse than a wash as far
as the fact that we're doing fewer
connections is just a single connection
that is more complex
the the abusers might do multiple
connections I don't know if you know if
you talk to some of the bigger CDN
providers they may have you know
mitigations that they're that they're
applying against that for example I
don't know if it makes any sense for a
single client to be to have multiple
connections so they may if they can
determine it's the same client they may
simply reject connections from the same
clients you know obviously if it's
behind some device that's connecting
through the same IP address you can't
use IP address as a mechanism but I
don't know I mean that that is something
that I could say I would think that the
people who are involved in the process
would have raised an alarm if they
thought it was significantly more
resource intensive for this server other
questions yeah right so so the question
is how much expenses there how come how
much complexity in requesting like the
core and more strategy I think that's a
place where there needs to be more
research and I think no matter what you
want no matter what you would want to
make sure that you tested for your
application I think that it's most
likely that 900 that is no bundling at
all is probably the wrong solution
because 900 is just a big number I know
that someone was saying that they were
using browserify they were using a bread
they were basically walking the
dependency tree on the fly on the client
side and just walking the dependency
tree saying well you know we don't want
to actually bundle anything we'll just
request the individual files
the amount of CPU time it took to walk
the dependency tree was massive so that
would kind of advise against requesting
all 900 files individually but I don't
know where the sweet spot is would it be
like in the case of h1 it's probably
more like 10 or 15 bundles maybe in the
case of h2 it's more like a hundred
bundles and obviously it depends if you
absolutely know that if this resource
changes that these other 20 change you
might as well put them in a bundle but I
don't think there's been enough done
there to come up with a definitive
answer maybe maybe there can't be one I
don't know other questions yeah so the
question was I've heard a lot of
negative things about - oh can you say
whether they're wrong or right I've
looked at some of those and actually
some of them are referenced in that
resources page some of them one of them
was about this issue of trying to
resolve hundreds of files and it turned
out that that was more about the amount
of time it took to resolve not the
connection issue to h2 connection there
was one that the trying to remember
there was another one that one group did
and I think they were saying there was
an issue with Firefox but not chrome I
think you're going to see some of these
things as people start and like if you
think about what happened when we used
h1 to begin with we created this big
toolkit of things like I say it's very
similar to the internal combustion
engine you go oh you know let gas kills
people we'll figure out a way around
that that's the kind of stuff that we're
still on with h2 but as far as specific
things I think it's usually just that
don't go crazy things so
a lot of times when people were using
browser 5 for example they would create
a single large app that j/s and that's
not good I would also say that 900 files
is not good so the the answer lies
somewhere in the middle and right now
probably the best way to find that out
is to experiment on your app to know you
know whether the number the right number
is 5 or 500 but if you know some
specific things I mean if there if you
know a specific knock against h2 I think
the main thing that I've heard is people
who say my boss says that we need to get
the ads onto the page as quickly as
possible so this is crazy we can't only
have one connection you know on the page
this goes to another talk that I have
about performance and people are always
you know thinking well I need to put the
ads on the page as quickly as possible
because that's how I make money but you
can see a page like huffington post when
you try to load it on your phone that
take 12 to 15 seconds sometimes 20
seconds to load people don't wait for
that so so people think that it's
important to you know have everybody
rushed for the door and get that ad up
on the page but if they actually built a
page that that responded quickly you
would keep the user busy enough that
they would start reading and the ad
could come in and they would stay for it
so sometimes I think the concerns are
misguided you know that really want to
try to follow the best practices and you
know look at the people who are doing it
the guys like Google or Facebook or
Amazon they're not crazy you know
they're trying to do if they saw that it
was cutting their revenue by half maybe
taking it out real fast so so I think
some of those may be overblown just
because people haven't really had the
chance to experiment with them I know
there's other questions yes right here
right the the h2 also has flow control
and the prioritization in particular the
ability to to stop sending something
that it determines later is not as
important to something else is
incredibly valuable reading and some of
these benchmarks really don't reflect
those benefits it's really easy to
accidentally when you create your HTML
file the resources are in the file and
kind of a random order and the pre
scanner looks for what it can request
from the server that's not the optimal
order it's never the optimal order and
that's where the reordering the
reprioritization that h2 provides can
really improve performance for free to
you there
but again definitely a be test h1 vs. h2
and make sure that you feel comfortable
with it other questions all right
oh yes yes there's only one connection
in h2 per server the connection can stay
open the same way it times out with an
h1 connection so it doesn't have to shut
down immediately
yeah the server can be pushing things
because it doesn't have to be just files
that you're requested it can be pushing
things you know at a later time as well
yes
I'm sorry Ken H to do what can Oh
can H to improve performance and rest
services I would I would think well it
depends on the amount of data you're
sending and the frequency of that data
if it's I mean the fact that you don't
have to do
well I won't I won't try to speculate
there because I don't know for sure but
I would think the main benefit fits of
h2 would be either in the initial page
load where there's a lot of resources to
pull in or in a high frequency
transaction situation so if your if your
rest service is transacting quite a bit
with with your client then yes it might
do there but but I don't know for sure
other questions okay well you feel free
to come up and ask questions thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>