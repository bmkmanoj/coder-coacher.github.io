<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>One kata, three languages -  Mark Seemann | Coder Coacher - Coaching Coders</title><meta content="One kata, three languages -  Mark Seemann - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>One kata, three languages -  Mark Seemann</b></h2><h5 class="post__date">2016-08-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ux5wUSOsEfc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright let's get started so if you're
already if you're still arriving then
welcome come on in there's plenty of
room so hello everyone and welcome my
name is Marc seaman if you want to know
more about me there's an about page
there and block deployed at decays I'm
not going to you know tire you with all
the details I'm also a twitter at plur
and I you know I love tweets
particularly if they're you know
positive but it's ok so this talk is
called 1:1 cards are 3 languages so I'm
going to do a software car so a little
exercise I'm going to do some live
coding while I do that and I'm going to
do it in 3 languages and those languages
will be C sharp and and Haskell and
enclosure so if you've never seen a
scale or closure before you're in the
right place because that's basically the
idea about this talk to say well if
you're curious about those languages
you've never seen them before but let me
you know want to know what they look
like and maybe also what they're about
then this talk should give you just a
you know a brief introduction to those
languages obviously you're not going to
be an expert or really understand much
but at least you would seen them and
then you can go and look into it
yourself if you think that's interesting
so that's that's basically the idea here
so first of all let's talk a little bit
about Casas how many of you two cancer's
regularly maybe not every day but just
you know once in a while no not a lot a
couple all right um I think I think you
should do cos I think you should do
consider doing classes so the concept of
a concert actually comes from martial
arts so that's why this karate guy is
there and I believe the word is Japanese
and means something like form but
basically the idea is that sometimes you
want to train but you don't have a
sparring partner and you still like to
train so you can do you can go through
some motions and that should build up
muscle memory which is important when
you're doing a physical activity to
actually have you know your body
accustomed to making certain moves so
that's a pretty good way of doing
something that is you know exercising
with when it's a physical activity now
sometimes when you do programming you'd
also like to train if you want to become
a better programmer it might actually be
a good idea to train but but the problem
with the you know we don't really need
to build up muscle memory you know
contrary to some people's believe it's
not the it's not the your typing speed
that you know determines whether not
you're a good programmer it's more like
what really makes you a good programmer
is experience and your ability to think
things through and and the more thing
the more you are accustomed to thinking
and looking at programming problems from
different angles the better you will be
at that so in order to train your brain
you don't go you shouldn't go through
the same X in your same steps all you
know all the time why you should do it
you try it you should try to make your
brain think about things that you don't
that you can't think about or you
haven't tried to think about before so
you need to you know do something that
is novel to your brain so it's sort of
like the opposite of actually building
up muscle memory you need to try to do
something that is new and even if you're
a professional software developer that's
actually not what you do on your day to
day job you know on your day to day job
you probably do the same thing you write
in the same language that you wrote in
you know last year or maybe last week
and so on and you you know you're
working on the same codebase you're
using the same methodology you're
probably you know working with the same
colleagues and it might be nice you know
it might be a very good job that you
have but it's not like it's actually
giving you you know challenges in and
force you to think about things in new
ways so I think it's a good idea to just
you know try to do things that you don't
know so that's why I think our tech is
actually a pretty good way of
approaching things so instead of trying
to do the same software exercise all
over and over know again what I really
do is I try to do various exercises but
I tried to do them you know in different
languages or with different constraints
and so on and I mix them up so and I
never really do the same thing twice
unless I give presentations and then I
do the same thing twice but that's work
so you know an example of a car that one
of my favorite classes is the tennis
Carter basically what you have to do
here is you have to implement the
scoring system for tennis and I like
this one because it's quite simple it's
easy to understand you can cover the
rules in about 20 seconds and it's not
difficult at all to implement but it
does have a few gotchas here and there
so you may be surprised the first time
you try to do the kharsa too and you'll
discover that well it's pretty simple
but it's not quite as simple as you
actually thought so I think I like that
for that reason another favorite of mine
is the diamond cancer but
the one that we're going to look at
today is the fist bus kata the simplest
of all Carter's this is ridiculously
simple and easy to implement but that
also means that the point here today is
not so much doing Carter the point here
today is to introduce you to new
language that you may not have seen
before so we're going to talk about you
know the syntax and the philosophy you
know behind the language and that means
you know the problem it's not going to
you know stand in the way and so you
don't have to think about the problem
this is trivial
I'll cover the rules if you've never
heard about it before but I'll only
spend like 20 20 seconds 30 seconds on
it before we do that you know I should
just tell you know there are lots of
cars out there a good place to go is
bitly slash code Carter's it's not all
of those classes but this is just a site
it started out as a wiki that someone
have you know created with a lot of
those cutters in them not all of them
but a lot of them right okay so we're
going to look at three languages today
so the first language that we're going
to look at is c-sharp so I'm assuming
that you are either a c-sharp developer
or Java developer or at least someone
who is familiar with the one of those
languages enough to be able to read the
c-sharp code that I'm showing you so I'm
not going to spend too much time
actually on the C sharp code I'm not
going to do live demoing of the Shopko
because that's not really the point the
the reason why I want to show you this G
sharp code is just so that we have
something to contrast to a compare to
but the first language that I'm actually
going to show you then is Haskell and
I'm going to talk about what Haskell is
when we get there and then when I'm done
doing Haskell I'll do the same Carter
again for a third time in closure and
the first thing we can you know identify
here when we are looking at this slide
is that we can see all cool languages
have nice logos and what does that say
about you sharp and I don't know you
know F sharp has a nice logo haha and so
um so that's basically it so um okay so
let's just cover the rules of fist bus
so um the rules of fist bus is very very
simple
you should write a program that prints
the numbers from 1 to 100 but there are
some special rules because if the number
is a multiple of 3 you should print
fists instead of the number if it's a
multiple of 5 its you should print buzz
and if the number is a multiple of both
3 and 5 you should print fist
that's it so as I promised you know we
can spend all of 20 seconds talking
about the rules of this bus and that's
basically it
so it's trivial you know it's not an
interesting problem at all if you if you
try to do this in the language you're
most familiar with you should be able to
do this in like five minutes
so but that also means that we you know
you shouldn't be confused okay what was
the rules about fifth bus and how do we
actually do this this is really really
trivial so that enables us to fall it's
just just focus on the language instead
of focus on the problem now just let's
just look at you know what could it look
like and see sharp so that you know she
shop is one of those languages where
there's not one way of doing things
there are plenty of alternative ways to
approach a problem so here's just a sort
of an old-fashioned implementation of
this bus in inches sharp so you know
since you want to have a program you
need to start with a main method so
that's fairly standard and what you
could do is if you want to do it really
the old-fashioned imperative way you can
say well let's have a full loop and
you'll just go from the numbers from 1
to 100 and the first thing you do is you
say well if I modulo 3 times 5 5 equals
zero you'll print or you'll consult
right line fizzbuzz and the only thing
you might wander here is so why do I do
3 times 5 and not just 15 which you know
3 times 5 obviously is and the reason
for that is basically just you know I
like the philosophy of domain-driven
design where you talk in the domain
language so even when I do carters I
like to do my classes in in the language
of the the Carter description and the
Carter description of this bus you know
specifically talks about the numbers 3
and 5 but it never talks about the
number 15 so I just thought that you
know I'm happy to use the constants 3
and 5 because they're part of the domain
language if you will but the number 15
is not so that's basically why I did
that it might be even clearer and more
you know relatable to the rules if I had
written something like if I modulo 3
equals 0 and I module 5 equals 0 then
you know print fizzbuzz whatever we can
do that later on all right otherwise
I'll say well if it's module 5 equals 0
I'll print bus and then you know modulo
3 equals 0 I put in fists and then
otherwise I'll just print the number so
that's basically it you know if I run
this program it's just going to start
printing out all of those
those numbers so I just you know wrapped
that column into multiple comment
columns here in order to fit all the
numbers on the screen but obviously it's
just going to you know print one column
so that's basically what what it is that
we want to achieve so that was the
c-sharp part of it we shot up part of it
now let's say let's look at it in
Haskell then so first of all before I
just start typing some Haskell code
let's talk a little bit about okay what
is Haskell actually so first of all we
realize that Haskell has a cool logo
there's also a version of that local in
colors it making it even more cool but
you know for some reason I decided to
pick the gray one the next thing we can
say about Haskell is that it's a
strictly functional programming language
so what do we mean by a strictly
functional well it turns out that a lot
of the popular functional programming
languages out there like Scala and
closure and f-sharp possibly also Erlang
which I don't know a lot about but the
other ones that I just mentioned here
they are not actually strictly
functional they are like what we could
call multi paradigmatic languages
particularly Scala is and also if sharp
is pretty multi paradigmatic you can do
object-oriented you know software
development in F sharp if you want to
because if sharp needs to interoperate
with all the C sharp code and the visual
basic code that's already on it and this
same sort of situation also goes for the
other languages there so they are not
strictly functional they're sort of like
designed to make functional programming
easy but they can do sorts of all sorts
of you know imperative stuff and things
with side effects as well if you want to
this is not true for Haskell haskers
Haskell is a strictly functional
language there is the Haskell way or all
the highway when you're writing Haskell
you can't just say well yeah but I'd
like a little bit of state mutation here
because whatever nope it's not possible
you have to write functional code that's
the only thing you can do so it's a
great language for learning functional
programming if you're interested in this
because you can only do a functional
program with it the other thing we can
say about Haskell is that it's
statically typed and actually what we're
looking at the moment this bullet list
is actually if we could call that a
bullet list this is actually Haskell
code this compiles and it has a type
Haskell is a value Haskell up here on
the slide the value has the type it's a
list of strings in this case it's
probably fairly
evident that what is going on because
the square brackets there indicates that
it's a list and since the you know
values inside of the list are quoted
with those quotes double quotes those
are strings so therefore this is a list
of strings but you'll notice that there
is actually no type declaration anywhere
but even so it is statically typed
because the compiler can infer you know
the type of this list you know third
third thing we can say about Haskell is
that it's lazily evaluated which is sort
of unusual that's not what we used to
when we do C sharp or Java development
but it's not something that we actually
need to think much about when you know
when I show you the D Carter here so
let's let's not talk too much about that
so with that said let's try to see what
it looks like to to do the fist bust
Carter in in Haskell so in order to do
that I'll switch to here's Adam and it'd
be not interesting to show you hello
world so I already put that in here but
that's basically what hello world looks
like and if I want to evaluate it I can
switch here to to a to my console here I
have loaded the Haskell rebel the read
eval print loop and if you can't see the
font size now and now it's the time to
actually speak up to ask me to change it
because that's better you know if you do
that straight away but I've tried to see
if I could make the font size big enough
so I can call the main function here and
you see that it prints out hello world
so yeah it works at this point but
that's not what we want to do we want to
do fist bus so I'll switch back to my
editor here and I'll say well okay so I
want to deke D I want to deconstruct the
problem into two problems I want to take
first of all I want to solve the problem
of having a single number and figure out
figuring out for that number
what should the resulting string be and
then once I have that function I can
then start to figure out okay if I have
a list of numbers or you know a sequence
of numbers then you know how do I
actually print out all of those those
strings instead so I'm going to write
first a function called fizzbuzz one and
I'm calling it one because it just deals
with one input element and you don't
have function overloading in in in
Haskell so you need to call this
function some something else and I want
to reserve the word fizzbuzz for the
function that actually does you know for
all the numbers so the first one
function needs to take an input and we
could just call that I I for integer
we could also have called a number but
you know in Haskell we like to keep
things very succinct so that it's as
unreadable as possible so the first
thing we need to figure out is how do we
actually convert a number to a string
and that turns out to be fairly easy
because there is a new that there is a
function called show that will convert a
lot of different things into integers so
if I try to compile this you will notice
that the all sorts of warnings popped up
up up over here some of the warnings you
shouldn't really worry about because one
of the mornings for example is that it
says well this function is not used and
I will use it but only until the end of
the Carter so you will help you will see
at least that warning until the very end
so don't worry too much about those
things there's a couple of other
warnings that we can talk about but
actually basically this already compiled
and is static the type - believe it or
not so if I go back here and reload my
my my code I can say well alright let's
call this plus one with the number one
for example and you see it prints out or
it returns the string 1 and if I do it
with 2 you know it you know returns the
string 2 and you know if I do it with 3
string 3 which is not the correct
implementation but shouldn't really
surprise us because we haven't started
dealing with that but that ought to be
fist right ok so I I told you that this
is statically typed so we can ask you
know in the ripple here we can say what
is the type of this plus 1 well the
compiler says well the type of fist bus
1 is this this looks a little bit weird
but it says show a fat arrow a small
arrow string so basically what it means
is what I usually do is I say well first
of all I focus on everything that's on
the right hand side of that fat arrow
and so I'm just looking a a thin arrow
two strings so basically what that means
is that it's a function that takes a
value of the type a and returns a string
now string is probably pretty
understandable for everyone that's done
any software development ever but what
is a well a is a generic type so you
know generic you know methods from
Shahab and Java has generics as well and
that's basically what we have here so
this could be any any well not actually
any value but it could be a value of a
lot of different types and I'll just
prove it to you
to say well okay instead of calling it
with with there with integers you know I
can call it with the decimal and that's
going to you know work just fine you
know I can call it with a boolean so if
I call it with the boolean value false
it's just going to give me the string
false back you know if I can even call
it with another string so I can say well
foo is just going to double quote it
that's a little bit weird but that you
know you did expect it to just return
the string and again you know without
actually double quoted it but that's
some you know whatever so it just takes
everything well actually not everything
but it takes a lot of things and just
turns them into strings so what does
this show a thing mean this so let's
just type out the let's look at the type
of this plus one again so you'll notice
that it says show a fat arrow and then a
and that what's on the left-hand side of
that fat arrow is a qualification of the
generic type so it says well it's not
every type it's only those types that
belong to what we call a type class
called show so you know in in them in
c-sharp in a java you are you know
probably used to every object belongs to
a an object hierarchy that you know
derives from objects and you know object
define a two string method not so here
in Haskell there are a lot of things
that you can turn into strings you know
everything that belongs to the type
class show you can turn into a string
but you shouldn't really take the word
type class to mean a class like in Java
Java because it's sort of different you
can think of it as a category of types
or a set of types that all can be turned
into string but basically what it means
is that if if a type belongs to the type
class show there is a show function or
the show function is defined for that
time and that means we can use that type
and turn it into a string all right so
you'll notice also that the compiler
tries to infer a type of the function
that is as you know as universal as
possible so in this case it says well it
could be anything as long as we can turn
it into a string it's not going to stay
that way because we will need to do some
arithmetic on the the number in order to
figure out whether it's a multiple of
three or five so it's kind of we have
we'll have to restrict it more on until
we can continue one of the things that
the compiler would like me to do though
is it like me to actually you know put
on a
a specific type declaration so we can do
that as well that's one of the mornings
so we can write fist bus one is so I'm
basically just going to you know write
what the compiler already inferred and
say for every show a the function is
takes a as input returns a string as
output so that's just one more warning
less now so so we you don't have you
don't have to this in order to make it
to compile but you know the Gaskell
still would like you to do that because
sometimes that is useful now with that
out of the way let's try to figure out
okay so how do we deal with all the
other requirements of having to you know
return fist if it's a multiple of three
so what I can do is I said well I can't
do overloading but you know I can define
the function in more than one way so in
this case I can say well fist pass one
of I it I can actually define a
constraint or a filtering you know
implementation of that function so that
what this is what this vertical bar
means it says well every what comes next
is a boolean expression in this case
I'll say well you know I Mott 3 should
equal zero so this is just a funky way
of writing you know an infix operation
let's not worry too much about that if
that is true now this is a boolean
expression if that is even if that
evaluates to true we can return you know
fist so the return value of the function
is just the expression after this you
know single equal sign here but this is
this particular you know implementation
of the function if you will will only be
cold if this boolean expression here
actually values to true otherwise it's
just going to fall down into this you
know default implementation if you will
that doesn't have any constraints so
this is sort of the fallback
implementation so the order actually
matters here now if I try to compile
this you'll notice that you know that it
that it doesn't actually compile these
red boxes around it and the reason for
that is it says well not is not defined
for any show you know for any generic
type argument a that only belongs to the
show or show type class Mott is not
defined for those types because you know
this you know how do we do Maat Maat on
a string for example that's we don't
really know how to do that
so we need to constrain the type further
on and say well you know a must belong
to the show type class but it must also
belong to another type class and that
type class is called
integral and I'll you know get back to
what that means in a moment but
basically now it compiles so if I go
back to my ripple I can reload my code
and I can say okay what is fizzbuzz 103
that is now fizz so I'm happy that works
okay so what is what does integral mean
well integral is basically just another
type class so that means it's a set of
types that you know share a contract if
you will and integral is just any
integer so you know in in Haskell
integers might not be you know one
integer this 16-bit integers and 32-bit
integers 64-bit integers and their own
but unbounded integers that can be as
large as as you will as long as they're
within the constraints of your of your
system you know that's true for that net
as well they have all of those different
integers and Haskell does that as well
but what I've done here is you know in
in dotnet you know in c-sharp I would
have had to write an overload for all of
those specific integers and deal with
each of those types specifically whereas
in Haskell I can just say well you know
this just applies to any integer that
that belongs to the set of integer types
that we call integral because for all of
those types the mod function is defined
I'm fine and there's a you know the
integral type class also defines other
functions that mod it you know like plus
and minus and and things like that but
now that means you know I can go back
and and reload I already did that I was
just talking about integral I sort of it
you know explained that already so let's
move on so I'll just do a copy and paste
and I'll say ok if it's you know model
of 5 I should print buzz and you know if
it's a modulo of so I could do what I
talked about in in G sharp I can say and
I mod 5 equals 0
then it should be fizzbuzz so again you
know this looks a little bit but beause
you may think that that it could be more
you know does it have to be this with
both and it doesn't you know I'm just
showing you
more verbose syntax because I think is a
good introduction to the language but
you can actually write it much more
compact so you don't have to repeat
yourself just as much as I did here but
so there are all sorts of you know
language syntax shortcuts you can use if
if you don't like you know the verbosity
of this so if I reload now we can see
that you know fist plus 3 we expect that
to return fist it does 5 returns bus 15
returns fist bus so that seems promising
so the next thing we need to figure out
is to say well okay now I have a
function that takes a single integer or
a single integral and returns a string
but what I actually need is to print all
the numbers from 1 to 100 using that you
know algorithm if you will so how do I
do that so I need to do a loop and then
you run into this problem that Haskell
doesn't do loop you can't do loops in
Haskell oh ok so what do you do then
well asko doesn't do loops but it does
lists so let's look at what a list is so
a list in Haskell is a linked list maybe
I should just clear the console here so
that we that doesn't give me the top
then hmm well I hope you can see even
though I'm writing down there at the
bottom so I was talking about lists so
lists in in Haskell are linked lists and
we can you know we can write them out
you know fairly easily like saying well
here's a list of 3 numbers the numbers 1
4 &amp;amp; 2 but lists are generic as well so
you know you can also write a list with
the with the strings foo and bar if I
wanted to do that you know but I can't
mix them so you know if I try to you
know put in a integer into a list of
strings that doesn't compile so it's
just like in inches sharp you have you
know lists of T this are also generic in
Haskell now lists in Haskell and you
know in general and functional
programming tend to be linked lists so
so what a linked list is that it's a it
was a value it contains a value which is
on the head of the list as we call it
this is the value that we can see and
then there's a pointer to the rest of
the list so so another way of writing
you know first of all you can write the
empty list the empty this just looks
like this
then what you can do is you can say well
the list with one element is actually
the element the value one and then a
pointer to the rest of the list
and the rest of the list might be the
empty list like this one so this colon
operator there's what we call the cons
operator and we sometimes say that we
cons one onto the rest of the list and
the rest of the list we call the tail of
the list in this case it's the empty
list so if when I evaluate that you will
notice that it gives me just a syntactic
sugar of that but that's basically those
two things are completely equivalent and
you can you know you can cons things on
to each other so you can say well 1 3 2
and then in them as long as you end them
with the empty list that's that's going
to be fine actually you can also create
infinite lists if you want to but not
with this syntax so you can see again
they know the syntactic sugar version of
that it's just then you know the numbers
1 3 &amp;amp; 2 now this is this becomes
important in just a moment the last
thing I want to show you or talk about
with lists is that we can also you know
we're interested in looking at the
numbers from 1 to 100 and we can use
this thing called list comprehension I'm
just going to do the numbers from 1 to
15 and basically I'm just saying well
you know the start number dot dot the
end number and then I'm just going to
get all of those numbers are generated
so that's a little bit easier way of
actually getting all the numbers from
you know in a range now remember this
cons you know way of expressing things
with the colon operator because
basically what I need to do now is I
want to write a function where I say
well if I have an input which is a list
of numbers I want to produce an output
which is a list of strings you know
where each element has been transformed
into a string using that fizzbuzz one
function so I'll call this function fist
bus so that's why I didn't call the
other one fist bus and what I want to
say is I want I want the input to be a
list of integers and what I can do then
is I can pattern match on that list you
know immediately and try to restructure
the head and the tail so I'll say well
there's going to be the a head I'll call
that I for integer and then there's
going to be the rest of the list the
tail of the list and I'm going to call
that eyes so that's the plural s so it
doesn't it doesn't say is here it says
eyes to read that as eyes this is very
common in Haskell that you have things
where it's called X and X's or I and I
so Y and Y's or whatever
so this is a fairly easy way of calling
it but basically it says well this is
actually still one argument but I mean
immediately instead of trying to you
know pull the head on the tail out of
the list I'm just immediately doing this
so this is just a compact syntax for
pulling the head of the tail out of the
list immediately even so it looks like
it's sort of two arguments but it's
actually just one so what I want to do
is I want to say well okay I want to
take the number I have one number the
eye that which is at the head of the
list I want to transform that using
fizzbuzz one that's very easy I just
call fizzbuzz one with AI and then I
want to say well that will be the head
of my new list of strings but I want to
constan onto another list of strings so
how do I get a list of strings from the
rest of the integers well I just can't
that you know to the rest of the inter
integer so just kind of cold you know
recursively called fist bus with the
eyes all right so that's basically going
to do almost all of it the only thing
that's that's still missing here and if
I try to compile it I actually get a
warning it says well there is a special
case that you haven't dealt with because
most lists tend to have this structure
but there is a special case of a list
that doesn't have a head and a tail and
that is the empty list so if the input
is the empty list this pattern actually
doesn't match because there's not both a
head and a tail so I need to define okay
what's going to happen in the case where
the input is the empty list I'm just
going to say all right in that case the
output is also going to be the empty
list but because the compiler knows the
types of these things the input here is
the empty list of integers the output is
an empty list of strings so even though
we can't see the types they're sort of
still there the compiler figures it out
because it knows what I mean so again
you know if we get if we go back here
and say alright let's reload all of this
stuff we can say let's call this bus
with the numbers just from 1 to 15 and
see what's going to happen and we can
see that we get you know 1 2 fist for
bus fist 7 8 and so on you know back so
that actually looks like it's working
what's the type of fist bus so we can
ask about that as well the type is it
looks a lot like the other one it says
for all integral a all show a it's a
list of A's that goes into a list of
strings
it's almost the other one which is just
it'll serve one a going into one string
it's a list of ace that goes into a list
of strings so we can almost just take
and copy and paste you know this you
know type declaration up here you know
paste it in here you know just remove a
couple of things I just need to put
those square brackets around the the
types here like this and this still
ought to work so so this is the same I
just put the type declaration on because
the compiler likes me to do this so
there's another warning here that that
that I might you know be interested in
here and this is not from the compiler
this is from a linter and it says well
you know this is something that they
started this you know thing where you
recursively call you know you
recursively move over a list and just
call you know a constant new list out of
that until you reach the end of the list
that is such a common thing to do that
that's actually built into the language
it's called a map and it's not just
Haskell you know it's in functional
programming in general this is just
called a map so why not why not do that
instead so so I just showed you this
here because it shows you the general
you know way that you actually deal with
things so you also understand that the
map the building map function is not
magical in any way it's actually
implemented pretty much like this but
what what it means though is we can say
well we'll just define if this bus to
say well we'll take any integers as
input any list of integers as input and
we'll just call map and we'll say
fizzbuzz one is the function that we're
going to use each to map each element
and then we're just going to say that
the other input to the map function is
those eyes and that is exactly the same
and then you know haskell wants me to do
something you know or the linty wants me
to do something called an e to reduce so
this is almost like this seems to almost
like you know mathematics you know like
when you are solving you know equations
back in high school or college or
whatever you can say well there's an
eyes on both sides of the of the equal
sign so we can actually just remove
those and and say that is exactly
equivalent again so this is called point
free programming and some people hate it
and some people think it's really
wonderful I am sort of in you know torn
in between that because it really likes
the feeling you know my brain gets every
time I can do this but then I come back
to Anna
is completely unreadable so so I
actually often tend not to do this book
but but the Haskell Linda really wants
you to do this but in F sharp I wouldn't
do stuff like this but you know if we go
and reload here we can see that it still
compiles and if I do you know fist pass
from one to fifteen it still returns
exactly the same so it's just a simpler
implementation if you will now we're not
quite there yet because we're actually
not you know the specification of the
problem says that we have to print the
numbers from 1 to 100 I'm actually not
printing anything yet and you probably
argue well but you are because the
things are just there well yes but that
is because the repple you know the read
eval print loop prints it for me so I'm
just toying around this development
environment called read eval print loop
that reads the expression that I write
you know evaluate it and then prints the
result of that expression and then gives
me you know prompt so that I can write a
new expression expression but that's
actually not you know if I run my
program it doesn't print anything
actually still you know my main method
still just prints a little world because
I haven't done anything else
so I'll lead to just the you know print
this and I also you know instead of
having just this list you know printing
from left to right I want to have you
know printing a column where with each
value on a new line so there's a couple
of things that I still need to do so you
might say well okay instead of having
put STR Ln hello world here can I just
put in you know a fist bus and then you
know one to fifteen with that work and
and that turns out not to work because I
have declared our you know my main entry
point to be of the type I Oh of unit and
that means that it's a function that's a
function that takes no no input it
returns no output but it has side
effects and the side effect is that it
prints to the console and fizzbuzz one
to fifteen doesn't have a side effect it
actually returns a string so these types
are actually incompatible so what a much
rather like to do is I want to say well
I have a list of strings
I want to concatenate all of those
strings together to become a single
string but where each of the elements
are separated with a newline character
and then I want to print those the most
of this is basically just built into
Haskell so that's that's very easy to do
so so the function that you know
a list of strings and just create a
single string with new lines is actually
built-in it's called on lines but that
just returns a single string that's
still not IO of unit but then I can say
all right so I'll just call put STR and
and then that's going to work so I'll
get back to this in a moment but let's
just see if we reload this and I call
the main function again
oh that's just one two fifteen I should
actually do you know one to one hundred
so reload and main again and you'll see
that it prints all the numbers so that's
very nice so normally when there is a
demo and it succeeds you clap oh I know
it's yeah I know that's that wasn't
actually particularly you know difficult
so alright so one of the things that is
a little bit funny about Haskell is that
you know functions are actually composed
right to lift so so what actually
happens here is we say well we'll start
with the function call where we call
fist bus with 1 to 100 then we take the
value of that and call the online
functions with that one the output of
that one will send then take that value
and call put STR with that value and
that's the string that Lince always
printed so there's sort of a backwards
and exactly why Haskell has that
backwards composition I don't actually
know it's a little bit weird it's not
the most readable it's one of the things
about the language that you know not my
favorite part but but there there are
ways around it so well you know in
practice it's not that big a deal all
right so that's just a glimpse into
Haskell and and if you're left with lots
of questions that's fine but in the
interest of time let's just move on to
closure so so what we what can we say
about closure so first of all we can say
that closure also has a nice logo so
that map must obviously mean that it's a
nice language and it's also a
dynamically typed language so haskell as
we looked at was statically typed the
type system of haskell is extremely
powerful it's much more powerful than
sheesh Abba Chavez type system now
closures and the completely different
end of the spectrum because it still
dynamically typed so that's interesting
just you know to contrast the other
thing it's
so what we call a functional first
language so cloture runs on the JVM the
Java Virtual Machine and just like if
sharp is a multiple jig Matic language
because it needs to run on it
interoperate with things written in C
sharp or in Visual Basic well closure
runs on the JVM so it needs to
interoperate with all the
object-oriented code written in Java and
therefore you know it can do
object-oriented things as well so you
don't have to be functional but it's
designed to make functional programming
easy so it's sort of like the its first
you know priority is to make functional
programming easy and then you can also
do imperative of you know object
oriented code with it the third thing
that you may already have sort of gotten
the hint is that it's a lisp
so just like in Haskell I showed you a
list of strings that were you know a
proper Haskell code this is actually
proper you know closure code there so
closure is a value that contains those
three strings so at run times obviously
it's a it's a late it's a list of
strings but you know at compile time
well there is no compile time so it's
just being interpreted as we go along so
so let's look at what that would look
like so I'll switch to another editor
and you as you can tell first of all
there are some errors there in the
output I'm not going to use that console
a whole lot it's just I just have that
console sitting there you know because
towards the end I want to print all the
numbers but this particular editor
sometimes complain about things and you
will see those pink error messages there
in the console just ignore them for now
you know it just makes the demo more
colourful because now you also have pink
on the screen so that's nice but
otherwise it doesn't really mean
anything hopefully so I can type things
over here on the left hand side and this
is where I'm going to type my closure
code so the first thing we might say
well you know what does a function call
look like so in Haskell we could you
know write something like show 1 in
order to to convert the number 1 into a
string now as you can tell that does not
work in closure now in other languages
you may have to say well your argument
should be enclosed in brackets like this
one that's you know the valley you know
normal syntax and pretty minute
reminiscent of you know how is she shop
works or Java works or whatever that's
not the closure syntax either but it's
we're getting closer because we actually
need to Braga's we just need to move the
bracket over here and then you know the
function to turn things into strings in
closure it's not called show it's called
STR string I suppose and now you can see
that I have new you know the number one
you know converted into a string and if
I you know use 3 that number is
converted into the string 3 so that's
basically what a function call looks
like so it's not you know one of the
common things that people have against
lisps are that you know there are all
these brackets but what we often find is
that there are just as many brackets in
c-sharp they're just placed in different
you know just put in different places
but there's actually not necessarily
more brackets that probably are more
brackets with closure but it's just you
know syntactical we don't have to worry
about it and as a you know won't you it
just dumps out all of these things
because the internet connection is
rubbish but I don't think it's actually
going to affect us anyway so the next
thing we could say well we need to
define a function called fist buzz how
do we define a function well that's
pretty easy which is write different and
we call the function fist bus and it's
going to take some arguments so we'll
say well the the function is going to
take a single argument we can call that
I and then the the body of the function
is just that we call STR on I so that
means that I can call fizzbuzz now with
the number one for example and that if
but the number one and that evaluates to
the string 1 so that's that's fantastic
and if we try to call it with the number
2 it evaluates to 2 now and 3 evaluator
3 that ought to be fist but it's 3 at
the moment so I'll just type out the
other ones that I actually care about 5
and you know 15 they all just evaluate
to the number at the moment and I want
them to evaluate to you know fist and
bus and fist bus and so on so but that's
just to get us started so now you can
see we already have a function so the
first thing we might say is ok so how do
we actually make the decision between
how do we switch between you know the
case where we should write fist pass in
the case where we should write bus and
so on so in Haskell you saw that I used
you know sort of like
constrained functions with boolean
expressions in each function definition
that's not how closure works so we need
to figure out whether we have something
that is closer to like in C sharp we had
you know if else if else if else do we
have that in closure and we do it's
called cond for condition I suppose and
basically the structure of this is that
you you provide pairs of boolean
expressions and return values so
basically what you say I'm just going to
hard code a boolean expression for now
I'm just going to save true
and then I'm going to say well have
fizzbuzz and then you know there's a new
pair of a boolean expression and a
return value and I'm going to say bus
here I'm going to change the hard-coded
you know boolean expressions later on
and then I say true fizz and then you
know there is an else branch if not none
of these are true I can say ills and
then I just returned you know some
number right now I'm just going to hard
code one so you can see this Excite
expression at the moment just returns
fizzbuzz because the first expression up
here the first boolean expression up
here is true right now it's hard-coded
so what's in all those other things here
actually doesn't matter you know if i am
if i type false here the result is still
fizzbuzz but you know if I change this
to false
obviously it now evaluates to fist
because it just falls back you know down
into the first true that it can find you
know and you know it's probably not
surprising but if they're all false it
we return the ilis value and that is one
so that's sort of the structure that I'm
looking for and I'll just cut that and
I'll replace the current function
function body that I have with this
structure and I'm just going to say well
instead of you know returning the
hard-coded string one I'm just going to
have to remember just still return STR
of I so the the behavior didn't change I
actually didn't get any further but now
I have sort of the template for where I
need to go so the next thing I need to
figure out is to instead of just hard
coding an expression here how do I
actually determine if a you know a
number is a multiple of three for
example down here well just like I did
with the other in the other examples I
need to do some sort of modulo
comparison so I can say well not three
of three for example that is actually
zero
oh you know mod six of three is also
zero but mod five of three is two for
example so that's not quite a boolean
expression but I really want what I
really need that you know modular
operation to be is I needed to be zero
so I need to compare is that expression
is it zero or not so how do I compare
something to values and figure out
whether they were equal well I used a
function that is used to determine
whether these two are equal and that
function is called the equal sign so I
just say well I'll just take those two
values and try to compare them to each
other so again you'll notice just like
everything else in closure the function
is the first element in the list and
that is but what what's being in you
know evaluated and all the other
elements in the list are just arguments
to that function and some functions can
take an arbitrary number of arguments
this one can for example so I can say
you know I can put as many zeros as I
want here and they're all equal to each
other but you know if I just you know
put one one here that actually turns out
to be no I should probably put you know
in order to demonstrate that I should
just probably change this to six so you
can see they're all 0 the data value is
true you know if I change one of them to
be not a serial that evaluates to false
then but that's that's a you know
ridiculous thing to do in this case so
let's just go back here and say this is
actually the sort of thing that we're
looking for you know is it is it equal
to 0 so I'll cut that and I'll paste it
in up here and I'll say well I'll just
replace that hard-coded 5 with an i and
now we can see that fizzbuzz 3 returns
fist this bus of 5 doesn't return you
know bus yet because I haven't done that
this bus of 15 also returns fist because
you know 15 is a multiple of 3 that's
also wrong but we can fix that fairly
easy so the next thing we can say is
okay let's just replace the other ones
here that one is just you know a replace
and changing the the number and then up
here we can say something like well the
easiest thing is probably to say well
but you know I could write 15 here and
that won't actually solve the problem
but again you know I don't want to think
too much about the the constant 15 so I
much rather do this and I think that
it's a little bit closer to the problem
description so something like something
something like that is something that
I'm happy with so
I'm not going to spend more time with
that anyway so let's move on so again
just like I had in Haskell I now have a
function that you know can take a single
integer and turn it into a string now I
want to figure out okay so what if I
have you know how do I print all the
numbers from 1 to 100 and it turns out
exactly the same thing in the same
principle that applies it to Haskell we
can also apply it here but in them in
closure we can actually do function
overloading which we couldn't in Haskell
and the way that we do function
overloading is that we say well we'll
put each of the arguments the group the
function you know according to argument
so we can say right now this is just a
way of grouping things a little bit
differently so since closure is a
dynamic language we can't overload on
the input type because you know things
don't have type as such but we can
overload on the number of arguments and
this is what's called the functions
arity that's just a fancy way of saying
number of arguments so this overload
here has a narrative 1 because it takes
1 argument so what I want now is to say
well let's define another function that
has a narrative too it's going to take
it start and an end and then it's going
to you know I'm just going to put in a
placeholder string here so that I can
call it and then we'll start to figure
out ok how do we actually replace that
so this function here this is the same
function still fizzbuzz function but
this is the overload that has arity too
so that means i should be able to call
it with you know like 1 to 16 for
example and right now it just returns
the string placeholder because that's
what I put there so you could say well
okay so how do I get the numbers from
start to end
well you know we had list comprehension
in Haskell so you know in high school I
could just write something like you know
1 dot dot you know 15 that is not a
syntax that is you know that you know
valid in in closure but we have a
function called range where we can just
pass in start and end and that Munich
now gives me the numbers from 1 to fit
where to 15 so you'll notice that end is
exclusive you know in Haskell 1 to 15
meant all the numbers you know 1 and 15
but this range function excludes the end
so that's why I need to say from 1 to 16
that gives me actually the numbers 1 up
till 15 but not 6
I'm not too happy about this yet because
it's just returning the numbers I want
to convert them into strings and that's
just as trivial as to do in in Haskell
because map is a functional concept so
we also have a built in map function
here I'm just going to say well use the
fist buzz function and it'll figure out
that it actually needs to use the
version with the different area too so
it didn't know that it needs to use the
the overload of this bus that has era to
1 and that is why now it's printing one
to face for bus fist and so on so that's
fine but we're not really I'm not quite
happy with this yet because you'll
notice that the overload that takes one
argument returns a string whereas the
overload that takes two arguments
returns a list of strings and I think
you know a function that has various
different overloads but return different
value you know different types that's
sort of confusing that is not good API
design so I want this to return a string
also specifically I want to return you
wanted to return a string that just
concatenated all of those things
together but with a new line in your
character between each of them so in in
Haskell we could call a function that
simply just takes a list of strings and
then just concatenate all of those in
together in one string that was the
built-in function on lines in her
enclosure we also have a function that
does that but it's buried you know
within some namespace that would then
need to open so instead of doing that
let's just see if we can build it from
first principles if we will because
there are building things here in the
call on the root namespace that actually
enabled us to do that so there is a
function called into post
that can do just that and basically it
just as well which which value do you
want to interpose with and then we can
just say well okay I want to interpose
with the newline character so or the
newline string so now we can see I have
you know the string 1 the string newline
the string 2 that's doing newline the
string fist so they're still not
concatenated but now I have the newline
you know string in between all the other
values so I'm closer to where I want to
be and you know it might be more
readable closure code we if we actually
you know wrap things around a little bit
I don't know so we need to figure out
okay how do we actually concatenate the
strings this is basically the last thing
we need to do so it turns out that that
is
ah function they're actually also does
that so you know just as an example you
know if I have lists of foo and bar and
and bass you know it just gives me the
fubar bass you know and again you know
the number of arguments it can be any
number of arguments so if you know at
cukes they're in you know just
concatenate all of those things together
so it can be you know any arbitrary
number of arguments it's just going to
concatenate all those strings together
so that seems promising let's try to do
that so we'll say okay so I just write
STR here and then I'll make sure to put
a bracket at the end and then we'll see
you know down here in the a variation it
says well it doesn't do what we expect
it because it just returns the string
closure that landed lace is sick at
number and that's not really what we
wanted and the reason for that is it
turns out that you know that expression
all of this expression here is exactly
of that type it's a lazy sequence it's
actually not yet a number you know a
list of numbers or a list of strings
it's only a list of strings once you
start enumerating in numerating them and
you know a a list of values is not the
same thing as an argument list that you
use in that you know put specifically
into a function call if you will so this
doesn't quite work but on the other hand
this is such a common thing that you
need to do in closure that obviously
there's a solution for that so basically
every time you need to to say well you
know I want to call a function for
example STR and I have a list of
something and I just want you to treat
that as the input list as the argument
list of this function well there's
another built-in function that's called
apply that basically just enabled you to
do that so just say well apply STR to
this you know input list and then it
does what it is that we need to do so
now you'll see you know down there at
that you know fist pass from one to
sixteen actually returns a single string
with all of this new line stuff in it so
I just want to do two things because
first of all you know the requirements
are actually that I should that I should
return the the numbers from 1 to 100 so
again you know I'm just going to do a
place holder here and I so I'm now
defining in an overload within arity of
one orphanet with an allergy of zero
and that means I can call fizzbuzz
without you know supplying any arguments
at all and right now it's just going to
return placeholder because that's what I
wrote up there but obviously what I want
to do instead is I want to hard-code if
you will the numbers from 1 to 100 so
what I'm going to do here is I'm going
to call fizzbuzz with the with the
numbers from 1 to 100 and since you know
the the end is exclusive I need to do 1
to 101 so that's this bus without any
arguments the only thing that we've left
now is just like in Haskell we might
need to do you know a main a main
function you know the entry point into
an application that would actually print
all of this stuff out there on the
console I'm not going to do that I'm
just going to you know I'm just I'm not
going to create a program for this I'm
just going to print it out here so let's
just see if we can clear the console
that there all this pink stuff went
array so we can say print I'm just going
to call fizzbuzz bang and there we have
all the stuff again all right so that's
the fist bus Carter in enclosure as well
very nice ok thank you alright so let's
go back and see did we learn anything
and what off what often happens to me
when I do when I do Carter's is that it
turns out that maybe not every time but
the by doing exercises and learning new
languages and doing you know Carter's
and so on it changes the way that I
think about things or it gives me more
options for modeling how to address
various problems and it turns out that
often what you can do is you can
backport what you learn from one
language or one technique into what you
do on in your day to day job and we can
do that here as well and there's nothing
new in this in the sense that you know a
lot of the features that you haven't
should sharpen a java now are things
that i actually back ported from other
languages and so on but let's just see
what it looks like here so here's a new
version of the C sharp implementation of
the Carter so you'll notice that the
entry point now is a main method and the
only thing it does is says well consult
a guideline the value of calling
fizzbuzz from 1 to 100 so that looks a
lot similar to what I did in Haskell in
closure I'm just you know the main the
entry point is just a call to something
that produces a string and then I print
that
ring now what is fist bus well it's a
it's a helper method here that takes and
start an account and basically you see
the first line there says innumerable
range from start to counter innumerable
dot range is built into c-sharp I think
it's part of the link namespace
somewhere so that's just a static helper
method that will produce an ienumerable
of int from start and then with count so
the API is a little bit different you
don't you know supply an int value you
know you tell it how many elements you
want so in this case it's it's the same
one to a and the number of elements you
want is 100 so that's pretty much the
same so that gives you an ienumerable of
int and then you can say well let's do a
select over that and select it's just
the c-sharp name for a map so you saw
map in both haskell and closure and that
and map is what it's called in
functional programming but you know when
Anna's Heights burg decided to do in you
know to implement link or language
integrated query in in c-sharp
he thought that it would be easier for
sheesh Arvind Visual Basic developers to
learn if the concepts were named not
from functional programming but from
sequel syntax because most you know
she's sharp developers were probably
familiar with you know working with
sequel server oracle or whatever at the
time so say select in sequence basically
the same thing as a map anyway also ever
is pretty closely related so there's I'm
not saying the name it's bad but that's
just why he chose to name it like that
instead of calling it map but it is
exactly the same thing and then what we
give what we get back there is then an
ienumerable of string and then we can
aggregate it so we you know we saw the
aggregation before you know enclosure I
had this interpose thing what I'm doing
here is I just supplied a lambda
expression and I'm saying well for any
two X&amp;amp;Y those are two strings I'm just
going to concatenate those together but
also put a new line in between them and
then that's going to create a new string
which becomes the new X and then I get a
new wife from the next element of the
list and then I can concatenate those
together and that just becomes one
string in the end and the fist post one
helper method is not surprising it just
looks like this it takes a single
integer and returns a string now one of
the things that are interesting in with
this is well first of all you might ask
is this better
than the previous the previous
implementation issue sharp this is
actually longer the last one was like
ten lines of actual code this is maybe
12 15 lines of code so do we think it's
better maybe not you know it's always
subjective because it depends on what
your needs are but one thing that I
think is interesting about this is if
you imagine that you took those two
helper functions you know this person
fits plus one and make them public these
functions with methods would actually be
very testable because these are actually
what we what we know as pure functions I
talked about pure functions yesterday in
my talk yesterday and one of the things
that I talked about well is if a
function is a pure function you know
it's deterministic has no side effects
it's trivial to unit tests this is very
very easy to unit this so if you have a
need of unit testing something you know
instead of going and trying to you know
introduce all sorts of interface and say
well I need an interface that that
emulates that I'm writing to the console
and then I need to mark that interface
and blah blah blah which a lot of people
would actually do if they needed to make
this testable well what we can say is
well you know now we have this bus 1 and
we have fist bus and these are two pure
functions so they're trivial to unit
tests and then what we have left is just
the main the main function or the main
method there and the question is that's
basically just like they were
declarative one-liner do we really need
to unit test that there's no logic
agents are probably not we can leave
that as what tierod Meszaros calls a
humble method and not test it and then
we could test all the other things so I
think is often interesting just to see
you know you actually get some benefit
out of learning how to do it in
different languages on different
paradigms and that might actually be
applicable when you bring it back home
so so if you thought this was
interesting or it piqued your interest
and interest then you're welcome to come
and ask me I think I have like two
minutes left so I'm not going to take
any you know answers questions and
answers now but just come up and ask me
afterwards and I'll be happy having to
talk to you if you if you thought this
was interesting I haven't sometimes I
block a little bit about my adventures
in Carter so you can you know subscribe
to the blog or to Twitter also I do
occasionally cover some of these things
that I'm on caster for example I do a
treatment of the diamond cards with
property based testing in one of my plot
site courses so if you're interested in
that you can go to
it leaves slash plural side because I
knew no sometimes known as SS plur and
that's all the link to all my courses if
you don't have a subscription to blue
side I have have vouchers here that you
can welcome to come and get this is say
this is a free one-month subscription to
two plus is a trial subscription so if
you want those then come and get them
and also if you want to ask me something
come and ask me meet me out in the
hallway if you see me later on today and
ask me I'll be happy to talk to you but
with that I'll you know let you go if
you if you want to you know go and do
something else so thank you for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>