<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Generic Locking in C++ -  Andrei Alexandrescu | Coder Coacher - Coaching Coders</title><meta content="Generic Locking in C++ -  Andrei Alexandrescu - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Generic Locking in C++ -  Andrei Alexandrescu</b></h2><h5 class="post__date">2016-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ozOgzlxIsdg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">morning all right
well uh who here has been at my top of
yesterday all right did you like it
all right I got some good feedback one
of them was Kay Andre can you ever give
a talk that is not revolutionary the
answer is yes and the proof is this talk
that's coming right now so if you want
something and you go for that if you
want something ah nice
come here otherwise you can go right now
another piece of feedback I got was very
nice
somebody told me Andre you are the
master of uncomfortable silences because
you ask a question and you have the guts
to wait until somebody answers until
everybody in the audience feels hot in
their seat like huh he's asking me
probably so he's looking at me right now
this is going to happen today so be
prepared how about we build the slides
how about we build the slides so makes
like that PS and acp slides that PS to
my site and as I say tuned to my site
and called PS to PDF because I don't
have it on Mac for some reason the Mac
doesn't have PS to PDF and then I'm
going to a CP the PDF back to my to my
computer here and let's see if it works
huh 100% are nice processing so we got a
way for it to be copied back and there
we go alright that was a hurdle so now
we have the nice e built and fresh and
I'm going to talk about the topic for
which I'm not the most qualified in the
room for the simple reason that you guys
are awesome and that awesomeness
includes two particular folks Anthony
who has been giving the Great Auk
yesterday and the tutorial the day's the
two days before that and mr. Hubert
thundering voice Matthew at least not to
mention mark and
other folks in the audience so I know
for a fact are very good at this kind of
stuff that being said I'm going to do a
discuss code that is actually used in
production at Facebook know kind of you
know on a regular basis it essentially
it is literally used every time you use
the site so that's pretty nice right I
call it I call the topic generic locking
to hear a beak of a background of of how
this came about others up there's a
story to this Oh in the early 2000
there's a huge battle of concurrent
paradisal huge competition going on and
they're like a number of contenders
contain like patterns let's say
message-passing like free work stealing
automated paralyzation that live gave a
great talk about this yesterday
comparing and defining properly and
comparing all of these ways of doing
things in a way now nobody won right
although clearly before that you had
some sort of locked base program was the
dominant paradigm and everything else
was new right now it's not a lock for
base program kind of disappeared and
then kind of it's not there anymore it
still remains a very important paradigm
and it's actually better than lock
fear'd unlock free approaches in certain
situations such as when you want to set
priorities for things and they need to
be different lock freeze like entirely
all to democratic if you wish so lock
based programming turns out it remains
hugely important for C process programs
do we have agreement on this do you
agree against again again yeah no so
that was a bit of a latency there up
staying like I don't care yeah I would
take off right now go to that angularjs
talk all right so um now actually um in
2001 I wrote a very controversial
article so I'm kind of building a waving
together story here right
so in not just as I wrote this um I
probably my most controversial article
on in the C++ world
volatile them you know this is actually
this is actually a typo but it's very
interesting because it was auto
corrected it was multi-threaded I'm not
kidding the editor fixed that for me and
it's the first time I noticing it
because you know it's like I I'm I'm
reading the slides I'm kind of
rehearsing and I like I know the style
saying just my eyes are going to skip
over it and at this moment I was like up
maltreated which is actually kind of
whimsical it's interesting that that
autocorrect happened it's a visionary
right the maltreated program's best
friend yep multi-threading is
maltreating all right so um that article
uses a trick it uses the vault pals
connection to the supply source type
system which is it's a qualifier like
const or any other i mean that's it like
const or any other or cancer itself it's
a qualifier and you can use it for
overloading and for sort of defining
methods that apply to threaded or not
threaded objects and it introduced a
nice interest a nice idiom which was you
know whenever you have volatile you
can't use you can't use the the object
and in order to get rid of volatile you
would need to lock the object so it
reduce the volatility fire as an
indicator that the object is locked or
not so um it did not rely on volatile
semantics anyhow moving forward in 2011
c+ was introduced multi-threading rules
for containers and the way they work is
the following in C++ too as of year 2008
this particular proposal was introduced
let me kind of summarize it for you if
you have a container an STL container
you can call cast methods from different
threads literally simultaneously if you
want to modify it that you can't do that
but as long as they're multiple call
seemed to cast methods you can do it
simultaneously okay to continue the
story I'm going to go back a couple of
slides to continue the story a lot based
programming has also made progress even
though as competition had intensified
right even though there are new
paradigms coming log based kind of
followed suit and just got better to
wait only yesterday I was talking to
Hubert and he said actually there's a
new new implementations of readers or
multiple readers one writer locks which
are very good they're just very good
quality and you know kind of very
refined and very subtle so there's been
out of improvements in CPUs operating
systems API is better kernel level
mutexes better user space mutex is
better spin locks better reader readers
writer mutexes so again just to define
terms a bit put someone tell us what the
multiple many readers want writer mutex
is what is that yes please
so right so you can have many readers
accessing the the entering the critical
section at any time but if a writer
comes it would have to wait for readers
to go away right and once it acquires
the lock
nobody can either read no all right okay
question if a writer is waiting in a
reader is waiting who should get
priority somebody else so if a reader if
if I like so any number of real million
readers can read B simultaneously you
know acquiring the lock the mutex right
so then if a writer wants to wait and
there's other readers waiting who should
get priority yes why the writer why
otherwise it's very easy to start the
writer for the simple reason that new
readers can come at any time on that in
the door at no cost to them and
essentially they would start the writer
way of course this more we find ways to
to do this prioritization but in essence
you got to be careful with with this
kind of starvation so okay great so
allow we can do one write access that
precludes all other reads or writes but
we can do any number of read accesses
excellent so c plus x1x is serious about
log based programming we already have a
bunch of stuff in there such as mutex
time you text Anthony knows all about it
is the list even complete probably not
recursive mutex return recursive timing
attacks and then we have share mutex
share time you text so these would be
these would be readers writers and you
have only insi process starting with 17
you have the multiple readers one writer
lock but it's available today in boost
etc now here's the interesting part
here's what I'm kind of get so that
there is a punch line to this kind of
building a story here there's a punch
line which is the STD containers were
designed for readers in writer and let
me explain why
so you have this right you have multiple
readers one writer and then you have a
steel containers and a steel container
says a forecast message you can have
many readers for non cast method that
means you're assuming you're writing to
the object and you know there could be
no readers or other writers now let me
ask you this practically to implement
such a container what rules would you
need to observe so to implement a
container can have in cosmetics any
number of readers any number of threads
can enter the cons methods of the
container what what like if you
implement such a container what would
you need to be careful with yes no
mutable members thank you anything else
there's another thing
so no mutable members because Mirabal
allows you to cheat cons that century
and change the object surreptitiously
right and there's one more yes iterators
will be problematic because they kind of
kind of look into the container but
they're they have their own life but
there's one more simple thing that you
need to avoid yes no global data no
global mutable data so you can have
global state kind of kind of manipulated
in because again global sort of in a way
allow you to cheat Const right so if you
observe these two simple rules you can
say well my container basically is a you
know is obeying this particular this
particular rule you know no i/o which is
also for sort of a global thing so you
don't have to have like hidden mutation
inside your cons functions right so now
let me ask you this so we have two
things we have this rule which says you
have if you have a container as long as
it comes many you know many people can
call it but if it's non Const nobody can
nobody else can can use that container
and then you have the readers writer
lock which goes you have many readers
for the subject but one writer aren't
these two isn't there an eerie
similarity between these two things
right sides you know either wait a
minute wait a minute moment here right
we have a wait wait a minute moment
which is well how about then I kind of
make the to dovetail so you have
multiple simultaneous calls to cast
methods no cost cost methods concurrent
with coastal mountains methods and you
have user serious calls to none comes
methods and this is the same exact thing
for the write reader like a writer it's
almost the same you know almost the same
bullets here which is amazing right so
this kind of the nice thing that is
noticeable so you look at this
one-to-one correspondence am I making
sense here my guinere trust here so I
can trick you into using a template and
something and you know I'm going to even
pull a macron you if I feel like it
right so okay hmm one to one
correspondence readers writer and
constant constant amazing so whenever I
call out cons method I need to enter
read acquire and whenever I in turn on
cosmetic I need to enter write acquire
for the same lock for the same mutex
same synchronization object and it just
works by that rule so it works like
today with a still just do it so that's
the idea now we want to encapsulate all
of this good stuff and because of this
rule and because of this this rule in
the language it becomes very easy to
encapsulate and put you in a little
library and we have it so this the idea
let's keep a reader readers writer lock
outside the guarded object and issue a
read lock around each cons method issue
right lock around each non cons method
so now okay
in order to do this kind of stuff what
which of C++ is encapsulation mechanisms
can you think of I want to hook every
Const and every non cons method over any
object there is a type that does the
same exact thing which is a smart
pointer shared PTR a smart point a smart
pointer essentially hooks every method
by defining operator arrow and then it
allows you to do things right so let's
do that
about the following alright let's get
ready here okay
have a sip of coffee there all right
let's see so I have a template of any
type and any mutex type not any mutex
but a special kind of reader slide
writer mutex so you know by default it's
going to be shared via text or whatnot
and we have defined a struct
synchronized which is going to hold the
datum right and the datum is not Mirabal
you don't cheat on the data and it has a
mutable mutex because you can manipulate
it even in cosmetics and I'm going to
define a little class lock pointer which
defines operator arrow and I'm going to
define for this very class synchronized
I'm going to define its own operator
arrow which returns LOC pointer
similarly for can synchronize object I
define a different operator arrow which
returns a cancel a pointer which is has
its own definition as its own definition
which is very similar to this guy now
explain to me please
if I have a synchronized object like
this and I say object arrow method what
what's what functions are going to be
involved in what order yes please
so the ir operator is going to call
Bicol recursively notice the completely
incorrect use of the recursive I'm
kidding
so it's indeed it's going to be called
for as transitively for as long as it is
written so none pointer right excellent
thank you very much so I'm going to call
first the operator arrow on this guy on
the synchronized object and that's going
to return a lock pointer and the see
process compare is going to be like wait
a minute I didn't get a pointer yet for
this operator arrow so let me continue
is going to invoke the operator l for
this guy the lock pointer and then I'm
going to get a T star and find the
compare is going to be happy it's going
to stop the recursion right it's going
to stop transitively invoking the
operator arrow and it's going to call
the method against that pointer but
there is one more thing that's happening
because there's this object is returned
by value it's an R value so if I call a
operator arrow against a synchronized
object several other things are going to
happen so why don't you continue telling
us what's happening so first thing that
happens is so I call this guy it would
call the constructor of lock PTR
whatever the hell that does right you
don't know I mean I'm kind of I'm saving
that right you don't know yet so you
know don't be don't don't get ahead of
me what I'm saying is that this object
is going to be to be first constructed
returned from the operator arrow the
compare is going to invoke operator
around this guy and it's going to
finally get the pointer after which the
invocation occurs whatever you've been
voted for and then somebody else what's
what's it happen after the call returns
the destructor of lock pointer is going
to be invoked and I'm done with the call
so by just writing object arrow method I
create an object invoke a function
destroy an object in this order right so
you see I'm very deliberately here
setting you up
for a lock method call unlock sequence
better yet in the case I in case I have
a casting Crenn eyes object-- huh I'm
going to return a different type here so
I'm going to go through the same motions
except I'm going to create and destroy a
different type of object which you know
you can see where I'm going with this
this is invoking the readers lock and
this is invoking the right the writer
lock and all of a sudden with
essentially like this code only I got a
one-to-one mapping between everything on
cast and the writer lock and everything
constant the reader lock alright so
let's see a bit of the implementation
here there is of course a lot of details
to fill so we have have a constructor
here that's private we don't need it we
have the default we have synchronous
that takes a copy but by you know by
cons reference and bio or value
reference these are sort of the usual
suspects ah one nice trick here is you
we have the conditional no accept going
on which goes like this whenever you
copy a synchronized object is going to
be no except if and only if the the
valley itself is no throw copy
constructible so that's a nice example
of using a bit of introspection there to
make sure that we propagate product
properly the the you know the the
capabilities of T which is our generic
argument into the capabilities of
synchronized makes it did you know about
this like no accept no accept so you
have a few folks don't so it's very nice
sort of no accept is isn't is of is an
attribute of the function it is a is
part of the signature and it takes a
boolean it takes a boolean as an
argument you can write know accept and
put an operand and no boolean and that
means it's never going to throw
that's not entirely true but anyhow so
it's a the user makes a vow a pledge to
not throw that's probably more like it
right like you know in C++ never is it
means almost never and always means
almost always except for this long list
of exceptions and this is no exception
gee Wow three meanings of the word in
one sentence
you have to disagree on yeah never say
almost never accept okay so some like
just say no accepted means I'm mama you
know making a vow here to never throw
but if you put my accept any open and
pour any put a boolean constant in there
it's going to be no accept or not
depending on the boolean if it's true
you know and in this case it turns out
this there's this is no throw move
constructible standard introspection
facility which cannot be implemented in
standard C++ it's it's magic so you
can't you can sit down and implement it
the compiler has to define it for you
and the comparing side is going to
differ it's going to some you know
understand the score things to to
implement it but it's not implementable
in use up in user code it's it's an
introspection primitive and the same
goes about no throw copy constructible
which is also magic provided by the
compiler
so by this i'm saying well if the
original type was copy constructible
without exception then I'm going to not
throw from the synchronize constructor
as well which is as expected when it
built from a piece of data you actually
don't need to lock anything because it's
just you know just building the object
anew so there's no there's only four
locking there's no multiple threads
accessing this constructor so again
there's this whole no accept trick again
so with the assignment we have an
interesting we have an interesting thing
here to worry about
who
been in Anthony's talk yesterday okay
Anthony made a very good point yesterday
which was if you want to if you have any
piece of code that needs to lock needs
to acquire more than one lock
they need to be acquiring the same water
in all threads because if not what's
going to happen somebody who hasn't been
in Anthony tour let's the thing
real-time here so if you acquire if you
want function acquires lock one lock to
and the other function choir is locked
to locked one what's going to happen yes
deadlock how is it occurring someone in
the front because it's easier for me to
hear how is it happening how's the
deadlock occurring yes right so it just
happens it doesn't always happen it only
happens when one thread got so far as
acquiring one of the two locks and the
other also has gotten to acquire the
other of the two locks and then they
both wait for each other in the other
they never release so what is the
obvious solution to that yes cycle
detection there's an easier solution
actually to that which is here locking
increasing role of that D address
because the address is unique and
ordered for the whole application you
don't care what the order is it just has
to be the same so that's the clever
thing here right so to be like more
Catholic than the Pope himself I just I
just say STD less of void star which is
a guarantee that I can compare pointers
for inequality regardless where they
come from this is the standard way of
saying I want to compare two pointers
they are not in the same array they're
not in the same object did you know this
is like this should become and everybody
should know this and everybody knows
it's starting like as of a second ago
awesome great so you know it just used
this less thing and on unit on on these
flat memory systems of to date work so
it's just works automatically but
remember when you were kids that does a
thing called segmented memory
architecture
I didn't have anybody work with this
okay some of us do have the gray hair to
prove it and you don't want huh or no
hair at all I know the bowl thing is in
vogue right now so I should try it so um
essentially like in those days you would
need to do some pointer adjustment so
the comparison would be more complicated
and more costly so therefore you would
need to use this listing all right
so all I'm saying is that if the if this
is at a lower address than RHS you lock
in the order of this and the other guy
otherwise you lock in the other order
and that way the assignment of two
synchronized objects proceeds nicely
right and we have a number of other
usual suspects such as move assignments
swap and such right awesome question so
far okay let's let's recap the basic
plot here let me see what okay excellent
so before getting to the implementation
of the operator arrow let me let me
share again the the basic plot I'm
following here just to make sure we are
on the same page so we we built the
synchronized pipe around the following
realization which is the new c plus 11
rule guarantees that i can call any i
can enter from any number of threads the
const methods of a container write at
the same time if the method is non const
I could allow no other cost or non cons
method to be executed concurrently so I
need to do logging taking the yes
no go ahead yes yes no because you
create objects here so you create
actually named objects which are going
to raise to be through the end of the
scope yeah so these g1 and g2 are these
lock PTR types and they're going to
exist until the end of the scope okay
actually I did have a moment when I
thought oh my god this may be all wrong
but then I thought you know sorry you
know I was uh it's this type is used a
lot inside Facebook so if there is a
there's a big mistake like this I'm sure
it would have been discovered by now or
not and you know so you know that when
Facebook like fails people call 9-1-1
and there's this you know this issue get
moving on with sort of the the recap so
my plan here is to say well we have cost
methods many many readers so the cost
would the cosmesis would be the many
readers and the non cons needed mutating
methods would be the writers and then I
have this nice correspondence I can use
Const as my trigger my indicator for
whether I want to lock the object for
reading or writing so that's my that's
my plot that's my basic this is sort of
the the discovery we've made that allows
us to implant this abstraction without
that particular rule in C++ you can't
and actually let me tell you this this
was the case before C++ 11 all C++
implementations I know of had containers
that obeyed this rule so this was just
simply enacting into law what was the
facto true which was C STL containers
never used mutable data and never used
Global's because people notice a number
of issues with those
related 2/3 or not the two threads or
not so those actually in the 94 does
kind of a transient issue with that and
people are gonna like you know what no
Global's no mutable data in STL so this
was kind of the case before this and I'm
very happy became law because then it
allows us to do this so alright so we
have this this operator arrow which is
going to be overloaded for constant on
constabies
and this this little thing here allows
me to choose whether I use Reed locking
or right locking by means of the return
type and then the return type has its
own arrow great alright so moving on
with the implementation of operator
arrow the locking pointer which is going
to be inside the synchronized holds a
pointer to its parent and it does not
have a default constructor it's you
wouldn't it does make sense to create an
default locking pointer object it's just
it's only it's only raison d'Ãªtre is to
just be created as a temporary from
operator arrow from from the
synchronized guy so you know simply
locking pointer synchronous start my
parent stores the parent and mutex lock
boom so that's my locking pointer what
do you think the cost locking pointer
constructor looks like yes ah so it's
going to be a shared lock here different
call this is the acquiring the lock in
right mode and this other guy is going
to acquire the lock in yeah come on ah
ok oh man I didn't write that
okay well I'm missing a slide here which
was very nicely so that the next slide
should have been the identical code
except the name locking pointer because
like in pointer and this would be a call
to Sherlock shared lock right ok so um
as a small details you should know that
readers write are mutex are recurs
Seve so you can lock the same thing
multiple times which is nice and you
kind of you know it's convenient when
you assign a lot pointer to another you
just have to make sure it sites there's
no self assignment etc so it's this is
just protium ization you could actually
acquire it twice
all right look so um for efficiency also
want to implant the move constructor
which takes a value reference to the
other lock pointer and again you compare
you make sure don't self self move
assign which would be very very bad but
it's still legal is that right can you
self move assign are you allowed to I'm
seeing some raised eyebrows I've up to
the ceiling there I'm seeing a sad not
from Detlef in the back and just like
telling you people what's happening in
the room right now so yeah it's very bad
but it does happen people kind of do it
they shouldn't but just for this is like
code for bad people it's going to
support them it's going to make them
happy alright so um awesome and what
else Oh
oh yeah you can't move construct an
object into itself that you're not
allowed to alter it syntactically can
you can't move from a non-existing
object into itself
well this is it was posed for it right
as always you can construct these
sentences that kind of parse and then
like oh well that can't be right
so okay so in the destructor obvious
you're going to unlock the mutex if the
pant was not now and that sort of you
know completes the lock pointer so you
know it's all boilerplate and it's all
simple code the nice thing is it's it's
it's highly reusable so okay
the whole point of of the lock pointer
was to implement this operator arrow
which simply just
does the data no problem of course if
you create a lock pointer and you move
from it or something and it gets to the
null pointer if you try to invoke the
operator arrow you're going to get a
sick segmentation fault which is you
know pretty much what you deserve right
excellent
we pop out of lock pointer and that
synchronize level as I promised we have
an operator arrow non Const which
returns on our value of type lock
pointer and this completes the lock
pointer part so whenever I use some H
PTR arrow XYZ you have three vocations
of operator l1 for the synchronized
object the next for the lock pointer and
then you get the object and then the
lock pointer gets destroyed and the
whole locking and locking mechanism is
automatic console.log pointer looks a
lot like it's essentially the same code
as I said it's pretty much just the same
except you've been to call parent mutex
lock unlock shared right so you're going
to call different methods right
all right who can tell us what see begin
and see and doing c plus 11 c begin c
and yes they return a constant iterator
for a mutable object right for a like
non constant you know regular container
they return cos theta raters could you
could you do you need them are they
necessary are they can I you know are
they necessary or they convenience well
they're convenience and I'll tell you
why you could take the container cast it
into a reference to a Const container
and then take begin from that and that's
my C begin but it will be through two
lines a only variable it will be
ridiculous sorry server cast cast like
an idiot there and I put like no cost
container
that and then I make a mr. typo I care
for something that I shouldn't be
casting to and you know it don't want
all that so see beginning is a
convenience function that says ah even
though I could mutate this container if
I so wanted I'd be good today
I'm not going to mutate it so let me
call C begin Sen is that right so for
the same reason sometimes I want to be
nice to an object I could mutate and say
actually I want as Const I want to look
at the subject as if it were a can stop
Jake so then you can say HP TRS Const
arrow method and that's going to acquire
which kind of lock which like the
readers lock or the writer lock the
readers lock right the multiple readers
because it's a constant object it's
going to invoke the method so that's a
nice convenience function so now it gets
to a fun part so whenever I give talk
about anything really
at some point if I have a macro in
variable there's going to be like three
dudes at the end of the talk saying you
know that macro let me ask you a few
questions about it I'm not kidding like
every fascinates people it's like I
don't know it's like people are weird
like that this is like that is the I
don't know adults-only section of my
talk it's like you know what I have to
ask you in private a few questions about
that macro because I found it very
interesting and dignified with you know
I I think it's good to talk about it and
I'm going to use this for the rest of my
life right so um this is going to be fun
so you know here's the thing
I'm gonna do something stupid here's
something stupid I'm gonna do who can
spot the huge mistake I'm making here
hmm yes please
yeah this is kind of a rookie mistake
so SV is like a synchronized vector
right very nice well let me test if it's
empty SV acquire a reader lock call
empty get back from the reader lock
unlock let's say it returns it's not
it's not empty
bond okay so then I open a scope here
and I'm going to say oh if it's not then
I can access the front right now because
I'm so smart so good right and this is
going to acquire another lock and of
course in the meantime between between
the closing of this particular
parenthesis and the opening of this guy
like this there's an e on here there's
an infinite amount of time
in thread like in theory you could think
an unbounded amount of time could occur
in there and you know the other threads
may have a party right then they like
you know this is awesome going to lock
and unlock the object and manipulate it
any way we want
including making it empty how about that
so then I'm going to take front of an
empty vector so you can't use the object
that way and actually I've been
criticized by people at Facebook we said
ah you made it too easy to do this
because you just people just write an
arrow and then whenever they write an
arrow there's a lock and unlock
happening and I'm like well right read
the fine manual RTFM right redefine
manual so um all right what's the cure
for this what is the cure for this yes
please right so I need some sort of I
need a mechanism to be able to lock the
whole SV thing and then use it in you
know inside the critical section and
then be done with it so you know I've
been thinking about this for a while and
I found something that's very nice
except it uses a macro here's what his
other trick is I define a pseudo
statement which is called obviously
synchronized in all caps because we like
to shout when we write macros
synchronize this V and this is the use
so it's almost like magic because inside
synchronized it's a critical section and
I can use this V as a vector so I can
write as V dot MP instead of SV arrow
empty so inside the pseudo statement I
have an already locked vector and if it
was mutable it's going to be acquired
for right and if it was not if it was
Const it's going to be synchronized for
for reads only so now I can call inside
the synchronized section I can call any
method on the vector because SV was
mutable so inside this visa is an L
value of type vector in and lock is in
in fact I can use this vector notice
something interesting this macro not
only in to does the Lockean of all that
stuff but also it changes the type of
the name is V from synchronized vector
to vector do you want to see it the
definition right up for it all right
they have that blood running through
your veins right now alright this is it
I'm not kidding this is it oh man looks
ugly it's only now I'm kind of band man
this looks really bad here all right so
all right this next section is like
andre tricks for writing macros and the
trick number one is you want you want to
inject things into a new scope then you
have these if statements and these four
statements that all they do is kind of
inject names into the upcoming scope so
first time I define an if bull
underscore one equals zero like an idiot
and I do nothing and I say else and that
made available for me a boolean variable
because I want to play with it and then
I have a four that does pretty much
nothing because it's going to last until
like not on the score line it's going to
run exactly once
several four and it says Auto underscore
two equals x which is my argument
operator arrow haha
so at this point I'm acquiring the lock
and then I'm going to do this you know
this stupid thing that essentially makes
the loop run exactly once and then I'm
going to take so here I'm taking the
locking pointer and at this point I'm
taking the vector which is an L value
and then calling star on the square -
which is my luck in pointer operator
arrow so I need to call by hand though I
make by hand those two calls to operator
arrow that we're talking about they're
done automatically by the compiler
otherwise in the macro I'll do the by
hand so at this point notice that I
entered this X which is a template sorry
a macro parameter and effect effectively
X is going to shadow the name X in the
scope that's above it and I redefine X
to be this time on a reference to in our
case of vector yes the compact does the
compared not to do that trick for you
no because what I want to get is not the
pointer I want to get the reference so
if I want to get the reference I need to
do them by hand right all right so all
this guy does one is limit look loops to
one pass as you see there's then not one
and one gets like there should be true
here just to be nice but I didn't have
room on the slide this should be true
I'm not kidding actually does not ruin
the side so I could is one right it
compiles and runs so I get actually I
checked it does get optimized the way
all that boolean nonsense that compares
like ah this guy must be an idiot so
okay let me compile this better for him
because I'm not sure what's wrong with
that code but I don't care so okay fine
first up crates are like in pointer ii
is going to take from the locking
pointer the L value and is going to
shadow the object with energy by the
same name and this macro actually does
everything all of the
all of that that allows me to do this
cleanly very nice all right
that's an issue though what if I have
and careful here is not a synchronized
vector it's a vector of synchronized so
the synchronized is inside that each
vector element is synchronized has a
lock right so not the whole vector is
synchronized but only what's inside and
I want to say I want to synchronize on
this vector front what's going to happen
there when you expand the macro who can
tell us yes
aha so remember I said this X here is a
macro parameter is going to shadow
whatever but in this case I call
synchronize with an expression it's not
done it's not a name it's an expression
so the compiler is going to be like you
are an idiot because you're trying not
to define a name but you're trying to
define an expression as equal something
which is ridiculous
right you're not you can't do that so
this is not going to work as soon as you
have an expression here that's not just
exactly one name you can't use this so
you know I lost a few nights of sleep
over that because I so I need to kind of
create like a temporary here and it's
not pleasant here's what I came up with
well when one argument is not enough I'm
going to define two so synchronize with
two arguments and this is my name first
and I'm assigning it from vsw front and
inside I'm going to use the name first
now anybody who's ever written one macro
is going to know that we're entering
dangerous territory here because we have
the same macro name used with one
argument or two arguments and it kind of
just got to distinguish the situation's
do you think is doable
honest because I thought is not doable
for a long time and then I don't know
one day I had the divine inspiration
so I did it so this is how it works I'll
start innocently define our one of a and
any other number of parameters a that
gives you the first argument of any
number of arguments nothing up my
sleeves define are two or one so if I
call our tour one with two arguments is
going to give me the second argument but
if I call it with one argument is going
to be give me the first argument and
here's how it works
our tour one impl var X comma V a args
and our two are on impl of a b and any
other argument is going to return B so
now let's see if you call our two or one
with one argument X it's going to expand
into our two or on impl X comma X and
then is our one or two run IPL of X
comma X is going to expand to argh you
know it's going to expand to X comma X
it's going to return X so that's what I
wanted and I'm done
how about we call this guy our to run
with X comma Y two arguments right in
that case I'm going to expand it to X
comma Y comma X comma Y XY XY right
because I'm doubling the readyq argument
here and in this case is going to go
into our two or on impl of X comma Y
comma X comma Y so it's going to give me
Y so if I call it with one argument is
going to be me give me that argument if
I call it with two argument is going to
be give me the second argument so I have
two macros give me the first argument
give me the second or first argument
already ready for the next level here
all right so we're done because we get
our tour one of VXR and I'm getting our
one here and it turns out it just were
that way say if we invoke this guy with
synchronize one argument you're going to
get just like before but if you invoke
is with two arguments
this operator arrow is going to be the
second argument call against the second
argument and in this case I'm always
saying I'm always speaking the first
argument to define the variable so this
very macro is going to be usable with
this idiom and that idiom which is
awesome I'm very happy I gotta tell you
this is one of those dirty pleasures of
life right it's you know I felt very
satisfied in and kind of in a shameful
way I should add by having written this
okay great so now you know
so recall C B and C and we sometimes
want to specify even though this
particular expression is mutable I'm
just I just want the Const accounts lock
reader lock so in that case it's good to
define a new macro which fortunately can
reuse the existing macros so we're good
we just use this as constant method here
and whenever I say synchronize cons you
know that inside you're going to have a
reader lock and you be able only to call
the cons methods of that guy so terrific
all right so
this codex yes this macro is used at
Facebook and actually like there's 7,000
something users of it is that right it's
in the thousands of years of course the
code is much larger but you know it's
it's used intensively yes you don't get
shadowing warnings all the time no
actually I'm I'm not sure if that
warning is explicitly suppressed or if
it's just you know okay well I gotta get
back to you on that so I remember those
there's a discussion about that and
people are like you know what I like
shadowing things all the time so I'm not
gonna oh and actually I remember the
problem
there are some Global's that people
define and you know the shadowing
warnings were too many false positives
and people didn't like it so didn't
enable that warning I remember Jim iring
a former coworker who really wanted to
introduce this warning and everybody
protested so it didn't you know I didn't
take yes can you implement this as a
function taking lamda I think you can
implant this as a function taking lamda
instead of a macro right yes it would be
a bit more quirky syntactically but you
can do it you can say lock the subject
call this lambda unlock the object yes
Anthony
so there is a so it's it's not there yet
it's uh it's going to be like year 3000
some okay awesome
thank you that's great yes
did I have any argument of using
volatile no actually this works better
because like I noticed that people have
such like people have like a very strong
emotional reaction when they see
volatile they like oh this can't
possibly work and they stop there it's
like a psychological barrier that I
found it's unpassable so I'm very happy
that this whole constant mutable thing
works properly with with a steel
containers into actually works with a
lot of user-defined data to be honest I
you know you don't use mutable data
every day and you don't use you know
static state every day right so um I'm
happy with the state of affairs and I
kind of renege that that old article yes
as long as you don't have operator dot
is the macro confusing by the use of the
arrow if you want to lock the object on
the fly versus dot if you don't lock the
object on the fly this comment came a
couple of times so let me kind of make
sure I understood what you mean so I
mean this like arrow here right
and here yeah so that's a so here use
the dot and if you don't use the
synchronize pseudo statement you just
use the arrow people mention that
actually let me add this you it's easy
to implement the macro to force you
twist the air in both cases I chose to a
lot of people to use the dot because
that pointer can never be now so I'm not
you know I I don't think it's a huge
problem I think people just you know get
used to it
yes
can use an acquire method in the object
that returns a lock I gotta take this
offline because I'm not sure I
understand how how this would work so it
would be instead of the arrow it there
will be an explicit call I guess you
could solve just to make sure I
understand so essentially instead of the
synchronous macro you would have a
method then you would it would return an
object and then you reuse that object
and then get rid of that object and is
that you get a reference ah yeah yeah I
got a look at it to make sure how but
anyhow you open you open with instead of
a magic macro and that point my brain
stopped because like no I instead of a
magic marker with nothing else I would
use a magic macro period thank you very
much so a magic macro is like kind of
cool and you know I have suspicion that
the see process standardization
Committee defined apply just because
they didn't know how to do this arcs one
and two this thing how about that
all right so further reading we're
getting there
all right further reading so um just
Google for follow synchronize you're
going to find it on github in Facebook
repository it's a my I'm very happy to
report that it's it's being used it's
been quite a bit there's like you know
there's a number of other methods that I
didn't discuss because they are trivial
there's time locking there's an
interesting other magic macro
unsynchronized which inside the
synchronous statement just so happens
sometimes you want to get rid of it say
I've synchronized you open a scope you
do tada
and you're like ah at this point I'm
kind of tired of being synchronized so
let me unsynchronized the following
operations see open a new scope with
unsynchronized and then you write
someone synchronous code then you close
that guy you're back to synchronization
it turns out it's
good to have and synchronized duel is a
macro that allows you to synchronize on
two objects at the same time by doing
that trick of locking them in increasing
order of the address right so I can take
a few more questions yes do you make do
you allow concurrency errors by using
this things like this I so you're asking
the I'm making it too easy too okay that
argument can be made and has been made
so on the other hand this is C++ I mean
you're trusting with it people know what
they're doing to some extent and it
turns out very often for highly granular
objects you do want to lock the object
column as a dialog the object quite
often so you know a ality to to decide
the argument can be made
i I do agree I I could mean more
difficult like just say SV dot you know
make sure not you're doing open closed
paren you know that kind of function yes
there's another other questions yes
house debugging you know I'm having
difficulty answering this question
because like house debugging going with
like step-by-step debug and stuff I
difficulty with this question because I
never need to debug my programs
it's like it's an unknown territory to
me all my programs work from the first
go so I have no idea
I suspect debugging goes just you know
macros have have the usual issues
debugging step by step is going to keep
the object locked inside the synchronous
method so it's probably the usual
suspects but I don't think there's
anything sort of new or interesting in
the debugging space brought about by
this the use of these functions and
macros yes yes
so getting back to the lock pointer that
used volatile and non-volatile and you
yes Oh would so what is the what's the
question yeah you could and so if you
could take sort of a temporary object
and use it in knowledge that that's a
lot of jecht yes definitely dark I think
there are a number of other idioms that
you could use around this the simple as
a standard rule or about HDL containers
so I happen to like this one it's it's
very it's very convenient and very terse
but definitely you can make it more
explicit if you so want it alright last
question all right you've been awesome
thank you so much thank you thank you
thank you very much thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>