<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>.NET without Windows - Matt Ellis | Coder Coacher - Coaching Coders</title><meta content=".NET without Windows - Matt Ellis - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/NDC-Conferences/">NDC Conferences</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>.NET without Windows - Matt Ellis</b></h2><h5 class="post__date">2016-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/a4xn-7sUDkE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay none folks good morning thanks for
coming hope you're enjoying the
conference so far and my name is Matt
and today we're going to talk about
dotnet without windows which of course
means it's a dotnet core talk I'm going
to have a look at what it means to build
and run and deploy and debug a net core
application without having to use
Windows without using visual studio and
the first thing we need to do really is
kind of ask ourselves why why are we
interested in doing this why do we want
to run dotnet without windows and of
course the answer is of course because
all developers love macbooks and we're
all sick and tired of running windows on
a vm well of course if you want to
slightly less flippant answer the
probably a couple of things you could
say here firstly I think there's a
decline of of the monoculture the idea
that Microsoft has to be the entire
stack top to bottom it's we've had more
of a sort of a rise of the polyglot
programming so the idea of using
different tools different languages
different operating systems with the
right tools for the right job we've also
seen in recent times the rise of the
DevOps culture more specifically the
idea that you can sort of automate your
infrastructure you can it's got a
repeatable it's immutable and you can
automate it and Windows doesn't really
fit into this world at the moment so
they're working on that with nano server
and it's going to be much more
scriptable and workable but right now
the majority of the tooling around this
is really focused around the linux space
and the third reason is is the cloud
running your servers in on somebody
else's hardware is a great idea it's
nice being able to scale up and scale
down as appropriate but when you pay for
this and you paper the the signs that
some of the files on disk and the size
of the memory footprint that you've got
then windows can be a bit heavy for this
windows server is several gigs whereas
Linux is several hundred megabyte when
you install Windows Server you've got
more files on disk than you actually
going to need you know Ken's use calm
you're not going use WPF you're not
going to use notepad or explorer and
it's just kind of blows then what you've
got on your disk and increases any kind
of surface area you've got 44 secure
attacks and means you've got more
reboots and so on and this is definitely
the use case for nano server in the
future it was much more stripped-down
version of windows which is against
several hundred Meg's similar to Linux
but linux is there now so we want to
sort of really have something within
that space which we can reuse our skill
sets as dotnet developers to implement
applications but it's not just darnet
core we shouldn't we shouldn't just
totally focus on neck or we've been able
to do cross platform for a good while
now mano has been around since 2001
since pretty much the start of the
dotnet framework itself it's
cross-platform it runs on linux on Mac
on Windows evanni PlayStation which is
pretty cool the other interesting thing
is that it's not just for server
applications so you can do GUI
applications where that gtk sharp is a
cross-platform GUI tool kit so you could
do desktop applications the other thing
to say about mono is this open source
which it means you can contribute to it
but also and anecdotally really the it
means that there isn't a big corporation
behind it like Microsoft to put in
necessarily the the resources that you'd
require for such a big project so
anecdotally there are people you are
more likely to encounter
incompatibilities with a dotnet
framework and other issues which can
cause you problems for example the
current conversation around dotnet core
is that it is faster than 10 so this is
a good thing here it also works both
ways as well so because mono is open
source it can take code in and because
net and dotnet core is open source then
they can pull those codes in so mano has
seen a number of things brought in from
the dark net framework they've replaced
the thread pool implementation with the
one from the for.net framework just the
other week on on net Miguel was talking
about the number of class libraries that
have changed and depend on how you count
is between forty and sixty percent of
the base class libraries have been
updated with code from Microsoft they're
also looking at bringing the garbage
collector in as well
and then we got xamarin which is perhaps
Manos biggest sponsor they provide
cross-platform support for the mac for
iOS for android and the thing they add
on top of Mauna really is a sum platform
api binding so you can do native
applications everything is statically
compiled ahead of time statically linked
so you don't deploy the runtime you
still got a garbage collector but you
don't necessarily have things like legit
compilation this has also been recently
open source with the acquisition by
Microsoft but the again the interesting
thing I want to point out here is
xamarin forms it's again it's about
cross-platform desktop applications and
gooey apps and having a native looking
field by have by abstracting the the
native widgets building a sam'l to work
Frank it haha toolkit or framework not
toolkit that that works with the native
widgets and gives you the native look
and feel that gives you kind like a
common subset of functionality but it
gives you then an escape hatch if you
want to get into more rich and more
native functionality and the this is
therefore I ask for Android for windows
phone and the interesting thing is
there's a WPF back end which is nearly
finished so this could be an interesting
thing to watch for doing cross-platform
desktop applications and in unity unity
is a huge thing as well the website says
they have four and a half million
registered developers if you haven't
used it then if you downloaded a game on
your mobile phone chances are it's
powered by unity it's a native game
engine but the logic behind the games
can be powered by net by mono and this
is very much cross-platform as well iOS
Android Windows Phone Windows Mac
PlayStation Xbox virtuality things and
even Tizen and it anybody know what ties
miss more than me well done I've got no
idea so that brings us to dark net cord
and I kind of assume out all of you have
heard of dark net core but just to kind
of quickly recap it's a new dotnet stack
from Microsoft that means it's the full
stack top to bottom the clr itself the
runtime the the JIT compiler the garbage
collector and it's the base class
libraries as well system dot threading
collections collections immutable XML
HTTP and so on
it's not brand new it was initially
forked from the dark net framework so it
is based on tried and tested code and
this is now cross platform this is a big
thing here it works on Windows it's also
going to work on nano server which is a
good thing and also runs on OS 10
various flavors of Linux and also
FreeBSD freebsd is in brackets here
because it's not listed as one of their
officially supported platforms but it
does run on there it's open source as
well it's hosted on github you can get
the sauce build it contributes you can
interact with the developers you can
raise issues and so on it's all good and
the other big thing about it really is
that the base class library has been
very much refactored all of the
assemblies have been split down into
more of a fine-grained set of
collections so collections API for
example is a good one you'd have
system.collections and collections
immutable of separate assemblies you've
got threading as one assembly
threatening tasks another and the same
we things like I oh zip files would be
different to drive info to different to
file info all the separate assemblies
and you get is everywhere every single
assembly is packaged as a nuget package
the runtime is also a nuget package this
is a big deal with net core I don't
spend too much time on this but this is
kind of the way that compatibility is
going to work with with.net core this is
worth looking at in more detail at the
dots on github the idea of the.net
standard platform this is a virtual
platform which other platforms implement
so it's like a specification release
it's a common subset of API is that are
available on a particular physical
platform and its version that each
version is sort of back was compatible
of the API is in that subset are
additive so for example you've got
dotnet platforms down at one point six
and the platforms that currently work
with that I dotnet core one point 0 and
the.net framework 463 the idea of this
is that it kind of replaces the portable
class library idea portable class
libraries they are not extensible so if
you have a library the target a portable
class library that specifies the list of
all the platforms that it actually
supports
if you add a new platform it's not
supported so this idea of having this
kind of virtual API abstraction
specification kind of gets around that
as long as the platform conforms to the
one of these standards then it can
consume stuff the idea is that as a
package author you target the lowest
next standard possible and in that way
you then get the widest reach of actual
platforms so for example if you targeted
1.6 your library would only work on neck
not net core 1 point 0 and donÃ­t
framework for 63 but if you targeted 1.3
for example you can run on dot net
framework 4.6 and above you can also run
on Windows 10 applications and also of
course mono and likewise if you run in
1.1 then you can run on all the
platforms at one point one supports
application authors will then target the
actual platform so you'd still target
dotnet 451 if you're unmet or you could
do another new one here which is net
corps app which is a an application for
net core now I don't think we can talk
about dotnet core really without talking
about some of the recent angst in the
community and the early adopters and a
bit of its image problem think this this
image here from the one of Em's damn
blogs is a good sort of metaphor for
this really at the bottom layer here
we've got dotnet core that's the runtime
the base class library it's all nice and
neat and and lovely and reading
everything next layer up is asp.net core
which relies on net core below and again
that's nice and neat and ready and
everything and then at the top in this
little kind of thing not quite fitting
in and sort of sticking out we've got
visual studio and the tooling and
everything and this is kind of the
situation we're in so to briefly recap
some of this up until sort of release
candidate one during development
everything's moving along nicely and
we've got the cross-platform ports we've
got refactored base class library we hit
our c1 we gotta go live license
everything's good and then after rc1
it's announced that they're going to re
platform that means that the tooling is
going to get a complete rewrite this is
a breaking change on top of RC one it
makes sense having had a look at the
platform you can see that it's actually
really quite
focused on asp.net development and
doesn't necessarily focus on some of the
plat for the platforms that dotnet call
would like to address and so there's
been a rewrite of all the tooling there
but we're then left in a situation where
we've had a goal I've license for RC 1
we've had lots of breaking changes for
RC 2 in the tooling and right now with
the release we've got the dotnet core
the bottom layer we got the middle layer
with asp.net school they are US release
candidates to status they're going to
rtm at the end of June but our tooling
is a preview one and that's just a bit
kind of weird and then on top of that
we've got a changes to the project
formats so the project format file right
now is project Jason this is going away
which makes kind of giving a talk about
it fun but the idea again having a look
at what it does it's very much again
focused on the asp.net side of things
and the sort of no DJ s type of working
and it's great for simple application
simple libraries but if you want to do
something a bit more complicated then
there's kind of not enough scope to work
with Adam to get that done so they could
Microsoft could invest time and effort
to increase what project Jason does make
it more flexible more powerful or they
could turn round to the existing
solution to this problem which is ms
build and that's what they're doing so
the rolling back changes in air in
project Jason and they're using ms build
and CS proj files that then leaves us it
gives it gives us a little bit of a
dilemma do we port now and migrate
everything to project Jason just for it
to return back to CS proj files or do we
hang on and wait the tooling is going to
help with this the tune is going to make
this a bit somewhat automatic but then
that's do with visual studio next which
we don't really know what the rtm is for
that and it sometime about November's is
kind of the best we know so there's kind
of a couple of frustrations about this
and then there's another thing so we've
kind of out after the rtm there are
plans to greatly expand the API surface
this was already part of the plans it
was already going to happen the API
service and the net standard was going
to increase and
prove but it looks like some of the
api's that were removed from dotnet core
and the net standard were decided to be
to be cut to to sort of improve the
developer experience and these are now
going to get put back in again and this
same sort of gives us a bit of a
interesting dilemma with with this here
so if we now have a next standard 2
point 0 which implements a whole bunch
of AP is that were previously cut we
could have dot net framework 4.5 for
example could implement all of those AP
is but how is it now going to support
net standard two point oh so you're
going to have code in that standard 2
point 0 which can't work on 4.5 so if
this all looks very much like its
associated with xamarin acquisition the
target API is that are going to be
implemented are that pretty much the
same as the exam as monos model platform
which is monos subset of api to the.net
framework that it implements and reading
between the lines then does that mean
that dotnet core is now starting to
target xamarin in unity there are
questions really does this harm adoption
should should I bother porting right now
too if it's going to sort of be easy
earlier later because if they're going
to go back to CS profile I don't have to
convert my file format I don't have to
work around any API changes are there so
from from a point of view jetbrains
we've got project rider which is going
to be our net ID we run resharper at the
moment on ma know when we're running a
cross platform we want to put that on
dotnet core because we've been told
monotonic core is going to be faster but
we've got back 300 projects to convert
so right now we'd have to convert 300
projects to project Jason fix up any API
changes or we could just wait and
waiting looks a whole lot easier the
other thing is does this change the
vision of the darknet course we had
something which was kind of small
focused on nice layering on the nice
refactoring of the base class libraries
does this kind of change the vision by X
greatly expanding the api's like that
this and right now this kind of early
days really we don't know enough detail
to to know how this is going to affect
things but don't panic this is this is
all okay this isn't too bad this is the
very top layer that we've got going on
here
the bottom layer is still good the
dotnet core and the asp.net core is is
good and most of this really is a timing
communications issue if this would
happen during beta this would be fine we
wouldn't bother about this but it's
happened during release candidate and
that kind of makes things a bit tricky
and it's not the great not the best
timing but we can work around we can
work with it this is a great quote by
Nick Craver saying the by the project
project it's not developed in the open
it's coded in the open and this is this
is things the decisions are made behind
closed doors that's not necessarily a
bad thing you know for example the
Rosalynn projects all of its language
design meetings happen behind closed
doors but then it didn't put on github
and discussed so it's all fine but we
all need to kind of adjust to this and
get used to this idea that it's still
Microsoft's project these changes can
happen and it's okay we just need to
make sure that the communications around
this happen well as well it's all recent
news dust will settle it'll move on and
it'll be okay the changes all make sense
as well so it's actually going to make
things better the new command line
tooling is better it's more extensible
it's better focused on tax so that we
wanted to be able to do the project
Jason changes are going to be good
because we're going to have projects
that do need the power of ms build and
do need to do extra interesting things
like that and also the idea of the
extended API said it is going to make 14
code easier and if we can get more code
onto the new platform it's going to be
better so the changes dual make sense we
also have very smart men and women
working on this as well so it's a it is
a good project it's going to come
together it's going to be okay and the
other thing to point out in it to
reiterate as well despite any kind of a
controversy we got at the top the.net
core and the asp.net core layers they
are definitely solid they are good
quality and a stable everything and
everything is kind of generally
genuinely ready for rtm the other thing
to point out I know it's not terribly
easy to read of that is the Microsoft
very much aware that CS proj files are
horrible and protect our JSON files are
much nicer and simpler and easier to use
and they're going to be aiming to work
towards this so we've got most of the
stuff in the cs profile on the left
there
this death of visual studio and they
also control visual studio and they
rewrite in the project system for visual
studio next for C sharp and they are
I've already got an issue which is
tracking this and trying to reduce the
amount of cruft that is in the file
there I don't think I'll ever get to the
simplicity of project Jason but it's it
can certainly get it close right that's
enough about that let's actually start
talking about darn it caught on outside
of Windows then okay so the first thing
you need to do is get dotnet core
actually installed you can get it from
from this URL which is clearly you are
our URL which is designed to be written
down and not set out loud really www it
is too much although to be fair it is
just shorten to.net which is clearly
better and once you go that and then
it's time to create a project so what
we're going to do now is going to switch
to the command line and obviously
everything is very much command line
driven you're all familiar with that if
you're not working on windows and the
first thing we need to do is is run the
dotnet command line tools and we can do
net new and we've now got a simple
sample application built in a in a file
here so now the dot nips tools it works
kind of like get where you've got a
driver application net and you've got a
bunch of subcommands and those sub
commands will do interesting stuff for
you got new you've got restore which
will do things like something like new
get restore and build publish run tests
and so on we'll have a look at some of
these as we go through okay so we've got
various files we'll have a quick look at
those programs es it's a simple hello
world application the interesting thing
to point out is that we've got a static
void main here so this is going to be a
console application and the other thing
to look at is project Jason this is our
file formats and this is kind of fairly
simple and there's not much going on
here we've got a version number of the
thing we're going to build and then the
other two
elements we've got our frameworks and
dependencies the frameworks tells us
what framework we are targeting and here
we're saying I'm targeting net corps app
one point oh this line here the import
is a bit of a backwards compatibility
thing it's saying that I'm going to
build a net corps app one point oh but I
can also consume DNX call 50 stuff this
is kind of one of the names that got
used in nuget packages as dotnet call
was evolving and we're saying that until
everything has kind of been updated and
moved on I can still consume DNX call 50
libraries the other dependency we've got
is on a package called microsoft net
cord app so all the items in the
dependencies list here are packages
they're nuget packages we can just
consume those this one is the standard
package for net core applications and we
get to specify the version rc2 version
we've also got a type of platform I'll
come back to that later so the next
thing we need to do is not net restore
this is a new get restore and it will go
off a little download absolutely
everything it'll download the microsoft
net corps app package and all of its
dependencies and fortunately i've done
this earlier and it's all locally cached
because there is a lot of them so that
the all the packages are the napkins
belt all the packages are cached locally
and sort of globally per user and so
you've got a nice easy way of pulling
and re restoring without necessarily
having all the pain of having to
download everything all the time and
there's a whole bunch of different
packages going on in there so we can see
there's a some Microsoft ones we've also
got the system type ones there these are
the nicely factored base class library
and we've also got the runtimes as well
so the the actual CLR itself is pulled
down as nuget packages
and once you've got a once we've
restored and we've got our nuget
packages all downloaded we end up with a
project like JSON file which is a
massive JSON file which we don't need to
worry about the contents of but
basically it's it lists all of our
transitive dependencies from our
packages so rather than having to walk
all the packages again every time it
needs that information it can just pull
it straight from the the lock JSON file
okay next we can do darnet build this
will compile the app for us and once
we're done we've got AB in an object
folder we've got a debug folder under
neath bin and we also got net core at
one point 0 underneath that we can
target multiple frameworks and so
everything is is handled it is this put
under director into that and in that
folder we got several files got a couple
of Jason files which are all about the
runtime information but the important
one there is we've got simple dll and a
PDB file for debugging as well now
interestingly we have a dll file even
though it's an executable this is
because even if it was a dot exe we
wouldn't be able to run it because I'm
on a Mac you can't run the Exies on that
so to write we've got two two options
really we can do dot net run and that
will sort of run the project it'll make
sure everything is compiled and
up-to-date and it'll run it or we can
get to the dll itself and we can do
dotnet simple dot DL and it'll just load
that DLL and execute it and run it okay
so that's running a very simple project
now that's good but that's not
particularly that much fun so it is not
that interesting so we could really kind
of create something a bit more
interesting and so how do we create an
asp.net core application we don't have
visual studio so we can use Visual
Studio templates dotnet new has a type
parameter to it and so it looks like you
could perhaps put in something
interesting here and generate something
with a bit more a bit more fun going on
there but it's only implemented for
console so you can do net new type
equals console that's all you've got
there are a couple of nuget packages
which can extend the.net command-line
tooling
there is one full web cogeneration but
it doesn't seem to do anything yet it's
not documented yet so maybe this is how
it'll work in the future I don't know
there are existing packages which extend
this for entity framework and publishing
2i is so the this could clearly be the
way to do it so what we'd do instead is
use yeoman yeoman is a node-based
scaffolding app which is extensible and
it's for for building for creating web
applications to to start with really the
Omni sharp team have created a generator
for asp.net core and we can use the
assented so to get ourselves started
well the steps here to actually get it
started need node install you need
yeoman installed you need Bower install
Bauer is a front-end package management
for CSS and JavaScript files and then
you need the generator installed and
they need to run yeoman with yo asp net
which is clearly i am too old to say and
get away with any kind of cool thing
though but it's easy to run we will do
yo s peanuts and now we get a choice of
options of things we can build here so
we can build an empty web application
this is probably the one you'd pick to
to get started here because it would
just give you the framework to get going
kind of a console app there are a couple
of demo web applications which are going
to be useful you can do like a Web API
application Nancy class library and a
unit test application as well so we'll
just create a simple web application and
we will just use the default values
there just to sort of get us up and
going so it creates a bunch of files for
us then it runs an NPM install and Bower
install to make sure we've got all of
our client side JavaScript type files
and we're done and if we go into web
application basic we've got a lot more
files here so if this is a much more
interesting project to get started with
if we have a look at the project Jason
let's just get to the top of the file
you can see that there's a bit more
going on here the dependencies is a bit
bigger we've got more things going on
we've got a microsoft net corps app here
again so we're still a dotnet core
application but we've got extra things
on top of that we've got asp net core
packages and various 610
missions as well we've also got a new
element here for tools which means that
we can extend the.net to link with with
various packages as well so if we go to
dotnet now we can do dotnet razor
tooling and that gives us command-line
tooling to work with razor files there
other sort of interesting things we've
gone here we can specify runtime options
to use the server version of the garbage
collector rather than the the sort of
desktop version and we can run some
scripts when we're publishing as well
okay so we need to do dotnet restore
again and again this will sort of
trundle through I've got everything
cached locally so it's all nice and
quick it's created our lock file so that
we've got something to build against and
we can do darknet build and it'll go off
and compile its and then we can do not
net run again and now we say that we're
running on localhost 5000 well clear the
screen around that let's just open a web
browser and as that loads up we're
hitting the viewer compile interviews
and in fact if we go back to that we can
see that there's logging going on on the
screen as we sort of click around and
move everything and so there so we can
run a dotnet an asp.net core application
on on the mac so let's have a look at
the code and that's probably a good time
to switch over and have a look at
editors what tools can we use when we're
not on Windows to edit and work with our
projects and applications and everything
so I'd like to introduce you to pimp so
this handy chart here's something up
just kidding so we've got several
different options we can do vim is
clearly a very capable register and we
won't go into that we've got several
options here we've got a couple of IDEs
that we can use a couple of editors we
can use as well job range rider dotnet
IDE which
using rashard from the back end that can
run cross-platform it's good xamarin
studio has recently just got a plug-in
which allows it to open rc2 applications
as well and so you can use that as an
ide to work with with your code and then
as Visual Studio code and at'em as rich
text editors which with the Omni sharp
plugin gives you editing for code
completion for C sharp and various
projects with that okay so let's just
have a look at that so let's have a
quick look we'll start with looking at
things in rider so right it gives you
the sort of ID things that we've got
here so if you want to do template so
you can have templates here to create
new projects and everything we can have
something which increase your adonit
cool class library or a desktop style
class library and so on so we can get
our features from you know the templates
that we'd like from that we're familiar
with with visual studio or we can just
sort of open an existing application
will open our web application basic here
I cheated a little bit there I've run a
little script here the Ides both rider
and xamarin studio they don't really
work with the project Jason as a file
format they still require the same thing
that visual studio requires which is a
solution file and a dot X proj file and
so I've just cheated and created the the
X proj file there ok let's just close
those windows so you know we've got an
ID all the kind of things we'd expect
from an IDE we can see our references we
can see that our packages and we can
sort of drill down into them and see
then what the dependencies are and then
what they resolve to with with various
assemblies and so on we can navigate to
the program and now we can see actually
looking at the code that this is all a
bit different to what we'd expect from a
web application so for example the big
difference here really is a republic
ation but we've have a public static
void main so we are still a console
application even though we're a web app
what we do is we create a web host
builder and basically we set up a bunch
of configuration for hosting a web app
and then we run it there's the sort of
thing there's a couple of interesting
things we do use kestrel by default
we've got to sort of use it is
integration even though we're not on on
Windows and it variously starts
everything up okay so well we're in the
editor here we've got all the sort of
usual kinds of things we can do sort of
I'll tend to clean things up navigate
around let's go to a HTML file and we
got all the usual kind of editor
features where are we things like code
completion we can do things like Co
completion with the tag helpers so
asp.net core includes the idea of a tag
helper which is a HTML tag which runs
server side which runs as part of the
CSS HTML processing and while it can
look like a real tag at least got some
additional processing on the top so for
example we can have a link to an ASP
action here and then we can sort of
provide those as code completion and
sort of navigate around and move around
to all those kinds of things there and
we can do a similar sort of thing in
code so I've got visual studio code here
this works in a different way it doesn't
work with project files and solution
files and works with folders that's what
we can do here is open a folder and
there's my web application basic if I
open this up code sort of restarts and
it takes a moment and then it notices
that actually I can work with this as a
project as a folder and actually if you
want to create some files and it creates
this vs code file with some config in
there which helps and again we get sort
of similar sort of functionality that we
are used to with an ID we got you know
tool tips and auto completion let's just
put this in
because I'll need this later so if we
hover over everything we're good there
we can we got navigation we've got
squigglies and we can sort of fix that
we can have a remove unnecessary usings
and so on so we've got ways of editing
and doing rich editing and ide type
functionality then on different
different platforms let's just go here
we can also set breakpoints we could do
debugging as well so we can switch
switch the debug window we can put a
breakpoint in our code we just press go
it'll make sure everything's up to date
and it won't be because I've just
changed it change things it'll rebuild
it and then it'll run and start
debugging okay so let's just start the
browser again and it'll just hit the the
first hit the first view it'll compile
everything and I put a breakpoint in
about so if we click about now bang
we've hit our break points and we've got
variables on the side here we can some
drill into that and we can see the the
values that are set there we can
highlight and right click evaluates and
it's down in the debug console down here
we can also set data
and if we sort of run and carry on then
it comes through and everything so we
can do debugging as well as we got
editing we got projects we've got
debugging we got refactoring we can do
all this kind of thing without having to
use visual studio okay so what's next
testing testing have to switch straight
back to the console we can use AOSP net
again for this one and we can create a
unit test project again I'll just take
the defaults and we'll do a quick
restore we've got so X units is the
default sort of all it was the kind of
de facto standard for running tests in
in.net core it's basically the first
frameworks I've got ported over there
are also frameworks to support ms tests
and in unit i believe has a framework
think is any unit light that they use
and you can use whichever one you want
there and if we have a quick look at the
project Jason here we'll see that this
is handled nice and easily by taking
under dependency on nest dotnet test X
units this is adding the test runner
into the tooling and we've got X units
which is our dependency for actually
using the X unit API we've also saying
that the test runner is X unison that
sort of enables it within the tooling so
we can do dotnet run and we can see that
it will immediately fall over because
we're not a console application if we
have a look at the code we can see this
is just a class so we're just building a
class library here we're not building a
console app like we did with our simple
demone with the web application so we've
got a simple test here we've got to test
one passes one fails and to run those we
just run usenet test that will make sure
everything is compiled and up to date
and it'll run it we can see that X units
does discovery and then it actually runs
the tests it prints out anything that
fails and then we get a nice little sort
of summary at the end there
so we can do testing as well so we can
do we can create project we can edit it
we can do refactoring and building and
debugging we can test it the next thing
we want to do is hosting and hosting so
how does this work in the in the world
where you don't have I is how do we do
testing sorry hosting and everything is
a console app as well so if everything
is a console app how does it kind of how
does this all work well we could have
seen it with the web application basic
there it's a console app we configure
everything all up and then we run it and
this basically means that we are
self-hosting we have an in-process web
server and this is kestrel there was a
great talk yesterday Damion Edwards and
David Fowler talking about the internals
of Kestrel they've done crazy things to
optimize it it is very very fast it's
all based on Libya V like no DS and it's
all sort of very much sort of async
await and efficient and they've reduced
all the allocations they possibly can
and it is just fast so there's a great
stat two thousand three hundred percent
more requests and an equivalent
benchmark on asp.net 4.6 that's pretty
fast so that'll be good but don't expose
it to the internets the the the
recommendation here is that you do not
have this exposed to the internet it's
while they have they made as secure as
they can it's not battle-tested it's not
battle-hardened or anything it's not
designed to be exposed to the internet
also yourself hosting so it's is a
different thing so what do we do now we
kind of we want to deploy it we want to
to get it up and running to be able to
host it properly we need to do packaging
and this is dotnet publish as we're back
to the command line again let's go back
to our simple hello world application
and will package this up ready to go
it's all nice and easy we just do dotnet
publish that will compile it and make
sure everything's good and if we go into
the bin debug net core at one point o
publish folder we're going to see these
are all the files that we need to deploy
and here it looks just like what we had
before just in the debug folder there's
our simple dll the PDB file and a couple
of runtime JSON files in fact if we
let's just let's just go into that
folder we can just do darknets simple
dot DL and run it and it's fine now one
of the premises of dark net court was
that you could do application local
installs of the.net framework and
clearly here there are no dependencies
going on here the.net framework isn't
being packaged up as part of all of this
so what we've created here is what
Microsoft are calling a portable
application this means it is portable to
anywhere that already has dotnet core
installed so it can be reused anywhere
you can dotnet core can run it and to
resolve everything and work with it and
the thing which works which drives this
is this the type equals platform
property of the dependency here so what
we're telling what we're doing here is
we're saying that the microsoft net
corps app dependency is a platform
dependency it's already there it's
installed and handled by the platform
and when dotnet publishes packaging
everything up it sees this and it knows
not to pull all of that in there we're
telling it that it's going to be on the
target platform when we get there we can
build a standalone application and a
standalone application will have all of
its dependencies in and we do that by
getting rid of the the type equals
platform now I'm just going to again
cheat and copy this in because there's
an extra bit you need to add which I
will fat finger if I'm going to do it
live so we've got rid of the the type
equals platform from myself net corps
app and then down the bottom we have to
add in a new a new element the runtimes
element because with the we're saying
we're going to run on a platform which
doesn't have dotnet installed there's no
smarts there to figure out what platform
the darknet actually supports here what
run time it is so we have to tell the
packaging dotnet publish what runtime
we're targeting so I'm going to run on
the wind on my back here so I want to
target the OS 10 runtime
and I've changed the project Jason so I
have to do another dotnet restore and if
I do not net publish now it should build
us a standalone application I'm going to
also add the minus C flag which means
i'm actually going to build in release
mode now and so we've got a release mode
application and if we have going to then
we've now got debug and release and i
can go into net corps app one point oh I
don't have the publish now I've got an
extra folder which is my OS 10 folder so
it's saying that this is now not only
framework specific but runtime specific
I don't now gotta publish folder under
that and if I list that I got a ton of
files and this is my full dependency set
now to do a full standalone application
and how to run this I can't use dot net
and the dll name but fortunately the
dotnet publish has given us an
executable here so I can just run simple
from the current directory and it'll do
my hello world and so we can package
everything we can package up as a stat
as a portable application or as a
standalone application right so let's
have a look at that how that works then
with sort of a web web application and
how that sort of fits together so we can
just do the same thing we could just do
don't know publish might see release and
that will go off and build the
application in release mode it'll run a
few more steps because we the project
Jason had some pre publish scripts which
would run some grunt and gulp tasks for
our our CSS and JavaScript and then
we're done so if we go to bin we've got
a debug and release again so we're going
to release and we can go to publish and
if we list at we've got a ton of files
but this project was set up to be a
portable app so it wasn't saying
including the net corps app stuff that
is still set to be a platform dependency
but we've still got a lot of files here
because these are the dependencies on
top of the platform so if
if we just have a quick look at the
project Jason have a look at my
dependencies here microsoft net corps
app is still a a platform dependency but
we've also got a whole bunch of other
dependencies on asp net core and various
extensions and so on these all need to
be distributed when we're packaging
things up as well and that's what these
extra files are in here and we've also
got then the main application this is
our program program static main and we
can run it by doing notes web
application basic dot dll nope because i
forgot to stop that and the port is in
use okay and we're listening on port
5000 again right so that's all good for
for packaging we can we can package our
application that we know now to how to
deploy it because we just need to
basically take all the files in that
folder and put it on another on a server
somewhere and run that if we're doing a
standalone app we can just run the
executable that dotnet package done it
publish creates if we're running a
portable application we need dotnet
installed on there already and we can
just do net run oh well net and the dll
name but that's no fun because we want
to use containers because everybody
wants to use containers so if you've not
used containers before the idea of this
is that it's a packaging format 444
create for for packaging up an
application and all of its dependencies
and running it in isolation the key
thing is that it's not a virtual machine
what it is is an isolated process group
that runs on a shared linux kernel so I
the idea is you've got a linux kernel at
the bottom here and then you can run a
container which kind of sits on top and
you can run multiple containers on the
same linux kernel and they are isolated
from each other so when you have one
kernel one container running it thinks
it's the only thing running on the under
linux kernel it thinks it owns that
kernel and the important thing to point
out is that
now containers are all about linux it is
a Linux technology Microsoft have got
windows containers coming in the next
version in fact I think they've got
hyper-v containers in the next in the
current preview builds of Windows 10 but
right now when we're talking about
containers we generally mean Linux
containers and this next bit I wish
they'd put this on the website to me
ages to kind of figure this one out but
if you are running a container on
Windows or Mac if you're trying to run
docker or any other kind of container on
Windows or Mac you need to have a
virtual machine which runs this Linux
container let's sorry this Linux kernel
it's all about linux is what we're doing
here and what you need them to put
things into a container is that you need
to create an image to running that okay
and that's all nice and easy so what we
want to do is have an image which
basically contains all of these files so
what we'll do is we'll grab a docker
file and pull it in if we have a look at
the daka file it's actually really quite
straightforward we've only got a few
steps here we're saying the first line
is a from command and we're saying I
want to build an image based on this
existing image an image is the
microsoft.net image which contain which
is packaged by Microsoft it's a version
of debian I think it is which has dotnet
already installed on it for us and so we
can build on top of this we have dotnet
installed and we can put our portable
app on there and run it so the next line
is to just copy the current directory
which is our portable app files and put
that into the / app folder we changed
our actually to / app we use the exposed
command to tell dr. that we're going to
be listening on port 5000 and then we
run the application we don't run nets
and the dll name itself so it's all nice
and easy there's only a few steps and
it's all straight forward and now what
we need to do is build let's call it
demo in the current folder and that will
build a new image based on the Microsoft
docker image that we've got so if we
list art for list our images now we can
see let's just pull that out of it we
have two images now I've got the
microsoft.net image which I'd downloaded
previously if it wasn't there already
doc a billboard of download
for me and then we have my demo image
which were just just created and now I
can run it and very importantly I need
to tell tell darker to expose poor 5,000
that I want to use poor 5,000 I'm going
to run it interactively so i can do
command ctrl c and finish it and there
it is it's running oh yeah i should
point out that i have don't start
Windows 10 that'll be bad there we go so
i have my doctor instance running i have
my linux virtual machine here that is my
shared kernel which is all the
containers are going to run in so that's
already running and let's just open up
the browser localhost 5000 and run it
and it fails and this is again because
we're running in a virtual machine our
linux kernel is running in a virtual
machine which has its own IP address and
which is separate to localhost so what i
need to do is I need to get the IP
address of my ducky so you can see that
so i can ask dr. what the IP address of
the shared linux kernel is and it'll
give me here and i can point the browser
at that let's just do that again and the
browser will now talk to the shared
linux kernel a port five thousand which
is then being forwarded to the container
and now we can actually display that so
now we are hosting our application and
running it in an a docker container but
we're doing that with kestrel with our
self hosted web server which we said
don't expose that to the Internet has
been battle-hardened you want to put
something in front of that and what we
want to do now is we want to put a
reverse proxy in front of it this is a
bit of kit which will actually be the
interface to the internet and it is
something which is designed to do this
job rather than cash flow which is sort
of designed to do self-hosting and be as
fast as possible so the idea of a
reverse proxy is you you're most likely
very much
already familiar with a forward proxy if
you've ever worked in a corporate
environment and you've had to configure
your browser to talk to a proxy to what
to get your web servers web pages then
that's a forward proxy your browser
knows about the proxy it talks to the
proxy and says go and get me google com
go and get me another site reverse proxy
kind of works the opposite direction the
client thinks it's talking to the end
server but the reverse proxy is then
talking internally to an actual another
server so it allows service to be
contacted by any client rather than any
client talking to us that's fine talking
to any server the easiest way to think
of this is as a load balancer a load
balancer is a a perfect example of
reverse proxy so we're going to sort of
step back out of this minute how would
this work in the iis world in the
windows world because we're all used to
how SP Nets apps are hosted in iis but
for this idea we've got executables and
reverse proxies everything how does this
work in iis and the answer is to use the
HTTP platform handler this actually
reverse proxy it does process management
so it would start up the executable
the.net dll and this is how it would
work for for things like Ruby
applications as well where they are run
essentially as a as an executable as an
outer process executable the the module
is responsible sort of forwarding the
request turn from these external
processes these child processes and it
kind of responsible for also telling the
child process where to listen to when we
run sort of Linux and everything there
are sort of several options here you've
got things like engine xha proxy HPD and
this is where you want to speak to your
certified devops engineer and not listen
to me and you get the best solution for
the job here these are reverse proxies
and load balancers H a proxy is a big
one used by github Stack Overflow
Twitter engine X is also huge and used
all over the world as web but it's also
provides extra functionality like web
servers and ATP caches and so on and
these are very easy to to do so I've got
hang on I can't see what I'm doing down
there right so I've got a config file
for H a proxy here and there's a bunch
of sort of defaults at the top the
interesting thing is down here and what
we need to do is we kind of listen on
port 5000 and then we can forward it on
to a server which I've called docker one
that's my IP address and port 5000 there
so I can just do hate a proxy which I've
got installed on my Mac and I can pass
in the config file if I swap back to the
browser and go to localhost forever it
refresh that I've now got my reverse
proxy in place so I'm talking to local
host which is my reverse proxy which
then forwards the call into my docker
container and if I had multiple
instances there I could use that as sort
of load balancing and sort of round
robin or whatever technique I want to to
to navigate around them ok so now we can
we've been able to create so that's
basically then we can create an
application we can edit it we can debug
it we can refactor it we can use IDs we
can use text editors we can package it
up we can publish it we can deploy it we
can put a reverse proxy in it we can
host it so we can do everything that we
need to do with an application outside
of Linux sorry outside of windows and on
on Linux so that just leaves me really
basically to say thanks and I'm just
glad I've managed to get to the end of a
net cool talk without anything changing
so it's a good so we've got a few
minutes if anyone has any questions
please shout outs if not come and grab
me later and thing that thank you very
much
yes question while running in dr. you
can't do bug you can do debugging but
you have to do a couple of steps to
actually get that working I'm not gonna
be able to show you with the time we've
got but yes you can do remote debugging
as well
hello</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>