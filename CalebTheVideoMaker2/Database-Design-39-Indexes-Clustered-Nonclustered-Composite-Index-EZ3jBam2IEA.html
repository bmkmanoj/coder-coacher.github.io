<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Database Design 39 - Indexes (Clustered, Nonclustered, Composite Index) | Coder Coacher - Coaching Coders</title><meta content="Database Design 39 - Indexes (Clustered, Nonclustered, Composite Index) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CalebTheVideoMaker2/">CalebTheVideoMaker2</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Database Design 39 - Indexes (Clustered, Nonclustered, Composite Index)</b></h2><h5 class="post__date">2015-01-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EZ3jBam2IEA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey yo what's up everybody this video we
will be discussing indexes the best way
to think about it is just to take a book
look in the back there's often an index
here which basically has a huge list of
topics and it says what pages are on so
you be like oh uh
that looks fun queries go to page 2078
Wow
it's right there I found that so fast I
don't have to go search through the
entire book to find it that's an example
of an index it's basically a list of
where certain data points are another
kind of indexes you can think of a phone
book you go to a phone book and you
search it through the phone book you
find someone's name gee we go to Grandma
and it'll have the phone number right
there that's another type of index it's
where the data is sorted in a way that
you can easily find it and the data is
right there versus an index in the back
where it's a list of data pointing to
where it's at the one we first discussed
is known as a non-clustered index what
that means is that the data is not
actually where the index is the index is
a separate thing and it basically just
sorts the data and it's basically a
point that tells you how to get to the
data so the way it works in a book is
you find the topic and it'll tell you
where to go 365 for example go to page
365 that's a non-clustered index a
clustered index is like the phone book
where it actually reorganizes the actual
data in a way that's easy to use
non-clustered points to the data
clustered organizes the actual data so
we can have multiple non-clustered
indexes that's because a non-clustered
index is basically just a list of
references that point you to the data so
we could organize it in different ways
but as for the clustered index we can
only have one of those that's because it
actually organizes the data that way so
think of a phone book it's organized
a-to-z or
ever you go through there and you find
it that's a clustered index it organizes
the data well what if I wanted to put
the data in by the phone number so the
smallest phone number like zero zero
zero zero zero zero one which would be
an awful way to organize a phone book at
the beginning and then nine nine nine
nine nine nine nine nine nine at the end
that's an awful way to design a phone
book like I just said but that is
another example of a clustered index
that's because it actually reorganizes
the data that's why you can only have
one of those because a phone book can't
be listed a-to-z and also by the size of
the phone number see what I mean it's
conflicting you can't have both at the
same time you can only have okay you can
only have okay this is sorted by name or
oh this is sorted by phone number you
can't have both now you could make the
phone number size or whatever as a
non-clustered index where it would be
like this to have the actual phone
numbers in the back and it would point
to where it's located so at the
beginning of the index it would be like
okay the phone number that's zero zero
zero zero zero zero zero zero zero one
would be on page 743 the phone number
with zero zero zero zero zero zero zero
zero zero two is on page 242 you see
that the actual data isn't organized by
the the the phone numbers but you can
use that non cluster to index that sorts
it that way and has a reference to the
actual data where it's located now you
guys are probably sick and tired of me
rambling about this so let me just
explain how this makes sense in
databases well when we're working we're
working with a database often we will
use a certain column for certain things
and that column will be used frequently
and we want that to be like super fast
so we want the database to know how to
use it the best way so we create an
index the database understands
index so that way when you tell it to do
something it can do it faster rather
than it having to go through all of the
data which is called a table scan when
you're working with a database with
millions of rows that can take forever
if you have an index it will use an
index seek which you'll basically know
where to start searching for that data
that's awesome because it makes our
queries tons faster and saves a lot of
resources there's downsides to it though
because when you create an index not
only does the actual table have to
update whenever you update it but you
also have to update the indexes think of
like a book when you add something to
this book or you change something within
this book not only does the actual book
content in the beginning of the book
change but also when you flip to the
back the index must also be updated
otherwise all this index information is
going to be out-of-date and useless so
that's a downside to indexes is when you
update your information it might take a
little longer in a database query we
might say something like select the
first name last name and the phone
number and the email of the user with
the user ID of 72 for example well I
kind of said that in English but when
you're actually working with a database
it might be more like select first name
last name email phone number where user
ID equals 72 that would be an example of
a database query now that where Clause
is using the primary key so basically
the database is going to go through the
table find the person with the user ID
of 72 and then display their first name
last name phone number and email well
that where is using a column that has an
index the primary key is usually the one
that's going to have the clustered index
so that's the way I actually sorts the
data so now it doesn't have to go
through the entire entire entire entire
table to find the person with the ID
of 72 because imagine if if it was just
random data thrown in there with no
organization you have two billion rows
right and the database has to go through
and find the one individual row with the
user ID of 70 to go to the first one
nope not 72 second one nope not 70 do
their own
nope not 72 and keep going on gone on to
finally found the person with the user
ID of 72 basically that would take
forever with a clustered index it knows
well 72 is going to be in this part of
the database it comes after 60 and comes
before 80 because that's the way it's
sorted so it's gonna be like boom got
done that is how indexes kind of work so
clustered indexes are going to be faster
and better but you can only have one
that's usually the primary key but it
doesn't always have to be depending on
the database and what your goal for the
databases the non-clustered indexes
which are like the index in a back of a
book those are still good and they are
recommended if you're doing something
where you're like where first-name
equals John now it has a list of all the
John's and where they're located on the
database or on the table I guess that's
also a good thing but you don't want to
have an index on something you're not
going to be using a lot because you'll
just have to have another thing updated
another thing you don't often want to do
where clauses which is like where first
name is Caleb without that column that
you're searching being a indexed column
because it can take forever
another reason for indexes is to
increase the speed of joins so the way
the join works is it takes data from one
table and another table and combines it
together by the primary key and foreign
key connection so think of a user's
users in Commons so a user posts the
comment so you have a user table and you
would have a comment table and let's
just draw rows in here so we have this
guy I'm just going to draw pictures
because it's funner so we have 3p
over here we have four comments on a
website or review or it doesn't really
matter well this one comment is posted
by one person and one person can post
multiple comments it's a one-to-many
relationship well when we want to output
this to where we can review the data we
want to use a join so it's not across
multiple tables because if you're
thinking like this comment was posted by
the user with the user ID of 72 you're
not going to know who that is right off
the top of your head because that's a
foreign key connection so rather you
want to replace that 72 with the actual
name of that person or the user name
that's a join and it's all done after
the database is created it's all for the
query side so basically this is what is
defined in our database and we want to
output with a join a new table that
looks more pretty and easier to read
when we do this we're going to do
something that says the user ID of this
call of the user idea of this table is
the same as the user ID in this table so
if they use if a comment has the user ID
of 72 we know that it's done by the user
with the user ID of 72 that's a foreign
key connection with which we've talked
about like some tire series so now I'm
going to explain that anymore but now
down here in this table it's going to
say Caleb curry then it'll put the
comment and I'll join that well this is
also done with a where clause in some
cases for different databases all the
terms might be a little different but
basically that column that you're
connecting by which in this case would
be the primary key needs to be indexed
to make it faster so whenever you're
joining a certain column the two tables
the column you're joining should be
indexed you can also have something
that's known as a composite index which
is an index that is an index on two or
more columns so think of like a first
name and a last name or last name first
name now the thing about these is when
you
you use the indexes so let's say you
select where first-name equals this and
lastname equals that you have to do them
both or it's not going to use that index
now there are exceptions to this think
for MySQL actually if you order them in
a certain way like like this if you put
an index on the last name and then also
the first name you can you can do a
where clause for both the last name and
first name so finding everybody with the
last name Curie in the first name Caleb
would be really fast but the way this is
set up you can also do the leftmost one
too so you can say I find the person
with the last name curry that's going to
work but in this case you couldn't do it
with the first name because it's not on
the left so that's just the way my sq
hasn't set up so different database
systems might have it set up differently
where you can't search with them
individually or you can but most likely
when you make a composite index you
should expect to always use that index
by itself unless you have it set up to
where you make a pretty awesome index
that can be optimized to do multiple
different queries that you need to do
like if I'm going to make a ton of
queries where I put the last name as the
where and then I'm going to make a ton
of queries where I put last name and
first name for the where this would be a
good way to set that up because I'm
making one index index for last name
first name that can also be used for
just last name so yeah that's the basic
introduction do indexes yeah I'm not
going to be giving you tons of syntax
actually making them because like you
should know by now this is a database
design course we're just trying to learn
how to design our indexes on our tables
so that or database works good so that's
something you may have to learn more
once you actually program a database
because you can test the speed of the
actual indexes to see this for speed
optimization to make the database as
fast as possible you can't really do
that if you're only designing a database
you can only get so far when designing
indexes
with the database but you can get pretty
far because I mean obviously you'll
likely be using the primary key for
where clauses and joins so that's
something that's good do have it
clustered index on so yeah that's about
all guys thank you for watching and be
sure to subscribe I'll catch you in the
next video</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>