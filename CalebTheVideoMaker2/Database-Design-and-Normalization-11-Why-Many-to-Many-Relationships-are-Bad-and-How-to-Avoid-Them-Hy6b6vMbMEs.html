<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Database Design and Normalization 11 - Why Many to Many Relationships are Bad and How to Avoid Them! | Coder Coacher - Coaching Coders</title><meta content="Database Design and Normalization 11 - Why Many to Many Relationships are Bad and How to Avoid Them! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CalebTheVideoMaker2/">CalebTheVideoMaker2</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Database Design and Normalization 11 - Why Many to Many Relationships are Bad and How to Avoid Them!</b></h2><h5 class="post__date">2012-08-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Hy6b6vMbMEs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay we have a table of books out on the
table for authors okay now we have a
book called physics master in physics
master in physics could have been
written by let's say Jim and Joe Jim
could have wrote mastering physics so
good Joe
cuz they could have worked together it
made a team work and split the income
block of all that stuff now we have
another book over here mastering biology
yeah that's it
biology so Jim could have written two
books I mean an author isn't limited to
only writing one book in their lifetime
that would be ridiculous so Jim can
write more than one book and a book can
be written by more than one person that
is a many-to-many think of it like this
mastering books could have gone to Jim
or Joe these guys could have worked
together to both both of them so that is
many to many because Jim could also work
on mastering biology by himself it's
many to many the thing about many to
many relationships is you want to avoid
them when designing a database because
many to many relationships can make a
ton of redundant useless confusing
information okay guys here as you can
see we have a table
and it lists movies and their actors a
studio separate columns now here this is
a many-to-many relationship I hope you
can see everything clear I'll try not to
make a go out of focus now there's a
huge problem with this so let's say
there's 10 movies and 10 after 's I
can't fit all that on here but let's
just say now each movie has these 10
actors let's say they all got work
together made 10 movies the problem with
this is movie one goes to movie all the
way to the 10 movies that makes 10
results movie two does the same thing so
when you spread all this out across
multiple rows it won't it's it's as bad
movie 3 does the same thing and all the
way down to 10 that's like 100 results
now you're probably thinking like what's
that I mean okay that's not so bad but
if you have 100 movies I mean it gets
pretty big now the other thing is you
have to list all the movies that actor 1
was in let's say actor one because actor
1 is in all of these movies too so actor
1 that movie one actor one movie 2 3 4 5
6 7 8 9 and 10 and after about like 3
results it's already a huge mince so
there's this this isn't proper just
don't do it there's better ways to do
this
um okay best way to do this is to
separate it into two separate tables
over on the left and then in the right
so now we have a table for the movies
and then a table for the actors now here
is another table
okay so sorry
movies afters and what you got here this
is called intermediary I think that's
the word intermediary table so here's
another term to learn inter
now what this is is it will combined
these many-to-many into two separate 1/2
minis that makes any sense
thank God movie one movie two and it
references it has the ID so the ID of it
so reference is the movies over here and
the actors over here combines them so
movie one movie one after one actor - so
now you're actors and movies tables are
organized you can actually read them you
don't have them together on one table
movies and actors because then it's a
mess you want to look at all the movies
there is there are and there's like six
thousand columns with the same movie now
all of this is organized you say you
want to see all the actors in movie one
you just do a query for like all the
actors where in this table where movie
ID is equal to the idea over heat /
sorry all the actors where movie ID is
equal to the movie ID over here and that
is how you connect it so then it would
come up with the ten actors and list
them for one movie this will be a
foreign key and this will be a foreign
key so now you have two keys and you
combine these together to make a primary
key because this should never ever
change oh that can't see much so
basically you have two foreign keys and
it's makes more room you have a foreign
key
and then another foreign key this would
be movie and movie ID and actor ID
combine these together and this becomes
the new primary key because it should
never change I mean actor one is never
going you can't go back and change an
actor in a movie it'll always be that
actor no matter what so then now instead
of you have these as primary keys
referencing to these foreign keys over
here I mean to these primary keys over
here say the primary key of actor ID and
then the primary key of movie ID which
goes here and here creating a extremely
organized intermediary intermediary to
the table and that is how you properly
make a many-to-many relationship in a
database</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>