<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>SQL Server 15 - Composite Key | Coder Coacher - Coaching Coders</title><meta content="SQL Server 15 - Composite Key - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CalebTheVideoMaker2/">CalebTheVideoMaker2</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>SQL Server 15 - Composite Key</b></h2><h5 class="post__date">2016-12-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KwdEs3fhNbs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome back everyone to Cael the video
maker - this video is going to continue
our discussion of primary keys inside of
sequel server the first thing we're
going to talk about is something known
as composite keys then we'll go into
indexes related to primary keys but
first let's just start with the
composite keys and get through that
first now what is a composite key a
composite key is a key or a primary key
that consists of multiple columns so
more than one column doesn't have to be
two it can actually be more than that so
you could have a primary key consisting
of ten columns if you wanted I think I
don't think there's a limit but you guys
can try and let me know if there is what
would you want to do this though you
would need to do this if one column is
not enough to make an entire row unique
let's go through a little example that
shows this in action we have a table so
we'll go with the bare minimum number of
columns just to keep it simple but you
could have much more data in here if you
really wanted to but to start off we'll
name this class students and over here
we'll have the class ID and the student
ID now for a specific class let's say
the class with the idea of seven it has
the student with the ID of 3084 could we
use either of these columns to uniquely
identify every single row well as we
have it now no we couldn't
that's because multiple students can
take a class so we could have seven and
then 300 3072
now the class ID is repeating so we
couldn't use the class ID to uniquely
identify each row that's because there's
repeating values so if I said oh grab
the one with the ID of seven you
wouldn't know which road to grab so what
about the student ID let's think about
the same thing can a student take
multiple classes yes so that means we
might have this student again 308 4 but
this time taking a different class now
we have repeating student IDs so if I
said grab the row with the student ID of
3084 you wouldn't know which road to
grab so the student ID also will not
qualify as the primary
a key in this situation a composite key
is actually a really good thing we could
use essentially we're going to combine
these two columns as the primary key now
these are actually going to be foreign
keys pointing to different tables so
we'll probably have a class table and a
student table and when we have two keys
inside of a composite key it's actually
known as a compound key but often people
use the terms composite compound
interchangeably so don't worry about it
too much
but I decided let you guys know that if
we made both of these IDs a composite
key the combination would have to be
unique so seven and 3084 could only be
in there one time so then I could tell
you hey grab me the row with the class
ID of seven and the student ID of 3084
and you would know it's always going to
talk about this row that's because we're
not allowed to have repeating data this
would not work now you might also be
asking is it really necessary to use a
composite key couldn't we just have
another column right here and make it
something like class student's ID and
then every single row would have a new
ID so we'd have one two three and then
you wouldn't need to say - you could
just say one mmm grab me the row with
the class student ID of two and you
would know it's always talking about
this row well actually that does work
some people actually prefer that in this
situation you want to be using a
composite key you would just be using a
single primary key and it would work
just fine on the downside though this
introduces some problems because now we
have to worry about repeating data for
example seven and 3084 so you might
still have to make the combination
unique and if you're going to do that
you might as well just use it as the
composite key for that table but even so
some people still like to be able to
refer to a row using only one primary
key call not a combination so that
decisions ultimately up to you I'm going
to try to go with this route using
two columns but if I need to I will just
go down to one call on this app if I
feel like that's relevant for the
situation also keep in mind you don't
have to limit yourself to just two
columns you could have three columns so
for example if the class ID and the
student ID is not enough to keep each
row unique you can add a column you
could say semester because you know
potentially a student could retake a
class that might not be the perfect
example for this situation
but you guys get the point if you can't
make the data unique using only one or
two columns add enough columns until it
is unique but you always want to get the
minimum amount of columns so if you can
use two columns to make these unique why
would you add a third column to be part
of the key when it's not needed always
have the smallest key is necessary
except for the situation which I
discussed we can use two keys here
instead of one just because it makes
more sense rather than having this extra
column when you're looking at your
tables you might have to go through and
look at all the different combinations
of columns that could make a key and
these are going to be known as candidate
keys then you have to go through this
list of candidate keys and pick which
one's going to be the most appropriate
for your primary key sometimes it's not
necessary to actually list all the
candidate keys and you can just know hey
this one's going to work as the primary
key but if you're working in an
organization or in school they might
make you list the candidate keys and
pick which one would be best for the
primary key candidate keys also come up
when you're talking about database
normalization which is a topic we're
going to discuss in upcoming videos but
a lot of the normal forms of
normalization talk about candidate keys
and not just your individual primary key
you might also be able to guess if
you're using natural keys things can get
a little bit more complicated because
you don't just have individual IDs to
identify rows so you might have to
combine a bunch of columns to make
something unique which can make
normalization a bit more challenging in
my opinion let me know what you guys
think if you prefer primary Keys as
surrogate or natural Keys thanks for
watching
oh wait ah indexes when you make a
column
primarykey that column is automatically
indexed now an index allows your
database to work with that data much
faster and there's two kinds of indexes
or two classifications clustered and
non-clustered I won't discuss all the
details of this in another video
dedicated to indexes but since this
video is about primary Keys I thought it
would be relevant to say that primary
keys are automatically clustered indexes
and what that means is that the data in
the table is actually organized by the
primary key unique columns these are
actually automatically non-clustered
which that's basically just lists all
the data in order but then makes a
reference to that data and as a side
note identity columns those are not
automatically indexed unless obviously
it's on a primary key in that situation
is going to be part of an index but if
you make another column the identity
it's not going to be indexed just
thought I'd throw that out there if you
guys were wondering which you probably
weren't okay yeah that's all I got to
say I'm a primary keys hopefully that
was helpful for you guys if you like
this video please click like be sure to
subscribe if you want to support this
channel and as always stay chill see you
guys in the next video peace</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>