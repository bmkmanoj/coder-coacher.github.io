<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • The Many Meanings of Event-Driven Architecture • Martin Fowler | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • The Many Meanings of Event-Driven Architecture • Martin Fowler - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • The Many Meanings of Event-Driven Architecture • Martin Fowler</b></h2><h5 class="post__date">2017-05-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/STKCRSUsyP0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">almost my entire career I've heard
people talking about event-driven
architectures and event-driven systems
and things of that kind and it's always
been a little bit harder still what
bacteria do people mean by that because
when I dig a bit further it seems that
there are various different things going
on there is some kind of common theme
events are or something called an event
is an important part of what's going on
but actually what it boils down to in
terms of something more meaningful
that's much more open-ended and for a
long time that's just been kicking
around in the background and I have that
various points in my career sort of
thought I want to really dig further
into this and I kind of never really got
round to it because I'd dig into other
things instead but it really kind of
came to a head late last year I thought
works we've been doing quite a lot of
event-driven stuff and various people
came to roughly the same conclusion as
me saying we've been doing all of this
stuff called event-driven we're not
really quite sure it's the same and
we're doing it as all these different
project teams around the world because
there's a several thousand people now at
four works and lots of different
projects we need to get together and
learn from each other so we organized a
workshop in Denver it was yes Denver
late last year and a whole bunch of
people got together and very quickly it
became apparent that yes there were some
very distinctly different things going
in under the title of event-driven and
we need to try and figure that out a
little bit better and as a result of
that I think we came to a bit of an
understanding of some common patterns
that help provide a bit more precision
to what we're talking about
and so we thought that's important that
we describe this and say a bit more to
the rest of the world about some of our
thoughts and I hope really hard that
somebody else would write it up and
nobody ever did but one of us did a
little video thing just for an internal
video whatsit and I thought oh I can't
stand it anymore so I wrote a little
note stick it up on my website not
really expecting it to get much traffic
and I saw it got downloaded with a huge
amount of traffic so I thought well
actually this seems to be a common
problem and that's what led me to decide
to inflict this talk on you this morning
is because it seems to be that people
are concerned about this and what it
boiled down to is we identified four
different things I would call them
patterns that often come under the term
event-driven an event-driven system
might you when people say they have an
event-driven system they usually mean
they've got at least one of these
patterns in play and could mean they
have all four patterns in play and I
will go through them one at a time
gradually revealing what they are so the
begin the first one let's imagine some
example system that might be had by an
insurance company and in this insurance
system we have our customers and our
customers have a habit of moving around
and changing their address but the
insurance imagine it's something like
car insurance or house insurance we're
changing where your address actually
affects you insurance quote levels and
your premiums that you have to pay and
everything so if somebody changes their
address it's not just a case of updating
a new dress field you actually have to
trigger the insurance quoting systems
come up with a new quote and they then
gotta send you some mail to say here's
your new insurance agreement
whatever whatever I don't know the
details it's a long time since I spent
any time with insurance people but the
point is in a kind of simple
call-and-response kind of architecture
what that requires is whatever
system you've got looking after customer
management needs to tell your quoting
system
paying going to are equipped and the
problem of that is that creates a
dependency from the customer management
system into the insurance quoting system
it needs to know that it's there it
needs to know what API is it has etc etc
etc and that couples the knowledge of
what how insurance quoting works into
something that's a much more generic
customer management kind of feature and
that's a kind of coupling that a lot of
people don't really like very much so
one way we can get around this coupling
is we can say instead of doing that
let's try and reverse things around I
don't mind my insurance quoting system
knowing about my customers and that
there is a customer management system
there that seems a more natural
dependency line to follow because
something that's very very generic
managing customers generally that's the
kind of thing you want to depend on and
have it depend on lots of other things
and a way we can do this is we can use
an event so what happens is whenever the
customer some customer data changes the
customer management system emits an
event object to some well-known place
event queue or whatever and when the
insurance quoting system can listen for
that event and when the event occurs it
can decide do I want to do something
about it if so what do I do
and then that nicely we've gives us that
ability to reverse the dependences
allows the insurance quoting system now
and has to know about this event
structure but the customer management
system can be independent of all of this
and this is an approach but we in our
discussion whoops giving you a slide
away there in our discussion we referred
to is event notification we're using
events as our notification system
notification blah blah blah mechanism
between multiple systems now I've got
I've described that in terms of
large-scale systems independent
relatively independent systems for a big
company but we also use this same
pattern in a very small layer system
it's a classic of course approach of how
to manage interactions between graphical
user interfaces and the rest of your
code when somebody enters information
into a text box you don't want some very
generic text box widget to have to know
all about your code and which things to
call instead you said.you then the text
box will generate an event when you
change it and then your code listens to
the event it's the same idea and again
the same trick is you are reversing
dependencies and that's really I think
the essence of why you want to do this
is you want to do that reversal of
dependencies now I've talked about if in
terms of events and I've stressed this
dependency switch but it does but it
also does something else it bottles it
sort of takes everything to do with the
change but the event talks about and
bottles it into a thing an object a
record or something of the third that
you can refer to and pass around it
makes the change a kind of first-class
thing the magic now when we do when we
call a function that's just a very
transient thing we call the function
supply the arguments goes away we never
know that we've done it unless we've got
some logging and tracing going on but
when we do is something like this what
we're doing is we're actually making a
record of it and then we have a real
thing that we can talk about refer to
and pass around and that has its own
benefits it wins once we can do that so
we're actually getting a second benefit
here which is this bottling it up into a
into a thing into an object or I don't
have to hesitate about using objects it
doesn't have to be an object in our
sense I think of it as a just some kind
of first-class thingamajig that needs to
be a new technical term first-class
thing the magic god I don't even get a
giggle for that that's a shame
now that's not the only way of thinking
about these those class thingamajigs
often we think of them in terms of
commands as well and that leads to an
interesting question well when do we
have
convinced and when do we have commands
what's the difference between an event
in the command and I think it's actually
it is both very subtle not really
anything that you can say is a strict
definition and yet at the same time very
important because it's about our
language and our communication and how
we talk about our intentions about
things we could describe that situation
I just described as the customer
management system saying re-quote
insurance for this customer
that's the customer management system
saying it knows what ought to be done
and it's telling some remote system
here's what you should do when I phrase
it in terms of events I'm saying the
customers address changed I'm not
expecting any particular response from
that from anybody I'm just indicating a
change both can be have this kind of
bottling it up and making it as fast
thingamajig effect but the way the
communication patterns differ is in
strongly implied as different whether
you use event naming or command naming
style naming so really it boils down to
this is one of the two hard problems in
software right this is naming things and
therefore when you're thinking about the
difference between events and commands
it's really how do I want to describe
how the system works most accurately to
the people who are reading that the
system if I'm trying to say I don't
really care what happens as a result of
this event I don't want to care then yes
I want to use the word event if I on the
other hand I am particular about I want
something to happen then I want to name
it in terms of a command now I mean you
can get all the other way you could have
your insurance quoting system right it's
insist on sending the communication and
email to the to the customer and natural
way to do that of course will be a
command send an email but of course if
you go too far down the event route you
then get this effective passive
aggressive events right or passive
aggressive commands where you say the
customer needs to be sent a message
about their new quote
hint hint and you know you don't really
want to go down that path if you're
trying to read how the system works
that's going to be confusing when you
get those kinds of events occurring so
whether you use eventual commands under
the covers they're basically the same
thing they're often messages on cues
they look exactly the same the
difference is all about naming that that
difference is really important it's
let's face it names in software systems
are one of the most important things you
have to deal with so going back to our
system again one of the nice benefits of
using events is it allows many other
systems to hook up to the event stream
very easily we thereof having to tell
the customer management system what's
going on and this is a very nice
property and those result of using
events for notification here I need to
hook up a new system that takes
advantage of change needs to know about
customer changing their addresses I
don't have to go and talk to the
customer management team and get them to
add a new note of no call into their
interfaces and go to endless meetings of
the customer management group and two
months later maybe I will get them to do
something know I have they produced
their events I just tap onto the event
stream I'm cool this is a very
attractive ability and it'll easily
allows you to do all sorts of
interesting things without changing
what's going on but when anything sounds
like it's really nice there's always a
but isn't that and in the case of event
notification that but is now you're in a
situation where you've got no way you
can figure out what the hell's going on
in your system anymore because there's
no program to look at there's no
statement of says these are all the
things that happens when the customer
changes their address what you have to
do the only way you can figure out
what's going on if you actually have to
watch we address these various events
and see what happens
looking at the flow of messages through
your systems try and figure out what the
hell's going on and this is true in the
GUI case
if you ever tried to debug a heavily
event-driven GUI kind of system pretty
much your only chance is to bring it up
in the debugger and try and trace the
various events that are flowing around I
remember doing this once to try and
figure out how the original small talk
76 worked as I was writing some stuff
about model-view-controller and i
rapidly discovered you couldn't trust
any of the papers that have been written
on it because they often didn't have
access to the source code so i was able
to get hold of a copy of the original
MDC small talk 76 bring it up and i
could actually figure out how it worked
but i couldn't figure out how it worked
by looking at the code i had to step
through the debugger do things and see
what happened because again it was all
events and that's the dark side of using
event notification you get this great
decoupling you get this great
flexibility being able to add new
consumers and you get a bility to see
what's going on across the system as a
whole there's no code anymore that you
can just look at and it's a trade-off
like so many things trade-offs so that's
the first thing
event notification and and Alla probably
saves the most common thing that people
say when they're event-driven they're
using an event notification mechanism
somewhere which is kind of odd in a way
because just about every system i've
ever looked at users event notification
to some extent I guess when you call it
event-driven it means the event
notification system is seen by at least
the the senior people on the project as
a particularly important part of the
architecture so the second one is a
minor variation on this case so let's go
back to our little example of the
insurance company again in an event
notification system all you really need
to know is that the event occurred and
that could really be very very generic
it could just be saying hey something
changed somewhere you probably want to
give a little bit more information on
the event about that so you might say
that the
the event thing for Linda changed
something's changed about Linda's
account and then all the other systems
are who what what's happened the way
they find out what's happened is they
have to talk to the custom management
system and even if you've got more
precise about this you might say
Linda's address changed though still
typically the insurance quote system has
okay so what's the new one what was the
old one you know have this has it
changed in a way that's important to me
event notification often involves
additional traffic because the the
systems that are the consumer systems
still have to go back to the original
source to get more information and of
course we reduce that burden by putting
more information into the event if I
just say something about Linda changed
then every time you have to pile in on
and it's probably after time it's not
worth it does actually mean anything so
it was kind of a waste of time if I'm
saying here's the address change then
there's less traffic required because I
only need to go in if I care about an
address change and then I can take this
to the logical final conclusion and so
can I put so much data in the events
that I don't naturally need to go back
to the host system so not just so I say
Linda's address changed I say what her
old address was what her new address is
at that point maybe I don't have to go
back well maybe I do I know the address
changed I know I need to do something
but now I need to go back to all of
other attributes all the other things I
know about Linda I think a browser
history how often she stands up as every
day all of these things we know and we
can find out by asking the customer
management system but now I've got a
customer management system that's got
all of these queries every time
something happens every other system is
bombarding me with stuff can I reduce
that can I eliminate that load well I
could and this is a pattern that we
tentatively named event carried state
transfer which is a bit of a long-winded
name but I like it because it's a play
on rest right
which is resource whatsit state transfer
this is event carried state Tramp this
is about using events that carried
dancer of state what happens when you
use this pattern is you say I want to
completely forbid any contact to the
customer management system from
insurance clothing system which means
the insurance quoting system will keep a
copy of all the data that it's ever
going to need
now that means of course because I'm a
management system has to broadcast in
its events all the data that those
downstream systems are going to want to
have and the downstream systems have to
keep copies of everything that they are
going to use I don't have to keep a copy
of the entire customer record I only
have to copy the stuff that I care about
so it's not as bad as one might think
but it's still obviously a lot of
copying of data but the benefit is I now
no longer need to call the customer
management system at all I have all the
data at hand so that might improve my
performance because you know I no longer
got remote network calls so the customer
management system it reduces the load on
the customer management system because
it's not responding to all those calls
it also may improve availability because
if the customer management system goes
down or it's intolerably slow I don't
care
I'll keep chugging along cuz I have all
the data to myself so we can immediately
see with some very nice benefits to do
with that now it doesn't mean I have to
do all the necessary stuff to make sure
that I'm up to date I'll keep copies of
the data it means of course I have to
copy all the data but we're not talking
about that much data these days storage
use is cheap and what's more I have my
insurance quoting system my availability
no longer depends on the customer
management system so that's a good thing
now hopefully you're well enough versed
in software development that you know
when people say I have greater
availability because I'm not dependent
on something else you know what the
price is what's the price of high
availability lack of consistency exactly
so now I've got to replicate the data I
have eventual consistency
to deal with that issue so I've got a
consistency problem so again then carry
state transfer has this trade-off I get
even more decoupling even more
availability but I lose complexity of
keeping the duplicated data and
inevitable eventual consistency so this
is a less common pattern I don't know
what the proportions are a lot of a time
that I see event notification I don't
see the state transpose state transfer
but you and you do have to have event
note but event notification to do this
but it is a technique to bear in mind I
would say this is one that you keep
deeper down in your toolbox but it's
many circumstances it can be a good one
to play so sometimes that's what we see
when we talk about event-driven systems
this notification of duplicating the
data to avoid calling back so the third
item so far what I've been doing is I've
been telling you the concept and then
telling you its name because I kind of
think it's more exciting that way you're
kind of bit more because if you read the
talk beforehand you already know what
the four things are so I'm really quite
sure why I'm doing it but for this one
I'm going to tell you what it is right
away event sourcing which is a technique
that is long been one that fascinated me
and it's interesting to see how it's
being how people are using it but let's
begin by explaining what it is what do I
mean by then sourcing hey by the way how
many people have come across the term
event sourcing stands at the sound
curious okay
smattering of people how many people
understand it well enough they think
they could explain it to somebody else
whew okay I'm not going to ask you to
come up on stage and do it don't worry
okay these how I explain event sourcing
and surprise surprise is to change your
address of example again because I'm
kind of boring so let's imagine I've got
some kind of customer management system
and I've got somebody with an address
and they want to change their address in
a typical system how do you change
address you just say okay let's blow
the old address create the new address
right that's how it works
right nice and simple what events or
thing does is it creates this subtle
change to the picture so now what we
have is we still have this
representation of the current state of
the world but we've also got a second
little area as well and when I say
change my address the first thing that
happens is we create an event object so
this is this first class thingamajig
that captures the details of the change
and we've popped that first class
thingamajig the event into some kind of
separate storage area then we process
that event and we process the event to
do exactly the thing that we expected to
do earlier we change the thing over the
consequence of this is that we've kind
of now got two sort of representations
of our world we have the what I refer to
as the application state which is the
current state that we're thinking of the
world and then we have a log of all the
events that ever changed that world and
this is the crucial test of event
sourcing the sort of the definitional
test is that at any time we can blow
away our application state and
confidently rebuild it from the log
that's the test I mean lots of people
log changes and things like that it's
the ability to replay the log and
confidently rebuild your state so that
basically you don't care about your
application state and trying to preserve
it anymore because the vital thing is
preserve the log if that's the situation
then you've got an event source system
so how many people here have built a
system using event sourcing this
approach smattering of hands few hands
how many people here have used the
system using event sourcing a few hands
not very many how many people here are
software developers put your hands up
okay I'm going to assume you didn't
quite understand what I've been talking
about for the last few minutes because
otherwise we are really screwed all
those people who haven't used an event
source base system and our
we're developers if that were true I
would be really really worried
in 2010 let alone 2017 because every
software developer should be intimately
familiar with one particular form of
events or system which is version
control if you use git use subversion
mercurial even if you use CVS and I have
it was a long time ago but I used it
you've used an event source system hell
I use SC CGS you know shows how old I am
and now see I think a very good point if
then sourcing is basically providing to
your users a system that works on their
data the way version control works on
your code that I find a very good way of
explaining at least the software
developers what event sourcing is about
and a lot of things about event sourcing
you can reason through by thinking well
what happens in my version control
system
what does get do what the subversion do
and then applying that same question to
the application state that you're in in
your version control system your
application state is your tree of files
your working copy your work tree and the
log is of course all the commits that
have occurred through now of course the
system internally doesn't necessarily
store it as all the dense but it stores
it effectively as it were all events
there are snapshots that are contained
at various points to speed up
performance which is basically a copy of
the entire application state as that son
commits but by moving back and forth
between snapshots and using commits and
being clever about how that all into
plays it gives you the sense that I've
got every single commit which is this
kind of the same thing of saying I've
got every single snapshot but it's
slightly more powerful to think of it in
terms of every commit now it's a good
metaphor authoress geeks it's not a
terribly good metaphor for business
people but fortunately there is another
really good example of event sourcing in
the business world that any business
person will be familiar with accounting
Ledger's right the honor sir
my current application state
however much money I've got in my
checking account but of course behind
that is every single credit and debit to
that account
and of course Ledger's and the counting
systems are used by all sorts of people
and that is very much an example of this
event sourcing approach and again notice
the fact that it's a combination reality
it's often a combination of every single
change and certain snapshots a common
thing in accounting is to say at the end
of a year or something we would say
we're going to close out the year we
calculate all the balances for the end
of the year and then we kind of ignore
everything that happened before then and
we build up a vents on points instead
that's a snapshot effect where
effectively you're throwing away history
behind a point in that case but it can
also be you'd up for a way to history
you just use it to make it easier to
calculate what's going on for this
year's money and if you really need to
you can dig and go further back so again
the storage is usually some mix of
events and snapshots done in some way
that is efficient for your capability
but you want to always be able to
synthesize that recreation of the events
so the question with event sourcing is
how can we use this more widely because
there are many interesting benefits but
also costs with this pan immediately off
the top of the head you can say well
it's obviously a great audit system if I
want to figure out what the hell
happened or how did this person get sent
this quote that was completely
ridiculous I can look back through two
events and figure it out and that's why
anybody who's involved in audit really
loves having an events or system that's
why because we have Ledger's because
that's one of the main reasons because
of the audit it's also a fantastic
debugging tool if you're trying to
figure out why your application state
got screwed up at some particular point
in time you can actually take a copy of
the system feed it the same event and
watch what happened going back in time
and of course the time travel going back
and seeing what was the application
state a month ago two months ago we're
familiar from doing that from verse
control right and it's really useful to
be able to go back and forth across time
the alternative state is also use
effectively branching and that can be
very useful in certain circumstances
I've worked on a few systems where we
might have notification events and we
deal with them the example I always use
is payroll somebody worked for 35 hours
in a week we record that we send them a
check we update their sick pay benefits
the pension benefits all sorts of
downstream stuff happens and then six
months later somebody says oh actually
it wasn't 35 hours it was 40 that's a
really complicated exercise to go and
then undo well not you can't undo
because you can't change it but then to
recalculate what the adjustments should
be for all of that but if you've got an
eventual system you say okay I'll tweak
that I'll copy it to a different system
tweak the event calculate what the
current state is look at the to
application states fit them and do an
adjustment I mean it obviously is a bit
more complicated than my casually saying
whether we just dip the application
state but you get the fit picture right
you actually get you can actually do it
and it can be a long computation it can
take or a couple of minutes but that's
why faster than doing it manually and
that can be a really powerful thing last
item on that lay on the list of good
things is actually one of the most
intriguing the idea of using a memory
image this basically says if our
long-term record of what's the state of
a system is the log of events actually I
should walk over here and give you
google this ended a room retreat force
the camera not to wake up if I do give
that long-term view then actually I
don't need to store the application
state in any kind of persistent form why
do I need to store my application state
in the relational database if I've got a
log of all my changes I can have a
purely in memory system and that has
some interesting benefits a great
example of this is a trading system
called L max
and it's a retail trading system and it
was built a few years ago and it has to
be very high performance very low
latency and they looked at various ways
to try and achieve this and they ended
up with saying we're going to run the
entire system on a single thread and
Java and their headline was we can do
six million transactions per second on
this single thread really really blazing
fast and one of the keys for doing this
was all of their data was in memory now
they have complicated transactions they
have lots and lots of things to look at
at once they didn't want to be going to
a database they have it all in memory
and they were able to process really
really fast and if anything happens and
the system went down they could very
quickly rebuild the state from their
application box they would snapshot
overnight so basically you run all the
events from the beginning of today and
work that way and in fact no again one
movie advantages events is you can have
multiple systems running off the same
event stream so they had a very good way
of having hot backups that basically
around two systems all the time with one
of them being the lead one and if it
went down the second one would instantly
take over very very nice system very
very performant one of the interesting
things I was talking with on the lead
developers and he said actually I mean
the performance was fantastic and really
got people's attention but one of the
things that I really miss about
programming in a different system is
that is an Isis system I've ever
programmed it because there was no
database to ever deal with everything
was in memory all the time
and as a result we have a really good
rich model is particularly good for
complex logic represented in a domain
model it was a real pleasure to work in
compared to many other systems
I'm surprised in many ways more people
haven't taken that kind of approach it's
a bit unusual and you have to set up the
infrastructure to make sure that you're
able to do the events with that but it
is actually quite a powerful model and
it may be getting more interesting as we
get more towards systems that have large
amounts of non-volatile main memory
because so much of ask of our systems
have been built under this assumption
but we've only got so much memory we
have to park everything else on disk and
now we've got tons of men
it all fits in RAM for so many
applications so maybe we should take
advantage about your memory images a way
to do it but you still have to have some
kind of persistent store and
communication mechanism and the event
log provides that so it then sourcing
can be very useful in that situation so
those are some of the upsides
but as inquired for a downside ok I'll
go back I hope you enjoyed that not
having to Crane your neck for a while so
it's an unfamiliar system that's bad
because things are unfamiliar harder to
work with talking to external systems
gets a bit more complicated because if I
want to be able to rebuild my
application state I can't just say oh I
call this external system two weeks ago
what was the results because I can't
call it again two weeks ago I have to
make sure I save basically every
response of an external system as an
event and make a part of replay
mechanism I have to think about how do I
store my events in a way that I can
confidently replay them even as I'm
changing the code that processes them so
the event schema starts becoming
interesting to be able to do that also a
little little thing but awkward when I
generate identifiers for things I have
to be careful that I can do that in a
way that I can replay this rule that
says I must always be able to replay the
events build the application state there
are these little tricks little traps for
you early on that you have to deal with
and you have to think through how to get
through those so those definitely do add
complexity and you get other complexity
but typically comes along for the ride
one of the triggers for doing this
talking and the workshop was when I ran
into people that were running into
difficulties with event-driven systems
but it wasn't clear what the source of
difficulty was so I remember chaning
somebody on a project that it was in
difficulties and they were saying wow I
will never ever use CQRS again okay you
had a hard time with that Oh awesome
rewind blah blah got that wrong he said
I will never ever again use
and sourcing and I asked him why and he
said well because every time I want to
do everything I have this read model to
build in the right model to build after
noon twice as much work and I thought
well hang on that's nothing to do with
the ven sourcing that's something to do
with something else and you often find
that people will miss that
mischaracterize where the problems are
with event sourcing I've often heard
this because the problem and the problem
on that project according to the lead
architect was a synchrony they processed
all their events in an asynchronous
manner an asynchronous processing got
difficult for people because a synchrony
tends to be hard to work with hard to
reason about now there's no reason why
you have to have a synchrony with an
event source system when I just make a
local commit in git that's not an
asynchronous operation now okay when I
when people are pushing up the shared
repositories then a synchrony comes into
play but there's none of that it's all
synchronous operations that I'm doing a
local commit but often people take
advantage of the event sourcing to
introduce a synchrony into the system
which can be a good thing because it
improves can improve responsiveness but
a synchrony then adds complexity so the
reason I put that as a kind of question
mark there is a synchrony often comes
along for the ride with event sourcing
systems and it does add a lot of
complexity but it doesn't have to be
used you don't have to use a cinco to an
event source approach even though it
seems common that people confuse that
another issue is versioning versioning
can get quite complicated in the event
source system because of this ability to
replay and particularly when you think
while the code of course is also
changing in this system over time if I
change with structure of my application
state and the schema that I'm using from
my application state can i still process
that event that was created a year ago
what does it mean to create to do that
do I need to change my event schemas and
version them versioning can get messy
again it doesn't have to be the Lmax
example I mentioned earlier on they
didn't run into that problem very much
because they only operated on a one day
snapshot and
Vence from that snapshot so we didn't
have to worry so much about the
versioning aspects but it can be a
killer for other systems and I'll
mention that there is a book in progress
or close to some degree of completion by
a guy called Greg young if you look on
lean pub about versioning for event
sourcing systems where he goes into a
lot of detail about the various options
you have the handling event sourcing so
handling versioning an event sourcing
Greg young is the creator of events
store which is a storage system
specifically designed for events he's
been working in the event space for
quite a while you can find a bunch of
his lectures and things on video I've
been trying to get him to write a book
about event sourcing for years so far
without success
so if you ever do see him telling to
write that book tsoay then sorting is
like most things a trade off there are
pros and cons there are some really nice
advantages there are complexities
involved I do find it surprising that
more people haven't made use of it
approach however one more thing to
mention about event sourcing them and
that is exactly what we record as our
events in the event source think about
the code example for a moment I go into
my code I see some function with a name
that I don't like anymore and I want to
change it so I'll go and change it
fairly straightforward refactoring
operation how do I represent that change
in terms of event sourcing there's two
events going on here one is my intention
change the name of this function and the
second is all the actual edits that I
actually have to do in my source code
which is not of course just in one place
it's the Declaration of the function and
everywhere that calls it now as far as
any version control system I've ever
used is concerned it only sees the
latter it sees a series of textual dips
that have absolutely no way that you can
tell the intention from that except by
looking at the dibs on and maybe the
commit message to say that's that's what
I've done we've talked in times of how
it'd be nice to have automated
refactorings
was storable that were first class
finger me jigs that you could apply
across your project but in practice it's
very difficult to do that because of
course a renamed function method
function Capac capability for that would
work with JavaScript is not going to
work with Java he's not going to work
with Python so I have two language
specific changes in my version control
system that starts getting very hairy
while text works with everything we know
how to dis and deal with text changes so
we rely on text but then we lose the
intention we lose what the reason why
same thing basically happens with
business stuff as well we say I've got
some intention of something I want to do
and I might want to capture Battin is an
event I think about as a kind of an
input event and then I have how does
this affect my internal knowledge of the
world which is a lot more detailed but
also often loses important context and
then there might be another kind of
event which is an output event that says
here's what changed over the rest of the
world knows about it it's important to
realize these are separate things and to
think about which ones you want to
capture which ones you want to store
because you might want to store more
than one of these if you look carefully
at the slide you might notice we have a
slight problem the code isn't quite
right the total is wrong what happens to
me
fixing this bug I've got to be able to
replay if I quoted that as the order
price I can't just change it because I
quoted it announced it to the world but
on the other hand I've still gotta fix
the bug but I've got to also be able to
replay then you start getting tangled
again it's this versioning issue
Greg Young's advice is quite firm he
says don't have any business logic in
between your event and its storage
because if you do you run into this
tangled versioning mess but on the other
hand if I don't have the input events
stored I lose the driving intention of
what I'm doing
because that that internal event can be
pretty complicated and messy one
solution of course is to store both and
in fact I've seen that done with some of
the events or systems I've worked in the
the canonical style that I that I saw
back in the 90s when doing this whereas
we would store the external event and
then actually all the changes to give
application state would be accounting
entries so they were naturally event
sourced because they're all accounting
entries and so we'd store both and you
might have a whole pipeline of changes
that payroll example I said every little
change change to your sick pay
allocation change to your vacation stuff
every one of those changes was a
counting entry and so everything was
stored as events flowing all the way
through and you've got a pipeline of
processes producing events produce it
with triggering other processes
producing events through the system and
that was very useful and that worked
quite well and I suspect that's where we
have to go part good part of the
discussion we had at this workshop was
this question of what's more important
the internal or the input event and as I
said I do think it's it's certainly
important to be clear of what you're
storing and to understand the
ramifications of what means across them
and I suspect most of the time you need
to store both okay so that's three of
them so what's the fourth one while I
kind of already hinted on that and that
is this thing called CQRS
command query responsibility segregation
a term coined by Greg young whose name
of called out a couple of times already
and he's talked about it I remember that
the first time we talked about it was at
a go to conference or this is this time
I saw him talk about it was that a go-to
conference many years ago the basic idea
with CQRS
is that you separate the components that
read and write to your store permanent
store so you have effectively two
separate models one for dealing with
updates and one for dealing with reads
so
the crucial thing here is that they are
separate pieces of software separate
components and that you really only ever
use the command component clan model
when you're making an update you always
read using something else I mean you
might do some reading in the middle of
processing the command will do some
reads but basically anything that reads
the system is completely separate and
the example I remember that he gave of
this it was quite nice was a system that
had to do a lot of complicated business
logic for all the updates and they
didn't want to have to be but they
updated much less frequently than they
read so it made sense to effectively
calculate a lot of derived data and
store it in the read model so the read
model could basically go direct to the
UI and the command model then had to do
all the complicated calculated
calculations this is a model that I am
this is an approach that I would say
you've got to be wary of I think it's an
appropriate pattern for a number of
situations but it is one that seems to
correlate a lot with people getting into
trouble and so you've got to really kind
of be careful and make sure you really
understand how it works and what its
benefits are and if you really need it
when you're using it my sense is it's
got to be pretty deep down in the tool
bag and to pull this one out it's a good
pattern when used appropriately which is
goes true with almost any pattern but
you really have to pay attention to thee
when to use this I also find it gets a
bit confused because I've heard people
say well we think CQRS should be used
everywhere because it's really useful to
have different models for reading things
and populating different models but to
me that's stuff we've been doing ages an
hour for ages been talking about the
idea of reporting databases where you
have your online transaction processing
system and then you take a input out of
it put it into a completely separate
database for generating reports people
have been doing this for years you might
do it every night from a extract
transfer load you might do it in more
time using event updates these days but
that idea of having different read
pictures but to mine to my mind if CQRS
is this then CQRS is every system that
was ever built I think what's important
about the CQRS model is the notion that
the that command model the thing that's
used for updating isn't used by anything
for reading it's only used in the
process and you've got a distinctly
different model that's only used in the
update area and that I feel is a
relatively rare ish thing to do is
appropriate when you want to use it but
be pay a lot of attention to where it's
appropriate on the other hand using
reports at different reporting views I
mean do that all the time I mean I'll
always been a big fan of transform the
data into a shape that makes sense
they're looking at it and then look at
it and multiple transformation steps
compose very nicely so pipelines of
transformations I mean that's that
should be something that's familiar to
pretty much everybody
so for patterns all coming under the
term event-driven I found this useful
and we found it useful in terms of our
workshop because now we feel that when
we hear somebody say event-driven we've
got an idea of where to go next
now we say okay we think one at least
one of these four patterns is in play
let's ask questions about that and
understanding these patterns then can
ask more questions about okay why are
you doing this are you doing this
appropriately what are the common traps
I mean the value of the pattern is
saying here's a particular technique
some are ideas about when when it's
applicable or not and enough knowledge
about the pattern for you to know are
these are the things I should watch out
for these are some of the things that I
would expect to see as consequences of
that it gives you a bit more leverage
but something as vague as event-driven
to me doesn't give you that because it's
too imprecise it's actually a similar
problem that I just found with
service-oriented architecture service or
intoxicants oh mary different things the
fact that somebody said that we're using
it didn't really tell me anything it was
have to dig deeper and so a more precise
term like micro services is better
because
just carve there a small amount of that
space and you've got a better idea
what's going on of course when a term
like micro-services get super overhyped
then that tends to lead to confusion
because people aren't using the term
properly so you know again it's not
perfect but again with but with events I
think we gain a lot by being a bit more
precise well I hope you've got out of my
talk is some sense of what that
precision looks like and what these
patterns are and so that you can have a
bit of better idea when you're talking
about event-driven systems what they
mean the original article and there's
the URL for it you can see I've stuck
the date at the front of the URL I only
do that the things that I think are
that's not going to be relevant I
probably delete it in six months I got
that wrong but anyway do go and take a
look at that it's a very brief summary
but there's links from there to lots of
other things things like the article on
Lmax some of the stuff I wrote ten years
ago and events sourcing that's still
fairly relevant and stuff of that kind
and I hope you found that useful and I
hope the talks that you will see later
on in this conference will be better
than this one thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>