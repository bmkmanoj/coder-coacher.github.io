<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Visualise, Document and Explore Your Software Architecture • Simon Brown | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Visualise, Document and Explore Your Software Architecture • Simon Brown - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Visualise, Document and Explore Your Software Architecture • Simon Brown</b></h2><h5 class="post__date">2016-11-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GM_J_jRp62g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you very much Linda no it's
seriously my own talent is I can draw an
act you can't draw either I'm going to
take you on a journey this morning let's
imagine the area's 2116 and we've
somehow in invented the teleporting
system and I teleport you all from here
to there
where are you could be France LaRue do
something it says in the in the text
there you're a bit lost on you not
really sure why why you can look around
you can ask some people maybe there are
no people around how would we solve this
with technology
yeah GPS we'd get our smartphone out we
need for Apple maps with Google Maps and
we'd find a little blue dot and we'd
zoom out so this is like a street view
we zoom out aha now it's getting a bit
clearer and maybe there's a little blue
dot superimposed on here somewhere
it's still a bit complex you can't
really answer the question where are you
can you we zoom out a bit further a hard
we're in Jersey this is where I live
this is a great map except it's kind of
complex isn't it
there's lots of colors lots of textures
going on it's hard to see some detail
one of the nice things with Google Maps
is we can remove the satellite view and
that becomes much much clearer and now
we can see the intricate networks of
lanes and roads connecting all the
different places who's heard of Jersey
right says not everybody so some of you
won't know where this little island is
so again we have to start the zooming
out thing we zoom out we can see there
some more Islands next to it we zoom out
some more that's near France we zoom
that further there we go so now we have
some context about what Jersey is and
where it is so you should definitely
come to Jersey Jersey is an amazing
place lots of things to do one of the
things you should do when you come to
Jersey Airport you should pick up one
these maps is a Vista map and the Vista
map is a very kind of low detail map and
it basically tells you the things you
need to go and see
so it's broke up into four parts
relatively easy to understand lots of
nice colorful graphics some places of
interest this is where I got battered on
Sunday in the waves trying to surf badly
we can zoom into the town section
there's a bit more detail you know some
of the road names we can see there this
is not entirely accurate I mean this bit
here this blue bit the tide actually
goes out so if you park your boat there
you will find it on dry land at some
point and this bathing pool here
actually does get filled by water which
is quite useful because I imagine kids
peeing it in the summer this map has a
bunch of points of interest on it things
you ought to go and see and look at and
do contrast this with like an ordnance
survey map which gives you a much more
higher detailed view of a location in
this case Jersey so here we can see lots
of information about the textures and
the land type and the contours and these
sorts of things but it's a bit harder to
understand listen you need a little bit
of training and intelligence to start
interpreting this data one of the things
these two maps have in comments they
show you selected highlights and when
you come to Joseon holiday next year and
you should you should go and visit
Elizabeth castle Elizabeth castle is a
castle it's like a little island
just the south of Jersey built in the
16th century and it was basically put
there to stop the French - the English
taking a true Jersey and so on and it's
beautiful you know big granite stone
work and all that sort of thing and as
you wander around this castle on your
holiday you get to the center you gets
the high points and this is really weird
big granite this concrete things stuck
on top of the granite and it's just
really jarring and it makes no sense
you've got this ornate stonework and
then this big concrete thing on top and
you kind of look at it and go wow why
when and the answer is really in the
history jersey was one of the places in
world war ii that occupied the germans
came along and they basically
refortified the existing fortifications
so that's why we've got things like
these gun emplacements stuck inside
these granite walls
example so the history is the key here
and of course when you come to Jersey
you need to go buy a guidebook because
it tells you all of this sort of stuff
well we can go to the website again all
of this information is freely variable
out there so that's my advert for Jersey
over with what does this got to do with
anything
around software well one of the things
we're going to talk about is visualizing
documenting and exploring software
architectures and one of the things that
I do is my kind of pay job that pays my
mortgage is I run workshops around the
world as part of that workshop I give
people requirements to say break stuff
up into groups go design a solution draw
some pictures and these are the types of
pictures I actually get during my
workshop I've been running this for 10
years or so I've got 15 gigabytes of
photos that look exactly like this I
promise you I've not made any of these
things up and sometimes when people are
doing this exercise I've got a lot more
achievable but stop there so sometimes
when I'm when I'm listening to people do
this exercise in groups they'll say
things like this they'll be drawing a
box or line they'll say this doesn't
make any sense but we'll explain later
right when is later exactly when you
present your diagrams how many people
present diagrams they're in
documentation you know sometimes you're
not always around to explain stuff and
of course it's all about teams if one
team is creating a set of documentation
and another team is creating a separate
documentation those diagrams as
documents make sense in that context but
if they switch guess what happens you
get this kind of big white moment it's
like I have no idea what any of this
stuff means because I was not part of
that conversation creating that artifact
and when I asked people to review the
diagrams they say things like this you
know I'm not sure what this box
arrow-shaped thing is why some lines
pink or someone had a pink sharpie and
they used it there are no annotations on
the lines the sticky notes are falling
off the whiteboard and so on and so on
the zone and I asked people well I've
seen your diagrams you clearly didn't
find this exercise easy so what was
challenging about it and they say say
things like well
not reassure wait to start we don't know
what to draw
not sure what notation we should use
what level of detail we should design to
what level of detail we should document
to and so on and so forth and it seems
this is one of the things that we've
forgotten how to do it as an industry
who here uses UML I'm going to count you
some two hands one two three four five
six seven I reckon there's 15 people
maximum here out of a large audience
so what several he hosts doing well I
guess the answer is diagrams like the
ones I just showed you I I've asked this
question everywhere I've been and I
think it's in the sort of temperature
mark these days I do you think this is
optimistic more and more people are
adopting ad hoc notations rather than
using something at UML which fixes a lot
of issues for example I do use your mail
myself but I don't find it's very useful
for doing software architecture stuff
you know for describing how a system
works so that at a high level an
overview level but I do use your mail
for things like class diagram sequence
diagram state charts and so on if you
can ask Google what it thinks the
software architecture diagram looks like
you get stuff like this just page after
page after page of very pretty colorful
Visio style PowerPoint style block
pictures there may be some UML in here
but you'll just skip that stuff because
it's too complex and I think ultimately
what we get to a diagram is like this
and and whenever I go and visit
organizations this is basically what I
see on wiki pages and half of these
things don't make any sense at all look
we've got layers with no lines between
them we've got different color codings
we've got acronyms and all sorts of
crazy stuff going on here this is hard
it shouldn't be hard but it is hot and
and pretty much every single team I work
with around the world struggles with
this exercise and it's not an exercise
in designing software the actual design
parts dead easy the exercise is really
about communication of visualization and
describing how system works and for me
the real irony here is agile over the
past 15 years our jaws made us awesome
at visualization information dashboards
radiators Kanban boards story walls and
songs so
fourth and we've totally forgotten how
to visualize the stuff for building
seems tragic and this is all right good
communication right if you want to move
fast as a team if you want to be agile
and adaptive and switch direction you
need good communication that's essential
this is about right here so there are a
couple of things to look at here one's
notation one's content notations dead
easy to sort out just be conscious of
the notation that you're using there are
some tips on this slide here I'll give
you a link to my book which you can
download for free at the end all of the
stuff is talked about the one thing I
will point out is this last one
responsibilities we often joke that
naming stuff is hard in software
development do you think this is true
yeah so if naming stuff is hard why are
most architecture diagrams just named
boxes literally a box with one word in
my advice here is just add more text to
your architecture diagrams because that
gives you a nice at-a-glance view of
what's going on so here are two examples
of the same diagram a typical looking
one on this side on the left and a one
with more text on the right and it just
it just adds a much more detail to it
it's not hard to do but it just said it
removes a lot of the ambiguity content
is really the more interesting thing
here so when I ask people to draw a
software architecture diagrams what is
it they should be drawing what level of
detail and it's hard to put all of that
information on a single picture and this
is why when you read the classic
architecture books they'll always talk
about views the logical view of the
system the physical view that
development viewed the design view the
infrastructure view the deployment view
and so on and so on and so on and there
are lots and lots of different view
catalogs that describe mechanisms and
techniques for describing software
systems for example the one thing they
all pretty much all have in common is
that you have this logical view of your
system which is functional building
blocks and you have some sort of
developmental design view which is
really how those logical building blocks
are reflected in the code and they're
separate
and we've been taught to keep them
separate and I don't know why because if
you have this logical view that that
describes logical building blocks and
this development view that somehow
describes code well there needs to be a
good mapping between the two and this
often not and this is when people say to
me well we have these wonderful
architects our diagrams on a wall but
they don't match the code have you seen
this is this happening right now yeah a
few people go admitting yeah so we have
these diagrams and they just don't make
sense they don't reflect what the
reality of the code says George
Fairbanks in his book just enough
software architecture cause this the
model code gap and it's very very simple
to explain when we're having an
architecture discussion we use terms
like components and modular and soft
system and layer but in our languages
that we use to program we don't have
these constructs so for those of you who
are Java developers here is there a
component keyword in Java no is there a
layer keyword in Java no we have to
create these abstract constructs based
upon packages namespaces interfaces
classes that you know they're call
building blocks that we have and
sometimes the two words just don't match
the code and the model and if your
diagrams don't reflect the code they're
basically pointless and you may also
just throw them away unless using them
form architecture and that's a totally
different purpose I guess and here's the
big thing here as an industry even in
2016 we don't have a common way to
describe software we don't have a common
vocabulary that we can use
interchangeably amongst all of us we
think we do but we actually don't who
likes a good quiz cool we're gonna have
a quiz right what's this it's a map of
Paris what's the blue thing in the
middle it's a water it's a river right
what is a river come on
it's a body of flowing water flows one
way or the other right so using this
information and this knowledge and we
understand what a river is we can go to
other places around the world and we
cannot identify other rivers this is an
easy quiz right what's this
it's a floorplan what's it a floor plan
for a bathroom perfect what's this thing
here a toilet what is a toilet you don't
know whirring what's a toilet it's
somewhere you take a person or it's
another body of flowing water if you
want to go that way right so again we
know what a toilet is and we can go and
use this knowledge to identify other
toilets in the environment are there any
electrical engineers in the room perfect
right so there are a couple of ways you
can represent electrical circuits you've
got a schematic view and our kind of
more pictorial view what's this thing
here it's a resistor what's a resistor
it resists something yeah right reduces
flow of something I'm not a logical
person if I had a big box of electrical
components here at the front with
capacitors and resistors and switches
and bulbs and and stuff like that Kuji
comes to the front and finds me a
resistor and oh here it is
yeah because we know how to identify
resistors and if we had the color-coding
chart we could we could identify how
strong that resistor was right this quiz
is far too easily let's ramp up the
complexity ready what's that
right so that's some of the basics what
type of diagrams are these right the UML
component diagram says a 1-point X
version and a 2.0 version don't ask me
which one is which
what we to the box's component eight and
what is it component it's a logical
construct and it's absolutely
meaningless because this one here is a
database component components I'm not
sure if this is a like Oracle deployment
or an in-memory database there is a JDBC
interface here the ones over on this
side are labeled application or UI so I
guess their UI components or maybe you
see wise or applications and the ones in
the middle I have absolutely no idea
about they're just generic components
they could be micro services they could
be components to run in the database or
run in the application I really have no
idea and unless you look at one of the
other views like the deployment view
this diagram basically tells you nothing
you see what I mean about adding more
text to pictures look seminar thing
what's it do does something with
seminars I guess and this is where we
are in the software world and to pull
this back down to its very essence
imagine we're building them for the
world's most boring web application for
some of us the web application is a
component of the entire system it's a
part of that's what the dictionary
definition says for others when we use
the word components we're using to refer
to something inside the web application
same words very different levels of
abstraction we talk about domain driven
design and having this ubiquitous
language between us and the business we
don't have that for us that's the odd
thing about all of this and for me
having that common set of abstractions
is way more useful than any sort of
standardized common notation at this
stage of our industries maturity I would
like to get to you know Electrical
Engineering one diagram for want to rule
them all I don't think we're anywhere
near that yet and a great example of
this principle in action is Maps real
world Maps if we take two maps of
Copenhagen put them side by side they
show the same things only
abstractions but they might use
different color coding shadings icons
and that sort of thing say my
abstractions different notations how do
we decipher the notation there's a key
in the corner a legend so the maps are
really nice simple self describing
documentation and whatever language we
come up with it needs to reflect the
technology that we're using so I want to
eliminate that whole logical development
view thing going on so the way I do this
is very simply when I look at a software
system is made up for containers the
container something like a web app a
standalone app a database is something
that needs to be running for your system
to work you look inside my containers
they contain components this is just a
grouping relate to stuff with a nice
clean interface on top because I mostly
deal with Java in c-sharp my components
are made from classes and we're done
that's it is a simple hierarchy to
describe static structure if you're
dealing with functional languages maybe
this is functions
sorry modules and functions javascript
might be components or modules and
objects so you're going to have to take
this approach and meld it to the
technology that you're using so it makes
sense what I'm trying to do is build a
very very simple static model of a
software system and then the other stuff
is really easy to document around the
outside so if you want to show how a
user story or feature works it's just a
sequence or collaboration diagram that
shows how things you know static model
interact at runtime that's it off the
back of this we can then draw some
pictures so pictures a secondary here
I'll have a system context diagram a
containers diagram a components diagram
per container and then optionally I
might have some low-level class diagrams
or something that reflects the code just
give you a really quick example of this
again this is all covered in the book
that that you can download
I created a really simple content
aggregator when I moved back to Jersey
called Tec tribes it just lists local
people businesses blogs and tweets this
is a context diagram of Tec tribes the
thing in the middle is my system this
diagram shows how my system fits into
the rest of the world you know the
different types of user
act as personas and also that the key
systems that we interact with if this
was interactive we would select it pinch
to zoom in and now we get to the level
to the container diagram and all I've
done here is I've exploded out that
middle box to show the containers inside
it it's the web app talking to a bunch
of databases and there's a standalone
process also talking to a bunch of
databases again if this is interactive
we select one of the containers we pinch
to zoom in we show the components inside
it same deal if we want more detail we
pinch to zoom in we get down to level 4
that's it it's just a simple hierarchy
of static building blocks so the reason
for the infoe mercial thing about
jerseys because i wanted to get the seed
plants about maps really early the
diagram is I like to draw with teams are
basically a set of maps on top of a
software system on top of code base and
again we can use them to zoom in and out
of different levels of detail and we can
we can use it to describe and and
discuss that software system with
different types of audiences you know
the context diagram is very high-level
works great for non-technical and
business people
music developer I want something very
low level and if I'm going to have my
system over to operations and supports
off well maybe they want something in
the middle you know this is a list of
things you need to look after but don't
worry about what's inside it the
notation again it's very easy one of the
things I don't want you to take away
from this talk is you must use this
style of notation this is the one I use
because it's very simple but again using
the demo notation you want provided you
have a good set of abstractions to base
it upon and you can use shapes and color
to differentiate different things but
for me really shape and color
supplements an existing diagram so you
should be able to take all the shape and
the color off and it still makes perfect
sense I'm also not saying that you
should only draw these types of diagrams
because of course there are lots of
other ways you might want to describe
how software system works and that's
where I will point you to things like
Philip Krypton's 4 plus 1 model and that
book there by Owen woods Nick rozanski
this is not a design process so I'm not
trying to dictate a hierarchical design
process that the C 4 thing is just a
collection of diagrams to describe
software and this is useful either
during upfront design or retrospectively
if you have an existing code base for
that documents right and now it gets
tooling and this is the question that
people always ask me and up until
recently have been saying just use Visio
and that hurts
that's what really hurts the diagrams I
showed you you can do them in any
general-purpose diagramming tool physio
OmniGraffle Gliffy draw dot io you name
it you can do it's just boxes and lines
I follow Kelly Thomas on Twitter and she
asked her followers so she's got like 20
thousand followers or something what's a
good matchup for making architecture
slides this is the summary not one
person suggested a modeling tool in 2016
this is crazy
building architects don't use Visio do
they well I hope not they use a modeling
tool they use up my AutoCAD and they
create a a very detailed
three-dimensional model of the thing
they want to build and then they surface
different views cross-sections and floor
plans and all that sort of stuff and the
irony here of course is we build this
software for building people and we
can't do this ourselves it's crazy
so this is my vendor alert products hat
I'm building some modeling tooling at
the moment it's called structure Iser
one of the simple ways you can use this
for free is I created a very simple DSL
and it's basically a DSL that implements
the c-4 construct it's essentially you
wire together people software system and
containers components and you create
some diagrams this is still just you
know manually doing all the work
yourself essentially so why don't we
just Auto generate this stuff as Imrie
tried also generating diagram some code
what happens you get a mess is that
because your codes a mess hopefully not
but you never know but normally these
diagrams are messed because they're
showing too much detail and I can show
you a really trivial simple example so
in the Java world there's a framework
called spring spring does everything and
there's a sample application called the
spring pet clinic this is the Arctic's a
diagram that the
spring team use it's basically stuff in
the browser a controller layer a service
layer a repository layer
it's a traditional simple three to three
layer architecture you download the code
that looks like this you've you open it
in your IDE you say correct me a diagram
and you get that remember this is only a
toy application I did try to move the
boxes around to make sure that none of
the lines overlapped is basically an
impossible task the problem of these
tools is that they see code they don't
see the logical constructs that we want
to talk about when we're having an
architecture discussion modules
components layers and services for
example and we can trace this problem
right back years and years and years so
I found a paper from the 90s and it
basically says if you ask an engineer to
draw a diagram of their system you get a
very high-level picture if you reverse
engineer a diagram from code that
diagram is super accurate but it doesn't
match the diagram that the engineer drew
totally different way of thinking about
the system it's the model code Gaffigan
and of course two answers question we
need to really really ask ourselves well
what is a component and again my
definition of the components going to
vary depending which code base I'm
looking at at the time because everybody
has a different implementation strategy
for building components for example if
we take our our simple spring pet clinic
example you know what's important in
this code base let's focus on showing
the important stuff so if I remove some
of the things I deemed to be not
important in drawing an after two
diagram you get this sort of picture
once you start to move the boxes and
lines around so basically I excluded all
of the value objects the drank classes
the entities and the utility classes and
now we can start to recreate that layer
diagram that we saw before but it's
still showing coding and what I really
want to show something you know one
level up I want to zoom out one notch to
not show interfaces and classes I want
to show components so I have to make
some assumptions what in this codebase
can sit to it is is you know what what
things make a component in this code
base in this example it's the
combination of the interface and the
implementation class but in a larger
system you
you might have a bunch more stuff going
on ultimately what I want to do is draw
this type of diagram automatically from
the code so it's continually kept up to
date now we often say that you know the
code is the final embodiment of all the
architectural ideas so the interesting
question is can we get that back out
again so if I if you give me any code
base can I extract some architectural
concepts from that code base
automatically and the answers will not
really so if you give me your code base
it's really hard to find a list of
people a list of users a list of actors
from a given code base I have to start
doing things like scraping configuration
files and scraping databases and looking
for role definitions and that sort of
thing the same with the list of software
systems that your software interacts
with that's often not very well
specified in the code itself you know
it's API calls and dropping documents on
file shares and documents on message
buses and that sort of thing it's hard
to get a list of containers from a code
base as well you know give me the list
of all of the Web Apps windows services
standalone applications and databases
that make up your system again that's a
hard thing to do just by extracting
information from a visual studio
solution file for example it's possible
but it's error-prone the thing I really
want to do here is extract a list of
components automatically because that's
the most volatile level of information
it changes the most frequently so that's
really the thing I'm most interested in
automating here but it comes down to
that what is a component and in order to
identify components you need something
like an architectural have an encoding
style so this is George Fairbanks is
solution to the model code gap an
architecture 11 coding style is
basically putting hints and metadata in
your source code so that your source
code reflects your architectural vision
and intent that sounds very grandiose
it's real it's really really simple it's
stuff like using naming conventions so
if you have a diagram here and there's a
box that says logging components make
sure there's something in the code that
is named logging components really
simple maybe it's our name spacing and
packaging maybe it's about having one
namespace per component maybe it's about
adding machine readable metadata
annotations attributes maybe it's about
using the module supporting the language
to you know say that one module equals
our component those sorts of things once
you have a code base for these sorts of
rules present you can then extract them
very simply and that's really my goal
here I want to extract as much
information as I can from the code and
supplement it with the stuff that's a
bit tricky to find and I want to bring
back this concept of an architecture
description language I see far too many
people just drawing boxes and lines
diagrams and you can't query a diagram
there's no model behind it an
architecture description language is
basically just a textual description of
a system normally static structure and
there are lots of implementations of
architecture description languages out
there but they're not really used in
mainstream software development but what
we can do is we can take that concepts
and write one using code and that's what
I've done and this is really the other
half a structure Iser so there are a
couple of open-source libraries on
github if github is working now it was
down earlier there's one for Java one
for dotnet and basically what they do is
is there a very simple implementation of
the C for stuff so there are a bunch of
classes representing people software
systems containers components you create
them and wire them together in both
libraries there are some additional
things which use static class static
analysis and reflection techniques so
you go and find things in code base so
the dotnet one uses Roselyn and there's
a bytecode engineering library
underneath the java one this is the sort
of thing you do so you create a person
and the software system to represent
things in the real world and you wire
them together you create a view you add
some styling you order two structures
over an API it draws you a picture you
write more code you get more pictures
again this is the very simplistic view
but this doesn't really capture the
power of an executable architecture
description that
which so if we go back to my spring pet
clinic example you know let's create
something that describes this the spring
pet clinic example is basically an
employee of the vet the pet clinic using
the system so we can model out with code
from a containers perspective is just a
web app talking to a database so we can
create a container for the web app a
container for the database and just wire
them together with some code this is
just creating an object graph in memory
essentially I don't want to have to do
that for the components so this is why I
built this component find a thing which
uses static analysis and reflection
techniques to go and find components
based upon a set of pluggable rules and
those plugin rules come back to the
architecture 11 encoding cells looking
for naming conventions looking for
annotations or attributes and so on and
so forth so - to document the spring pet
clinic system is basically that so
there's a pre-built spring component
finder and it goes and finds spring
components in in simple terms all it
does is it looks for the spring
annotations axe controller at service
repository and it does some bundling
together of the implementation class in
the interface that's essentially all it
doesn't it finds the dependencies
between the things that find we can then
write some more codes to wire things
together so we can say things like go
find me all of the spring MVC
controllers you just found to make the
user use them do the same with the
repositories and make them use a
database so again we can manipulate this
model because it's just sitting in code
it's in memory and then once you have a
model you can start to visualize it and
for me this is where it gets really
interesting so structure Iser the open
source libraries allow you to create
views the views correspond to the c-4
diagrams and you can add and remove
different elements from those views once
you add a bit of styling and you upload
it via the API you get some diagrams so
this is the context diagram for the
spring pet clinic system it's the user
using the system this is all generated
from code that's the container diagram
it's the user using the web app the web
app using the database again all of that
came from the code I showed you and
that's the diagram I briefly showed you
before so this is the component diagram
for the spring pet clinic system all of
these boxes here in the middle are
extracted automatically from the
basse the text in the boxes that's
actually the top-level Java comment so
what I want to do is use the source code
as a an a repository of lots of useful
information and put as much of the
information as I possibly can out
because it's a model we can do things
like generate keys very simply so gone
are the days of you know complex
notation if you double-click so if you
go to the live version it's a diagram if
you double-click a component it takes
you to the github page where the source
code is so again it's reinforcing that
diagrams as Maps concept you click
through the levels you print to zoom in
and you ultimately get from the source
code to the top level or vice versa I
love this tree although it's really
really funny the reason I put the tweet
in this basically does this approach
scalar and the answer is not really if
using naively because again what you
don't want to show is everything this is
what happens when I through my own
tooling at one of my own systems and
it's too complex but because this model
is in CODIS in memory we can write more
code to manipulate the model so for
example it's very easy to say go and
find me all of the in this case spring
MVC controllers and rather than showing
all of the components for the web app on
a single picture let's draw multiple
pictures one per slice where the
starting point for slice is a controller
a web app controller and the net result
is you get a larger number of much much
simpler pictures
so we're partitioning we're reducing the
complexity you don't have to use my
structure eyes attorney again once you
have that model you can do a bunch of
things with it such as throat through
graph this that's all supported in the
open source library and again you can
take it it's just a big JSON document
with a graph inside and you can do
anything you want with it if you hook
this into your build pipeline your your
architecture artifacts remain up to date
that's the whole point of this
essentially so that's a most the content
around visualization documentation was
also in the title of this talk so I want
to talk about documentation briefly
because it's something that I see teams
not doing very well or actually not
doing at all I'm sure you're not guilty
of course and it's all because of our
friend the anti manifesto and
well rather people people
misinterpreting care to a manifesto
shall I say
given any code base you know if I drop
you in a code base like that first
picture I showed you i teleport you to a
random leafy Lane you can start to
explore and make some assumptions but
it's going to take you a while to get to
some where you understand to get to
somewhere you know and that's really a
thing here what I want to do is I want
to fast track people I want to fast
track their understanding this is
tactics for better teams for onboarding
new staff quickly for example and the
code doesn't tell us everything the code
can't tell us why it can't tell us the
intent around things like design
decisions for example and we also have
this thing about tribal knowledge you
know they're always thought silos in our
teams local teams of specialists who
know everything about a certain part of
the system and that's fine until they
leave and this is the bus factor thing
and the bus factor is not just about
buses so you know someone gets run over
by a bus that's unfortunate someone goes
on sabbatical for a year then we have to
fire somebody else I don't use
animations you can tell and and you're
not with this much smaller team and they
have these odd conversations like what's
that thing now and how does it work and
someone says never seen it it wasn't
part of my little tribe and that's the
sort of thing that can kill productivity
essentially and this is where our friend
the sad comes into play the aptly named
sad and there are lots of templates out
there for this you know it's a normally
a good way to describe a software system
and how it works and it has a lot of
really interesting content but the
delivery mechanism is suboptimal should
we say so one of the things I do with
teams is I just rename it it turns out
you can do a lot of things just by
renaming and I call it a guidebook much
like the little travel guidebook that
you buy when you're in Jersey and the
guidebook has maps to help you navigate
that's what the diagrams are for it
tells you what's interesting to go and
see because if you have a million lines
of Java code
I can guarantee most that is not
interesting it's just the same thing
repeated over and over and over again so
that's point people to those
sites history and culture why does the
system look like a system of two halves
let's explain that to people and let's
do all the practical stuff around
building supporting and figuring and so
on and let's use our documentation to
describe what the code doesn't that's my
biggest tip around documentation I'm not
going to go through these in any
particular detail again it's all in the
book that I'll give you links download
my diet my documentation has a contact
section to seen some sort of functional
overview it describes something around
the quality attributes the non function
requirements performance and security
and so on it details the constraints
that were present when we built one and
and design this thing initially because
they always come back to bite us the
principles we're adopting for
development so how do we keep things
consistent what sort of things should
developers do I have a software
architecture section this is normally
called the logical view in most
architecture document templates I got
into far too many arguments about why it
was logical or not physical so I just
changed the name of the section
drop-down this is where a lot of those
diagrams I showed you go I might talk
about external interfaces if I'm dealing
with lots of external interfaces I might
have a code section that talks about
interesting parts the code again it's
the sites and points for interesting
data section talk about data
infrastructure deployment operations and
support so again some of the usual sorts
of things you'd expect seen
documentation here and a decision log
that's the history why did we make these
decisions why did we choose X over Y or
Y over X and these things need to be
kept up-to-date relevant and ideally
lightweight I don't start playing
battleships through documentation
throwing away pages that just don't make
any sense let's keep these things as
small as we possibly can and they're
living breathing evolving documents
let's not make the mistake of going back
to let's do big up big upfront design
you get everything signed off and then
we start coding now this is a piece of
documentation that accompanies the code
it's a product related document it
companies the software system and it
describes how it works and how we got
there essentially
if you want to I don't care how you do
documentation as long as it's useful a
lot of people still use words you can
throw it onto wiki pages like confluence
or SharePoint or there are lots of ways
to do this
I've seen customers creating markdown
files or asciidoc files you know one per
section of my little guy but I just
showed you and they kind of turn these
things into HTML that's that's a fairly
good approach again something I'm doing
structure Iser is I'm trying to combine
the documentation and the diagrams into
a single model so you can simply refer
to all this stuff if you're interested
in documentation there's another
template another strategy called arc 42
arc 42 is very very similar to the
software guide by thing I just showed
you there's a couple of books on lean
pub you can grab and and this guy's
doing a lot of interesting work around
the tool chain around documentation so
how do we again how do we automate a lot
of this documentation there's some
really really good stuff in there how
long should a document be well let's not
talk about numbers of pages let's talk
about if I'm a new joiner to your team
give me something I can read and consume
in like one or two hours over a coffee
or two to get a good starting point and
overview a starting point for more
exploration that's really what I'm
trying to do here so finally just
briefly exploring your codebase
exploring a software architecture and
again this comes back to modeling thing
once you have a good model of your
system you can explore it a number of
different ways it's just a number of
different visualizations so here are
some visualizations that I've thrown
into structure Iser but these are really
easy so the the open source libraries
create a JSON document and this is just
JavaScript d3 this is like ten lines of
code to create a nice or tree view so
this is a tree view of the the static
elements in the spring pet clinic system
system containers components really
really simple if you have a map of all
of your components you can start to do
things like well show me that the
ingoing and outgoing dependencies if I
select this particular component of
interest again it's all in the model we
can just inspect it in different ways we
can do things like show me a some sort
of map of where my biggest components
reside in my codebase again that's
relatively
easy to do once you have this model that
you can explore you can throw it into
neo4j and a graph database michael
hunger did this once isn't a graph
database because the software
architecture model is just a graph you
can query it with Seifer how calls that
there's a whole products built around
this approach it's called JQ assistant
you basically point out a code base you
create some rules about what your
components are your layers are and again
it does the same thing it allows you to
write queries and check for violations
during your build process so again you
can do some really really interesting
stuff once you have a model of your
software system I've got some friends
over Empire and are now building this
product which takes the static view of
software system and superimposes the
human elements on top so you have a cope
a code base made up of modules or
components or whatever how does your
team of developers map onto that or the
boundaries lines or all that overlapping
and this really really interesting
analytics that you can get from tools
like this so a quick summary there's a
really interesting little virtual panel
about software architecture
documentation on info key from 2009 all
that time we go and you know Grady Booch
and Len bass and own woods are on here
and they all say things like this you
know we should put the architecture in
the code we should get documentation
with a click of a button I don't think
we're they yet but some of the
techniques I've outlined and spoken
about this morning I think push us in
the right direction some points to take
away treat diagrams as maps of your code
they help you get a starting point they
help you explore they help you navigate
a large and complex code base
documentation needs to describe what you
can't get from the code if you're just
describing how old your classes work and
interact and stop right shift the detail
up one level of abstraction this is all
about tactics of better teams I'm really
interested in making teams communicate
better through visualizing what they
have this makes things like collective
ownership of the code better it makes
things like bigger architecture
refactorings much easier because if you
know what you have
now and we want to get to it's a really
simple transformation process the one
warning I will give you especially
around things like my diagramming
technique is if you don't know what
you're doing you'll be showing up fairly
quickly so what when I run these
workshops is true story when I run these
workshops sometimes the more junior
developers who have a much more
technical focus are able to create
better diagrams than the architect and
some organizations don't like that yes
the 1990s called and they want their
turning back
please stop using Visio it's 2016 we're
supposed to be computer scientists or
computer engineers or software engineers
or whatever you want to call us why we
still using Visio angle iffy and draw
the ire and all of these general-purpose
diagramming tools let's progress to the
next level let's progress to some sort
of engineering discipline and how do we
how do we do that
lots of lots of ways so if you want more
information on the stuff I've spoken
about you can download my lean pub book
for free with this special coupon so you
have to use this by Friday I think there
are a bunch of videos online where I
spoke about this topic in more depth
before if you go to structure Iser and
you click the help link or all of the
information about my documentation
approach is what was all there for free
to consume and if you want a really
quick overview my c4 model the Vox
article is a really good starting point
regardless of how you do all this stuff
my simplest advice is very simply create
a ubiquitous language thank you very
much
Wow Thank You Simon I want to run out
and document something we have time for
maybe one or two questions anybody Cory
so cynically I asked when it it's always
just sort of like brushed off of like
this needs to be a living document and
every time I've tried doing that it ends
up dying and like nobody comes back so
do you have some suggestions for how to
integrate it into being a part of like
the team's process and keep it from
being that oh crap now it's it you know
it did my 4 o'clock to 5 o'clock yeah
painful task to do but how do i how do
we make it so it's really really
integral that people value it yeah so
the very simplest tip I can give is if
you have a definition of done for tasks
or stories stick a line at the bottom
have you updated the diagrams and
documents and then it's a five minutes
or rather than seeing that between four
and five every day go well that's it
that's a simplest tip I can provide
people anything else there's one right
on the other side
there's all the sounds pretty awesome
actually
when we do have code where we can embed
all this information into but how would
you recommend going about this before we
have any code and integrating these
tools into that so before you have code
my general process for doing this is if
I'm doing it up front design exercise
I'll still use sheets of paper and
whiteboards and things like that because
that's a good way to create a starting
point it's a good way to create that
initial vision that a team needs to
follows the wrong word but you know
that's that's a direction that we want
to go and once we start having codes
then I'll switch to using these sorts of
techniques so I'm not going to start
doing up front design easy intent these
techniques because that's a bit overkill
really so again it's on be pragmatic and
using the tools that we have at the time
that's most appropriate for them
anything else before lunch
yes Linda's going so I've used the C for
models just for on the whiteboard for in
my own understanding for conveying yeah
these concepts to your friends and
colleagues but scaling it to the
enterprise what I see a big bit of the
problem is having an in-house software
as a service is great for some things
but there's in some enterprises there
are reluctance to use these services how
do you see it scaling to the enterprise
having an in-house and what kind of
tools for the modeling is actually
available now so in terms of my
structure eyes to think you're right
that there are lots of companies I speak
to and I think is great but they're not
they can't use it because it's on the
cloud of the cloud is apparently
dangerous I discovered as well one of
the things I'm doing is I'm creating an
on-premises API so all the data stored
locally it's funny because I see people
using Gliffy a lot and glyph is exactly
the same thing it's just a bunch of
diagrams on the cloud somewhere so I I
think tooling in this area is pretty
immature actually and there is either
needs to be a mind shift change
to get people to use the cloud all we
need to start building some on-premise
stuff I don't know which the correct
answer is I would hope it's a cloud
because my structure my start dried
stuff is all running on on pill to Web
Services and it's an amazing platform
and I don't want to have to kind of lose
a lot that functionality to package up
an on-premise version that's the thing
that really kind of bugs me
thank you again Simon right</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>