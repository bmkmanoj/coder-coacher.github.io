<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Why You Should Take Another Look at C# • Mads Torgersen | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Why You Should Take Another Look at C# • Mads Torgersen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Why You Should Take Another Look at C# • Mads Torgersen</b></h2><h5 class="post__date">2016-11-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zQXNq-isqFI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay then come welcome I hope you're
sitting comfortably
my name is Matt Olsen known in America
as Matt's torgussen and I work on C
sharp and for Microsoft I always I'm
getting old I always carry t-shirt with
the name of the programming language I'm
working on in case I forget and I'm here
to talk about c-sharp and why it may be
maybe worth thinking about even if you
haven't so far so let's get the let's
get the embarrassing details over with
how many people already familiar with
c-sharp hahahaha that's a lot how many
are not Wow
so I will I will completely fail
introducing somebody to to c-sharp at
this talk it's good to know we can maybe
breeze over some details I had planned
on and get into some my hand so even
even so they say that the reason why
they they make those SUV commercials is
not to make people buy them it's to make
the people already bought and feel good
about the fact that they did so maybe I
can maybe I can achieve that so I am
have been asked to remind you to
evaluate the talk it's good for me
because then if I do something in a in
an unsatisfactory way I can do it better
next time maybe and it's good for the
go-to folks because then they can decide
whether to invite me again some other
time so I do want so this is in the feel
good Department stackoverflow have a
survey every year of the their
developers and they they ask some
various questions and and of course it's
skewed and and unscientific in all kinds
of ways first of all you have to be in
Stack Overflow to participate but I did
I liked the numbers so I'm gonna use
them anyway um so if we look here
c-sharp is is a very widely used
language it's number four here of the
three above
one of them is not a programming
language so um and I'm not talking about
JavaScript I'm talking about sequel and
so so c-sharp is definitely a language
that's in broad usage already it's it's
one of the sort of main mainstream
languages if you will and they also
asked people whether they would like to
continue using the language they're
using and they rate you set to rate the
most loved technologies and it's
interesting to see the T sharp is on
this list as well right so people
actually love c-sharp to some degree
there are some languages that they love
more but if you notice many of them are
languages with small audience is sort of
very dedicated audiences that are maybe
more part of a cult or something and and
but it's a there's only a few here at
the bottom that are actually in both
lists that are both highly used and
highly loved so it's nice to be one of
the three technologies on that list to
which a programming languages and yay
for Python also for being on there right
so so so we in Python we must be doing
something right and and we we constantly
try to think about what is it that we're
probably doing right that we are that we
are still a fairly enjoyed programming
language after all these years so it
seems to be not the fact that everybody
uses c-sharp just because they have to
because people did ten years ago at that
company and they have all this legacy
code there seems to be some kind of
energy around and we want to try to keep
that going and we have some ideas about
why that may be and and that's sort of
what is driving our our language
evolution if you will so we'll get back
to that a little bit later but I think
one core thing to to point out here is
that we are very eager to evolve c-sharp
like if you look at the language
evolution scale from a little to a lot
we're kind of over there as a mainstream
line as mainstream languages goes we
kind of tend to be pretty aggressive
about keeping the language fresh and
keeping it modern and ask the
programming language state of the art
evolves so do we and sometimes we are
the we're the movers and sometimes we're
the followers but we try to keep the
language a good choice for
our programmers in modern day not just
something you have to do because
somebody made that choice in a previous
decade so that's kind of a philosophy
around it I also want to point out F
sharp because it's our little sister
language and it's it's very popular
because it's also very small and and
that's a talk next door
about it at the same time so I'm I'm
sorry that those are scheduled at the
same time but um F sharp is is a very
much more functional language and we
have a lot of we have a lot of benefit
from from the collaboration with F sharp
and the kind of inspiration that it
gives us in the C sharp language design
as well so I wanted to call that out so
how many of you use C sharp and
something other than windows okay thank
you it looked like none for a second
there now it's more like 2% good that's
a lot so most people use C sharp on
windows and that's because that pretty
much used to be where you could use C
sharp and and we're kind of changing our
tune on that so part of the reason I
wanted to to frame the talk in this way
was that we're really pushing it's it's
sort of increasingly being the case that
you can use C Sharbel so we're really
pushing to make that an option right
we've sort of in this weird situation
where C sharp has been a massive main
programming language on Windows but at
the same time we're like complete
newcomers to some other platforms at
least mostly so and so this is
interesting situation right now that
it's actually becoming an option on all
the platforms we're at the same time
very entrenched and and and also very
very new and kind of a fledgling
language in some of those platforms and
we are eager to to help that adoption on
those other platforms one other thing
that has changed that is changing how
and where you can use C sharp is the
fact that we've evolved our language
technology so the the compiler and ID
technologies that underlies the
implementation of the language quite a
bit
with what we call a project rustling and
that's enabling some some I think quite
unique scenarios about how you can use
and how you can how you can program in
c-sharp I'm gonna show you a little bit
of that because I think it's a it's a
nerdy and cool and maybe you can it's
also useful to you one of the
consequences of that is that
that work I'm sort of the language core
and ripping it out of the sort of
windows and visual studio specifics
means that it's become it's become very
easy well as these things go to to
implement c-sharp and other ide so you
can essentially use c-sharp in your
favorite ID and we'll talk a little bit
about that as well
are you a favorite editor and of course
one of the big changes is that we moved
from being a completely proprietary
technology to being completely
open-source so everyone can contribute
to c-sharp and a lot of people do and
you we're getting a conversation with
the community that's vastly different
now it's more of a collaboration project
as opposed to microsoft says and and
that's very exciting it means that
rather than coming out every three years
or whatever and saying that uh this is
what we worked on hope you like it we
are now in a very open dialogue every
day with with the community about our
direction we get feedback all the time
like probably tens of you will come to
me after and and say why we should be
doing something different or proposing
things and that happens online and on
github and and elsewhere as well so we
have a much better we have much better
quality on our design work as a result
of it I think ok so that's a couple of
good things let's start about let's
start with some of those other places
that see char bar so how many people
here have used Sam erine so a few there
so uh have you all you must all have
used Sam rein to non-windows on non
Windows platforms right some that that's
probably the that's probably the reason
why you do so Sam erine how many people
are aware what xamarin is
okay about half samurai rain is summer
mean it used to be a separate company we
acquired them a six months ago it's a
technology for using C sharp to target
to make native apps for Android and iOS
right so it's signal g2 very much that's
very much based on letting you use the
same language and the same source code
for the most part to write to write apps
for multiple different mobile platforms
right so it works in iOS it works on
Android it actually targets Mac as well
and by the way Windows 2 if you want to
and create you know creates high quality
native UI it's it's in it's a number of
big apps that are using this technology
because it saves the effort of separate
implementations on those platforms it
also lets you use the language that you
can use on the backend as well which yes
you can with Java but it's not quite
there yet with with Swift or Objective C
and so it's sort of its economy of scale
and it's also just a very good language
for for implementing apps it's based on
on the mono project how many people know
about the mono project okay about half
so which that is an open source
implementation done by people outside of
Microsoft many years ago and maintained
ever since to to target c-sharp to other
platforms and windows while we at
Microsoft were sort of tunnel vision on
Windows for many many years these people
saw the cross-platform potential of
c-sharp much before we did and an
implement of this great cross platform a
cross-platform implementation so a
samurai rain is based on that and and a
lot of the apps that you see in the the
iOS or Android stores are actually based
on c-sharp either because of Sam rain or
because of unity which is probably the
industry-leading game engine so if
you're up there on the back rows playing
a game instead of listening chances are
it's written in unity right so you're
even even your hands are engaged in
c-sharp right now so again this is based
on mono and and these 2d this 2d 3d game
engine is
is one that you essentially target with
c-sharp so a lot of those games out
there are written in C sharp as well so
we we do actually have this
cross-platform reach in many of the
client technologies that many people are
not aware of so I wanted to call that
out also at Microsoft we're working on
what we called net core which is a fresh
implementation if you will of the whole
net stack the runtime and the libraries
that's intended to be lightweight and
for kind of server server-side use for
cloud and server workloads it's also
cross-platform works and Linux and Mac
and Windows and and we're we're putting
the asp.net framework on top which is
very broadly used web framework that you
can now you can now run on non Windows
machines can it's open source so this
kind of helps with why are we building a
separate one well this helps with sort
of the more the lighter weight things
that you want to do when you're in the
server side first of all there's no UI
framework but it also is able to do
standalone deployment for instance you
can ship the runtime together with your
code so that you don't have dependencies
and various things being installed on
the box that it happens to run on in the
cloud somewhere so it kind of has a
better architecture makes it a lot more
suitable for for micro services and
stuff like that so it's kind of trying
to modernize our our platform for the
for the server side as well
how many people have dabbled with the
net core so far so quite a few again Wow
given that the tooling isn't even RTM
yet I'm quite impressed and do you like
it okay I'm glad to hear because a lot
of people don't yet but I think we kind
of just need to finish it properly so
this kind of proliferation of all these
different Nets that run on different
platforms or sets of platforms creates a
little bit of confusion especially if
you were if you're like a library
provider you want to try to to write
something that runs multiple different
platforms so we also
we're also doing what we called net
standard which is a as we're specifying
a set of api's that are supposed to be
on all compliant done net platforms and
if you target that and you can sort of
just say target dotnet standard in your
tool then then the thing you write will
run everywhere and so you can so you
kind of claw back the ability to to
write code that works everywhere in the
ecosystem and will evolve the standard
over time including you
Hynek or essential libraries and them
and you can then target whichever
whichever standard you want so that's
pretty much the rub on where c-sharp
runs and hopefully that should convince
if there was anyone in the room who
needed to be convinced that people that
there's some that there's some much
bigger addressable space for for C sharp
then there's sort of traditionally been
and it's it's kind of a exciting for us
to to be able to target that so I want
to I want to go to the more geekery side
and talk more about the the project
rustling so I said we modernized or the
c-sharp language engineer if you will it
used to be that there was a c-sharp
compiler it was written in C++ and and
then there was visual studio and some
language integration therefore c-sharp
and both kind of understood c-sharp in
their own way there's a little bit of
code sharing and nobody else could kind
of get in on the deal if somebody wanted
to understand anything about c-sharp
right a tool or their own IDE support or
whatever they were kind of lost they had
to start from scratch because it was all
black box and and when we and that was
kind of unsatisfactory for us as well so
when we decided there was time to
rewrite the compiler we not only did we
do it in c-sharp but we also took some
strong of architectural stands if you
will on how it should be done so
essentially I don't think we articulated
quite this way when we started but this
is kind of how it turned out that they
should really only need to be one place
in the world where the c-sharp semantics
are implemented right we should build
the same
that everybody can use for everything
they want to do with the language
regardless of platform regardless of
what it is they're doing regardless of
whether it's a batch process or whether
like a compilation or whether it's an
interactive situation like an IDE full
of full of erroneous code and and all
that stuff it should it should work for
all of those things so it's pretty love
to go and it took it took us uh quite a
while and a lot of a lot of people
worked on it but but we now have the
Rosslyn API which is which really does
satisfy this goal and and most things
out there that that understand c-sharp
or shifting over to two have shifted
over to use Rosling not all of them I
don't know the previous speaker in the
room but JetBrains is and it's an
exception to this for further taking
technical reasons of their own but so
the idea really is that this is a code
base that you used to implement IDs and
editors and and if you have analysis
tools of various kinds Lindner linters
that call out problems with your code if
you want to manipulate code like have
automatic fixers or refactorings or
whatever that produce new code from all
code you can use it if you actually
generate source you can use it if you if
you're doing more interactive things
like scripting or rep holes or whatever
like we have a sous chef Breville in the
in Mitchell studio for instance it's
built on top of Rosslyn oh and it still
does compile the code as well and
produce happen so so this is this is
sort of a sampling of the kinds of
things that you can do and that people
are doing in spades with Rosslyn right
now so it has really created this this
explosion is Cambrian explosion of
language based tools because people can
now get off the ground much faster it
sort of democratizes working with the
language you already have something you
can ask about the syntax and semantics
you just need to add the specific bits
to what you want to do and one
particular community project that makes
really great use of this is Omni sharp
how many people have heard of our use
Downey sharp so that's that's too few
more of you should know about Omni sure
it's really a project to make c-sharp
available on your favorite editor okay
and the way they do it is pretty clever
because c-sharp now runs everywhere they
can take they can take the rosslyn
c-sharp engine and they can run it in a
separate process on whatever machine you
are you're delivering developing on be
it a mac or whatever they've run that as
a separate process and then they only
need to do a thin integration into the
whatever integration layer that
particular editor has that talks on the
wire using some wire format talks to the
process about everything regarding the
language every time you you press a key
like your first dot and you want to get
completion it asks the process next door
like hey they press dot what should I
show in the completion list and it knows
all the semantics so it'll tell them oh
these five methods are available show
those and and it's kind of this
separation of concerns where all the
language understanding is wrapped up in
a separate process and can be created
over that standardized wire format and
so that makes made it possible to go and
implement see really good semantically
aware of c-sharp modes and in lots of
editors that some of you might might
love it or hate or whatever some which a
sample up here I should note that
Microsoft's Visual Studio code for
instance uses Omni sharp for its c-sharp
mode which is an extension that you just
load in like everything else it's not
it's not built into the editor c-sharp
is just an extension like like other
languages so that's a pretty cool
technology I think I also want to it's
time for some code I think and I don't
know if you're itching for code as well
or it makes you sleepy will needs
probably 50/50 I should go home I should
go out and and see if I have my project
still running here so let's do probably
the weirdest geekiest example here we
have some resolution issues here this
should be good can you see the code on
the back row yes you can actually read
it cool why it is a pretty big screen up
there good so what I want to do is so
one of the things we did to kind of help
people get started think
about language based tool and try to
democratize is we we created this
framework that we call the analyzer
framework where it's really easy to
build something that analyzes people's
source code and can give Diagnostics on
it and also to build something that when
you get those Diagnostics it will offer
up fixes to the code and so if you think
about your organization having special
code Styles that you want to enforce or
you have refactorings that you want to
build because you often do this kind of
manipulation of the code yourself and
all you want to share that with the
world
you're you were you have fixes that you
often find yourself doing that that you
might as well automate this is this is a
tool for you and what I'm this is a this
is a project type that you can just
install and visual studio and start
using when you open the project it comes
with a bunch of boilerplate already
built for you so what happens
specifically when you enter debug mode
on a project like this is that it takes
that analyzer that you were writing and
the code fixes and whatever and it
installs them they can be run in batch
code or whatever you can ship them as
and you'll get packaged but what it does
is it actually installs them as a visual
studio extension in a nested version of
Visual Studio that it then runs as part
of the debug mode here so now I have
visual studio running Visual Studio with
the code fixes that I'm writing actually
operative in the nested version of
Visual Studio so let's open some code in
the nested version of Visual Studio here
and so I should say that I haven't
actually completely written those
analyzers yet we'll do that together so
it doesn't do anything yet but here's
some sample code that we want to operate
on the the thing I want to implement
it's purely syntactical just for
simplicity but you I could have
implemented very semantic rules as well
the the rustling engine provides
complete information for me to use but
what I want to just say here is it's bad
style to have statements inside of if
statements or else clauses that don't
have Curly's around them we want to
implement that old-fashioned rigid style
of they always have to be curly because
then you don't get so many so many bugs
that you edit the code later so we want
to actually complain about this code in
those
and for in the sake for the sake of time
I'll only implement it for if but we
could also implement it for else
so let's employ a little code analyzer
live here so we we go back to the
running code I'm not actually going to
kind of stop the nested the nested thing
here I'm going to just put a breakpoint
so what I did is essentially what I did
ahead of time is I'm just registering
that whenever we see an if statement we
should call this method analyze node
that's all I did and so whenever the
source analysis in Visual Studio hits an
if statement go here okay and let's then
go and and trigger that so if we go to
the nested Visual Studio here and I do
an edit it will reanalyze the code and
boom it will hit the breakpoint and I am
now I now get all kinds of information
about where I am in the code that I can
start working on so the thing that I get
past is is a it's a context object
so let's look what's inside of that
context dot hmm looks like I am able to
report Diagnostics if I don't like this
if statement I can also get the the node
of the syntax tree that I'm looking at
now which is the if statement hopefully
so let's start getting it that out and
if we hover over it here since we're in
debug mode that's an actual object that
got passed in we see that it is indeed
an if statement sorry that the the font
is a little small here so let's let's
get it as an if statement using just
essentially rustling is an object model
for code right so I'm just looking at a
syntax tree node and it happens to be
out the derived class that is a an if
statement syntax here so we can save our
if statement is that thing and now
that's the only kind of thing we're
gonna get called with so I'm gonna skip
checking that it was act it actually was
in your statement and what you say when
is an if statement wrong well it's wrong
if the if statements statement the thing
that's inside of it if that is not
something with Curly's around it that's
called a block so if that if the kind of
thing that this is is not a block
syntax kind blog then I want to complain
okay then I want to say to the user you
are you're wrong and so what I think you
want to do is to take that remember that
report diagnostic that I have here now
I'm going to report a diagnostic okay
and what am I going to put in there I'm
gonna put a diagnostic okay whatever
that is let's call it diagnostic um so I
don't have that yet so I'm going to use
a little refactoring to generate a local
for it it turns out I can create a
diagnostic by saying diagnostic
directory right and it takes a few
things I happen to have prepared a
descriptor sorry it's called
roll and then I need some kind of
location that is where that is where to
put a squiggle in the code when this
when this problem appears and then I
need to say what kind of statement or
what kind of thing I'm looking at here
as well so okay
and we need to find out what the
location is so let's do that refactoring
again generate a local this is all while
I'm in debug mode by the way I'm
actively debugging right now let's see
what is the location where probably the
the note that I'm looking at the if
statement where do we actually want the
squiggle let's have it on the if keyword
all right so the if statement what does
it have it has an if keyword because
this is a synth this is a concrete
syntax tree it has all the details about
the code including where everything is
and so let's get the location of that I
see there's a get location method let's
get the location of that if keyword and
and put that in okay so I just wrote
some code let's see if it actually works
let's remove the breakpoint and and keep
running in the debugger we wait a little
to see what happens and now you see
squiggles appear and the if statements
up here right so that was all I had to
do was write those three four lines of
code in order to identify the problem
and until the tell the framework where
to show it okay and and just to prove to
you
that that it actually works I can I can
go where did that snow come from I can
go and and put Curly's there and the
squiggle go away and that if all right
so essentially we've created very easy
to use gets a little harder when you
start to do complex things but
relatively easy to use model of the
language including its full syntax and
it's full binding semantics and so on so
that people can build tools share them
out and whole editing experience for
everyone using Sierra regardless of
which editor they use as long as it's
based on Roslyn and regardless of which
platform they they're on they can they
can benefit from these and the analyzer
wrote can be equally run in batch mode
like it could be part of the compilation
process and it could flag warnings or
errors just like the compiler does and
its own native things alright so let's
see for time I'm probably gonna skip I
could also implement the fixer but I'm
not going to I'm not going to do that in
the interest of time but we could also
write a little fixer it's not much
harder that actually fixes up the code
and puts those curly same okay so that's
sort of the geek out on the on the
Roslin side and and how that hopefully
helps people get a better editing
experience a better development
experience with c-sharp quite outside
the language it also gives us gave us a
much better code base and much better
architected code base and obviously one
in c-sharp so we can dog for their own
language that helps us evolve the
language itself it's a lot easier for us
now and to to evolve the language and
for the community to participate in that
evolution through contributions so let's
take a let's take a quick reminder of
the evolution of c-sharp here that's a
lot of versions I'm not going to go
through all of them but I think kind of
what it kind of shows is that this kind
of aggressiveness that we've had in
innovation I kind of I may want to point
out the the async there's a couple of
things I where I think we kind of we
kind of did fun things in the language
we did the the link the queries that we
introduced in
in c-sharp 3 really sort of took it's
one of the things that we try to do is
we kind of try to take concepts that
exist in interesting languages that
aren't very used and we try to
mainstream them and kind of pull them in
to see sharbat as a mainstream language
and and help bring them to brought to a
broader market if you will and this is
definitely an example of that the link
queries in c-sharp are an example of
comprehensions that you find in
functional languages and so on we pulled
those in along with lambdas now every
every language in the world has lambda
it was a little less common back then
Java got them now I hear so so that's
pretty cool
of course way back in c-sharp 2 we did
generics only a little later than Java
did I actually got to be part of
introducing generics to Java then went
to c-sharp and and was was part of
rolling it out there in c-sharp we did
it right in that I'm sorry I'm getting
into Java batting I shouldn't really we
did it right in that generics are kind
of deeply implemented into the into the
runtime like Java did the more cautious
approach of making generics something
that the compiler compiles away but when
you have it deeply in the runtime that
that's really good for kind of first of
all getting the semantics 100% but it
also means that the performance
characteristics are very different
especially when you have value types in
the language like C sharp head from
version 1 I hear that Java is possibly
getting it sometime in the future when
you have value types you really want
generics to recognize those and kind of
specialize for those value types so you
don't get a lot of boxing and allocation
around using generics it has to be that
generics makes your code faster not
slower and and generics has really been
the workhorse for many of the language
features we did since then we were able
to do queries right because of generics
because the generics was deeply
implemented in runtime it were available
through reflection as we did all kinds
of weird code quoting and translating
c-sharp 2 sequel and all that kind of
stuff it was all based on the fact that
the types would flow and that would be
available even at runtime
dynamic which integrated
dynamic nests into a static type system
by having a type for when things were
dynamic called dynamic again uses
generics heavily under the hood to make
that efficient them and to avoid a bunch
of boxing and stuff async very deeply
reliant on on generics as well then in
c-sharp six we got Rosling and we were
like okay now it's no longer it's no
longer a big war to implement any given
language feature we actually have more
agility and so now's the time to take
all those little features that we never
got to implement and we wanted to
implement to just make development
easier and nicer and lighter and cleaner
and so we did a swath of those in
c-sharp six which is the version of
c-sharp that's out there now and n ng
shop seven where we're taking on some of
the some deeper features again that we
think that we again borrow heavily from
the functional world and we think that
we are we are essentially taking the
next step in terms of dealing with data
that's not necessarily so object
oriented if you will I think you're
seeing us start as a very object
oriented language and kind of lean
towards a more functional style as a
supplement to the object-oriented if you
will and trying to integrate those as
well as we can it's a bit of an
inspiration from Scala if you will and
what it's doing on the JVM which is to
try to make functional and object going
to work well together but definitely
with the with our roots in the in the
imperative object go in the world for
for for Alice situation and so I think
the next thing we should do I'm gonna
skip the async demo and since most of
you probably know what that is about
and then that's uh let's talk a little
bit about what is it's coming into
c-sharp seven so how many people have
how many people here actually use
c-sharp six or newer so that's quite a
lot of you so many of you have a feeling
for what's in there already
so for C sharps seven and now I
apologize to the few in the room that
aren't see sharpie if that gets if this
gets a little too
too deep here but I think hopefully it's
still useful to see I didn't plan to
kind of show all the new features that
are there but I think some of the most
important ones are was looking at it
kind of goes to some of the common
situations you find you're in where the
this sort of standard C style if you're
going to paradigm get a little in the
way so let's start out with I start out
with tuples okay so I have this is my
whole program here so I have some
numbers actually since they're you know
they're sort of recognizable here but
not everybody may know them by heart we
actually have binary literals now it's
kind of a tiny feature but but hey um
it's good for when you're teaching your
kids to program right oh this is
actually these are the bits that are
underneath these numbers okay I'm gonna
stop you know actually I'm gonna make
one more because another thing we also
this is totally just in there I'm just
doing this because yeah I don't know why
I'm doing it we also have digit
separators now so you can like other
languages too so you can put under bars
wherever you want so the numbers get
easier to read which and if you want
many is fine okay
now let's leave the 32 there so what I
want to do is I want to implement a
method called tally that that summarizes
the numbers in an array and also that
sums them up and also counts them okay
so will tell you these numbers okay of
course I don't have that message yet so
let's use a refactoring to generate it
just a static method here it returns
void it probably should return something
else but this is so here's the question
right should it return the sum or should
it return the count both yes right okay
so so the idea is you can only return
one thing in c-sharp today but tomorrow
you can return two things and three like
coddling but you can also return four so
if you're in the room last week cuddling
we beat you by one actually we beat you
by infinity because you can have as big
tools as you want but it's probably a
bad idea so so let's return to intz
okay and so this is a tuple type and
it's sort of deliberately well it's a
tuple type so it says two mints it
should be pretty easy to to understand
and here's a tubule literal that will
just return a dummy for now do you get
started that then consists of some
values also with Francis in parentheses
and comments and that shouldn't be too
surprising a syntax for it and so when I
go up here I can take the result of the
tally and I can look at it and lo and
behold it's a tuple great so how can I
use a tuple let's let's print something
out since this is a console app that's
pretty much what we can do interpolate
it strings we love them the sum is
probably the first thing in there so
let's see t dot let's see what a tuple
has well it has an item one and it has
an item two okay
it's kinda obvious what they are so we
can use them not the best names in the
world but it works Tina
item two okay so here's something that
works but it would I mean it would be
nice if they had nice a name so tuples
in c-sharp can actually up optionally
have names for the different for the
different elements here so now I gave
the names and what does that mean well
it means that when I get it back it
tells me what they are good sort of
operational comment if you will it also
means though that if I go here and and
press start in addition to these which
this is a preview the final version
should probably hide the bad names when
we have good names because you can see
some is here and I can use that name
instead
so the these are the sort of real names
of the underlying type but the compiler
knows too to keep track of these other
names and show those instead so you get
a nicer experience going against that so
I think it's important that tools have
have names in them because who can who
can remember whether it was first name
last name or last name first name and
all those things right it needs they
need to come with with
and it needs to be operational you need
to be able to get it of course you might
prefer to immediately pick the tool
apart as you get it and deconstruct it
and you can do that too in c-sharp so
you can say some come and count here and
now the tool immediately gets
deconstructed into some variable and
account variable that get declared here
and instead of T dot here we can just
say sum and count okay alright to lames
yeh so so let's go now and implement
this method for real so instead of
returning just a dummy here let's return
a result and let's let's make the result
equal to that dummy value here to start
with so what we want to do is we want to
for each over the numbers let's call
them values because I like that better
let's for each over the values and VAR v
in values and then we want to update the
result every time around so we can say
actually result that's too long I want
to just call it R okay there we go so
let's just say R equals and then a new
tuple literal our dog I want to get the
old value out I wish I wish our had
names as well let's go and give it names
we can you can give names in the two
literal as well so you do that with the
same syntax that you use for named
arguments so now our has a s and a C so
now we can say our that s the sum that's
already there plus the new value and the
count that was already there plus one
okay
so you might you might be justified in
wondering isn't this terribly wasteful
isn't he allocating a new array or a new
tuple every time around in this loop and
in these in these resource constrained
devices and and
and cycle set custom anja on the cloud
and so on isn't it wasteful to allocate
all these tuples and it's not because
the tools aren't actually objects
they're there to bliss about tools
implemented as a value type is destruct
in c-sharp so they're not allocated this
is just really in place updating some
stuff that's already on the stack
right so they're their value types are
passed by copy not by reference to balls
don't have identity they just have
values okay which a thing is the way to
 be they should sort of be
ephemeral they shouldn't have this kind
of life of their own and also it's more
efficient so that's so that's good you
could actually actually trubel's are not
only value types they're also mutable
and I know there are people in the
functional camp that are going to revolt
about this because they already have um
but tuples are immutable
you can mutate a tuple so instead of
doing this I could actually write it
it's probably less elegant but I could
write RS plus equals the value and as a
separate statement are at c plus plus no
pun intended
well a little but um so i can actually
mutate the tuple in place because that's
not dangerous because there's no shared
mutable state among threads or whatever
here because it's a struct right
nobody's sharing it you passage someone
it's a company so it's not actually
dangerous so we just said what the heck
while this is one of these like why does
it always have to be so object-oriented
right right right is that everything has
to be encapsulated and and so there's no
so tuples don't have these they don't
have properties they just have fields
they're just struct with some mutable
public fields there all right it's as
simple as to get so you understand what
you have I think that's right for tuples
because they're not really an
abstraction they're not wrapping
something they're just values so let me
just be values so let that I could do
this but let's actually not because I
like the other thing better okay so the
remaining few things are to say about
tuples is that since it's a type it's a
type it has value equality so you can
use it as a key in in a dictionary for
instance that means you
if you want to kind of if you want you
to be key delft of two things that both
have to be right then you can just use a
tuple as the key and everything works
right the hash code and everything works
out right in the in the data structures
also of course it's a good way to get
multiple results back from an
asynchronous method because if your
async and and you and you return tasks
of a tuple then it all works out when
you go up here and await it the tuple
comes back out and you can deconstruct
it and keep going right so there they're
good transport for the situation around
multiple results was even worse for
async methods and other methods because
you couldn't use out parameters but now
you can just use tuples okay of course I
don't get to a wait because that thing
was not anything but ignore that okay so
that's tuples for you the other thing
that I think is it's quite interesting
is the is that we are starting to add
pattern matching to c-sharp and that's a
whole new concept that we're again
bringing in from the functional camp and
we're sort of doing it gradually so I
think that you'll see more on that front
in later versions of c-sharp but we're
taking a big step I think in introducing
the first couple of patterns and so how
does this work well let's let's turn
this example into one where we have
recursive lists of numbers so instead of
an int array this is an object array
where we just have a convention that the
things inside are either int or there
are other arrays within synonym so new
object array with some of these in
Sonesta inside like this maybe there's
also a null in there for good measure
and now we want to update the tally
method so that it can deal with that so
let's take object arrays instead here
and now we get an error here because
because V is not an int anymore it's an
object so we need to know that it's an
end before we can add it here so we need
some kind of logic there and and what we
would do in the old days is we'd do a
type test
so we'll say if if V is int then we can
go and do this but of course just even
though we just check that it's int we
don't actually know it again down here
we have to check
again and cast it or whatever so what
we're doing instead now is we're we're a
so first approximation you can think of
it as we are extending the Ennis
expression so that you can now declare a
variable here when you say it's in when
you ask if it's in if it is then take
that int and put it into the new
variable I and then the variable I has
the value of V but typed us in so now I
can add it here and I know I'm good okay
so it's sort of added just a an extended
version of this expression if you will
but what's really going on is that the
is expression is now being extended to
allow patterns which is a new concept in
c-sharp patterns instead of just types
and patterns can be many different
things they can't be very many different
things now they can essentially just be
constants or type type patterns like
this it could be like a constant could
for instance be you could you could say
V is seven that's actually also now
allowed because that's a constant
pattern and and then we are taking these
patterns we're integrating them into
language features such as this
expression the other place where we're
integrating it just to just to stay with
the example here is we're integrating
into the switch statement so if I say if
I say switch if I could spell here
switch I can now switch on anything it
used to be that switch could just switch
on primitive types it's sort of this
dinosaur of a feature but now I can
switch on anything I can switch an
object switch on V and now in my switch
statement I can have cases that have not
just constants in them which are now
just a special kind of pattern but the
cases can have any kind of pattern so I
can say case int I except we need to do
some something to intellisense here to
completion before we ship this and I and
I have to remember the break that's why
I'm getting the squiggly there and now
I've essentially used a pattern so so I
extended the the case clauses in a
switch statement to be able to apply a
pattern and say when this pattern
applies do this particular case alright
and so now I can so now sort of
modernize the switch statement a bit I
can also say case object array which is
the other thing I mix
affecting let's call that a and I can
actually also put conditions in mice
which in my case clauses here ii say i
only want the object a when when a is
longer than 0 because he de edad length
its greater than 0 because otherwise
there's no work to do right and then
when that's the case I can do VAR t
equals tally than the nested array and
and go add that to 2r as well R equals R
you know how it goes r 2 s plus T dot
some comma r dot C plus T dot count
right and a break so again spelling
helps so so that's there's a
generalization of existing features with
patterns and that's how far we got in
c-sharp so far with pattern matching
there are some things that if I go back
to the slides here some things that we
would like to do there more things we
want to do with patterns in the future
first of all we want to have smarter
pattern so it's you should be able to
have recursive patterns we actually I
didn't show but we actually also let it
let you specify in a given type that it
can be deconstructed so you can specify
an appoint type for instance that it can
be deconstructed just like a
deconstructed to tuple in two separate
variables and when things are d
constructible why don't we why don't we
put that together with the pattern
matching and allow you to have both
check that always a point and if it is
deconstructed and get you know maybe
apply patterns recursively here saying
if oh it's a point and the first part of
that point the X is 5 then put the
second part into variable Y and do
something with Y right so you can kind
of get smarter and smarter patterns you
can probably also write unreadable code
with this but I think in general it's
it's going to be useful to be able to
dig a little deeper in a pattern the
other thing is maybe we should we should
come up with new places to have patterns
the switch statement is kind of it is
kind of
60s right and and so maybe there's an
expression version of the switch
statement maybe it's a match expression
like it's called in functional languages
that's in it that where the that has
niftier syntax this expression based the
cases are expressions and your code gets
a little more terse like that but that's
the kind of thing that we can now we
have the notion of patterns in there we
can both add new patterns and add new
places where they occur so that's one
thing that we are focused on for the
next version of C sharp which we're
already working on because c-sharp 7 is
pretty much done we just haven't shifted
yet and don't ask me when the other
thing we're thinking about is that one
of the things I talked about kind of
moving with the state of the art and one
of the things that's becoming mainstream
in your lovely little languages is that
is the ability to distinguish in the
type system between when things are
supposed to be Nala Boleyn they're not
right this variable is supposed to
sometimes be null it's part of its
domain
this one isn't so why am I getting all
reference exceptions all the time the
previous guy here
had you talked about the same thing for
for for cuddling and switch tests that
as well and so on so we've been like can
we do something for c-sharp along these
lines even though we've had seven
versions now we're not ability has been
purely a runtime thing and we think we
can and it's a it's a long familiar
lines maybe where we already have that
trailing question mark in c-sharp for
nullable value types so if we allow you
to apply that to a reference type maybe
that's how you say that something is
nullable and if you say that then there
are things we won't let you do on the
other hand if you don't say that and you
opt into this new world somehow then we
will expect the thing in there to not be
known and we will help you maintain that
okay so what that means is I can assign
all into the N but not into the S and I
can't assign n to s without any
qualification either because that would
that might you know right so I'm just
protecting the variable from the kinds
of variables that it's not supposed to
hold on the other hand though when I
want to use it to reference it I can do
s that length without any qualification
because I know it's not in all I I know
it's probably not null because we
probably can't give any absolute
guarantees in a language like C
sharp but it's probably gonna find most
of the places where where you're not
supposed to dog right and so on the
other hand and in that length it's going
to warn you about it potentially being
null and you're potentially getting that
a null reference exception right and so
way to get around that is some of these
new languages they have specific mune
all checking features all right they
have like a new way that pattern
matching or error you can use to check
for now we don't want to change how you
check for null there are already like
seven ways of checking for now on
c-sharp we're good things so what we
want to do instead is to track with a
have the compiler track when you check
that something was null and then use
that knowledge so if you have an if
statement that checks the and sees that
n is not in fact null in this case then
we will know that in the scope of that
check and is in fact not null and we'll
assume that it's fine that you dot into
it okay other ways to get around this
yeah but you kind of have to work a
little to get around it now instead of
the other way around where you have to
work all the time to eliminate all your
null reference exceptions so they'll
also be a damnit operator we call it
where you can actually walk up to
nullable thing and put a bang postfix
bang on it and that means the thing the
thing you are but assuming in the type
system that that was not null because I
know better than the compiler so
sometimes you you just know that for
some you tested something else and ii
knew somewhere and you know in this case
this is never known and if you're bold
enough to just stick with that you get
to insist and we will let you dot
without a warning all right so that's
another thing that we're we've already
working on this feature and we're hoping
to get it into an extra version of C
sharp so hopefully that's going to be
useful the the interesting thing about a
future like this is it it needs to not
only go into the language but we need to
make sure that our frameworks and so on
are adequately annotated so that when
you build on those you get the right
null abilities of propagated into your
own code okay so it's a bit of a
challenging future but I think it's
worth it so I think we are at the end
where I say remember to fill out
evaluations do know that we're over time
thank you very much
someplace
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>