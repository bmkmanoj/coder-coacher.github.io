<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2012 • Continuous Delivery: The Dirty Details • Mike Brittain | Coder Coacher - Coaching Coders</title><meta content="GOTO 2012 • Continuous Delivery: The Dirty Details • Mike Brittain - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2012 • Continuous Delivery: The Dirty Details • Mike Brittain</b></h2><h5 class="post__date">2013-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JR-ccCTmMKY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we will try to get into what
continues to plan and continuous
delivery actually look like in practice
it's hard to it's hard to give a talk
about continuous delivery at Etsy
without really just talking about how we
work in general so I think that I think
that a lot of the way that we work is is
influenced and enabled by doing
continuous delivery so I'll get right
out of the way usually we refer to this
as continuous deployment so when you
hear me say continuous deployment really
what we're talking about is the same
thing and you may not I'm guessing that
most people here probably don't know
what s/he is we are still not expanded
very far into into Europe or Asia but
Etsy's a marketplace it's it's a place
where creative businesses can sell
online is small independent shops and
we're dealing with we're dealing with
e-commerce this is a this is a basically
a 7 year old company so we also look a
lot like a startup despite the size of
our team we look like a lot like a
start-up and we work that way and the
primary product is a website so just to
be really clear about that we're not
packaging software outside of deploying
an iOS app right now everything we ship
really goes to web servers so that's
just a little bit of context around that
this is what our growth looks like in
terms of sales just to give you a
perspective on our continued uptick on
this this is gross sales in the
marketplace so this is the money
transacted between buyers and sellers
we're fairly large scale too so we're
doing nearly a billion and a half page
views a month just in August we did
nearly or note we did 76 million in
transactions so sometimes when people
talk about continuous deployment and
deploying quickly there's an association
with being a small company or or being
able to take greater risks and I think
the story here is that is that we can
take these risks and still enable a lot
of growth and a lot of transactions to
be happening we have about 170 people
committing to our code base that
includes our engineers
designers and product managers and if
you're if you're committing code you're
also deploying code this is the rate of
deploys that we've seen over the last
two years we started basically doing
continuous deployment at the at the very
very tail end of 2009 and as you can see
it sort of starts ticking up there the
difference between the colors here is
that yellow is a full application deploy
where we're pushing all the code that's
on in our main line the red is where
we're flipping config flags and we'll
talk a little bit about that
but you can see that these are these
metrics are per day so you can see that
on average we're you know generally
we're doing between 20 and 30 deploys a
day and then our config changes or
somewhere you know generally 10 to 10 to
20 sometimes 30 or 40 config changes in
a day so that's how fast we're changing
things on the site we're gonna try to
talk about some of the more advanced
topics and I'm expecting that you come
to come into here sort of knowing so in
the background of what continues
delivery is I'm not really going to go
into so much of the what but really more
of the how it looks at at Etsy
this is the wiki part of the Wikipedia
article and these are some of the terms
that you probably recognized repeatedly
push low risk minimal manual overhead
what's missing from that I think are
some things like this and these are some
of the topics that we'll end up talking
about a little bit more DevOps who knows
of DevOps do people know this movement
great awesome working directly a
mainline trunk or master whatever you
want to call it feature Flags people
know what feature flags are great
looking good and then in branching in
code which is obviously you've got main
line you've got feature Flags and
branching in code those are really
really sort of the heart of what we're
doing I'll start with an apology though
because I heard a little bit of
chuckling at the end of the last talk
when PHP was mentioned we work in PHP so
please don't run out the doors so this
is really the crux of the talk what
continuous deployment looks like at Etsy
in practice every single day this is
less of what it is more of how we apply
it and
because I'm not a consultant and I'm not
a very good salesperson it's going to be
more of this is just what we're doing
and this is what we find that works and
less of you guys should go out and try
to do it just this way because I think
it's a great idea for you it's not a
one-size-fits-all proposition so I'm not
I'm not here to tell you that you're
doing things wrong if you don't want to
do this but this is what's working for
us this is our deploy button everybody
on our engineering team all of our
designers all of our product managers
who are committing code have access to
this as long as you can get through the
LDAP credentials you can get to this
when you press this button we deploy all
of our app code to our production
servers that process only takes about
two minutes for for the actual
deployment there's some build and things
that live lead up to that but but
pushing the code is pretty pretty fast
so some then and now then is the sort of
before the end of 2009 when we when we
transfer it over to continuous
deployment and now is the 2010 since
then is hours and hours of deploys and
as Michael talked about the deployment
army this was usually at least five
people and when I was interviewing for
Etsy one of the people who was
interviewing me had to leave during the
interview to go to go help with a deploy
because it hadn't been running too long
and things were failing it's highly
orchestrated and infrequent now it's one
person pushing a button the entire build
and deploy takes about 15 minutes and
it's a rapid rapid cycle previously this
is a special event that we had to plan
out and organize now it's commonplace
and if you ask most of the managers on
the team they don't even know what being
deployed in a single day frankly that's
a little bit of a challenge for us but
it's one of the things where we've
pushed decision-making and in speed of
delivery out to out to our smaller team
so every engineering team is about you
know two to six people out of out of an
entire group each of them is sort the
point is to empower all these teams to
go out and build their features rapidly
in the past I talked a lot about
managing our site in an operational
sense and this is one of the things that
the continuous deployment allows us to
do
in the past if we had a problem with a
deployed we'd be blocked through the
remainder of that deploy and then
through the follow-up deployed to push a
fix that's going to be hours and hours
and hours and now with continuous
deployment we're able to make changes
very quickly a poor deploy can be
resolved within about 10 to 15 minutes
and if we just are going to be tweaking
config flag those deploys actually only
take about five minutes there was a lot
more complexity around deployments in
the past we had packaging we had release
branches we coupled schema changes
together with code deploys which is you
imagine if you're trying to do that and
you're transforming data at the same
time you're probably going to have
downtime for that as you're as you're
moving both those versions ahead now we
work off the mainline we do very minimal
linking there's always some things that
we have to put together in place before
before we push but our builds are entire
our deploys are essentially our sinks
and again this is this is PHP we're
working with so this is one of the huge
advantages we get out of that which is
that we can just arcing files into place
and they start running we don't have to
worry about any other restarts or things
like that so to sum that up old or the
past this is slow and complex and
special new or what we're doing now is
fast and simple and it's common it's so
common that when you started that scene
this is the first thing you do you learn
how to deploy the site on your first day
we assign you a project to put your you
know picture of yourself onto our under
our company like team page and that
doesn't really involve a whole lot of
code it doesn't it doesn't involve like
really learning the deep innards it's
it's a pretty simple project for
figuring out where to put a picture of
yourself getting it into a template but
then you know that comes with the
overhead of understanding how to get
onto your virtual machine where the code
lives how to run tests how to deploy the
site and where to find metrics to ensure
that everything is running properly
after the deploy is done so in the very
first day we're looking at making taking
all the ceremony away from deployments
on the second day we let you complete
your tax forms and insurance and
benefits and things like that
that's the harder stuff I didn't mention
anything in the first two days about
about learning about our framework or a
code base we use an ORM coding patterns
or any of that stuff that's stuff you
can learn over time but if you push off
learning about deployment until further
down the road after you spend a couple
of months building something then it
becomes a big scary event and that's
exactly what we're trying to avoid doing
because this is the button that's going
to be in front of you and you have to
deploy and that means something we're
really really good at doing this like I
said we're pushing 20 to 30 times a day
and if you're not familiar with that
that should sound really scary and you
should have like kind of a pit in your
stomach handing somebody to deploy
button without any safety measures is
like handing somebody a gun without a
safety so I want to talk a little bit
about how to make that safe but I'm
going to tell you about that later I
just want to point out that if that were
inherently unsafe and if we were failing
deploys every single time we did it or
even 10% of the time we did it then I
don't think I'm speculating but I don't
think we would see the growth over the
last two years that we see like this so
continuous deployment for us looks like
this small frequent changes keeping it
as Michael was talking about in the last
talk keeping the batches of changes that
you're making really small constantly
integrating into production and I'm
going to talk a lot about that and doing
this repeatedly throughout the day so
questions you know some of the things I
want to answer in this talk are some of
the questions that regularly come up
when we talk about you know the process
of deploying and and the tools that we
use for deploying which I'm not going to
talk about so much this time but but how
that impacts what we're doing so how do
we build so many features so quickly the
answer is we're not building features
that we're releasing every single day
we're making small incremental changes
to the site we're making additions to
the site and if you think about it in
terms of commits that you're making to a
repo it's the same thing you're making a
small amount of code change that works
that you know is is valid and then
you're
you're integrating it with production so
software deploys don't equal product
launches we can launch code late we can
actually launch features later and we
can organize that into into a bigger
thing but deploys happen really
frequently so these commits you know
typically only represent a day or maybe
a couple of days of work and rarely they
do they make up in themselves a complete
feature or a complete a complete project
so we push code into you know that is
gated by config flags so we can push
changes that are incomplete because
we've got sections of our application
that are turned off we refer to this as
dark releases and so let's look at
exactly what that looks like for us we
do we tend to try to do the simplest
thing possible in a lot of cases our
config flags are just built into an
array in PHP and the reason for that is
that if PHP and Apache are working on a
server then we know that we've got
access to our configs if we put them
into a decentralized service somewhere
else or distributed service then we have
to ensure that that service is available
and we've learned the hard way that
that's not always the case so if we're
building out a new search feature or if
we're refactoring search in place then
we start with a config flag in the off
position and then we look at the code
that exists and we've got you know some
some kind of thing that we were doing in
the past that we want to improve upon
and we just wrap that so we've got our
config flag says if the new search is on
then we'll do this new thing that we
want to do using solar and if it's not
well we'll just use the default old
version our checks are actually a little
bit more sophisticated than this because
we can we can set we can set values
other than just on and off it's not
binaries but we have different levels of
ramping up so on really means a hundred
percent off means zero percent for
public users but we can also ramp up to
any percentage of users and we can do
special things like only staff users or
maybe a list of
people like myself and John and kelan
are the people who can see this
particular feature so we are deploying
code frequently and we're validating in
production but we're doing this in a way
that's hidden from the public so
software deploys again don't mean
launches and they don't mean public
visibility into what you're changing
I've sort of already talked about this
but I'll just point it out again these
are small changes typically we're adding
portions of a new feature so new classes
and controllers and methods in there we
might have designers who are working on
graphics and style sheets and templates
that are getting added in and we might
have people who are working on copying
content changes we don't really work
with a CMS on the site because deploying
deploying a change that's in the repo is
essentially our content management
system and then we also have the ability
to turn flags on and off and ramp up but
this enables us to also respond to
issues on the site as well as as build
new features so so imagine our security
team gets a report of a hole on the site
and we want to be able to respond
quickly
having the mainline ready for deployment
and being able to deploy quickly means
that we can have somebody put in a patch
in a very quick manner and deploy that
quickly because we have the confidence
that we know how to do this and we don't
have to do a lot of a lot of
pre-planning or organization around
releasing our code or releasing the site
we can also respond to unexpected loads
in traffic or contention on on back-end
services a load shedding is a thing that
we do often which means that we turn off
some feature because the back end is
getting thrashed or something is
happening in production that we never
anticipated before so I liken this to an
airline in its pilot if you were
building a version a single singular
version of software that you that you
deploy on a regular basis then you only
have the option to run that one way this
is kind of like having a pre-programmed
route from from London to New York and
once you're in the air you can't do
anything about that you can't you can't
move around
and such but what we look at continuous
deployment enabling for us is that we
have as we'll talk a little bit later
and and Michael talked about a little
bit earlier we collect tons and tons of
metrics which are like these dials that
are in front of us and we put those
metrics in front of everybody so you can
see them and then we have this really
rich set of config Flags so we can tweak
little little things we can take
specific servers out of rotation we can
turn up the traffic on a particular
feature we can turn off features that
are not working in this operator becomes
there's a great question of is that
operator somebody on our operations
staff or is that an engineer and does it
really matter we sort of blur those
lines it's not we don't hand off
software for our operations team to run
on the room but we're involved with that
and what this looks like in practice is
these red boxes are pointing out
different parts of a tool on the site
called favorites which is like your
ability to bookmark specific products to
come back to later and with a simple
config flag we can just flip that off
and as you see in our interfaces we'll
just hide hide those pieces of the
application so if if our favorites tool
which we've seen in the past had too
much too much load and was was failing
requests for some reason we can just
turn it off and most users not even
going to know that the next big question
we get is how do you continues to
continuously deploy database config
schema changes and this is I know this
came up a couple of times earlier today
the answer is we don't our code deploys
happen about once every 15 to 20 minutes
during the day we do schema changes on
Thursday and the reason for this is that
the schema obviously those changes are
more expensive some changes can take
hours some we've seen take days so we
don't have as fine-grained control over
when that starts and stops so it's hard
to know if you were to change a version
of code in response to the schema
when that's supposed to land in
production so the risk around schema
changes are higher those are places
where we force more conversations about
are we doing the right thing and move
somewhat out of individual teams and
talk more broadly about about the risk
involved so our application is actually
largely monolithic within it you could
probably find things that look like
services models around database
different parts of our database schema
it typically get treated as services
where our controllers are talking to
that there's much many much fewer
external web services in our application
and I think that that's somewhat
different than what Sam was talking
about this morning but this is what we
found
seems to work really well we've got a
lot of people working out of shared
codebase so we have very high visibility
into what's changing and very high
visibility into where different parts of
our application are coupled together
where that does happen it also means
that when we run through tests we're
testing sort of end to end and
everything in between one of the things
we've punted on for a long time is
trying to figure out exactly what tests
are associated with a particular change
instead we've just managed to keep our
tests really fast on the front end when
we do a deploy we're deploying all these
different services together and we
didn't always do this but but we have
shared libraries that the power the Etsy
comm website the developer API back
office and support tools that we've got
things like that and what we found in
the past is if we deploy these services
separately then we end up with latent
bugs in in underlying code so if we have
a library that that both etsy.com and
the developer API rely on and we only
deploy the API then once we're into
production we can find that the API is
working perfectly but we end up with
bundled you know the sort of bundled
commit that we've never deployed to
etsy.com
batching along with some future commits
in making that commit or in that deploy
more confusing if something goes wrong
so
see we've found in the past bugs that
occur in lower level libraries and if we
don't expose if we don't integrate all
those front ends into production at the
same time we lose track of some of those
bugs and that's that's been a problem
for us that's one of those practical
things that we've learned over time so
we're shooting for a fewer surprises
external services are not deployed with
the main application and I talked about
that being somewhat separate separate
schedules external services for us look
like our database our database schema
our search cluster which runs in solar
and Java so it's a very different animal
from from PHP and photo storage which
has also got a completely different
back-end infrastructure than our main
web application and we deal with this by
by configs config flags that allow allow
us to move backward and forward on
different states of of those services so
a config flag that allows us to use a
new versus an old version of a schema or
a new versus an old end point of our
search tier changing the flags
themselves is very very fast like I said
this is less than five minutes
it doesn't include you know changing
excuse me changing that config flag
doesn't mean that we're merging any code
and we're not not having to deal with
reverting pieces of code if something
goes wrong it's literally one line
changing from things like off to one
percent or off to on so we deal with
this by exposing multiple versions of a
service or a schema and our application
expects multiple versions and has config
flags to allow us to go backwards and
forwards and so we'll talk about that in
there in respect to a changing a
database schema and how that looks
generally we prefer ads over altars we
don't like altering data in place
especially for lying on on some kind of
data transform to happen on a column
like if your if your address column for
some reason the formatting of it had to
change and your application is expecting
one one side versus the
this is something that I believe Sam
referred to as non-breaking expansions
I've actually never heard that term
before this morning but that pretty well
describes what we're talking about here
we're talking about adding on new
columns instead of altering the things
in place alters can take a lot of time
like I talked about before transforming
data especially on on a on a column in
production can make your code
incompatible and trying to link that up
with a code deploy is really really
difficult reverting something that
you've transformed to a new version is
also very difficult so so exposing two
different versions in production is
really important for us so we can move
back and forward so I'll talk about the
practical aspect of how we did this for
a particular project we did earlier this
year which was merging two different
tables a couple years ago we thought
that having a separate user preferences
table was a great denormalization we
found that we didn't use it that much
and just be better to have the few
values that were they were stored in
that table to be merged in with our
users table this wasn't just something
we were looking around to make work for
ourselves it turned out that we were
also moving the datastore itself so it
seemed like a good opportunity to glob
those two things together the steps look
like this you start by writing to both
versions of the schema and then once
you've started writing to both you need
to figure out how to backfill all the
existing data that you've had in the
past and then once you have that and
you've validated and you start reading
from the new version and once you're
good with that you cut off the old
version don't go and go into more detail
about this and obviously you start
really with with adding the new version
to the schema before you do anything
else that looks like this you add the
schema and we add we added some new
columns to a user's table and we also
started with three different three
different config files that we had never
had before the first was the existing
state of the system and we turn that to
on so writing our writing our users
preferences to this old table that we're
using in the past and then two others
that represented the state that we're
moving to where we were writing
preferences to the users table and then
where we're reading preferences from the
users table as opposed to reading them
from the user
preferences table so in the second step
we write the code for writing to two
places and after we've got that deploy
to production then we flip the flag so
our actual or actual release of this
means that we're just flipping a flag as
we're not actually releasing application
code these are two different deploys
happening and then we go through a
process that happens offline where we
where we write some scripts to transform
data or just copy data from one place to
another to catch us up to where we were
when we did that release because we're
still not reading from the from the new
version we're reading from the old
version and then we get when we wanted
to go to the new version like I said
we've got this very fine-grain ability
to tune up traffic onto a version of our
application so we start reading
preferences from the users table only
for people within the company and we can
do that for as long as we want sometimes
that's a couple of hours to validate
something small and sometimes it's a
couple of weeks then we can go to one
percent and we can go to five percent
and whatever else we want and as we ramp
up we look at we look at feedback we
look at logs from our application
servers in the database to make sure
there's nothing surprising showing up in
there and we look at metrics to make
sure that we're seeing what we would
expect the the right amount of uptake on
a new feature and then we'll also refer
back to whether we're getting support
tickets for people complaining about
this particular feature and we'll look
in our user forums to see if anybody's
reporting that there's a bug on the site
or related to this and when we feel good
about that then we move on to the point
of reading at a hundred percent on to
the on to the new version which means
that we're basically ready to cut off
rights to the old version and we can do
that we don't have to actually delete
any code at that point we can just turn
it off and everything's in place so you
know we try to avoid many releases that
have anything to do with making changes
to logic and production with the
exception of just these flags
this is something I learned two nights
ago is in I guess more of a sort of
pattern or enterprise-e way referred to
as branch by abstraction and I think
it's I think it's a great set up this is
this you know completely models what we
do I've added my own names in here we've
got our controllers talking to a user's
model and within the model is where we
put this config flag so all the people
writing code that goes out to the front
end have no I don't really have to know
where to get their user preferences they
don't need to touch SQL or changes to to
queries things like that the users model
is the only place that needs to know
that these two different things exist
and that's where the changes happen
there's a couple of links down here
these slides will be available later but
these there's some links to more more
discussion of that but like I said I
didn't know that name so I've been
calling this for a long time I call this
the migration four-step and I guess in
in truth there's probably a fifth step
to that which is going back and cleaning
up the code and after you're done and
that always becomes a question for us
because it's question of whether you'll
ever need that code again if you stop
writing your data to that to that old
version then you probably don't need the
code if the code is a complete mess
you're probably gonna want to get rid of
it and if it's a performance problem
you're certainly going to want to get
rid of it but if the old system if the
old version is still valid and it's
still stable then it's a good exit
strategy for if something goes wrong
with your new version so keeping that in
place to be able to rollback in the
future maybe may be days or weeks or
even months and also this is a matter of
if you have time because cleanup takes
time there's a trade-off there so when
Michael and I started talking about this
talk we we got on this question about
how does continuous delivery impact
processes that are upstream of
production and engineering and I thought
about this a lot this isn't this isn't
really tightly involved with continuous
delivery as it is just what we've been
in abled to do and how we like to work
our upstream process is really really
lightweight we do we do fairly
planning in terms of writing things down
we have high code visibility our teams
aren't siloed they're working in the
same place
there's no territorialism over this is
my my code this don't touch it and
there's high communication so that's
something that's really helped us
without having you know sort of designed
by contract situations
everyone can deploy code and deploying
is commonplace this isn't this isn't a
special event so keeping deployment
really cheap allows us to do things more
rapidly which is what we like so there's
some philosophies I want to talk about
some of the things that we really that
we find really successful for us within
continued a continuous deployment
environment gathering data should also
be cheap so the ability to get a
prototype into production and put it in
front of a limited beta group or 1% of
you users and gather data on whether
it's working is incredibly helpful we're
looking with new features for
interesting gate and engagement before
we spend a lot of time making sure that
that is a really really solid
architecture so oftentimes the first the
first iteration is much of very much an
experiment and it largely doesn't matter
what the architecture looks like when
you're deploying it to 1% we're almost
never certain what's going to happen if
we make a change to the site in terms of
whether it'll be a better feature or
whether it be a worse worse feature in
some cases this is changing the size of
the button that says add to cart' but we
like to be able to test and gather data
around that and we don't like wasting
time getting to that we focus on getting
code to production as quickly as
possible and so we hire designers
graphic designers who are actually
really functional in a code base they're
able to our designers are able to write
in HTML and CSS they commit directly to
our get repo even crazier is they use
the command line to do this and they can
also stub a controller out just largely
enough that they can create the
templates that we're going to use on the
site so that an engine engineer can
follow through with additional logic but
they can basically stub out what
something is going to look like and
deploy that to production so we can look
at it our
selves like I said architecture largely
doesn't matter when we're talking about
very small groups and we want to find
out if something's going to be
worthwhile when we start will design
within a small group within your team
your peers will take as many shortcuts
as possible and will will reach out to
an architect on the team somebody more
senior basically as a sanity check to
make sure that we're not cutting
ourselves off from doing the smart thing
later on but we often just stick to
known patterns if we if we we don't want
to invent new crap to add to the site if
the stuff that we have on the site
already is still holding up we only want
to invent new new things when when we
know that it's not working anymore for
us another thing that we feel is really
important because deploying is really
easily easy and it doesn't take a lot of
organization to to release something is
that we try to kill things off as as
quickly as possible and as early as
possible we like to get rid of code
that's not working and get rid of
features that aren't working supporting
legacy features in particular is really
boring and frustrating and it takes away
time from your engineering team so it's
really great to get rid of that and it
also doing that frees you up from
thinking about your code being perfect
all the time if you know that somebody's
gonna take joy and getting rid of it in
the future after your your experiments
failed you'll focus rather you'll focus
on shipping your features more quickly
rather than building cathedrals so we
always like to ask is the dumb solution
enough for us to build a product and how
long is the dumb solution going to last
because often times by time you scale
10% most of the assumptions you've
started with or wrong and you start
reacting and we architecting is the
thing that we like to to focus on after
we've seen that something is working
then we put then we prove it out further
and make it better this the architecture
that we had when we were 10 million
pages a month is totally different than
what it was when we're 100 million page
views a month and it is now completely
different as we're over a billion pages
a month so we try not to take ourselves
too seriously
there's a corollary I think to this
which is don't hastily judge the people
who built the version before you because
their assumptions were completely
different this is a quote as I was
talking to Kellan who's our CTO about
this talk and getting and training some
ideas I decided to just quote him
directly on this and not completely
steal it because I thought it was really
put well put we optimized for being we
don't optimize for being right or having
the right architecture we optimized for
knowing when we're wrong and when it's
time to change and so we we work really
hard at becoming good at changing our
architecture that migration four-step
that I talked about
we are freaking masters at doing that
work that's pretty much what my team's
do almost all the time is going back and
refactoring things that aren't working
or moving from an old data store to a
new data store in finding out how to
make things better so we're constantly
working through this process of cutting
out the old and bringing in the new
with complete uptime where we do spend
time is is within the second or third
iteration when we know and we've got
data that suggests that this is a
worthwhile endeavor then we start
bringing in more senior engineers to
review how the architecture works how
people are using it and what our new
expectations are from it after we've
gathered data we're no longer guessing
at this point so it's worth investing
time so another another section I want
to talk about I've got about 15 minutes
left I think here so I want to get into
a bit about integration and operations
and then I think there's a little bit
more about a few final thoughts that if
I can get to it'll be great if not no
big deal so this was sort of my
definition of how we do continuous
deployment in the main piece here is
that we're constantly integrating into
production the part the safety measures
I talked about these should be pretty
obviously it's pretty obvious everybody
here code review before you commit we
like to get peers looking at code and
just making sure we're not really doing
the dumb things and also because we're
changing things so rapidly in in
production it's always good having
somebody knowing
somebody sitting next to you or somebody
you know in another group knowing what
you're about to deploy because so many
different people are deploying things
throughout the day automated test before
you deploy this should also be obvious
we want to do as much validation as we
can in development before we push
changes into production which begs the
question why do we bother integrating
with production if we're writing in
committing tests with our code then
there's an assumption that maybe running
them against every commit is enough to
ensure all of our assumptions why are we
bothering with deploying the code as
well it feels like maybe we're asking
for additional trouble and the answer
that is that dev your dev environment is
not the same as production and if you
think that it is you're going to
constantly be surprised the way that
we're constantly surprised if your dev
environment were exactly like prod then
the unit tests running in dev would be
perfect at validating that your software
works but when you deploy it to
production you often find that that's
not true so quick question for everybody
how many of you write tests while you're
writing your code or even before you're
writing your code I would expect a lot
of hands on this crew how many of you
wait until you've written all of your
code before you write the tests ok
amazing I see no hands which means that
you guys are all model engineers and you
should Pat yourselves on the backs this
is fantastic we integrating with
production is a test in itself which is
why we do this frequently in small
batches this is the same thing with unit
tests with frequently and in small
batches I heard this recently production
is truly the only place you can validate
your code recently means 40 minutes ago
Michael said that in the last talk
production in dev are not the same
because these are the types of things
that that go wrong these are the things
that we sometimes don't expect some of
the things that I'd really like on this
list somewhat further down legacy data
we have seven years of users
who have been in multiple versions of
our software and and the data about them
has changed to the point now people are
in states that didn't exist two years
ago when we hired most of our
engineering team so they don't even know
how the data is supposed to look and we
don't have all of this data in depth
because there's too much of it we also
don't have production traffic running in
our dev environment so it's hard to
simulate all the different scenarios
that can go wrong in production yes you
can model traffic and you can do
simulations but models in simulations
only show what you expect or what or
what you've seen in the past you may be
replayed replaying history but that's
what's what's happened in the past that
changes basically the future changes
every time we deploy code what what our
application looks like changes every
time somebody makes a commit so it's
really hard to know everything that
could go wrong here's one of my
favorites and I'm so embarrassed even
though that I was involved in this
using a MySQL database to test an
application that's eventually going to
be an Oracle this is probably the worst
you can possibly think of priceless
verify frequently in small batches not
after we've written weeks and months of
code but all the time are we integrating
with production and just so you don't
lose track this dev is not equal to prod
we work as a team we work really really
hard to keep these two environments as
close as possible do people know about
chef or puppet or configuration
management okay so we play we play the
same recipes as prod in development we
keep these in sync yet based on all
those things I told you before we can't
keep it the same and the larger we get
the more dev is not like production so
we like to also keep deployments really
simple and really quick we like to focus
on things that bring us value when I
started we had four different
environments we had dev where people are
working and then QA where people are
integrating staging which is very much
like a pre-production and then
production but we realized we should
probably trim some fat these
where where those environments are
actually sort of split in terms of
services
Devon QA shared the same database so
they had the same same terrible data
staging also had its own database and
its own memcache servers is totally
separate from production so not seeing
traffic and and not seeing the same
things that you see in production that
was fairly unuseful for us yet we spent
time testing and staging and uncovering
things that were surprising which always
ended up being an artifact of the of the
environments being wrong and and
unsimilar
so we've actually cut it down to
something like this dev has its own
databases and services and then a pre
prod which is not which we've renamed
from staging so there's not confusion
pre prod talks to the same servers the
services as our production servers
talked to so pre prod is essentially our
sanity checking spot we dump new code
onto it and make sure that it's still
working that say like the schemas or the
new versions of a service that we're
depending on are in production in that
they're working so it's really important
to think about trimming fat from your
deploy pipeline and making it fast
testing your integrate where you'll see
value like I said QA didn't provide a
lot of value for us we have a build
stage where we run all of our our
integration and unit tests but we no
longer have a web interface for that to
be able to manually click around it
didn't provide us any value config Flags
protect us because again we're
integrating with production but we're
not just throwing things out in front of
users all the time
we're Privett preventing risk by doing
this and we have this very rich
mechanism for being able to turn the
visibility of of a product up in
production and this I think is probably
what our canary pools look like is our
ability to turn up a new part of our
application on just a subset of our
users and be able to inspect them versus
other parts of our user base
I talked about validating before
deploying we also validate after there's
no reason you can't run the same tests
in production so we do that we also have
automated alerts that go off when these
fail we use real-time metrics and
dashboards that look at everything from
the health of our network and servers to
how our application is running how many
how many people have hit a particular
part of the application or triggered a
particular event and then things like
business metrics like our our checkouts
happening and how much money have we
made throughout the day and we put these
metrics in front of everybody we
actually have a dashboard that as you're
deploying code this is one of the things
you put in front of you is is to be able
to look at the health of the system and
I apologize that all of these are so
gray and hard to read but I'll try to
tell you the lower the lower side is our
web tier that's all of our Apache
servers and the number of requests per
second up top or things like logins and
registrations and checkouts and and then
there's some page performance and in the
middle so like if our performance
suffers after a deploy and it's Michael
pointed out in the last talk we use
these vertical lines to signify when
we've changed something in the
application or our config so generally
well I'll get to that that you know the
question will be why is an engineer do I
need this in front of me and the answer
is oh yeah because we don't have any
release managers doing this for you
you're doing it yourself you're pushing
the button yourself and you're also
monitoring when code goes into
production to make sure things are
working so yes these deploy lines
basically signify changes and we're
looking for those metrics to shift
sometimes they'll go up sometimes
they'll go down sometimes they'll look
like this this is one of my favorites to
watch after a deploy which is your our
egress bandwidth and if our bandwidth
from our data center drops by 25%
you might be thinking that might not
have been expected that looks like sort
of interesting behavior we don't know
whether that's something that just broke
whether people aren't getting to a
certain part of our site or maybe that
we've just improved something where
we're shipping a lot fewer image
or images are scaled down dramatically
so we have this operational feedback
cycle that every engineers involved in
you write code your release code and
then you you monitor what's going on in
production and whether it's whether it's
working the way you expect and there's
this great there's this great thing I
think from military use observe orient
decide and act so we observe an orient
we're collecting metrics and we're
looking at those metrics gauging whether
something's working properly or not
working properly and then we're making a
decision in making changes to our
application on a frequent basis to
respond to that continuous deployment
allows us to keep that cycle really
really close and tight and I tend to
talk about this I refer to this as a
theoretical versus practical software
engineering if you're not in my opinion
if you're not working and seeing what
production looks like then you are
largely making guesses at how your
software works but if you're operating
your software and in being involved in
looking at metrics then you are actually
practically involved in how it works and
understanding the ramifications of
decisions you've made such as the kinds
of surprises that you might find if we
turn off the tools that allow you to
translate on the site we found this out
at one point when we were doing some
tests which was that our page
performance got dramatically better when
we shut off those tools it led us to
looking more closely at at how the
internationalization tools work for us
and refactoring them it also puts you
really close to when things go wrong
it's really nice when you when you push
some code and find out that you're you
were completely wrong or you deployed a
bug that that burn sticks with you and
yes it's really broken so again this
it's this it's it's not just building
the plane but flying it it's all the
dials and levers close at hand we do
this constantly and although these dates
mean probably nothing to you in the
United States these are the sort of
milestones that lead up to our our
Christmas shopping season and this is
the point where ecommerce sites usually
deploying code and that looks like this
for us these red bands are the month
before Christmas and we are still at the
point where we're able to react and
operate the system and I'm gonna cut it
off there there's the last bit I'm gonna
run out of time for but that's what I
have for you and thank you very much all
right the question is what in what at
what point do we involve business and
the answer that is is these engineering
teams I was talking that about that are
very small they're typically made up of
about two to two to five maybe two to
six engineers and then a designer maybe
and then a product manager who is
essentially representing the business so
we will have in terms of planning we'll
have generally about three months bands
that will plan out we'll do some core
like very thick brushstrokes of what
quarterly planning looks like and then
each of those teams will will be like
sort of running off on their own
it's very decentralized whether they're
getting what they want
yes so part of the metrics collection is
also a large amount of business
intelligence that we collect so within
that team we're able to if we're if
we're deploying a test or deploying a
new feature we get a very rich amount of
data that comes back from the site that
we that informs the business of what
goes next and whether things are working
as we expected thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>