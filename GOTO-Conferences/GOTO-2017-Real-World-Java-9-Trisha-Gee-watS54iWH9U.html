<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • Real World Java 9 • Trisha Gee | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • Real World Java 9 • Trisha Gee - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • Real World Java 9 • Trisha Gee</b></h2><h5 class="post__date">2017-06-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/watS54iWH9U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and it's really nice to be back in
Amsterdam the first time I was here I'd
go to Amsterdam was about my third ever
presentation so I was insanely nervous
and now I'm not insanely nervous but I
probably should be friendly
hello I'm sure sure I work for JetBrains
I am the advocate for intelligent idea
and up source and what that kind of
means is that I have set up to date with
what's happening in the Java world and
particularly obviously the big news at
the moment is Java 9 so my job today is
to try and look at how the Java 9
features will impact odds as Java
developers and which ones we might
actually use in real life so we're going
to go over jigsaw in action so I really
I didn't want to talk about jigsaw
because everyone is going to connect
jigsaw all year this year for Java 9 and
it's like the big ticket item and don't
tell anyone but I don't think it's very
exciting so I really didn't want to talk
about jigsaw but I did them I did try it
out so I do want to talk about the pain
of using modularity in Java and who
knows about jigsaw so far anyone a bunch
of you that's good I'm just checking you
our Java programmers ish right good
excellent
I'm hope using Java 8 oh my god that's
like all of you this is really good
you're exactly the right audience for
this talk so I will talk about jigsaw
even though I really didn't want to so
we will go over that and the original
goal of this presentation was to talk
about reactive programming in Java 9 the
reason being that the reactor streams
API is embedded in a language in Java 9
so I want to see this big reactive
programming thing but it turns out
there's so many features in Java 9
there's just not a lot of time for all
of that so we'll skim over what that
looks like but we won't go into it in a
lot of detail and then we'll talk about
all of the other stuff in Java 9 now not
all of it just the bits that are
interesting so if you do decide to
migrate to Java 9 don't do that just yet
but if you do want to then you're going
to need some arguments as to why why use
Java 9 now the Oracle guys in particular
have been working very hard as usual on
the latest version of Java so it's not
just
adding modularity there's loads of like
free stuff like better performance
better use of the CPU better
documentation better graphics blah blah
blah so even if you don't use any of the
Java 9 features you will get
improvements probably if you use Java 9
the slides will be available afterwards
so and this talk never ever comes in at
50 minutes so I'm going to talk really
fast
I apologize and skip over a bunch of
slides so if you're interested in the
detail you can put the slides after and
of course jigsaw is part of Java 9 you
may have heard as a repple who's heard
of the repple in Java 9 loads of you who
has heard of a referal generally or used
one okay so the wrestle for others Java
developers I think the repple is a
fairly is a very new idea so it allows
us to try out things from the command
line so we can type like a single line
of code and have it execute which for
Java is very exciting you don't have to
have a whole class with public static
void main or any of that nonsense you
don't have to create entire test files
just to just to create like a little
tiny trial Smith it of code you can do
that from the record and the repple is
going to be part of Java 9 we're not
going to cover a lot of that because
that's kind of a big topic in its own
right as well so if you think about Java
9 you hear about jigsaw you hear about
the rep or maybe and you don't really
know if there's anything else in Java 9
that's particularly exciting for us as
Java developers but it turns out that
it's just one or two other features that
went into Java 9 sits a couple and some
of these you won't see there's a lot of
stuff under the covers I mentioned some
of the performance improvements there's
things like they wrote performance tests
for the JDK itself and there's a lot of
infrastructure stuff that went on that
doesn't necessarily they're not features
that we'll use but they will hopefully
impact us in terms of a better JDK a
better JVM but there are things in here
that we won't have heard of small
features that I do want to cover in this
talk I always like to set the
expectations appropriately low so do not
put Java 9 into production it's not
ready yet
it's not out yet recently they were
saying it's going to be else in July now
they're proposing September so it's not
out yet however you can try out the EA
version of it which I do highly
recommend but it is evolving and
still evolving to the extent that even
the api's are still changing so each API
will behave HEA will behave slightly
differently I've just updated this demo
from build 166 which I used early on
this year to build 173 and there are
changes in those in those builds and the
other early access thing is IntelliJ
IDEA so I'm using IntelliJ IDEA 2017
point to EAP which is as always this ApS
an interesting experience and sometimes
crashes horribly so like I say setting
expectations appropriately low but the
2017 point to EAP has a bunch of jigsaw
features which I really want to demo so
I have to use all the early access
things to kind of show you this stuff
the case study and you may or may not
have seen an earlier presentation I did
was called Java Aiken anger and I wrote
this is like a Java effects UI which
I'll see if I can show it to you and it
kind of reacts in real-time to like
Twitter messages it says like how happy
or sad they are who's doing the most
tweets and stuff like that and this was
designed to show off the Java 8 features
so there's like streams and lambdas and
stuff oh no blah blah blah blah blah and
and what I wanted to do was use this
because it's a real it's a real piece of
code it's kind of demo code but it's a
real piece of code and I wanted to see
how much pain it was to migrate towards
Java 9 what the advantages might be so
we're going to use this code base and
try and use some of the Java 9 features
in it the other good thing about it is
is they're kind of where I wouldn't say
micro servers architecture because it
doesn't have good micro service and
stuff like you know reliability but it
does have independent services which can
which were designed to pass messages
between them so this architecture works
quite nicely for the reactive paradigms
so that's another reason why I wanted to
use this case study if you're interested
in the original case study then go away
and look at the video of that I'm not
going to do any of the background on
this at all so because it's just a waste
of time there's loads of videos on that
already as I said I'm going to go quite
quickly
first up compiling with Java 9 if you've
heard anything about Java 9 it's
probably that everything is going to
break that's not strictly true but there
are a lot of changes which may impact
your code so the first thing I wanted to
do was compile my Java 8 application in
Java 9 and and see what breaks so let's
go ahead and do that
ok so let's switch switch to an
appropriate branch which has got which
is my original code so this is my if I
compile this we build the whole project
this is my original Java 8 code building
on build 173 of Java 9 let's put this
into presentation mode so you can see it
properly right so the first error we get
is that as of release 9 underscores a
keyword may not be used as identifier so
this is something I did sneak in to show
an error I didn't really have something
which is called underscore it turns out
honestly I promise it turns out that
under school was a perfectly valid
variable field parameter name and and
it's not going to be going forward but
now everyone knows that it's a valid
field name people are like oh that's
quite interesting I could use that it's
going away don't need it so that's an
easy fix something useful just rename it
to something else but if you are using
underscores it won't work anymore in
Java 8 you'll get a warning about that
so you should see that that's something
you shouldn't be doing ok what else
happens if I recompile so this is the
sort of thing that we will have heard
about we read anything about Java 9 the
encapsulation of internal api's so
anything which is some misc which we
shouldn't have been using in the first
place but we did because sometimes there
wasn't an alternative in this case I
genuinely was using this class in my
Java 8 one because I was like oh that
does what I want I know
not supposed to use it but it does what
I want so I'm going to use it anyway
which is what we are to so you can't use
that anymore basically the compiler says
and it's not there now it is there it's
just hidden away so you can't access it
anymore
and so I need to get rid of that and
replace it with whatever the the
replacement is and in this case it turns
out it's fairly straightforward
I need base 64 Java dot util get the
controller and codes of strings rebuild
and everything will work so generally
speaking if you're using some miss
position that's been in the first place
you need to replace those anything which
has a valid replacement in Java 8 or 9
is documented so you can see what the
replacement should be there are a couple
of exceptions which don't have
replacements most notably some misses or
unsafe so unsafe is a special case and
has been it's been given it's been given
leave to continue existing for the time
being because there isn't a full
replacement for unsafe but an you
shouldn't be using unsafe if you don't
know what you're doing anyway that's
what they say that's what I have to say
that's the official line and when I did
my last annotation here I was talking
about the destructor and the destructor
does use unsafe because it has to use on
face and that's that's where it goes and
right so compiling with Java 9 you may
find there some things which are broken
but probably not as broken as as you
expected one of the things I wanted to
recommend is that you drop the Java 9
JVM into your continuous integration
environment and spin it up and see if it
runs and it turns out that lots of CI
servers don't support Java 9 yet so that
might not work so you might yes
download it give it a go see what breaks
jigsaw let's talk a bit about jigsaw and
because you know everyone's going to
talk about jigsaw now this is my
original project structure it is modular
I was using make Gradle plus IntelliJ to
kind of split it into modules I had this
kind of micro service type architecture
so it lends itself to modular code but
it turns out that when I went back to it
later to turn it into proper modular
code I hadn't done it right who knew so
what I had done in the original one is I
had a mod
for my UI code a module for my shared
infrastructure code and the module for
everything else all of my back-end
services and I didn't notice this with a
problem probably because I am NOT
responsible for deploying this code
because it's demo code now if I had to
deploy it as small independent jars I
probably would have split it up
differently
I'm with jigsaw with the Java module
system you're forced to think about what
you're going to deploy which jars you're
going to deploy and how your code is
modular eyes like as a developer that
something you have to think about which
is I think it's kind of a good thing so
when I modular as my code I ended up
with a module for my UI code a module
for my shared infrastructure code a
module for another utility and then all
of my other services were independent
modules so it was actually more correct
so jigsaw kind of forced me to think
about this more correctly so I did it
wrong to begin with but I didn't have
anything to really tell me I was doing
it wrong and when you oh yes and the
other thing is that grater doesn't work
in Java 9 they're working on it and I
keep pinging them every week saying is
it done yet and who's it done yet Gradle
doesn't work in Java 9 it will they are
working on it the problem is that Java 9
has been moving so fast that Gradle were
like we're just going to wait for DES
stabilize a little bit before we start
trying to catch up
maven does work Gradle doesn't so I have
to rip Gradle out of my project groovy
at the time when I first wrote this in
February groovy wasn't working with Java
9 I don't know if it is now so I can't
categorically state so I stripped out
all the groovy tests as well turn them
into J unit 5 tests and it turns out
that I mean I really like spots for
testing but what I noticed when I was
using J unit 5 is that the tests run
much quicker now so I'm not using groovy
which is sad but true
so as well as restructuring my whole
project I also had to rip out Gradle to
get it to work and I had to rip out
groovy to get it to work and then I can
jigsaw wise my code so what this means
is are you cut to that very well but you
have a magics new file called module - -
info Java and that defines the modules
it doesn't just define what the module
looks like it also tells things like
IntelliJ IDEA that you're using
so you can pile with module module path
instead of class path and this is where
all the magic happens so the thing about
jigsaw about modularity that I hadn't
really realized till I started doing my
research is when you use modularity
there's no such thing as a class path
anymore
that was sort of part of the point to
try and get rid of this enormous monster
and trying to treat code as separate
individual modules so when you start
using module info files you have to
start using module passing center
classifier I'm not going to go into
details of that but just be aware of
that because I didn't know that class
path was like a thing of the past it's a
dinosaur it's dead but except you can
still use class path if you still want
to use class path and that's part of the
the noise around when do we release Java
9 what does jigsaw look like what are we
allowed to do what we're not allowed to
do lots of people still want to use a
class class not surprisingly and the
other thing is so my structure here is
I'm using a grader style structure which
has got the module with a source
directory and a test directory and my
tests are actually doesn't have a module
file because then I'd have split
packages across two different modules
there is a way to fix that I didn't do
it for this demo and I run the test from
inside the IDE so it doesn't impact me
that much so moving to use a modular
system was a non-trivial task for me the
suggestions from the the demos and stuff
from the Oracle guys is that your
structure has a source directory at the
top level and your modules are inside
your source and then you have a test
site between modules inside that which
is what I did when I first migrated but
that's like I obviously if I was using
Gradle it would completely freak out
about that so it's a totally different
way of working but you can do it the
sort of more traditional Gradle Maven
way and it still works it's fine right
so we're talking about architectural
type stuff so I thought I'd put some UML
up here I generated a diagram using
IntelliJ because I'm lazy and what I
wanted to do is when I was starting to
split my project into modules I needed
to understand my dependencies to figure
out if I had things correct and it turns
out I don't have them correct
because I have my modular code from two
different services to
upon code from another service which
isn't right it can depend it can listen
to messages from that service but it
shouldn't be reusing code from there I
have one jar file which is only used by
one particular module which made sense
it's no sense it's an API which
shouldn't have been being used and I had
a reactor streams jar file which was
used by two different modules which also
made no sense it should either be used
by one or all of them and so by actually
mapping out my dependencies I kind of
figured out I designed my application in
a slightly weird way so i redesigned it
so all my services are now at the same
level they don't depend upon each other
code wise which is the right thing they
depend upon my reusable infrastructure
code and they depend upon my only
utility as well my back-end services all
depend upon this reactor streams utility
and two of my services care about one
reactive implementation and another one
cares about a different reaction
implementation the idea here being that
I'm using react so streams API so I
don't care about the implementations in
the independent services and so that's
the dependencies diagram I was talking
about our intelligence and our jar files
this is not the same as a as a JDK
module diagram so if we look at one of
these modules to client the UI module
let's look at what the module diagram
looks like so this is kind of quite a
different way of looking at things so my
client uses Java effects so it's
dependent upon a number of Java FX
modules from the JDK specifically FX ml
controls and Java X base and you can see
there all the dependencies inside there
of all the modules they depend upon so
all those yellow ones are inside the JDK
itself and the point about modularity is
that you don't have to use the whole JDK
you just define which bits you want to
use so here I have to say I want to use
these specific bits of Java FX and
apparently that will have all of those
other dependencies my back-end and
service module depends upon jar file
which has not been modularized so it
doesn't look as pretty as the the jdk
dependencies what happens when you
when you're depending upon a jar file
that hasn't been modularized as it gets
turned into something called an
automatic module and this is something
else that people are arguing over what
do automatic modules look like what
should the name be how do they work and
in this case I'm dependent upon one jar
file which is the WebSocket server
impulse and that translates to three
different automatic modules because it's
based upon package name so if there's
something to be aware of like there's
not a one-to-one mapping between the
idea of a module and the jar and and the
point here is that the jdk modules there
are lots of them and you have to
understand how to work also this new and
this module diagram is new in IntelliJ
IDEA 2017 point two so I kind of want to
show off as well but it's quite useful
when you're starting getting started
with jigsaw to understand the
architecture it's quite useful obviously
to draw this out to figure out what
you've got so you can see if you're if
it matches your expectations so given
all of that preambles which was supposed
to take five minutes and didn't let's
look at what happens if we want to
create a module info file so let's look
at this from a code from a developer
point of view and see see how hard it
really is I'm going to switch it to the
right branch
so what I've got here hmm I've got my my
different modules most of these have a
module info already I've got one module
which doesn't have one so we're going to
create one for this module obviously I'm
going to make the IDE do it for me
because I'm really lazy and once I start
doing that when I compile as I've
mentioned before the the way the
compiler works is now different it's not
dependent upon all the code on the class
path you have to start defining the
modules that you care about so if we
have a look at this class for example
previously I was dependent upon Java
util lager and and that was fine and
that works and it compiled and now I've
just added a single thing I've added the
module info file now that no longer
compiles and that sounds kind of weird
but it's because you need to
specifically state that you know you're
using the module Java logging so if we
add that let me show you my module info
we have to say we require Java dot
logging by default what we get I don't
have to say this I'll just show you what
it looks like by default we will get
requires Java dot base I don't have to
say that and Java doc base has things
like Java dot util and most of the basic
stuff that you use all the time so you
don't have to say you need that for
anything else outside of the base
package base module you have to
explicitly declare that you're dependent
upon a different module so in this case
Java dot logging and the other thing I
need is I'm using an external jar file
I'm using react to streams so I need to
tell the module info file to look for
those modules even though they're not
real modules so here I say it requires
reactive streams if I drill through to
that
there we go it's loading up that means
it's using this jar file here okay so
the good thing is that IDE can do a lot
of the heavy lifting for you if you're
not keen on the idea doing heavy lifting
for you you can use a tool called J dips
which will analyze your dependencies and
it will tell you which modules you are
depending on and then you can basically
copy paste all those modules into your
into your module intro file and then it
should work
I believe you can use J dips to generate
your module info file but I didn't I
couldn't get that to work last time I
tried I think that might be in a version
that's not out yet and so actually build
what's the other error we've got
now if I want to use the the flow module
from another module this is the module
flow does not export the package send
stop flow so the if I want my module to
be used by other people which presumably
I do because I created the module I need
to say what I export so I'm going to
export just that package what that means
is that the whole point about modularity
is to allow you to encapsulate your code
so what I what I could have is if I'd
had another package here let's say new
package if I had an import package I
didn't want you to access then I don't
export the import package and you can't
do anything with it you can't access it
so all of my internal details are hidden
away from you and that's the point of
jigsaw really not just the spitting out
your code but hiding stuff that you
don't want people to see alright so
let's talk about the pain of moving
specifically to jigsaw and some
structural reorganization may be needed
not as much as I originally thought I
didn't have to restructure everything to
follow the the JDK way of doing stuff I
can still continue to have modules in a
Gradle style structure but I did have to
do some structural reorganization but
that's largely because I hadn't been
designing my application in a modular
way to begin with so it's kind of my own
fault for not doing it right in the
first place and this project has no
command line build because I don't have
Gradle I just take Gradle out so
everything is done through the IDE all
the dependencies are managed through the
IDE running the tests is done through
the IDE so it's not super real-world
application I do want to try this in
maven to see if it works out properly
the IDE support for new functionality
specifically jigsaw but Java 9 stuff is
not quite as mature as it is for other
stuff and so you could see that I could
add modules into my module info file but
I can't generate my module info file I
couldn't generate the exports statement
yet either so this stuff is is coming
it's we're working on it we have issues
for all of it but mu4 jigsaw
specifically it's a good idea to
understand what's going on under the
covers
so that you know what to do it's a raw
level because the IDE can't fix
everything for you and do if you do want
to use jigsaw if you do want to use
modularity you really do have to do your
homework I did a lot of brute force
trying to figure out what my module
files look like let me show you an
example so I don't show you the others
let's look at the client one this module
info I brute force my way through this
so I basically fixed all my compilation
errors the Java compiler will give you
useful messages like you need to depend
upon this module or you need to export
that so it does tell you what's wrong
but it just takes a while to brute-force
your way through that plus some of the
errors only come when you start at the
runtime not just at compile time so
don't do it my way because it took about
two days to do that
run jada and figure out how J tips works
I was really lazy I couldn't figure out
how to get the J tips to work so I was
like oh how hard can it be two days
later and we should just figure out how
to use J dibs
so do read the manual and otherwise
he'll be totally lost especially this
difference between module path and class
path that is actually what stopped me
being able to run J tips because I
needed a module path not a class path
the advantages you do get a cleaner
design it is better design it's better
encapsulation better separation of
concerns and you do get I'm not sure
deployables is a word and you can
potentially make the code that you
deploy your jar files smaller which can
be a good thing particularly in the IOT
worlds maybe in cloud if you're like
paying per byte I don't know but it can
give you smaller coder deploy for
probably most applications particularly
enterprise applications that will kind
of run on site I do not think these
benefits are worth the pain
certainly not straight away the
important thing to know though is you
don't have to use jigsaw to use Java 9
this is all optional so if you don't use
jigsaw you don't add module info you're
still using the class path you're still
working with jar files the way you used
to everything should work the way you
expect it to
so don't go down the jigsaw path just
because you think you should because you
don't have to and I don't recommend it
either
right let's talk a bit about reactive ap
I have 20 minutes on jigsaw okay hi
let's talk a bit about the reactive API
in Java world or the JVM world it's not
just Java we have how to react to
streams API for a little while in 1.0
and the reactor streams API has most
importantly a publisher and subscriber
and it's also got a processor which is
both of those things combined and a
subscription to help you manage your
subscriptions and so there are lots of
implementations as there's actor reactor
rx Java vertex a bunch of things like
that so if you're using a reactive
streams library it's most of them like
rx Java 2.0 onwards will support the
reactive streams API it turns out that
the the Java guys thought this is
important enough to actually build it
into their language so the reactor
streams API is part of Java 9 and it's
not just part of Java 9 it's actually
part of the Java base module so it's
part of the free stuff you get so it's
kind of like seems to be suggesting that
the react programming is going to be I
was going though way to go but like a
way a standard way of working at first
glance this looks exactly the same as
the REC 2 streams API it's not of course
and the package name is different so
Java dot util concurrent dot flow with
inner interfaces which match the same
names of the interfaces this is a bit of
a pain because when I was implementing
this one I am using rxjava and reactor
and they use the vector streams API and
I wanted my service staff to talk in
terms of the Java 9 reactive API and
then I have to adapt between the two so
it's a bit of a pain I'm not really sure
how the library developers are going to
manage that I suspect maybe multi
release jar files might help but I'm not
sure anyway be aware of that it looks
same it's not the same where do I use
the reaction streams API this is where
we come back to our case study so my
services are really stupid they use
WebSockets to talk to each other and
they basically they deal with strings so
I'm going to get string in and I'm going
to per string out and I'm going to do
stuff in the middle and the stuff in the
middle because it was a Java 8 demo the
stuff in
it'll effectively is a lambda expression
that map's a string to a string so
that's kind of that's what I was doing
so I can do something a bit more
powerful with reactive streams so I can
actually just say well let's assume that
when I get stuff off the WebSocket I can
publish it and people can subscribe to
me to listen to that information the
business logic can now use the power of
a reactive implementation to do
something with that and then I can have
a subscriber which listens to the output
of whatever the business logic does and
then put that back on the WebSocket it's
still the same functionality but
potentially can give me a lot more power
so I'll just take a quick look at how I
implemented this so my look at the
publisher to begin with my publisher was
a class called client endpoints so I
made this implements load up publisher
which is the Java 9 reactive streams API
and this has a single method on it
subscribe so something a subscriber will
subscribe to me so I'm just going to
implement that here I get given a
subscriber and I've chosen in my service
code to create my own reactive
implementation don't recommend doing
this by the way because other people
have done this and done all the hard
work but all I really wanted to do with
management descriptions so I just
basically create some subscriptions have
a list of subscriptions and then when I
get something off the WebSocket I just
tell all my subscribers about that
so my implementation is quite it's quite
simple so I can write my own
implementations I think it sounds simple
that took ages to implement of course
because you know everything always does
so on the other end my subscriber end I
have broadcasting server end point which
can the point is that anything can be
like I have a number of things listening
to the WebSocket there and this
implements subscriber the SUBSCRIBE is a
bit more complicated I have an
unsubscribe which
subscription on next which is the main
thing which does something when I when I
get something from as a subscriber when
I get something what do I do with it on
error and on completes at the end of it
what do I do at the end so my
broadcasting server endpoint has
unsubscribe
unsubscribe all I'm going to do is to
say give me everything you've got
just like everything not just some set
of values on next is the main thing so
I'm just going to publish anything I get
I published that on the WebSocket to
anything that's listening to me
on error do not do this because I was
writing the demo because I was learning
stuff you know I did stuff that the
simplest quickest way possible and I
would like to call out that if you are
working with reactive streams the
simplest quickest way possible is not to
do nothing on error these are
asynchronous messages and so if
something goes wrong you have no idea
you don't get stack traces you don't it
doesn't stop it just just doesn't do
what you want it to do and you've got no
idea why so this is not a quick way to
learn reactive programming always do
something with error message even if
it's just printed to system out and on
completely closed of WebSocket so again
I've got a fairly simple implementation
of this I will come back to the error
handling obviously so now that I have
done that where do I apply this what's
the point what's the point in kind of
changing my whole infrastructure to
expose reactive streams this reactor
streams API well I put one specific
example of it 15 minutes I will never
get this talk to under 50 minutes and
let's look at one example what I had
here I'm like I was saying before one of
the points of this demo is to
demonstrate Java eight streams so I've
got a lot of suffered streams and lambda
expressions what I could do instead of
using Java eight streams for this is use
react histories what the functionality
does is I'm reading a file and for every
line in that file I'm going to filter
out some noise I'm going to insert
a delay of 100 milliseconds because
thank you windows for wanting to restart
my computer this is demo code so I kind
of I want the stuff that displays on the
screen to not like just get fired at the
screen I want to delay of 100
milliseconds so that you can see it
ticking over and then I'm going to
publish that string so we can do the
same thing with reactive with reactive
streams I'll come at that I'm going to
use our extrav are for this particular
implementation so we have flowable so I
need to add reactive Rx Java to the cuff
cuff and I need to okay fine import the
class and then I need to add requires rx
Java to my module info that's my Java 9
overhead and so flowable from iterable
I'm going to do basically the same sort
of thing I could do before but I don't
get a nice try with resources
functionality because it's not it's not
quite straightforward but we'll do
something similar and then I can feel I
mean we use all of that peak in Java 8
we'll do some operation on everything
which comes through the pipeline of that
stage and in our extra hour I can say do
one next instead is the same same
functionality basically so I can use our
extravasated
Java 8 streams to do let's get rid of
the Java 8 version so now I've got
slightly more code it's not quite as
pretty and I depend upon an external
library to do exactly the same thing but
I'll show you why this might be an
advantage I was always uncomfortable
with this is kind of like use the kind
of server the debug peek method to like
inject 100 millisecond delay but it's
actually part of the business logic of
my application I want each each line in
the file I wanted to be delayed by 100
milliseconds in with reactive streams
you can do this in a slightly different
way so I can say flowable interval give
it an interval of 100 milliseconds
let's call it tick so this is a stream
which is just going to tick every 100
milliseconds it's going to make a long
value every 100 milliseconds now what I
can do instead of inserting this delay
here I can zip my stream of strings from
the file to my stream of of ticks at an
interval and then I have to say well
given I have a string from this stream
and a long from this stream what do you
want me to do with those two values well
I don't care about the long I just want
them I just want the string value and
then I can get rid of this and and so
that's quite a nice way of having the
same functionality and also demonstrate
something very different about reactor
streams versus Java eight streams you
can actually merge two streams together
you can use two streams at the same time
you can also do things that you can
reuse streams in Java eight streams when
you don't for each then this stream is
done and that's that you can't do
anything else with it but with reactive
streams if I have this as a stream in
its own right I can do and I can do
other stuff with a stream and and I can
reuse it so I can split streams and I
can merge streams and I can reuse
strings which I can't do in Java I have
another implementation as well which
uses reactor but it's basically the same
thing it shows that you have a syntax
which is very similar to Java eight but
the functionality is slightly different
in this in this other case I'm using
flat map and flatmap in reactive streams
has a very different concurrency model
to flat map in Java eight streams and
it's something to really be aware of
because it doesn't work if you think
that it just works in a single threaded
way okay so just to summarize the
reactive side of things I told you how
it's going to give you a really quick
demo of reactive and Java eight streams
and reactive streams look pretty much
identical the syntax is very similar but
they're not the same thing and they
don't work the same way
so reactor streams you can work with
multiple streams you can zip them you
can
you have multiple consumers back
pressure is a very very important part
of reactive streams and this is this is
a good thing
you treat back pressure as being like a
first-class thing to consider like what
do I do if the if the producer is
producing more than the consumer can
consume do I drop messages do I block do
I send a message to the user saying stop
pressing that button so much I mean that
what do I do
under the case where when I have that
pressure and has a very different
concurrency model there's like threading
going on these are covers sometimes
you're not aware of where as Java 8
streams are single threaded unless you
tell them to be parallel and but the
point about the Java 9 reactive API is
that you can expose your active API and
use whichever implementation you want to
under the covers so in this case I used
rx Java and reactor I could even be
using different jvm languages and but
they're still talking in the same API so
that's a really good benefit all right
oh good I've got 10 minutes that other
Java 9 feature this is fine there
weren't many of them
I think the most used Java 9 feature is
going to be this convenience factory
methods for collections and I'll show
you why let's take a look in the olden
days ie now and when we want to create a
new list we say arrays door as lists in
the New World Order I can say list of
I've just saved myself six characters
yay and the implementation of list is
slightly different it is an immutable
list but I believe arrays door as list
gives you an immutable list anyway it's
just a slightly different type of a
mutable list so that's great
most used feature no so let me show you
why it's interesting let's pretend that
we have a set instead now currently if
you want quite a set like the most
succinct way of doing it is to create a
list and then put it in a hash set and
then put it in a set now of course we
don't have to do that anymore
tada and that's the immutable collection
as well so this is a good thing and of
course you can make this narrower let's
get rid of that and then in at some
point in the near future new features
like Java 11 you might be able to say
that okay probably not for a constant
maybe for like a variable but um so you
can see how we start to get rid of some
of the boilerplate that everyone's
always moaning about in Java the other
places is really interesting
particularly cuz I used to work for
MongoDB and we used to create a lot of
maps is this is just again this is code
that existed in this application I
needed to initialize a map this way and
this is in the production code not in
the test code and it's not uncommon to
see this and it's ugly and horrible but
it was the only way I had to do it but
not anymore I could say map of entries I
can use my very favorite column
selection mode map store entry I can use
the most used feature of IntelliJ IDEA
replace await now I need to replace it
with that
and and so now this is how I create my
my map it's a bit smaller it's not like
those smaller but it is a bit smaller a
bit more succinct what's really nice
about it is if you've got fewer than ten
get rid of conflict
you've got fewer than ten you can say
map off and you can get rid of all of
this I happen to call them flick our
IntelliJ don't let me down now oh you
hate me so much
fine let's use the most used feature I
told you it's an EIP also I'm using a
surface
so away all right so and then I can just
give key value pairs if it's a fewer
than 10 so you can see I've got key 9
there so that's quite nice so this would
have been super useful when I was
working at MongoDB three years ago and
it's still not out yet in Java 9 but and
it's not quite as pretty as perhaps the
groovy way of creating maps but it is an
enormous step in the right direction so
working with collections is just going
to be an awful lot easier in Java 9 and
I honestly this is the thing I think I'm
going to use most from Java 9 more than
anything else
report Oracle developers they work
really hard on Java 9 for seven years
and I'm like oh I really like your
collection methods it's great if you use
jigsaw no we dope you Tilley and right
private methods on interfaces this might
seem really stupid because what is the
point of having an interface which
defines your API and then having a
private method on there now let me show
you again this is real code which was
actually in Maya predation and I have to
have duplicate code without being able
to extract it into a reusable method
because in Java 8 as you know you can
have static methods on interfaces and
default methods on interfaces so
interfaces don't just define them as a
signature they actually have behavior in
them so you could potentially in Java 8
have duplicate code I could of course
have extracted this into a method get
value for field and sat down and but I
didn't want this to be part of my
interface so I don't want this to be a
public method and in Java 9 it doesn't
have to be ok
so it's super useful for static methods
and for default methods otherwise it's
really stupid to have a private method
or interface and this is part of a
bigger jet called milling project coin
and there's loads of little bits and
pieces in this about better ways of
working with generics and anonymous
inner classes and some other things
which just tightens up some of the
syntax new methods on the streams API so
Java 8 streams can have let's turn this
back into Java 8 streams
think that and this as well Java edge
streams Java a streams can be infinite
streams the same less reactive streams
are designed to the infinite streams
Java 8 streams communes in extremes I do
not recommend this this is very
difficult to terminate streams in Java 8
plate those are very it's very difficult
to say I'm done now pleased like let's
get over it and now in Java 9 there is a
way of saying take while so take while
some predicate is true so let's assume
that our file of of tweets let's say it
was ordered and each string started with
like a number so let's say I want to
take the first anything which begins
with 1 through 5 then I could say I've
started it starts with so I'm going to
take while and it doesn't begin with 6
and then when I get to the first entry
which begins at 6 I just stop the stream
and it terminates it I could potentially
combine this with drop while and I can
say a start starts with I don't - so I
can take everything from like 3 through
5 so this is going to be I think this
could be really useful if you're working
with infinite streams it's particularly
useful if you're working with ordered
streams obviously because you want to be
able to say like while like it's not the
first set of values and ignore the last
set of values you can you can use it to
cheat and do some other stuff so I had a
running field so running equals true and
then I can set running equals false when
I actually want it to be false and then
my stream will terminate so I can do
that also it should be an atomic boolean
because it's multi-threaded and black
but you get the idea it's possible to
terminate things with external and
criteria as well so that's really useful
and in my opinion should have been there
from the beginning but you know these
things are difficult to see
and set walking API this is everyone
knows it creating or getting a stack
trace is quite expensive right and now
we can do things in a more lazy way now
that we have things like lambdas and
streams and stuff so that we can we
don't have to get the whole stack trade
and then do something with it we can
kind of build it in a lazy way and I
don't know all of the ins and outs of it
but I've only played it a little bit but
what you do is you get a stack Walker
and then you get you end up with
slightly complicated syntax stack frame
stream which is a real stream I put this
down here so I can do the sorts of
operations I expect to be able to do so
when I filter it so I could say I don't
know I want to filter out anything where
my set frame starts a stack frame get
class name starts with I don't know like
my package name and then maybe I want to
be something like count how many
instances of my classes are in that
stack frame I mean I'm not sure exactly
what you might want to do but the point
is that you can that's not what I wanted
to do and so you can do things like you
can basically do queries on the stack
frame as it is and it's not as expensive
as it was for of course if you do for
each then if it's as expensive as
getting the stack frame to begin with
but it's quite an interesting thing and
it doesn't have to be in an or in an
error message it could be it could be at
any point in your code so if you're
doing lower level stuff you might want
to figure out where you are what
happened and so forth a multi release
jar files this is like a big topic in
its own right I had a bit of a play with
us from now on potentially a library
might give you a single jar file which
is for both Java 9 and pre Java 9
versions just in a single jar file so
you know that at the moment if you're
using Java 8 some of your libraries
might say use this version for Java 8
and use this version for pre Java 8 well
from now on you just it will
the Java file itself will have Java nine
specific code if you're running on Java
9 otherwise it will use the Java 8 and
the 4 code note that this only works
Java 9 pre Java 9 you can't do the Java
8 version and a Java 9 version which is
kind of sad but going forward you'll be
able have a Java 9 version of Java 10
version Java 11 version so this is kind
of cool I haven't seen anyone using it
yet I heard of it the play it's not
impossible to work with there are some
best practice ideas that the API should
be the same between the different
versions so I'm not sure if this is a
solution to the the reactive streams API
problem or not but it's potentially
their process for API updates I'm kind
of really out of time so I'm just going
to give a quick show of what this looks
like and the main thing here is that you
can get your own kid so you get your
process ID now which is quite cool now
so I think that's the most useful thing
here there's loads of other stuff around
being able to build up command line
stuff and that's great but I think
probably the most useful thing is the
ability to get your amp it updated
deprecation this is kind of cool this is
all cool otherwise I want to put it in
here and threads here we go
now when you see deprecated methods you
can they can also be annotated with when
they were deprecated so Java 1.2 and
whether they're going away or not okay
so that's kind of cool so you can get an
idea of is this deprecated ml you
shouldn't really use it or this is
deprecated and if you don't stop using
it it will go away and your code will
break so this is really useful for when
we're looking at other library if you're
working on library code of your own then
do start using this because it's super
useful for for your users and what else
I keep moving the slides on so fast that
you can't take photos I feel ready sorry
you can generate html5 Java doc yay we
brought Java doc into the 21st century
only 17 years too late
this is great if you generate Java doc
of course this is kind of useful to know
mostly we will be reading Java doc so
it's kind of nice to know that our Java
doc won't be quite as ugly most
importantly this allows us to have a
Java doc search
look and it's got type-ahead as well so
when you start typing in there it says
what do you mean I don't know I suppose
Java dot util dot whatever and I mean
this so this is the actual Java 9 Java
doc and I've been using the search
feature on here and it is super useful
it's really cool oh what a shame I don't
have time to talk about the repple and
if you're interested in the raffle
there's a tutorial here it tells you how
to get started it tells you the sorts of
things that you can do from the raffle
if you have used a record before and you
kind of know what you want to do with a
referal and particularly how you wanted
to integrate with the IDE do tell us how
you want IntelliJ IDEA integrate with
the repple because we haven't done it
yet and we really do want to know and
use cases from from you guys ok in
summary I'm sorry I made you late for
lunch the pain of Java 9 your code might
break and so that my recommendation is
do download an early access of Java 9 do
try it out now figure out which things
break because it's probably not your
code it might be your infrastructure it
might be your CI server it might be
Gradle it might be something else it
might be a library that you're dependent
upon for this demo I had to migrate from
Marketo to point seven point eight to
mockito to point eight point nine
because it was dependent on a library
called bite buddy which wasn't working
with jigsaw with the version that I was
using so download it and see what's
going to stop working is probably not
your code it's probably something else
then the important thing here is that if
you find a library that isn't working
with it or you find a tool it isn't
working with it do tell the library
maintainer Zoar the tool vendor because
we don't always know what weird things
you're doing in your system and we need
to know like how how the pain that
you're feeling so that we can fix it and
it sounds unfair to put the work on to
you guys but when I worked at Mongo this
library is like a hundred classes it's
this tiny library including tests but
people were using in all sorts of odd
ways and there's no way that we can test
it in like a million different
environments it's just not possible the
reason why your code might break is that
there's a lot of stuff that's going away
deprecated stuff is being deleted in
Java 9 whoo
and there's a lot of stuff that the
command-line so garbage collection flags
and launch time JRE version selection
which I'm not sure I've ever used but
lots of things that you can use the
command line is just basically gone away
encapsulate most internal API s that's
the thing where some missed whatever
they all go away so it says encapsulate
which sounds nice what it means is it's
gone away you can't get to it and your
codes going to break and they've removed
a bunch of stuff that you probably
weren't using anyway oh yes deprecated
the after API someone asked me on
Mondays what's the replacement for
applet HTML not sure and there will be
some unexpected behavior I believe so
there's things here these are the sorts
of things that these are sort of changes
that people make think you know that
won't impact anybody and it'll turn out
that somebody somewhere is doing
something weird like looking at the GC
log files and like pausing the string
values to get particular errors to
figure out what went wrong and they've
changed a lot of the logging so they've
changed including some of the love
messages and stuff so some of that stuff
might impact odd things that you are
doing for me the number one thing here I
think well another thing is that g1 is
now the default garbage collector I
don't think that's a big deal because I
think if you care about garbage
collection you've probably tuned your
systems within an inch of its life and
you don't care about the defaults and if
you are if you don't care about the
garbage collector you're using defaults
and you don't care so I think it's not a
problem but be aware of it the one thing
which I think is going to bite people in
the arse and not realize it is new
version string scheme Java 9 is
officially Java 9 not Java 1.9 like Java
8 with Java 1.8 and when you get the
version string it comes back as 9 and
you'll see that some of the tools that
you use including earlier versions of
Gradle and earlier versions I think of
IntelliJ will tell you I have no idea
what this version 9 is or it might tell
you they've gotten out a ray out of
index exception as it tries to do one
point something and it's not there so I
think this is going to bite way more
people than anyone realizes to be aware
of it if you are doing any version
string pausing in your application it's
not going to work in Java 9 Java 9 is
still evolving its
evolving even now Oliver in June it was
supposed to be released next month and
the API is still changing gifs are still
changing a lot mostly for the better
those module info files that I showed
you when I first did this application
which is only February March they were
massive I had to define like every
single package I was using and now
they're much much smaller and much
easier to manage
so still evolving still getting better
IntelliJ IDEA is also still evolving and
we need your help as and the Oracle guys
on the JDK and the library developers
need the help of real developers to tell
us what pain you're feeling or what
features you want to see to help us give
you what you need and Java 9 I've
actually raised like two or three bugs
from Java 9 I thought I was being stupid
and I broke something it turns out I was
doing something fairly ordinary but
hadn't been expected so I've raised bugs
on the JDK and the JDK has changed
accordingly so they're still trying to
do that now better to do it now than
before it's actually officially released
it's worth it don't mush into modular
ization you don't have to use jigsaw to
use Java 9 and I don't recommend modular
eyes in your code unless you have to for
new applications I think it's a good
idea to think in a modular way because I
think your design will be simpler and
cleaner and it's kind of the way forward
but if you're working in a fairly mature
application I would not recommend making
major changes like motorizing your code
is the same as deciding to migrate your
monolith to microservices just for shits
and giggles which we've all done let's
be fair plan so yeah it might not be for
you do be aware that it's not a trivial
thing we access streams are not the same
as Java 8 streams they look the same but
they have different behavior and they're
designed for different news cases the
game jigsaw in particular encourages
good design and capsulation separation
concerns that's great Java 9 encourages
new ways of working particularly via the
repple via reactive streams and things
like that so that's good it's kind of
it's moving us forward is helping us to
evolve for me it's not like the most
compelling tag line Java 9 just a bit
nicer to write code but if that's
actually the most compelling thing
though it will be easier for us to
create collections there will be
slightly less boilerplate
we'll be things like being able to get
the kids for our processes and stuff oh
I think these things would just make our
life a little bit easier all the slides
all the resources all the links to where
to download Java 9 all the links to
pretty much everything is available from
this link this URL here so please do
take a look and because I don't have any
time for questions service or e thank
you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>