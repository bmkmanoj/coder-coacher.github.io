<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Unselfish Testing • Jay Fields | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Unselfish Testing • Jay Fields - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Unselfish Testing • Jay Fields</b></h2><h5 class="post__date">2015-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/f9eu4mMOtN4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright thank you for coming let's talk
about unit tests how many of you write
unit tests an tastic and how many of you
run your test suite before you check in
fantastic perfect so this will feel
familiar that's exactly where we're
starting so we're going to run our tests
we've just made some changes pretty
simple change and we get this this is
unfortunately far too familiar for a lot
of us we have failures and these are our
failures don't worry about a lot of text
on the slide we're going to dig into
this a lot you don't need to read it all
right now but what we have here is two
failures one for a statement method one
for an HTML statement method both in the
customer test class we don't even have
time to dig into the HTML statement
failure but we're going to dig into the
statement failure so the problem here is
we're in a terrible terrible position we
have code that we just want to check in
we ran the tests that we thought were
relevant to our code and we have two
failures we have no idea why we thought
we've done everything right and we have
no choices I mean really our choices are
fixed this problem or go to lunch we
really can't do anything else this is
bob bob has bad tests the problem is
that Bob is our teammate and also a
friend of ours Bob's a good guy he wants
to write good tests he wants everybody
on the team to be happy he wants to
write maintainable code not just domain
code with testing code he's trying to
help everybody out wants to do the right
thing everything's great except he
doesn't write maintainable tests he
writes terrible tests Bob left you this
failing test this is the statement
method this test isn't very long I don't
know half a dozen lines of code and yet
there's way too much going on here
specifically Bob decided we need to loop
in our tests how many of you use loops
and your tests come on you're lying so
Bob Bob also likes loops in this test
and we need to figure out when you'd
figure out what's wrong with this test
so we need to figure out what terminates
this loop pretty simple length but but
what's customers nor in the slide can
you find what customers is
if this is your screen nowhere on your
screen can you find find what customers
is if you're lucky you're working with
an IDE that helps you get there but but
just think about that for a minute you
need an IDE to help you get there for
the first line of code for a failing
test that you didn't write it's not a
great situation that's okay because we
have an ID so we go to the definition
and it brings us here customer test
class not a big deal we have some fields
customers great fantastic answer right
it's just just a Java array of customer
instances I mean what's the problem
problem is we still don't know what's
going on with these customers so we have
to go or use the ID again to bring us
here and now we have this magic setup
method that we're all familiar with this
template method pattern magically made
it into our X unit framework and never
went away so find usages brings us here
we don't even have time again to dig
into something the object mother for
this let's just assume that by some
magic we already know exactly what's
going on with our object mother and yay
we have customers took us all of those
steps just to read not even the whole
first line of code that's not great so
back to the failing test we're looping
through some customer instances and we
have you know what's the next thing you
look at when you look at a test you look
you look at the expected value that
should be pretty easy to figure out
except it's not instead we have an
expected value that's returned from a
method call so we have to look at the
arguments step one figure out what the
arguments are in this case as we all
know we need to look to the last
argument rental info again should be
straightforward except it's not because
we have to go to another definition and
rental info is a helper method to take
strings and rentals and returns a string
finally we get to something that we can
understand it took three minutes and 45
seconds to get to anything reasonable
for some value of reasonable never mind
the law of Demeter violation which we
would all of course change except were
three minutes and 55 seconds into just
trying to check in so we present and
that this problem is not there and we
continue on rental info loops over the
rentals and returns the string
describing
rental straightforward enough I guess
back to the statement method and what's
next well we have to figure out what the
next argument is it's a customer we have
no idea what customer we know we have
four customers we don't know which one
is causing the problem in fact we have
no way to figure out what our failing
test is without a print statement or
running our test in debug and putting a
breakpoint in there so this is not
exactly a great test we have a problem
and can't can't even look at the test
and figure out what's going on without
writing some type of code finally
something simple some type of string
literal even though it's being passed to
another method but but at least it's not
something we have to use the IDE to
understand so we take all of those
things and we go to the expect statement
and what does it do not much at all it
does not deserve its own method but
somebody aggressively applied dry Bob as
we know Bob thinks try always applies
and so Bob applied dry and has this
expect statement and all we're really
doing is a string dot format in here
it's not worthy of its own method so if
we're going to fix this test this is
what we have to work with we're forced
to digest all of this code we're forced
to look through stuff for about five
minutes and I'm familiar with it so I'm
going a little fast imagine you we're
having to go through all of this code
all the code that's on the screen
because you made a change in the movie
domain object I think about that the
movie domain object which you haven't
seen the movie test which you haven't
seen because you're in customer you made
a change in movie you added a new
feature everything's great and you have
failures in some other tests that you've
spent far too much time looking into I
think this is a bit of a problem I don't
really call that maintainable so what
all would I say about this code so far I
would say that it follows common testing
patterns I think there's probably a lot
of people in here that are like yeah
okay sure looks about pretty standard
there's probably some people that find
this code not too impressive but at the
same time it's just kind of the standard
isn't it this is this is what unit tests
look like these days people use setup
because it's there and they don't know
any better people use object mother
because it it's a pattern that's
established and
I don't know of a better alternative and
people use dry because dry is like the
golden rule of programming if you do
nothing else don't repeat those
characters yeah i don't know i don't i
don't think that's a really great way to
test but but that's kind of where we're
at where i think it fails and where I
think we should spend a lot more of our
time is we can't understand any of this
quickly all we want to do is check in we
really shouldn't have to go through all
this trouble to just check in our code
so let's let's review all again what all
we looked at we had to find the
statement test we had to find the
definition of the customers array that
we're iterating we had to find the
assignment to customers we had to digest
set up the assignment each customer in
their associated name we had to find the
object mother class which we skipped
because we don't even have time we
determine how the customer instances are
created then we have to digest each of
the different customer instance creation
methods within the object mother at this
point we understand the first line of
the test then we digest the expected
value that's being created by calling a
method with a string a customer and the
result of calling rental info with two
string instances and customer rentals
find the rental until info method and
determine the value it's returning to
expect statement digest rental info is
creating a string by iterating and
formatting rental data and now you've
mentally resolved the arcs to expect
statement you find the method and digest
it and at this point it's taken you ten
steps to simply understand the expected
value of your test not one character
that you have digested will ever run in
production you have provided no value to
your customer or to your business or
whoever you wrote the code for other
than preventing regression I mean at
least these tests told us that something
changed and something needed to be
looked at but other than that no value
no customer will ever use any of this
code that you've just looked through and
it's practically impossible as I said to
fix this problem without putting a
breakpoint in or putting some type of
print lining so this is bad this is the
state of the world this is the average
state of the world right now and we just
go about writing these tests and not
really asking ourselves why are we doing
this why are we applying these patterns
that do work very well in our domain
models why are we applying them to tests
blindly without asking ourselves is
there a better way to write these tests
is there a different way to code that
will actually create more maintainable
tests we write tests we don't need with
time we don't have to satisfy people we
don't like what if we took a step back I
do believe there's a better way I do
believe that we can write really nice
tests I hope we've begun to realize the
things have gone wrong really looking
through these tests things have
obviously gone wrong it's time to look
at unit testing with a fresh point of
view josh graham succinctly provided
what i believe is the best high level
goal for unit testing you can have your
own high level goal but this is my high
level goal this is what i like to think
of to create a tiny universe where
software exists to do one thing and do
it well one thing and universe are the
most important pieces here I want my
test to focus on a single thing have a
single responsibility if you will and I
want a tiny universe I don't need for
customers if I'm testing one customer I
need one customer so before we even get
into what changes we could wit make we
need to think about motivators what
motivates us to write tests in the first
place they're probably a lot of
motivators i would say these are pretty
reasonable motivators these are the
motivators that i think would would
drive Bob if Bob and I are working
together to write some tests so let's
say the Bob uses these motivators to
write his tests how do we feel like
Bob's doing given these motivators i
would say bob's actually doing pretty
well with enabling refactoring i have a
failing test that means i can refactor i
have some confidence fantastic immediate
feedback yeah works well enough run the
test suite I see things are broken
fantastic bob has no idea how to make
how to break this problem up into
smaller pieces Bob gave me for customers
that have nothing to do with each other
they're all in the same test but they
don't interact with each other in any
way whatsoever there's really no reason
they need to be together except Bob
wanted to consolidate characters Bob
blindly applied dry so again there's a
better way dry don't repeat yourself
hopefully everybody knows that it's
widely accepted as the golden rule of
programming or at least that's what i
like to call it probably when i'm
putting it down but it doesn't apply not
all the time i think it applies
contextually not dogmatically the test
we looked at or dry i don't think anyone
can argue that the tests are dry we use
the loop and helper methods we repeated
as few characters as possible but we
never stop to ask if that application of
dry would help future maintained errs
does anybody here feel like the
application of dry help them understand
this test of course not but the way Bob
wrote this test is he wrote maybe four
tests to start with and then he put the
whole thing in a loop because he applied
dry and he didn't really think about
future maintainer so he just thought
look how dry my code is look how many
characters I saved fantastic that
savings buys you nothing drying up your
code like that just takes away from
readability so there are three levels at
which you can apply dry I mean it's not
all bad it's not like we should just
throw dry away but think about how
you're applying dry most people apply
dry at the sweet fixture and test levels
so specifically here i'm talking about
sweet being global likely if we're in
java global static methods that's that's
a pretty decent place fixture fixture is
the methods and fields of a test class
this is so common so many people apply
dry there and i really don't understand
why and i'm gonna i'm going to do that
in one second but test test is a great
place to apply dry you don't want to
repeat your stuff within the test method
itself but you do want to switch to this
i think i would take that away from this
talk I'm here to strongly suggest that
you change your approach i recommend you
apply dry at the suite level that's
fantastic you want to create customers
could use a customer builder you want to
create movies use a movie builder you
want to create rentals use a rental
builder apply the Builder pattern
globally and any domain object that you
want to create within your tests use
that same builder that's fantastic day
one on the job you look at the tests and
you say oh I need a customer i'm using a
customer builder interesting let me look
at that day one you look at the movie
builder at that point you now know
everybody's using builders to create
domain objects I know where my builders
are defined so now i can create anywhere
in the whole test suite i can create a
customer or a rental or a movie and it's
all created the same way shared
knowledge same thing in a test level
obviously that that's great to remove
dry mean you don't or to apply dry you
don't want duplication within the test
but the fixture really the everything
you dry and a fixture can't be reused
that's the problem i have with it it's
it's reused within the single class but
every time you open a test from that
class you're coming fresh you have no
idea about these helper methods and what
they're there for so you have 10 tests
and several helper methods which helper
methods go with which tests I don't know
especially if one of them set up and
it's just magically used and then of
course the problem of everything that's
created in setup is not used in every
test so we have a lot of problems with
this but it's a pretty simple answer
just stop drawing things at the fixture
level so specifically testing diverse
customers at the same time is a bad idea
stop testing on related concepts don't
create unrelated data if you're not
going to use it just create what you
need and don't extract methods for a
single string return value or anything
silly like that there's not there's
often not much value in extracting a
method within a test because you're
forcing there's always conceptual
overhead of going somewhere else always
every single time so think about it as
if you were coming to that test fresh
would you really want the conceptual
overhead just to reduce a couple more
characters so we know of a few things
that could be improved but you know it's
all a little abstract right now we do
have concrete examples of exactly how we
can get all this done so the first thing
is simple we're just going to replace
the loop with individual tests not that
hard just break everything out break
everything out into four tests there are
a lot more characters here but you can
read exactly what's going on per
customer running these tests produces
the following output it's so much more
clear than trying to understand what's
going on with the loop this is instead
of the single failure for the statement
this is
three failures and we can see that let's
see here John has Godfather failing and
Steve does also and Pat does also how
about that we have a pattern that we
couldn't see whenever we had a loop now
we have some type of pattern that we can
dig into and figure out what the problem
is so back here we can see that
interesting John has get rentals so we
don't have that much info here either do
we we don't know exactly what John has
but at least things are broken out so we
know which tests are failing and it's
only after we've duplicated everything
that we're free to dry anything it's
okay if the duplication bothers you at
this point we're tearing it all down
we're tearing the loop auto out of our
code we're going to duplicate everything
and then we'll go back and look at what
we can can dry up later on but we'll do
it at the suite level not at the fixture
level so the next thing we're going to
do is expect literals here's how the
tests look now we're still calling this
helper function that really is not
providing us any value other than some
dogmatic application of dry so why call
a parameterised method once that does
nothing more than return a string you
know what the best representation of a
string is a string literal every single
time and that's what these tests give
you string literals for expected values
so there's no more looking around these
tests are significantly easier to digest
at this point I'm pretty sure everybody
knows exactly what's going on in these
tests and the final thing the problem I
brought up earlier you still didn't know
what was what those three failing tests
what they were what what cuz what type
of customer was that here we have no
idea what type of customer we have we
have Pat and we have John we have Steve
but that's not really clear enough but
here we put the object mother straight
in line we get rid of the setup method
and what we end up with our tests that
are easy to read so we know basically
what we know is that the one on the top
left works I could I could go back to
the failing tests but I won't waste your
time the one on the top left works and
everything else fails so it's pretty
safe to say looking at the object mother
def static method definitions we can see
that if we have 12 oh sorry 11 new
release
or new release and a regular etc etc
suddenly we can see what's going on by
reading the test is not kind of nice
what's even better is that we can delete
the setup method and we can delete the
customer fields so we're deleting code
and we're creating better tests but
setup is clever that's fine bob's tests
are very clever okay the problem is
clever is less maintainable in this case
the aggressive application of dry made
these stuff harder to understand that's
a real problem for me it's a real
problem for me whenever my teammates are
writing tests that are harder to
understand and it's even worse when I'm
writing tests that's hard for my
teammates to work with I mean it's a
pretty sure fire clue whenever somebody
comes to you and says I can't figure out
exactly what's going on with your test
can you come help me out chances are
there's going to be some type of
extraction because if your tests look
like this they shouldn't need your help
so you know what else is interesting
about all this in my opinion I said that
we were going to kind of expand
everything out and then we'd go back and
look at drive the thing is even after we
duplicated all this code even after
every change we made the overall number
of lines is barely changed it hasn't
changed but people dry things so
aggressively that they don't even look
at the actual impact to the code so I'm
practicing this presentation in front of
my wife and she says you're so angry can
you just cheer up a little bit and I
can't these tests are killing me how
many people in here are consultants so I
did consulting for quite a while and it
would be very common to run into test
that look exactly like this and it's so
frustrating you want to go in and
provide business value you want to help
a customer and they have somebody on the
client site who you can only gently say
there's a better way you know we can do
better and it just drove me crazy it
really did it really kills your
productivity it kills the team's
performance and there there are so many
rules that are applied dogmatically that
really just don't apply to tests and
we're only halfway there that there's
still many more changes we can make
but first we're just going to talk about
motivators because people don't even
take a step back and ask themselves why
are we even writing tests I mean there
are a lot of great reasons to write
tests but chances are there's going to
be I don't know six different things on
my list and not all six will apply to
every person in here in fact the
combinations probably everybody in here
will have three out of six that apply to
them and they'll be different and that's
okay you just have to take a step back
though and understand why you're writing
the test in the first place and then
make your tests match what your
motivators are specifically I'm
motivated to write tests whenever I want
to validate the system also known as
getting feedback or preventing
regression this is pretty standard code
coverage very standard for a while code
coverage was a main motivator for
writing tests a lot of people believed
in a hundred percent code coverage it
used to be some consultancies would put
that in their agreements we promise to
give you a hundred percent code coverage
and then they realized what a terrible
idea that was and stop doing that but
it's still out there there's still tons
of tests out there that were written
just for code coverage purposes enabling
refactoring one of my favorite reasons
to write tests pretty self-explanatory
documenting the system something I
cannot relate to something I've never
done but I've worked with some brilliant
people who just love to document the
system by writing tests when they come
to a new code base first thing they do
is read a bunch of tests it just doesn't
work for me it's so boring puts me to
sleep but but people can use in so it's
fantastic if I worked on a team with
three other people and all of them
preferred documenting the system via
tests I would have more tests you know
the test just has to have a positive
return on investment for me a test that
only serves to document the system
doesn't help I'm never going to go read
it more than likely but if 75% of my
team eighty percent of my team will
that's a great motivator your manager
told you to I would not be surprised if
there are people in here who hate unit
tests frankly the unit tests that I've
seen I hate them too sometimes maybe
you've given up on it a lot of people
have and I don't blame you and your
manager tells you you still have to
write them anyways now you're in a
tricky position right you're not a
believer you think it's a complete waste
of time and your manager makes you do it
I'm sure that motivator applies to some
people in here test driven development
the most common motivator I don't think
there's much to say also known as
breaking up the problem or improved
design it's a great motivator for
writing tests while I was a consultant I
once had a customer who would only
accept new features to the system when
the unit test suite was green the
customer couldn't read the test had no
idea what was going on in the tests but
if they were green things were good and
if they were red we weren't moving on so
that's an interesting motivator I just
suggest that everybody ask themselves
what motivates their team and what
motivates you personally might not
actually be the same as what motivates
the team and then you really have two
choices you should either conform or you
should probably go go find another team
honestly you have to do what's right for
the team you write a test for you the
first time you read the test but if you
leave a test that you wrote for you
you're doing a disservice to the team
you really have to think about what the
team wants what the team needs and
that's just as important for writing
tests as it is for deleting tests you
have to maintain every line of code if
there's only one thing that you remember
please remember any fool can write a
test that helps them today good
programmers write tests that help the
entire team in the future it's really
not about you it's about the team so
what else can we do what else can we do
not just to help ourselves but to help
our team the first thing worth
considering is this is your career and
it is ending one test suite run at a
time who has a test suite now no one
will answer this who has a test suite
that runs in more than 10 minutes there
you go some brave people thank you what
are you doing those ten minutes browse
the web Twitter I don't look at emails
you're not working on code and it's
breaking up your flow running that test
suite for 10 minutes and it's not really
that hard to make things better one
simple rule in your test suite will run
a whole lot better never cross the
boundaries don't go the file system
don't go to the network don't go to the
database that's it just don't do any of
those things
mock out those resources I don't care if
you use constructor injection setter
injection or something magical it
doesn't matter to me how you do it but
just don't don't do those things and
your test suite immediately will go up
100x thousand X does anybody in here
have in process computation is the
bottleneck in their test suite running
that is very cool you must work in a
cool domain and the percentage is still
great right the rest of you all you have
to do is don't go to the file system
network of the database and you're good
that's simple change alone will help
your team significantly there's one
other simple rule it's simple and
straightforward but this is a little
dense the class under test should be the
only concrete class found in a test the
last time I gave this presentation
somebody said what do I mean by concrete
I mean the implementation the actual
implemented any class with an
implementation if you can get away with
it should be the only class within that
test so movie class movie test customer
class customer test if you can get away
with it no movies in your customer tests
for example this test can be a bit of a
problem the test you've seen thus far
including this one are conflating string
building verification of summing points
verification of summing charges here we
have a customer method test method but
the results depend both on rentals and
on movies so of course any change to
rental or movie can also cause this test
to fail even though we're in the
customer test we have an implicit or
explicit dependency depending upon how
you look at it the test on the right is
the alternative rather than living with
the implicit dependency there's a really
simple solution all you need is a mock
here we have a mock that's really just
behaving as a stub which is pretty much
how I always use my marks to be honest
and that's it now any change to the
rental or any change to the movie that's
even farther down will have no impact on
this test I mean other than an API
change obviously but no implementation
within those classes will cause this
test to break
which is a great thing quick side note
you might have noticed no I'm sure half
the people were offended and the other
half thought I made a mistake null is
just a magic string here just like
Godfather over on the left is just a
magic string here if you have just an
aversion to nulls then sub the method
but me I I see no difference between
those magic strings so moving on we have
string concatenation now verified here
we have simple tests that also verifies
the total charge and the total points
you can introduce these tests that focus
exclusively on summing so now we have
even smaller tests we had what we
thought looked like a pretty simple test
we thought maybe single responsibility
because we're calling one method but
turns out not so much because that
method was calling other methods here we
just test them all in isolation and we
mock things out or stub as I prefer and
and we have even smaller tests with even
less responsibility and we're now well
covered fantastic everything's great
except we have you know this null and we
have zero points and that's a little bit
interesting so of course we need another
test which is not really a big deal I
mean this movie test is pretty
straightforward we have movies and we
specify the number of our we specify the
type and then we specify the numbers in
there are days and we get a charge for
the days and again straightforward tests
coming to this test fresh come to this
test when you want to check in you
should be able to understand what's
going on extremely quickly which is
great that's the goal you want to be
able to come to a test see what's gone
wrong and change it as fast as you can
this is a great incremental step these
tests make life so much better for our
team we now have confidence in
everything because it's all just as
covered as it was before so fantastic we
maintain that confidence but we have
isolation we feel comfortable it changes
to a given class will only create
failures within the test for that class
movie test changes movie or sorry movie
class changes movie tests fail customers
change customer test fail but they're
all isolated in a way using those stubs
that the other changes will not cause
those tests to fail no more cascading
failures one of the big reasons people
hate unit tests
okay so things are much better despite
my happiness with unit tests there's
still another test that I would honestly
right every single time the tests now
are very isolated and that's great but
we're only working with mocks so we have
no verification of integration right we
have a gap in our testing that didn't
exist before this is of course the
problem that we should address I mean we
we don't want to find this gap in
production so we get here this unit test
brings everything together and shares no
integration surprises and it feels very
much like I've contradicted myself
because now we have concrete classes and
what it really comes down to is that I
have different tests for what I'm
looking for the type of feedback that
I'm looking to get so this isn't it
confuse you instead I like to have my
unit tests serve specific purposes the
tests that have a single concrete class
are designed to test the code branches
in logic all of the tests that you saw
before tested all of the branches they
tested to get charged for the movies
with a specific number of days they
tested the string concatenation in
isolation but here we have one thing
that brings it all together so the tests
that you stubs I call them solitary
tests the steps that bring everything
together or the tests that bring
everything together like this the
integration tests I call them sociable
because the classes talk to each other
and I break these things up I actually
have separate namespaces in Java
projects so all of the solitary tests
live in one space and all of the
sociable tests live in another space
that way when one of them fails I can
look at the failure and say alright what
exactly am i testing here well what am I
worried about if it's sociable I'm only
worried about integration if I'm testing
code branches or corner cases in my
sociable tests I'm doing the wrong thing
I have a missing test there i have a
clue that i have a missing solitary test
no problem go right the solitary test if
the failure is in the solitary test then
maybe I have an actual problem my domain
or I just need to update the test but I
have tests again that are focusing on a
single responsibility so not only does
the test only test one thing but it's
also a specific type of test that tells
me where I need to go based on the
feedback and you separate them to make
it easy for you to know where to go
based on the feedback
how else can you improve things they're
a couple easy ways this is the movie
tests that we all saw if the second if
the second assertion fails none of the
code below it will run I assume
everybody knows that but have you ever
really thought about that how valuable
is that code the code below the second
assertion if it fails i think the easy
answer would be it's not valuable at all
because it doesn't run what what value
is there in code that doesn't run but
it's worse really if you think about it
there's no value in code that doesn't
run but it's still sitting there you're
still maintaining that code when this
test fails you have to go look at the
test and you have to try to figure out
what's going on so you have not only a
failing assertion but you have noise
below it and you have no idea what's
going on with that noise if you have
this failure you don't know what's going
on after it in any way whatsoever all
you know is that you had a charge for
children's and you expected 1.5 and you
got three point 0 so we go back and we
can see that we're expecting 1.5 in
several places so we have to use the
line number basically and we know
everything below that line was worthless
so that's not great I know of one
failure have no automatically generated
information about the remaining tests
given a test with multiple assertions
when they're all passing they all
provide value it's obvious it's easy but
when it fails all the value is removed
from the subsequent assertions and when
faced with a failing test with multiple
assertions you're forced to make one of
two choices neither one of them are good
to be honest one is read everything in
guess if it's going to work next time
and none of us will do that because
we're lazy as we should be instead we
will run the test we will fix the
assertion will run the tests and we'll
fix the assertion and we will run the
test and fix the assertion over and over
until everything works probably never
even stopping to think why am I wasting
my time doing this because it's become
natural to us it's just what we do now
or we could stop doing that what if we
ran the test once and we got all of the
feedback at once that would that would
be nice and it doesn't sound so crazy
does it but yet you talked a few
when you say how about one assertion for
tests and they think you're insane but
this is what it looks like this is the
same test only two of the four because
it's a slide but suddenly our tests are
easy can easy to consume again single
responsibility and so now we have a test
suite run that whenever it runs instead
of seeing one failure and not knowing
what else is going on we see three
failures we see that the charge for a
children's three day is one expected 1.5
and got three and four a four-day we
expected three-point oh and got 4.5 and
45 we expected 4.5 and got six so it's
just three failures by breaking things
up instead of having one failure we have
three but the sum of this is obviously
better it doesn't take a genius to
understand that suddenly the pattern has
come out that anything over two days is
broken but it's always off by 1.5 so now
you can go to your domain and figure out
what that entails did you did you break
the domain code or did the business
actually just say yeah that's the change
that we want to make but the sum of the
errors is better so why wouldn't you
want that information so the expected
return values give you valuable
information per test as i said the sum
is is better than the parts and every
time you write multiple assertions
you're suppressing valuable information
again not just for you more importantly
probably for your teammates to come here
without context so wrapping up a little
bit the second thing that I would like
you to walk away remembering if if you
willing to give me two things to
remember is the test it's you the tests
that you own end up owning you there are
so many examples of this and I love all
of them so bear with me imagine you're
working for an insurance company and you
need to look people up by their social
security number or whatever unique
identifier it doesn't really matter you
want to validate that somehow when
somebody calls up and ask about their
policy you need to be able to pull up
their file but what if their names jay
and instead it was j-a-y 1 i'm still
going to be a customer you're still
going to look me up everything's still
going to work out okay the worst thing
that happens is that maybe I get mail
with my name on it and it looks a little
bit wrong but that's it so the tests
that validate these things the tests
that validate the unique ID they need to
work because you need to be able to look
people up to run your business but the
tests that verifies that my name is
alpha is not necessary is it good to
have sure it's nice maybe I mean now
there are names with alpha so how great
was that test really but maybe it's good
to have maybe it's not in that case it's
probably easy to write the test and you
move on but what about something like a
web form I want to put a red background
whenever somebody puts a one in their
first name okay simple logic and nice
right but how are you going to unit test
that selenium some type of web runner
that takes five minutes to execute 10
minutes to execute is it is it really
worth it is it really worth adding to
your test suite to validate that the
background went red can you still do
business without a red background on
your web page I think you can another
example that I don't think people
consider is what I mentioned earlier but
this is the most common one you you want
to write TDD fantastic tdd is great I'm
all on board with TDD but that just
helps you design your code it helps you
create maintainable designs and it helps
you drive towards the design you want
evolutionary design so many great things
so many buzzwords but once you're done
once you have that good design that test
is maybe not necessarily as valuable
look at that test that you created for
tdd and decide is it going to help the
team in the future if it helps you get
to the design you got to that's great
it's served its purpose nobody's going
to tell you that you shouldn't write
that test but that doesn't mean you need
to maintain that test forever and your
team needs to maintain that test forever
so look at a test and decide if it's
worth it in the moment but also if it'll
continue to be worth maintaining stop
thinking about test from your individual
point of view think about the team I
mean that's that's definitely the high
level take away from this presentation
your tests are not special they're not
beautiful or unique snowflakes have the
same decaying text is every other test
it's all about your team it's really not
about you it's about making the whole
team more successful and it's about
thinking about the context that you're
in and how you can help your team
right so they are some questions great
what is dry don't repeat yourself it
just means it means very different
things to different people I believe it
originated in the pragmatic programmer
I'm sure it came before that book was
released and it basically just says
don't repeat the same concept some
people interpret that is don't repeat
the same characters I don't agree with
that definition but it's very common to
find that but I would say the the
essence of it is just don't repeat the
same concept within your systems okay
thank you how do you mock final classes
find a better language that was CC know
what I guess there's if if you're using
some if you're using a final class that
you you absolutely have to use you could
just wrap it in a knot final class and
then and mock that that's what I would
do what if I relevant data helps us
discover false negatives and false
positives as long as you have a
motivator driving you to write a test
write it then write more of them as long
as it's providing value that's great but
the takeaway should be is this test
providing value not oh I just need to
test blindly why limit not drawing
aggressively to testing will these
readability improvements cause problems
outside the tests can you repeat the
second half again sorry I didn't get it
either will these readability
improvements cause problems outside of
tests ah I assume the question is why
limit it would it be better to duplicate
also as well I mean that's a great
question for it's great to think about
code that way I can't possibly say don't
dry your code they'll throw me out of
the community but but thinking about the
return on investment of every line of
code is extremely valuable not not just
for tests obviously right we have time
for a few more what's your take on
naming i miss descriptive test method
names in your examples I think if X unit
had been created in a language that
actually supported and
onymous functions then we wouldn't have
had test names by default I think
they're great when they're great and
they're worse than bad in many occasions
because they're wrong the first version
of this book had test names that were
wrong because you write a test will you
write the name first most of the time
and then you write the test and the test
either revolves right then and you
forget to change it or somebody else
involves the test in the future and as
we said in the last presentation the
famous quote code doesn't lie which is
great and true but comments do lie and
it tests names a comment don't kid
yourself a test name is a comment it is
nothing else is BDD a viable way to
improve maintainability of tests or your
thoughts on PDD in general a beauty is
very opinionated and if the team is on
board go for it fantastic and if the
team is not on board it's the worst idea
maybe not the worst but pretty terrible
it's all about buying it's extremely
opinionated there are many opinionated
test frameworks out there and none of
them are the right answer it's all about
the team I think this will be the last
question if you're doing single
assertion protests you would easily end
up refactoring to dry should you copy
the same setup for the multitude of
assertions yes not in the setup method
within the test itself absolutely the
key is to have that tiny universe that's
incredibly easy to digest so when you go
to a failure you don't have to go
anywhere that's that's the perfect world
maybe you have a builder and you already
know what the builder is doing but the
perfect world is you get there the
Builder creates the domain object and
you look at what's actually being tested
the expected value as a literal perfect
you look at the the method call a
function call to the domain and it's
extremely clear what's going on ideally
you don't want to rely on any type of
IDE to have to read a test that that
just feels wrong to me
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>