<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Microservices: A Utopian Mystery • Praveena Fernandes | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Microservices: A Utopian Mystery • Praveena Fernandes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Microservices: A Utopian Mystery • Praveena Fernandes</b></h2><h5 class="post__date">2016-10-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OIqcR5yi_to" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi I'm Praveena so just the logistics
make sure you rate the session and
please do if you have any questions
please type it in there as well I'm
really interested to hear what you have
to say or what I mean what have you
observed and things like that I know
that Sam has already given me an
introduction but I thought I'll just do
it again I'm a software engineer at new
technology or like how my Swedish
colleagues would say neo4j
so I want to talk about micro services
but before I proceed to like present my
case study I just wanted to understand
to get a bearing on the audience so that
I don't like use a ton of jargons and
like I don't explain things that this
audience already knows so it'll be
easier to skip through the parts the
obvious ones at least so how many of you
have worked with micro services okay
that's that's good how many of you are
developers okay
how many of you have worked in like an
agile methodologies like I'm many of you
have used like good so that's yeah so
that that makes things really simple so
micro services is a software
architecture style where like you
compose like complex applications since
to like small independent processes when
you look at micro services almost like
all major conferences around the world
have a separate track dedicated for
micro services and and it's not just in
terms of like software architecture
style even like specific language
conferences have specific tracks on
micro services so it's it's been like
gaining a ton of momentum in the recent
years and the places which use micro
services are companies like Pinterest
Twitter halo uber and like ton ton of
these things which I already use and I'm
sure like many of you are in customers
of these services
Netflix at least come on who isn't a
customer of Netflix so when you look at
these companies you see that all of them
have been there for maybe maximum a
decade you could say and they they have
like a lot of like young engineers
working there and in terms of legacy
they don't have much to like carry it
around in some sense whereas I and the
things that micro-services brings in are
like the kind of small gifts that comes
along with using macro services are you
the ability to do quick deployments you
can like release something to production
and then like look at the feedback and
try and adapt to the feedback as quickly
as possible and you can scale up and you
can scale down services as however you
like based on how your user consumption
is and it's very very easy to enhance
features or to add features and like the
path from like when you start
development to when it has deployed is
reduced so rapidly so these are the
invitees are the kind of small gifts
that lakum comes along with micro
services but what about age-old systems
I worked in a place as a consultant
where we had to we have to we we're in
an environment which had like Microsoft
servers behind like this huge like what
do you call it like architecture and we
don't know what was happening there but
what we knew was that they the the
customers were kind of seeing patterns
where they saw like new startups which
came into their own space their own
publication domain where they were able
to like quickly add features the ones
that they have been trying to add for
years
and then like eating into their user
market so they were in a position where
they were still like market pioneers but
they they slowly saw their user base
like being corroded away by electrons of
new startups in their space so they they
really wanted to like change how they
work and they wanted to like change how
they deliver software because ultimately
the
what like that's the interface to their
end users this webpage that they were
like that that that is that is what they
were serving to the end users so I was I
mean not just me like my team we're like
dealing with the 20 year old system
which was written in C and the team did
not have any business analysts at the
beginning and we were basically given a
part of the codebase not the entire one
a part of the code base maybe we were
told like okay
this is the thing you don't have any
business analysts you have to go ahead
and like pre engineer code we don't know
how things work or why things work but
we want it to be exactly the same
because we don't want to use lose any
user base because some features are not
there which they were like used to
before and the ultimate goal that they
wanted to have was also like they were
moving like a development their
development center from across
continents so they wanted to like say
okay we've got a new development center
in and we're like going to transform how
this thing works and and we want to
prove the success like you know you
remember the good old days when you were
taking like three months to like just
release not develop just release we're
going to like we are done with that now
now what we want you to have is
basically like write code and then like
release it maximum in the week like
that's that's the target that they were
looking at and with any business
critical application you always have
tight deadlines which was the case in
our in our in our in our system as well
so when we looked at like when we saw
what how people are tackling problems
like these we saw micro services as like
the future this Lake great world where
like it answered like every single
problem that we were having we wanted to
release quickly we wanted to gay gage
god gage yeah gage customer feedback and
and yeah basically so we when we looked
at micro services we felt that it is
like it's the future like yes that's the
answer that's where we want to go to but
it also
like an Adobe entreat to me because when
you look at so just just to get some
basic definitions utopia is like an
imagined place where like everyone
exactly knows what they are supposed to
do and everyone have a purpose in that
world and the mystery is something that
like I mean it just explains what it is
like I mean it's impossible to
understand or like explain it so like
when I was looking when I was given this
project and I was looking at micro
services that's exactly how I felt I
felt like it was all of this is like
great but it's used by companies which
are there for like 10 years and they
don't they basically know what they're
doing and they know their software well
when it's like we were in in that place
so it looked a lot like utopian mystery
to us but we still decided to like steer
on because we were like okay we need to
start delivering and let's just do
something and see how how it works out
so we decided to use micro services for
application so we initially thought that
our monolithic application is going to
be like that like a like this like
beautiful like multi multi tier higher
tier oh this is great audience thank you
anyways multi tier cake and we were all
like you know like balancing it greatly
and it's going to be like when we change
it into micro services it's going to
look like that where you have like the
same to you and architecture but you
have like smaller cupcakes where it's
like divided into like really small tiny
nuggets and you can just like go ahead
and like bite onto it but reality will
seem much like this like literally like
it I mean not literally figuratively it
is like this I don't want to be like
yeah so it was like this and and it
isn't an easy thing when you are dealing
with like a big pile of and now you
have to like deal with like ten piles of
little poo like it's it's not like a
layering sorry anyway it's like it's not
it's not like an easy it's not easy
problem to solve so these are basically
like oh I ran a bit there these are
basically like ten lessons and like if I
can I can talk in length about each one
of these and how important this
but I'm just giving you like a like a
big loss over what I learned by using
micro-services so the first lesson that
we learnt from doing things wrong was we
have to keep it small and what what do
you mean by small what is micro and
micro services mean is it like the
number of services that you have in
production which I'm gonna say the
answer is no it's not that it and why is
it important to have like small services
it is it is important to have small
services so that you you can basically
rewrite the entire service if you want
and how how you can measure the the size
of your service by answering this
question which is like how long does it
take to rewrite your entire service the
ideal answer ideal answer for that
should be in the order of two weeks now
you can say hang on a minute crimina
like i thought you were saying that
you're talking about like 20 year old
system and whatever you're saying right
now it just looks like hipster talk to
me so like why why would you ever have
to like rewrite an entire service like I
don't I think you're like lying or
something like that but there is
actually a reason why why you want the
service to be able to like you have the
ability to be written read it and
basically it is because so that you
could write work on a story and you
should be able to like deploy it quick
to production so how long does your
story take from development to
deployment ideally what you would want
is like when you pull a story in when
you when you pull a story and you want
it to be like you know like a smooth
ride across like this Lane so this was
our card wall and when you pull a story
from like analysis into ready for death
what you want is you want a smooth ride
across all this Lane and you have to
come to the ready for prod so that's
that's your ideal situation and you
should be able to like glide
on that like you're riding like a cycle
which is like in on a really smooth
plane but if you if you're working with
like a service which is massive then
it's going to be an experience as though
like you're riding with this we dislike
bicycle because it's it's not it's not
going to be a pleasant experience when
you like take a story do the development
and then push it into test and then wait
because select some other story is like
having having a dependency on on the one
that you're working on so you will run
into problems where like you face
questions like okay I worked on a story
to improve like the query performance
and there is a UI bug and why is like
these are completely like unrelated
things why are why is my story blocked
because of like a UI bug I I don't see
any point in blocking my story but like
if you have a service which is like
small enough and it has like one
responsibility and it knows and it does
just one thing then it's very very
simple for you to be able to like make
changes to that service and be able to
deploy it quickly and remember like one
of the important things that we had in
our application was that it took months
to see any changes deploy to production
and this is what we started to this is
why we wanted avoid is first to have
like a quick deployment to production so
this was very important for us to like
keep our services small the next one
that I I'm sorry the important thing to
realize here is that like you have
smaller code bases that leads to like
really small context to change which
means that you Italy it helps you to
like do autonomous delivery small isn't
just beautiful it's it's really
practical for you to like deploy a small
services on in a very big environment so
like you have to remember why this is
very very important listen to is to
focus on autonomy from design to
deployment now autonomy is basically the
right of self-governance
how does autonomy look
like in a micro-services environment you
would want ideally when you when you're
doing the deployment you basically say
that like okay I have developed and like
I was pairing or not pairing it's fine
like I'm done with development and the
testing is over on that story now I want
to go and deploy and what you want to do
is just like push a button and it's
deployed or like it gets deployed
automatically so you basically have like
absolutely like no choreograph to deploy
you don't have to do any choreography at
all you didn't have to talk to people
you don't have to talk to other services
that's what you want and here's here is
where something tricky comes in like
early I was talking about how your
service should be small if your service
is small enough it definitely would have
like dependencies that that it's it's
it's what it needs to like make its work
happen then in that case like how can
you just like deploy your service
without choreography on like its
dependent services because more often
than not when you're when you're working
on a solid piece of work you do have to
like touch multiple services so like you
can you can again like say that this
this is like one of those things where
like people say one thing but the
reality is actually something else which
was in our case one thing that we
finally succumbed to was basically on
like saying that okay fine there's
always going to be dependencies and we
just have to deal with it so that's
that's that was like a important turning
point for us because we tried really
hard to like have oh no no no no like
you're not supposed to do choreography
at all like it you shouldn't we
shouldn't be we shouldn't have to do
this we are doing microservices wrong so
like the first step - the first step to
recovery is like acceptance we accepted
that there's always going to be
dependencies and now let's have a
conversation on how to deal with those
dependencies so what we wanted was no
choreography in our deployments but what
we needed was actually easy choreography
in deployments which is why this is like
a user story card and I don't know
whether it's really clear but what you
see in this yep what do you see in this
is like three different services on on a
sticky note there and some numbers next
to it so
in my project we used rpms so all our
services gets packaged as rpms and then
they are like baked into an ami and
installed so what we knew was that like
when we used this when we developed this
story we knew that this this one has
this to implement this story we had to
touch three different services and those
three different services once the
changes were made they're built into
that number rpm so we basically marked
those rpm versions on that story and
said like okay fine if you're going to
if this story
if these rpms are deployed in any
environment then it means that the
story's features already there in that
environment so that was one easy way for
us to like track how the services are
dependent is like when you start working
on the story we decide like okay this is
how these are the services that it's
going to touch and these are the nun
wants the deployment once the
development is done we mark the service
RPMs that it was using and then say like
okay fine if you deploy these three
services those services the story is
done it's basically there in that
environment so we made a conscious
decision to think about what a
deployment strategy is going to be at
the beginning of the story development
like so when you do an analysis we the
first thing that we did was like okay
the story is going to touch three-phase
services so let's just like identify
those services and put it on the card
and then when the development is done
you just add the service RPMs there and
when you do have easy choreograph
deployments there's always going to be
like breaking changes the important
thing is to like plan for breaking
changes so some of some times when we
were thinking about a deployment
strategy we realize that there are going
to be breaking changes so the next thing
to to think about is like how do we
ensure that like the end user isn't
going to be affected when this breaking
changes are going to be like deployed so
how do you avoid breaking changes so we
had a bunch of like a set of tools that
we were using in sometimes like in
conjunction with other things
sometimes like by itself so we use
semantic versioning we ensure that we
had like a tolerant reader in our api's
and sometimes we would do lockstep
deployments and more and the one thing
that we used extensively was feature
toggles and feature toggles based on
which environment a certain story is in
so while a story is in development it
will be feature toggled on on dev
environment but the QA the staging the
production environment it would be
toggled off
so even when the RPMs actually reached
to those environments until we we are
able to like test and all of these all
those necessary checks are done they are
actually not available to the end user
so when you have feature toggles and
when you ensure that you have like
semantic versioning tolerant reader and
and other things like you you can try
and avoid breaking changes or you can
you can at least like plan for
contingency measures so when we did have
breaking changes like if you see this
one says you're blocked on on some story
here which is like in analysis so this
is one way where we identified like okay
these stories although they are
independent if we Club both of them
together while in development it's going
to take weeks for it to complete and
weeks for a to finish testing so what we
would go ahead and do is actually divide
that story intellect sensible parts and
then say it's going to be blocked so do
not deploy this until the other story is
ready so like the developers can
continue with the development the
testers can continue with that and when
when these two things are ready then you
just basically turn the feature on so
that's one of the important things that
we when we were able to plan for it like
at the start of development it made a
lot of sense to us
so one another important thing that
microservices brings along is actually
having like a heterogeneous architecture
and this is one of the things that
people talk repeatedly that you can
exploit to your benefit to say that like
you can choose the tools that works for
you but when you work with all systems
you have to be really careful on like
what you're doing as a con
and I have the responsibility to ensure
that I am NOT choosing tools that the
that my customers are not able to like
maintain it at the end of it like when
I'm out of the dough so that there comes
to certain responsibilities when you're
deciding what you have to do so in our
case we chose things that we knew that
is going to add like long term benefits
to customers unlike they are never done
in like really simple languages rather
than like ml or like closure that I say
but so we use chat tops like we use
things like Hubert to like in to make
sure like our deployment like you can
basically ask Hubert which is like a
JavaScript
chat up that you can add it to HipChat
and like slack as well I suppose and it
will tell you like what's the status of
your deployment and you can tell like
notify me when this service is deployed
so you can just go ahead and do your
stuff what you could go grab a coffee or
something like that and it will tell you
basically when your deployment is done
and other things that you used we're
like Cabana dashboards which is like
again built on like an elk L stack and
you know like it's saved in like in
Jason so people were able to like
interface with it and it's easier to
learn as well and we were able to like
quickly fix we we had the ability to
like add like really small cards which
would like go through all the lanes
really quickly if we know that we we are
getting user feedback on a certain thing
like so that was like okay this is going
to add short like long term value but
it's like a really short things can we
just like quickly do this and this was
this was not just for the end user this
was also for like things that the OPSEC
people needed or like things that the
DevOps people needed like so we were
able to quickly prioritize stories on
those ends and other things that we did
was like automating support scripts so
chat ops was using javascript for
support scripts we realized like so i
was working on a java application
now java and scripting doesn't really
mix so we decided we will do we will use
python scripts because like our info
infrastructure was on ansible so we
thought like python runs really good
with ansible so we wrote like really
small scripts like whenever systems
would go down like if a support engineer
were to look at it how would they do it
really quickly so we wrote these really
small scripts and the next thing we did
was like automate those support scripts
like so without even the intervention of
of a support engineer it will the minute
something goes down it it shows likes a
certain status what automatically so
these are just examples of things that
you can use even in in like age-old
systems where it is like really hard to
incorporate things lesson 4 was to pay
attention to the bounded context I think
I really do think no microservices talk
gets complete without mentioning bounded
context because it's it's such an
important thing to consider and it's
it's very very easy to miss as well so
bounded context so this is from Martin
Fowler's blog and Eric Evans on his
domain driven design book talks in
extensively about this so in simple
terms bounded context is like you have
in any application you have like dude
you have multiple contexts and these
multiple contexts have like have models
which are named exactly the same for
example in a support context you have
customer and you also have a customer in
a sales context but although these
models are named the same and they kind
of indicate the same person the
operations that that person has is
completely different and this is
actually a reflection of of humans in
like in reality I'm here as a speaker
but I'm also an employer at what do you
call it like at at near technology so
this happens this happens quite a lot
like so people sometimes miss interpret
this and they try and like share
operations and models between these two
contexts and that's that's a big no
please don't do that
we were bitten really hard by that I'll
show you how quickly so we had to
services or
indication service and the web app and
when the web app is trying to
authenticate it uses like the
authentication service return returns
back a JSON response with the auth token
username and some user details let's say
age for instance but what the web app
needed was a response like this it
didn't need the author cane but if I
were to lake import this inside
authentication service then it would
mean that authentication service would
have to return this response which which
is what we did like honestly which is
what we did which meant like any end web
app had to change we had to change what
authentication service was returning
which was a bitch was a big mistake on
our part what we should have done
instead is made this transformation
inside web app instead of authentication
service so authentication service always
gives this one response and its
consumers interpreted in different ways
based on what they want lesson Phi was
choose what works for you and document
your reasons
now I'm an I'm a software developer and
the last thing that I want to do is
write pages of confluence document but
it was very important for us to do this
one important step because because like
developers like to add always like
improve the system that they're working
on which meant that we were having the
same conversations over and over again
about like why why are we doing this and
like what this shouldn't be this way
kind of thing which is which is fair
like I mean I I would do that in
anything that I'm in but what it meant
was that like people were getting tired
of like explaining this again and again
and like try and see what was happening
so one of the things that we did was
when we take a decision on something
just understand the context why a
certain decision was taken and just put
it up somewhere in the mail or like
somewhere so that it's communicated to
the entire team about what we are doing
and why we decided to do this and
reevaluate it any
we're one of those context things
changes so you don't have you you don't
end up having the same discussion over
and over again but you do have the
discussion where it matters when your
your context in which this went when you
decided a certain but when you came up
at the certain decision has changed then
your decision no longer applies because
your context has changed so we ensure
that certain we imported certain things
like that an example of this was
understanding where our constraints and
where our principles came from an
example of principle was we decided that
we will do our validations at every
service level which meant the
validations were duplicated but we were
fine we had good reasons why the
validations should be the should be
duplicated which I'll probably cover in
in a short while but the important thing
was around constraints there are certain
things which you can't change in your
project constraint for instance we had
so I just tell you that I was working on
a java application and we had Python
scripts now when we came to use a johnny
test
we started with ruby and at that point
our clients went like no like we can't
do like one more language into the pot
like I mean can you please just pick up
something else like either Python or
Java to do this so we did like after
doing the user journey tests in Ruby we
decided to change the user journey test
using Java because you come has like a
Java API as well yeah anyway it's like
so we decided to do that and that was it
it made a lot of sense at that point why
we had to do it because it was from from
a constraint which we had no control
over and there's no point in discussing
this over and over again with a ruby is
better our java is better when like when
your client sees like just use Java so
about validations for principles we
decided to an example of this as to the
acceptance that it is okay to duplicate
validations and the important thing like
when I first became a developer in my
training that was taught over and over
again was dry do not repeat yourselves
so why would I want to duplicate
validations because that's one of the
tenets of flex after development you
never repeat yourself but
it comes like from a greater
understanding where you understand that
like okay fine
there are certain duplications which you
never want to do but then there are like
certain duplications which you should be
doing for inst an example of this one
would be say validations like where you
have like your client-side validation in
JavaScript when a user is entering
something and you say you match like an
email or something like that and you say
like well this is not a valid email
address so that's something that you
would do in JavaScript where this when
you are trying to save something in your
database that's a completely different
kind of validation which you should be
doing which is it does it have any
sequel injection in it does it have like
Bobbie tables and things like that so so
these validations serve two different
purposes when it's done in the client
side versus when it's done in the server
side and it is a good thing to not to
ensure that like you do validations
wherever it is necessary in some places
where we had to like duplicate
validations our avi we needed to like
check this over and over again an
important there was there was like this
tension between like okay do we make
shared libraries or shared clients or do
we just like accept everything that
comes by and in our case we decided to
do both so like in in like one of the
services which I was taking care of we
the the service itself published like a
client for any of its consumers to
connect to the service so the client had
all the validations that the service
would do so like if you were to use the
client then you can just you can ensure
that all the validations are done but
there were times where like you don't
want to you don't want that thing you
don't want to like use a shared client
but you want to use instead a shared
library an example of an example where
we use like a shared library which is a
very good layer of abstraction was
managing negative TTL caching so we used
ELB
and Lake when you have when your lbs
which is being made like your service
endpoints which is being made your at
that point like there are times where
like your your negative TTL caching
affects the service discovery so when we
had to abstract that so that was a very
important thing for for all the services
to to basically haven't done the same
way there was no reason for it to be
done in two different ways so that was a
very good example for us to do something
in like a shared library and an example
of like abstracting something which we
shouldn't have is abstracting models
into shared libraries an example of this
is what I spoke about earlier so we saw
that the support context and sales
context had basically cost a customer
and leg product shed so someone thought
like I mean for I think in all fairness
it it could have been me was like oh
like I know what to do here we're doing
the validations again and again let's
just do the smart thing let's just like
extract that into a separate library and
then like ensure that those domain
models are basically shared between
those things what it did was basically
like remove this boundary completely and
it made this entire thing into a support
and sales context context and it was a
mess like I mean we couldn't we couldn't
add any features to one context without
affecting the other which is why we
wanted the micro services in the first
place which is why we wanted to keep it
small in the first place but what's the
point of keeping it small when you like
share libraries in between you might as
well have both of them together which
was the costly lesson for us because we
by the time we wanted to change the web
app to do something else it was very
much tied to authentication service and
it meant that we had to we had we spent
like a month or so like trying to strip
away features from web app and it was
still a mess which is which is a shame
really
lesson six is to embrace convex law so
this is one of those things that gets
mentioned along with bounded context
time and again in
in any micro-services talk which is
convex law like I mean conveys loss is
basically something that has been like
through Reuben again and again where
when you try and come up with a solution
your solution is going to like mirror
what your organization structure is so
instead of fighting Conway's law it's
very very useful for you to like embrace
it and make it work for you an example
of that is deciding between these two
teams so initially we had like an UI
team which is why we had like a web app
service and then we had a platform team
which is why we had like multiple what
do you call it like the we had like one
AWS like deployment architecture and
then we had feature teams which meant
like we had like features in between but
what this meant was that like anytime
you had to add some a feature it is
going to touch both the UI team and the
feature team and the platform team which
meant you had to like somehow coordinate
like giving or like splitting work
across these three different teams and
like deployment between these three
different teams so it's a mess like I
mean as I as I say it I can realize like
you know how difficult it's like a
trauma it's coming back all to me like
so it's not it's not really a good
feeling for you to like just the last
thing is the developer you want is like
sit in meetings about how you should
develop code or like how you should
deploy code and you're like this is what
I wanted to avoid why am I here again so
an important thing that we decided like
after trying out the wrong way of doing
it in that context is try and do it a
different way which is like actually
make our teams like our feature teams
have UI developers have a platform
person and importantly have a product
owner within that so when we had like a
product owner team it I don't know like
somehow it was it was making things
really difficult when we had to like
make decisions we had to send emails
wait for a long time and like wait for a
long time for it to like get business
owner approval and things like that
the minute we actually had a product
owner in our
when he was attending when he was
attending all stand ups everyday stand
ups it was very easy for us to just go
like okay what do you think about the
story we have tested this I should we
just deployed this then he goes like yep
if it's yep sure deployed and that's at
the end of the stand-up it was deployed
basically that that's how simple things
became in terms of deployment so what
you want to have in your team is a
vertical slicing of teams instead of
having like horizontal slicing and other
things that we used Conway's law in our
to our benefit was to have
self-contained systems and like under
steak talking to a product owner about
like look you're the product owner you
give us the requirements
you're not like stopping from changes
being happening because we we are
basically in this together and we need
to like work out how we are going to
work out like it's not like I'm
suggesting something and you are like no
that can't go in its instead the other
way around we're like you're suggesting
us something and we are going to make
sure that that change is actually in and
that that made like tons of difference
lesson seven is to take monitoring
seriously I can't stress how important
it is to ensure that you monitor your
systems because things can go wrong
easily like I mean when you have one
thing to take care of you just have to
like sit and stare at that one thing
with us when you have like hundreds of
things to take care of your you would go
mental about this so like it's important
to like take your monitoring seriously
and ensure that you have like proper
alerts to just alert important things
not not like all or like some region
like an region went down is an important
thing but like an instance went down
maybe not that important because you do
have like lbs and things like that in
front which can take care of it
it can be like a post mortem so you you
need to understand where at which
different levels you have like alerts so
we had our dashboards configured for
three important things the first one who
is business metrics the second one was
kind of like mongol together which is
like your application metrics and your
two metrics now business metrics this
was a huge win for us to like win a
product on his confidence because he
could basically see any like anything
that he is adding how quick it reaches
to production and how does it affect the
user interaction with the system so we
were showing him after this after a
certain feature was added how did the
downloads increase or decrease or like
how many users stayed on these pages and
things like that those are the kind of
metrics that they like to see and those
are the kind of metrics which you should
track as well as a develop on your team
to understand like how how the software
that you put out there is interacting
with the users and we use like a ton of
these tools like whichever one that
suited our needs and we kept we worked
on our dashboards continuously as well
as we went by because we were like oh
like when we thought that this one thing
was really important now like we
actually fix that problem like we
automated that problem it shouldn't
happen anymore so we can just push it
down the stack and let's look for some
other alert that we should look for so
we worked on this continuously it wasn't
just one thing that was just there so an
example of this is how many of you have
used hystrix
Netflix is tricks so it's a great it's a
great library so it ensures that if it
has circuit breakers so if any of your
dependent services aren't working we
decided that we will show the content to
the user anyway because the user
shouldn't be penalized for basically
like our problem of not being able to
put software out there properly so that
so that was an example of a very good
call back we had in our system so we
would see we were talking we were
tracking callbacks in our application
logistics also gives out metrics for you
so you are tracking callbacks in an
application and we saw that like certain
services were like you see here there is
like a huge what do you call it like
alert death which means that like
something went wrong there at that point
like maybe a region went down and
something happened but they but the user
got the content anyway and other things
that we were tracking where things like
availability zones
like is there any cloud watch alarm not
like specific alarm says like if there's
any cloud watch alarm that's that's on
then it would just that I think so that
one would go red and like a support
engineer would go ahead and look at it
so that was an example of an application
matrix this is an example of a business
metrics so we we tracked the user
interaction and how much time the user
spent in in our in application so we we
send an event out when like when the
user enters in ters a system and we also
sent an even doubt when the user exits
the system and we were able to see
something happening here and that's
around the time when the call when the
call backs were failing and we were like
okay this definitely something wrong so
those are the ways that we were able to
like show to the product owner like this
application that you put out there this
work that we are doing in terms of
infrastructure it's for you as well like
you can add these dashboards and he was
like he was really happy going on to the
next lesson an important thing for us
was to make sure that we do testing now
this this shouldn't be a point of
contention at this in this century like
I mean it's important that we have to do
testing and we it's important that we
have to do testing at different levels
so in in our case so when you talk about
micro services people always say that
like oh like you have done your
development properly just release it
into production and you can see
something goes wrong just like pull it
back or like roll back or like release
effects now in I was working in the
system where like product owners we're
like not used to change at a rapid pace
and this was basically like scaring them
that they could potentially release
software and lose customers and they
were and basically ready for it so in
our case we decided okay fine in that
case what we will do is like have a QA
environment which mirrors exactly what
the production does and we will run a
soak test so that like we have always
like a user interaction happening with
the QA environment so anytime we were
finished with like a story we would
release we will ask
we will we will check whether the QA
environment is free and we would just
release it in in QA and because the soak
test was running continuously it was
giving us feedback if anything were to
go wrong
so that covered like 80 percent of her
cases when things could go wrong and the
product owner seemed to come around at
after it like you know when he saw that
like Oh things went wrong in QA
developers are working to fix it so it
was very easy for us to like say once
something is like QA testing done it's
ready for production like we can release
it immediately in a matter of minutes
so once QA testing is done we would talk
about it and the in the stand up will be
like okay we we saw this we saw this
problems we fixed it can be release and
prod it went from a point where like the
product owner was like yeah sure go
ahead release it it's fine like I mean
if it's done in QA if all the test has
passed just go ahead and release it
likes it it went to it went there like
in a matter of months and it was it was
a great feeling for us to be able to do
that so this is like an so this was
basically like how we thought we did our
testing like when we do something in
production it's like Schrodinger's cat
they say that them you never know
whether the cat is like dead or alive
when it's in a box like the moment you
open it as when you see it's dead or
alive but no you can actually test it if
you shake the box and the cat shouts
then it's probably alive like so that's
that's how we tested in our inoculating
n't apart from this like to enable the
to enable that our production is always
online we had a ton of other measures
that we added apart from just testing so
chaos monkey is an important thing that
I think if you're working in a micro
service environment even if chaos monkey
isn't automated into your test suit just
try doing it as like exercise for a week
and see what happens like bring down
like a house monkey will take care of
bringing down systems and you can
actually track whether your
infrastructure is resilient enough to
handle chaos another I think like one of
the important things that we did which
was like a no-brainer and it was really
quick fix for all our services was to
add health checks
but the health check would not only like
say for example the webapp the health
check would not only check whether the
web app is up and running the web app is
able to like accept requests it would
also check whether it can talk to the
authentication service that it was
dependent on or other five other
services that it was dependent on so we
tied the health checks of a service to
be also tied to the health checks of its
dependent services so that was a very
very easy win for us when we broke any
contracts between those two services so
we deploy something in production or
like someone said if we deploy something
in QA or someone deployed a dependent
service in QA then we know that the
health checks of the dependent services
go down and really wait there's
something wrong here
maybe this shouldn't go to production
maybe we should just stop and see what
happens so that just just by doing that
it gave it gave us like tons of
resources on how we are doing things
wrong and we region all we had to do was
just quick go fix one by one and it was
it was a very very simple thing to do if
you can do one thing to your system
right now which you haven't already done
please go and had health checks and also
health checks to make sure that it's
dependent on like you're dependent
services so in terms of testing we had
our soy test pyramid looks like this you
need to have like tons of unit I mean
not tons yeah you need to have a lot of
unit tests underneath and then on top of
it you have integration tests and then
functional tests and then you can't see
clearly I'm really sorry that's a
contract is there so you basically want
to have something like that
sorry that's a journey test but in our
case it actually became like this so we
had a unit test integration test a
functional test and then in between we
had something called as the service test
which was checking whether the services
on by itself is working by sending like
dummy requests into it and checking
whether we are getting a proper response
back so that was a service test which
was run anytime a service was deployed
and on top of that was the contractor
switches which is something that our
dependent services would give us so that
we added in a pipeline and we go like
okay fine now this thing
being deployed the service is working
but is it still working as how my
consumers expected it to be working so
that's why we want to test the
contractors and on top of that was the
journey test which was actually
replicating how a user interacts with
the system so if we were to do just
depend on the journey test and not do
any of these things it would take we
wouldn't know when something fails
what's failing basically so it's
important for you to realize like how do
you ensure that your service by itself
is working and then service with its
ecosystem is working and then services
for your user is working so that's
that's very important for you to think
about in your testing strategy note that
tests are there to validate constraints
they shouldn't be constraints themselves
so if you see yourself like whenever you
have to add a feature going and editing
like all the way down like the pediment
then you're probably not testing it at
the right level and that's an indication
that you have to have a look at and
definitely fix it whenever you can
lesson number nine is definitely invest
in that should say ten but it is also
nine listen in - get it - invest in
infrastructure no one so this again like
just so you guys know this is an
indicative
chart of how my what do you call it how
the story split was there isn't there
was actual data behind it but for
reasons I can't share that with you so
this is like an indicated chart so when
we started our application between
infrastructure and feature we had at the
start we had like 100% infrastructure
stories and then it started like going
down this is for one service then we
added one more service this is how it
looked like we started getting feature
stories at the beginning because some
infrastructure work has already been
done and then for the third service this
is how it looked so as we went by we saw
that the amount of infrastructure code
that needs to be done was reducing so
it's important that like don't be it can
be very daunting when you start with
infrastructure it's like oh I have to
like reinvent the wheel again like why
do I have to do it but perseverance is
key definitely you need to invest in
infrastructure why wouldn't you at this
age
that's that's important thing like you
need to embrace new technology it's an
evolving ecosystem out there and you are
losing out if you're not actually
tapping on to that potential digital
disruption has already happened like the
blockbuster used to be a big thing now I
don't own a TV I don't own a DVD in my
MacBook doesn't have like a DVD slot
like I mean that that's where it is that
so people like now a lot of things are
done towards like your middleman and if
you're not if you are not like embracing
new technology and if you're not
adopting like things that's already out
there you're going to be phased out
sooner than later and and it's I think
it's important for like really old
companies to understand this and not
fight this just because you have to use
a base because it's not it's not going
to work out that way at least maybe for
now it works out but it won't be like
like that for too long banking every
environment like banking technology
other services everyone like you know is
is is working on the space and you need
to tap into that potential to make
things happen for you there are new kids
on the block I would definitely have you
please like go ahead and read about it
if you're if you are like if you're high
up in the ladder please ensure that you
know like D what these things are the
three factors that people say that like
it it contributes to your personal
growth is autonomy mastery and purpose I
think your micro services also need to
have these three things in them for them
to work properly which is like ensure
that it has proper autonomy and it knows
what it is doing it has the right tools
to do and it has a purpose to exist if
it doesn't exist just don't leave it out
there micro services helps you to
improve in iterations which is very very
important in agile software development
is to improve in iterations adapter
feedback and having autonomy and taking
control of like business as well as
technology in smaller teams helps you to
like deliver software quickly you have
to ensure that there is like high
cohesion between your services but there
are couple loosely enough such that you
can alter it state
as you need and you need to be able to
like embrace convience law and if your
team isn't structured to do that then
that's definitely going to get into the
way of like you adopting adapting
microservices properly and why do micro
services it's it's a lot of fun doing it
out there and and as a developer it
gives me like great purpose when I work
on something and I don't have to wait
for it like six months to be released to
the user I think it it I enjoy it when I
see something that I worked on and I can
actually show to my mom like you know
like you know that thing I worked on it
so that's I think I I deserve like I
deserve bragging rights on the things
that I were a corn so that's my summary
these are sources I'm just reading my
sleeves at this point image credits and
thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>