<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Progress Toward an Engineering Discipline of Software • Mary Shaw | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Progress Toward an Engineering Discipline of Software • Mary Shaw - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Progress Toward an Engineering Discipline of Software • Mary Shaw</b></h2><h5 class="post__date">2016-02-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lLnsi522LS8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you all it sounds like I'm live
and and thank you spend for that
wonderful introduction so it's it's my
pleasure to stand here and get to talk
to you about engineering and software
engineering I wish I could see you for
the lights and I understand that I am
between you and the final reception so
let us let us make progress I'm going to
talk about the extent to which we have
come from 1968 and actually achieved the
aspiration that we stated there and to
what extent we're actually acting like
an engineering discipline and sort of
giving away the answer what we ought to
do to get closer hello
okay I would do this if I could advance
I got that one we'll wait on the next
one so there there are three parts to
the talk one is what does it mean to
have an engineering discipline for
software one is how far have we
progressed toward that goal the third is
what are the next steps
and I'm going to do this by beginning
with examples from civil engineering and
then moving on to examples from software
architecture now I had the chance a few
years ago to read history of engineering
for six months or so and out of that
reading I kind of collected the
definitions of engineering that I found
in the histories of engineering the
definitions of engineering and I put
them all in a pile and stood back and
squinted and they all look pretty much
like this engineering is about creating
cost-effective solutions to practical
problems by applying scientific
knowledge building things in the service
of mankind and
you can look at engineering disciplines
and you look at software and you can say
well even before that started there was
a really really great systems build yes
there have always been really really
great systems built by virtuosos the
point of engineering is to make it
possible for the rest of us to achieve
the sorts of things that used to require
virtuosos but there's a funny thing
about this definition and that is the
way it focuses on applying scientific
knowledge in fact engineers don't rely
solely on fully organized fully
demonstrated scientific knowledge we
haven't got enough of that if there
isn't solid science to support an
engineering discipline the engineers
don't throw up their hands in the air
they say well what else do we know
do we have empirical evidence do we have
a history do we have experience with
this kind of thing do we have a lot of
experience with a lot of things that
give us the ability to make informed
engineering judgments and so I think the
definition really ought to read by
applying systematically codified
knowledge the best we can get at the
moment the codified knowledge building
things in the service of mankind so what
are the characteristics of engineering
well one is that you're forced to build
those practical things under constraints
of limited time and knowledge and
resources and this forces you to make
decisions are about trade-offs or at
least it ought to force you to make
explicit decisions about trade-offs you
also have the option of wandering into
the trade-offs which usually comes to a
bad end Engineers apply the best
codified knowledge they have available
preferably science but if they haven't
got the science than the one ahead now
use that to shape these design decisions
they use reference materials to document
that codified knowledge and to make the
prior experience available and they use
that scientific or codified knowledge so
that when they do a design as they're
doing the design they can predict
the properties of the eventual system
will be and that predictive power of the
knowledge to help shape the design
decisions is one of the key
characteristics
now engineering disciplines evolve kind
of like this you start out with some
technology that your practicing is craft
people are doing it at home they're
doing it in their spare time there
aren't dedicated professionals think
about community parties to build a house
there's a kind of recipe that you all
follow you get together you build the
house and then you go back to whatever
it else it is you were doing and that
works ok on a local basis on a small
scale but some technologies many
technologies eventually become
sufficiently significant that you want
to be better at producing them you may
have to get materials from far away and
pay for them upfront and bring them
together and hire people to to actually
do the building before you can sell them
to get the money to repay yourself from
buying the materials and on around the
circle so to do that you need management
in production and process skills and
that's ways of organizing people to get
the work done which allows you then to
get a commercial practice or a
systematic practice that that lets you
rent it as a business now as that
happens you start stumbling on defects
in your knowledge about the technology
that in turn generates questions that
can be answered by science if you go and
look at the history of chemistry the the
science of chemistry really got started
by trying to explain chemical phenomena
from from production of materials
science then starts returning answers to
to commerce commerce generates more
questions there's cross talk back and
forth and then when you get the codified
knowledge to the point that you can use
it systematically to improve your
practice then then you're really in the
business of professional engineering
this this is the point at which you can
make confident predictions about where
your systems will do based on your
designs so
Engineering evolved out of craft and
commerce it requires systematically
codified knowledge preferably scientific
knowledge and exploiting it requires
both management and that systematic
knowledge it needs both pieces and the
science itself often evolves from the
progressive codification of practice so
let's turn to civil engineering and I
want to look particularly at bridges and
arches it's easy to imagine how people
faced with a task of crossing a stream
or a river would look to natural
phenomena and and from that devise in
this case an arch bridge and a beam
bridge eventually the rivers are too big
the cost of construction is too high and
by the first century the Romans were
holding an empire together with roads
and bridges so what the Romans did was
was they built and every so often
something would fall down they would
repair the thing that fell down and if
you go back and look at the the
construction chronologically you can see
that the repairs were incorporated in
the design of the next span of the the
are the bridge or the aqueduct or
whatever so they were making progress
but they were making it by trial and
error by failure and repair and by
incorporation of the repair in the next
stage there doesn't seem to be any
reason to believe that there was a
deliberate application of mathematics to
determine the sizes or shapes of things
so they didn't have much theory but they
had construction methods that persisted
to the 19th century so they did pretty
well by trial and error the best
organized knowledge is a book called the
seven books of architecture by Vitruvius
was written about 25 BC and it is a
handbook of practice it tells you how to
build a wall that has stone facings and
rubble in the middle it tells you how to
tune an amphitheatre by putting bronze
pots in just the right places it tells
you how to layout the streets of your
village so the evil my asthma's of the
local swamp don't make all the natives
sick
all kinds of useful information like
that okay moving on the histor history
of bridges is is easy to to capture in a
diagram bridges got longer and longer
spans with less and less rise in the
arch as time passes and you can actually
compute some of the ratios and that
turns out to be a measure of of the
progress in stone arch bridges as it
happens so this brings us from 14 c ii
up till the 18th century and then people
started getting a little bit more
systematic so Alberti said I I built a
lot of bridges and here's my rule of
thumb about building bridges let me help
you parse out this picture this is a
side view of the bridge that's the
bottom of the river
that's the water in the river that's the
bridge deck and the lines are labeled
with ratios that say the the width of
the pier is the height of the arch over
four and other clever ratios like that
so this this isn't science space this is
experience based he was writing down
this is what has been working for me as
time passed new materials came along so
the first use of iron in a bridge was in
iron bridge at Coalbrookdale in England
in 1779 this is a more recent picture
that we took a few years ago when we
were there the bridge is still standing
it's still open its pedestrian traffic
only now you don't want to run heavy
trucks over it but if you look at the
design of the bridge you can see that
the the design evokes a stone arch
bridge so one of the common phenomena is
that as you bring in a new material you
take the old designs in and see how they
work with them a new material and then
you start refining the designs to
exploit the material as you understand
it better
so cast-iron bridges were built for a
while
and eventually they they overstayed
their welcome in 1847 there was a
particular one of a series of bridge
collapses the general scenario was a
train would be going across the bridge
the bridge would fall out from under the
train a catastrophe would happen in this
case it was the sort of catastrophe that
got attention the Queen called a
commission the Commission did a study
the the Commission reported out the
study and what they discovered is that
Camp Styron is not actually a really
great material to be building bridges
out of because it doesn't work in
tension it only works in compression and
so they started adding water iron pieces
and eventually building bridges out of
steel instead of out of cast iron
by that time there we had a business of
bridges a commercial practice of bridges
we saw increasingly long spans we saw
rules of thumb about proportions and
along the way there were explanations of
structures Brunelleschi did some things
on arches and domes Galileo did some
studies on beams and cast iron then
wrought iron then steel and eventually
reinforced concrete were introduced as
alternative methods but they didn't
really have theory until the late 17th
or early 18th centuries there were two
basic problems associated with this task
one is the composition of forces what
happens if you push both here and here
and the answer is the force goes that
way and the other was probably bending
if you stick a beam in the wall and and
push down on it what happens to the
forces inside the beam the two theories
that solve those problems of the theory
of statics and the theory of strength of
materials they date right around the
turn of the 18th century which
incidentally is about when we got
calculus so in doing this it turns out
the hardest problem was figuring out
what the basic concepts were like like
what is force and they needed some new
mathematics to help so so after all
those centuries of building bridges we
got some theory
the brittania bridge of the mid 19th
century was the first bridge that was
actually fully analyzed the stress
analysis of this bridge was none before
they built it the engineer being
conservative designed the bridge with
piers so they can add suspension cables
if it turned out that the analysis was
wrong and the picture on the right is a
cross section this was a bridge that the
Train drove through the beam by the
early 20th century we had early
handbooks this is from the first edition
of the iron and steel handbook and let
me zoom in so you can see it a little
bit better there are on the left cross
sections of beams and then the columns
tell you various properties of the beam
so that you can go and look in your beam
catalog and get some beams and analyze
what your bridge would do by the latter
part mid latter part of the of the 20th
century we had text books about bridge
Stoker structures the thing I think is
interesting about this one is that it
shows you a selection of arch bridge
types and then on the right there's a
there's a chart that says on the one
side the coefficient of buckling and on
the other side a particular ratio about
the about the arch that you're looking
at and so this sums up an enormous
amount of knowledge about bridges about
arch bridges in particular and lets you
look in this chart and figure out what
your design is likely to produce so from
1700 we got good theories by about 1750
there were tabulations of the properties
of materials around 1850 we got a formal
analysis of a bridge bridge structure
and this machine has done a funny thing
to my font around 1900 we worked out
structural analysis about 1950 there was
some systematic theory like the the one
I just showed you and by 20 by the turn
of the 21st century we had design
automation and so bridge design is now
down to the point that in the state in
which I live
the Department of Transportation now
requires the use of its software for
automated design of simple bridges that
means you don't get to be creative about
the design of a single span bridge
anymore you go to their software you
turn the crank it handles concrete steel
and current and concrete bridges with
spans of anywhere from 18 to 200 feet
and there's a there's a software suite
you put in some decisions about the
bridge piers in the bridge deck
and then it it produces design drawings
so that's where we got to with civil
engineering and we can put some some
time points on this chart about 1700 the
the science gave us statics and the
strength of materials hydraulics or
fluid flow is also part of civil
engineering as you know static analysis
it's easier than dynamic analysis it
turns out to be true in materials as
well as it is in code and so it was in
75 years before we got a theory for
turbulent water the move into commerce
was the Romans in the first century and
then you can date the the emergence of
professional engineering either from
maybe 1750 with the properties of
materials or 1852 a full analysis of the
bridge pick some date in there okay
don't be scared about the time lines
communication works much faster now
think about the history of ideas how how
the ideas evolved through trial and
error and then through the simulation of
science so now let's turn to software
engineering taking software engineering
as engineering I guess the first
question is is this a reasonable thing
for us to aspire to so if we go back to
the definition definition of engineering
if I just tweaked it a little bit we
would we would have the branch of
computer science that creates
cost-effective solutions through
practical computing for
problems by applying codified knowledge
in developing software systems in the
service of mankind seems to me that's a
pretty reasonable aspiration for us so
let's go with that but there's a couple
of caveats one is be careful about the
way you map software to engineering and
the way you make it comparison to other
engineering disciplines because software
is design intensive the manufacturing
costs of software are very small it used
to be pressing CDs and shrink wrapping
them in boxes and now it's it's setting
up the download install packaging and
letting people suck it down over the net
people sometimes make the mistake of
mapping programming to driving rivets
and that leads you down all kinds of
unfortunate paths the programming
activity is the refinement of the design
the manufacturing of the software is a
very small cost so that's one caveat
about carrying these analogies over the
second is that that software is less
tangible software is symbolic software
is abstract and software is constrained
much more by intellectual complexity
than it is by fundamental physical laws
I mean yes we are constrained by
physical laws we have we have a
computability problem we have the limits
of scaling and these limit us in various
ways but the limits the problems the
difficulties that come first are the
difficulties of intellectual complexity
not the difficulties of the strengths of
our materials so be careful about those
two things as we as we carry the analogy
over we already talked about 1968 the
NATO conference there's a book here and
that books available online just go
search for it brand Randall got it
scanned and and put it up on the web for
everybody to read the label software
engineering was picked as a rallying cry
it was in it was it was used
deliberately to be provocative to call
attention to the then-current
problems in software production and so
you can think of the 1968 version of
software engineering as an aspiration
and our efforts since then to turn it
into a description and incidentally by
some reports the phrase was actually
used by Margaret Hamilton in connection
with some NASA software a few years
before that but I've got to say that
that this is the 68th conference is what
made it stick so here are some some
snippets from this report from 1968 gee
we have problems with monolithic
development merging research development
and production and not getting all those
things separated from each other
software is fine in many areas but we
have problems with critical applications
there's a widening gap between our
ambitions and our achievements
it's too risky software is late
over-estimate doesn't meet
specifications
there's too much too much revolution and
not enough evolution and I promise these
came from the 1968 report not not from
something written yesterday and just to
give you a sense of context for that
here's one of the diagrams it says
here's a schematic for the total
programming software system building
process and the complaint is that the
traditional concepts of programming the
traditional concepts as of 1968 remember
the traditional concepts cover this
stage which is implementation but in
practice programmers perform duties over
the span which is a problem recognition
through obsolescence and the labels
probably are not visible at the back but
they're pretty obvious so that's where
we were in 1968 then what happened well
now let's talk about production about
the management of software there's been
a lot of activity in the software
community about methods of software
development these are these bring order
and predictability to projects they
impose structure on the organization
they provide guidance for project
management
provide an interface with the management
of the business in which the software is
being developed and from 1970 till deep
in the 1990s we saw an enormous amount
of attention sometimes almost to the
exclusion of attention to the technology
on production techniques so we've had
structured programming Waterfall models
and so forth on into extreme and agile
processes these are important things to
have and and I believe their home is
here on the production arc and by
putting it there that gives me space to
put the technology on the science and
engineering arc so in what ways has the
commercial practice you know once we got
the software development methods in
place we could start churning out
software but then problems arise that
triggered science so we got safety
analysis large systems led us to think
about architectures concurrency issues
led us to parallel logics and languages
and proof methods for for dynamic
systems very large state spaces led us
to a form of verification that we call
model checking multiple versions have
led to systemic understanding of program
families and they were one of the
stimuli for inheritance in the
object-oriented world
huge data sets have made us think harder
about scalability they triggered
MapReduce and adaptive systems required
I think some understanding of feedback
but the dominant model for adaptive
systems these days is the make model
that came out of IBM so we've had this
crosstalk in which the commercial
practice has generated problems for the
scientists who have responded we have
codified knowledge that was already
there like data structures and
algorithms that everybody learns as
sophomores that's part of the knowledge
base of software engineering guys we
have programming languages we have the
semantics of programming languages we
have languages intended for particular
types of applications released we have
languages that many of us believe
are more and less suitable for different
types of applications if you have if you
have hung your reputation on a
particular language then you probably
believe it solves all the problems in
the world but I probably don't we have
verification model checking objects the
whole long litany of things that we
really do have at our disposal as
knowledge that we can apply to our
problems now this chart traces a few
particular technologies from early
research into practice and again I'll
zoom in so that there's some hope that
you can see it it doesn't particularly
matter which technologies they are they
happen to be raid portable communication
and world wide web speech recognition
and broadband that's just because that
happens to be the adjacent piece that I
could zoom in on but you'll see that the
the really interesting thing here is the
flow the red lines are University
Research the blue lines are Industry R&amp;amp;D
the black dashed lines are products and
the green lines are billion-dollar
markets so you can see that there's a
period of time during which ideas
develop and there's a certain amount of
crosstalk and and feeding between the
the different technologies so for for
software engineering in general I for me
personally the way I measure progress is
about the increasing size of the chunks
that you don't look inside so around
1960 a macro was a thing a macro was an
abstraction by the the 70s we were
talking about information hiding in very
early objects in the mid 1970s to 1980s
we started thought the thinking's more
more systematically about software
systems as collections of components
that had to interact with each other
from the research standpoint that
actually started in 1976 with a paper
called programming and the large versus
programming in the small and it's moved
on since then
software architecture I'll put a little
after 1990 and then we move on up into
to web services and and
things that are really composition of
very large components so so you can see
that that we have made an enormous
amount of progress by virtue of
increasing the size of the chunks that
we work with and it it it bothers me no
end that we still talk about lines of
code because measuring lines of code is
really counting how fast people type and
that actually hasn't got much faster
over the years when you talk about lines
of code we're missing the beat because
the hardware guys talk about transistors
right have you when did you last see a
transistor the little top hat with the
three legs right but you still talk
about number of transistor equivalents
in hardware when you talk about Moore's
Law so so they picked something and
they're counting the same thing when we
talk about productivity we pick how fast
you can type not how much capability you
can generate per hour so I think we're
missing the boat on that one we're doing
ourselves a disservice anyway I look all
the time for good design guidance how
can you help people make decisions about
what they're going to do and the best
piece I have ever found is from a paper
on sorting and searching in 1970 I think
73 perhaps and zooming in on that a
little bit this is a decision chart it
you play 20 questions with your problem
it helps pick a sorting algorithm so is
the sort to be done on two discs yes it
or leave the strings no are six or fewer
tape drives no can seven or more
seventy-eight polyphase merge okay you
don't care about the sorting
technologies anymore
what's significant is that I don't know
of anything that is a better
organization of a body of design
decision knowledge than this very
ancient chart and and we need
desperately things like that so now
let's move on to software architecture
in particular
software architecture is the principled
understanding of the large-scale
structure of your software system
understanding it is collections not only
of components but also of the ways that
those components interact it emerged as
a labelled thing in the early 1990s the
roots go back to many many many
discussions writing on cocktail napkins
trying to explain systems in which the
vocabulary was used in a completely
unsystematic way and I think what we did
in the 1990s was to help organize that
vocabulary so other people could use it
and what you get from it is some
guidance about explicit design choices
bridging from your requirements to what
code you're going to write so going back
very far here's a here's a picture of a
COBOL compiler you can see boxes and
lines this is this is Conway's paper
from 1963 that actually had a program
transformation in it
it talked about what to do if you if you
could if you couldn't fit everything in
memory and you had to put a tape in the
way here's how you make the program
transformation that separates the two
processes paper by Edsger Dijkstra a
very famous paper on hierarchical
organization of the t-h-e operating
system it was a layered system this is a
diagram from multics and I know you
can't read things but the little tiny
print at the top says ring 0 and ring 1
up there and when you look at the
diagram carefully you'll see that there
really breaks in these places and so
what they had there was a layered system
just by intuition by experience by by
proper knowledge so if you look back
into craft track practice
software has always had structure of
some kind there's been an informal
vocabulary we've had intuitions there's
been folklore about what works for what
tasks and you can look back in the
diagrams that people were drawing
that they were they were striving to
explain what was going on in a system so
we've had examples since NATO that began
with software bundled with the hardware
that then gave us compilers and layered
operating systems which which we came to
understand pretty well in the 1960s and
early 1970s and that by the way I think
is why so many university curricula
still have a course on compilers and a
course on operating systems they aren't
really about compilers and about
operating systems they're about the the
ideas that go into compilers and
operating systems but those were the
examples that we understood so well we
could build courses around them and
there we still are so moving on people
still drew boxes and lines and you read
a paper about a system there'd be about
six column inches called the
architecture of my system which would
have about four column inches of text
and two column inches of box and line
diagrams where there's often no key what
does this line mean what is a dotted
line mean what does a round box mean but
you can see the trying and so they look
like this
sometimes there weren't actually lines
sometimes adjacency was used sometimes
you can see hierarchical layering with
some cheats this one actually has a key
but but this level of practice with with
people working from experience to to
choose the architecture of their systems
is what stimulated the science so for
example uncertainties about the quality
and performance and change ability led
to models that support software metrics
the ad hoc nature of the structure
dealing with multiple versions and
interoperability led to the styles and
patterns for software architectures and
so here are some examples of the idioms
or styles or patterns that we receive
fairly commonly there are layered
systems such as having a virtual machine
or using a client service system there
are dataflow systems such as the classic
batch sequential system of the 1950s
and the pipes and filters of Unix there
interacting processes that might
communicate by by messages or they might
be event systems with implicit
invitations and I think micro-services
fall directly in this category and
moving on from diagrams of particular
systems if you look on the web now
you'll find tutorials that say here is a
canonical into your architecture here's
a template for an interior architecture
if you think you want to build an
interior architecture here's a starting
point now fill in the details here's a
template for a virtual machine if you
want to build a virtual machine start
here and fill in the details so we've
we've got up from this is the the
description of my system - I understand
a class of systems and I can help you
build one like it so now we have a
commercial practice for software
architecture we began with batch
processing in the 1970s moved on through
the 80s in informal architecture as the
part of the narrative for a description
of the system 1990s with with early
structure and with software product
lines and by the beginning of this
century architecture research has been
entering practice there any number of
companies have company specific
sometimes proprietary architectures for
the particular kinds of things they
field we have object-oriented frameworks
we have you and all for better or worse
I think you memo is dying I think that's
okay we have objects everywhere for
better or for worse but we have a we
have a thriving commercial practice of
architecture so there's a there's a
section in here on how scientific ideas
mature but I realize that I'm standing
between you and the reception's so I'm
going to breeze past it pretty quickly
the main idea is that an idea starts out
as a basic research idea and moves
through a series of stages in which the
concept is refined it's it's clarified
and refined and improved it goes through
a couple of phases where people try it
out
first find out how it works and second
to find out whether it will work for
them and then eventually it gets used by
outsiders not just to find out what it's
for but by outsiders to solve their own
problems and eventually becomes
popularized and propagates through the
community of course not all ideas do
this part of the reason that that that
it's okay for there to be this long
chain is that bad ideas get filtered out
early before they hurt bystanders so
here are the principle dates for that
process for software architecture there
was a period of foundations and I I want
to skip on through this in the interest
of getting into the rest of the talk
there was a basic research period around
1985 to 93 where the ideas were were
sorted out there was some explorations
and languages and formalizations in 1992
to 96 period of development and
extension in 1995 to 2000 you can see
there's some overlap here
coupled with internal exploration at
pretty much the same time here we're
getting some some evaluation techniques
we're beginning to get some books out
and then from 1998 we saw the
technologies useful outside the
development groups some tools and
frameworks
some companies specific architectures
and then moving on into popularization
we now have some standards
commercialized technology education
professional organizations and in many
companies the architect has become the
the senior technical leader of the
company and then just to go back to to
this idea of layers there was the
multics layered system there was the
layered system of the 1980 era there was
the the templates of the system and from
that we have now come around the corner
and we have reached the point of popular
culture where comic xkcd can say
here is a layered system and the layered
system works like this and now they need
that the individual layers have names
you recognize the names and you can use
it all to watch a cat fall out of the
box so we we've reached we've reached
popular culture that's some kind of
landmark and and we do now have some
systematically organized knowledge
there's a series of books from the
software engineering Institute that
present a lot of it in various ways
Paul Clements and I did a taxonomy of
styles what's interesting about this is
the right-hand column where for each of
the class of styles we identified a
particular type of reasoning that is
appropriate to that style so if you're
doing a data flow kind of system then
functional composition and latency or
perhaps the ant analyses you want to do
whereas if you're doing a data centered
repository that would include your
favorite database then then acid
properties and transaction rates are or
what you might care about and we also
identified some rules of thumb this
isn't this isn't settled science but
this is based on experience if your
problem is decomposed in the sequence or
stages consider a batch sequential
system or a pipeline architecture and so
forth so we can we can say some systemic
things that are not settled science but
are still useful guidance we've also
done some exploration as a as a field
about generality power trades so we we
know that we can use generic styles
which are very broadly applicable but
don't offer a lot of power and that we
can move up the generality power
trade-off to have product lines that are
only good for one thing but they're very
powerful at that one thing and the
interesting bit is that there are
intermediate points along the way okay
but the question is is it engineering
yet well remember our good old friend
the the D bridge collapse there's a
there's a firm standard I think
engineering is associated with a level
of a sure
rats that protects the public health
safety and welfare it's kind of a social
contract that we make with the community
that if we want to call ourselves
engineers that the stuff that we will
produce will be worthy stuff but
consider ripped from the headlines
Toyota's unexpected ends acceleration
case of last year
data breaches more numerous to count
this week's did you see the headline
Tuesday about the Samsung Galaxy s5 and
s6 and s6 key boy to exploit it it
appears that if you that the operating
system on the the galaxy periodically
pulls for an update for a certain kind
of keyboard that you might or might not
be using it if it gets a response it
executed at a very high privilege level
and it's vulnerable to a
man-in-the-middle attack on an unsecured
Wi-Fi network and oh by the way you
can't delete this from your operating
system this was this was demonstrated at
Def Con last Tuesday and everyone is now
scrambling to get patches out so there's
there's every every week there's
headlines about what were they thinking
the Toyota unintended acceleration case
is one in which there was an electronic
throttle control system in model years
2002 to 2010 it could occasionally
happen that the throttle stuck open and
you could not stop the car this actually
happened once to a test driver this
wasn't some amateur who couldn't figure
out how to stop the car he couldn't stop
the car
they settled the lawsuit for over a
billion and a half US dollars and that
doesn't that's not the end of it because
more lawsuits are coming out of the
woodwork basically the problem seems to
be that stray electronic radiation can
kill processes in things like throttle
control systems there is a process that
if the process dies
the throttle will stick open there
supposed to be a watchdog process but
sometimes the watchdog process doesn't
detect the expiration of the critical
process and when that happens the only
way to restart the process is to
completely take your foot off the brake
and then step on the brake firmly which
is not something to it that really
occurs to anyone whose car is speeding
down the highway out of out of control
so this was this was pretty much
attributed to the software the software
didn't follow them follow known good
practices they the watchdog didn't
detect a major task failure the
cyclomatic complexity was sometimes in
the three digits they had 10,000 global
variables recursion could cause on
caught Stack Overflow and they had poor
compliance with even the testing
standards that they claimed to have okay
folks this isn't really engineering in
the data breaches Department the big one
in the headline last week is the US
government with four million personnel
records were breached this is a summary
chart from 2014 from an outfit that
tracks the united states only data
breaches 494 2014 they have a report of
783 data breaches in banking business
education government and medical and the
number of records compromised is at
least 85 million and I've looked at the
data and many of these reports on
breaches don't report the number of
records put in jeopardy so you know it's
more than 85 million okay that list can
go on there's a there's a mailing list
called risks where you can read about a
lot of them if you want to but let's go
back to the characteristics of
engineering and and try to check off
where we are
well engineering forces us to make
trade-off decisions based on limited
time and knowledge and resources check
we use the best codified knowledge to
shape designs
sessions sometimes reference materials
make this knowledge and experience
available I think we're really falling
down on that one and the analysis of a
design predicts the properties of the
implementation sometimes so to put this
on the the engineering evolution
timeline the software development
methods of the 70s to the 90s were where
we learned about production around 1990
those were widely adopted and I would
say that professional engineering is
emerging but spotty okay so the question
then is how do we make progress and by
the way I'm not sewing a book but if you
want to be part of making progress we
have both a PhD program and a
professional master's program in
software engineering and there in the
corner is the URL where you can come and
find out about it so thinking about
making progress I think it's useful to
spread out the kinds of applications
we're working with and for me it's
useful to spread them out across two
dimensions one is how bad is it if it
goes wrong that's the vertical axis and
the other is is any live human being who
understands what's going on likely to
discover that something is going wrong
and do something about it that's the
horizontal axis with full automation on
the right and manual operation on the
left so there are things here that I
really really care about like nuclear
power plant shut down I think that
really ought to work there are things
that I don't appointment scheduling
finding a restaurant it's not so bad I
will probably notice if my restaurant
Finder doesn't find a note a restaurant
and I'm not gonna starve so there's
there's some leeway here and I and I
think you really want to be applying
engineering techniques for sure in the
upper right hand corner and then there's
a there's a scale but notice that things
tend to move to the right so automobile
cruise control used to just keep the
throttle going so that you didn't drift
let the car slow down we're moving into
advanced cruise control that will
actually cause the car to change lanes
pass and move back in again and and
people are working on self-driving cars
so when you think about the
implementation of some application
remember that if it's successful it's
going to move to the right and there's
going to be less opportunity for manual
oversight so I that the greatest need
for engineering discipline is in the
upper right hand corner and there
there's a there's a gradient that takes
you there but what about getting there
well our technology is moving really
fast we're not keeping up with it and
there are ways that we could take
advantage of it
to do better one is to understand this
problem of getting access to the prior
knowledge in classical engineering they
print paper hand books perhaps every 15
years that's obviously a non-starter for
us but what we're doing now is tossing
the software up for providing minimal
documentation of the API and letting
user groups and blogs describe what
problems they had had and how they
resolve them that's not good either but
but but we understand search much better
than we ever did so the question is how
could we use search to supplant editing
and indexing as a way of getting access
to prior material could we could we find
some analog of MapReduce that lets us
farm out the documentation problem so
that people can write little snippets
and let them let them come together
don't know but that's an idea we we're
facing agility which is a reluctance to
document resistance to upfront structure
we have systems that are in perpetual
data and they just evolve through the
tolerance of users we ought to be
thinking harder about the power end of
the generality trade-off and embedding
some of this knowledge in task specific
tools so that the people could use
domain-specific languages
rather than dropping into whatever the
favorite language of anyone in this room
might be and we need to think about
scaling the costs to the consequences so
these are in large measure about getting
the codified knowledge that we actually
have connected with the tasks and
finally I think a charge for all of us
not just to mature a software
engineering but for all of us as
computing professionals is to try to
help civilize the electronic frontier we
have had a wild and woolly electronic
frontier the Cowboys have had a lot of
fun out here but it's time to make it a
civil place for the rest of the world
and that means infrastructure and
amenities it means civil order good
manners the rule of law empowering
citizens at large to actually understand
how to manage their own computing and to
get some clarity on personal security
and responsibility this requires that
that the public at large understand the
technology much much better than we have
made it possible to why do we care well
there are lots of casual developers out
there on the Left we have a projection
that crisco feeding and I did a few
years ago about the about the American
workplace and this is the American
workplace not the world the world
workplace the drawing is to scale across
the bottom we see along about now that
there ought to be about two and a half
million highly trained computer
professionals computer scientists
programmers software engineers there are
something like 90 million of people out
there who are doing programming like
things they're building databases
they're building spreadsheets they're
using scripting languages they're
building sophisticated websites what are
we doing to help them well we're not
reaching them necessarily through our
training programs because on the right
we have a poll from Stack Overflow from
earlier this year Stack Overflow serves
professional and enthusiast programmers
they pulled their members
and 41.8% of them say they are
self-taught notice that the numbers add
up to more than a hundred percent so
some people are reporting in twice but
the bachelor's degree in computer
science or a related field is less than
40 percent there's a lot of on-the-job
training an online class other boot camp
and what-have-you
so there are lots of people developing
software and it's our responsibility in
software engineers to make them able to
develop sound predictably reliable
predictably secure software there's an
organization in the United States that
that tracks us internet usage the main
point of this slide is that the
demographics say that already almost
everybody is online and this says what
it is they do and we'll zoom in on this
bit everybody searches everybody looks
for health information almost everybody
gets news it's interesting that the
columns correspond to 10-year age
brackets it's interesting that that
younger people have social network sites
way high on the list and older people
have social network sites way low on the
list so there's there's a lot of a lot
of texture and what people are actually
doing so symbolizing the front the
frontier involves three kinds of things
one is a policy and that policy is going
to have to be informed by technology
it's going to have to strike balances
among anonymous anonymity and
accountability between security and
privacy dealing with product liability
there are also technology issues in
actually applying the best knowledge
that we have and in figuring out how to
convert some of the old problems that we
have to use the new technologies like
search rather than indexing and
management of independent software
components and
the police I think we have mostly fallen
down is providing user models that help
the public at large understands what's
actually going on anyway I'd like to
think of my various collaborators for
collaborating with me and here's a
recapitulation which is that there's a
history about the way in engineering
discipline evolves that our engineering
basis has evolved through increasingly
powerful abstractions that these ideas
evolve over time from bright ideas to
things that are actually useful with
fall out of hopefully of bad ideas along
the way and that the greatest need for
engineering is in the most critical
applications but you can't draw a line
there's there's a gradient where the
more critical at the application the
greater the intensity of your need for
engineering so thank you very much I
appreciate being invited and appreciated
having talked to many of you this week
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>