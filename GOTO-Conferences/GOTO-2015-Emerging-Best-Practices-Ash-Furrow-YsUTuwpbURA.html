<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Emerging Best Practices • Ash Furrow | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Emerging Best Practices • Ash Furrow - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Emerging Best Practices • Ash Furrow</b></h2><h5 class="post__date">2015-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YsUTuwpbURA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">(soothing music)
Today we are going
to talk about emerging
best practices in Swift.
Before we get started I
want to start with a story.
Last summer Swift was
announced and then released
and I was excited,
because I did not like
Objective-C.
I went around giving talks
about Swift, and specifically
about solving familiar
problems in new ways
because we have this whole new language.
It would be a shame
not to take advantage
of the new things that Swift can do.
I was telling everyone to not
treat Swift like Objective-C
and that is because I was
terrified that we were just
going to solve problems in the
same way that we have always
solved them with Objective-C,
but using Swift syntax.
That did not sit
well with me because I was
so excited about Swift
that the idea of not taking
full advantage of the cool
new things Swift can do
just gives me shivers.
But, it turned out everything was fine.
The community and Apple have
exceeded my expectations
in terms of what I had hoped for.
We have embraced Swift and
used it capabilities to
explore the new ways that
we can solve the familiar
problems that we are all used to.
Problems that exist on iOS
regardless of the language
you use.
We have actually taken a
look and found new ways
that we had no idea. No one
knew how to do this before
and we figured it out.
Those have become best practices.
How do we talk about
best practices in Swift?
This is not
a listicle of a talk.
I am not going to be giving
you the 13 best practices
in Swift, number four will blow your mind.
That is not
what I am here to do.
I am here for two reasons:
1) What do best practices look like?
2) How do we find new ones?
I think those are
interesting questions
I am going to
mention some technical topics
and there is going to be
some code on the slides,
but mainly this is a talk
to try and prime all of us
to look out for interesting ways
to solve familiar problems.
More important than a
list is the process
of how we get there.
To discover that
process and to discuss it
we are going discuss five things.
1) Take a look at the history
of the iOS community.
We have been in a similar situation
before. I know this is the
first time Swift's ever been out
but we have seen
changes like Swift come before.
2) Talk about learning
(and how you should do it
always, not just when
Xcode is in a beta period).
3) Never throw ideas away
(they are very precious).
4) Force yourself to think
(which is how you come up
with new best practices).
5) Abstraction.
(I am excited.
This looks familiar).
We have been in a similar
situation to Swift before.
(Before I get into exactly
what that was I need to dispel
a common misconception).
(You have probably heard
this expression before:
&quot;Those who do not study history
are doomed to repeat it,&quot;)
(right?)
(This has been said by many
people, I tried to find
an original citation for this
to find out who said it first,
could not do it).
(It has been said for at least 300 years,
probably longer than that;
it is depressing).
Think about it, &quot;Those
who do not study the past
&quot;are doomed to repeat it.&quot;
Those who do not know history
are doomed to repeat it:
that is sad.
That implies that
history only has mistakes
and that repeating history
is necessarily a bad thing.
That is not true.
We can think about
things in recent history
or even longer ago that were
good ideas, ideas that we
want to keep doing or ideas
that we would like to repeat.
It is not fair to say
that those who do not know
history are doomed to repeat
it, because repeating it
is not  necessarily a bad thing.
A more accurate statement
in my opinion would be,
&quot;Those who do not understand
the past cannot make
&quot;informed decisions about the present.&quot;
(History).
(Can I see a show of hands of
everyone who developed for
iOS 5 or earlier?)
(cool).
What I am about to show
you may stir some memories
that you would rather not remember.
For everyone else in the
room the following slide
may look shocking.
Before iOS 5 we did not have
object literals; this
is how we created arrays,
dictionaries,
and NSNumbers.
(Terrible)
Arrays have this arrayWithObjects,
this is the short-hand syntax by the way.
You have this nil
terminated list of things,
dictionaryWithObjectsAndKeys
and numberWithInt,
numberwithBool, numberWithFloat,
numberWithLong.
It was tedious and if you were
doing this before ARC it is even worse.
Some of you may have
noticed but there is actually
a mistake on this slide because
dictionaryWithObjectsAndKeys
the objects come first;
the Key is &quot;Not Me&quot;
and the value is &quot;Who would
do this?&quot;, which is backwards.
I have done this mistake a few times.
(sighs)
I am so glad we do not
have to do that anymore.
(Now, we do this).
We have object literals,
arrays are created with
an @ and then square brackets,
dictionaries @ curly braces,
NSNumbers are created
using
boxed expressions (put an
@ the expression that comes
after it is evaluated as a number).
That is a huge improvement.
They are better.
Universally better.
There is not a reason why you would not
want to use object literals.
(I have not
been able to think of one).
They have been adopted by the
community almost immediately
everyone switched to these
because there was no reason
not to and Xcode had a built in feature
where it would do it for you.
Using object literals
became what you might call
a best practice.
What else came out
a year before object literals?
(Anyone have a guess of
what I am about to say?)
Blocks.
Blocks came out in 2010 for iOS 4.
Blocks were great, I was
excited about blocks.
Introduced in iOS 4, adopted
slowly but surely.
Blocks are exciting
because they require
a new way to think.
Before you had executable
code that could be referred to
as data, you could not solve
problems in certain ways.
You were restricted by the language.
When blocks came out,
they had
a weird syntax and were hard too adopt,
but also iOS developers
were used to solving problems
without them.
We were used to solving
problems with protocols,
and delegation, or target
action, or any number of ways.
Did using blocks become a best practice?
Is using
an if statement a best practice?
Blocks are just syntax.
They enable other best practices.
The key here is using blocks
and saying, &quot;Oh, use a
block because it is better
than a delegation or a
target action,&quot;
(not the point).
The point is with blocks we
can do cool things.
We can do functional reactor programming,
or we can execute a block
of code in a context,
for example, an animation.
Before, if you wanted to
animate something you would
call a method that says, &quot;I
am beginning the animation,&quot;
and then you would change
things, and then you had
better call a method at the end that says,
&quot;And now the animation is over.&quot;
(That is weird).
If you needed to be
notified of when that animation
was complete, that is a lot of work.
We could also do call backs when
an asynchronous network
response has been delivered.
Collection operations,
we can now enumerate over
a collection (e.g. an array
of things), or we could map it
into an array of something else.
New ideas at the time.
Even some of them are
still kind of new to iOS.
But they are only enabled by blocks.
These might be best practices.
But blocks? No.
My point is: we embraced change.
We have the blocks and we are like,
&quot;Let's do something with them.&quot;
It has taken five years
to get to where we are now,
but I am  proud and excited
that we have accomplished as
a community in that time.
We have a history of
taking the new technology
that Apple has provided
for iOS development
and doing amazing things with it.
That brings us to Swift 2.
Swift 2 is the second version
of Apple's programming
language, first announced
and released last year.
(Exciting stuff, I
was thrilled with Swift).
(The more I use Swift
2 the more I like it).
Swift 2 includes new syntax.
New syntax lets us do new
things (like the new block
syntax let us do new things with blocks).
But, syntax is only a tool.
Like blocks, the new syntax in
Swift is not something
you can classify as a best
practice (because it does not
make sense).
Things like guards statements,
or defer statements,
or throwing with new air handling.
(yelling in background)
(laughs)
These are syntax, but there is not
a best practice of throwing something
(e.g. using defer is not a best practice).
A question that you might
ask is, &quot;Should I use guard?&quot;
(But, that is not quite the
right question, is it?)
The right question is,
&quot;What can I do with guard?&quot;
Now that I have this new
capability and this new syntax
what can I do with it?
(a much more interesting question).
Let's take a look at a few examples.
First of all, we have the Pyramid of Doom.
(named because it has
this triangle or pyramid
coming in from the left,
creeping towards the right).
I am sure you have all written
code like this (I have for sure).
Writing code like this is
easy (but writing code
is always easy).
The hard part is reading it.
This code (particularly
with the Pyramid of Doom)
makes it even more
difficult than it has to be.
Swift 2 intorduced
compound if/let statements
and where clauses.
We have something like this now.
This is semantically identical
code, we are binding two
variables, two optional variable
and we have a where clause
that obviates the need for
one of the if statements.
Let's take a look at another example.
Mutability, this is very Objective-C code
(this was what I was afraid
of when Swift came out).
I was afraid that people
we are going to write this Swift.
This is Obective-C in Swift
syntax and it looks terrible.
(I am not even going to go over what it does,
because it does not matter.
it is terrible).
What we want to write instead
is something like this.
This is the same function,
it takes an array of strings,
and it takes a prefix and
it returns you any of those
strings that you gave it
that start with the prefix
(that is all it does).
Less typing, more expressive.
It maybe easy to write,
but it is more easy to read.
It is more expressive.
Another thing I want to
talk about is currying.
(This is one of those weird
words that you may have heard
and you may have avoided it
because some of these like
functional programming
gurus are jerks
and they use it a lot).
It is actually a useful tool;
not as complicated as you might think.
Currying is useful
when you have a function,
and another function,... and they
do almost the same thing.
(useful for providing
customization to a function).
Let's take a look at an example.
I have a function
called containsAtSign.
It takes a string, returns a
boolean and it returns true
if that string contains an at
sign (fairly straight forward).
Now, you have, say an array
of strings called input,
you cna filter them based on
which ones contain an at sign.
Because we have a function
(functions are identical
semantically to closures
and the filter function
takes a closure that goes
from whatever is in the array
to a boolean), we can pass in
a reference to the function
directly into the filter closure.
(This is good, this is great,
but it can be even better).
Let's take a look at currying.
Now, instead of a
containsAtSign function we have
a contains function.
It takes a substring and
it returns a closure.
That closure goes
from a string to a boolean.
You can see the
closure that we are returning
inside the function takes
a thing called a string
returns a boolean and does
the exact same thing, except
now instead of an at sign
literal we are using the substring
parameter passed into the
original function. We can
can call it like this.
Instead of having a
function for containsAtSign,
a function for
containsPercentSign, a function
for containsDollarSign we just
have one contains function,
we give it the little bit of
customization that it needs
and it does the rest for us.
This is powerful, and
it is so important to the Swift
developers at Apple. I do not
mean, &quot;I am a Swift
&quot;developer,&quot;  the
people who develop Swift,
that they introduced a
syntactic sugar for it.
This is a semantically
identical expression.
It goes from a substring
and returns you a closure
that goes from string to
bool (it looks funny
at first, but I am telling you
like the first or second time
you do this you get used
to it quickly
and it is so much fun).
Another interesting
thing that Swift let us do,
Swift 1 even, associated values on enums.
You create a enum you attach
an associated value to it
and you extract that value
through a case statement.
In Swift 1 case statements
were only available inside
of a switch block.
You would write code like this.
You have an enum at the top,
it has a success and a failure.
If it failed we'd like to know why.
We have an associated value, a reason.
It is a string that we
can present to the user
about why something did not work.
Say, there is a function
called doThing, it returns
one of these results if it is
a success then we print
(party time); if
it is not then we can extract
the reason from the case
and print it out, too.
This was great but Swift
2 got even better because
it let us take case statements
outside of switches.
If we do not care about the
success case, if we only care
if something went wrong we
can write code like this.
We can say if it is a failure
then extract the reason.
Again, it is
unfamiliar syntax, but it is not
complicated syntax.
This is something that we
can adopt easily.
Is this a best practice?
No, just syntax.
What does it matter
that we can use case statements
outside of switch statements?
it is easier to do (which is nice).
It might enable us to do
things more easily or quickly.
What matters are the ideas.
Swift 2 introduces a ot of
new syntax that lets us do
new things, and
we need to look for the new
things that it lets us do.
For example, I am sure many
of you have heard of this
buzzword going around
&quot;protocol-oriented programming&quot;.
What does that mean?
it is a interesting idea
that Apple has come up with
around using protocols
instead of class hierarchies
to contain information (interesting).
Will it become best practice?
Maybe. I think
it looks is cool.
Unfortunately, I do not have
time to go into right now,
I just encourage you to all
go watch the WWDC video.
Apple has cool ideas
about what a best practice
in Swift might look like.
I bet other people have
ideas, too. Let's go ask them.
There are other communities
out there besides iOS,
besides Objective-C and Swift.
Apple has clearly taken
ques from other programming
languages (Ruby, and
JavaScript, and Scala).
There are tons
of communities out there
who have similar syntax and
similar capabilities to Swift.
I wonder what solutions
and what best practices
work for them, and why?
Are the solutions they use
something that we could use?
Are the solutions that
they choose not to use
something that are appropriate for us?
We should go and ask them,
or better yet we should
go out and learn Python over a weekend,
it is been on my to-do
list for like a year,
just to see what they do and
see if some of those ideas
can be brought over to Swift.
How do you tell if something
is just a piece of syntax
or if it is an idea that
can become a best practice.
You cannot.
I have been lying to you,
it is a very false dicotomy.
there is no like right or wrong,
there is nothing that says
This is syntax, but this is an idea.
it is the if/else statement
I mentioned earlier.
Is using an if statement a
best practice or is it syntax?
It is both.
How would you do
things without if statements?
What I am trying to say is:
we have
to go try stuff.
You have to try things and
see, maybe they will work
maybe they will not, but we
will not know until we try.
Which brings us to
&quot;Never throw away ideas.&quot;
Swift was released and I treated it
like object literals instead of blocks.
I treated it as something that
we should use all the time
because it is universally
better and I threw away
the ideas that Objective-C had.
Some of those ideas are worth
keeping, for example, Swift
still does not have a replacement
for key value observation.
That is something we still need to use
the Objective-C runtime for.
Older ideas have merit, too.
Even if a community, maybe
there is something interesting
in Cobalt that would be
cool to implement in Swift.
I do not know, because I
have not learned Cobalt,
I am not going to, but you
know it is something worth
exploring and worth thinking about.
The tragedy is that iOS
developers throw things away
all the time.
In general, developers
do, but iOS developers
do it a lot.
Why?
We will get to that
eventually, but I want to take you
through a pattern
that I have noticed in my own
career (and maybe you have
noticed it in yours
or others as well).
We have a beginner, they have
never programmed before
and they are learning iOS.
They learn something (e.g. Objective-C)
and they are bad at it
(because they are a beginner)
and a beginners are bad
at things
(that is how we learn: to be
bad, and improve).
They blame their frustration
on the thing, they assume that
because they are frustrated
with it and they are bad at
it, that it must be bad.
But, they get more experience.
They learn Objective-C
and iOS, and then Swift comes out.
Learning the new thing is easier
than learning the old thing.
They assume it is because
the new thing is better,
but in reality it is also because they have
more experience, and it is
easier to learn things.
They have mixed these two
ideas up (they have crossed wires
in their brain, they had
an old thing that was hard
to learn because they were
a beginner, they have a new
thing that is easy to learn
partially because they have
more experience).
This is why new ideas are appealing.
This is why the new and shiny
APIs that come out every year
are exciting while the
old ones are so terrifying
and gross.
We blame the older version of iOS.
It is a running joke in our community:
we cannot wait to drop iOS 9 support,
cannot wait for iOS X.
iOS is constantly changing;
Apple is always providing us
with brand new APIs. That
means that there is a constant
supply of old APIs for us to be angry at
and for us to blame.
I do not think they are
doing this on purpose;
I think Apple is doing
their best to give us APIs
that enable us to build cool applications,
because that will make them money.
This is a side effect, not something
we need to be ashamed;
it is something it
would be nice to acknowledge
and realize that,
if we see ourself doing this
maybe step back and think about iOS 8
or 7, is not so bad.
(I want to take a side track.
This is something that has been
on my mind for a long time).
I want to talk about refactoring.
(This is a term that I hear all
the time, people tweet about
refactoring the view controller
or refactoring an object
into some smaller objects,
maybe they talk about
refactoring an entire
project over the weekend).
(Keep using that word, I do not
think you know what it means,
&quot;I do not think it means
what you think it means.&quot;)
What is not a refactor?
If you are adding new functionality
that is not a refactor.
If you are changing the public
interface for your type,
that is not a refactor.
A refactor does not
change a type's behavior.
If it used to do something
and it does not anymore,
or if it did not and now it
does that is not a refactor.
that is a re-write.
This is a very simple test.
Do you have to change a unit test.
If you do, then that is
a re-write, if you do not
then you are actually
refactoring something.
Why does this matter?
Because re-writes are
bad and this is not me
(here at the front of
the room, who cares
what I think).
Someone much smarter than me said this.
I read this article earlier
in my career and it had
a big impact on me.
Joel Spolsky wrote this:
Things You Should Never Do,
Part 1: dedicated
to rewriting software.
Never re-write software.
Now, granted this blog post was discussing
Netscape (an entire application,
not a view controller).
The idea that you should never re-write
a view controller does not hold water.
But, what is an
application but just a collection
of view controllers?
If you should never
re-write applications,
maybe we should be more
careful about re-writing
our view controllers.
We should favor incremental change.
I do not think that code
is necessarily valuable.
I think that code is
pretty worthless, and
the code I write now is not going to have
any value in a year or ten years even.
Throwing code away and
replacing it with something
brand new is dangerous, because
you lack the context for
how that code interacts
with the rest of the code.
That is why re-writing is
terrible, because it will always take
longer than you think and
you will always make mistakes
that you do not anticipate.
If we should not
throw away ideas
or code, the two things we should
never throw away are code and ideas.
Maybe there is something
interesting in Obejctive-C
that I still do not know, but
I should learn about in order
to do it in Swift, or bring
that idea over to Swift.
Maybe my project that is
in Objective-C can stay in
Objective-C and any new
classes I add can be written
in Swift.
I do not have to throw away
everything just to embrace
the new thing.
(That is rant number one).
Let's talk about unit testing.
Unit testing is going to help
you change your code better.
These incremental changes
that I am asking you to do
you do this with unit tests.
I want to talk
about what that means.
Unit testing, controversial topic
in iOS, not so controversial
literally anywhere else.
We are the only
people who have a
big problem with unit testing.
Individual developers
know that communities
do not like it, but as
iOS is allergic to it,
at least that is how we act.
We will get into that later.
First, I want to make a
presumption that unit testing
is a good idea.
If you do not agree with
that just park that belief
and assume that I am right
just for this slide,
and the one after that,
and the one after that.
I do not  care that
much about the tests.
There is this idea
&quot;I have never caught
&quot;a bug because of a unit
test - unit testing
&quot;must not be that valuable&quot;
If the only value you see
in unit tests are the actual
tests, then you are
missing the point.
I care more about writing
the test because of the way
that writing tests changes
how I write the code.
Writing tests forces me to
think about what I am doing,
which is kind of important,
especially in the context
of how to find new best practices.
We cannot find new best
practices unless we are thinking
about them.
(makes sense, right?)
Testing forces us to
think so maybe unit testing
will help us discover the best practices.
One of the biggest
advantages to unit testing
is that it limits the scope of your object
because you need to think about it.
If you have an object
that is complex
and does many things that is
very difficult to test
and you are more likely to
make several smaller objects
that each do one thing
individually, but do them well.
That is better because now you
have more cohesive objects
that do only one thing and
you do not have behavior
that is coupled to each other.
Part of the object
depends on this other part
but also depends on this.
It depends
on the way it used to be.
You do not have that
because everything is separated
into individual components.
How do you limit the scope?
The best way is to control
your public interface
and you do that in conjunction
with something called
dependency injection
which is the scariest word
in software development.
Dependency injection?
(I do not want to do it, I
did not even want to look up
what it meant).
I looked it up, I went on Wikipedia
and it is complicated.
(it is not, trust me, Wikipedia
is just like,
if you did not know what a
computer was and you went
to WIkipedia and it told you
that a computer is a machine
of formal logic that processes
input and blah, blah,
blah, blah, blah.
It would be  confusing, right?)
Same with dependency injection,
it is not that complicated
of a topic.
Dependency injection is a five euro word
for a five cent idea.
(Ward is laughing because he
uses this expression a lot).
The idea of dependency injection,
your thing should not
create the things it needs.
That is it.
Let me repeat that:
the thing you are making
should not itself create the
other things that it needs
to do it is job.
Let's look at some examples.
This is what I would say a pretty standard
iOs view controller.
It has a networking
controller and if you did load
it fetches stuff from the network.
Once that is done, a completion block
is invoked and it shows that stuff.
Very straight forward,
there is nothing wrong
with this view controller.
I have written this view
controller many times.
I imagine most of you have too.
How does it look different
with dependency injection?
Look at the slides carefully;
see if you can tell the difference.
(anybody miss it?)
(it is right there).
We are no longer creating
the network controller.
Instead, we have a network controller,
it is variable because we need to set it
to something later on.
It is an optional network
controller and now when
viewDidLoad is called we
ask our network controller
to fetch stuff.
When it is done it invokes
our completion block
and we show that stuff.
That is exactly the same,
nothing in the rest
of our class has changed.
The only thing that is changed
is the line that defines
the network controller.
We are relying on someone
else to create the network
controller for us and give it to us.
It could be another part of
our app, maybe in prepare
for Segue.
The view controller before
us created a network
controller for us, or maybe
it passed in a reference
to the one it had.
Maybe it is a unit test.
(This is the exciting
part, and we will get to
what that means later).
Dependency injection is not that hard.
Protocols work well for this.
Let's take a look at a
hypothetical network controller
protocol.
It has a function, fetchStuff.
It accepts a completion
block that it calls
when it does the fetching.
Let's take a look at an
API network controller.
This is a specific class
that conforms to the protcol.
It has the fetchStuff function.
(I have not implemented
it yet, but you can get
the idea of what I am going to do).
I am going to go to the network, fetchStuff,
and then invoke the completion block.
(In my unit test I would
have something like this.)
A test network controller
conforms to the same protocol.
Instead of fetching from the network
it uses stubbed data
that I know ahead of time
and it immediately invokes
the completion block.
Now, I can configure the
test controller, pass it into
the view controller, and
ask the view controller
to do something and test it is behavior.
I have a protocol (and
does whatever), I do not care about that
for the purposes of unit tests.
I will test that independently later.
I have a protocol and I
conform to that protocol
in my mock, this test network controller.
I do something that I
know what it is going to do
ahead of time and I know
how I expect the view
controller to react.
Then, I test to
make sure that reaction
is what I expect.
(That is all dependency injection is).
The use of protocols helps you limit scope
(because you have a
clearly defined contract
about what your individual
object is supposed to do).
Adding a method to your
protocol now becomes
a decision.
You do not have access to the
entire class list of functions,
even the internal ones that
should not know about.
If it is not in the
protocol you cannot call it
(deal).
If you want to call it you
have to make the decision
to add it to the protocol (that is fine,
sometimes it makes sense to).
Dependency injection is
more useful than just that.
Let's talk about shared
state and singletons.

(I do not know what Sal's reaction
is going to be).
Singletons are not that bad,
if you use dependency injection.
Let's say we have this
function called loadAppSetup.
(something you call
when your app launches).
It is responsibility is to check and see,
&quot;Have I launched before?
&quot;If I have not launched before then show
&quot;the user something,&quot;
maybe a login in screen
(who cares?)
It grabs something out of NSUserDefaults
standardUserDefaults;
if it has not happened yet
then it calls some function.
How would you test that?
I have no idea.
You are going to clear
out the standardUserDefault
and then set them up
for your specific test.
Then, make sure to clear them out
afterwards (so it does not
pollute the next test you run).
(it sounds a lot of work).
Dependency injection
would have us inject
the defaults into the function (that is it).
This is now a dependency
injection friendly function.
Do not be an ideologue.
It does not always make sense to do things.
Sometimes you need to break
the rules and sometimes
you need to cheat.
Sometimes you need to bend the rules,
and sometimes you need to
ignore them altogether.
This is how I would
cheat with that function.
I would say, &quot;same
thing but I am going to provide
&quot;a default parameter value
of the standardUnitDefaults.&quot;
Now, if I do not specify a
parameter it is going to fall back
to the standardUserDefaults.
(That is great for my application
because it is less typing for me).
In my unit tests I
can create my own user defaults
that are not the standard
ones (not shared
with anybody else).
I can inject them in.
This is what it looks like,
loadAppSetup. Nothing has
changed from the rest of the
application's perspective,
but in the unit tests
now we can inject that in
and our tests become
simpler and they become
isolated (which is what you want in tests).
Let's go back to our
view controller example.
Using the same cheat I might
have the network controller
property set to the
API network controller,
but critically important
here is the fact that I am
specifying that it
conforms to the protocol.
The view controller
still does not have access
to the actual API network controller.
It only has access to the protocol
(exactly what we want).
Nothing else in the view
controller has changed.
You could test this now
by creating the view
controller, creating a stubbed
or mocked version of the
network controller protocol
and injecting it in.
As long as you inject it
before the view is loaded
then you can test your
controller (easy).
There is this amazing
quote by Mackenzie King,
prime minister of Canada in the 40s.
He said, &quot;TDD if necessary,
but not necessarily TDD.&quot;
People have compared him to
Winston Churchill of Canada
(which I quite like because
his management style
was saying things that were so inscrutable
that you could not disagree with him).
(Obviously, that is what I am
trying to do right now).
Let's review unit testing.
Do not test private
functions, also start marking
your functions as private.
By default
they are internal, which
means you can call them
and you should not be calling them.
Avoid re-writing wherever possible,
and do not test your implementation.
Remember the goal of unit
testing is to test the behavior
of the public interface.
In an ideal world every
object would only have one
public function.
(We do not live in an
ideal world, but just imagine.)
Last week Justin Sirls had
this amazing post
about using partial mocks.
A partial mock is something real,
but also fake.
In our example we could not do
it because we used protocols;
say intead of protocols
we used subclassing,
but we only overwrote some of the methods,
some of the functions.
Some of the behavior is
real and some of it is fake.
(He compares it to testing cars.
Unit testing is just
like testing car safety.
A mock would be a
crash test dummy, whatever you call it.
Those like people
with little like yellow
and black circles, and you
know, they measure the force
that they experience when
a car crashes.
That is our double,
those are useful).
(A partial mock is someone
wearing a Halloween costume
that looks like a test crash dummy.
How is that useful in testing
the safety of the car?)
(You probably do not want to
crash them into a wall
and see if they survive).
(It would be much better to use a full,
actual test crash dummy).
Why do not iOS developers like testing?
I think it comes down to this:
it is unfamiliar and no
one forces us to do it
(a silly reason not to do something).
(Going to the doctor is unfamiliar
and I do not like to do it
and my mom has not forced
me to go to the doctor in 10 years.
Maybe I should go to the doctor
if I am feeling sick even
though I do not like to.
that is the same thing with unit testing).
It is good for us, even though it feels
 weird at first.
(I could not come up with a
better metaphor, I am sorry).
(laughs)
Testing has made me a better developer
(I think it will make
you a better developer too
if you try it).
I want to make code that is easy
to maintain, that is easy
to expand upon later,
and that I am proud of.
Unit testing helps
me do those three things.
Last section
of the talk, abstraction.
(&quot;this has already
been an abstract talk,
&quot;and now he is going to talk
about abstraction&quot;).
I worked at a company who said this,
&quot;If you are repeating two
or more lines of code,
&quot;then you are doing it
wrong, you need to find
&quot;an abstraction and do it a better way.&quot;
(What?)
Creating a label and
then adding it to my view
that is two lines of code.
&quot;Abstract it.&quot;

(At first it was difficult to do
but after a day or two I liked it).
(After a few weeks I
went back to my old project
and I thought it was bananas,
look at all this
duplicated code, I am adding
a label here, and here,
and here, and here).
(It was terrible, I  did not like it.
And now, I try and take this to heart.
I do not always do it, but it is something
I am always looking for).
You are already learning
new syntax with Swift 2.
Let's look for new
abstractions along the way.
Let's try new things.
Not all the ideas are
going to work out, in fact,
most of them will not, but that is
you should still do it.
Experimentation has personal
and professional benefits.
It is satisfying to play
around with a new thing.
This is why we
all download the betas
of Xcode and try and
build things with them.
(it is fun to try new things).
Let's do that with abstractions, too.
It is also professional development:
if we find something
new that works,
we can build better code
that is better for our employers.
That is the case you
should make to your boss
when he is, &quot;Why are you
downloading the Xcode beta?&quot;
(that is how you do it.
A good idea).
(I had another point, but I forgot it.
Even if you try
something and it does not work,
this is the point, I remembered).
Even if you try something
and it does not work
you still understand that solution.
(You try technique and
it blows up in your face).
Now you know that you
should not use that technique,
but maybe that technique would be valuable
in another scenario, another
solution, another problem
somewhere else.
When you try
something maybe it does not work
but you still learn something.
In my opinion, that is
the case for the idea
that there is no such thing
as a failed experiment.
If you try something and it does not work,
if you have an idea and
it turns out you are wrong,
you still learned something.
In that way it is a success.
Some people say that
there is not always time
to experiment.
You have crunch time, you have
put out code in a
very small amount of time.
(that happens, but it is
important to try to experiment
when you can).
When you cannot anymore
then you will fall back down
to a different level of abstraction.
(that is a better level of abstraction
than when you started).
(I made a graph.
Laser pointer).
You can see the
beginning at this talk right now.
I am encouraging you to
experiment and try new things.
You are going to write
unit tests along the way.
(You are getting so much better),
You are working at
high level of abstraction
(that is great9.
It is crunch time,
you have got a deadline,
you have to ship to the App Store.
You do not have time
to write unit tests,
you do not have time to
explore, you do not have time
to try new things.
(Oh look!
you are there, higher than where
you were when you started).
You can fall back to a position later.
You do not have to always write units test.
You do not have to always
test, you do not have to
always experiment.
But, when you are used to experimenting
and you are used to testing it gets easier
so that you can do it, you can experiment
and continue to experiment
and test when you do not
have as much time.
When you are done the crunch time
you can go back and do it some more.
There is always
an opportunity to learn.
We should take advantage
of those opportunities.
Let's wrap up.
We have a history, as a
community and as an industry,
iOS community has a history of exploring
new technologies: taking
something that is cool and new
and building amazing things with it.
We have done it with
Objective-C,
with Swift (I think we are
going to continue to do it).
Now is not the time to stop
looking for cool, new solutions.
Learning is not just
for when Xcode is in beta.
(Just because Xcode 7
is out, Swift 2 is stable...)
(laughs)
(finshed, finished).
Just because Swift 2 is
finished, does not mean that you
should no longer look for cool new things
you can do with it.
Ideas are more valuable
than code, but neither one
of them should be thrown
away (throwing away
code is dangerous).
Effective unit tests makes
your code easier to change
incrementally.
Finally, if you can
operate at the highest level
of abstraction you can at any given time
then when you cannot
operate at that high level
you can fall back to
something that is still better
than where you were.
(this has been a
fun talk for me to research
and think.
Thinking back over
my own career and some
of the decisions I made.
I made mistakes,
and things that I would do
differently now in
hindsight, but I do not regret
any of the mistakes that I
made because each one of them
has helped me learn.
As long as I think about
the mistake afterward
and learn from it, then
it is not a negative thing).
Our goal as software
developers should not be
to never make a mistake.
Our goal as software
developers should be to try
and make better mistakes tomorrow.
Thank you very much.
(applause)
- [Voiceover] A couple of
questions from the audience,
start at the bottom I think.
In MVVM, should view
controllers communicate
with view models through
a protocol, or know
the concrete type they are dealing with?
- I love how I have this
reputation as the MVVM guy,
that like I do not mention them at all,
yeah, and it is like, &quot;Oh
a question about MVVMs.&quot;
MVVMs, I recently converted a
large part of our code base,
that is Swift code base
to Model View ViewModel
and I found protocols to be way better,
because it helped me avoid
the partial mock situation.
If the test stub, like the
subclass that you would have,
cannot choose to not
override something because,
 there is nothing to
override then that is better.
You cannot accidentally fall
back to actually performing
a network request in your unit tests.
 protocols definitely, all the way.
- [Voiceover] Right, and if
we cannot pass in objects
how would you pass an object
to the view controller's
viewmodel?
- Right, so this is a
common question of like
who creates the viewmodel?
 is it the view controller?
Is it the view controller
that presented this one?
It is  tricky
and it comes down
to personal preference.
I am still kind of figuring this out, too.
In my opinion, I like
the viewmodel that is created
by the view controller
in a lazy closure block.
And then, if a test is being
run then it can override
that property so that the real
viewmodel is never created,
so that the view controller
only ever uses test
view models in unit tests.
The viewmodel itself
to be created
you can have it created
by a different view model,
or you can have it created
by the view controller
that is presenting this one.
It does not  matter; I
encourage you to experiment
and see what you like best.
- [Voiceover]  if you
would start a new iOS project
tomorrow would you write
it in Swift of Objective-C?
The only reason I can think
of for choosing Objective-C
would be having a team of
developers with no Swift
experience and a tight deadline.
Can you think of other reasons?
- That'd be a big one, ,
I would write it in Swift,
first of all, even if I had
a tight deadline, but I
did that mistake last year
and it did not work out well.
 maybe do not listen to me.
Talk it over with your team, figure out
how familiar they are
with Swift and how excited
they are to learn Swift.
Make a decision together.
I cannot tell you what
to do because I do not know
what is best for your team.
I do not know the different
priorities that you have,
and I do not know the different constraints
that you are working in.
 if you communicate with
each other and figure out
what'll work best for all of you as a team
that is the best solution.
- [Voiceover] what did square brackets
do to offend you so much?
- Square brackets did not
do anything to offend me.
I am pretty sure I know
who asked that question.
(laughs)
Exactly.
I do not hate square brackets.
I do not hate semicolons, I
do not  hate anybody,
or anything.
I try to be easygoing now.
I used to be  angry.
Square brackets
they make certain types of programming,
like functional reactive programming
more verbose than they need to be,
that is what I would say is the
case against square brackets.
- [Voiceover] Right, and
of course these are
anonymous when is Canada
going to land on Mars?
- Land on Mars?
We invented the space arm,
the Canadarm.
That is actually what
it is called, by the way.
It was  popular in
the space shuttle days
and it was this like
multi-articulated arm that could like
rotate and grab like space
telescopes and things
and like do stuff with it.
Thank you for verifying that.
I do not know when
we are landing on Mars,
but I know if we do it it
will be for the benefit
of all humanity, like our
keynote speaker this morning
discussed, and not for just
the benefit of one nation.
(laughs)
- [Voiceover] Other
questions from the audience?
- [Voiceover] I have one
because you talked about
doing a lot experiments,
and some of them, of course,
being bad--
- No bad experiments.
- [Voiceover] end of
production and somebody
has to maintain them for a
very long time afterwards.
If everybody's experimenting all the time
then you will have a fun
time producing code I think.
- that is true.
I guess I should have
stipulated that if an experiment
does not work out the way
you think than you should
throw it away, or at least
not merge it into master.
The ideas is--
- [Voiceover] we are talking
about, I suspect, feature
frames experiments, not
like let's do weird stuff
and see what happens.
- Exactly I am like the
spaghetti against the wall
approach, or anything like that.
Ideally, you would be
working on experiments in
a playground, not in a
production application.
That is where I do it, so.
- [Voiceover] Ash.
- How is it going?
- [Voiceover] Good, how
was your talk for you?
- Little tired.
(laughs)
- [Voiceover]  just an easy one then.
 there was a
exciting slide where you said,
&quot; because of dependency injection
&quot;I am able to write tests for
my code, I also write my code
in a better way.&quot;
I am not  sure that is
saying it word for word,
but the--
- that is the general gist.
- [Voiceover] And then, like
you cheated and just actually
did not change your actual code at all.
 I was  bit let
down, so can you comment?
- Sure, yeah so I did not
change the code at all
because the whole class was
like eight lines and there is
not a lot to change.
I was trying to
show how simple it was
to do a dependency injection
and this is kind of
a cheat, but I was
focusing on the pedagogical
example of teaching you how
to do dependency injection
and not at the time how
to write better code
with unit tests.
In that specific instance
it would not  be the
view controller necessarily
that would have been changed.
it is the network controller,
the thing that does
the networking request.
If the view controller
can only access it through
the clearly definied protocol,
then it is less likely
to call the internal functions
that it  should not
be aware of, and that way
you have very loose coupling.
The view controller and
the network controller
do not know about each other,
except through explicitly
defined and limited ways.
They do not do things
like the network controller
is not able to like add a subview.
The view controller
is not able to parse JSON.
Those are two
different separate concerns
and they should be in separate classes
and their communication
to each other should be
very constricted.
I think maybe in a
future version of this talk
maybe one that is instead
of calling it like,
&quot;Merging Best Practices,&quot;
what if I actually have a talk
on unit testing, maybe I would go
into more detail about that.
Thank you.
I am supposed to remind
you to rate this session.
Thanks again everyone,
you have been a great audience.
(applause)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>