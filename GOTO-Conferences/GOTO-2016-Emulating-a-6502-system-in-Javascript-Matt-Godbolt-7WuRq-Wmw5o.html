<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Emulating a 6502 system in Javascript • Matt Godbolt | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Emulating a 6502 system in Javascript • Matt Godbolt - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Emulating a 6502 system in Javascript • Matt Godbolt</b></h2><h5 class="post__date">2016-08-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7WuRq-Wmw5o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Wow I haven't even done anything yet I'm
getting applause this is awesome
so yes as we've just said I'm gonna be
talking today about emulating a 6502
system in JavaScript so first of all a
little bit about myself my name's matt
god bolt I work for a fabulous trading
company here in Chicago called dlw
I'm contractually obliged to say we're
hiring come speak to us so if this talk
is interesting to you I can't promise
that we use 6502 s
anywhere in our trading stack but we do
have similarly interesting things to do
so come talk to me afterwards or there's
Katie who's waving at the back there is
can tell you a lot more about what we do
anyway so emulating a 6502 system let's
just go fullscreen there we are
well first of all this slide is far far
too high-tech let's let's go back you
remember this kind of stuff all right so
first of all who has ever used a 6502
based computer yeah a fair number of you
I guess probably you wouldn't be here if
you would if you hadn't so what is the
6502 it is this
it's an 8-bit computer first made in
1975 so it's just a little bit older
than me three thousand five hundred and
ten transistors drawn out and laid out
by hand by just a small team of people
crawling over a large piece of acetate
like you would like for an HP and
drawing in marker pen to where all the
tracks would go and then listen little
graphically sure a shrunk down to sort
of this size which is I just think I'm
unbelievable I mean in my day job at the
moment we do a little bit of like fpga
development type stuff and the tooling
behind that is amazing but just the
thing that human beings were doing this
is just incredible if it's not when it's
not naked oh hang on a second I have
just had an abundant on my screen know
it when it's not didn't you did of it's
a plastic case it looks like this it's
got thousands of pins on the outside but
it
actually just a tiny tiny little thing
in the inside of there so these these
sir chips are important because in the
1980s they're the s65 or two along with
the z80 was responsible really for the
1980s boom in home computing it was an
affordable chip it was powerful and
certainly for me it was it came at the
time when computers were sort of picking
up and I supposed to rectly led to me
being here in front of you you know
becoming a pewter computer programmer
and I'll talk a little bit more about
that in a second so I actually contacted
over Twitter the people who still have
the patents and the rights for the 6502
and I said if you've got any idea how
many of these are in existence thinking
it would be a few hundred thousand I was
thinking and how many how many computers
with them there have been made you know
maybe a hundred thousand maybe a half a
half a million or something but
apparently more than ten billion of
these things have been produced by just
one company so there's probably much
more than that out there it's pretty
incredible so what kind of computers was
the 6502 in well here you can see we've
got the Apple two we've got the Atari
800 and the Atari 2600 the BBC micro and
there also is the commodore pet the
commodore 64 the vic-20 it was also in
the original Nintendo Entertainment
System the nares it was in the tamagochi
virtual pet if you ever have one of
those really really irritating things
it was also powering the Terminator in
the Terminator films according to if you
freeze-frame likes the fin within the
first five minutes if you remember like
the DIA the the sort of text from
scrolling down the screen and just one
select random computer gibberish if you
freeze frame that it's actually part of
the Apple 2 booklet boot loader that's
been disassembled so it's 6502 and
apparently it's also what powers bender
from Futurama but the computer that I'm
interested in talking to you about which
is sort of ironic because here I am in
Chicago talking to a largely American
audience is a sort of strange British
computer called the BBC micro it the BBC
micro was made by a company called acorn
in 1981 and it was part of the BBC's
computer literacy program so that's the
BBC like the
Broadcasting Corporation British
Broadcasting Corporation they decided
that they wanted to run a whole series
of educational programs explaining what
this newfangled computing thing was why
it was important and in order to do that
they thought that they should have like
a sponsored computer system to go
alongside the TV shows so they put out
to tender this idea of like an
affordable sort of hackable I guess we'd
say nowadays a computer system and a
company called acorn came up with the
winning design and they they produced
this computer and as a result of that TV
series it became one of the more popular
systems in the UK and if you go on
YouTube we can actually go and see the
the computer program with the British PR
ogr amme spelling and they are
universally dreadful programs now but
you know they were there at the
beginning and it was certainly got a lot
of people interested in it it also meant
there were tons of these around in like
schools so a lot of people in the UK for
this is their first idea about what a
computer is this sort of screamish box
with the bright red keys on the top as a
sort of size story just quickly the
company acorn went on to make other
computers after this and it's a
testament to how hackable the BBC micro
was you know here we are in 1981 and as
part of the design there was a sort of
second processor bus that you could
connect other processors on to so they
had like another 6502 as a sort of
daughter card or you could get even an
80 88 or some of the other 16-bit
computer chips that were around but
acorn themselves decided that they were
going to make their own processor for
their next generation of computers they
thought that actually they could do a
good job and sort of inspired by the
6502 simplicity and its design they came
up with a 32-bit processor that was
originally spiked out and was a second
processor to the BBC micro they called
this the acorn RISC machine and many
many years later when the Acorn company
itself folded that company that they
spun off to look after the IP for that
chip there was renamed to advanced RISC
machines and I'm guaranteeing that
there's probably a couple of hundred of
those things in this room right now
powering all of our iPhones and our
Android so in many ways this computer is
the logical ancestor of the cheapness
inside your
you're off your phone so the beep had
32k of RAM the 32k of ROM it ran at two
megahertz a whole two megahertz and the
hardware attached to it the the way the
6502 works it didn't have instructions
that were uniquely able to talk to
hardware you just simply wrote to sort
of magic memory addresses and those
member magic memory addresses on the bus
would sort of map out to actual physical
Hardware so to like read a right to the
keyboard you would just write to read a
right from particular addresses why is
it so important to me well I guess in
many ways I've already explained that
and sort of following on from the talk
we had earlier here about how getting
kids into programming when I was growing
up the way that you got into programming
is that you had your computer you saved
up your pocket money maybe you bought a
game every now and then maybe you did
some illicit trading of copied games in
the playground Shh but more importantly
every every month you would go and buy
one of the magazines that you could get
from the newsagent
and you would read all about the latest
games and you would read all about the
latest sort of things that your were
coming out for your computer and at the
back would be the toilet of half of the
magazine would be printouts that you
would just type in and so there would be
games there would be examples of like
this one here's a Fraxel like rendering
thing and you would learn how to program
sort of by osmosis you type in these
things or you get your mum to read it
out to you you tap it away you would
type run it would inevitably not work
you just sort of see the syntax error
and you go and you look at the listing
and you discover that it was a colon or
not a semicolon and all these kinds of
things but but sort of then you learn
how to primitively how to debug so I got
pretty good at typing these things and I
learned a lot about this and this
particular Oh sugar I've just pressed
too many times nobody I know it is this
particular magazine article this one I
wrote myself with my good friend from
school used to get fifty quid for fifty
pounds which is what like eighty dollars
for submitting a program that got
published in the magazine so that kept
us in in sweets and candy for quite a
lot of time when we were there so I was
about 15 when this came out and of
course the other reason that these kind
of
computer systems are interesting is
because of the games right that's really
what computers are for as we all know
and so the BBC micro is particularly
legendary for this this game which I
don't know if anyone in this room other
than the people I know who know it did
yeah there's some people who have
recognized its games called elite and
it's a 3d space trading game or action
game it's it's one of those it was one
of the first games I mean 1984 I think
and it's just an awesome game and to get
it squished into 32 K of RAM where most
of the memory is taken up with the
actual just picture you're looking out
there is just incredible and I've been
lucky enough to get in contact with one
of the people who wrote the game and
we've been discussing it all and it's
just amazing to think that the reason
pretty much that they they wrote this
game is that no one told them that you
couldn't possibly do 3d rendering on a
two megahertz processor so they just
tried it and turned out you can and my
personal favorite is this one here which
is a game called exile it's a 2d physics
based puzzle game it's just amazing what
you could do in such a restricted amount
of RAM such a restricted amount of
computing power okay so that's why I
love the Beeb that's why I love the 6502
the powers it why on earth I can see
Sue's taking a picture of this right now
why JavaScript well cuz it's fun it
really amuses me
to take something which is as low level
as the assembly code over of a computer
and emulator impossibly the system the
highest farthest removed from it but no
there's a real reason to anyone who's
ever played with emulators knows that
it's a sort of a long painstaking
process usually to get a one working on
your system you have to find the roms
you have to find the code you have to
find the funny versions of Lib GDK that
it needs you have to run configure you
have to find the right compiler you run
make you run it and then you get a
segfault and then you're like oh what
happened here and you know all that
kinda stuff they're not very it's not a
great user experience but everyone
understands going to a webpage and
seeing something so that's why
javascript okay so I'm gonna explain to
you how I wrote an emulator but before
we do that I'm gonna have to give you a
little bit of a background about what it
is inside I've lost my
my clicker I've just realize I'm
pressing the keys on the keyboard here
and I've got a clicker somewhere oh well
I'll just have to keep doing that
um so 6502 it's an 8-bit aha
thank you so it's an 8-bit processor
which means that all of the internals of
it are eight bits wide it has three hole
registers the first register then the
most important is the accumulator that
was an 8-bit register again that has
only be used for like simple swipe was
the only register you could use for
arithmetic so any kind of adding
subtracting comparing had to happen with
the accumulator there were two other
registers called X&amp;amp;Y which have pretty
much only used for indexing so you could
use them as loot counters maybe and you
could use them to like index into an
array but other than that you couldn't
do any comparison or arithmetic on them
you had a whole 256 bytes of stack
although if you were anywhere near using
more than about 100 of them you are
probably in trouble the the 6502 has an
interesting design so it's very
restricted in terms of only having these
three registers it treated the bottom
256 bytes of RAM slightly differently
from the rest of the memory and as much
as there were special op codes that only
allowed you to access those addresses
which was smaller and shorter obviously
every byte you save in terms of memory
is one byte more in your your game or
your Europe or your operating system
whatever to use but also it could treat
pairs of values in the zero page and
this first 256 bytes of memory has
almost like 16-bit pointers so that was
the way that you kind of got around the
fact that the rest of the system was
only 8-bit you could use two values in
the zero page as your 16-bit pointer
I'll hopefully become a little bit more
clear in a second so this is what the
instructions look like you've got like
load and store two registers transfer
between registers push pop compare add
and subtract all that kind of stuff and
comparisons and branches conditional
branches so that's pretty much what most
assembly ends up looking like let's just
take one of those instructions the load
a so this is something which just brings
a value into the accumulator there are a
bunch of ways you can bring values into
the accumulator the first and most
obvious way is to bring in an actual
number I just want the number 32 into
the array
and that's what this first disruption is
this hash I'm gonna call it hash a lot
of you will still sink pound I think the
proper name for that thing is octothorpe
which is only through arguments with
Americans about it not being a pound
that is that is sort of like you over
here we can see these are the opcodes
there are actually being sore I can
point over here as well
these are the opcodes that are actually
being interpreted by the processor to
tell it what to do so you can see that
the opcode for load immediate is a 9 so
a 9 to 0 means load to 0 which is 32
into the a register and then the the
next two things are reading from memory
so now a 5 means load from the memory
address 70 so that will read something
from byte 17 to 0 page and then load a 1
2 3 4 will load from the address 1 2 3 4
and you can see that there this guy here
is a 5 and he only needs one extra byte
this guy's a D and he needs 2 extra
bytes so if you're using a 0 Paige is
slightly more efficient then we get into
more advanced things where we start
seeing those X&amp;amp;Y registers and so the
top two here are reading from an offset
from address 1 2 3 4 so you can think of
this as really reading the X or the wife
element in an array stored at address 1
2 3 4 and then the real killer 1 is this
in directing with all the brackets over
here parentheses what that instruction
means is read the value at address 70
then I read the address the value at
address 71 treat that as being a 16-bit
pointer then add Y to it and read the
byte from that address so there's a sort
of indirect mode where you can use a
pointer at 70 and 71 to point to a
particular piece of data so like your
sprite routines that would be written so
that you would use you know 70 and 71 is
the source of the sprite and 72 and 73
is being about the destination and you
would use these things indirectly
through those so that's a pretty cool
concept to give you sort of some context
the z80 had I think eight registers that
you could pair up so you have an A or B
a C in a D and you could use B and C to
mean a 16-bit register but the z80 was
much much slower in terms of it to many
many more cycles to do any
thing even if it was running slightly
faster so they sort of netted out and
this is slightly more risky slightly
more risky sorry that's risky with a
small C not risky isn't scary or
whatever okay so you got a little bit of
a sort of groundwork about what what it
looks like to emulate a 6502
how do we start well pretty simple
really
just like the processor you fix the net
fetching the next instruction you decode
it and you execute it what does that
look like well that pretty much is an
emulator give or take a few hundred
instructions that I haven't put on the
slides here so we've got an A and x and
a y which are going to mirror the
register contents of those three
registers I was talking about we've got
a program counter which just happens to
start at a particular address doesn't
really matter for this and then we have
a loop forever read the next byte we're
assuming there's a function called read
mem that's going to go away and read
read memory whatever that means we'll
talk about that in the minute read the
next by incrementing the program counter
and then switch it what does it mean and
as we saw earlier a nine is the load a
with an immediate value so the code for
that is going to be a equals read mem PC
plus plus let's just read the next byte
and then put that into the a register
there's a whole bunch of other things
I'm sort of missing out for this but you
get the idea
similarly like the the a three here is
two load of an address and so the code
is a little bit more complicated but so
you you do this you get your manual open
in your lab you go one by one through
all the like 160 documented codes for
the 6502 and you're done well you're
done if you like just changing random
values inside an array in memory without
actually seeing what the heck that looks
like so you actually do have to do a bit
more work before it gets more exciting
than that so we need to talk to the
outside world and of course the most
interesting thing to talk about is the
video path so a BBC micro was usually
plugged into a TV over if you were very
fancy you did have a monitor but
ultimately amounted to the same thing
there was something which was has an
electron beam scanning 50 times a second
and outputting colours to the screen
there was a dedicated chip inside the
computer which was responsible for
driving that CRT beam and the
you talk to that like any other device
was through memory-mapped i/o so some of
the places you could store to some of
those reads and writes the memory would
actually instead of going to ROM or Ram
they would go to circuits or they would
go to registers on Hardware that was
inside the machine so one of those again
as I say would be the video chip and the
video chip has a few registers itself
and is a relatively complicated chip in
its own right one of those registers
would be but what address is the screen
stored and you say you would tell it
where the screen was stored and then
every single clock tick of the clock or
clock of the tick as I keep saying the
video chip would also fetch a byte from
memory and it would interpret it to
being what what colors am I going to
display here and there were a variety of
ways of interpreting the byte that it'll
read but what that means is that every
single tick of the clock the CPU needs
to read something from memory and the
video chip needs to read something from
memory now if any of you has ever looked
at like how modern graphics cards work
you hear about like dual ported or quad
ported Ram where you can read and write
all the same time and you think well
surely this must mean you had very
expensive and complicated Ram inside a
6502 based system and the answer is no
no this was in the golden time in
computing the one there only time in
computing when Ram was faster than the
processor so as it happened the ram ran
at twice the speed of the processor and
so it was able to be shared
cooperatively with the video circuit one
cycle was given to this the cpu and then
the next cycle was given to the Ram chip
so as I say some registers allowed you
to configure how the video processor
worked and it could do something as
simple as read the bike from memory and
generate eight pixels either from and
like a little table the video chip had
its own ROM and had its own set of
characters so you could have a character
map to display where it would literally
interpret the biters and ask you buy it
and write it to the screen as that
picture or you could put it into a
bitmap mode where you either had a high
or low resolution 2 4 or 16 color mode
and there are other parts of this that
you need in order to actually get the
system up and booting as you might
understand like most most sort of
operating systems need some way of doing
some periodic work and so there are
timers on the there's a chip that's
differ
- generating timing signals so you would
basically load a value into it again by
writing to one of these magic memory
addresses and then the timer would start
ticking and counting down and when it
hit zero would generate an interrupt and
then the CPU so if the CPU would be
interrupted the operating system would
go and check whatever it needed to check
so that's quite a sensitive issue so we
needed to get the timer's working as
well before we got anything appearing on
the screen and you know you want to
emulate the sound and stuff and again
it's just a question of opening the
hardware manuals and sort of going
through them all so let's see what that
looks like if I can I've just realized a
small problem here is that you'll be
able to see this but won't array so this
is so so familiar to anyone who's been
in Britain there's at least one guy
who's have seen this before that noise
of the system booting back up is
extremely sort of reminiscent but given
that this is a go-to conference I'm
going to do what everyone did back in
1985 whoo so many department stores that
had computers that were left on unknown
they would wind up with things like this
for running on them so that's pretty
cool and so you know Here I am you're in
the mode where it's emulating oh of
course
there it is so many I'm sorry we're in
the character map mode here this is
called mode 7 and so at the moment what
I can do if I just reset it
I happen to know where the memory for
the screen is stored so just to sort of
prove a point if I've typed this in
right
7c 0 0 this is a poke this is just like
raw writing to memory I mean it's
amazing what you could do and like
nowadays kids will never like get the
opportunity to just write to random
parts of their computer's memory but by
putting like 65 the ASCII for a there I
can put an A at the top of the screen
and so on and you know if I change to a
different mode I can start showing you
that oh god I can't see what I'm doing
where are we to put this one let's just
do four thousand equals to five five we
can put a big flashing blob in the
middle of this we know so this is a
bitmaps mode it's very low resolution as
you can see the suddenly that characters
have got all giant so that's cool so
another thing that you'll obviously want
to emulate
pretty much straight on is it is the
disk system that was attached to it you
know there sometimes you had to load
stuff of cassette tape if you weren't as
fortunate enough to have the disk drive
I won't subject you to the screeching
horrible five-minute process of loading
something off of tape and so here's this
disk system I can just quickly show did
I get that yeah hey yellow lie at the
bottom it's the disk like there so this
is like one of the games that came if
you if you splashed out on the disk
system so you know this doesn't look
particularly inspiring so far and it's
all in that horrible graphics mode but
you know hey my system is working it's
pretty cool so obviously what you next
do is you go on to like an online site
that has a whole archive of disk images
and you're like alright I'm gonna play
that game that I love so much and if I
can find the mouse pointer there it is
we're going to load now I would just
like to say I have permission to use
this image which is white actually even
it checks into github we're gonna load
up that space trading game and so we
have elite and we go awesome except we
don't go awesome because we're like ah
well that doesn't look quite how I
remember it you can say the photograph
who gets better I'll do another version
this in a minute when you can see it
with less corruption so you can probably
see that just under where it says load
new commander this it's getting a bit
sort of murky and now it's sort of
something sort of scrolling over it now
and horrible things are happening so
something isn't quite right with our
emulation so what what on earth is going
on there let's try and find a way back
here we are so what happened there
well as I alluded to earlier the video
chip is a pretty simple device and you
could change the way that it interprets
those bytes I also sort of mentioned
that there are different modes that it
had you had high resolution low
resolution high color low color all of
those come with attendant trade-offs in
terms of the amount of memory that it
used and when you've only got 32 K of
RAM and most of that's given over to the
operating system every single byte
counts also if you're writing a 3d
renderer you really want to be right
touching as little memory as possible so
if you're using a high color high
resolution mode you're having to write
more bytes to draw the same amount of
data so the people who wrote elite were
smart they were like well
what we'd like to do is have the top
two-thirds or three-quarters whatever
that is in high resolution but low
colormode so that I get pretty much a
good memory efficiency but then when
I've got my little little chart at the
bottom here which shows your mic sort of
like status and where I am on the map
and everything let's do some few more
colors that splash out what the hell so
how did he achieve this it's not
something the video chip can do but it
is what they would do is every time the
video chip reach the top I knew that the
electron beam had just reached the top
of the screen it would generate an
interrupt and say hey I'm at the top
again what elite would do would set up
one of those timers to say hey count
down and I know exactly how long it
takes for the electron beam to scan all
the way down to here to about all here
and then I'm gonna reprogram the video
hardware to say okay we're now in
multicolor mode and low resolution and
as long as I can do it quickly enough
I've got all the time it takes the
electron beam to go off the side here
zoom back and start up here before
anyone even notices dived then it's kind
of a magician's trick and sort of like
pull the tablecloth underneath which is
cool right so why does my emulator not
work well I've glossed over a whole
bunch of details about how high that
loop was done so effectively I have to
decide when to draw the picture right I
was in my sort of example code of like
the while loop it was just a while
forever well at some point I have to
stop and like draw the screen and so
what I was doing in that previous
example was just running for like I know
8,000 opcodes and then I say okay now
let's draw the screen and I went back
and drew 8,000 opcodes and drew the
screen which meant of course there was
no chance for me to ever observe the
video in the right place so how do we
fix it well I have to go back to my
giant table of op codes that I've got
all my case statements and instead of
assuming that they all take the same
amount of time I have to say okay well
loading a immediate takes to CPU cycles
so I have to kind of run the video and
the timers for two cycles every time I
see a load AAA media so I've kind of got
this Co routine between the CPU and the
rest of the hardware I mean obviously in
reality they're all running together at
the same time in a real system but we do
that and now we get an uncorrupted
uncorrupt is that a word tis the
Oh beep JIT problems at the beginning so
now we as you can see we we've got a
much cleaner display but even then this
wasn't perfect and I've checked out on a
real BBC this this also happens on a
real beep see the little dot here that's
flashing a little bit and sometimes you
see a little dot down here it's not
quite right there are some other things
that are going on the timing wasn't
perfect so I mean how we do it for time
you'll forgive me if I have a quick play
as it's been so long but like seriously
this is the two megahertz machine isn't
that amazing it's awesome this like I
know it gets faster when there's nothing
on the screen so this is the space
station I've just come out of that's
what I took the screens to come out and
chase me come on we can see some other
ships as well had AI and everything and
it's got like you know where are we
that's me this is the prices of all the
goods in this particular place there's a
dictatorship apparently all this was
done through like a seeded random number
generator that they've like generated a
whole bunch of stuff and then apparently
they had to go through and check there
were no naughty words that come out as a
result of their random algorithm for all
the things I did but it's great anyway
so that's great
big attack right that's enough of that
right so that's cool and the best thing
about writing an emulator is that once
you've done the hard work and you've got
all those things worked out you suddenly
have this huge suite of games that were
are available to you and you can boil
away many many long evenings loading up
old games and enjoying and the fruit of
your labor and so one of my other
favorites was this which is a blatant
ripoff of the arcade game Galaga which
yeah so isn't this
so you spend me your evenings doing this
and your oh oh well that's unfortunate
and so what you really discovered is
that what you spend your time doing is
debugging other people's software or
rather your own software's problems
except you don't have the source code
you have no idea what it was doing in
the first place so if you write an
emulator my advice to you is spend as
much time as you possibly can writing a
decent debugger so I in here I have an
instruction level debugger I can set
breakpoints I can set watch points I can
put arbitrary bits of JavaScript to run
on certain conditions it's a godsend
now I'm cheating here because I actually
remember this game from my childhood and
I know exactly what this crash is but oh
if I can remember the number I will just
go I didn't think you can read this
anyway so you might as take my word for
this but that gray blob there is a
question mark question mark question
mark so basically there's a point at
which we're stuck on here is an
instruction for which I don't know right
it's an undefined instruction now of
course on a modern PC what would happen
if you hit an undefined instruction you
get like a seg fault it disagreeing of
death or whatever depending on which
mode you're in but the basic the
processor knows that you've tried to do
something you shouldn't do on as on a
C's 502 what happens well it just plays
on you think so in fact my default case
in my like being switch statement is
just P C++ continue alright that's
clearly not right because why would they
have done this if we take a look if we
can get the mouse pointer back on my
screen over here helps there we go if we
take a look at what the op codes are
around that funny instruction so that
instruction is hex 87 which was not in
my table we look at the ones nearby
we've got 84 apparently a store why 85
is store a 86 is store X 87 is undefined
hmm well there's a sort of pattern going
on here it looks like for this sort of
sequence of bits the CPU is interpreting
it as a store something and then
depending on the bottom two bits 0 0 0 1
1 0 is the Y register the a register or
the X register ok so maybe we can get a
clue as to what this other instruction
is doing because this must be doing
something
well thankfully people much smarter than
me have taken the time to do something
absolutely incredible so a big thanks to
the visual 6502 people for letting me do
this
this is a circuit diagram of the 6502 so
the reason i know there are three
thousand five hundred and ten
transistors is because these guys have
decap to 6502 they have taken loads and
loads and loads of high-resolution
photographs of the dye they've then
shaved off the top layer and done it
again
and they've shaved off the next layer
and done it again they've written
programs to stitch those together then
they've written image recognition
software which can find where all the
gates are and they have
reverse-engineered the entire transistor
netlist of the 6502 so that's an amazing
achievement in itself and that's where I
got on the picture at the beginning of
the Naked 6502 but more so than that
they've been able to write emulators and
simulators for that netlist and so I can
run a virtual 6502 and look at every
single bit going on additionally they've
taken the time to reverse engineer
further and they've worked out where the
accumulator is stored where there a
register is where the X register is
where there are all these type of things
and so in this picture here this is like
a top level shot you can't quite see who
this guy says instruction decode this
sort of regular looking array turns out
to be a I'm going to look at my notes
130 by 21 ROM now it's addressed in a
very strange way so I'm not going to go
into it but effectively the instruction
that was read is taken it's some bits
are flipped from fill in it from the
instruction and some extra timing
information is added to give you like a
21 bit like lookup that's presented to
the ROM and the 130 bit output from that
ROM is energizing various parts of the
circuit trees and there's no micro
coding or anything like that it's just
like well if it matches this bit bit
pattern then you need to do this on this
sub cycle of this instruction and if you
take the time to reverse-engineer the
entire table as other much smarter
people than me have done you discover
that in that 87 case what's happening is
both the a register and the X register
are enabled at the same time so as the
store is going to write to memory the a
and the X are together present
to the bus now it turns out that the
zeros win out so what really happens is
a and X is written and in fact this was
well known people did experimented with
6502 s before they'd even decap didn't
everything people knew about this which
is exactly why twas in that game this is
the somewhat confusing store ax
instruction which actually stores a and
X so you find a big list of all of these
funny undefined op codes and you fill in
the rest of your table and so you now
instead of having just one hundred and
sixty odd entries in your your case they
when you have all 256 they all do
something useful and now you can run a
load of games then of course I this this
is a I guess this is an admission I may
have alluded earlier to the playground
transfer of illicit MIT games that I may
may have partaken in in my youth but so
this game here alienate it came on
cassette and I could never get it to run
on my computer because I actually had a
slightly different version of the the
BBC either BBC master the upgrade
diversion where they happen to use a
different version to the 6502 days a 65
C 1 2 which unfortunate all the
undefined opcodes did different
undefined things so he liked a whole
bunch of games didn't work so I spent a
lot of my youth hacking games just to
get them to work on my computer which is
exactly why I knew where's Alec I was
going wrong I knew that that didn't work
um the computer that I had but this game
alienate and a bunch of other games
related all written by the same author I
could never get to work and the reason
for that is they had protection systems
on them which most games did but these
protection systems I was unable to break
as a fifteen year old in my bedroom so
let's just talk briefly about what a
protection system is I mean this is DRM
the birth of DRM you could say so the
general gist of it is that you would
take the game code at the author's would
take the game code they would encrypt it
in some way and then they would place
the decrypt routine just before they
immediately ran into the game itself and
they would have by this point they'd
have disabled all of the interrupts or
set them up in their own way they'd have
made sure the operating system is no
longer involved and they would have set
a bit in the RAM which meant that even
if you hit the likes restart button it
would provide blank all of the RAM out
so basically as soon as you were that
you were locked in
then the next thing that happen would be
the game would play and so you had no
opportunity to stop it and say can I
save this off please and take a copy so
if it's encrypted or or decrypt above
why can't I decrypt it I mean I can load
up the code right and I can see what
it's doing and I can decrypt it just
like it is well it was more complicated
now obviously so the decryption keys
would include things like magic values
that were loaded from tape so if you
were able to talk to the tape controller
directly you could actually listen for
something which wasn't like a normal
tape signal at the end of your loading
and kind of go crackle crackle crackle
yep that's exactly what I was expecting
and now I've got the son of a magic part
of my key that can decode the game and
of course the assumption there is that
when you're using your tape to tape tape
- deck you would stop it after the
noises have stopped and you wouldn't
actually pick up that bit or it wouldn't
translate as well
similarly for disc games games that had
this protection would use like direct
talking to the disk controller to like
read apparently bad sectors that weren't
in fact bad that copying programs
wouldn't see so that that would prevent
you from copying the game rather than
preventing you from disassembling it and
changing it this is kind of fun the
decryption code would often use itself
as part of the key why would you do that
you say well if it didn't include itself
what would be stopping me from replacing
the very last instruction of the
decryption code with a return statement
like a little return instruction they
would run through happily decode the
game and instead of running off into the
game it would stop and I could save it
well if the get if the encryption
decryption code uses itself are the
opcodes of itself as part of the key if
I modify it in any way then of course
it's going to corrupt the game and not
decode so that's pretty cool but there
are ways around that you can hack around
that um it gets really funky at this
point now the really good game could
protection systems would use Hardware
timers and hardware registers so while
they were running they would read from
those memory map counters that were
forever counting down them in that if
you disturbed the amount of time it took
to do the decryption in any way
whatsoever the timers wouldn't stop they
keep on going on you would start getting
bogus values the key would be corrupted
in the game would not decode so you
couldn't even like single step in a deep
even if you had a debugger but you
couldn't single step through it because
you would disturb it and in the
registers are another thing I used to be
in my own game protections
systems I would use like the position of
the hardware cursor because of course if
you're single stepping through the code
you've probably got some overlay on the
screen and you're moving the cursor and
I was expect you to read the position of
the cursor and ER and then the really
really cool games would use the
interrupt information they would set up
their own interrupt handlers to happen
at a particular time and then they would
mutate the key maybe it would just like
add one to the key randomly every time
the interrupts pan for fired which which
was you know pretty perplexing so my
friend Richard and I the guy who I wrote
the the magazine article was we sat down
and we thought how are we gonna crack
this game alienate uses all of these
things and more and so we thought let's
write a 6502 emulator and then we can
decode the game by running our emulator
and stopping it when it gets to the end
and we spent many many evenings and
afternoons after school trying to get
this to work but you need such deep
intimate knowledge of what's going on in
there be able to do it you know it's so
sensitive to timing I mean one example
is like there's an instruction inside
the the alien 8 protection where it says
rotate this memory address which means
read it shift it all up by one move the
carry into the bottom and write it back
out again it takes seven cycles there's
no no indication which cycle it does the
read in and which cycle it does the
write in and those things are very
important because every single cycle the
counter is ticking down and so you're
getting different values so and we're
starting to run out of time here but I'm
just going to very quickly show you
visual 6502 which is not mine this is
the guys hoody cap the the 6502 this is
their JavaScript emulator of like a
transistor level and you can sort of
single step through and see which parts
of the chip are lit up at what cycle and
even more importantly if I can get over
to here you've got a list of all the
things that are going on inside the chip
and each cycle so armed with this
information I could single step through
and I could find out which which cycles
it was reading and which cycles it was
writing so I could actually put in the
emulation that I finally needed to do
here it is in because he couldn't really
see it in that last slide so did I say
seven cycles it's six cycles do a rotate
so you can see the first three cycles
it's reading the opcode and the low and
the high byte of the address that it's
going
to rotate then he actually reads that
memory then it does the rotate which
takes a cycle and in a final one it
stores it back but one of the more
interesting things in this is that it
actually writes back in the fourth cycle
as well
there was no pin on that sixty five
eighteen 6502 so none of the pins on
this chip which said whether it wanted
to talk to the memory or not it just
happened every SEC lock cycle so
whatever was left on the bus on both the
address side and the data side was being
just broadcast out now so on that fourth
cycle it's writing back the unmodified
value which again is no harm no foul
right okay if you write to memory twice
what difference does it make except that
Fe for eight here is one of those
Hardware timers writing to it actually
has a side effect it does something to
it it actually cancels an interrupt
that's going and can cause all sorts of
things happen so you have to model that
too so very quickly how do we fix it
well you suddenly your code is looking a
lot more complicated there's no more
like run Hardware for two cycles at the
end I have to account for every single
cycle as it's going through within an
instruction this is very complicated
looking but it's actually code generated
from from a table so I actually have a
big table of all of the op codes the
same thing I used to generate the
disassembler I actually now use and I
have a sort of rule engine that
understands the rules of what things do
get written read from by the 6502 and it
can emit all of this code so I didn't
actually have to write all this stuff so
it's not as painful as it seems we don't
really have too much time to go over
this but there's another layer of
complexity on this bush which is that
the hardware itself ran at half the
speed of the CPU so we've got the brown
running at twice the speed and the
hardware running at half the speed and
in order for the CPU to access the
hardware it kind of had to be slowed
down and so there's this thing called
cycle stretching where the clock coming
in is kind of tied up high it's like
whoa they're on the reins and of course
depending on whether you're on the even
or odd cycle compared to the hardware is
whether it takes three cycles to kind of
get in step or five cycles so there's a
lot of subtlety in terms of the timing
so armed with all of this and a friend
of mine who's back in the UK still has
one of these computers running tons of
experiments for me I was able to get the
whole thing decoding and I'm glad to say
finally thirty years probably too late
or 25 years later I've been able to have
alienate all right I'm gonna turbo go
through this I just wanted to make a few
things about the performance stuff so
JavaScript is not well known for being a
fast language although the JIT guys are
amazing um I just like to say some
things I discovered along the way first
of all switch statements it's amazing if
you have a big big switch statement most
jits
inside like Chrome and Firefox give up
they like well this is a 256 the entry
case statement I'm giving up with it so
we just interprets it so don't do that I
actually have a binary search to find
the opcode for for Chrome and I think I
use a set of jump tables for for Firefox
don't do dynamic dispatch it's a really
cool thing to do you can have like a
single thing which it points at which
routine is gonna be called on which
cycle and you keep writing over it and
stuff again the the the jits go woah
every time I call this function it does
something different I can't inline
anything and it gives up and it goes
back to interpreting amazingly loop
unrolling is alive and well so you
remember the old technique of like
taking a snippet of code and instead of
putting it in a loop you actually just
copied the code eight times or whatever
that actually made a big difference in
terms of the loop code at the video code
where I'm gonna do eight pixels at a
time which it's sort of slightly sad use
typed arrays for the screen that's kind
of a no-brainer WebGL was a massive win
for me I mean it's hardly doing anything
but by doing the presentation part using
WebGL it meant that I actually get some
like multi primitive multi-threading
where the GPU is doing the screen blip
while I'm carrying on with the next
frame and I did some complicated stuff
to defer the sound so the sound is done
in a come and talk to me afterwards but
you know again people were we're doing
some cool things with sound like they
were sampled speech was was was a thing
by like sitting in a very very tight
loop changing the volume of the sound
very very very quickly cool so in
conclusion you can get an awful lot of
fun out of doing this kind of stuff this
is not my first emulator in fact my my
first emulator was a Sega Master System
emulator which I read not with a friend
in arm assembly way back when and then I
ported to JavaScript so I've had a bit
of a history of doing this kind of stuff
but it's so rewarding especially when
once you start posting this stuff out
there people whose games these are will
get back in contact with you or will at
least answer your emails and I was very
lucky that the guy who wrote in
got back to me after I wrote a blog post
about how I'd crack there like
compressed text formats that I was
trying to like a friend of mine on a
mailing lists wanted to have like a
hacked name inside elite and he'd done
it in Photoshop and I'm like I can do
one better than a photoshopped version
of this I can give you a version of the
game that has that hack in it but it
turns out I couldn't find it I was just
you know I grips through this thing
looking for the ASCII that I was
expecting to change and it wasn't there
so on a huge odyssey of like how does
this actually work and I emailed him
afterwards I said hey I think I reverse
inter did your your string.format he
says yep that's pretty much it and he
sent me back this which is an original
scan of the sort of like fan feed
computer printout that he and the other
author had written like the original
list of like tokenized strings which you
can barely see I'm so sorry but that was
so rewarding anyway
I'm well over time so I've got a list of
resources there you can go and play it
on the web it's on the source is all on
github visual 6502 is amazing they're
also doing other chips so do look at
their website big thanks to the people
listed there and like the man said
please remember to rate this sis thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>