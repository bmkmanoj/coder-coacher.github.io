<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Treat Your Code as a Crime Scene • Adam Tornhill | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Treat Your Code as a Crime Scene • Adam Tornhill - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Treat Your Code as a Crime Scene • Adam Tornhill</b></h2><h5 class="post__date">2015-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TfZmuS01CNs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so good morning everyone and welcome
welcome to code as a crime scene today I
want to give you a different perspective
on your code base I'm here to
investigate the traces we all leave
behind as we create our systems and you
will see that there's a lot of valuable
information in those traces and it's
information that's going to help us
identify the code that's hard to
maintain the code that risk for the
effects and the code that becomes a team
probe tip the ball neck so let's jump
right in and have a look at what we
programmers actually do with programmers
we don't write code I mean sure
obviously we do that as well but that's
not where we spend most of our time if
you look the research findings you will
see that which shall spend most of our
time making modifications to existing
code and the majority of that time is
spent trying to understand what the code
does in the first place so they take
away at least for me is that if we want
to optimize any aspect of software
development we should optimize for ease
of understanding this is a challenge
here's why have a look at this
visualization that's a most of the
systems look at least the ones I've been
you working with and given this
visualization which parts are hard to
maintain when will the bugs be or run a
team productivity bottlenecks without
more context we just cannot tell and
this is a challenge that gets harder
with the scale of it because today's
systems are developed by multiple
programmers organize the multiple teams
and that leaves everyone with their own
view of how the system looks no one has
a holistic picture and this is an
age-old problem right so we've been
struggling with this for a long time in
the software industry and i would like
to start by having a look at one of the
traditional approaches to tackling that
and then we see the limitations of that
approach before we move on to some
entirely different right so let's start
with complexity metrics have any one of
you or any one of you using complexity
metrics today on your systems cool so
approximately 1015 people great so we
have a bunch of different metrics to
choose from and most of them go all the
way back to the 70s so this is an
example this is called McCabe cyclomatic
complexity where you basically consider
your program or your function as a graph
and then you calculate the number of
possible paths through it and the higher
that number the more complicated the
code and this kind of makes sense right
because its ties to one of the most
limiting factors we have in programming
it's a cognitive factor our working
memory there's really just so much we
can hold in our head at once so I would
say things like McCabe cyclomatic
complexity definitely makes sense I also
ask you I know it was just like 10
people out of all the people in this
room that uses excel complexity metrics
today so if we have complexity metrics
to identify the code that's hard to
maintain why don't we use them in our
industry I really don't know but I know
why I don't use complexity metrics and
the reason i don't use complexity
metrics is because complexity metrics
are pretty bad at predicting complexity
it's a bold statement so please let me
support it by reading a quote for you
syntactic complexity metrics cannot
capture the whole picture of software
complexity and what I like about this
code is that it's from a research paper
and what these researchers did was they
took a bunch of different metrics like
McCabe &amp;amp; Halstead's complexity measures
and they identified how well do these
metrics perform on real-world code bases
and what they found out was that as soon
as you start to control for the number
of lines of code those metrics don't add
any further predictive value Wow the
number of lines of code that's a really
rough metric is that really the best we
can do let me read another quote for you
and this is one of my favorites because
it's a little bit evil
the use of metrics to manage software
projects has not even reached a state of
infancy so this is a quote by Robert
gloss and is one of my idols is really
great and robot class means that
software is just so complicated so
open-ended that we will never ever be
able to measure it so what gloss suggest
instead is that we rely upon our
intuition now as some of you may know I
actually have a parallel career as well
other parallel career within psychology
and as a psychologist you just have to
love the concept of the intuition
because it's such a warm fluffy human
subject right but what is it actually it
turns out that how many of you have been
working more than a decade in the
software industry so almost everyone
cool so during that time you have all
built up a lot of expertise and all that
expertise is stored away in your head
now intuition that's basically just
something in this situation perhaps
something you see on screen or something
you see in your code editor the triggers
a recall of some of that information so
intuition is basically just recognition
the thing is intuition is an automatic
unconscious process and that means you
have no conscious recall or what kind of
information that gets retrieved and
that's kind of what gives the intuition
its mythical qualities but it also makes
intuition extremely thrown to cognitive
biases and even if we could somehow
control those biases which we can't
because we are humans intuition would
still not do the trick and the reason
for that is that intuition doesn't scale
no matter how good programmers we are
there's just no way that our expertise
is going to scale to hundreds of
thousands or even millions lines of code
there's really no way to do it and in
the software industry we haven't come up
to go with a good response to that
challenge so what I suggest is that we
look into a completely different field
it's a different discipline but one that
face is familiar open-ended complicated
questions as we do so please welcome to
forensic psychology you probably all
know a little bit about forensics
already perhaps you've read about
profiling in the news or you've seen CSI
haven't ya yeah and also bet that all of
you have seen the movie Silence of the
Lambs right cool also bet that you all
agree with me that Hannibal Lecter is
the coolest character right so the first
time I saw that movie I'm also extremely
influenced behind a lectern and I don't
mean that no no no I don't mean that in
a scary way right no I was influenced by
his forensic skills not the other stuff
it's completely safe to have dinner with
me tonight the promisee so if you think
about it's actually quite amazing what
Hannibal Lecter does Hannibal Lecter
sits there locked up in his cage and he
receives information from the crime
scenes and based on that information
alone Hannibal Lecter is able to deduce
not only their motives but also the
personality of the offender and the
first time I saw that movie I was like
wow I want to learn to do that years
later as I actually start to study
criminal psychology I get terribly
disappointed because it turned out that
those techniques that Hannibal Lecter
had been using they have a very serious
limitation it turns out they only work
in Hollywood movies fortunately we got
some more scientific methods so please
allow me to give you a two minutes
introduction to geographical offender
profiling now geographical offender
profiling is based on a very fundamental
fact and it's perhaps a bit surprising
because it's obvious but did you know
that Truman Al's most of the time behave
just like us they go to the movies they
go to restaurants the visit friends
perhaps they even pick up the kids from
school and esta move around in an area
that's where the spot on opportunity for
crime because for crime talk or there
has to be an overlap in time and space
between an offender and victim and what
that means is that the crime scenes
their geographical locations are never
random they contain information about
the criminal and that's something we can
use to catch them let me show you how
this is done and I'll do that by taking
it all the way back to 19th century
London to the Whitechapel area the
streets that Jack the Ripper haunted and
I hope you can see that here you have
some blue dots there those are the crime
scenes of the Ripper so what you do with
your graphical offender profiling if you
want to catch Jack the Ripper is that
you consider each crime scene a center
of gravity right and then you wait them
all together but with one important
psychological twist psychologically all
distances aren't equal so crime scenes
that are closer to each other tend to
get the sign more weight so now when you
wait them all together you end up with a
new center of gravity and that's the red
area there in the middle that's called a
hotspot and according to the research
there's a seventy percent chance that
our offender will have his home based
there so if you want to catch the Ripper
that's the area to patrol and supervise
and now I guess you're all curious how
is he ever going to tie this back to
software I'm a bit curious myself so
let's have a go at that but before we do
that perhaps you want to know if this
profiling stuff works at all because I
know it Jack the Ripper so sheep case
started to make right he was never
cooked so who was Jack the Ripper I
really wish I could answer that question
I can't but what I can do is to look at
the main suspects and see how well they
fit the profile so let's start with my
number one personal favorite suspect mr.
James Maybrick mr. James Maybrick was a
cotton merchant from Liverpool and when
he went to London to do business he used
to rent a room in
six straight so let's have a look at
male sex trade it's there right in the
middle of our hot spot so James May wick
is pretty good fit for this profile if
you read the news I guess it was lost
fall you probably heard about the
supposed DNA evidence against another
Ripper suspect the hairdresser Aaron
Kosminski now kozminski a probable lived
at sayan square so let's have a look at
sine square as you see sine square is a
little bit east of the hotspot so
kozminski is not a good as a fit as my
brick but this just raises an important
point about your graphical offender
profiling that is important that you
keep in the back of your head as we move
to the software word so geographical
offender profiling never points to
precise position whether geographical
offender profile does is that it
projects a probability surface onto the
geography right so finally let's see how
this relates to software and I think
that's important because look at it for
a moment look at the hotspot and
consider what we have done we have taken
a potentially vast geographical area and
narrow it down to much smaller area
where we can now focus a human expertise
so what if we could do the same for
software what if we could take those
hundreds of thousands lines of code and
neverland down to some smaller hotspots
where we can now focus our intuition how
can we do that the first thing that we
need is obviously a geography of code
here's my favorite approach this is code
cydia an include city software systems
of visualize the stones so each package
is each name space becomes a city block
and each module each class becomes a
building and you probably see that there
are some large buildings and some really
small ones and that's because sighs
represents complexity so the more
complicated a code a building represents
the larger the building right and what I
like about this visualization it
gives us a pretty good idea of where the
complex parts are in that code base but
again that doesn't move us forward
that's just plain old complexity metrics
visualized in a new way it's useful but
it's not as useful as it could be so
what I suggest is that we add the
missing dimension we need to add the
spatial movement not of criminals but of
programmers and let's data that you all
already have we just not used to think
about it that way I'm talking about the
version control systems each time we
make a change to the software our
version control system records a lot of
interesting information this is a simple
example from get and you see that each
time you make commit get knows who did a
change when was the change done and most
importantly where in the code did a
change took place now this is a single
commit for a single programmer a large
system consists of virtually thousands
of commits right perhaps hundreds of
programmers so what if what if we take
all the data aggregate it and project it
onto our geography of code here's what
it looks like
so you see those red spots glowing up
those are our hot spots and the hot spot
in this case is defined as complicated
code that we're to work with often so
complicated code that we have to work
with often what kind of code is that
what's the consequence of that to find
out I did a set of case studies and i
would like to present one of them for
you this is a case study done on a
fairly large system consisting of four
hundred thousand lines of code that
system was developed by 89 programmers
and i looked at the period of a year and
a half and during that time those
programs made a lot of changes so here's
what the geographical offender profile
looks like my wife claims it looks like
an alien but it's not it's not this is
four hundred thousand lines of code and
the first thing that you note besides
the alm is that i moved back to
two-dimensional representation and
that's because i think it gives us a
better overview on large systems it's
also a bit more reminiscent of the real
world of vendor profiles that we watched
earlier so this is an interactive
visualization which means you can zoom
in and out to the level of detail of
interest but even here on the highest
level we're able to spot a number of
hotspots now remember hot spots were
complicated code that you have to work
with often what can we expect to find
when we look into a hotspot to answer
that question I decided to mine a second
set of metrics I decided to look at the
bug distribution in that system and I
did that because bugs have this funny
property that bugs tend to cluster bags
like each other so in typical large
system relatively few modules tend to be
responsible for the majority of all bugs
and I look for an overlap with the hot
spots I kind of looked at the predictive
value of hot spots and what would have
found out was really interesting and
found out that the hot spots identified
seven out of the eight most effect and
sport
even more interesting the hot spots only
made up four percent of the code yet
that code was responsible for
seventy-two percent of all the effects
or if we turn it round in this
particular system if we improve just
four percent of that code you get rid of
the majority of your defects and the hot
spots show you exactly the parts of your
code base that matters the most right
now so hot spots help us narrow down on
large system to the parts that really
matter the parts that we actually work
with where we are likely to get a payoff
on our investment that we make in a
redesign or improvement but that's
really just a starting point we can do
so much more with this data and I would
like to show that to you by having a
look at what happens to our code what
you see here is a picture of a computer
program and I'm well aware that you
cannot read the details that's
deliberate I just want to float to focus
on the overall pattern here and that's
because I'm pretty convinced as we as an
industry we are actually quite good at
writing code we know what good code
looks like we know about loose coupling
we know about cohesion we know about the
solid principles and all that other
stuff that we think is important so I
would claim that their first version of
a program typically looks quite good but
then something happens let's have a look
at that whoops doesn't look too good oh
no oh no oh no oh gee what just happened
a program started out so pretty and then
a number of small D sauce to succour to
it what are those disasters what just
happened well let me tell ya we start
out really well the second one that's a
new feature the third one that's a bug
fix later on Friday just before on the
red line
and the third one that has to be when
the project lead decided to cut the
scope and then of course he changed his
mind so dis my friends this is time
happening to your program this is
maintenance and that's actually a good
sign it means somebody using your
program and they care enough about it to
suggest improvements because each one of
those disasters represent something that
someone Fox adds value to your program
so this is a good sign the problem
starts when we continue to build up on
that shaky foundation when we allow our
code to decline in quality like that so
what we want to be able to do is to
somehow identify those part of the code
base that they grade like that here's
one way to do it this is an analysis I
call complexity trends and what I do
here is that a pic each hot spot in the
code base and then a scan through its
version control history and measure the
complexity of each historic reparation
of that hotspot and that allows us to
plot the trend in time like that which
in turn allows us to predict the future
and the graph that you see there
represents the complexity trend of a
single hot spot over four years and you
can see that this code had just kept
accumulating complexity now remember
it's a hot spot which means we had to
work with it often what do you think
happens if we have to work with code
often and it becomes more and more
complicated over time I would say it's
not a wonder that there's a strong
correlation between hotspots and defects
so with a complexity trend we're
actually able to catch your debt and
stop that trend stop that further
decline all right so up until this point
I've been pretty much focusing on the
technical side but we have something
even more important to talk about today
and that's the other dimension of
software development software
development as
social activity and I like to introduce
this part of the presentation by one of
the best quotes I know about software
development code doesn't lie if we want
to know how something really really
really works we need to look into the
code the truth is there and it's
described in where a precise technical
detail so co doesn't lie but it doesn't
tell the whole truth either and if we
limit ourselves to what's visible in a
static structure of the code we miss a
lot of valuable information and what I'm
going to show you now or measures that
we just cannot do from the code alone
and the first example is something I
call a tempura coupling analysis so
let's see how that works with tempura
coupling so where the simple system here
it consists of just three different
modules and what we're interested in now
is the evolution over time so the first
time we make a change to the system we
change the fuel injector and the
diagnostics module together in the
second commit we change something else
in the third commit we're back to
changing the fuel injector and a
diagnostics module again now if this is
a trend that continues there has to be
some kind of relationship between a fuel
injector and diagnostics module right
because they are changing together in
time what kind of relationship could
that possibly be what you will find when
you start to investigate those findings
is most of the time you will find this
you will find that you have some code
over here you have some other code here
and this one uses that one so each time
you change this API you have to modify
the client as well this is just plain
old physical coupling and that's indeed
something you can see in the code but
remember tempura coupling isn't measured
from code its measured from the
evolution of the code and that means you
will sometimes find patterns like this
we have some code over here you have
some other code here and there's no
dependency at all between them yet they
keep changing together over time how can
that possibly happen it's it's some kind
of spooky quantum physics thing most of
the time not what I usually find when I
investigate those cases is a dear old
friend copy paste you have some code
over here compu ties the tear here and
here and now each time you modify the
original you have to remember to modify
the copies as well so tempura coupling
is an excellent way to detect software
clones but there's really so much more
we can do with tempura coupling we can
analyze complete software architectures
and I would like to show you one of the
example of that and then we see the
social dimension come into play as well
so this is a an example for pretty
simple system we have three different
subsystems and we can measure
temperature playing on a subsystem level
as well if we do that on this system we
actually found out that if these freight
systems are couple in time do you think
it makes a difference if that system is
developed by a single programmer or if
it is developed and multiple programmers
organize the multiple teams oh yeah it
makes all the difference and actually
experienced that a few years ago at that
time I did some work for a fairly large
development organization we were
something like 200 programmers and the
first day I get to work I get assigned a
number of tasks so I picked one of them
sat down and start to work on that one
but a pretty soon noticed in order to
complete this task I have to make a
modification to an API here was a really
simple change but that API was owned by
a different team so I walked over to
that team lead and asked him if he could
do that's change and he went like yeah
sure it's a dead simple change I get
started on it right away Oh perfect so I
went back to my desk then he came back
like a week later now I'm done all right
simple change
but I didn't think too much about it at
that time probably something came up so
thing was it turned out we had to change
that API a lot and each time we had to
do that the change took at least one
week to get at least one week so I
figured I really have to find out what's
going on here so I walked up to a team
lead once again and asked him I mean
sorry but that change was it so much
harder than you expected and he looked
at me like no of course not that stole
it was simple so why do you ask yeah I
mean it took you a week and what he told
me completely changed how have you
software architecture because what
happened was this the change was indeed
three bell for them to make by in order
to do it that modify yet another API
that was owned by a different team and
they in turn had to go to yet another
team and that team had to go to the
database administrators and yeah as we
all know that's what changed request go
to die so it turns out if you have a
system where you have a coupling between
its different parts and also developed
by multiple teams well you actually have
a dependency between people too
and this goes all the way back to one of
the famous observations about software
development Conway's law I guess all of
you are familiar with calm voice how
many are familiar with Conway's law coos
almost half of you great so I would just
cover it really briefly because Conway's
law has received a lot of attention over
the past years so Conway's law is
basically the observation that the way
we are organized tends to be reflected
in the kind of software design so the
popular saying if you look it up and
like the hackers dictionary is that if
you have four teams designing a compiler
you will get a four pass compiler and
that's kind of the fun cynical way to
look at it but the cool thing with
Conway's law is that come with law has
just as many interpretations as their
research papers about it so we can
actually pick our favorite here and i
always use Congress law in reverse and
there you start with the kind of system
you're trying to build and then you look
at it and then you design your
organization based on that system how
should we be organized to make this
happen as efficiently as possible and I
do that because when Conway's law is
used in Reverse it becomes a useful
organizational tool but I mean most of
the time we aren't doing new software
she textures we have existing systems
that we need to modify that we need to
improve that we need to correct bugs in
so how can we use Conway's law on legacy
code the first thing I always suggest is
that you start but trying to understand
what you have today how well does your
current architecture support your way of
working and one way to do that is by
using something I call communication
diagrams so communication diagrams are
created out of the evolution of your
code base so what I do is a scan the
complete source code repository and each
time I find a module where two different
programmers have contributed those two
programmers get a communication link
between them and then I continue to scan
and a third programmer comes along and
if she has worked in the same part then
she gets a communication link as well so
over time this allows us to
we'll up a complete graph over their
ideal communication paths of our
organization and let's say ideal because
remember this is mined from how the code
was actually created there's nothing
here to suggest that that represents
communication that actually took place
so what you want to do is to take a
communication diagram and compare it
against your formal organizational chart
and any discrepancies really have to be
understood so let's have a look at some
typical findings what you can expect to
find when you do that according to
Conway this is what you would expect to
find and what you see there it is simple
example have three different teams and
you see that most lines of between
members of the same team and that means
they work in the same parts of the code
they share the same context and that's
something that actually makes
communication so much simpler and
cheaper so that's what you want to see
and you also see that you have the
occasional programmer that works in a
different part of the code base and
that's just a sign that the certain
degree of cross-pollination is a good
thing in software development to this is
knowledge sharing probably people that
are rotating teams so this is where you
want to be let's look at the opposite
side of spectrum do you want to see a
complete disaster here we go so this is
a story about the company this is a
company they were in a very good
position they were going to do a new
product and they were in a good position
because they had done something very
similar in the past so they knew this
will take us one year of course someone
came up with the idea that you had one
year but you know we have this really
cool trade show in just three months can
we do it in three months all right so
how do you take something that's expect
to take one year compress it down to
just three months it's so easy just 40
four times as many developers on it
and I promise you this is a was a really
fast paced project right so the initial
architecture was set and 25 consultants
were recruited that ensure the time that
it would take you to read the mythical
man month and this used to organize them
in four different teams how do you think
the communication structure looked like
and this is the actual data was allowed
to use this is the real data from the
real project here it is that finger
looks kinda cool doesn't it but let me
assure you there's nothing cool about it
this represents chaos this is complete
communication anarchy because if you
have a look at it you will see that yeah
sure within each team the people do work
in the same parts of a codebase the
problem is everyone else does that as
well so this is not four different teams
this is virtually one giant team of 29
people with artificial organizational
boundaries between them and I didn't
work on the real project but I came in
afterwards and did a post-mortem
analysis and I get to talk a lot to the
developers and they told me a lot of
interesting stuff virtually all of them
complained about quality they had a lot
of defects the second thing that
everyone told me was that the code was
hard to understand because even if you
wrote the piece of code yourself today
three days later it looked completely
different because five other developers
had been working it in the meantime and
another thing that turned up was that
they spent a lot of time merging
different feature branches they could
spend literally day sometimes even a
week merging different branches if you
look at that communication diagram you
see that no they didn't have a merge
problem their problem was that their
architecture just couldn't support their
way of working with it so if you find
yourself in that situation that's
unfortunately just two things you can do
either you need to change your seat
architecture to support the way you want
to work with it or you need to change
your organization so people please align
your architecture and your organization
your
code is going to thank you for it
alright so the project has just totally
about remember that the programmers
complained a lot about bugs and that
shouldn't be surprising given what we
actually know about software bugs it
turns out that the number of programmers
behind a piece of code is one of the
best predictors of the number of defects
you will find there so in general the
more programmers that have contributed
to one module the more quality issues in
that module so I start to think yeah
well again this is data that we actually
could mine from a version control system
and identify those components at risk
for defects here's one way to do it this
is a visualization called fractal
figures and freak the figures works like
this that you consider each module a box
and each programmer gets assigned a
color and the more they have contributed
to the code the larger there are way off
the box so you see an example here of
four different modules and you see that
the red orange developer and the that
one is actually green on one them green
grayish a programmer they have written
most of the code but if a master access
parallel development I would go for the
second module there because you see it
as contributions from a lot of different
developers many small contributions and
when you see a pattern like that you
need to understand why and I promise you
if you look into that code you will find
that code changes for a reason the
reason that module attracts many
programmers is probably because it has
many reasons to do so it tests too many
responsibilities so this is a good
starting point but we can do so much
more with factor figures as you see
fraktur figures makes it pretty easy to
identify the knowledge owner the main
developer behind each module and if you
have that information for each module
why don't we project it onto our static
geography of code that would allow us to
build up a complete knowledge map over
code base here's how it looks and again
this is real data from real project this
is the scholar project and you see a
part of the compiler there and this is
something you use to simplify your
communication so let's say that it works
exactly the same each programmer is
assigned a color and what you see is the
main developer so say that you join the
scholar project and you want to know
something about the back end into your
upper right corner well i would say that
there is a fairly good chance that the
light blue developer may know something
about it and if she doesn't know perhaps
the green developer knows so this is
something you use not only simplified
communication but also to ensure that
you invite the right people to kill
review or discuss a proposed design
change with the right people but we can
do even more instead of focusing
individual developers why don't we
aggregate them into teams that will give
us a way to evaluate Conway's law here's
how it looks so now the colors represent
teams and you see according to conway
this actually looks pretty good you see
the red team they have their own
subsystem where they pretty much can
work in isolation and the pink system
also have their own system so that also
looks fairly good but down below you
have a fairly large subsystem with
contributions from all three teams and
again when you find something like that
you need to understand why and it could
be as simple as this organization may be
just like so another team to take on a
shared responsibility but i guess that
most of the time what you will find is
again the code changes for a reason the
reason that subsystem attracts three
different teams is probably the sauce it
has three reasons to do that it would
perhaps be better off split into three
different parts and when we have a
knowledge map of teams why don't you
overlay the result of a temporal
coupling analysis and that allows us to
spot those expensive modification
patterns that ripple through the
organization you know like that story I
told you about a while ago where a
simple change took one week because it's
ripple through the organization
here's how we identify those and we
already touched upon their communication
diagrams but those communication
diagrams don't those are virtually your
social network of code and when we talk
about social networks you will find that
the at2020 principle holds in code bases
as well you know it's true on Twitter
it's true and Facebook and it's to
encode that eighty percent of the
content is generated but twenty percent
of the members and us see that all the
time I have analyzed literally hundreds
of different source code repositories
and you will see you see the developer
on the right there's a lot of
communication going out so these people
they're probably core developers there
are key players they know the code base
inside out and you have that in all
organizations perhaps they are you so
what would happen if you suddenly lived
left if you just walked out the door on
a jade a job decided to quit or you get
pulled from a current project what would
a consequence be well we would obviously
get a knowledge gap how big most of the
time we have no idea but using this data
we can actually find out here's what it
looks like so you see those orange dots
there in this case they don't represent
hotspots no they represent abandoned
code that is code that's written by a
developer who is no longer in the
organization and this is something you
can use as a technical leader or
technical manager to reason about the
knowledge distribution in your code base
and when you do that you will sometimes
find things like this where you have an
entire abandoned subsystem and again
that's something you can use as part of
a risk assessment because it is an
increased risk to modify code that we no
longer understand
all right I'm almost done now I just
want to summarize it for for you before
we go to the questions so i think that
ideas from forensic has a lot to offer
in software development too we have seen
how hot spots help us identify code
that's hard to maintain and code at risk
for defects and we have also seen the
state dis analyzes dig away beyond code
and they let us reason about things that
we haven't really measured before things
like knowledge distribution and we can
even evaluate the organization with
respect to our communication paths
control our way of working so this is
something you can use in a tech lead
position to improve and simplify and
this is a large area and this
presentation has really just scratched
the surface so if you want to dig deeper
feel free to send me an email or have a
look at my blog where I regularly right
about this stuff and of course also get
the complete book that goes into all
this stuff in much more detail so now
before we go to the questions I just
want to take this opportunity and say
thanks a lot for listening to me and may
the code be with you thanks
Thanks there are some questions Adam oh
great so which tools support extracting
all those data from our code base so
which tools I'm actually using my own
tools and the reason for that is when I
started out with this kind of stuff like
five years ago there was virtually no
tooling support beyond academic gap so
I'd to write my own tools for that and
are still using them and if you go to my
homepage you will actually find a link
to my github page because I do open
source a lot of these tools that I use
so there are they available there to
help you get started and I think we will
see a lot more happening in the tooling
area because i actually just launched my
startup where I will be focusing on
delivering professional tools around
this area so i hope i have some really
exciting stuff coming up soon right so
that also answer the next question about
open source tools you do have that i do
have them yes and i would continue to
maintain them great so here's another
one which is that's a tricky question
and long would you agree that your tools
will work only for mature projects with
stable crew developing them you cannot
predict the future or compensate for
people joining and leaving the team so
it's partly true I mean there are
basically two different sets of analysis
you have the technical analysis like hot
spots and temporal coupling and those
are useful on all kinds of projects even
those one with quickly changing stuff it
doesn't really matter there are even
more important that I would argue but
things like a communication diagram kind
of loses its meaning if they're people
wrote eight teams a lot the new people
come out and leave but I still think
it's useful to have a knowledge map at
least for the abandoned code right so do
you have any tips on how we can utilize
that in an agile environment where in at
least my team we do not encourage code
ownership Thanks alright so how can you
use this in agile why well
what I've been doing is that at the end
of each if you're doing something like
iterations of sprints at the end of each
iteration I used to print out the
hotspot map and give it to the test
later when the test later used that to
focus their exploratory testing efforts
to the areas that were most likely to
contain the defects and we actually get
a you to return on that simple
investment and I also think that it
makes sense to measure temperature pling
at the end of each iteration and do
something use a real low tech dead
simple technique just print out a map of
your temper our couplings nail it to the
wall and in the next iteration you do
the same thing and that simple technique
allows you to spot architectural decay
and that is when you suddenly get the
dependencies in time between different
parts of the code by locating different
subsystems so that's something i really
recommend what about projects with no
source control they do exist
unfortunately they do Wow well
yeah in Denmark they do my tools won't
be able to solve that unfortunately
right so which tools do you use for the
visualization Oh again that's my own
tools and I do the visualization say I
use mostly a d free the JavaScript
framework but also do a lot of them in
closure using our framework or a library
called quill which is a layer on top of
processing which in turn is our creative
coding environment and it's really fun
so please pick up processing it's just
so fun to code in but I think the last
question now how do you convince
management to reshape the organization
to fit the architecture once you have to
identify the need for it wow if I would
know the answer to that question I
wouldn't be here I will be out there on
my yacht or something so I'm sorry I
really don't know that but what I do
know from experience I do these kind of
analysis in different organizations and
management do tend to react to what they
see because you get hard figures that
shows you that this is something that
actually costs you money so management
tend to be quite receptive to this kind
of analysis that's my experience at
least right so remember to vote and you
can still add comments and I'll sent
them to Adam in an hour or so thank you
very much for listening and thank you to
Adam
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>