<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Level Up Your Automated Tests • Trisha Gee | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Level Up Your Automated Tests • Trisha Gee - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Level Up Your Automated Tests • Trisha Gee</b></h2><h5 class="post__date">2015-07-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/D-xra_X9Nwg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you um yeah so hopefully this is a
talk about how testing will make you
happy maybe not I'm not sure but that's
the aim I had a tiny tiny panic this
morning when I realized I left my cable
at the user group that I spoke at last
night and my laptop was completely out
of battery so we're going to play spot
the slides that Trish didn't have a
chance to make up properly yesterday
what could possibly go wrong right
enough about me
you guys hands up if you're a developer
most most of you hands up if you kind of
identify as being more of a tester okay
cool
and I don't know there was probably some
overlap between those two people that's
fantastic
so um I'm going to tell a story about
how so I work for jetbrains we make
IntelliJ who's using IntelliJ or
resharper a chunk of you good the rest
of you you should definitely do that
pick up a leaflet down here and get on
it straight away but this is not a talk
about jetbrains or about IntelliJ or
about tools this is a talk about and
when I worked at MongoDB which is my
last job how we changed our approach to
testing for for MongoDB so this is a
user new technology and all your
problems will be fixed talk now it's not
thank goodness it's not one of those I
am going to touch on a technology I'm
going to talk about a technology which
helped us but I'm going to talk more
about why this particular technology
solved our particular problems around
testing so I really want to talk a
little bit more about why we as
developers are not always super awesome
at writing tests and sort of look into
some of the the reasons for that and how
you can perhaps attack some of those
problems that's the theory anyway so
let's have a look at why we don't write
tests I'm going to try a bit audience
participation this might go horribly
wrong so I apologize okay let's
I knew this is a bad idea okay cool so
this is like a quiz show type thing
about so name me a reason why you don't
write tests when you should do too hard
to set up
hey you read that other than too hard to
set up
all right fine let's do that oh what's
going on I knew this wasn't going to
work I put my clothes in here and
everything I had to write VB script
yesterday it was revolting
all right format let's do the old-school
way it's probably cuz my laptop ran out
of battery yesterday right yes too hard
to set up well done yes yes good one
well actually I'm going to put that on
too hard to set up because legacy code
is generally not designed to be well
tested so you have to put in place
framework yes
right the tests become irrelevant as the
code changes that's a good one and I
don't have that one yes
all right you don't think the tests are
very valuable I've got that somewhere
don't read it okay I'm gonna put I'm
going to call our effort versus value
and right this is yeah I've totally done
this talk loads of times before you can
totally see this work yes somewhere over
here someone had a hand up yes too
difficult to work with dependencies okay
I've got one of those too oh stop
reading everybody too hard to mock or
you know to stab or whatever yes yes
actually I thought that would be the
number one thing that people said I know
you're all reading this for the Spry and
you'll get the answers right we'll get
through it quicker and so yeah number
one reason normally is I don't have time
to write tests and then of course it
comes and bites you in the ass later on
when you don't have time to refactor
either and your code is a big mess right
right I'm going to classify that as too
hard to set up and too hard to mock but
yeah you're right I mean legacy code or
code which is kind of yeah
evolving is difficult testers are
supposed to write tests okay that's a
good point I don't have that one yes
right so the person who writes the code
shouldn't be writing the tests because
you know what the code looks like so
you're going to write the tests too so
they pass your code yeah totally I don't
have that I guess a lot of people who
answered this form or TDD type people so
it's less less of a problem still a
problem yep how outrageous quit
immediately right so working for a
company that doesn't let you write tests
it's not unusual worked yeah it's not
unusual I had a number of people say
that actually on Twitter not allowed to
write tests I didn't put that down
because I thought that was outrageous
and shocking right okay well let's let's
move on before this gets too involved
right format Oh God and I'm using Excel
and I'm using Windows and it's all
fairly new to me lots of people saying
single-use codes those scripts
prototyping one-off and then more or
less all of those same people afterwards
saying I really wish I'd written tests
for that stuff because it ended up in
production at some point the code is
simple they might start off that way but
it almost definitely doesn't end up that
way and the code might be simple for you
but the test isn't necessarily for you
the test might be for future maintainer
x' UI code yeah it's tough it's
certainly tough to unit test UI code not
enough time effort versus value I'm the
only maintainer so I don't need to write
tests because I understand my code and
that might be true for you luck but I
have a memory of a goldfish I have no
idea what my code does five seconds
later and I had two more things which I
really wanted to put on here one was and
I don't write tests when I want to do
things the hard way
IE i'm masochistic and then the other
one was I don't write tests when I want
to inflict pain on my coworkers nice
okay and in actual fact let me just
quickly turn off my Wi-Fi before someone
tweets me something inappropriate right
not that that's ever happened to me
before and now I'm stuck because I'm in
the wrong mode I'm so sorry about this
I'm a total professional presenter this
is what I do all the time
yeah wait so we don't write tests
because we don't have enough time
because it's hard because if we're right
into second things are difficult so it's
hard to write tests and the funny thing
about about testing being hard is that
as developers we don't really have a
problem with hard problems we actually
like hard problems
if someone says if a business comes to
us and says I have this problem that's
really difficult to do we go yes bring
it on and then if someone says would you
want to test this legacy system like no
really it's a bit hard so we have this
kind of weird mindset towards testing so
what what a tests for automated tests or
even manual tests what is it that we
think we're doing when we're testing
stuff well that's obvious right we're
checking that the code works
that's what testing is for but I think
that's one of the things that leads us
into this trap of not writing tests
because we know the code works we wrote
the code it's totally fine or we're
about to write the code for doing
test-driven so writing code that checks
our code works seems a little bit of a
waste of time it often feels like a
duplication of effort because we've
written the code so writing a test that
proves the codes oh we've already done
that it works of course it's perfect and
but there's a number of things that
tests are actually good for other than
checking that the code works so
obviously there's the quality thing but
it's not just a case of making sure that
your tests work right now
it's obviously regression testing and
running them over time making sure that
your code continues to work in the
future maintainability so it's not just
about checking that once I've written my
code it works it's about giving me the
safety to do things like we factoring so
yes so I can refactor in safety and know
that everything still works design
if you're doing testing upfront
test-driven development test-driven
design writing your test first can
influence the design of your coat and it
should influence the design of your coat
it allows you to inject dependencies it
allows you to make it easier to test a
lot of these brownfield and legacy codes
are difficult to test because they
haven't been written in test first so by
writing tests whether it's first or
second you can influence the design of
your software and reliability it's not
uncommon for tests maybe not so much
unit tests but integration tests or
acceptance tests to occasionally fail
and not in a kind of not in a
predictable way so sometimes that's a
sign of a flaky test but sometimes it's
a sign of something deeper in your
system in terms of reliability it can
point to things like race conditions it
can point to I don't know dependencies
on external things which might not be
super reliable so testing also gives you
an idea of the reliability of your
testing and you don't always know
whether it's the reliability of your
test or the reliability of your system
but if you have this as a metric to bear
in mind and take this seriously you can
dive in and figure out whether your
system is is the problem with your
tester we had a tool at Lmax
so I used to work at L mics like Martin
Thompson as well and we used to do a lot
of this testing stuff quite right and we
had these big acceptance tests which
test everything end-to-end and some of
these tests would be failing because the
functionality is broken or perhaps not
implemented yet and some of these tests
would just intermittently fail so my job
at the beginning not my job I signed
this to myself because I'm enormous ly
OCD and seeing red on the board drove me
crazy and what I used to do in the
mornings is I would check to see which
tests were really failing and which
tests were just intermittently failing
so someone else decided this was a waste
of my time took away half of my job and
automated this and created a tool called
Auto Trish
which is nice and they still use that
now and I left them like three years ago
um and that will give you an indication
of the reliability of the system and
over time because they have visibility
over these intermittent tests they've
been able to and get reliability from
their tests and from the system it has
actually allowed them to see where there
are issues that they can fix not just
the not just the correctness of a couple
of lines of code reliability the overall
system documentation now for me it's all
more of a visual person so although I
can read code and kind of understand it
I may be doing it for 15 years I ought
to be able to understand it
I much prefer tests to document what
things are supposed to be doing I can
read a method and figure out what it
thinks it's doing what I like about
tests is they should document what you
think the system should do the behavior
it should have so if I insert this sort
of document into MongoDB it should fail
with these conditions or it should not
fail under these circumstances so you
can document that better I think with
tests than with comments or with with
the code even with nicely written code
and finally this is a kind of weird one
in MongoDB what I was working on is a
Java library which your JVM application
can use to talk to MongoDB and so we
don't have a UI our user interface if
you like is our API so we actually found
that by writing tests which exercise the
API we get an idea of how usable that
API is for Java developers so there's a
different kind of usability to clicking
this button here and putting these
images in this part of the screen but it
does allow you to get an idea for the
usability of your code the usability of
your system from a developer point of
view and maybe even if you're doing an
UI testing as well but that's not an
area for looked at for a while so
how can we change ass shoes how can we
shift from this testing is to make sure
it's correct attitude and my codes
perfect - testing has a birth is a
first-class citizen it belongs as a very
very important part of what we do as
developers or what we do as a team and
what our system should do so testing is
also about documentation and usability
and all these other things so how can I
make mic how can I force my co-workers
to see things the same way I do and
really understand that testing is a
first-class citizen well actually it
doesn't really matter whether other
developers have in their mind exactly
the same thing that I have in my mind
what matters to me is that they behave
the way I want them to behave
I want my co-workers to be writing tests
I want them to be writing tests which
are understandable they're good
documentation tests they fulfill all
those criteria we had on that what our
tests good at so I don't necessarily
have to change people's minds so they
believe things like as religiously as I
do or whatever I just have to make it
easy for them to behave in a way that we
get value out of our tests I think I had
too much coffee this morning I'm talking
far too fast
right so how can we change behaviour and
this is a really unstable stage by the
way so I'm going to fall off and kill
myself in a minute how can we change
behaviour so for us it was useful to
have a champion that was kind of me
being the OCD test type person I'm not
going to walk around because it's too
quickie and so yes having a champion who
can be the person who really cares about
the quality of the tests is a good way
to drive overall quality for the whole
team so for example one of my first jobs
if you like that I kind of assigned
myself was what I didn't like when I
first got to the team is that on Jenkins
the build would quite often fail and we
didn't really know whether it was
because we had an overnight build of the
server which perhaps didn't perhaps some
contracts had changed some behavior
changed or whether the tests were flaky
or whether the code was bad and so
because we didn't know why things were
failing we often ignored them so read
builds were like oh yeah it's right
again so I kind of I do a lot of nagging
I think I don't like that word nagging
is a very female word I do a lot of
steering people in the direction I want
them to go home so I would kind of get
on get on to chats or get on to email
and say look the build is read again it
looks like something this Pleasants
commit so broke it and can you get on it
and fix it one of the things I didn't do
is I did not sit there and fix
everyone's broken builds because that's
not the job of the champion the job of
the champion is to delegate to other
people and say look you should care
about these things so making sure that
we took red-billed seriously making sure
that we had things like static analysis
tools again I guess that's maybe because
I'm a bit OCD but I wanted people to
take consistency and style very
seriously so we had Czech style and fine
bugs and we fixed those errors between
us we dish them out between the whole
team and then we made sure that we had
zero Czech style and Feinberg's find
bugs
errors going forward that would fail the
build if there were any errors what else
oh yeah and we did code of you so I
quite like pair programming which is
what we did at L max but we were a
distributed team so we kind of had to do
the code of you thing more be
of the time zone difference than the
distance because you can do
asynchronously so encode reviews people
learnt very quickly that the first
question I was going to ask when I was
reviewing someone else's code is where
are your tests and some people say I
have one test I mean yes but you wrote
200 lines of code and you have one test
you should probably have at least two
hundred lines of code worth of tests and
I don't just want happy path tests have
you perhaps tests are very easy to write
when you wrote the code first and then
you write the test to check the code
does what you thought it was supposed to
do but what you should be thinking is
okay well what if someone calls this
with something weird what happens if
someone pokes a null in here what
happens if the server returns with an
error or of course the server can easily
return with nothing because the network
connection could drop so for every happy
path test I'm expecting I don't know
three four half-a-dozen unhappy path
tests so I was pushing on that stuff so
as I kept pushing people in the
direction I wanted them to go in and
doing these things becomes a habit
so keeping jenkins green is something
that we all do making sure that checks
tile passes is something that we all do
and making sure that we have tests in
code review is something that we just
get into the habit of doing this stuff
so I don't have to nag any more and the
whole team just kind of does it because
it comes routine it becomes habit now
this can only get you so far because
especially if you're trying to change
behavior and you haven't necessarily got
everyone's buy-in into thinking the same
way as you you you can't necessarily get
everyone to do everything the way that
you want them to especially if your I
found it difficult to articulate some of
the things I wanted from people or and
why I wanted tests to be a particular
way I don't want them to just kind of
write test a particular way by like
habit and by rote and not thinking about
it I want them to to understand this
stuff and if they haven't if I haven't
articulated that very well
then they're not going to buy into it so
we still had a bunch of a bunch of other
problems so I'm not sure if you can read
that this is where we spot the slides
that I wrote on a piece of paper this
morning
I heard we had a number of other
problems so we have a complicated matrix
of capabilities what this means is that
we have our jar file can be used by
anyone it's a downloadable library so it
needs to be tested against Java 6 Java 7
Java 8 we need to be able to run against
all the most recent versions of the
server so server versions do point to
different 42.6 3.0 so we have already
have a communicating matrix of stuff on
top of that we have some tests that run
against replica set some tests that run
against single servers some tests that
run in the sharded environment so things
get kind of complicated we still have
this tendency to only write happy path
type tests it's just not it's just not
in our nature to try and break the
system we're developers we kind of want
to make sure it does what we said it was
going to do I think this is compounded
by the fact that our team didn't have
any QA or tester type people we only
have developers and I think QA people
are really brilliant at helping guide
you into this mindset of how can I break
it what could go wrong and developers
are not as good at that we didn't have
any unit tests which I thought was a I
thought that was a smell because I feel
like with unit tests you can run them
much much quicker and you can get fast
feedback and not everything should
require you to have the database up and
running consequently because we had a
lot of functional integration tests lots
of tests had a lot of setup to get
everything in the right state before we
could poke it with whatever values we
wanted we were again sign of the same
problem testing too many things so once
we've done all that complicated setup
we're like well we won't just do one
assertion because you just spent ages
setting up the server in the state we
want so we're going to assert this
assert this try this do the other and
that's kind of a certainly when you're
using j-unit that's not a very good
pattern to follow weird horrible test
names test basic two strings strings to
mind test doesn't fail well good that's
nice
difficult to see what's under test so
because we have this long set up because
we have complicated functional tests you
don't really know when you're looking at
sort of 30 lines of test code which bit
is a bit
testing and which bit is the stuff that
just gets the server into the state
might need it into consequently their
tests are difficult to read and we have
lots of many similar tests so and this
is kind of good patented practice in
j-unit where you have one test which
tests like inputs one two three another
test which tests input ABC and another
test which tests input null and they
should be separate tests because if
something goes wrong they should fail
separately but this was kind of
cluttering up a lot of our test code
base so in order to fix a lot of these
problems and address these problems we
need to make it as easy as possible for
developers to do the right thing so I
investigated a bunch of solutions I'm
not really going to go into the details
of this because the slides are available
online and you could look up all of
these things but the point of this slide
really is to show that I I heard about
Spock as a possible solution for testing
problems but it wasn't the first one I
jumped on it's not like I went our spot
cutscene groovy that sounds amazing I
don't know groovy I'd love to add it to
my CV and that did not go through my
head I went to a bunch of these other
things but my ex-colleagues that Lmax
had been playing with spock so i learned
a little bit about spock and decided i
have a look at what Spock could do for
us to fix some of our remaining problems
now normally I wouldn't necessarily look
for a technical solution to a kind of
process problem because then you
probably end up with two different
problems especially because Spock is a
library written in groovy and you have
to write your tests in groovy we're a
Java driver were a bunch of Java
developers we are going to be used by
Java people it doesn't seem to make a
lot of sense to bring on a different JVM
language to test our code so I wanted to
be really careful to make sure that
Spock actually fixed the problems that
we were having before we made the leap
to a brand-new JVM language just for
testing so I have a quick look at a
simple spot test there's anyone here
using Spock Oh quite a lot of you that's
good
so you guys can like snooze for the next
ten minutes that's fine and who's using
groovy generally or has awareness of
groovy a few of you and who well as
other people's Java people or you don't
really care about the technology Java
people are chunk with you okay cool and
the rest of you don't care about
technology you can snooze as well that's
fine and so I'm going to go through a
little bit of of the of what Spock looks
like because what I want to do is say
the sort of process I went through in
evaluating this to fix our particular
problems around testing so I can I want
to point to this but I'm a bit short
there's a number of things that occur to
me when I look at this this is a very
simple spot test but it's a genuine one
that lives in the MongoDB Java driver
codebase firstly the test method is a
string the method name is a string and
actually for tests that's really nice
because you don't have to people stop
freaking out about writing long method
names they can actually write something
longer descriptive in there with stuff
other than just lower case you can use
camel case and whatever you want to and
so it kind of frees you from this test
basic to mindset and the thing which
really drew me to Spock though is
instead of having an annotation like
test to say this is a test method you
use a series of labels in this case
given when and then there are other ones
but given one and then of my favorite
ones so this gets you into the BDD style
testing mindset this forces you to split
your tests up into this is the set up
this is the stuff that's actually under
test and these are my assertions and so
once you've split it up into those three
sections you can start to see any smells
in your test so you can see oh I've got
like 25 lines of setup for one line of
tests the least I could do is extract
that out into something usable or
perhaps my test is doing far too many
things or as quite often happen to us
especially when we were translating old
tests into new tests when we come to
figure out what goes under the when bit
then we're definitely not testing the
right things because you should be
thinking what is the thing I'm really
trying to
test here when what happens should what
happen so yes and then under your
assertions obviously you can tell
whether you've got too many assertions
and you could figure out what's a real
assertion and sometimes you know when
you scatter assertions and the set up
just to make sure the setup Mike right
and you could kind of tell that you're
doing that if you if you follow this
pattern what else so I'm a Java person
and lots of people always complain about
Java boilerplate and how painful it is
and I was like well whatever I don't
care because like I'm a Java person I
just ignore all the boilerplate until I
came to looking at the way maps are done
in groovy and I was like oh like key
value pairs that's nice
and I have to do an append with like two
parameters it's a it's just much nicer
when it's laid out like a key value pair
MongoDB is a document store and
documents look like JSON so a lot of
what we did was creating these map
objects to be turned into JSON to go
into MongoDB and it's it's ugly it's
painful but with the groovy testing we
found that the map syntax was much more
descriptive and was clearer for us even
as Java people it was clearer for us
which documents we were creating and
what we were doing with them what else
and any assertions you can say equals
equals equals instead of assert equals
or assert that or assert false so again
it's kind of a little bit more readable
so even if you've been doing J unit for
I don't know seven eight years like I
have been I actually found this a little
bit easier to read than J unit tests so
how do these Spock tests fix the
particular problems that we had well
we'll go back to the example I just
showed one of the problems we had is
that they were hard to read and all of
the members of the team generally found
that the Spock tests were easier to read
for a number of reasons one the given
when and then really puts it into your
brain like what's happening in the test
what's really under test what set up
what am I really trying to do and the
the string method names also make it
kind of easier to tell what's supposed
to be happening in the tech
so similarly we had these horrible test
names so again the string method names
that made us have much better tests test
names and this is actually one of the
shorter ones I didn't put the really
descriptive ones on there because they
wouldn't have fitted on the slide so the
problem we had was that it's difficult
to tell which thing is really under test
and Spock has an annotation called
subject which is not mandatory but you
can put it in there as a sort of
documentation annotation so you can say
look in this case we're testing
MapReduce so the MapReduce output class
is the thing that's under test and the
thing that happens after the when label
that is the thing we're testing in this
specific test so it became a bit clearer
what we were really trying to achieve
and again if we were doing translation
from our old tests into new spot tests
and we couldn't figure out what the
subject was and what the when was that
test had very limited value lots of
setup so again the same test here if you
do have lots this is again a much more
shorter example in some of the examples
we had if you do have a lot of setup it
becomes very obvious that you've got
lots of setup because it's all in given
and so you might want to reflect that
stuff out or worst case you keep
everything in given but you can just
ignore that because you know that setup
and skip straight to the one of my
testing what are the assertions we
didn't have any unit tests because
mocking and stubbing is kind of tricky
and we kind of we didn't want a lot of
dependencies the production code has
zero dependencies we didn't want to have
loads of dependencies are in our test
code on things like mockito or jmark or
whatever and so we found mocking very
challenging when you don't have a
mocking library to help you out with
spock you get mocking for free
and it's kind of super easy so you just
say at the top there you just say i'm
going to mock this thing and it does it
for you magically and then at the bottom
these are the assertions you have on
your mocks so this is checking that if i
encode an array it gets
you know those particular methods on the
writer get called in order I was
learning Spanish by the way which is
crisis una dos tres and so here we said
we expect one of these one of these one
of these so unlike a lot of other
mocking frameworks which I've used I
found this easy painless and readable so
I can see what I'm expecting in the
assertions and the assertions are at the
bottom of the method as well unlike
something like Jay mark where you have
to set up at the top what you are
expecting the mock and stub to do
there's sort of backwards in spoke all
the all the mocking all the assertions
are at the bottom where you expect them
to be we were terrible at writing
unhappy / code tests so what makes this
a little bit easier as well because we
could do go over here I'm going to
change sides and you can do tests which
make sure the specific exception is
thrown that's not a fantastic example
actually not only can you do a test to
make sure that a specific example is
thrown because you can do that in j-unit
too but you can get that exception and
you can query things like the root cause
of the exception or the or the message
or whatever so you can do a lot more
proper assertions on your on your
failure cases then you can enjoy mocks
in j-unit and one of the other things I
really liked is it's explicit about when
exceptions aren't thrown so we used to
have a bunch of tests which had no
assertions did a bunch of stuff and then
didn't have any assertions and they I
couldn't work out what it was testing
and of course what it's testing is you
don't get an exception
and I'm like well that's kind of weird
let's be explicit about that so here I'm
checking that if I do this with them an
invalid URI I don't get an exception
it's totally valid so if you have a
bunch of tests which look really similar
sort of copy/paste testing with lots of
slightly different inputs and outputs
Spock has data-driven testing so I can
put in like the criteria something to
sort by and then the expected ID for
example I can put in whatever I want and
that allows me to run the same sort of
tests
with different inputs and outputs and
that's really powerful especially for
something like a database driver where
what we do is take input do something to
it and put our output and we quite often
want to put in different types of input
to the same method similarly when we had
the other problem which is one test
which tests everything we could split
that again into one of these data-driven
tests and one of the really nice things
about the data-driven tests is it's not
super clear but if one of those Minds
it's kind of I'm red green colorblind so
this is not very obvious but there's
like a orange failure halfway down there
and if one of the inputs and outputs
fails then you just get just that one
failure coming up and you can see all
the others are run and they're all green
so you know that the failure is just on
that particular input output combination
and it's not say something wrong with
the encoding overall one of the other
things is that groovy has really nice
assertions it's really helpful at
telling you what's actually wrong with
your code which bit is which bits
failing whether like here again that's
it right well I don't think but you can
see the value of collection the value of
find one the value of criteria so you
can see exactly what what caused the
problem we had this complicated matrix
of sort of versions if you like and and
you can do this is not I don't think
this is just a Spock thing we just found
it easier in Spock you can do ignore if
so for example when we were doing
testing on legacy legacy and things
we're not going to run this on the 3.0
server because it doesn't support this
we're not going to run this particular
thing on Java 1 6 because it doesn't
work and we're not going to run this it
is a replica set thing because I don't
know assume it doesn't work with replica
set but again that kind of documents the
expectations of those tests and
previously we kind of had if inside our
our test methods and they would just
kind of not run but they wouldn't pass
or fail whereas these are literally
they're ignored tests under the
circumstances where they're not supposed
to run in spock 1.0 which i haven't used
yet there's also
requires annotation so kind of the other
way around you can say requires Java 8
if for example we had some Java 8
specific stuff right so that's kind of
everyone who went to sleep can wake up
now so we kind of we run with this for
quite a while I did I did a week-long
spike first to make sure that my
questions were answered but we ran with
it for a bit and obviously what we want
to do is keep checking in to make sure
that Spock is giving us what we want is
odd our tests giving us more value than
they were before our is Spock is it
worth it having this different language
to test the library maybe we could have
just learnt to write better tests so I
think Jays talk after this it's going to
do a lot more about how you write good
tests and I kind of decided to go for a
framework which kind of forces you to
write in the BDD style given when and
then rather than trying to coach the
team on how to write better tests in
j-unit which is entirely possible but it
requires a bit more discipline so what I
found is so I wanted to Spock originally
for unit tests because it's got great
mocking and we didn't have any unit
tests and I didn't really want to
complicate things by saying we're going
to have integration tests in Spock and
Java we're gonna have like old-style
Java tests new and not too bad Java
tests new new Spock tests and then spot
J unit tests because I just thought that
was going to be crazy but what happened
was everyone was enjoying Spock so much
and found it so readable and so easy to
write tests they started writing
functional tests in them and they
started using Spock like pretty much
wherever they could because it was
easier faster and more descriptive to
write tests this way so the fact that
the rest of the team which don't get me
wrong they did write tests but they were
not super excited about writing tests
we're kind of rolling Spock out across
the whole library means that in my mind
it was its success because people were
enjoying writing tests I'm going to say
enjoying yeah sure they were enjoying it
but they were preferring to write tests
in this particular way rather than in J
unit and what else oh yeah and it proved
itself for time and again because as we
were writing more tests because it was
easier
it's a little bit more fun no one on the
team was actually one of these are and
we need to learn a new language type
thing so we weren't like super excited
about writing groovy tests just for the
sake of learning groovy but it was kind
of fun learning how to use groovy as
well as part of our testing so we wrote
more tests than we would have written
before and obviously we started catching
more failures so more failures in our
code and we were often running against a
nightly build of the server so we could
feed back to the server team quickly if
something like an error message had
changed and they weren't really
they haven't published that these things
were changing so we got much better at
finding errors before our users found
errors which is a good thing but we
still had a number of issues oh yeah one
of the other interesting things and I
don't know if this was because we
started getting a better at testing or
if it was just an evolution of MongoDB
as it got more mature but we started
writing and we started writing
specifications for how things were going
to interact with a server but we also
eventually just before I left we started
writing kind of compatibility kit type
BDD style descriptions of it weren't
actually tests but descriptions of tests
to run to make sure a driver was meeting
new specifications from the server so we
got this idea of tests as documentation
starting to come through the whole
company not just the Java team but all
of the driver team and the server team
as well so that was fantastic just
starting to think of tests as being a
much better way of describing the
behavior than documentation or committee
meetings or whatever but we still had a
bunch of issues
did we yes um grooviest performance is
different to Java's performance it's a
little bit slower to run individual
tests we found that some of our
performance sensitive tests didn't
always run in groovy and I didn't always
run didn't always succeed in groovy they
timed out earlier than they did in Java
and I'm not sure if we should have got
better at writing better groovy tests
but we ended up writing those tests in
Java the performance sensitive ones who
wrote them in Java because Java
performance is more predictable it's not
necessarily Paul it is better but it's
not that as there's more predict
so we kept our performance sensitive
tests in Java and it was easier for us
to keep them in Java than to try and
figure out what to do in groovy to make
things better dynamic dynamic languages
dynamic typing I'm a Java person I found
it a bit challenging especially when you
kind of miss type of method name or you
you don't know what type something is
because you've defined it as a I don't
care what type this is and you only get
the error when you run the test rather
than when the IDE says oh you did
something stupid dumbass so that was
kind of as if it's a bit frustrating the
feedback cycle on groovy is a little bit
slower and so I would quite like I quite
like my touch safety
having said that the dynamic language is
it's kind of nice for testing quite a
lot of the time because especially for
things like mocks you often don't really
care what type it is you don't really
care what gets called as arguments you
just want it to just function until you
tell it to behave differently and groovy
is very very good for that so to get
back to the sort of three questions that
were in my abstract how can we as
developers write tests not how can we
how can we write more tests how can you
get excited about writing tests and or
how can we encourage our team to write
tests personally I am a big fan of pair
programming I haven't done it since up
Lmax sad about that pairing keeps you
really honest because even when you
would normally not write a test when
your partner doesn't write tests then
you're like I think you should write a
test for this and then they say you
should write the test for it because
we're pairing okay I'll do that
so pairing is really good at kind of
keeping you honest about writing tests
but failing that you should be doing
some sort of code reviews or code
demonstrations or presumably you should
be sharing with the rest of your team
what you have achieved code wise and at
that point it's a good time to ask the
question where are your tests what do
they do and I found that with code
reviews I find it difficult to read code
and grok it straight away but if there's
tests there I can figure out what the
developer thought they were trying to do
with this code and then I can have a
look through the code so it was a lot
easier for me to sort of say where are
your tests and where are the failure
case
is for these tests make it as simple as
possible to write tests so in our case
we found Spock and groovy made it a lot
easier for us to write tests so for
example we recreate a lot of maps in
groovy map syntax makes that much easier
we they're given when and then syntax
forces us to think about what it is
we're really testing rather than just
kind of throwing together some stuff and
making sure it doesn't error and so yeah
that just made it a lot simpler for us
to write tests we found it was me
personally maybe I'm not sure about the
others I found it more fun to write
tests in groovy and Spock it was just
kind of its kind of prettier and I like
Java don't get me wrong and I'm not
jumping ship to groovy but I liked
writing the tests in Spock I thought it
was it's just kind of fun to write them
in that way yes and if you understand
why you're writing the test that's also
a better motivator so this kind of we
write tests to check that your code does
what you thought it does is not a great
motivator because we think our codes
fine we wrote it we probably manually
tested it and it's alright so it's very
little motivation to write a test to
check that but when you think about the
fact the purpose of the test is
something like documentation reliability
maintainability so that I can go back
and refactor this stuff later when I
want to then you're a bit more motivated
to write the tests how can we write
readable tests the astute amongst you
might notice I swapped B and C from the
abstract but the rest of you don't care
so that's fine my OCD is going crazy I
was like I want to swap these around but
I said it was going to be different in
the abstract so writing mutable tests
for us we found that spot from groovy
made our test more writable because
right a lot more readable because it
takes away a lot of the boilerplate of
java which i've previously hentry cared
about but it's not just about you just
have to use a new language for this
there's a library called Gwen which was
created by and the guys at Shazam and
that's a that allows you to do given
when and then inside a J unit test so
that's cool I can kind of force you to
to create these more readable tests and
you can cry
and ESL's so we had a dsl at Lmax it was
a java-based DSL and we used that for
our acceptance tests so our acceptance
tests would read something like user
login with this username and password
and the DSL would tell you what you can
do with various things like obviously I
can place orders I can I don't know look
up my order history and we did that with
a DSL and that can just make things more
readable and separating out what's under
test what are the expectations what set
up all of that just makes things more
readable and there's more than one way
of doing this and I think that I'm
hoping that jay is going to cover a
bunch of this and his talk afterwards as
well um so readable test is one thing I
can write a readable test that's kind of
useless I can write a readable test for
a ghetto if you want to I'm not going to
go into why testing getters is stupid
and so what we really want is meaningful
tests tests but tell people what the
behavior their system is supposed to be
and also fail for the right reasons and
pass for the right reasons and this is
kind of the difficult thing because this
is going to require thinking which is
tough I find the given when and then
structure is a really good way to make
more meaningful tests I mean there are
there are other things as well when we
did the data-driven testing it wasn't
just given one and then but this kind of
forces you to think about what's
actually under test what am I really
trying to achieve and how much setup do
I need to do in order to do this this is
kind of mental maybe I should turn this
into a unit test so that I can mock or
stub various behaviors so yeah so again
a library like Gwen which is the other
given one then thing or a DSL might also
help you write more meaningful tests
code review is a really really good
place to catch whether the tests mean
anything or not because when someone
goes I don't really understand what
you're trying to achieve with this test
then you've probably not written a
readable meaningful test yes
so again and understanding understanding
the reasoning than why we write tests is
a good way to motivate us to write
meaningful tests so not just to check
that our code works and there
is because of course it does but to
allow us to refactor later to allow us
to not be pestered by new members when
they join the team because we can point
them to the test and they can understand
the behavior to document the system so
one of my Jobs was to go on Stack
Overflow and answer questions about how
to use the Java driver and my ideal was
to be able to say to them here's a test
for houses - how to insert into MongoDB
and all the stuff that you want to know
is in that test so taking the burden off
me as a support person in conclusion you
want to make it as easy as possible to
write readable meaningful tests you want
to automate everything I haven't even
mentioned running these tests in CI
because if you're not running unit tests
and your continuous integration
environment well I was going to say
you're doing it wrong but you've got a
really quick win right there okay you
should be running these tests every
single time you check in and you should
be running if you are going to do branch
type development you should be running
them on the branches - so we had it in
Jenkins and we had things on Travis so
that when people submitted pull requests
Travis said everything's broken we can
just say no we're not going to accept
your pull request so similarly zero
tolerance for failures when things go
wrong get on that straightaway it's not
acceptable to say oh I'm working on a
new feature I can't fix the thing I
broke in the last feature because you
haven't finished the last feature yet
until everything goes green so drop
everything and work on those failures
because you're blocking everyone else no
one should be committing to Jenkins if
it's red because then you don't know if
you're just compounding the problem with
more errors later on it helps to have a
champion he doesn't have to be a tester
or a BA or it can just be a developer
who's as OCD as me or it can just be
someone who thinks that we could be
doing better and it doesn't have to be a
senior person I'm not team leader on
this I'm just I'm just another developer
who just wants things to be better so
have a champion and preferably obviously
give them permission to nag people and
tell them that this is not the head not
acceptable and we should be doing things
this way one of the things I had to
learn as the OCD champion was there are
some things you are not going to
it's really some things that the team is
not going to buy and and that's okay
just let it go I'm gonna be singing that
all day now um just just let it go I
wanted I want a spot to be just for unit
tests and the team used some functional
integration tests that's fine that's
good they're writing tests so let go of
your ID love Spock is for unit tests I
really wanted us to write acceptance
tests end-to-end test that exercise the
API and describe to our users the
behavior of the system and we never
really got that far because I never
could articulate exactly what I wanted
from those tests so I know how to let
that go pairing and code reviews are
kind of vital don't just let any old
person just check in any old code and
say yeah it works because I tested it
manually you need that kind of sanity
check to make sure that you are you know
keep people honest with writing tests
and writing unhappy and happy path tests
and you know and think about the
purposes of testing so I've named some
of the things that I find useful about
testing reliability quality
maintainability and those are just the
ones that I thought of on the plane on
the way over there's probably like
35,000 different reasons to test and for
your team it might be different to what
they are from my team
but it just takes five minutes to sit
down and think what value can we get out
of tests other than the code does what
it's supposed to do so I have some
resources not not for this test but if
you are more not for this talk but if
you are interested in Spock and groovy
and Java for testing and I've got
another talk about that but also links
to some more information about Spock and
some blog posts and stuff like that so
yes if that interests you that's all
there the slides will be available
online so if you don't get chance to
photo that then tough and yes
so we have no time for questions sorry
but I am going across the across the
road across the thing over there to the
left
there's a was it called the power lounge
and I'm going to be there for a meet and
greet with Pearson so you can come over
and chat to me ask me questions I'm
going to be on the JetBrains booth which
is just out there for the rest of the
day so come and grab me if you have any
questions whatsoever thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>