<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2014 • Idioms for Building Distributed Fault-tolerant Applications with Elixir • José Valim | Coder Coacher - Coaching Coders</title><meta content="GOTO 2014 • Idioms for Building Distributed Fault-tolerant Applications with Elixir • José Valim - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2014 • Idioms for Building Distributed Fault-tolerant Applications with Elixir • José Valim</b></h2><h5 class="post__date">2015-01-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/B4rOG9Bc65Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so thank you for coming to this talk
about elixir just to start to give an
idea what the talk is about so this
talks not about recipes for building
distributed and fault tolerant
applications it's more of a talk how
Alex here when you write software in
elixir and also our link how you
approach it from a different mechanism
and you need to designer software in a
way that you get things like concurrency
distribution and fault tolerance as a
consequence of your software design so
it's basically the idiom also having the
language that allows you to get those
things as a consequence and we are going
to break this talk into three main parts
the first one is a very quick
introduction how elixir came to be the
second one are about the idioms and how
they are going to affect you the
developer and the third part is what
elixir specifically is because al akir
is a programming language that runs on
the early in virtual machine and else
the only virtual machine as the JVM has
many languages that run in this virtual
machine so what elixir is bringing to
the table in this from this perspective
ok and then if we have time we can do a
little bit of live coding questions and
so on so let's get started so to talk
about how a lecture came to be a little
bit of the history we need to go a
little bit back in time I'm also in the
rails core team the rails web framework
and quite some time ago at this point
2007 2008 we had a rails 2.2 releases
and one of the big things in this
release was that rails is finally thread
safe okay and the whole idea of being
thread safe is the rails core team knew
that concurrency was becoming more and
more important right so what they wanted
is that
you should get her a rails application
deploy it in a machine and if this
machine has eight cores
it should be able to use all the cores
okay but the interesting thing about the
word thread saves that it's not it does
not it's not about using all the eight
cores efficiently it's about using all
the eight cores in a way that it's not
going to crash right like you can get
your code running with cores and it's
going to work right it's not going to
crash and so we had this in the release
notes and later I joined the rails core
team and I kind of found out that this
was a lie ray it was not really thread
safe because it's hard right how do you
say that something is thread safe you
have a lot of heisenberg's you try to
debug and then the bugs not there
anymore but when it's in production it
shows up and because of many reasons
right it was a very frustrating work to
do it was hard to debug it was hard to
think of good solutions because the
abstractions that we have here they you
know when most imperative
object-oriented languages they're not
good to solve those concurrency problems
and so you know I was so 8 I stop and
start to think to myself if concurrency
is becoming more and more important
right or we're starting to have more and
more CPUs I need to find a good solution
and I knew that there was a category
there is a category of programming
languages that solve this problem really
really well I didn't said okay I want to
investigate I want to go deeper and then
I started writing software functional
programming languages study them explore
them and they really make concurrency
easier ok and there are many reasons for
that and I think actually the following
talk to this one is about immutability
it's going to cover some important
aspects right but I just want to focus
on two right now which is first
inclusion of programming language we
typically have the state explicit right
so we are talking about object
orientation we have like objects to wrap
around a state and many of the
concurrency issues
they come exactly for example you have
two treads or running different cars for
exemple they try to change the same
place in memory alright so you get a
segmentation fault things that corrupted
things not go as spectator like as
expected because two things are trying
to go to that same place okay so and
it's hard to figure this stuff out
because this states hidden inside those
objects right but if we start to treat
the state more split utley it's easier
to see you see oh here's where I have a
state and I can see that two things are
possibly trying to change here at the
same time it gets much easier to reason
about so that's one step right but the
most important step is that we even try
to metate things as little as possible
so instead of going if I have an array
try to mutate that array in memory by
adding an element I don't do that
I think of transformations I have an
array and then if I want to add an
element to that I get a new array and
then we start to work with data
structures that are very good to work
towards transformation
instead of mutation so this was really
interesting and when I got to this point
and had this realization said okay this
is a very good direction to go it really
felt identified exactly those solutions
because many of the problems that I was
having been working with rails as
exactly because you're not following
right those those guidelines and
eventually I continued explore the
continued learning and I found out about
Airlink
okay and I say that this is when I fell
in love okay who are from me who here is
familiar with Airlink
okay good so Airlink is a language
created by Ericsson and Erickson's the
telecommunication company Airlink at
this point is almost 30 years old okay
and the the what makes learning really
interesting is that when they designed
language as a telic telecommunication
company they had a very specific set of
use case in mind and requirements so
imagine that they are Ericsson right
you need to build a telephone switch
right telephone switch needs to be able
to connect person a to person B so they
can have a conversation but you want a
telephone switch to be able to handle as
many connections at the same time right
want to restore telephone switch
somewhere and a lot of people are going
to talk to their friends so they are
family all going through the same switch
so I start to have this idea of being
able to handle right many connections
concurrently everything at the same time
and you also need to have with
telephones which need to have this idea
of distribution because sometimes you
want to call your friend but your friend
is already talking to someone else
someone else through another switch so
the switch is they need to be able to
exchange information and tell you know
you cannot talk that person it's busy
right now so they also have this idea it
should be very easy for the switches to
communicate to each other and have this
idea of distributed set up of switches
exchanging information okay and they
have a bunch of other interesting ones
my favorite is the one I like to to joke
about is that we don't receive phone
calls right from our operators or phone
operators saying hey we are going to be
maintenance mode from midnight until
1:00 a.m. so please don't use your phone
right we don't receive those kind of
warnings so they came up with the whole
idea of how can you upgrade your code in
production without bringing the system
now and we are going to explore a couple
other consequences that you have when
your beauties of order an inverter
machine okay but the thing is that they
build this great virtual machine and it
was used mostly for telecommunication
for a long period of time and it was
just about 2003 2004 that people realize
that this use case is very similar to
this use case right anything that's
really running the network so you have a
server and it can be it can be a server
that is doing video streaming have a lot
of clients connected that and you need
to send them the data and sometimes you
need to contact internal endpoints to
get information or web applications even
more now that we are going
towards the internet of things right you
have mo to a lot of different devices
talking different protocols you need to
be able to handle a lot of them at the
same time okay so you know people start
always so if it was good for
telecommunication it's probably very
good for this use case - and they're
right okay so we have companies like
Amazon Facebook that use the early
inverter machine in the infrastructure
telecommunication companies like Eric's
and the Motorola Creston
yeah cress is not here but I think it's
about 40% of the 3G data in Europe goes
through our link switches right earning
machines so that's really interesting
and we also have startups like Heroku so
if you ever deployed an application to
Heroku you use Erlang because they use
earning in their routing layer and we
have even databases like crier the bunch
of folks they are here can talk to them
about it that is implemented in Erlang
and so we have a bunch of people using
it in production and one of the very
interesting of them it's whatsapp they
got acquired at the beginning of this
year by by Facebook by 19 billions or
something and throughout their history
as a company they were they always gave
talks how they are using air laying the
infrastructure and how they are able to
leverage Erlang as part of the
infrastructure and they rolled one of
those was like how they got two million
connections on a single node so whatsapp
is an application that you see on your
phone and you can you know you can
install on iPhone Android Windows Nokia
whatever and you can you know exchange
talk with your friends create groups and
so on so it's a messaging app so they
were talking about the infrastructure
and here the interesting thing is that
they were using a really powerful
machine right they this machine had 24
cores 96 gigabytes of RAM they're not
using it just 40% of the machine
resources was being used but it's
exactly the idea that we want right I
want to build a software it's going to
run on my machine is going to use all
the four cars on this machine right here
but when we put into production it's
going to be able to use those 24 cores
in the machine production as efficiently
as possible okay and they have talks or
they say they got to some point up to
three million connections on single
machines and one of the things that if
you read the the announcement are the
the news when they were acquired by
Facebook one of the thing that everyone
remarked is how their engineering team
was actually quite small to handle all
the law that they they handle it and
still handled inside Facebook so you
know so this is all very interesting
okay and so and this is the
interrogatory part of the talk okay so
now you're wondering okay so how those
companies are able to leverage airline
to write those kind of applications
efficient applications that are
distributed run very well concurrently
so we are going to the part of idioms
right so what are the idioms what the
language requires from you and how
should you design software and to talk
about this we are going to go now into
Alex here okay
so Alex Syria is a programming language
that runs on the same virtual machine of
earnings so everything I said so far
apply so Alex sir okay and if you go to
the website you're going to see that
elixir is a functional programming
language but I don't like to stay with
this description because alex is more
than that right it's a concurrent
programming language and not only that
it's a distributed programming language
and this is very important because this
is actually one of the reasons I fell in
love with the early inverter machine is
because to me they are kind of solving
the big problem okay they are like
handling the big elephant in the room
because if we go back 30 years ago when
we were designing the diverter machine
they are not worried about concurrency
nobody was worried about concurrency in
the eighties okay maybe some academics
but the industry in general there or not
and what they wanted to do was actually
to build distributed software but when
concurrency became more
more important what they realized that
concurrency is a special case of
distribution right because when you have
distribution you have what you have your
code running in two different machines
at the same time but when you have
concurrency just a special case where
everything happens to be running the
same machine right they're not over the
network and then they whoa we can do
concurrency really well too right
so how can we leverage all that so here
if you are programming a majority of
languages imperative object-oriented
this is your code right you write a
bunch of sequential code that's going to
execute instructions and the thing
that's hard about trans is that we we
need to think about threads as
interleaving of the sequential code
right you have the sequential code I
mean you need to think how are going to
interleave her going to put the locks
all think in terms of this sequential
code and in a lecture we also have
sequential code okay but this sequential
code is organized in very tiny things
that we call processes okay and those
processes they're not operating system
processes they are virtual machine
processes and they are lightweight
thread of executions okay
so here's so if you are talking about
idioms this very important we just
learned a new word you just added a new
word to our vocabulary which is process
okay so those process they are very tiny
very lightweight which means that we can
have many of them okay so when at the
moment you you know start your elixir
node you are you want to go to the to
the shell right to type some commands or
it have like 50 processes running okay
and all those processes they are
isolated from each other and the
isolation gives us very interesting
properties you're going to see next so
you know in the whatsapp case when they
are saying they had two million
connections each connection was one
process okay so they actually had two
million process more than 2 million
processes running at the same time that
case that's how lightweight they are you
should not be concerned about creating
hundreds thousands of them okay so we
create all those processes they are
related and because there are isolated
we can have all of them running at the
same time so we start to get this idea
of concurrency right because if they
need something to do they just do
whatever they need to do they are all
running at the same time and every time
you need to exchange information or do
some kind of coordination you do it by
sending messages right so if I want to
tell one process that it needs to do
something particular or it's waiting for
some particular input I just send it a
message okay so you know we are talking
about processes is our new word we are
talking about message passing and to
learn more let's you know let's zoom in
let's speak like four processes and try
to see what they are doing okay and
let's imagine that this is a server
right it's doing something over the
network
so those four processes that I chose we
can imagine that one is responsible for
communicating with the database another
one is responsible for accepting
requests over TCP so responsible for the
network web part we have any statistic
process that is just keeping live
statistics about who is using your
application who is connected and so on
and we have a mailer process okay that
is responsible to send an email every
time we need to do something in
particular so here's the interesting
thing if you're using classical language
is write imperative a budget oriented
you have a request and then you want to
send an email during that request what
could actually happen that at the moment
you are sending the mail if something
goes wrong while sending the email the
web the thing that's responsible for
accept requests can actually crash and
actually fail right so if we start to
think about it's really weird you know
like why the thing that sends me oh if
that scene crashes how can it bring the
fee Nets accepting requests down right
so what we need to do in those language
is that we need to use try catch write
need to so if you go to your web server
implementation in your language or the
framework whatever they wrap your cold
in a huge try-catch begin rescue and
things like that why because if
something goes wrong with the mailer you
just know don't allow it to leak
allow it to to go through and bring
everything now and you know this whole
idea we like to say oh it should rescue
an exception or catch an exception this
whole idea is weird right because an
exception is the way of our software to
say something went wrong right something
suppose the exception will happen and
I'll just saying thank you just continue
doing whatever you're doing right so
it's a very weird idea when you start to
put state with it all so basically what
could happen is that you have your code
running it goes into inconsistent state
and then it start raising exceptions and
exceptions and so on and you're just
telling it to continue doing whatever
it's doing so in here because everything
is isolated right a crash in the mailer
cannot bring any of those other things
now and that's a very important property
because it changes the way you write
software what we like to say is that you
know if something is wrong in the Manor
just let it crash I am told to not use
the let it crash expression because
sometimes it scares people alright so we
also say fail fast ok if stuff is not
good with the mailer fail fast and what
is going to happen is that we define
supervisor's okay so this is a new kind
of process it's a it's a process that
has a very specific responsibility of
supervising other processes so each one
of each process in different colors here
they are going to belong to different
supervisors so what happens is that if
the mail if something is wrong with the
mailer and it crashes this Manor you
know this process is going to die and
then the supervisor is going to notice
that the mailer crashed and is going to
start a new Manor to handle the next
upcoming requests okay so and this is
very important because it starts start
to take us this idea of building fault
tolerant applications because the thing
is it doesn't matter what you do it
doesn't matter well whatever language
you choose things are going to go wrong
right unexpected things are going to
happen even more when you include
network file system a kind of third
party resources okay so you know instead
of trying to be defensive and foresee
all the possible cases which we can't we
should plan for crashes right instead of
saying you know I'm going to handle
possible case just let it crash and come
up with a strategy for your system to
self-heal to go back to a state that's
guaranteed to work and that's why we
have this whole idea of supervisors
because if surfing crashes we start
something new with the initial state
that you know that it works is the same
is the same of our machines right
sometimes you're coding and then our
machine starts to get you know not
respond quite well it's not working
quite well what do we do we restart it
right we go back to the initial state
and then suddenly it's good again all
right it's the same idea let's go back
to that initial state so so if are
speaking about words right and the new
words or vocabulary and idioms we are
talking about processes supervisors and
sometime the supervisors they have
supervisors - that may have a supervisor
- so we start to create those
supervision trees right and at one point
your application is ready you define the
supervision tree with the responsibility
and what should be restarted and we
package although all of these inside an
application and an application is it's
kind of a component right it's something
that you can start and stop as a unit so
that's how we design software and
everyone writing elixir code is how
you're going to structure and design
your software okay so so what we have
talked about so far I talked about
processes which are isolated okay and we
also have supervisors which are
processes that has a very specific
responsibility of supervising other
processes and they have strategies on
how they should react when something
does not go as expected and they are
constantly putting our system back into
this nonlinear state that's guaranteed
to work and then we define supervision
trees okay and we package them inside
applications
and every time we need to do
communication we always do it with
message-passing and we got many features
from you try to that's kind of God for
free from this design right so we got
concurrency concurrency does not come as
an afterthought right it's not like you
write a sauce and then you need all I
need to make it concurrent and then I'm
like now I'm making my code all ugly and
messy just because they need to add
concurrency right it's walking in elixir
right it's walking along with your
design it's a consequence of our design
so we are now getting concurrency we are
now talking about failing fast okay it's
a different approach when we are
designed the software we got fault
tolerance because we now have the
supervisors with their strategies and
there is one thing which is actually the
title of the talk but we haven't talked
so far which is distributed okay we got
all the things but how do we get
distribution out of all of this so if we
go back a couple slides right we said
that you know this is this is your
elixir software okay running production
so have a bunch of processes exchange
messages and for some reason like part
of application starts to have a
increasing the load right like you can
have a a statistic server for example
for some reason it starts to have an
increase it load so what you can do is
that you can get our code right and we
have something called the release
process where you can create different
releases with different responsibilities
so you can get part of your code right
and just say you know I want to run this
particular code in a different machine
right so you just split putting two
machines and everything is going to work
we just need to update the reference to
say to who you want to send a message
because since the processes they all
they all communicate with message
passing the virtual machine actually
abstracts the message passing for you so
it doesn't matter if you are sending a
message to this processing to this
process in this machine or a process in
another machine it's all obstructed and
handle for you and we are going to see
some some examples away
I'll do a little bit of live coding and
send messages between nodes so we can
have a quick overview so questions so
far before we go into the third part
okay so okay so this is all interesting
right and as I said this is all
properties of how the the virtual
machine was designed so this not only
applies to alex theory but Erlang jaques
everything that's running in that
virtual machine so why Alex here okay
why would I use Alex here and we have
and the best way to tell why you should
go with alex here when you're coming to
this particular virtual machine and when
you want to think about this particular
kind of design of software the best way
to talk about it is to talk about our
three goals in the language okay and
they are compatibility extensibility and
productivity so compatibility is the
easy one right it's just everything I
talked so far right it comes from the
virtual machine and we are compatible
and all the abstractions they are the
same whether if you're running malloc
Siri or if we're running our link so for
example a list in Erlang is a list in
Alex here a process in Alex here is also
a process in our link there is no
conversion cost nor anything so
compatibility is about you know
respecting this foundation of being
distributed and fault tolerant right and
you're not going to sacrifice that
that's what this goal is is saying the
second one is accessibility and the best
way I like to describe is this bit is
with this code quote from guys - it's
one of my favorite talks of all times
called growing a language and at the end
of the talk he says now we need to go
matter we should now think of a language
design as being a pattern for language
designs a tool for making more tools of
the same kind because the field of
computer science it got so wide that it
is impossible for a language - you know
natively
attack all those possible fields right
so what we need to do is we need to
design a language that you as a
developer you can go and extend it and
take it to the domain you're working on
so you can really be productive and the
way we do that with Aleks theory is that
we have a macro system that's very
similar to how macros working Lisp so
here is some electric code so in Aleks
you in in many programming languages
have if and unless right they are kind
of meddling with their keywords they are
something special that the language
knows how to handle how to compile to
and in Aleks here those things they are
just macros they are implemented with a
lecture itself which basically means
that if we are using alex here to
implement the majority of the features
in the language it means that you you
can also get alex here and take it to
the domain you're working on
right we are not cheating there are no
special cases all of those are in the
core of the language so what is the idea
of a macro a macro for example analyze
is a macro it does not receive the
evaluation of is number x right it's not
going to evaluate if X is a number and
return true or false a macro is going to
receive the representation of this code
right so a macro is going to receive the
code representation and then it can
transform this code to be something else
since unless is the opposite of a if
isn't negated if that's exactly what we
translated to right we basically get on
the last and transformator and get
negated if so in which this we can
extend language and implement most of
the language using a lecture itself so
some examples of what you can do with it
right so here's how you would write a
test case with Alex here so we define a
module called math test and all your
code the next series leaves inside
modules and you can say you know I want
to use the X unit case which is the name
of our test framework and now you get
these macros that allow you to express
very elegantly what you're testing right
so here's testing a very basic operation
and you're you're just asserting that
one plus one is equal to and the
interesting thing is depending on
language you're using you're kind of
saying no no don't do that right because
depending on the test framework you use
you should never call cert because if
something goes wrong a search is going
to say hey expected true we'll got false
you need to use things like assert equal
assert more than a certain match you
need to go into this specific API of
unit testing but in Aleks you just use
assert for everything because assert is
a macro and as a macro it can look at
the code and say I can see here that
they're trying to compare two numbers
okay and when something goes wrong it's
going to give you a very nice oral
report what are trying to do what is the
left side what is the right side and why
it failed because we can look at the
code at compilation time and get
information about it translate it to
other things so this one example the
other example is we have a library
called ecto which allows you to write
queries to run in a sequel database so
elixir is a dynamic language okay but
act oh it's actually a typesafe okay so
if here the author is a string but if
you try to pass try to compare altar
with a integer for example the car would
say you know those things do not
actually match right and we got a lot of
inspiration from link from dotnet and
link is the language integrated query
right it's part of the language but here
is implemented just using the language
features just using macros and we can
and we can do a lot of we can extend the
language for example to I'd tap to add
type checking we can ensure it seekers
are not going to inject something that
can lead to a sequel injection and it's
also also extremely efficient because in
many cases we can compile most of the
query to sequel during compilation time
all right so you're not doing a lot of
work at runtime we just reduce the work
we do at runtime is as little as
possible okay so those are all examples
and we can see many examples in the
community right of people getting Alex
here and extending to all those domains
and
the third goal is productivity and
productivity is kind of hard right - to
explain how do you say that a language
is more productive than another and so
the way we like to describe productivity
in Aleks here is you know about tooling
for example or having first-class
documentation because sometimes being
productive it's not always a language
issue is a community issue right how can
you get the community - all together
right very good tools right with good
api's and good documentation okay so
there is a focus on the commendation I
can show a little bit we have very good
tooling out of the box so as soon as you
install the language you're going to get
a good test unit framework you're going
to get a shell to start writing code and
we have this mix build tool I'm also
going to show and lately we got a
package manager - so if you start
working with Alex Siri and someone
already solved the problem that you want
to work on you just add one line to your
file and you're going to fetch the
dependency compile and have it available
for you so if you want to use that
active code that compiles to sequel you
can just edit the dependency and go work
on your problem okay so to show the
things let's actually do a very quicky
quick demo time so what I'm going to do
here is as I said when you when you
install Alex here you get wait that's
not what you're supposed to see
yes so when you install exterior you
come with it comes with this bill -
called mix that allows you to create new
project handle your dependencies compile
them test them and so on so what I'm
going to do here is that I'm going to
create a new project called foo and one
option that you can pass when you're
create a new project is the sub option
which tells it to create a supervision
tree so at the beginning we say no we
have the supervision trees that are
inside applications and I'm passing this
flag just so we can get some time it's
going to generate a supervision tree for
us so we run this we run this command it
create the code for us and then we can
just run something like mix test and
it's going to compile and run everything
for us one of the advantages of the
airline virtual machine is a very fast
boot time so that's always nice and ok
so let's take a quick look at the code
that it generated so you can see the
project is really really small it comes
with a config directory so we everyone
is saying that the the runtime comes
with this idea of applications right
it also comes the idea of how you're
going to configure applications which is
really good because all the libraries in
the language they follow the same
structure on how they are configured
right they're not going to use the
library and they it's configured this
way and another one's configured the
other way everything is kind of standard
right we have this idea of how you
define applications and configure them
and we have a Lib directory which comes
with a simple file on the test directory
so let me remove the comments so we can
focus on ok so here is so here we define
a module again our code always leave
inside modules can everyone see well in
the back so all of our code is defining
signed modules right and I'm saying this
module foo is defining an application
and what on an application needs to do
is to define a start function that
receives two arguments
and start a supervision tree so you're
saying no here we are going to define
our children and in this case we don't
have anything yet right and we define
what is the strategy so for the
supervision so a one-for-one supervisor
means that you have you can have many
children right so one for one supervise
me is that if one particular child dies
you just restart that one but you can
have for example things like one for all
if one of the child dies you you know
you queue everything else and start them
again so there are different strategies
that we can play with and just to show a
little bit how it works let's do this
let's define a worker which is a task
and a task is just when you want to
execute some particular computation like
send an email and this task we are going
to define it with a module okay sorry
we are going to define it with a module
the module that we want to call so in
this case I'm going to be a little bit
lazy and say that the task is going to
be defined the same module as my
application the function it should call
so I'm going to go with do some work and
the arguments are not going to pass any
argument in this case okay so here I
defined a supervisor that has exactly
one child that is a task so let's define
exactly this task so you have function
do some work it doesn't receive any
argument and all we're going to do here
is I'm just going to print start to do
some work and I'm going to sleep because
just simulate that we are doing some
work okay so if everything went well
what I can do now is that I can start my
application and start it with a shell
and you can see that it created right it
started to do some work and because we
started the application which started
the supervision tree which started the
task that's starting to do those
computations and what I can do here is
that our supervisor it had a name if we
go back to the file can say that we gave
it a name of food supervisor this is
just an identifier it can be whatever
you want and I can I can ask you know
give me all the children for the food
supervisor right and then it returns
this information saying
well what is the the module which is a
task this PID is this process identifier
right it's just identifying the process
in case we want to send it messages and
so on and it's the type of a worker and
the the fourth argument we use it in
case of cold reloading I'm not going to
go in details if you want to know more
we can ask later in the questions part
or discuss later so I'm going to do is
that I'm interested in this PID okay so
I'm going to pattern match on it I just
want the PID I don't care about the rest
right so I'm going to match all those
things and get the PID out and what I
can do is that I'm going to send an exit
signal to this process saying that I
want to kill it and what happens here is
that it just printed start to do some
work again because I killed that process
and killing that process is a way that I
am a milady fader right you manage that
that process was doing something and
then it crashed something went wrong and
then the supervisor saw that process
crashed and say okay I'm starting a new
one and you can see that it started to
do some work again and the thing here is
is that you know if that process was
sending an email right and something
went wrong that email you know by
default if you don't add some kind of
persistence it's gone right but the idea
is that you know your system always
going back to that initial state and
building on top of persistence layer for
example to guarantee that the emails are
always delivered is actually
straightforward we have a couple
libraries in our ecosystem that do that
but the important is all this idea of
the supervisor restarting and going back
to that initial state that's guaranteed
to work Joe Armstrong the creator of air
link right to say that they have systems
at Ericsson that runs with nine nines of
reliability which is I think is a second
or microseconds being offline per year
right which is quite fantastic yes we
have time so let me show something else
that's really really cool what I'm going
to do now is that I'm going to start a
shell right
the interactive shell interactive Alex
here and I'm going to give it a short
name and when we give a shell a name in
this case a shark name it allows other
shells or other machines that are
running the same network to communicate
so I'm going to give this one on the
name of foo and you can see that here it
change it is showing right right now the
name of this node this foo @gv okay and
I'm going to give this one the name of
bar so if I fam in this shell here and I
define a module like I know this is a
little bit cliche but hello world that
prints hello you can see it defines the
module on this show and then I can say
hello dot Road and it's going to print
hello and return okay which is the
result of calling I output so you can
see that hello was printed here but if I
go to the other shell and type hello
Road it doesn't work right because this
module was defined just in the other
ones not available here but what I can
do is that I can very easily is spawn a
process in the other node right I just
say you know I want to spawn a process
in the node named foo @gv and oops and
what this process going to do is to just
is acute this function which calls hello
dot Road and when I run it you can see
that now it works and the interesting
thing is there are two very interesting
things here the first one is that you
can see that hello world was not printed
here again right so it's not printed
twice hello was printed here so what
happens is that we started to execute
the code in the other node but the other
node knows that these nodes they want
that triggered the the request so if you
want to do any i/o it's going to send
back right and and we use it in
production because sometimes you have a
machine that's not behaving well you can
do a remote shell you can connect to it
and send commands to it and try to get
information what is happening there
right and you can see here that the PID
in this case starts with a big number
the previous ones always started with
zero so the one starting with zero is
running in our machine and the ones that
does not start with zero they're running
on another node
it's right and I can get I could get
this PID and send a message to eat and
exchange information okay let me go to
the last slides and then we can open for
questions so if you really found Alex
very interesting this is our website and
you can go to our getting started guide
right now we have two main guides one is
literally getting started is going to
introduce you to the data types how you
do i oh how you work with collections
and so on and we have an advanced guide
which builds an actual application using
those principles we kind of talked about
here and it's a distributed key-value
store okay a very small tubular value
store where you have you can have keys
being stored in different nodes and so
on oh and if you are interested in
seeing some actual use cases of people
use the an extreme production so we just
released elixir 1.0 kind of like three
weeks ago and two months ago we had our
first elixir conference in Austin and we
have a bunch of interesting talks
interesting conversations of people
using elixir for gaming applications
telecommunication services there was
someone talking about having a Bitcoin
exchange server all built with Alex here
and so you can go to the to the to
elixir call from conflicts and watch
some videos one of my favorite talks is
a developer working at a game company
and they build a poker game right and
the field and the poker game lasts on
average their twenty minutes which means
it's really really hard for you to stop
the system to upgrade it right because
when one game is in the middle another
one is the starting another one is
finishing so you don't have really a
good time like for downtime right and
people play the whole day the whole
night so it gets tricky and he was in
his talk he was saying how they were
using all these distributed aspects of
for running for doing a hot coding
upgrade right so they could be great
their software live by using the
distribution and then he he goes into
how did he design the whole application
so in their case each poker table is a
process each player is a process and
they are exchanged information of the
poker table
and when you're upgrading our code live
they basically move the poker table to
another node but still have the players
here so they have kind of a mixed set
setup I really recommend it's really
interesting and we have plenty of books
if you go to the website here are some
of of them and I think at this point
they were already updated to Alex here
1.0 and so we have plenty resources if
you you know if you start with a getting
started guide and say oh I want
something deeper right there are
different options you could choose from
we have screencasts being published and
that's it I want to thank my company
that allows me to work at this point I'm
working full time and at expiry for a
year and a half and really painful
because allow me to take the language to
where we are today that's it thank you
have time for questions awesome what
would happen today it is just gone right
so so the question is what's going to
happen to the the faulty process when
when the supervisor acts right so if you
have something like a I'm going to use
one for always strategy as an example so
something crashes right and the other
ones they because of the supervision
strategy it since you're going to kill
the other one and we're starting restart
everything again you just kills them
right it's just you know whatever
they're doing is way to be interrupts
it's going to cut and they're gone
and the interesting thing is so I I was
saying about just to have an idea how
this impact impacts also the design of
the virtual machine and the language the
interesting thing is that because
they're isolated we don't have for
example stop the world garbage
collection right because the process is
not really sure memory and this is
really good because if something is
wrong and a faulting process you know
dies the garbage collector just you know
goes and okay I got the memory back you
don't need to do any check and it's
really good for also the cases of
whatsapp right you have a connection per
process when that connection is gone
because the clients connected or because
you want to disconnect you just reclaim
it there is you're not going to have a
garbage collector going through all the
two million connections at the same time
to see if there's something shared and
so on
did I answer the question if please ask
more
this is something like later and look at
one of those for one and see what was
wrong with it so that's a very question
what about the bugging right and
something goes wrong what I'm going to
do is so so I'm going to answer two
different things so the first thing is
that we don't have traditional debuggers
here because if you have a lot of
processes running at the same time right
and you say I want to see what is
happening there when that process you
say stop do a breakpoint to see what is
happening there everything else the
whole road continues running right now
nobody is going to stop for that
particular process so if you set a
breakpoint in there you can have other
process that we're waiting for a message
from this one right and then they are
going to get a timeout because they
don't get a reply so we don't have a
typical debugging system because at the
point you are going to type what we
really want to see your system state
change it completely and then we are
going to be debugging something you
don't think it is there so how do we
work around that right the fact that we
cannot use traditional debugger so very
good tracing tools you can basically
trace any event that is happening in the
virtual machine a process started a
process crash hood I want to call this
function I want to see if this function
is being called by this process with
this particular argument so that's one
thing and it would come we ship with a
very useful logging framework and by
default all processes they are going to
to log I I crash the last message I
received was this this was my particular
state and this distracts the stack trace
so we prove with those tools and and I
think that the the whole language came
from you know from industrial setup
right so they had to figure this stuff
out how to have a good login
understanding of the system so
break points and I would affect
something and write some expressions I
once asked means that needs to be
changed my first foot before you changed
my forgive that deployed but you
mentioned also that while the
applications how would I if I need to
change these logging statements ok so
the question one is about the hot code
loading and how we're doing production
so typically what it would do is that
one machine is faulty right and you
don't want to bring it down for some
reason you're going to log into this
machine you're probably going to start
to do some tracing and try to see what
is wrong if the logs are not good you
could start with some tracing to see why
the logs are not good at exactly this
happening there and when you pinpoint if
if you want you can you know get the you
go to to the tag in your source code
right that had a particular version
deployed you can change that module
compile it and tell the virtual machine
to load this new version of the module
ok so this is the that's a very simple
idea of how it work I don't think I have
like time to show exactly how to do the
set up to show how it would work but we
I said like a couple of times going to
talk that all your code leaves inside
modules right and you cannot have code
outside of a module and there is is
because we use the module as the main
the main you know container for code
because you also use it for upgrading
the coding production so you can see
here that when we define the module
right it returns a tuple saying oh this
is module this the name of the module
and you can see this whole thing with
bunch of gibberish here this is a binary
with the module bytecode okay so for
example what I could do is that I could
actually I'm see if I can do that
so yeah it may not work so don't hold me
to it so still
hello dot roads not
define it here right so what I'm going
to do is that so if I get v1 is going to
give me the contents of the first
expression which was that module being
defined so if I type v1 it gives me what
it was the value defined here right so
we can see that we have the module the
name and the binary and I'm interested
in the binary so I want to pattern match
on it just to get this binary okay and
this isn't going to match them if you
want so now I have the binary here so
I'm going to do is that I'm going to do
an RPC call to the node bar at JV dammit
what are the arguments
it's called load binary and I need to
pass the module name the file it was
defined and the binary let's see if this
works
oh it worked so now if I go to the other
node hello road is here right so I
started to sweat so this is for example
how you you would do right there's a
little bit more of more detail to that
but that's basically the idea it can get
the byte code and since the virtual
machine let's say hey now what the
return machine has that it has two
versions of the same module it can have
two verse in the same module memory so
you have the old one and the new one you
just sent and you can say to some
existing code say I wanted to upgrade to
the new version right so this kind of
how you can do a live patch in a
production system oh we're out of time
please
ping me and thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>