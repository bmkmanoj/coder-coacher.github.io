<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Using Modern C++ In Anger • Todd Montgomery | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Using Modern C++ In Anger • Todd Montgomery - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Using Modern C++ In Anger • Todd Montgomery</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9KljYagEPnE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we'll be talking about how bar C++
will go over what that using it a
non-trivial very latency sensitive kind
of application what what it tends to do
and it's all lessons learned so a little
bit about me my name is Bob Montgomery
cooked down during the CTO of 29 West
doing some high-performance messaging
car by informatica in 2010 probably for
the last year been doing consulting and
Aaron is actually one of those pieces of
consultant so some will go over here is
NC + possible primer of what area is a
little background about the kind of
environment that it looks like and we'll
talk about what constitutes modern
signals it's actually a term for this
I'm mother the developer Scott Meyer and
we'll talk about how it's adopted in
Aaron and lessons we learned and then
sort of what's next
so Aaron and C++ Aaron tries to provide
their really modern messaging transport
so you know think about the protocols
that we have out there that are that are
mostly used in most applications we use
things like DCP if we're in doing
Telecom we may be using things like setp
and a few other based protocols and if
we are doing something in that's more
latency sensitive we may be using a vast
array of different protocols
20ms provided you know several of them
but there's other vendors who have
provided them as well typically the MTL
you know souls with there's you know
lots of others as well and so a lot of
the things that are sort of inheriting
that those protocols and the way that
they work is that they're actually built
on most technology that at best is a
little more than
years old so modern approaches have
changed drastically in terms of you know
basically the architecture of our CPUs
how systems basically work so adopting a
little modern approach is really what
Aaron tries to do it's a very different
architecture than most other
implementations so the first thing is
you know being one who's looked at
messaging before a large number of years
most products are you know loaded with
features in the complex and it's simply
just not fast enough you know if you are
trading technologies you don't know that
you know what ok they're better than
they were but from where they could be
there's still quite a bit of aways and
it's not about just low latency it's
also not predictable latency and sorry
it's a little cut off so it's not just
that latency is low its that latency is
predictable at all percentiles
or as many as you can get and it's also
not simply about you know being
predictable and low latency when there's
hardly anything running it's also having
that system so we live in a world which
is basically multi everything multi-core
multi socket cloud and we have a vast
array of other kinds of transports that
we need to run away you know IP IPC but
we also have things like minivan already
made others that are also coming so just
ignoring those are not treating them as
first-class citizens doesn't help
right so Aaron tries to take this as an
approach so the team is myself Martin
Thompson a Richard Warburg who had
worked on this for about the last two
years look over two years from the misty
perspective messaging is fairly simple
Impala sure she have subscribers
connected they operate over some sort of
channel and within the end even have
dreams within the chain and we took the
standpoint that we didn't want to have a
new framework we didn't want to create
something like Jan that's you know 3.0
anyway so we want to make something
which was very work but elaborate
something which was very easy to
integrate and it provided the brand
abstractions that applications can be
built them and from a composable design
perspective we wanted something was
month more closer instead of two a
messaging system much more as I
mentioned a messaging transport so
unless I'm layer 4 transport from
message oriented streams it actually has
some complications we wanted to
basically have these five properties
that are a part of the outside layer 4
transport services connection or any
communication reliability local looking
for one of those messaging systems is at
best a second class concern and in most
cases congestion control and avoidance
some situations you want some you don't
so you want to basically be something
that can be turned off any idea as I
mentioned it's a everything well so you
just don't have a single publisher or a
single service subscriber you have there
any demands some publishers that are
very active some subscribers are very
active and you also want many channels
so we started airing with the idea of
Java because we wanted something that we
could iterate on and evolve very very
rapidly and so we came up originally
with a set of design principles helped
us to basically decide if we had two
different things
which one to pick right and so these are
ranking order of priority first garbage
spring steady-state running was
something that you know for Java not new
if you're doing anything with latency
but for most the Java community is not
something that is much more concerned
smart magic basically being able to do
high throughput a link to the same time
Wiggly algorithms in the message
and originally used to look at this
block tree but we decided we could you
wait for it changed it no I'm walking I
in exceptional cases apply the cigarette
principle prefer matured state avoid
unnecessary native copies these are
these different principles actually
helped us to when given a choice figure
out which one will be the best does it
basically led us to believe any choice
would fit into one of these and let us
write them this also carries over from
not just the job of it into the C++ side
work we have the ability to basically
look at different things and come up
with what would be the best way of
handling architectural II what Aaron is
doing is replicating a log from a
publisher to a set of subscribers okay
same kind of ideas Kafka and then you're
replicating the law how unhurt
Aaron is a little different and then it
really means replicating the log
replicating every single thing including
the protocol that is associated getting
that log over to the other side or the
other sides so if we look at here we
look at what something we call the log
buffer that is setting on the publisher
it needs to be a subscriber and by
extension we also have other publishers
who need to get them to other
subscribers so we need to have the
ability to go in both directions so to
do that you have to put something in the
middle you have to have some sort of
data that allows the sender to send to a
receiver and that media could be UDP and
PCIe all kinds of different technologies
so the idea of having the media be
something which is pluggable was
important to us and as I said you're
just replicating that same log buffer or
that log on the subscriber that is on
the culture but to do that you have a
lot of different housekeeping to do so
we separated that housekeeping into
something called a conductor that
conductor takes events and
administration commands and basically
does the you know the administration of
those buffers and then we can wrap this
into the different pieces or
architectural into pieces that we see
the client is what integrates with
application and driver does the nasty
job of sending things for the network
and it also has its own you know
administration and everything else it's
in this is basically the architecture
and if you look at the code we've we
also believe that you should be able to
look at the code and see names of
classes names of components that fit
into this so all the components have
these names so there may be some you
know a little bit of information that's
clarifying here such as we have client
conductor and Driver conductor but those
find themselves you know should give you
an idea of what they what their jobs are
what they do so that's basically Aaron
but how does he feels bus fit into this
admission that we did this in in Java
first and that we've entered iterative
on the design and job we've also
integrated on the design in C++ but
we've started by doing this taking the
architecture and C++ goes on the client
side and basically that's it so that
gives the ability to have a C++
application that talks the job
application or java application to talk
to C++ or C++ the talks to C++ the media
driver itself you know can be just job
basically and that's what's currently
available
the e driver itself is currently job so
the first thing is don't panic okay just
because it's Java doesn't mean it's slow
back to play fast but they do
intentionally plan to do a C++ version
of the driver effect it's in Sigma works
and it's one of our side projects so for
the moment don't be too put off by the
fact that C plug that it's not C++ all
the way your application
it's simply writing into shared memory
reading from shared memory if it's going
to C++ and if it's going IPC the driver
is just there it's an administration
tool it's creating files it's removing
them it's for orchestrating things but
it's not in the message path so again
so what constitutes modern C++ so we'll
talk about what that really means the
first thing is throughout this whole
thing I'll try not the batch okay I'll
try that C++ go try not the best Java
try not to fashion the other languages
it's gonna be hard something real hard
but I'm gonna try to do this you know
so first thing is Mauro Zucca plus it's
basically Scott - boy this is a
fantastic book that you how many of you
know this book okay if you if you use
C++ and you're thinking about using some
of the newer features and C++ 11 to get
this book it has a lot of really good
examples in a lot of you clarifications
and when you think about C++ modern C++
which means basically it's equals plus
11 and on then this is the book back
it's not a reference
it's more of a here's what this means
here's how to use it here's how to not
use it which is just as important here's
how to think about so all that is very
very good
Samarra c++ if I had to sum up what
modern C++ really means is resource
ownership in lifetime it's made a lot
more explicit if also is encapsulated
much much better this is the sort of the
family difference between basically C++
98 and previous it's C++ 11 in all the
years in between those two standards a
lot had been learned in terms of how to
basically look at object lifetime
resource ownership things like that a
lot of the best practices got wrapped up
and codified into idioms with in C++ 11
so that's the first thing the idioms
that are involved the first idiom here
is resource acquisition is
initialization our AII and this is
permeated throughout the whole library
and the language here's just a couple
a lot guard is big mechanism where when
it was accentuated it lobby it takes a
lock and when it is destructed it
releases a lock so you can put it on the
stack put wherever you please like and
wherever it's constructed it acquires a
lock and when it is destroyed it
releases it right that has a kind of a
profound look now this is not new that's
been around since actually in the early
90s if you look at some of the work that
was done by thuggish men and others you
know they were using guards for locks
and things like this for a long time but
having them as part of the library took
a long time it wasn't hard to do so much
as it was just it just took a while for
that permanent at that level wearing
that affected the language itself unique
pointer another one smart pointer and
all the ones that we'll talk about here
a minute
all these are concerned with scope so
when you have the research acquisition
is initialization you quat you create
you know a unique object when it is you
know basically comes into scope and when
it goes out of scope it's all badly
released that would be what you need
corner goes for a unique piece so
there's no sharing and it brings us to
the second part which of smart pointers
smart pointers have a large impact on
the way that you think about you know on
resource ownership on lifetime
and here's the three that make it up you
gotta you know share corner which
basically is an object which and the
reference count but it's more than that
and if you're familiar with Auto pointer
it's kind of like on a pointer and kind
of not it means that this object is
shared in somewhat there will be two at
least two you know connections to it
anything on top so the ownership what is
the ownership that's an aggregate
ownership
right it's if you have two different
owners you can only reclaim the object
of both of them go away
it's basically codifying automatic
reference counting and it's very useful
for that purpose you can move a shared
corner you can copy a shirt pointer it's
copy look like well means increment the
reference count and decrement right when
you're done with the copy things like
that so when you use something like
SharePoint it has those semantics that
doesn't very effectively in a very
efficiently accessing it is you know
very efficient sorry
unique pointer means that you're going
to have exactly one owner of this object
right so it prevents copy it prevents
you know other things ah but can be
moved right so this is could find those
practices weak pointer weak planner is
created from SharePoint so you can
create a soft mirthless effectively it's
okay to make a very general statement
it's effectively like a soft reference
in something like but it's a little
different you can use it the same way
and she would normally think about if
you're thinking okay well share it I get
it
reference counting okay you need that
makes sense if weak pointer is kind of
okay soft reference what happens if I
have something that's non-trivial like
that crack right how do i how do i how
do we manage that
well turns out that this is actually not
a bad place to be in some languages you
know are built like this automatic
reference counting for us for example in
other things it's not a bad thing to
limit your stuff in a design bank gives
you some very good ideas we'll talk a
little bit about that sort of lessons
learned but effectively we pointer is
there so you can create cyclic perhaps
I'm gonna be here for me with game
engines okay here's a question in a game
engine you may have a physics object
that physics object may also
romance me why they just sometimes
different textures may also have physics
audience don't ask me why I think just
sometimes did what you get a lot of
times in game engines is a very cyclic
graph of dependencies ok minutes are
primarily done and see how in the world
do they deal with the cycles they break
it so that when you have to actually
access something like that you do it
through some intermediary a lot of times
it's a look at things so you don't
access just a pointer you access I look
updated for example just one weak
pointer is like this weak pointer that's
there and if share pointer goes away you
try to access the weak pointer it says
can't do that economy so that technique
has influenced for example this design
I've seen firsthand and fairly complex
graphs in dependencies that are modeled
with that's quite delicate so it's not
it's not a hindrance at all C++ 11
introduced lambdas and function objects
you know these are nice they make things
very clean they also can be a little
tricky they are very powerful to use and
they just actually clean up code quite
nuts been said about bones don't really
have to talk too much about them a
Comics comic operations stuff atomic is
a is a portable library that allows you
to do some very interesting economic
things with it and here's an example
suppose you have a boolean you want to
do atomic operations on that boolean you
can just basically say it's a typical
title that's then instead of common
atomic flag is also another example that
has some more tests and sets and some
other things on it that are just more
convenient in other words there's a
specialization of still common room but
you have all kinds of different ones you
can do except ones that you really need
do sometimes so there is a hole that
we'll talk about here so that keeps
sorry about the headset here the idioms
smart pointers land does Atomics but we
also have threat support so it's very
annoying for many years they have POSIX
arounds but not have them as first-class
citizens within the language well now
they are so whatever threatening you
have underneath you have access to the
standard library heads thread index
promises futures pretty much everything
you would normally think of in a modern
kind of set it now move construction
assignment is another big part of C++ 11
the basically means is how many of you
familiar with copy constructors things
like that okay Luke instructors don't
have to copy just move what you have
from one to another each transfer of
ownership that's how it kind of comes
back to things like you know the small
pointers and everything else and idea of
ownership in lifetime has a lot to do
with move construction and assignment
we'll talk a little bit about lessons
learned from that and you know within
the C++ you know community things like
you know tool chains have always been
involved you know it just may have taken
a long time now we have some actually
very nice to use tool chains you know
see make is great it can be used on very
large projects with very good effect you
know you may not like the syntax or you
may like this context depending on you
know how it looks but it's useful good
test vocal mock and even II's that are
out there like see line from JetBrains
which I use very heavily I'm a big Emacs
guy have used Emacs for weight and it
took it took actually sea lion for me to
look at an actual ID when I used Eclipse
I actually I mean I could use it it's
just I didn't want to and so you know it
took something like sea lion which is a
lot better integrated a lot cleaner
you know for me to really jump and you
know actually stop using Emacs for most
C and C++ development so how many of you
seen it okay if you have it and you're
doing something with C or C++ just take
a look you you know you sit a couple
times it pays for itself
I'm gonna give you just other things
like auto calm it's not like that okay
first thing if you're using auto comm
don't find it in it so what I want you
to do and then letting you know for
example so how does Erin adopt these C++
modern C++ way of doing things well the
first thing is you know share pointers
you need pointers there all the way
through the actual code so here's just a
good here's just an example if you call
something like Annan and you connect
which is the idea of actually having the
object you can now add publications and
and subscriptions to you get back a
share pointer of error so the idea of
the EPI giving you back already
unwrapped item that says here's how
you're to use this its reference
calendar that's kind of handy right so
that's that's training it the way that
this is done in fact this also pertains
to things like publication you had a
publication you then try to find it it's
a non-blocking api so you add it if they
immediately return but a problem Albany
gives you back an idea that you can then
find it and giving you a share pointer
that kind of is around the whole EPI and
it's used internally as well it's very
efficient it also means that when a
publication gives out of scope for
example here once you would leave that
scope that publication then is closed in
the Java version there's an explicit
close but the publication has to do if
for Java developers this is painful
because it's something that they're not
used to now you can put a cleaner and
other things attached to it and it'll go
away sometime but you know if you're in
an environment where you want to know
when things happen and control them you
have to do it explicitly it's kind of
nice to have these
these kind of the ownership in the
lifetime sort of you know built into the
language a little bit closer lateness
instruction objects there's a couple
different ways of specifying callbacks
and things like that so having this is a
just a lambda that is in passed into the
new subscription handler so when a new
subscription is seen it calls this
callback and in the including code there
it makes things a little bit simpler
instead of specifying you know the old
stop function object doing something in
the class and object thread support is
issue standard thread now most equals
plus 11 and on developers will say that
I'm doing this exactly wrong it should
be not actually creating a new thread
you should be doing it with an exec
error or something like that sometimes
that works sometimes it's not this is
just an example you know where you can
have a thread specify when to run an X
right with the lambda you know when it
goes out of scope it gets clean because
it's closed things like that and also
just an example of Al Akbar Al Akbar
would look with quiring that mutex that
recursively mutex with Interscope and
getting rid of it when it so that's just
a couple of examples so it's basically
you know permeated through the idioms
and everything else that will list that
we looked at has actually been there so
you know the lessons were learned this
is a bit of the rule meet what I wanted
to really talk about the last year so
you know we look at this list of things
do you think we learned a lot from what
kind of things do you think we're
painful well the first thing is we gonna
kind of give any an idea that you know
the these first three things are going
to have a profound impact right lambdas
some function objects it's really kind
of syntactic sugar going away but it
actually does have some you know
clarifying effects but think about
things like Atomics okay
well thread support threats of course
probably a little cleaner but doesn't
have much
pack move destruction assignment low
latency sensitive so part of that may
have an impact right toll chain when I
can tell you that we you see make we use
Google Tasks we use Google mock you know
to make sure that we're doing things
appropriately in to do unit tests let's
just start down this list first these
three can not be kind of taken apart
they all have things to do with one
another
so stack allocation stack allocation is
a big one and the thing I will tell you
about some or pointers is give in to
your anger to smart pointers don't try
to fight it okay
don't kind of mold your thinking of what
you would normally do in other languages
and then use smart pointers for it
because you're going to get twisted
trying to do what you would normally do
so as we were doing here in C++ we had
here in Java that was being iterated on
we were working and we wanted to take
C++ and just poured it you could do that
but how does ownership work and what
happens with any cycles and how does
that how does that you know kind of come
about but once you get in to the anger
you actually come out with something
which is much cleaner so you just start
to look at it and say these are the
tools that I have and let's see what
happens you notice a couple things
so as this would being done
there's a lot of explicit coupling that
is in there and it's explicit because
you've got a share point you got unique
point you're in week corner how do they
interact if you got a moto jacket
sometimes a share but it's kind of
unique because it's one place where it
should be you know sort of kept around
how does that work thanks it makes a
couple your explicit because it's not
just that there's a reference from here
to here it means that there is this type
of reference from here to here which is
a very different thing think about that
it makes it it makes it so that you can
see oh you know what yeah this there
isn't one place where this is owned
SharePoint is probably the right thing
or is it really the right thing because
really shouldn't there just be one place
where it's controlled scooping is also a
really good thing look at because it's
explicit in this regard so having is
where you know what the scope of an
object is can lead you down pads to
clean up and get rid of some things that
you don't really need to worry about
because you know what the explicit scope
is you know anything's created you know
what he gets destroyed so I said it with
a badge but I'm going to and will match
every other language it doesn't have
stack allocation so the lack of stacking
Hill allocation whenever you talk to
other language designers and you say why
doesn't your language provide stack
allocation you give a lot of excuses I
want to say these are really excuses
you're going to see things like well we
have scape analysis you know what
analysis of escape analysis ology
returns
yes it's gate that's where it always
returns there are so many ways to defeat
you know the escape analysis let's take
a look at go and escape analysis there's
an old Ogden keeps getting handed to
about how many of the ways you it can be
defeated in other words how and
something leaks and can't be basically
put on stack another thing value types
you don't need stack out of each one you
have value types these are like saying I
don't need an orange because I have an
apple just because you have a use
doesn't mean you have the mechanism so
it makes me want to do this okay step
location is so useful because you don't
have to actually allocate it also is
useful because it's dead reckoned by the
compiler
it's what do we want we want that
there's no data dependent alone there's
nothing else that is involved in that it
knows where it is
it can figure it out at compile time so
this doesn't help you right
skip analysis if it gets defeated well
guess what it's not on the stack right
okay that's one use of stack allocation
it is not the mechanism of stack
allocation that gives you all the other
benefits that misses its core a lot of
this right when you don't have it you
really really miss it especially if
you're doing anything that has to be
fast
okay and I'm fashioned from that list
we're not going to think he's in order
Oh
let's prize you that move construction
assignment is actually one of those
areas that is exceedingly tricky and the
advice that I give here is sometimes you
just don't want to move it okay
sometimes you really don't want to use a
loop or a move assignment operator and
the reason here is covered in death and
I'm going to summarize this in a very
poor way for you know lots of different
talks to talk about move constructors I
don't use them and move constructors of
why you want to use them essentially
it's much more than you think the
concept of move constructors and move
assignment operators actually has a very
deeper meaning than just simply
providing me with that mechanism just
like stack allocation is used in a lot
of different ways it also has a very
deep impact on the language itself so
the first thing is you know if you're
thinking about using it think about just
a second what it implies implies that
you're moving one object to replace
another that may not be what you want it
sometimes often better to copy if you're
doing something where the scope of what
you have to replace is basically going
to go off on its own
you might as well copy it okay then -
that is you know a fairly interesting
way of thinking about the way that
optimizations interact with one another
when you use a MOOC instructor you can
effectively understand to the compiler
gross over-exaggeration
I know what I want to do here so don't
you know do X or Y and sometimes x and y
could be actually good things so
there is actually the way that this is
could find in that standard there is the
rule of three the rule of five in the
rule of zero that basically has the
interaction of different instructors
comic instructors MOOC instructors and
assignment operators and everything else
they give you certain rules I don't
think you need to go on to that length
to sort of understand what to do if you
just do one more thing if you think you
need to move object because it's heavy
weight but you need to basically have
that state somewhere else why they come
at it from a higher level for a minute
what is prompting you know the exercise
of having to take the internal state of
this object and move it somewhere else
you might think that there is a better
solution for that I give you a reason
why within within Aaron one of the
things that we went into was the ability
to iterate over a set of images or
replication of block buffers and we
originally maintaining this array was
being used by move constructors we would
just move from one ring to the next one
the objects themselves were just
overlays there was no ownership of them
or didn't need to be they could be
copied it freely so doing some micro
benchmarks it turned out instead of
moving them that there are other
optimizations that kick in it would be
better to copy and that was by looking
at it and just sitting there thinking
why do these need to be moving they're
just overlaying the memories are not
actually owning anything they could go
away on the stack so how do they get how
do they get managed but the biggest
lesson we learned was that sometimes
language features aren't built for the
things you need to do stood a time for
example so it kind of led us to think of
this anybody know this reference by the
way anybody see a movie dude
okay I'm a big geek architecture let's
think that look look again and sort of
the architecture the C++ pieces you know
the client pieces here they interact
with the media driver at this layer
which means these are ranked and
broadcast buffers shared memory and
these are logged offers which are shared
memory so you know we had these
different data structures that operate
on shared memory that needed to sort of
work together now really quickly what
this Erin do replicates a persistent
lock how does it do that well it has a
file and it operates on that file by
putting messages in let's slow it down
it increments tale then writes the
message then our rights to heaven in
that specific order into memory we lay
these things out with multiple sort of
terms that's you know sort of the area
that we just talked about with metadata
and even log metadata all of these have
atomic and ordered off memory operations
for so human thanks to Tom and that's
you need that right in there right what
can see what worse than that so we have
the concept of a position within the law
which is basically you need a
vindication of a fight with industry the
publisher centers receivers and
subscribers all keep position counters
in memory their key to flow control and
monitoring their shared memory pieces
that have an order to them there is
atomic operations on that there's also
word you know order semantics that are
attached to them so you think Stan stood
atomic all over the place right well
looking instead of common chemical
challenges the first size and layout is
it the same between Java and C is it the
same from different C compilers okay in
the memory models C++ 11 into Java C++
11 actually has memory so what does it
look like
well turns out size matters okay I'm a
big guy - sometimes I do feel like this
and basically size matters in a couple
different ways stood atomic was not
designed for arbitrary memory access so
you can't say something like I want to
split a comic and I want to put into
this memory location you can kind of
fudge that but it you don't want to
because there it's very you know
compiler specific don't do that and then
beyond that the size may not be the size
of the type so you may say something
like I don't want a 32-bit integer and
so the public will say that's great I
want to give you a 64 bit because
there's nothing in the standard it says
that it's laid out it says it has to
have particularly adult but it doesn't
have to have the exact layout some
others do this differently than others
mostly it's okay mostly they are you
know the same layout but they're not
guaranteed to be and so pilers can get
very interesting when you talk about
undefined behavior which is where this
starts to basically come into play the
thing is - the topic is concerned only
with the operation to provide you the
variable what the interoperability with
the job on the right well the memory
order stood memory order allows you to
sort of specify in different ways that
things should operate job is different
model and here here's the robic
difference say plus eleven normal model
says this generates this set of
instructions on these architectures so
it's basically here's what gets
generated Java normal model says if
these this thing happened before this
thing had this relationship exactly this
relationship this relationship these are
two different ways of specifying things
which means that you can't really take
and say these set of instructions you
know go to go to this they are slightly
different so they're a little bit it's
like looking at an order in state it's
not really to fit for purpose rent for
job remember it's not that it's wrong
so much as what turns out is equals plus
11 is much more conservative with what
it allows code to migrate up before and
after operations so what did this lead
to well we tried different try them in
atomic comic actually and we had some
various problems with getting that to
work until we had a contributor who
basically said you know what let's just
go through the GBM take the instruction
solution area but for all the different
types and unsafe import them all so
that's what we did it basically took you
know and have our own operation sequels
policies C++ functions that RJ
Chandrakala compatible so when you say
something like put int volatile it does
effectively the same instruction on did
the you know on x86 then that would be
doing that would do with the job of
chemical so we identified this up front
but we kind of innovates when playing
around with various things this is where
we landed if you're doing this with
Windows you have to do things slightly
differently but effectively it generates
the same code
they're just C++ it's good about that so
ramp up here gave us a little bit of
time for questions sort of what's next
and I'll cover sort of you know where we
stand
it says might be C 32 byte messages at
the top so we're gonna C++ standard
you're looking at IPC you're looking at
just the language a message is send it
goes it goes through you know a set of
operations that append to a log buffer a
receiver reads that and that's all that
there is the driver has no impact on so
the fact that your Java has no impact on
a message okay C++ to C++ 32 million
messages per second okay how does that
stack up with the rest of the things
well Java is 30 and we actually haven't
done import that's just just starting to
for the last week you know have the
capability of running these and it's at
15 million actually see
see shirt coming in 15 million is
actually about what we started with job
so this will only get better but still
notice that C++ is a little bit better
why do you think that way but then then
the fact that we're also mostly it's how
it mostly is compiled organizations
there's a lot of compiler optimizations
that are done in C++ and C that haven't
made their way to you know the JIT
compilers eventually they were all but
there are optimizations there's also a
few things that we hit with that we you
know we can elicit more optimizations so
you know what's next while we've been
working on
persistence revolution we've been also
talking about you know doing encryption
and security various aspects efficient
MVC for error correction and the design
the log buffer structure allows us to do
some very nice things for life from an
error correcting code standpoint
everyone point out is something that
does it's imminent and there's always
performance Thanks and there's actually
quite a few things that can be done here
I figure there's probably just with some
C++ specific things they could get
another three million out of this just
conservatively so I think this can
actually get better and also we've been
working on a C++ driver for in a while
in multiple unique accents most of this
aside you know most of this actually is
things that we've been doing in our I'm
tired you know some of the there's some
sponsored work that we've been looking
at for persistence and replication so
there's there's interesting things so
enclosing so we we went after Aaron with
a very different design I've written a
lot of protocols and you know when you
think you know how to do something you
probably should actually ask someone
else how would they do because they'll
come up with idea is that you never
thought working with Martin has been his
real joy in that he's not afraid to try
things and tribes you to try to do
things and see let's see what happens
that's what really has evolved up there
that's trying to do things different
things seeing what happens and you know
seeing what you can do so if I haven't
say one thing is try to put this up
forever here and talk to me give you
know try new things in and see what
happens
you can find area you can find the
sequel plus code as well and up here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>