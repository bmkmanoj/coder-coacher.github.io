<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • Make Web Apps Fun to Build and Easy to Refactor with Elm • Daniel Bachler | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • Make Web Apps Fun to Build and Easy to Refactor with Elm • Daniel Bachler - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • Make Web Apps Fun to Build and Easy to Refactor with Elm • Daniel Bachler</b></h2><h5 class="post__date">2018-01-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ehtn81p06Ow" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so this is my talk I work at a
company called Douglas Connect which is
a small a small company in Switzerland
that works in toxicology and we built
two of our products in Elm and I want to
talk to you a bit about my journey that
brought me to Al and what I like about
it and about this kind of languages so
one idle Sunday this this year this
summer
I brought this I made this little map of
like programming languages that I I know
and I like and I experienced at some
point in my life so I started out in the
non garbage collected deserts in C and
C++ and then I worked there for a while
and then I started to go more to the
object-oriented mountains to c-sharp
mostly I did a bit of Java as well I
mean I think for most intents and
purposes they're very similar there were
a couple of things I brought some
multi-threaded Windows desktop
applications for statistics basically
and there were a couple of things that I
really liked about it but then over time
there were also these things that
started to really annoy me two-way
data-binding was very nice in like
theory but in practice it led to very
big problems in complex code
object-oriented design patterns are cool
and they allow you to think a certain
way but I often found that they are a
kind of a distraction also I then went
into the dynamically typed swamps
I call them swamps because I think it's
a bit hard to build big projects in them
in a solid way that like endure for a
long time in big teams I did some Python
work I'm still using that at the moment
quite a bit JavaScript I started to
build web front-ends in JavaScript and I
had this problem that refactorings are
really error-prone I think that was one
of my main pain points whenever I
changed something in JavaScript you have
to be really diligent to make sure that
you capture all usages and make sure
that changed data structures are caught
everywhere and then I had a friend who
was telling me about Haskell which is
part of this group of the functional
forests I called them so we have
language like Scala which is like a
hybrid language and f-sharp like they're
somewhat object-oriented somewhat
functional and then we have pure script
and Haskell and F sharp and pure script
in Haskell and I've sorry and in these
kinds of languages and then we have Elm
up there in the forest and I think that
Elm is a very nice language because it's
from this entire family of languages
that are all really cool and powerful I
think and a very good thing to learn as
a programmer I think that Elm is the
most approachable and it's very useful
for building web applications and that's
why I want to talk to you about it let's
jump in have a look at what the other
way to pitch would be so what is L maybe
a quick show of hands how many of you
have done at least a little bit of Elm
coding like a tutorial or something like
that okay a few I mean if you like have
heard a lot about Elm or like it has
come up on their radar okay cool so a
lot of you will probably already have
like this idea what L mean is it is a
statically typed language it's purely
functional so it's not object oriented
it's not imperative it compiles to
JavaScript it's made for building web
apps with it the big thing I was
thinking about making this blink or
something like that right is it's no
runtime errors if you've ever written
web apps in JavaScript I think this
would be immediately appealing to you
right so no runtime errors ever and it's
very easy to learn it's really a very
approachable language and having a
simplicity the creator of made it a
priority that I think we heard in the
talk before here in the programming
language is track where it was about
rust that the error messages from the
compiler of Elm were an inspiration to
make the rust error messages better I
think that is true for a lot of
languages nowaday so Elm error messages
are like the gold standard I think by
now for how nicely a compiler can tell
you about what goes wrong
the syntax so here we have JavaScript
cindex javascript is one of the
languages that like a lot of language
has come from the c family of languages
syntax wise so it has these curly braces
and like semicolons on the end of the
lines and stuff like that and elm is
from the ML family of languages both
syntactically and also from the concepts
it uses and initially the syntax looks
weird but if you arrange it in the right
way then you see that it just gets rid
of the clutter so this is Elm so I
switch back basically all these weird
things right we just take them away with
curly braces the semicolons yeah it was
nice in the 70s to have that two bright
parts there's a little easier but we
don't really need those right so usually
you would align it more like this so you
have a function declaration that is it's
clearly this a function because there
are other tokens before the equals sign
on the top level and then it evaluates
to this thing we don't need to return
statements and then below you have
function application so we have a value
called result and we assign the result
of using the function multiply numbers
with these two operands and it's
statically typed check so instead of
hear some weird type coercion happening
when you call this function with an
integer in the string here this would be
a compile error the compiler compiler
would say no this doesn't work you need
to use two numbers when you try to use
multiplications okay you can if you like
use type annotation so this is a way of
specifying what these arguments are
they're a bit unusual if you've never
seen an ml language family language so
the way this works is the last thing in
these type annotations is the return
type of the function so in this case
multiply numbers is a function that
takes two integers the first argument is
an integer the second argument is an
integer the thing it returns is an
integer and below you we also give a
type annotation to the single value
result right it's also an it okay that's
easy enough but it's good to know that
type of annotations in elm aren't I
optional so you can never in your
program write any type of notation and
it will be exactly as strongly typed as
if you write type annotations a lot of
programmers like to use type annotations
because it's a kind of documentation and
the compiler can tell you when you make
a mistake right at the first point where
you make the mistake and not then at
some point later in the program when
it's maybe a bit more obscure what's
going on here here's a bit more of like
what a language look like this is a
simple type alias for we define a type
called person and then we define a
function calculate age that takes an
integer and then this person record or
structure and it returns an integer by
calculating the difference between the
current year and when the person was
born ok let's talk a bit about pain
point at Elm addresses because I think
that that's that's a good way to to
think about the language especially
because it compiles to JavaScript and a
lot of the use cases that you would use
it for is to replace JavaScript
basically one of the things that I
always found is I said that before a
code in dynamic languages is hard to
refactor correctly right and because
it's hard to refactor correctly we have
to really take care that we don't make
any stupid mistake like if we add an
argument to a function that all the
places where we call that function we
make sure to pass in that argument and
stuff like that if we have these
problems and we have to take care that
we take it that we take care of doing
this correctly we do it less because
we're afraid of changing it and we don't
want to deal with it right now and which
leads to lower code quality so if this
is a big project that several people are
working on over time this can lead to a
lot of like just a lot of refactoring is
not done a lot of lower like the code
quality becomes lower and then the
development speed goes down because you
have all these cruft that accumulates
and you never deal with it and when you
do refactoring they often introduce bugs
and crashes now in L everything is fully
typed so even if you give as I said no
type annotations ever in your project
the entire project will will be fully
typed and the compiler checks that all
types match even between modules and
bitches and everything like that there's
also no any type so if you know
typescript or flow they have this kind
of escape hatch of any Ellen doesn't
have that and doesn't have any it
doesn't also have because it's not an
object-oriented language so there's no
type hierarchy where everything like
derives from object or something like
that there's just a fundamental
difference between types and compiler
will make sure that you don't cross
these okay so records we briefly showed
those before we find one of those called
programmer has two two fields one is
named which is a string and favorite
language which is a string and then we
create a new value with that type or off
that type named Daniel favorite language
l that's nice and easy but then Elm has
a very nice feature that is called union
types or some types this is something
that I wish basically every modern
language had and I'm really sorely
missing this in languages like Java and
c-sharp if you look at it like that so
it's often used for cases like where you
have something like an status right so
it there's like two possible values this
status can have it can be by the pending
word can be completed and then maybe we
have a record called task it has a name
and then a value of this type so far so
good right so far this is this looks
like an enum maybe that you know from
Java or C sharp right okay
so what's so special about this the
special thing about this or maybe first
quickly how we use it so if you ever
want to use a value of this type you
have to do pattern matching and elm does
exhaustion checks so it will check did
you at every use of a well a variable of
this type did you cover all cases so if
you want to use a value of this type of
this type then you cannot just like grab
into like look at it you have to say
there's a value of this type I give you
all the cases that this can possibly
have if I just write the pending a state
here then the compiler will complain and
will say hey you didn't cover all cases
so if I give it the completed state as
well in this function that turns this
status value into a string then this is
how you would do it you say case that is
off and then you give all the possible
cases that this status there
we could have the thing where it gets
interesting with union types is what if
some of the states have data attached
right so maybe for example we would have
a progress report right so we introduce
a new state that's running I'm sorry I
forgot that the running state here so
between pending there should be a
running state as well as completed and
failed and then we have the current item
and the number of items and then maybe
we would like add these fields to the
task right so we basically have our enum
like thing called status and then we
have we would store this information
somehow now in the task and we also have
this failed state right so when we are
in the failed state maybe we want to
store a list of error messages that
occurred during the task and again we
would need to store these in the task
itself the problem with this is that and
these kinds of things in data modeling I
think they come up all the time right
where we have different States and some
of them have additional like payload
data that we need to take care of but in
most languages this is all you can do
you have some kind of an enum that says
like or like this state type that says
okay which state are you currently in
and then you have a bunch of additional
data then you want to keep track of and
do you have to pack these into some
other data structure that's did you keep
around the problem is the errors like
variable for example it only really
makes sense when we're in the failed
state right I mean sure we can't have
the empty field around lying lying there
but it doesn't really make so much sense
and there is this great thing that also
was mentioned in the talk about rusk
that's a really important design
philosophy I think if you can make
invalid States presentable in your code
that's a very very useful thing to do so
what this means is if you can write your
types so that an invalid state cannot
even be expressed in the program then
you don't have to test for it
it cannot occur and it can slip through
your code in practice and it can never
end up in a bucket in production so here
we see the real power of Union types
basically each one of these enum like
things right of this different cases
that the type status can have like
you're on a like pending they can have
payload data attached
and so running for example has to intz
that it carries with it and failed has a
list of strings that it carries with it
and so if we want to for example create
a value like here in the middle in valve
one where we create the value of this
running of this type status but in this
case we want to use the running value
constructor then we always have to
specify these two integers in this case
right because the type definition says
that there's four different kinds of
things that a value of this type can
have and if it's running then it need
you need to give me two integers and
this means that our task struct type or
a task record type only needs concern
itself with the name of the status right
and the status depending on which of
these values it actually has will have
different payload data data attached so
here's how we do pattern matching when
we have payload data so again this is to
get your I string function it takes a
status it will like turns it into a
string that we can display in the user
interface the first case and the
completed case are the same as before
but now we have this running where we
say okay so we want to give these two
integers that we pass on in the running
state we want to name these current and
total and then we turn the whole string
into a the whole thing into a string
that basically says this is number 1 of
10 or something like that and in the
failed case we want to give an error
message that joins all the entire list
of error messages and puts that into the
string and this is a really powerful
construct right together these types
these things are called often algebraic
data types when a type system has some
types and I think that this alone is a
very nice feature that allows us to
model a lot of cases that are really
useful this pattern matching is the only
way that we can get payload data out of
these value types right so for example
if you we wanted to access the list of
errors we have to make to pattern match
and say in the error case then I get a
list of errors in all of these other
cases I don't have that data even
available and I cannot accidentally
access it or use it in a wrong way
briefly to mention it for some reason my
syntax highlighting broke down on this
slide and I think one or two
you can have polymorphic types aka
generics so this is how you define a
binary tree type basically you have a
type variable now called element type
and again this is a union type either
it's a leaf then it has whatever type
you instantiate this with or you have a
node type and then you have two payload
data pieces both of these are again
binary trees and we need the parentheses
here to indicate to Elm that these are
like basically positional arguments and
there's like two of them otherwise it
would parse it differently okay
basically that's it and there's a sample
of how to create a leaf only or how to
make a small binary tree out of this
other pain points right undefined is not
a function or null reference exception
when I was program in C sharp I think
about half the like major bugs that we
have were not reference exceptions and
often this is the case of just a big
code base grows you had a piece of code
that had this assumption that this part
can never be null and then the code
changes and it grows and grows and grows
and sometime later this assumption is no
longer valid and you end up with null
reference exceptions in production code
Elm doesn't have that Sun doesn't have
the concept of null or undefined and
this kills a whole family of bugs but
then if you don't have null right how
can you represent missing values well we
use Union types for that so there's this
cut type called maybe so if you know
Scala that's what option is in Scala
basically it's either nothing now we
don't have any payload or just and then
we have like one value of whatever a is
defined to be and so there's here we
define two different values again about
one is used a nothing constructor and
well two uses just and then we need to
give it the actual content of it and
then it's an maybe of int the first
thing where we use nothing the type that
I've brought here is actually more
specific than it would really be so
because elm if you just leave it to
itself will just say okay this is a
maybe of a because
nothing can be anything which is
philosophically you've been weird but
whatever but basically it would infer
that the type can even be more generic
and you can always give it a more
specific type if you like what if we
need error information so we saw this in
if you went to that in the in the in the
previous talk the rust language has
picked up the same concept of a result
type to represent operations that can
either succeed with some data type a or
fail with some other data type beep
very often the error type is maybe just
a string or a list of strings like here
which use a single string and in the
okay case in the examples down here we
use an integer but of course these can
be arbitrarily complex data types right
this is a very nice thing because again
every time you use a value of this type
you have to say what do I want to do if
this is the okay case and what do I have
to do if this is the error case another
interesting thing about elm is that all
values are immutable so as opposed to
rust where this is like kind of an
opt-in thing to make variables mutable
in album everything is mutable so you
cannot assign to the same variable a new
value so they're more like named values
than like what you would think of as
variables in programming languages and
you cannot like dot into length into
values like for example here we define a
value of this programmer type there's no
way you can just change a property or a
field of this record now maybe you think
of like how the heck are you ever gonna
program if there's no mutable values
right which is a fair question the thing
is what you do is you have you create
new values right so for example here
when we want to create a new program or
B that has all the values all the fields
set to the same value as programmer a
just the name be different then this is
how you do it there's like this special
syntax when you use the record curly
braces again and then you use a vertical
bar before you specify what is the value
that you want to base it on and then you
give the fields that you want to change
and give the new values for that I'll
come
how to actually write useful programs
with an immutable language in a second
right so keep that thought if you have
it I just want to finish a few other
things about the language first one of
the side effects of this by the way is
we can't do Loops you know right so for
loops they require a counter variable
right in other languages we can't do
that you know because we have no mutable
values the solution for this particular
thing is to use either map or fold which
most of you probably know more under the
name reduce or use recursion instead but
yeah this is a bit weird in the
beginning but you can use to it ok we're
almost through like language like
features so we can look at some code in
practice and how this all plays out but
one thing that you need to know still is
that elm is entirely pure so this means
that all the functions are pure and none
of the functions can have side effects
there's two small caveats which is debug
log which writes to the console and
debug crash which just crashes your
application for debugging purposes but
other than that it's like every function
is idempotent so this means that if you
call the same function again with the
same arguments the same thing will come
out of it right so how do you get work
done in a language that's immutable and
all functions are pure it sounds weird
Allan comes with a small runtime and
there's also no direct JavaScript
foreign function interface so you cannot
just call out into JavaScript but the
thing this how this works is the arm
architecture that we'll take a look at
in a second but just to explain a bit
more in detail maybe how this thing was
the pure what this means that every
function is pure in elm because there is
no way to just execute arbitrary
JavaScript or perform any side-effects
really this function that I have up here
at numbers D it will always evaluate to
the same value right in JavaScript as
you see below you could do weird stuff
you could like have a global variable
that use this that may in this case for
example is a counter that we increase
and so calling the same function again
with
different arguments actually leads to
different results right or if you have a
library and you just call this function
it might actually just do an HTTP call
and like transmit your data somewhere
else or whatever in Al you have this
guarantee that this can't happen there's
no side effects and you can perform in
the language itself plus side makes
testing super nice functions that are
idempotent that always return the same
values when you give it the same
arguments they're super nice to test and
you don't need this kind of knocking
that you sometimes need in other
languages and thanks to static typing
most of the unit tests can actually
focus on the logic like in JavaScript
you test a lot of like okay but what if
I pass in null here and what if I pass
some other and integer instead of a
string and these kinds of things these
are kind of boring properties that the
type system takes care of it also makes
the refactor refactoring is a lot more
safe and fun because the compiler can
check all these things for you and then
can tell you if something goes wrong so
now how to write actual programs in this
there's something called the Elm
architecture and this is basically the
gist of how it works you give the AL
initial start program that is that you
used to create an elm application three
functions you give it the init function
the update function interview function
the init function basically creates the
initial model this is basically a single
big record usually that contains the
entire state of your application from
this this is then passed into the view
as you see here the model signature of
that function is model goes to HTML of
message and so what this does is it it
uses this model type that you created
before this value and it turns whatever
this state representation is that you
have of your application into something
that can be displayed to the user it
does it's very similar to react if you
know that so it has a virtual Dom kind
of library and you build up basically a
virtual Dom the on runtime does the
dipping to you and then changes the Dom
representation that is shown in the
browser to the hello user the user does
something and whenever the user clicks
something for example a message is sent
back to your update function the update
function gets this
new message that just happened it gets
the model as it is currently and it
outputs the new model as it should be
and a couple of commands if you like
so commands are these things that go to
the young runtime and there they are the
things that actually are allowed to
perform side effects so a command is
basically just a way of describing
please do this HTTP request for me and
then when you're done like come back to
my update function sent me to request
the result of that request as a message
this is basically all there is to it
right so this is the UM architecture and
it's this unidirectional cycle of doing
user interfaces that has been very
popular also in the reaction world with
the Redux library the Redux library took
its ideas in its inspiration exactly
from the unmarked attack sure the thing
is this looks maybe a bit weird if you
use two other UI paradigms but the
really nice thing about this is that
it's super easy to test and you have it
all laid out because the only place
where some stake in your application can
ever be modified is in the update
function so I think that this is a
really powerful model the model that you
create in this initial intent and update
continuously in your update function is
a single source of truth so in a lot of
JavaScript applications when you the old
way right though jQuery where you were
restore it will restore data in the Dom
itself you had this kind of race
conditions mercy for several components
maybe try to update the same value in
the Dom at different times this cannot
happen with the ARM architecture because
there's only one place where it gets
updated which is the update function and
this value that gets out of the update
function the new model is the single
source of truth for your entire user
interface visual elements are then
created from this current model right as
we saw with this all with this new
function the apps are always
well-structured because they all follow
the same paradigm and you can easily
replay UI sessions because you just have
to log basically all the messages that
were sent to your update function and
then you can go back and forth and you
can serialize them and do an undo redo
and stuff like that ok before we look at
actually some live demo of how this all
works
a quick
explainer of how new functions work
because otherwise you will spend all the
time on the next demo looking at what
the heck this weird new function thing
is basically what you have here is like
this is very similar to much reactors
with whatever it does with these diff
functions that create virtual downloads
and stuff like that in elm this is not
this is no special syntax right so this
is not like JSX or so there was like
patched on to javascript this is just
normal elm code and all of these
functions did you see here like div and
button and so forth there are functions
that create a single Dom representation
node and they always take two lists to
live the first list is the list of
attributes so as you see in the first
example with the outer div it gets a
take the first list has exactly one
element which is whatever happens when
you call the function class with the
argument about the string of counter and
then you have three child elements
that's the second argument to the div
function is another list of the children
the children children elements and in
this case we have a button that if on
the button and it corresponds to this
HTML that you see below right again in
the beginning this looks a bit weird it
takes a while a few days maybe for your
eyes to acclimatize to this particular
syntax but once you get into it just
like with the ML syntax it becomes
really very obvious in a very
straightforward way of encoding this and
you actually can read it very quickly
okay demo time so let's switch over here
I have an app running live that was
created with create an app which is
maybe very similar to create react app
if you know that and here I have the
atom editor with the elm plug-in
installed one of the nice things that
you see immediately I hope you can maybe
I don't know if you can read this but
you have this these type annotations
here on hover right there bit too small
maybe should I make this
can you read this in the back is that
okay should I make it bigger it's okay
okay so let's go through this basically
what we have here is here we define our
model right this is a record that has
one variable called counter and it's of
type int right it's a simple demo app
then we have the init function and this
creates a tuple so I didn't cover the
tuple syntax but this is basically just
like within parenthesis separated by
comma you can have tuple values 2 2 this
is a 2-tuple the first value is of type
counter model and the second type is of
type command of counter model so this is
basically if you want to tell the
runtime to do something for you like an
HTTP request this is basically how what
you would use for that in this case the
account and the thing that we want to do
initially for the for the model is we
want to create a new record with a field
counter set to 0 and for the command we
just want to do nothing for now then we
have counter message this is the message
type and the message type is a really
nice use of Union types because it
enumerates all the possible things that
can happen in your entire application so
if I if I colleague hands over an ell
project to me I just need to look at the
message type and I know immediately all
the things that can happen in this
application and then I look at the
update version then I see all the state
transformations that have actually
happened in this in this application so
here what we do is we get the message
that was sent to the up to the
application to the update function we
get the current model and then we
pattern match on the message that we
received and if the message is increment
then what we do is we create a new tuple
and for the model value of the tuple we
use we use this record update syntax
that I showed before so we update the
current we use the current model as it
the base and then we set counter to
model count row plus 1 right so we
increment the counter field in the
record for command we still use none we
don't want to do any HTTP requests or
something like that and then for
decrement is basically the same thing
but with minus 1 here and then here we
have this view function that we just saw
before that
it just takes this model and renders it
so here you have the text where it
renders out the string as child node of
this second div of this nested divs and
what's maybe interesting is this thing
here the onclick decrement so unclick is
a function that will render an attribute
and but what you pass into this on
clique is not a function which is maybe
what you would expect from a functional
programming language but it's the actual
message value that we want to receive
when this happens so when the user
clicks on this button what we would like
to receive in our update function is the
message that was declared here decrement
right and here if the user clicks the
plus button we want to receive the
message increment and then here in the
bottom we just wire it all together we
use this HTML program which is defined
in one of the Elm standard libraries it
gets it takes a record and it wants a
view function an init function and an
update function which is what we give it
and it also wants this thing called
subscriptions which I don't want to go
into now but which is basically for
receiving regular events from JavaScript
ok let's see how it behaves in practice
all lo and behold we have a culture now
if I click - here a couple of times one
of the things that I want to show you
here is that this is running in debug
mode so down here you have this explore
history thing I hope you can all see it
I can move them we know a bit up further
up maybe and what this is is basically
just the log of what happened in the
application all the messages that we got
which here is a bit boring because
there's just two possible message and
they don't have any payload but you can
just click on these and you can see that
the counter reacts to this so maybe
let's make the counter a bit bigger so
you can see that if I go back this is
the first time I got a message then
we've got another increment and
decrement the decrement the decrement
and this is really nice for debugging
and you can also import or export these
so you if you have testers and they do
Q&amp;amp;A and they say oh this is your numbers
can get negative if that wasn't supposed
to happen you're like oh I don't know
how that could happen please send me the
logs and they can just see realize they
send you to chasing you you know
ingested into your application and it's
super obvious what happened and you can
play around with this and fix it okay
but what is the actual behavior of or
the experience of developing it now
let's start and let's say business comes
back and they say okay this is like -
and plus buttons they're really cool but
for our customer we want a double +
button right ok so we say sure we make a
double + button so let's make double
increment right okay now let me save
this and let me say it like this because
what you will see is that just like if
it works yeah just like you maybe you
notice from NGO or something like this
there's an auto format which just form
its code always the same way right so
maybe you notice from JavaScript now
it's getting popular with prettier or go
format in go does this which is a really
nice thing because I can just read every
Elm code because everyone uses own
format and it's so it's always formatted
the same way okay what happened here we
get an error message and again the
overlay is a bit small I don't think I
can easily make that bigger but
basically the compiler here tells me
wait a second the Union type that you
defined up here it has three cases but
you're not handling double increment
then that's super nice because yeah I
forgot to do this so let's go in here
and add a case for this double increment
and in this case what do we want to do
well basically the same as with
increment but in this case yeah yeah go
away but in this case I want to add two
right okay safe now it's gone okay
that's fantastic but we don't see it
anywhere yet right we don't render it
okay so let's duplicate this button here
that we have there and do a plus plus
and save it again and here we have minus
plus and plus plus so now if we click
plus plus whoa what happens here yeah I
sent the wrong message so we need to
send double increment of course save and
now if we click plus plus then it gets
incremented by 2 if we plus it gets
incremented by 1 okay fantastic
now business comes back and they say
yeah this is fantastic this feature you
implemented super but now we want triple
increment right and you're like come on
you know really but you think okay this
is getting a bit silly right making a
single message every time for for these
things let's just give a payload to the
incremented section value right so let's
say increment always carries with it an
integer which is by how much we want to
increment it okay we click Save and
kaboom right something is wrong so what
is wrong we click here and Elm tells us
it I cannot find the pattern double
increment Yeah right I mean we removed
it so let's remove this okay safe what
happens now still red okay it says
pattern main increment has too few
arguments now this is also correct right
I now said that increment always has to
have a payload of an integer okay
so let's give it an X and then of course
we don't want to increment always by one
we now want to increment by this value X
okay safe again and still something is
wrong okay double increment doesn't
exist yeah correct
okay let's remove this button and
duplicate the increment and now we need
to pass in two right now again I said
this before
sometimes in Elm you have to use
parentheses like this in this case also
we need it's a positional argument we
need to tell it one click once exactly
one argument so we need to use increment
here with parentheses around them and
then we click Save and still there's a
problem right increment here in the in
place before doesn't have the number
attached to it by how much we should
increment it so let's do this and save
and now we're good again we have minus
plus and plus two right and it's a very
simple example of course but this
development experience of course it
works across modules it works across
like other packages it's just really
nice and it helps you develop with
confidence right the code just tends to
work when it compiles it works and
sometimes it takes a while to get it to
compile again because like when you
refactor like all kinds of stuff all of
a sudden looks different but the
compiler just nags you until everything
works out again and this is a really
really nice thing that let
you sleep much calmer there's also a
really nice feature in that elm can
check the types of the packages that are
generated and then it can enforce
correct semantic versioning so basically
when you do an update to a package and
you change something because you rename
a variable or a rename function then the
Elm compiler will say hey the types are
different this is a breaking change you
have to do a major version upgrade the
small caveat is of course that if you
just do like if you have a boolean and
then you treat it differently or stuff
like that so these kinds of things it
cannot check for you but a lot of the
like usual semantic versioning breakages
that happen in like JavaScript packages
it can catch these because the compiler
just knows about it okay so time to go
to slowly come to the end what do they
have my singing here okay quickly I just
passed like mentioned these commands in
passing just to quickly show you how
that works because maybe you're still
wondering how to do side effects so for
stuff like HTTP requests or generate
random numbers and things like these we
need to use commands and the basic way
that this works is as you see here so
send command
it basically constructs one of these
command values it uses the HTTP library
to say okay when this command should be
done like clear run time please go and
do an HTTP GET string to this particular
URL and and this is the the second
parameter to http send in line nine when
this comes back either like succeeding
or failing please send the loaded
message back to my update function right
and then in the update function you have
a case and then you handle loaded either
with okay if it went well with the text
that you want it to have or you handle
loaded with the error and then whatever
HTTP error timeout or whatever is
captured in that HTTP error okay ports
okay I see I'm running a bit low on time
so I'm just going to quickly go over
this ports are basically similar to
commands but instead of talking to the
on runtime and doing like things that
are more or less pre baked into it ports
are used to have so you have your bright
your own javascript next to your elm
code and then you can communicate with
messages back and forth this is useful
if for example you want to play audio
which the elm light library doesn't
support yet then you write a bit of
JavaScript that uses D Web Audio SDK and
then you send a message through ports to
Chaves scripts the JavaScript starts
playing and then if you like you can
send messages back again the overall
experience of building production elm
apps with Alain was super nice we really
never had runtime exceptions which i
think is really a fantastic development
experience the compiler helps you all
the time and you have this wonderful
confidence in your code you're not like
I need to push this button oh my god
maybe it's gonna break in writing
production in these kinds of things
right so reading great obstacles some of
the things that are like not so ideal
sometimes you need to use ports for
things that seem kind of trivial for
example to move focus between several
input elements which is a bit annoying
because in JavaScript is like not even a
one-liner basically and in elm you have
to then set up ports and stuff like that
you can't at the moment publish native
modules so basically all modules that
also have JavaScript accompanying it but
you can do that just with github sharing
code and there is a thing when you use
ports and you like deal like send
messages back and forth you not only
have to define the types of these things
that get sector sent back and forth but
you have to write what's called Chase
and decoders these things are a bit
tedious to write in theory for most of
the cases the compiler could do it for
you but for now it doesn't ok I think I
was absolutely ready to be used in
production it drastically reduces part
counts the development speed as I said
before it doesn't slow down as the
project gets bigger and realistically
you will probably have to maintain some
JavaScript on the side but I think that
you still gain a lot if you can move the
majority of your logic into L if you
want to learn more about it there's try
l9 org which is an online editor that
you can use to play around with on Allen
Lang dot orc you can get the compiler
and all the links to the editor plugins
and stuff like that in the beginning
maybe try it for a site tool or internal
tool and go on the arm slack and ask
questions the very beginner friendly
yeah with that thank you all for coming
and I'm Daniel Butler I'm Danny x-23 and
Twitter and please ask questions and
rate the talk thank you yeah we have
some questions one of them is are there
any non-trivial open-source M
applications that could be used to learn
a silent pneumatic and stuff
yes so if you go to Allen Langer org
there's a couple of projects linked out
and they are there's at least some of
them who have like a couple of thousand
code lines or so I don't know if there's
any like tens of thousands or so
open-source projects yet but there's
definitely a few and two questions about
default values on models or parameters
or on attributes yeah it's possible yes
this is something that I didn't have the
time to go into it there's something
called partial function application that
you can do in L where basically you can
have a function with let's say seven
parameters and if most of the time you
just need two of them then you can make
a new function based on this function
with seven parameters that has five of
these parameters applied in a default
way so that's how you would do it
another two questions really about how
do you structure or split an application
which is a bit more complex so this is
an interesting point a lot of people are
coming from react or similar other UI
frameworks they think in components
right so there's a visual component and
they think like okay this should have
its own update and its own view and its
own unit basically which you can do in L
so you can do this kind of structuring
but usually it's more idiomatic if you
just try to create different functions
and then maybe you have this one thing
that renders like what like an abstract
of a person like first name last name
whatever github repository count or
whatever and then maybe you just have a
function that renders this given a
certain kind of data but you don't but
you wouldn't necessarily have its
own update function and these kinds of
things again this is a bit of a bigger
topic so because it's a bit of a mind
shift but you can absolutely structure
your applications in a similar way but
it's usually nicer if you just think in
functions first how about using other
frameworks like ember x GS and something
like that in L you can't do it so the
Elm is really tied to its own
implementation of the virtual Dom so it
works basically similar to what react
does and that's the only way you can
write code in it and you basically now
you live in your like own little bubble
so there's no directly calling out to
JavaScript in any form which is what
makes it possible to give you all these
guarantees on the other hand another
question I just read it it's been a
while since the last major release of
elm when will be the next release and
will it support server-side rendering on
nodejs yeah I don't know I mean it's
definitely actively developed evan isn't
the creator of the language was like the
main developer on it isn't very keen on
publicizing any deadlines we know that
he's working on it and has been for a
year it's probably gonna be soon ish
whether it's gonna be this year or well
like human nobody knows server-side
rendering was set to be in his like
focus whether it will be a nice language
to develop for node I'm not so sure for
now because it's just like very much
made for creating browser apps at the
moment yeah but there is some some
support hinted at for like at least like
rendering the initial like basically
HTML that you could serve to a non
JavaScript enabled client and then also
one yeah one this track at least any
vital question a comparison question can
you compare it a bit to Alex here yeah
that's that's very different they're
often used side by side because Alex
here of course is a server-side language
right and it has a great concurrency
model whereas Alan doesn't have any
basically right I mean it has effect
like concurrency model through this
update cycle but alum is very much like
focused on writing user interfaces like
basically in
the browser right whereas elixir is
something that runs on the server and
it's very good at like handling like a
lot of processes that communicate with
different end points and stuff like that
but as I said they're often used
together so in the company no red ink
where Evan works who develops the
language they use both of these
languages together
okay the others have probably be
answered already in the end of your talk
any other questions in the room here
okay you just replace any java
application for example or yes so
basically everything that runs in the
JavaScript that runs in the browser and
doesn't have like external dependencies
that you need to bring in is a good
candidate to replace so basically the
majority of web applications if you
start building them now or if you
rewrite something that you have I think
would be a good candidate the caveat is
if you have a lot of like experimental
Web API that you use like WebGL plus Web
Audio and so forth at some point maybe
you've you spend most of your time like
sending messages through the ports to
your JavaScript that you also have to
maintain and then you have to make this
trade-off does it make sense but for a
lot of like the normal kind of business
just display a couple of forums like
make validations these kind of things I
think Elm is a fantastic language okay
last question Thanks it is actually my
second question okay ask on all night
very nice talk one thing I want to ask
and I find it difficult so in redux how
do you work with the front-end team like
they have to learn these strange
definitional views that is there
something you mitigate somehow so we
have this we had this experience when we
did our production if we have one
developer who is mostly responsible for
styling and designing she does have some
Python experience so she's maybe not
your typical like entire just CSS person
but she was really she was into it and
she liked it and it like as I said like
it takes a few days for your
to accommodate to this like kind of
writing like basically HTML again but
it's totally possible and I think that
if you invite them and like try to
explain these things like we can write
back free software with if we do it this
way that they might very well be open to
adjusting to different kind of doing it
writing back free software so very good
ok thanks a lot thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>