<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • The Future of Software Engineering • Mary Poppendieck | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • The Future of Software Engineering • Mary Poppendieck - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • The Future of Software Engineering • Mary Poppendieck</b></h2><h5 class="post__date">2016-11-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6K4ljFZWgW8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I think you've heard that the future
is already here it's just not evenly
distributed so if you want to know about
the future like let's say 2020 actually
that's not that far in the future
anymore maybe three years 2025 all you
have to do is look sort of in the
corners of what's going on today and and
in fact at this conference you're going
to be doing quite a bit of that and you
get a pretty good idea about where the
future is going to go let's however go
back aways maybe 20 years or something
like that and the first thing I want to
talk about is scale getting big
because actually 20 years ago things
were things that felt big are really
small today and and things that are big
today have scaled in a particularly
interesting way they scaled broad rather
than tall so if you were a penguin in
South Georgia island all these pictures
by the way were taken by my husband Tom
who's great photographer and this is
king penguins and when they don't have
enough space they go out to sea you know
they don't climb up more mountains and
so let's talk about what happened 20
years ago
in 1996 what was the state of what was
going on there most of the software
development at that time was business
software or control software when I did
software development I was a process
control engineer I controlled great big
pieces of equipment with my code which
I'm biased but I think that's the best
suffer in the world and so I wasn't
involved in this stuff that they call IT
but most software was done at least the
the literature to read the literature
was all about great transaction
processing mostly in enterprises
and this is just as the internet started
together some software
I remember in 1999 somebody was saying
about how fast the software how big
software wasn't how long it took to
change we're talking a release of a year
was fast I can remember reading in
computer world that there are some teams
out there that have learned how to
deliver software in six months can you
imagine that so it was really slow to
change and I thought you know there's an
awful lot of new software that's come
this is ninety nine and I was talking to
some colleagues and it's called the
Internet you know that's a lot of
software that's been developed in the
last few years and looked at me and said
the Internet that's not software yes it
is but it's different kind of software
so back in 1996 we thought about
transaction processing as here's a
database an ERP database when I was
doing process control systems I followed
one of my system to a manufacturing
plant and I headed up the information
technology office in the manufacturing
plant and we did something called MRP
called material requirements planning
which meant we planned all of the
different inventory movements that
happen through the plant and all of the
production workstations and that
eventually expanded to the whole
enterprise so it got to be called ERP
enterprise resource planning and
enterprise resource planning was
centered on a database the corporate
database the one single thing which sort
of integrated all of the applications in
the enterprise and still does actually
and it's sat on a single server and well
why is that well you know there's this
theorem called the cap theorem you may
have heard of it which basically says if
you've partitioned your database on two
different servers there you can have one
of two things but you can't have both
you can either have it available
instantly when you want it or you can
have a consistency
sistent you can have consistency of
across a transaction the whole
transaction or none of it but you can't
have both and so because the database
was the thing that provided us with both
the availability and the consistency of
transactions we had to have it on a
single server so if you look into the
late 90s all of the databases sat there
the corporation enterprise sitting on
one big computer and integrated through
that computer and that was like the only
way to go but then you know
Along Came Google and suddenly there was
a whole bunch of data that didn't fit on
one server anymore in fact if you have
1.3 billion pages this is about 2001
it's just not going to work you have to
go across a bunch more a bunch more
servers you have to figure out how to do
that in a way that allows you to respond
very rapidly so there's two ways you can
go big or you can go wide okay tall or
wide you can either get a much bigger
computer and interestingly enough in
about 2000 I think it was Amazon was
sitting there with a big front in one
big front end and when big back end you
know that single database and at every
holiday season they absolutely couldn't
handle the transaction volume anymore
and so you know what they did they got a
bigger computer and you know what
happened okay if you know anything about
queueing theory you go to bigger batch
and you get slower and they got slower
so they said well that's not going to
work so this is Grace Hooper you've
heard of gray super she's a sort of you
know she's the one that designed COBOL
and all of it and she said if one act
couldn't do a job they didn't try to
grow a bigger ox they used to awesome
when we need greater computer power the
answer is not to get a bigger computer
is to build systems of computers and
operate them in parallel managed by
software that's the whole concept of
scaling out rather than scaling up so
you get more computers
and you figure out how to deal with the
fact that they have problems so for
example here's one of the first Hardware
racks from Google in 1999 it's in the
Computer History Museum now and when I
first heard about how they were storing
all of those billions of pages I was
rather surprised they used this really
cheap stuff and they expected it to fail
and they kept multiple copies of stuff
so they could just toss out the stuff
that fails like what a good idea and
they managed it with software so the
concept was actually kind of radical at
first but really the only way to go so
the whole idea if you're going to search
the whole internet and you're going to
provide responses instantly is that not
only do you take your hardware and
spread it out you have to do the same
with your file system so here is the
early paper in 2003 on the Google file
system and same concept you took it you
take little tiny chunks of your file you
throw them all over the place you make
sure you got good three copies of
everything and then when one of them
dies that's okay there's two more you
just sort of throw out the stuff that
dies and regenerate it and it's that
whole concept that your whole underlying
system is fragile no problem you manage
it and you have multiple instances so
you can deal with it and then of course
you've got your data that you have to
search instantly scattered all across
these files and a year later in 2004
they came out with the paper on
MapReduce which became the basis for
Hadoop which sort of spread through
about took from 2004 to maybe 2010 12
before it emerged suddenly as this
wonderful thing that everybody could use
it took a long time to get Hadoop from
handling just a few files and just you
know just a couple of computers to
something that could deal with massive
amounts of data and it was done it was
done out of the Apache open source
project and but I think was the kalfa -
who worked on it
wenton worked at yahoo he was hired by
Yahoo because they decided maybe they
better go to this MapReduce thing too
and between the various big companies in
Silicon Valley at the time the whole
underlying structure of Hadoop was
developed over about a five to eight
year period and there was an awful lot
of sharing because Doug decided that it
was going to be open source and he would
be happy to work for Yahoo but had to be
open source and it's that thing that we
do in the software engineering world we
share our knowledge so that it can grow
a whole lot faster and I don't think
without the sharing of all of the
different knowledge of how these file
structures and databases work I think if
these companies kept a proprietary we'd
be a long ways back from where we are
now
so that's one concept you scale out with
a file system when you look at your
architecture it's the same concept you
might think you've got a big monolithic
database but if you have a big
monolithic database you're not big
because if it's all in one spot it's
actually pretty small in order to really
get big you have to scale out so let's
go back to that Amazon in as I said
about 2004 2001 and there they are were
the gazillion transactions and they had
to handle all of these transactions all
at the same time and the first option
was to scale up okay so take and take a
single transaction let's say it's all
four things there's there's shopping
shopping cart you know browsing shopping
cart payment and fulfillment okay and if
you take a look at that then you can
scale the whole transaction maybe even
across in Regent's different computers
if you want to but if you want to scale
out you scale differently
you take your transaction and you say
you know what
I'm not going to let the database handle
it anymore I'm going to handle that
transaction all by myself so I have my
four different services say the browsing
and the purchasing and the fulfillment
in the payment and if I have a few that
are bottlenecks I'll just scale out at
that small area it turned out to be
pretty much the way that people have
figured out how to scale since as in
they did micro services long before a
lot of other companies and they did it
because the idea was if we are going to
have to handle this many transactions
we're going to have to think differently
about how we scale Amazon had a meeting
of the executives after one of these
disasters almost disastrous holiday
seasons and they said how are we going
to deal with this whole thing next year
and they came to a conclusion the
conclusion was we have to communicate
better have you ever heard that kind of
sound familiar
I think it's kind of a cop-out
if cop-out is a good word in English
it's just I don't know what you say in
German for cop-out it's um what's the
what's the good translation for that
hmm
out
did you guys hear him so it's a it's an
interesting excuse but it isn't the
solution in fact I hear the same about
training oh if we just had more training
well you know Jeff Pisa says you know
what we need is less communication
instead of more we communicate too much
it doesn't scale not at the scale that I
intend to scale this company and so the
idea is not to communicate more the idea
is to communicate less and you do that
through an architecture which doesn't
force people to have to communicate so
he decided they decided that they were
going to break the company into much
smaller teams and put those teams on
chunks of software that didn't have
dependency so they wouldn't have to talk
to each other they were relatively
autonomous teams as autonomous as they
could make them without dependencies as
much as possible and they were what Jeff
Bezos calls a to pizza team they could
be served lunch with two big Seattle
sized pizzas yes so maybe eight people
or something like that and they own the
whole service cradle-to-grave
idea design testing deployment
everything monitoring in production and
so you have these two pizza teams that
deal with all of those transactions
coming through at they might own a
shopping cart service or they might own
the recommendation service or something
like that so that concept of scaling out
rather than scaling up only works if you
are using software to manage the stuff
you used to have depend upon the
hardware or depending upon the dependent
upon the database so let's go on to
infrastructure as code and continue our
story because I just talked about scale
out you want to talk about
infrastructure as code is another
important hugely important thing
happening in software engineering so
have you heard of Conway's law most of
you have for those who haven't
it sort of says your organizational
structure and your system architecture
are going to match no matter how hard
you try not to your architecture is
going to drive your organizational
structure or your organizational
structure will drive your architecture
now if we go to Amazon that then broke
up into these two pizza teams they now
have an organizational structure that
drove their architecture so what
happened is these two pieces of teams
were supposed to be autonomous yes and
so they had autonomous teams and
autonomous means independent deployments
that's what I'm going to define it as
it's not I get to make my own decisions
as I get to deploy without having to
talk to all the other teams that's what
a kind of meant there which basically
created havoc in operations if you're in
ops and all of a sudden you had 50
million teams trying to deploy all
independent of each other and you hadn't
actually handled all the dependencies
this could be a real nightmare and it
was so Chris Pinkham who was the vice
president of infrastructure thought
about Amazon and thought about the
problem and said you know what we ought
to do we how to have self-service
deployment for development ease you know
instead of dumping all their problems on
us and ops we oughta let them handle
their own problem we will just give them
the code to deploy by themselves and he
said you know maybe we could even sell
this capacity and if you know anything
about Jeff Bezos who is the CEO there
you know that if you have something he
might be able to sell he was truly
interested it took a little while for
that interest to sort of percolate up
and then down again and meanwhile Chris
Pinkham went back to South Africa where
he grew up
and when they finally got to his idea
and said let's do it they chased him
down in South Africa and said say why
don't you put together a team there
where you want to be and see if you
can't make this idea work so he did he
assembled and led a team and in two
years they came out with ec2 elastic
cloud
Alessa compute cloud which was launched
in 2006
and as I say the rest is history here we
are 10 years later and Amazon Web
Services is making like about 10 billion
u.s. dollars a year or something like
that and growing lest you know I used to
say a billion dollars a quarter but it's
it's even more now and it all came from
this concept of these independent teams
that could do something that really
could be separate so if we think about
that then um I want to protect I propose
that there's a cloud in your future I
don't care if there's regulations to
keep it from being that if you're in a
bank or anything telecom or if you're in
medical area we're actually right now
there isn't a cloud there will be and
the reason is because from economic
point of view cloud is cheaper generally
speaking most clouds are cheaper more
stable more secure and more expandable
by far than most on-premise data centers
so if your IT Center is about cost and
it becomes possible to overcome those
issues of regulation and things like
that then there will be a cloud there
because it will just plain be cheaper
simpler more secure and so on even if it
isn't today it's almost certainly going
to be and then there's what's sorry
and then there's a technology so if
there's an let's say you're in a bank ok
banks currently are all on-premise or
sometimes hybrid and the stuff that
really really has to be stored on
premise stays there but right now GE has
a a cloud called
what's pretext that's right called
predicts which is an industrial clock it
can like for example manage electrical
grids it was the underlying technology
that managed the electrical grid in
London during the Olympics to make sure
that none of the venue's lost power
during the any of the events that were
there now if you can put IOT devices on
electrical grids or aircraft engine
which ge does to and send that
information to the cloud to some place
you have to be able to do it securely
that's what they do they do this stuff
with a high degree of security and they
do it
matching whatever regulations of the of
the governments that they're working
with so their cloud is probably quite
secure and matching regulations in
industrial areas and they have just put
a medical device cloud together which
which which passes at least all the US
HIPPA regulations which you know people
said couldn't be done but they figured
out how to do it so if you're in a bank
I'm going to bet that in a few years
some bank out there will come up with a
banking cloud which matches all of the
regulations and security requirements
that you currently think can't be
matched and then you go back to that
cloud will probably be cheaper more
stable more secure and more expandable
than what you happen to be working with
right now so the economics of it will be
incredible so I bet there's a cloud in
your future and not necessarily a hybrid
crowd because people are doing hybrid
clouds but the right use case for hybrid
clouds that really makes it the right
thing to do has yet to be discovered now
if you're going to a cloud you're going
to understand that the applications
which are designed with traditional data
architectures are not going to work very
well in the cloud because cloud is
distributed because a cloud wants to be
sitting on top of a bunch of say it's
like building a house on the sand
Pitts and you have to figure out how to
deal with building a house on the sand
when you're in the internet or when
you're in the club so the other area
they don't want to talk about is
infrastructure as code because that's
sort of part of this how do I deal with
the whole cloud environment because
that's what it is it's infrastructure as
code and you can do it internally but
eventually you're probably heading
towards some mechanism of cloud
containers as there's going to be a lot
of talks about containers at least one
or two I won't talk about those today
but containers are the thing that
creates a process which allows your
development to be easily put into a
secure standardized mechanism so when
it's deployed you don't have to worry
about any of the downstream stuff
thought works likes to call it a
containers a process that allows you to
have a secure standardized environment
and then there are service architectures
and I think there was talk about this
yesterday serverless is my kind of thing
because remember what I did when I was
doing software development was I was
programming pieces of equipment and we
didn't have this I mean our equipment
sent interrupts and we waited to listen
to those and we responded to them it was
an invent driven environment which to me
is a really comfortable place to be but
to a lot of programmers who are used to
procedural programming it's kind of
what's this all about but the idea of
being an inventor of an environment is
really important when you get into the
internet of things and most people that
are involved in server lesyk when any
type of sort of variation in response to
stuff out there in the world is finding
that's a massive economic advantage not
to have to have stuff sitting there
waiting for events to happen it just
costs a lot less and then
software-defined networks so forget the
network hardware anymore the there's a
really interesting paper by Google just
recently out on how they structure all
of their networks with software
more hardware anymore because it's just
not big enough it just can't handle the
kind of volume that they're heading for
so when you think about that when you
think about where the whole this whole
sort of cloud areas going there's a
whole new technology stack you have to
learn how to deal with back in the you
know 20 years ago timeframe we had a
thick client server app we had some you
know runtimes and some middleware and
some operating system and then we had
some monolithic database sitting
underneath it and today it's much more
like a sin app on a mobile tablet or
something like that it's a simpler we'll
assemble an assortment of the best
available services which will change
constantly and running on whatever
available hardware happens to be around
so if you think about that then the real
problem we have in architecture is a
dependency problem the fundamental
problem we're seeing in software
engineering from our history is we've
got this thing called a enterprise
architecture have you seen this picture
anybody
some people have right it's kind of I
was giving a talk to some enterprise
engineers so I went and looked up what
it was all about and that's what it's
all about good and Ana the problem here
is that there's this one database that's
sort of the magic integrator of
everything else but if you think about
it's also the magic dependency generator
of everything else that's what it is a
massive big dependency generator and so
it's a scale up approach and if you
really want to get big you can't scale
up you have to scale out to get
seriously big so you need a federated
architecture of some sort
not necessarily Micra services but in
any environment at all where you want to
be able to get really big you need to
scale out so you need some sort of
federated architecture where the data
stores are within the federated
architecture not some central thing that
everything together so this fundamental
concept of a federated architecture is
where we have to go in order to get rid
of the dependencies that are killing us
delaying our our deployments and all of
that sort of stuff and that's kind of
the architecture you need to have if you
want to move to the cloud and I don't
think although I'll bet you a bunch of
you are sitting on the left side today I
don't think you can stay there it's your
future has to be over over here where
there's some sort of federated
architecture so you need to learn how to
do software engineering not with
databases but with api's which means
they're just every bit as important and
valuable and subject to all the kinds of
constraints that our databases used to
be subject to all sorts of things like
you have to have good hardened
interfaces you have to have good
directories you have to have standards
by which the the interfaces change
slowly you have to versioning on changes
it's almost like just a different way to
look at the database but a way that can
be localized so if you think of api's as
architecture what they do is they enable
service architectures they lower that
integration friction because it's only
just between me and the other service
over there it's not me and all 50 of
those other services and they have local
persistence so our SQL databases are
rapidly being replaced by this stuff
that spreads across all of those
different files that you saw in Google
file structure instead of just one and
we don't worry anymore about we don't
have space to put it in our database we
have space we're going to worry about
our database later you know it's not we
know what information we need and we're
going to put it where it belongs as you
heard in the just before this talk we're
going to just gather it and put it up
there in some format and figure out
later how to deal with it and what to do
with it and those are just a whole
different concept then
the way that we used to think about
databases just a few years ago you can
also think about api's as a product so
API is as a product means an API needs
to be owned by a team who understands
who are the consumers of that API and
who focuses on it and who evolved the
capabilities of that API so if you take
a look for example at anything in the
Internet of Things this would be a nest
thermostat and it's got an API and then
I can use that API to put a mobile app
together on my Android phone and go and
deal with my thermostat or my iPhone or
whatever so the api's are the ones that
allow those little things in the
internet they they can own an API
against which you can put you know
whatever and talk to them so they're a
product and that's what makes them into
a product is their API connection to the
rest of the world um I find it
interesting that Carnegie Mellon which
has always been really big about what do
we have to think about in software
engineering in in 2014 they came out
with an article which is about software
engineering for big data systems now
what they said is big data applications
are pushing the limits of software
engineering it's essential that the body
of software architectural knowledge
evolves to capture the advanced design
knowledge for big data systems that's
where software engineering needs to be
spending time and if if you're thinking
about going thinking about research
thinking about what you do in a
university are you thinking about the
engineering necessary for really good
big data systems they said that big data
systems are inherently distributed
there's no option there architectures
therefore must explicitly handle partial
failures concurrency consistency and
replication
and any kind of communication latency so
they're sure to occur it has to be
handled in the whole concept of managing
big data they have to have architectures
that replicate data to ensure the
availability in case of failure and they
have to be able to design components
that are stateless because components
and instances get killed all the time
that are replicated and that are
tolerant of failures on dependent
services so we need to figure out how to
move architectural engineering this way
not just for big data but for sure for
big data so the last thing I want to
talk about in this whole area of the
cloud is resilience engineering because
now we have huge amounts of things
depending upon our software like for
example there were a couple of airlines
that went down in the u.s. for like a
whole day in July within two weeks of
each other one was Delta and one with
Southwest and they had a little glitch
so Southwest lost a router and it took
about four a day
and Delta lost him an electrical switch
in Atlanta and that's it's you know home
base and it turns out that in order to
fly an airplane you have to file a
report with the FAA Federal Aviation
Administration and so for any airplane
to fly anywhere this report has to be
filed and the only computer that could
do this happen to be hooked up to that
electrical switch that failed so the
entire system was down because one
electrical switch in Atlanta didn't
allow the flight plans to be filed so
where are we going to know when these
failures are going to happen if we try
to make everything a hundred percent
failure free we have to start thinking
differently we have to start thinking
about anti fragile instead so if you
want to see more about this you can read
Nikolas tell bum tell tell abut the
whole concept is that there are things
that are fragile like glass and there's
things are they're robust like swords
and then there are things the
get better when they're attacked like
for example a month ago I had a flu shot
every fall I have a flu shot and to put
these bad things in my body so that it
gets stronger and I don't get this I
don't get sick much anymore ever since I
started doing that so the whole idea of
adding bad stuff to make stuff better is
what anti fragile is all about so if you
look at the the classic women of met
flicks with their simian army they do
stuff all the time from small every two
hours I'm going to kill an instanced I'm
going to add Layton sees to their chaos
gorillas which takes down a whole Amazon
region every so often just to see how it
everything responds so when you think
about testing you also have to think
about Netflix think about the real test
is whether or not your system your
software can survive in production with
all these chaos monkeys and things like
that
killing instances and making sure that
things still work and the ultimate test
of good is whether or not that's that's
the way that the ultimate test of any
team's good is whether or not any of
their services fail when any of these
gorillas come in and or monkeys come in
and kill them so to sum up software
engineering in the cloud and where I see
it going we gotta move to federated
architectures there's just not like
going to be an option it's going to be
cheaper better way faster to deploy and
it's going to be necessary because
you're going to go to the club
we have to start thinking about the
database stop thinking about the
database as the integrator anymore and I
still reading stuff in in McKinsey and
and Gartner about how the database in
the ERP system is the integrator it's
got to stop being the integrator okay
that's like so last decade we need to
think about how we connect with api's
across multiple different concepts of
way we store data we have all these
stateful protocols but when we start
getting into anything that's going to be
out there like the Internet of Things we
have to think stateless because when you
get on the cloud stuff dies all the time
and it will lose stake so what are you
gonna do about it if you're depending on
it we have to stop thinking about
consecutive execution and think about
stuff happening concurrently and we
don't actually know which race condition
is going to win I can remember that race
conditions are one of the biggest things
I had to deal with when I was
programming equipment and you always
thought about which one's going to get
there first you don't know so instead of
synchronous communication like talking
on a telephone we have to figure out how
to do asynchronous communication like
text messaging okay the other person
doesn't have to be there until get they
get around to answering your text we
have to figure out how to do
event-driven programming as I said to me
that's like natural because it was the
first way I thought of well maybe the
second or the third way I thought about
programming but when you have big pieces
of equipment it's still kind of very
obvious but I've been told it's really
hard for people to think about
event-driven programming well if you
know trust me it's not so hard you just
got to change switch your mind a little
bit
instead of procedural programming and we
have to start thinking about forget
about defect free forget about because
that means we're fragile we have to
think about when stuff happens how
resilient are we how fast can we recover
how small can we limit the blast radius
when stuff goes down because it's going
to go down so this is like an artifact
of the enterprise like
see stuff and this is more like what you
got to do to be involved in the internet
of things and when we get this stuff
working right then we're going to be
much further into the future than we
were now it's not the end of my hour so
I'm going to continue on with something
else
but it's about the same thing so this is
Germany and I've been told actually I've
observed that people like process in
Germany so this whole whoa how do we
deal with all of this uncertainty
becomes what process can we apply in
order to get our hands on this so I
would like to talk about DevOps this is
a book that's not a month old and I
actually not sure you could get your
hands on it yet I have I've got my hands
on it and I read through it and I like
it a lot it's by Jean Kim and just
humble and Patrick / in John Lewis and
it's about the three ways Jean Kim wrote
the Phoenix project about DevOps and
this is sort of like the handbook behind
it lots of how to's and in it they
emphasize these three ways the three
ways our flow feedback and
experimentation and learning so the
other part of this talk is about flow
feedback and expert mentation and
learning because if you're going to make
this stuff work you have to figure out
how to make that process work
so there's one thing that we know for
sure absolutely for sure when we have a
complex system it doesn't matter if it's
a weather system or you know a heating
system or software system here's
something that does not work when you
take a complex system and you smash it
you have no idea how it's going to
respond guaranteed all bets are off you
don't know the interconnections you
don't know the unintended consequences
you don't know exactly what's going to
happen and try as you might to test it
you can't figure it out so what does
work what works for complex systems is
this
and there's an awful lot of experience
showing us that this is the way to make
sure we have secure stable complex
systems that don't crash as we poke them
instead of Smashing and we respond to
whatever happens with that small
contained poke so because of that sort
of the landmark thing that happened in
2010 is Dave Farley and just humbles
book on continuous delivery and if you
haven't read it you should and maybe you
should be going to Dave Farrelly stock
if you haven't heard it because this has
change the way we think about software
development process it's just had an
amazing impact and this is pretty much
the process you need to be thinking
about if you want good stable systems so
what is this all about it's about making
sure that your process is driven from
acceptance tests that are executable and
that you write code to pass those tests
it's about making sure that you have
cross-functional or full stack teams
that include the full stack of people
necessary to do that particular thing
you're trying to do product has to be
there QA has to be there obsessed to be
there yeah few doves - it's about
automated everything build testing
database macwrite migration deployment
you name it it's about deploying to the
trunk it's about having no branching how
many here have branches
okay then you're not actually here yet
but it's about not having branches Wow
now if you have 30 you get three you
know you've made a big step but in the
end you want to have one single trunk
that you're continuously integrating to
and that software is always production
ready or you get you get a fixed right
away top priority
sound terrifying that's where you need
to go and you deploy all the time
constantly differing by domain but
deployment and release are not the same
thing you release by turning something
on with a switch you deploy all the time
the code does not have to be live until
you turn it on but you deploy it
constantly so if you think about that as
a deployment pipeline what you have is
something that's going to be faster it's
going to be safer and it's going to be
better I mean what you had before and
this needs to be the process you think
very hard about heading towards the
second piece remember the three ways
flow feedback the next one is feedback
and I propose you need end-to-end
feedback you need yes to see what's
going on in production with monitoring
systems but you also need to see what's
going on when the code is deployed with
your consumers and get that feedback
straight to the people who are making
decisions about what to do next who had
better be on the team
because this is a fast process so we
don't have anymore
outsourced design
there's research to show that the
product manager is wrong at least half
the time and I put the reference down
here you can get these slides and look
it up and actually if I talk to product
managers they say yeah actually this is
true so how do we not do everything that
we're asked to do because clearly half
the time it's just a guess well it's
always just to guess and you could flip
a coin to decide which have to take just
as easily um or if you take a look at a
spec that somebody's given you like a
government body or something like that
probably two-thirds of the features and
functions in the specification are not
necessary don't need to be there okay
and so it's just better to be lazy and
only do that one-third or less of the
work that actually is going to provide
value than to do everything in the spec
so we should not be outsourcing design
to somebody else that tells our teams
what to do we need to move from delivery
teams to problem solving teams so
delivery teams get instructions take
orders you know somebody gives them the
you give them a menu and they they give
you the order and we have to move to
problem solving teams seems to have
everybody necessary to take a problem
not a solution but here's what the
consumers are trying to accomplish here
is the job that they need to be done
here's the metric we need to move in a
different direction see what you can do
with it and we need to have problem
solving teams that address that kind of
question rather than teams that are that
are told what to do so if you look at
the experimentation and learning process
I promised you a process here it is
you start with signals not requirements
you have a problem statement not
features you want to focus on what are
the problems we're trying to solve and
problem statement isn't easy you plan
with hypotheses not estimates it's not
clear to me anymore if you have problem
solving teams what good estimates do
anybody you do have to know that you can
solve the problem within the constraints
and given that the rest should be up to
the team here's my constraints here's my
problem if you can handle it within
those constraints usually of time and
money
then go ahead and do it your way and so
we don't want a backlog of stories we
want multiple experiments we're going to
run against the hypotheses and we don't
want guesses we want analysis and
conclusion so this is the standard I
don't know scientific method the
engineering process and if this process
does not underlie the process that you
use today then you should be asking
yourself why not because in our world
with our uncertainty this is the only
process that works now scientists have
been using this process for hundreds of
years it's actually not such a bad
process but it's time we got there but
one of the hard parts about this process
is the first part what problem are we
going to serve solve and what kinds of
hypotheses our rational hypotheses to
take out so right at the end here I'm
just going to take a couple minutes to
talk about a process that I've run into
recently certainly not the only one out
there but one that I find pretty
interesting and it's called the Google's
ein sprint it was introduced in 2014 at
the Google i/o conference an interesting
conference about it's more a design
conference than it is a development
contest and it's a process for figuring
out how to prototype and test any idea
in five days
okay which means before you actually
code it's described pretty well in this
let me go through it it starts on the
first day where they everybody get on
the same page how do we do stuff what's
the problem we're trying to solve here
are the issues here the constraints and
then the second day there's something
I'll talk about in just a little bit
more but it's about H individual
sketching out quietly their own ideas
about how to do it and then sharing
under the guidance of a designer because
it's a standard design process and then
sharing those ideas on paper so that
we're not dealing with brainstorming
that has been proven to brain starving
has been proven to make sure that the
people who are loudest or most in
command of the language or whatever else
it is or the most like everybody else
are the ones who get their ideas heard
so instead we want a process that allows
lots of different ideas from quieter
people and from the people who are not
so comfortable talking to get their
ideas too and then there's decide which
one is ones of these ideas and there I'm
going to talk about not voting because
voting again suppresses minority ideas
and then you do a very quick prototype
you've got some designers there they put
together something really quick it's not
code it's maybe keynote or you know
PowerPoint or something like that and
then on the fifth day you have a few
users come in and actually test out the
idea with an interviewer walking them
through some stuff rest of the team
watching from a remote screen seeing how
things go and finding out how that idea
plays with at least a few people so
that's the general concept here and here
it is book on it where you can get a lot
more information and I'm just going to
do a quick video of a summary of it in
business development time is a precious
resource why are you wasting it to be
more efficient and responsive Google
Ventures created the design sprint the
process for answering critical business
questions in just five days
the first day of the sprint is for
sharing information between departments
and creating a simple user journey day
two is sketch day where the team works
individually to generate creative
solutions to the problem
on Wednesday the team looks at all the
solutions and decides on the best
approach
create a visual storyboard and you're
ready for prototype Thursday it's time
to get productive and build your
prototype on the final day you test your
idea on real people to see if it has any
value if it does high fives
you're on to something great if it
doesn't well you've learned something
and the cost is only five days so stop
wasting your time and compress the
endless debate cycle into a single
design sprint week so um two things
about the design sprint I'd like to
quickly point out here if you find it
fascinating and one is the idea
generation on the second day is really
interesting because it's having
individuals not compete with each other
to get their ideas heard right from the
beginning but allowing those fragile
ideas to be developed by individuals
slowly until it comes to some detailed
thing that they post and then that's
reviewed by the group well without even
knowing whose ideas are which because
there's a thing called conformity bias
one of Linda's biases yes Linda and it's
about the idea that people who think
they are in the morning will in the
minority will self silence or change
their opinion and then that makes it
even harder for other people who have
minority opinions to have opinions so
the idea is to find a way for people to
get their ideas exposed before they have
to worry about if they're in the
majority or in the minority and in a way
that doesn't require them to be the
loudest person or the most you know
forward person or the it's okay if
they're a little bit different than the
rest of the group but I don't agree with
the way that they talk about doing this
the third day because then people vote
and I'm not actually so fun to voting
you might figure
why but uh at 3m where I worked for 20
years we didn't vote on product ideas we
attracted people to product ideas so we
explored a lot of ideas which you should
be too because then the holy Nydia is
not don't settle on one idea try a whole
lot of them and make sure they're from
the whole design space including some
outliers which means if you vote the out
lawyers aren't going to make it and so
you want to pursue a variety of ideas
and if she has an idea and can attract a
couple of other people to try her idea
out why not let them they don't have to
be in the majority they can just be a
few people that try their ideas that's
how almost all of our really innovative
product teams worked if a champion could
attract a few other people the idea got
explored until either didn't work out or
it did work out you gradually narrow the
ideas to the ones that are going to work
and you want to maintain multiple
options for as long as possible before
you settle on something don't just
choose one thing and go with it so to
sum up the future of software
engineering first of all there's going
to be a big technical advance that's
there we can see it now
it's about scaling up it's about
infrastructure as code it's about that
whole new technology stack that's
sitting in the cloud and having a
different way for us to think about
programming and think about security and
think about reliability and resilience
and then there's the three ways of
DevOps sort of expand it to make sure we
think about the whole product not just
Devon ops but the whole thing so we want
to think about how do we get a
continuous deployment pipeline how do we
put together full stack problem solving
teams
okay and make sure that we're doing
experimentation and learning all the way
through our development cycle so the
future is here actually it's just not
easy to see not quite so evenly
distributed but if you look around
you're going to find futures you know
even in our sessions throughout the rest
of the day so thank you very much
we have time for two questions if you
have a question please come forth to the
microphone yes
hello thank you for your talk I have a
question regarding the first part of
your talk where you are talking about
the trend away from monoliths and more
towards distributed systems I'm afraid
that a lot of developers who are looking
at what the big companies are doing and
who are attending talks like these will
then try and solve problems they don't
really have and over-engineer their
solutions like for example using Hadoop
when they only have a few gigabytes of
data or a small team that deploys
thousands of micro services where a
monolith may be the more economic choice
right what do you think I think there's
there's never any here's the final
answer like everybody move here you need
to know where the trend is going and
where you eventually need to be but if
you don't have a smart way of getting
there if all of a sudden you think you
can jump there without any learning at
all you're almost certainly wrong so for
example if you're in a bank your bank
has to be scared right now because
there's so much attacked on the fees of
banks their basic income from all kinds
of fintechs all over whether it's
mortgage fees or any kinds of fees so
they quickly want to do something but
it's not easy to be quick because the
back end is really hard to break apart
and how do I combine it with the front
end so thanks didn't have front-end
teams and they can do whatever they want
and back-end teams are there slow as
they always were which means they can't
get much change done because almost
everything in the front end depends on
the backend and so there needs to be a
solution but maybe the solution isn't
tomorrow we can break everything apart
and start over again because we've
already got a business to sustain so you
have to figure out how to migrate and
that's going to depend on the context
that you sit in it's not going to depend
on how that company over there did
something they're different than you one
thing you can be sure of is if you take
that company's solution it's their
solution to their problem it's probably
not
your solution to your problem so you
need smart people that can think and
figure out given the trends what's the
right mechanism to get to the proper
solution for us in the future remember
everything out about Hadoop took five or
six years at Amazon the mic the service
orientated architecture took five or six
years every one of those things took
that long to go from an idea to actually
develop at scale and if you think you
can do it in five months you're crazy
and I'm going to happen so you know stop
dreaming make sense thank you okay let's
let's take another question from from
the app I have a lot of questions here
I'm sorry I can't ask everything do you
what do you think about the role of
regulation systems like governments or
national laws in the cloud Federated
world well the the there will definitely
be national government regulations
doesn't matter if they're good or bad
they are not going to go away so what I
observe is that the people that are
sitting in the clouds learn how to
understand those regulation systems
learn how to understand security
concerns and learn how to deal with them
and so that's another reason however way
I think the cloud will eventually become
the thing of choice because they're
currently the regulations are
complicated to navigate country by
country and if you have your OneSource
figuring it all out might make more
sense I know in the u.s. a bunch of
people are moving many of their personal
much of their personal data to European
data servers called cloud servers why
because the laws here are much more
protective of individual private data
than they are in us so if data sits on
servers here it's much more protected by
regulation so the the clouds that people
are figuring out what the regs are and
how to deal with them I think that GES
predict system is really good at that
and other cloud vendors are learning so
they'll have to figure it out but clouds
can be in a lot of different places
okay and they will have to deal with
whatever the regulations are thank you
thank you very much Mary for this
keynote
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>