<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2014 • The Functional Final Frontier • David Nolen | Coder Coacher - Coaching Coders</title><meta content="GOTO 2014 • The Functional Final Frontier • David Nolen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2014 • The Functional Final Frontier • David Nolen</b></h2><h5 class="post__date">2014-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xeEojV8K7Lk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so the ad is to talk with
a functional final
what this talk is called it's gonna be
somewhat related to that but I think I
want to give in this sort of variation
of this talk some wider context and
actually this talk could be called you
know immutability interact interactivity
and clojurescript but honestly it could
be called immutability interactivity and
insert your language of choice it
doesn't really matter the thing I'm
ensured here is communicating the
principles not any specific language so
I until recently was employed at the New
York Times for about four years doing
front-end development there and that was
a lot of fun my background is in doing
user interfaces all kinds of user
interfaces I've done user interfaces in
cocoa and Java and C++ and but I spent
the most time doing them in JavaScript I
now work at cognate echt and I'm excited
about that
cognate X a fun place because they're
probably of all things they take the
mutability as like a sort of central
tenant of all the things they design
both you know there's sort of stewards
have closures the language which
embraces immutability as well as a
pretty interesting database solution
called atomic which also emphasizes
immutability but I want to talk more
specifically about immutability in the
context of user interfaces so
object-oriented programming a user
interfaces sort of came to be almost at
the same time I mean objects did it sort
of appear in the late 60s but we really
wasn't until small talk until the
variant that we're more familiar with
came to be and at the exact same time
the modern user interface also came to
be this is an image of some kids playing
with a small talk system as you know at
Xerox PARC if you you can fire up a
small talk image today there's a very
fantastic open-source version of small
talk called squeak you can install it
you can write small talk in it if you
open up the system browser which allows
you to see all the classes that are
involved in the entire system you would
probably encounter the words Model View
controller right
so that's that's pretty wild though so
it's you know that's I don't know that
image was the the kids is probably from
the mid 70s so that's 30 years of MVC
and people have code opted this term
when they're talking about web-based
systems as well but basically the idea
was first familiar by trig Vereen skog
and Adelle Goldberg at Xerox PARC in
1979 and it's had an extremely long
shadow the basic concepts are still
prevalent today if you're doing
front-end development
I don't doesn't really matter if you're
targeting iOS Android JavaScript MVC is
a very popular way to organize use
interfaces and that's because I think at
a very abstract level MC MVC is a
extremely sounds separation of concerns
but implementations leave much to be
desired
we haven't really advanced much far
further beyond what they came up with
that Xerox PARC which is pretty sad
given that's 30 years old and the the
thing I'm gonna question here is I
believe that we can get all the benefits
of traditional MVC systems but we can
eliminate this thing that I do not like
about the implementation which is that
embassies are constructed on top of
staple objects and you're probably
thinking how could you do that how can
you get all the benefits of NBC and
eliminate something that almost all
modern embassies have which is that
they're constructed on top of stateful
objects so to throw our wrench in this
history of UI programming though which
it plays into this talk because we're
gonna be sort of emphasizing web
browsers is Tim berners-lee invented
this thing called the web browser in the
late 80s on a next machine so next at
the time had one of the most powerful
MVC frameworks next step it eventually
became cocoa which is also now everybody
knows about because of iOS but he he
took this rich MVC desktop system and he
built the world's first browser web
browser and the idea behind web browsers
was not I want to build rich user
interfaces I want a hyperlink documents
over a network that was the only thing
it was meant to do
hyperlinked textual
documents which are rendered right there
was no there was no point in solving the
rich user interface issue here that's
not that wasn't that wasn't a goal it
was a completely non goal so I don't
think he first saw a future where most
people interact or not most but many
people interact with the web through the
document object model if you've done any
if you've done any serious work on the
web this is more or less why your life
is terrible
because the document object model is
fundamentally about documents it was not
about user interfaces is not about
events I mean these things are just not
meant to they're designed the Dom was
designed to solve a different problem
and so when I look at the sort of the
landscape of what people are doing with
web browsers and the DOM and JavaScript
you know it really feels a lot like this
right
Alan Kay has this really great analogy
ray says software architecture too often
looks a bit like the Great Pyramids
right it's very impressive to look at
but there's no deep conceptual route
like idea here is that you know it's
going to take thousands of people
hundreds of years to build right so
often software feels like this and the
and he makes this interesting claim that
often what's missing from software
development is one tiny simple idea and
then you can have a radically different
architecture you can have a much more
efficient placement of architectural
material and he points out that it was
the arch right this extremely simple
concept permitted humans to build a
completely different type of building
and so I think you know we're gonna
DUI's we're looking for this arch I
don't think we've found it yet MVC is a
good starting place but I think there is
something missing so object-oriented
programmers got their chance they came
up with MVC
that's awesome but we need something
more and so maybe we should look at what
the functional programmers are doing so
there's a thing called functional
reactive programming FR
it's still a very active area of
research if you're into Haskell you
would have heard of this it's fairly
academic and they have lots of problems
they still need to solve to make that
work there is a stateful object-oriented
take on this which is getting really
popular now called Rx from Microsoft rx
Java rx cocoa all this stuff the just
it's the object-oriented take on FRP
it's very interesting definitely awesome
for coordinating events and complex
asynchronous workflows however it
doesn't really solve the problem that
you eyes encounter which said how do we
deal with the fact that the end at the
edges of our sort of system we have to
render something the user has to see
something if you're coming from go the
go programming language or if you're if
you're into closure closure dressing
this thing called core async then you've
probably heard of CSP this is Toni
whore's abstraction but again it's also
a coordination language it doesn't
really address the rendering problem so
you might be thinking well maybe MVC is
it maybe there's nothing more maybe
maybe we're just stuck with stateful
objects and we have to sort of erect
these pyramids of user interfaces that
are hard to modify hard to extend hard
to maintain maybe there is no arch and I
and I would argue from from having
played around with closure for a long
time and this is probably old hat for
for people who've played around with
Haskell or Scala but there's been an
amazing amount of incredible practical
academic research gotten into something
called persistent data structures which
I'm not going to assume that you guys
have heard of and I want to talk about
them now because I think they give us an
opportunity to simplify the coordination
of state and user interfaces right which
i think is the the main source of
complexity and a complicated user
interface is that you have lots of
stateful components how do you
coordinate them how do you know who's
changing the state and I think
persistent data structures can sort of
make this tractable so I'm going to show
some slides these are not my own slides
about how persistent data structures
work just to
you sort of a sense about how I'm able
to come accomplish from about to show
you these slides were done by Zack all
in a packer school which is a really
awesome sort of like coders like a code
writers retreat in New York and so
stealing his slides so functional part
gave me in data
functional programmers like data they
like immutable values not mutable
objects whenever you change of something
change right all you mean is you're
going to modify something to get a new
value you're not going to change the
original things so it's not like you get
an array and you mutate the thing at the
second index the old value that they
represent is now gone forever we don't
like that so this is where the word
persistent comes from and the cool thing
that I'm going to demonstrate is that
starting in the early 2000s because of a
paper by phil Bagwell we now understand
how you can do this efficiently so I'm
assuming everybody's seen a linked list
and you might be saying that's so boring
that's like you know data structures 101
but linked lists have a really cool
property if you treat them in a mutable
way that's that demonstrates how
persistent data structures work the ones
we use in closure and the ones that are
used in Scala and Haskell so a linked
list you've got something at the head
and it points to other items in that
linked list
well the neat thing about a linked list
is if icons if I if I have a new head
and I point to X what's cool about this
is I have two distinct values right but
these two distinct values actually share
three elements right they're actually
sharing memory here so even though Y
represents the the the list with the Y
on the head represents a particular
value it didn't destroy the value that X
represents now you could imagine that I
could get the tail of X and then cons Z
onto the head of that and now I have
three distinct values but they all share
more than 50% of memory right this is a
really cool property of linked lists
structural sharing so sharing structure
gives us space efficiency
but it also gives us computational
efficiency when we update something it
means that we can update something
without having to update without any new
copy-on-write so this is a traditional
technique is that if I have some data
structure and I want to update it and I
want to appear to have a mutability we
simply copy the whole thing of course
when you get to like a million million
elements right that's not efficient so
persistent data structures allow us to
update a large data structure in a
functional way and we're going to
minimize copying and that might not be
obvious how to do that and I'm going to
show you so fill Bagwell who sadly
passed away hat came up with this thing
called the hash array map try he wrote
this paper in like 2002 at EPFL where
Scala was created and he had come up
with a mutable variant rich Hickey read
the paper was like this is fantastic
just by tweaking it a tiny bit we can
create an immutable variant of this data
structure so I'm going to show a simpler
version a simpler variant not the hash
array map try because it's a bit
complicated but I'm going to show you
how we can have an immutable array like
type so it has all the properties we
liked about arrays it's random access
like an ArrayList you can if you can
append to the end efficiently you can
you can you can split them efficiently
and so on so so the idea here is that
data lives in the leaves and the way
that what a what a bitmap vector tree
really is is just a tree of arrays right
it's just a tree of arrays and it's
going to be a prefixed tree that we use
to find any particular element but it's
going to be a bitwise prefix tree and
let's see what that looks like so let's
pick some arbitrary size for our nodes
arrays with four elements in them so
each each element of that array points
to another array of the same dimension
each array of that points to another
four arrays of that dimension and then
finally we hit the leaf nodes where our
values live and here we just have the
numbers representing the indexes
right so how do we find something in
this and we said it was a prefixed tree
so get index on that so imagine I want
to find the hundred and sixth element in
this in this representation well that
number has a binary representation and
we can mask off the bits to get to where
we need to be we mask off the first two
bits this is the index 1 so we descend
down here we mask off the next two bits
that's index 2 it's 2 again and it's
finally two right so in order to get
there what did I have to do I have to do
three array lookups and some bit masks
this is this is stuff that the JVM and
modern JavaScript engines this compiles
down to into you know x86 instructions
this is going to be very fast so what
about updating so if I want to update
what do I have to update I only have to
update the route and any nodes on the
path to the thing I need to change and
here I'm going to up to replace 106 with
the string foo
all those other nodes right they're not
going to change and then you're probably
thinking well that's you know what four
to the fourth what is that so that if we
if we have the vector and the node size
four we can hold 256 elements so that's
that seems ok so as it turns out if you
do a bunch of empirical testing 32 is a
great size it's a size in which lookup
and updates are sort of an optimal ratio
this is an image from a bag well paper
that took Rich's variant and they
further extended it just to give you a
sense of how good 32 actually is imagine
a persistent vector which has 32 levels
of note are sorry seven levels of nodes
where each element is 32 wide that's 32
to the seventh power
that's 34 billion elements on a 60 even
if this was a flat array on a 64-bit
virtual machine if every element was an
object pointer that's 256 gigs of RAM
right so to update a data structures
this huge we only have two at most do
seven bit operations and seven array
accesses to update anything in this
massive data structure we only have to
replace seven arrays so hopefully this
has convinced you that that structural
sharing is really awesome okay so now
you get the idea so this is how this is
how we're gonna be able to play this
game so now that we have the data
structures that are suited to represent
immutable values we can do some really
cool stuff with user interfaces and so I
wrote a library called ohm and what I
did was I said we can couple in this
case closure script which has a suitable
persistent data structure library and we
can couple it with with react and react
is a relatively new on the scene a
library for rendering it doesn't really
do MBC it's very much focused on
rendering but the way that their
algorithm works is extremely suited to
pairing with persistent data structures
so the way that react works react is
sort of like when you use it you're like
this looks object-oriented but actually
it's object-oriented as if a functional
programmer had to write a library in an
obdurate and style so what effectively
lets you do it lets you take your data
which you can pretend is assumed as your
app state you can apply a function and
then react will generate more data and
this is what's called the virtual Dom so
react doesn't actually change anything
it creates creates a new data structure
so if I have some data it's not at time
0 and I apply a function I get the data
search that represents my interface at
time 0 now if I update the data we don't
destroy the old data right we're not
destroying the old data we're simply new
data that represents the new state of
the application at time one I can apply
the same function and now I get the UI
at time 1
so what react does for us is it
calculates the diff
takes the to virtual representation with
the UI should look like and it
calculates the minimal set of changes to
actually make to the DOM and it does
this efficiently it's like it's lazy and
the sub-tree calculations are only only
looks at what it needs to look at and so
on but what's cool about this is what
happens if I flip v-0 and v1 react will
for free give me the reverse set of
changes right it's just free because
that's just the way diffing works right
so I can go back in time and I don't I
don't have to write any code for this
react just gives us time travel by
definition by the way that it works you
might be skeptical I'm going to show a
demo and the demo is pretty cool so so
really what it does is your component
tree looks something like this and and
though and react and the way that react
makes diffing tractable is that they
simplify the the what gets diff so you
can imagine the blue guy as a div and
here we see oh it's a div in one and at
time zero and it's a divot at time one
and we're like well nothing's changed
there then we descend into the children
and we see oh now we have two paragraph
tags well they don't look different and
then we descended in the children and we
see oh there was a there was a span and
then a font tag but they switched places
and so what is what is what is their
algorithm do it simply knows to move
those two Dom nodes right and so again
but again this should show you that we
can go in either direction either
direction right and it's driven by data
so let's see a demo of this so once I
realized that that persistent data
structures and react to a good pairing I
was like I wonder how hard it would be
to do undo so I've been doing MVC style
programs for a very long time and I
really hate doing undo if you've ever
looked at Cocos undo manager if you
number one it's hard to get right even
if you plan for it upfront retrofitting
undo onto an existing object or Ian
good luck that's you know whatever it's
not going to happen
but if you start off with a functional
model you can you can I
added undo so I took the very sort of
traditional benchmark NVC application
which is to do MBC it's not very
interesting but I said how hard would it
be for me to add undo to an existing
system and so basically there's like
five this is like five lines of code I
wrote five lines of code I had an
existing version of to do MBC in ohm
already so I wrote five lines of code
and then I got I got this so here I can
go go to go to so I can click here I can
switch tabs I can clear completed like
this I can I don't know why you would
walk a cat but just for fun so up here
you see that it's not slow this is far
faster than 60 frames a second so you
know 60 frames a second is like 16
milliseconds so I can click undo that's
it and I didn't have to plan ahead for
that right there was no planning ahead
for this this is this is false
completely out of saying I'm gonna
represent my app state as with
persistent data structures I'm gonna let
react calculate the the changes to the
Dom so you might think well undo who
cares about that it is actually pretty
cool but maybe your app doesn't need
undo but think about error handling what
happens when you when you can't
communicate to the server and you need
to roll back so what do you do I look at
somebody's program and see oh they had
to manually roll back their app state or
say a customer has an error right what
can you do in this model you can
actually you can actually serialize the
last 50 steps send it to your server and
play it back it's trivial right you
don't have to write code to do this all
these things that we want to do around
error handling and rolling back these
also fall out of the ability to travel
freely through time so I
talk more about things that I've done
but I think it's more fun to demo
something that somebody else did so this
was a from one of the developers of
Ableton Live he sort of ran across my
blog post and he was like okay that
sounds cool here's a little toy toy NBC
app and it has undo and he said I'm
gonna do something less toy like because
I don't really believe David Nolan he
seems smart but this seems like this
seems like too much magic so he said I
want to build a 64 by 64 pixel editor
and I wanted to see how much effort it's
gonna take for me to add undo redo and
then like a time-travelling preview
right to my app and will it still be
simple so here we've got his pixel
editor so this is his I did not write
this this is somebody else so I can I
can pick some colors here I can draw a
little circle over here on the right you
see all the events piling up like this
okay so if you notice on the left I can
scrub and it's and it's just it's going
right back over the time line we can
move forwards through time so this this
image is actually a persistent vector
that has 4096 distinct values right so
he's encoded 4096 individual pieces of
application state right so between each
step you would assume we'd have to
replicate all four hundred 96 96 values
but I explained you up resistant vectors
work it's not true so even if I even if
I click even if I click like this and I
just I'm dropping like this right the
difference between this one and this one
it's it's like again maybe it's maybe
it's four or five arrays right if
there's not there's not much difference
um persistent data structures naturally
represent the Delta pretty cool stuff so
he's also able to here he has this
really cool thing where because it's
encoded inside of um inside these
persistent data structures doing things
like producing an animated gif from what
I just drew again trivial trivial to do
well in you're probably wondering well
how much code did that take so this is
the entire this is actually all the code
it's like less than 50 lines this is the
whole thing you can almost if you're if
you're if you're in the front row you
can actually read it and I think that's
pretty amazing this includes undo redo
and the the time-travel preview so I
think that's a that's a pretty awesome
radical decrease in complexity if you've
ever done undo before much less than a
pixel editor you know it's not very fun
what's also cool about this is that like
you're probably thinking well how much
memory does this really take maybe and
maybe you're like okay this sounds like
it's gonna be good but really how much
memory does it take so
I made a little I made a little a little
memory test using the chrome developer
tools heat profiler and so on the on the
snapshot the application right when it
starts and and it starts at about 3.8
megabytes of memory being consumed on
the right what I did was they said well
I'm gonna take a JavaScript array I'm
gonna stick you know 4096 sized array
I'm gonna stick strings in it and I'm
gonna change one value of course with
the JavaScript array all I can do is
copy it every time so copying it 100
times with a different one a different
value everywhere that consumes about 1.7
megabytes of memory to hold a 100
distinct pixel images on the Left we see
that doing the same thing with a
persistent vector 0.2 megabytes right so
I don't know what's that times 8 9 it's
9 times almost an order of magnitude
smaller the amount of memory being
consumed that's pretty cool so efficient
in time and space so I don't have I mean
I if you haven't seen own before I
definitely recommend checking out it's
available on github I don't know how
many people here are familiar with
called your script or closure though
these ideas are extremely portable to
other languages for example I know that
the Scala guys are using Scala j/s and
Scala has very good persistent data
structures I've seen some awesome demos
where Scala j s+ react works great even
if you're a JavaScript programmer you
can do what I'm demonstrating so there's
a fantastic not we're not fantastic I'm
just my library but it's just exporting
closure script to be consumed by
JavaScript consumers so maybe you're in
JavaScript and you can't or maybe you're
in CoffeeScript
right I don't know what you're using but
you want the data structures but you
don't want have to adopt the language so
Mori exports in a very underscore like
way all of the persistent data
structures as well as the entire
standard library for manipulating them
so quite a few people actually I know
are actually using Mori in their
client-side apps because they want they
want to be able to pair react
with immutable data structures because
again react gets a lot better if you
pair with immutable data structures so
that's actually all I had today I think
I'll take some questions
does this work with and we see
frameworks or is this instead off using
an MVC framework so that's what I was
trying to suggest so you can just you I
know people are sorry the question was
does this replace MVC frameworks or can
you use it with MVC frameworks so they
are in some sense or orthogonal so what
I'm saying is like you can do you can
have the MVC architecture you can still
have models which represents a domain
you can have controllers which
coordinate between a view and the domain
that's fine but instead of having
mutable models are mutable controllers
and mutable views this is how you can
replace every part of that stack with
immutable immutable things so people
have played them on with ember I've seen
some experience with ember like you got
ember plus an immutable model you you
you can do this again it's more it's
going to require some unlearning though
right there are a lot of things that
people do in these traditional systems
are like kind of are swimming the wrong
direction
sorry disappeared so who owns the model
of the MVC framework obviously has its
own copy of the model and this is
keeping a version history of those
models our how are there two systems
interacting with each other so those are
those are orthogonal right so what I
tried to demonstrate with what I was
doing is that I was able to build the
two DS to do MVC application the undo is
a separate thing the work that's
completely separate if you don't want
undo you don't have to do that I think
there's somebody behind you you
mentioned at the beginning that you had
tons it's cocoa iOS and certified and
Mac have you tried or have you thought
about if it's possible to sort of apply
this to sort of native mobile or other
frameworks so it's definitely worth
experimenting with because so the
question was has did has this been
applied to like Android or iOS so it's
definitely worth experimenting with in
iOS it's a bit easier to actually just
use react but that's because um OS 10
and iOS 7 OS 10 mavericks and i always
have an now export JavaScript core so
that you can directly bind from
javascript to native a directive c so i
think there's a lot of cool things you
could do there by literally just loading
react and having react manipulate
Objective C objects
is there any sort of case it really
aggravates the behavior of the of the
react rom structure are the things where
you would definitely stay away from it I
mean so it does I mean it's it is like
it is pretty intensive I will say that
like it benefits from fast you see
definitely the same as closure it
benefits from JavaScript
engines granted I mean a ton of work is
going to react to make it work even if
those things aren't present and same
with closure script we test on slower
JavaScript engines but it's going to be
slower than like mutating array if
there's something you're doing where you
just need to like mutate something do it
in fact in fact the the pixel-based
editor what does it do when it Blitz
right
it's just mutating the canvas we don't
we don't need to get in the way of that
so part what I'm suggesting is that this
works best when you when this is your
domain use your model don't you don't
need this for like high-performance
algorithms does that answer a question
and thank you very much David thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>