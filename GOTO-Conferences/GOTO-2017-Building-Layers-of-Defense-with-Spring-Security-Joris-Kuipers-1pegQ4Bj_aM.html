<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • Building Layers of Defense with Spring Security • Joris Kuipers | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • Building Layers of Defense with Spring Security • Joris Kuipers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • Building Layers of Defense with Spring Security • Joris Kuipers</b></h2><h5 class="post__date">2017-09-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1pegQ4Bj_aM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to this talk on spring security
actually it was the the go to conference
who decided that on this unhackable
track they really wanted to have a talk
on spring security and they asked me to
deliver it so when they did obviously I
said yes because I'm a sucker for these
sort of things but I was also wondering
this is this is not a Java conference
right this is a general-purpose
developer conference let alone a spring
conference so what what can I do to
actually create a presentation or a talk
on spring security I will be interesting
for more than just people already in
that ecosystem in that space so then I
thought I I know it I'm gonna make
videos of myself half-naked jumping off
of cliffs I'm gonna present that but
then I realize no I'm not in the agile
track I cannot actually do that you can
only do that if you're speaking on that
job so what I decided to do instead is
I'm gonna focus on applying this one
framework spring security to build
layers of defense in your application
and hopefully even if you're here and
you don't really have a Java or spring
background you will be able to still
take away several important things and
lessons learned in the things that you
should consider when actually securing
your application however if you are in
fact working in this space of doing Java
spring then obviously you should be able
to learn a thing or two as well so my
name is your sky brush you can tweet
using this handle I work to try for
usually as a hands-on architect I'm also
doing some spring trainings here and
there and especially in security talk
right it's it's important to establish a
sense of authority so that you can all
trust Who I am so why am I actually the
guy that should be speaking on spring
security it turns out actually have an
author tag in one of the related code
bases so you can trust me so the
interesting thing about this conference
and this track is unhackable track is
that security is such a broad topic
and if you have attended any of the
talks in this track already or even if
you have just visited the keynote that
should be quite obvious what you see
there is that there is the actual
physical security right preventing
people from accessing actually messing
around with your hardware and accessing
it there is a network stack making sure
that things are properly secured there
that you have firewalls in place etc etc
there is the operating system level and
nowadays it isn't even clear really what
the operating system level is right
because that could mean a hypervisor it
could mean a minimal host for your
docker it could be your daughter
containers themselves so a room you are
actually did a talk which was mostly
concerned with that level today already
it's the middleware it's the
applications and again it's not even
clear anymore nowadays what is
middleware and what are applications
because all of those things are fluid
and merging into one and of course there
is the whole idea of making sure that
you have policies governing certain
changes and allowing for security in
that way so I want to make it very clear
that this talk will focus on how to
apply security just at the application
level which i think is a nice follow up
on what we've seen so far basically what
we're doing is we're going up is stack
from from hardware to middleware to
secure coding practices in in Kathleen's
talk to actually applying security to
your applications here because if you
are thinking about like a typical web
application is actually quite a lot of
different layers in your application so
to speak that needs some form of
protection there is the browser to begin
with which if you think about what Kevin
I just said in terms of post alles Lal I
can be a liberal in what you in what you
accept well the browser is an excellent
example of how that can lead to all sort
of known security issues so you probably
need some protection in that space then
there is the the application itself
right you might want to secure things at
a URL level saying certain sup URLs can
only be accessed by a certain type of
people you might have multi-tenancy
requirements you might have secured a
security requirements at the method
level you might have security access
requirements at the data level right so
there's many different layers to
you need to provide protection for
sometimes these things are really not
directly related right how I actually
tell my browser that would really prefer
this application to only use HTTPS and
not be embedded in like a frame of some
other application it's very different
than what I'm actually going to do to
secure someone from calling a method in
my application if it doesn't have the
right role but in many cases a lot of
those concerns and a lot of those
policies that you will implement are
actually edited they will reinforce each
other and that's important because the
idea that you're having multiple things
adding on top of each other also implies
that there might be actually some
redundancy in there and typically when
we think about coding we think that's a
bad thing
because we've all learned that we need
to be dry we didn't repeat ourselves and
things should be in a single place and
we're all applying clean coding it turns
out that actually and when it comes to
applying security to your application
it's a good thing to have some
redundancy in there you don't want to
rely on just a single level of defense
because there might be obviously an
error in that level of defense and then
if a perpetrator and the attacker
actually manages to go through that or
even worse I mean that's what typically
happens find a way to simply bypass that
completely well then you're out in the
open right so you want to have multiple
layers of defense now this is a concept
this defense-in-depth there's actually
quite broadly applicable it comes out of
out of the defense actually mostly the
military defense but it's broadly
applicable to to software and to systems
as a whole right so defense in depth is
something that applies to the things I
mentioned earlier on like your actual
operating system level your network
level but even within an application it
applies to multiple layers there as well
so that's actually what I'm going to
address I'm going to address this by
explaining how to apply something like
that using an open source framework
which is called spring security this
comes out the spring portfolio of open
source projects it's a project that you
can use to add security at the applique
lair level in in a number of different
ways
it supports common standards things like
basic or digest authentication form
based authentication it can integrate
with all that it can integrate with
single sign-on solutions it has support
for things like Olaf or auth - etc etc
so there's all of these standard things
and it's basically written in a way that
you can use it within any java web
application it doesn't actually have to
be a spring application let alone
something like a spring MVC application
spring security is actually quite
general-purpose and if you have
something that's the servlet based java
web application you can plug it in and
one of the nice things about spring
Security's it works completely at the
application level so what does that mean
it means it doesn't rely on something
like an outside container to actually
provide you with security functionality
that you then somehow need to integrate
with because that's the standard model
that you get in a circle based Java web
application you can define that a user
needs to be authenticated and have a
certain role but you cannot actually
define how that happens it's completely
up to the application server to support
your authentication mechanism or
authentication mechanisms because
nowadays it's actually quite common for
application to have multiple there and
it's gonna be really hard to take that
same application and deploy it onto
something else because you will need to
start all over again and figuring out
how to actually get that stuff up and
running in there it becomes even worse
if you need something custom my
experiences as an application architect
it's actually quite common that people
have some weird legacy back-end system
that they use as their source of
authentication for example if you need
to hook up your application to that then
good luck getting a plug-in deployed to
the company WebSphere cluster in order
to facilitate that right so whispering
security all of this is actually handled
at the application level and it's up to
your application to handle its own
security requirements that means first
of all that the application becomes
completely portable because it's not
actually relying on any outside
functionality provided by some container
but it also means you are in full
control so it becomes actually quite
easy to extend and adapt your
application to custom authentication
scenarios customer authorization
scenarios
etc etc right one thing that is
important to realize is that spring
security is a framework that assumes
that your code itself can actually be
trusted right this is not a framework
that will prevent you from using an old
Apache Commons collection library that
has known issues with deserialization
that allows an attacker to do certain
things it has no protection against all
of the bad coding practices that
Kathleen actually was just talking about
them and how to actually clean up your
code so that the code itself actually
becomes secure this is not that type of
framework this is a framework that
actually builds on top of that and says
we need to functionally add security
requirements to your application and
allow basically users to be
authenticated and then do authorization
so that's what this thing is and when it
comes to those two things separating
authentication and authorization is one
of the strong points here you want to be
able to say I don't really care if a
user was authenticated by entering a
username password and then we look that
up in our own user database and we have
some hashed passwords in there or be
authenticated against an external LDAP
server or maybe we were actually already
authenticated using some single sign-on
system and we just want to hook into
that we don't really care how that
happens if we then want to define ok
users that have that in that role can
can call a certain URL or users that
then belong to a certain organization a
certain tenant in our application that
can only access the data that belongs to
that same tenant right those are
completely different requirements and
spring security make sure that they are
in fact completely different so you can
change one without affecting the other
one it's basically all Interceptor based
because that is what application level
security is basically about someone is
about to do something and we want to
secure that so we want to prevent that
from happening automatically and we want
to check are there any security
constraints defined for what this user
is trying to do and if so is the user
actually meeting those requirements if
so ok will allow him to execute his
action or allow him to access the data
that he wants to to see or that he wants
to change if not that we're going to
prevent the user from doing that so how
this basically works is that everything
that happens up in the web tier will
just use standard
ah filters because they are a built-in
interceptor mechanism that is provided
by the servlet spec everything that
happens below that is based on the
custom aspects basically which is just
another form of doing interception for
code if you think about it this whole
thing is configured using a fluent Java
API for those of you who have not been
using spring for a while or have just
been reading on it a couple of years ago
yes there used to be a lot of XML
configuration if you're really happy
about XML you can still use XML
configuration it's actually quite okay
because there is a well-developed
namespace for that but in this
presentation I'm just going to show you
the newer Java based configuration to
yourself for this so what does it
actually take to get started with this
framework well basically you need to add
it as a dependency you need to get some
some filter set up I'm not actually
going to bother showing you that if
you're using a framework like spring but
it will actually happen automatically
for you and then you do a number of
things you're going to explain the
framework well where are my users are
going to come from what how am I going
to perform authentication it's gonna be
user name/password form based
authentication with my own database or
is it going to be something using
client-side certificates maybe because
we're doing a b2b integration whatever
you have then we're going to configure
some centralized authorization
constraints so we can say only these
type of users are allowed to enter these
type of sub-q or elles in our
application and these methods can only
call by well whatever I'm gonna show you
in a moment and then you might also have
some decentralized authorization that
you put directly in your codes in the
appropriate places and that's basically
it so this is a typical way that you
would set this up so we have a
configuration class here it's extending
some helper class and this helper will
give you a number of builders basically
to configure the whole thing now I'm not
going to explain everything here but the
first thing that you see here is this
authentication manager builder as the
name suggests it allows you to configure
something called an authentication
manager and I'm not going to talk much
about authentication in this
presentation I'm going to focus on
authorization but the authentication
manager basically allows you to
configure how do I authenticate users am
I going to support my own custom
database I'm going to integrate with an
owl a porn actor
I'm gonna use Kerberos whatever you have
if you are storing your own users which
is actually quite common in many
applications you're probably gonna end
up configuring something called a user
details service which is a really simple
thing you just give it a user name when
someone tries to log in and the user
details service will return a user with
the actual hashed password for that user
and the framework and then check if
someone is successfully logging in
because password matches or if it isn't
there are tons of other ways to do this
but like I said I'm not gonna focus on
the authentication part I'm gonna focus
on the authorization part and one of the
first things you should probably do is
you want to make sure that certain
things are simply not secured because if
someone is trying to access a static
resource like downloading JavaScript
downloading pictures that only CSS in
many cases you want that to be
accessible for everyone right it
shouldn't have to be a logging user for
that so you can use this thing called
the web security class to say there are
certain URLs that I just want ignore
we're just using some end like wildcard
patterns here right very straightforward
and then we get to the actual meet of
the authorization configuration which
says well for example there are certain
URLs that I want to restrict access to
so I'm going to say everything on their
admin have to be an admin user for some
other things that having to do with
projects and if you want to do a post to
that so you're making a change you
probably have to be a project manager
for everything else just have to be
logged in we don't really care about the
rest now I'll explain this in more
detail in a moment but this gives you an
idea of a really basic configuration for
spring security and the interesting
thing is that with this without doing
anything else there will be a whole lot
of default setup for you you will get
all sorts of custom response headers
added to your HTTP responses for example
that will instruct your browser to
operate in a more secure manner also
you're going to get built in support for
cross-site request forgery which I will
explain in a moment in more detail and
you're also going to get a default login
page because we didn't actually specify
one ourselves but you typically do so
before going into doing custom
configuration on the authorization I'd
like to explain what these defaults are
first of all because it's important to
realize what this framework is doing for
you when you're not actually configuring
all of those things and second of all
simply because
I've noticed that a lot of application
developers not really aware of what they
can actually do in terms of headers to
instruct browsers to act in a more
secure manner right so one of the things
that spring security will do for you is
that every request that you make that is
not explicitly ignored we will tell the
browser and not to cache the response
because that could leads to a situation
where someone goes to a computer logs
into a site does some work involving
seeing interesting data that should not
be visible to anyone then explicitly
logging out going away and then someone
else comes in goes through the browser
click the back button and it can
actually see off the old pages because
the browser had client-side caching
that's a security risk but in general if
you're building a web application
another website and all of your content
is going to be dynamic the whole browser
caching thing is just going to get in
the way anyways so what spring security
is going to do by default for every URL
that you have not told it to ignore
because obviously for static content you
do want browser caching as much as
possible it's going to add these browser
headers which is basically all of the
different ways that you can tell a
modern browser to say please please stop
caching all of this content and a couple
of years ago if you were using HTTPS for
a secured website this wasn't even that
important because most browser would
choose not to cache content surfed over
HTTPS but nowadays everyone using HTTPS
for everything which is actually a
really good thing but that also means
that browsers will now adlib by default
mostly cache all of the content certs
over HTTPS so you actually need this in
order for them to not do that something
else is content sniffing so again this
is a great example of post sales law
gone bad what browsers typically expect
from a response is a header that tells
the browser you know the stuff that I'm
actually sending you is going to be HTML
or it's going to be JavaScript or it's
going to be a binary file and it's going
to contain the PDF or its kind of
contain an excel file or whatever it is
that the browser knows how to handle but
if that's missing then there's a feature
in the browser that your browser says
yeah I know what
I'm just gonna guess I'm just gonna look
at what's coming in hmm it looks like
JavaScript
it must be JavaScript and you can abuse
this in a number of ways so for example
there's the idea of a polyglot file this
is a file that is valid as different
file types so for example you can
construct a file that is a valid
PostScript or PDF form but it could also
pass as an actual JavaScript file and an
attacker might be able to upload this
file to your system and that have
another user downloaded and if your
system is not going to explicitly say
this is going to be a file with this and
this content type your browser may start
to guess it may guess wrong because that
file might actually be a valid
JavaScript file it will execute the
JavaScript this is something that you
can tell the browser not to do it does
require obviously that your application
should have the right content type in
your response headers and this is just
good practice right as a developer you
should know how HTTP works and you
should always make sure that this is the
case and if it is spring security is
automatically going to add this header
telling the browser I do not want you to
start content sniffing is that it's cool
to guess what the file type is I'm gonna
tell you what it is and you're gonna
believe me and you're not gonna try to
figure it out for yourself another
interesting one related to the HTTP
transport I was just talking about is
something called HTTP strict Transport
Security or HSTs so there is an attack
vector where you could have a website
that is HTTP only like your bank for
example and if you access it over HTTP
what that server will typically do is
just send you a redirect back to tell
your browser
you're not going to connect over plain
HTTP you're going to connect over HTTP
and from there on out all of your
communication is going to be encrypted
but that first HTTP request that led to
the redirect that's actually vulnerable
to a man-in-the-middle attack there
might be some one especially if you're
on an untrusted Wi-Fi network someone
like something like that that can
actually sit between your browser and
the server intercepting that request and
then redirecting you to something else
that they control and you think you're
going to the right website but you're
not so what
you can do is you can actually send the
header after your browser makes an HTTP
request to tell the browser next time
you're going to try to access this
application domain make sure you do it
over HTTP directly so even if the user
would bookmark a banking website using
plain HTTP the schema your browser gonna
say ah I'm not even gonna make that
request I'm just gonna do a secure
request from the get-go which prevents
you against that man in the middle
attack you can do this just for the
domain you can also do this for all
subdomains right if you if you are
connecting to something and this is the
way that this is enabled there is a
strict Transport Security header you can
set some options there and this is what
spraying security will do buddy fault
because spring security tries to be as
secure as possible
out of the box so you don't have to
configure anything to get this that's
actually interesting because this can go
very wrong I've worked for a media
company in Amsterdam where we had built
our system and we secured it with spring
security and after that it was in
production running already a while did
great but they wanted to have some
additional authentication options and
specifically they wanted to have
federated authentication using sam'l so
we added that and then the sam'l library
said well the user is now trying to come
in with a plain HTTP request rather than
with an HTTP request I'm gonna deny it
but they weren't they were coming in
through HTTPS and it turned out that the
load balancer was terminating the SSL
connection and it was not adding the
right header to the request to tell the
application you know this request was
originally done over HTTPS now we were
only using HTTPS at the time to allow
the user to log in with a username
password the reason for that was simply
that the rest of their application
didn't support full HTTP only at the
time because they had some ad network
that could only serve up ads over plain
HTTP what we did when we found out that
our sam'l library was tell us telling us
it doesn't work you're not doing a
secure request we went over to the
networking maintenance guys and we said
you know can you add this header for us
whenever there is a nice TPS request
because then the application will be
able to
they tell that we're making a request
over HTTPS sure we do that we tested it
worked great
I left there I came back a week later
and it turned out that by asking those
Network guys to do that in production
because after we tested on acceptance we
said yeah just go ahead and do it in
production as well for when we deploy
the federated login we broke their
entire website and not actually just
their website everything running on
their domain because turned out that as
soon as someone would log in over HTTPS
now automatically that header will be
sent to the browser and the browser
would say okay if you tell me then I'll
just continue to make all requests over
HTTPS now including all of the requests
to serve up the ads and all of the other
content that could not actually be
loaded over HTTPS right so think about
it if you are going to add something
like spring security or something else
that will have this default to your
application your web application itself
may not support HTTPS only but hopefully
it will because that should really be
the default in 2017 but also that same
application domain might host other
applications that are not under your
control that may not in fact support
HTTPS only right so if you want to do
something actually I think this is not a
great default this is probably something
that you should just configure at the
web server or the load balancer level to
add that header because there you have
made an informed decision that it's
actually okay for your entire domain to
do this right so keep that in mind some
other things that spring security will
do is it will prevent clickjacking
attacks what this is is a way that your
site will actually be projected over
some other websites in an invisible
frame so the user doesn't really see
your application see something else
with when he thinks he's clicking on a
button he might actually be clicking on
something in your website where he's
already logged in and doing something
that he did not intend to do that's
called a clickjacking attack and there's
an easy way to prevent this by simply
telling the browser you know this side
can never be embedded inside of a frame
that's what stream security will do by
default using the X frame options here
you can tune that obviously you can say
well it cannot be embedded in a frame if
it's running on a different domain but
it's actually okay in my own
because I trust that one you have some
options there but you can you can look
em up this is an interesting one not
everyone may be familiar with what this
is this is called a reflected cross-site
scripting attack where basically the
server is just sending back whatever the
user passed in it's as simple as that
but that means that if the user is
tricked into clicking on some URL that
might contain some malicious JavaScript
that JavaScript could actually get
executed by the server sending back
exactly that same thing now browsers by
default
typically prevent you already from this
but what browsers will do again in a
typical post style or fashion is they'll
try to be as nice as possible because
they really want stuff to just work and
not break so what browsers will do by
the fault is they will try to fix the
content that gets sent back this way and
that's another attack factor and it
turns out that there are actually
attacks that make use of a feature of
the browser that will detect an attempt
at a reflective cross-site scripting and
then tries to fix it but fails to and
you're still screwed so basically what
spring security will do is it will tell
your browser just don't even try just
block all of the content that looks like
this malicious type of request so
there's other stuff you can do but
that's not enabled by default for
example you can prevent something called
well actually you can enable something
called public key pinning what this is
doing is that your application is
actually telling the browser this domain
will always use this particular SSL
certificate and if you try to go to this
domain the next time and you find a
valid certificate but it's not actually
that certificate Oh watch out something
is wrong now this is not something that
I would typically recommend you to
enable by default but there are
definitely good use cases for this maybe
you remember a couple of years ago there
were a lot of problems with Lenovo
laptops for example in the in the
consumer range that were actually
shipping with software that was
injecting ads into the browser and it
was doing that by actually man in the
middle in you with its own custom
certificate then that certificate was
leaked and basically attackers could
make any websites look legit to everyone
owning such a laptop what this would
actually prevent that attack from
happening there are some other stuff but
this is basically the idea of headers
right
this is just a browser part we haven't
even made it through the server yet this
is just telling the browser to behave in
a more secure manner but something else
that will be enabled by default is CS
ref protection cross side scripting
request forgery also known as session
writing which i think is a much better
term because session writing describes
exactly what this is it's a way for an
attacker to just ride along with a valid
session that you have already so you as
a logged in user will be tricked to go
to on through some malicious website and
that website will actually make a
request to the website that you are
already logged in somehow it will trick
you into doing that like showing you
this really big button that says win
free money now when you're actually
clicking on that now don't do that but
if you do what will happen this your
browser will make that request and
because it makes that request to that
domain
it sends well I have a valid session
cookie already for that domain so I'm
just going to send off the session
cookie and as far as the server can tell
you really initiate this request
everything looks ok so it will just
execute your request right you just got
tricked into doing this and this is
actually quite a common attack factor
which is why spring security prevents
you against this type of attack by
default but you need to do something
here this is not just a matter of
setting a browser header because your
browser cannot know this so the way to
typically do this is to add a custom
token to every webpage that your
application renders that contains
something like a form that the user can
then submit and then when the user
submits that form what you're going to
do is you're going to make sure that you
explicitly sent that token with the rest
of the form and then the user kind of
the server can check and it says yeah
that token is there it's actually your
token looks legit but if an attacker
tries to do the same thing they will
never be able to create a fake site or a
fake page that will also send that same
token header because they don't know
that token header because they cannot
actually get that from the server you
have to be logged in in order to get the
token then you have to send it back
that's basically how this works now
one thing that's important here is that
if you're using this you should only be
using this for state changing operations
so you should be doing this for posts
for put
four deletes you should not be using it
forgets first of all it gets you be safe
in general that's how HTTP is designed
to work a get request should not
actually change the state on the server
so tricking you into making a get
request that I as an attacker cannot
actually see the result of should be
fine
more importantly if you would include
the token in a get request it would have
to be part of the URL because you cannot
put it in like a form and coded body
because that's not how get requests work
so that allows token optionally to leak
and then you're back to square one
because well then an attacker might
actually be able to obtain your token as
well and he can again trick you into
forging a request so basically how
spring security does this is that when
you log in next to your session your
session cookie you will also get the
session scope token and you as a
developer are responsible for including
that in all of your web pages where you
are including a form that will be posted
or put or used leet basically right if
it's plain HTML it's going to be post
but if it's gonna be JavaScript you have
to think about these other verbs as well
this is the typical way to do that
basically those the token value and the
name of the token will be made available
as a request attributes you can just
include them there will be libraries
doing port this for you right if you're
using like the tag library from spring
reusing something like I'm leaf
it will all do this for you
automatically you don't even notice it
but the token will be there there will
be a hidden request parameter in the
form now this is nice if you're building
an application that the server-side HTML
rendering nowadays a lot of people are
actually just building single page
applications that just post JSON in the
body of the request
they don't actually post form and coded
parameters so that means that you cannot
add another form and coded hidden
request parameter so there is a solution
for this obviously and by default the
way that this works in security being
security at least if you can figure
something called a cookie CSRs token
repository what that does is instead of
creating a token and storing it in
server in the session it's just gonna be
another cookie that it sends to the
client however when the client makes a
request we're not going to check the
cookie value because well that's going
to be sent automatically so that's not
to be trusted
we're just going to make sure that the
JavaScript running in the single page
application will take the value from
that cookie and then puts it in the
request as a header we can take the
value from that request header we can
compare it to the value that was also
sent by the browser in the cookie so we
don't actually have to remember anything
on the server here we're just comparing
two values that the browser sent to us
and we're going to check if they're the
same thing the interesting thing here is
an attacker cannot force your your
browser to actually read the value of
that session CSRF token and from the
cookie and then send it as a request
header because cookies are restricted to
be read only by a JavaScript that was
served from the same domain right so
this gives you still a pretty good
protection against the srf if you're a
security expert you might actually argue
that it's slightly less secure in most
cases you won't actually care because
this is going to provide sufficient
protection against the common type of
CSRF attack so that's that that is
basically covering the whole thing from
browser to server right so now we
actually get onto the server and someone
is actually trying to make a request
we've decided that this is probably a
legit request is not an attacker who is
trying to force you use me to do
something so how we're going to secure
that and a very common way is to say
we're gonna have rules that are going to
match certain URLs in our application so
we're gonna map our URL structure onto
some authorities those authorities are
typically roles that you may assign to a
user and then that will check if you
have access or not so what that look
like in spring security is that inside
of this method that gives you this HTTP
security object there is a method called
authorize requests that gives you a
builder to configure all of this URL
based security so in this example what
we see is that first of all we say
everything starting with slash admin
that should only be accessible for admin
users so this is easy to do if you
actually model your URLs based on these
security rules that you have because
then this is a straight
or one-to-one mapping also we're going
to say if you're going to have a user
that makes a post so that is supposedly
an unsafe state changing operation to
anything under slash projects well he
has to have the role of project manager
in this case because I wanted to fit
this on a single slide we're gonna say
for everything else yeah you just have
to be an authenticated user you have to
be logged in you cannot be anonymous you
cannot be a guest user but we don't
really care about the rest now there are
some limitations and some tricky things
and using this approach and especially
in using this approach exclusively so
first of all this might become bloated
very quickly especially if your URL
structure doesn't actually mirror your
authority or your role structure but
you're using some other way of mapping
out URLs very quickly your code will
look like this and this is like one
third of the overall configuration of an
actual project I'm working on so this
can this can become very tedious to do
maintenance on very quickly also it can
be tricky to get right because there are
some Salty's here ordering of rules
actually matters most important one
should go first the metrics might
actually be slightly different in
behavior than what you're thinking and
I'll talk a bit more about it on the
next slide and really important is you
need to have a catch-all in place here
right that's a common security principle
if you haven't explicitly stated how
something should be secured that's
probably just should be inaccessible
rather than being unsecured by default
so on the next on the previous slide I
showed you the any request all
authenticated as the last line that says
that at least the catch holes as well
you should at least be logged in in
order to do something if I haven't
explicitly allowed you to do it before
as an anonymous user then at least are
required to be authenticated if you're
actually strict about security well
maybe it should be be paranoid right say
okay my catch-all is actually going to
be I'm just going to deny all access so
that means that you have to explicitly
state your security requirement for
every URL if that is a workable approach
or not very much depends on your
application so I'm not going to try to
pretend to have an absolute truth here
but this is definitely
something to consider so what are the
gut shots that I was talking about well
here you see an example where first
we're saying if someone tries to go to
the product inventory sub-domain in our
application every URL starting with that
they have to be in that min but for
everything else under slash products
they either have to be an admin but
regular user rise also suffice now if
someone would actually reverse these two
lines all of a sudden you have a big
problem because now if someone actually
comes in on slash products less
inventory slash delete the entire
inventory dot HTML it would simply match
this last project slash star star rule
and regular users would be allowed to do
this now if you literally exchanged
these two lines you would probably know
this simply by reviewing the
configuration if you're actually if your
configuration looks like this and one
line is over there and the other one is
over there you're probably not going to
notice this so be careful about this
make sure that your more precise rules
go first another thing is this one and
this is a particularly nasty one because
I've seen people trip up over this if
you're not using wildcards and you're
saying okay slash product / delete
that's only accessible to admin users
that will be an exact match so if
someone literally goes to that URL okay
it will work but many web frameworks say
well you know slash sporadic slash
delete I'll consider that to be exactly
the same resource as slash products /
delete slash let's bring security
doesn't bring security says yeah if you
have a trailing slash and I'm using an
admin sir that's a different URL so that
is not secured if someone is someone
that tecar simply adds a trailing slash
and tries to do this who knows what will
happen it's certainly not going to be
this rule that will match so hopefully
you have a good casual somewhere else
but not in URL matching so there is an
easy fix for this and that is to not use
the end matcher it's use something
called an MVC matcher because the rules
of that matcher
exactly match the way that spring MVC
handles request mapping but if you're
not using spring MVC if you're using
something else make sure to understand
those rules and make sure that you
encode them properly and test this right
so one thing that this illustrates is
that just relying on a single layer of
security
just relying on your ell level mapping
is actually quite tricky so in many
cases what you want to do is in addition
to this and not instead of this with in
addition to this you want to use method
level security as well so this is
something that you need to enable
explicitly and just show it here for
those of you who actually care about
spring security so there is a net
enabled well with method security
annotation you can say I want to enable
these pre post annotations and if you
enable this what this will allow you to
do is you can put an annotation on a
method for those of you not doing Java
that's just a little piece of metadata
and that at pre-authorized can be used
to specify a security expression so in
this case we're going to say in order to
call this method there must be a logged
in user and logged in user must have to
roll a product manager and if that is
not the case so either there is no
logged in user or there is but he
doesn't have to require role this method
will not be called but instead security
related exception will be thrown and you
can handle that by showing either an
access denied page if user was already
logged in or by showing a login page if
the user wasn't even logged in to begin
with and you can just start the whole
authentication process there and there's
much more that you can do with this
particularly interesting feature I think
is that this will allow you to access
method parameters in your security
constraints so in this example what I'm
saying is well not alone do you have to
have a particular role in order to call
update products also the actual product
that you're trying to update here should
have a company ID and the company would
be some type of tenants in this
particular system that matches the idea
of the current users company so that
means I can only update product that
belonged to my company if I'm trying to
update some other tenants products maybe
to just lower their price so much that
they will go bankrupt or actually do it
the opposite way so they won't be
selling anything I won't be allowed to
do that because I will only be able to
update products that belong to my own
company now similarly to pre authorizers
also post authorize so this happens
after the method executes and you can do
some check on what it returns so very
similarly if we say we're going to look
up a project by ID that ID itself
depending on how we implement our
multi-tenancy
may not actually indicate if this is a
product that belongs to the current
company or not so similar to the
previous light what we can do here is
you can say in the post authorize well
the object that was being returned which
is conveniently accessible under the
name return object must belong again to
the same company as the current user
right so that's what these things allow
you to do and this is still pretty
declarative we just put an annotation on
code I can write an integration test
that doesn't do anything with security
and these things will simply not be
handled so I don't have to worry about
setting up fake users everywhere for
example for testing purposes but on the
other hand they are actually expressive
enough that I can do all sorts of things
so there's a lot of built-in functions
for this so I showed you has role you
can check for multiple roles you can
check the anonymous you can check if
someone is simply a login user or not
but obviously you're gonna end up having
some custom constraints here typically
now you could actually tell spraying
security I want to add my own
expressions directly so you could have I
don't know has whitelisted IP address as
a function it turns out that even though
it's possible it's not particularly easy
fortunately there is a really easy way
to get exactly the same effect because
from one of those expressions you can
actually call a method simply on one of
your spring - objects so if we have a
service called authorization checks in
this case we're all checks to make it
fit on the slide we can say
pre-authorized and then say ok in order
to add a report to the patient that I'm
passing in here I want to check if the
current user actually has an active
treatment relationship with this
particular patient so this would be in
the domain of some medical record system
for example and this makes it really
easy to have custom security integrated
in a declarative fashion in your
application
so that's method level security now if
you really only care about roles and you
also really care about standards well
because standards you can use the net
roles allowed annotation which is a
standard Java annotation it's fully
supported by spring security although
you have to add support for it
explicitly we're saying jsr 250 enabled
is true because that's the name of the
specification
that includes this annotation but this
will only allow you to say user should
have a certain role on nothing else so
in general I just forgot this completely
and I would advise you to just use the
pre-imposed
authorized for everything because you
can do roll wise with that but also so
much more right so that's declarative
method level security now in many cases
as you're working with this you will
find that you also want to do things
programmatically probably not directly
in your business logic mix with security
codes but in some other environments you
do need to be able to write code that
accesses the current user and that's
actually really easy to do because you
can always access the current user by
looking it up there's a method for that
and the way that this works for those of
you actually know a little bit about
java is that the current user is always
stored in a thread local variable called
the security context so what we can do
is we can look up this authentication
object from there and then in the
authentication we'll find a user which
could be any type of object that you
have defined as being a user in your
system bringing security is pretty
flexible in that and you can find some
other things as well like the name and
the actual authorities that were
assigned to this particular user and you
can do all sorts of things with this so
just some quick examples of why you
might want to use this obviously for
custom or authorization right maybe you
have some custom security check and you
cannot implement it easily with
something I showed you already well just
implement it yourself and write the code
that hooks in to all of the places where
you need to have that check but another
one is to say well I want to make sure
that as soon as I have a logged in user
I will be able to put that in the output
of my logging so that I can always see
what user are on behalf of what user we
were trying to do something when we
issue a log statements that's a really
common thing to do also if you are in a
multi-tenant system so you have multiple
organizations with their own users and
their own data it's actually really
convenient if you can always access the
current tenants so you might want to
extract that from the current user and
make it available to your application
somehow you could auto populate things
like database columns right actually
using other spring frameworks you will
be able to do this automatically but
this will allow you to see whenever
change was being made to a certain piece
of data not only when it happened but
also by whom it was done you could make
sure that because by default this thing
is stored in a thread if you're actually
gonna have worker threads doing others
things asynchronously but you still want
to know on behalf of what user that
happens that you can actually propagate
the security contractors tons and tons
of reasons for doing programmatic access
so use it where appropriate just make
sure that you don't start mixing
security code with all of your regular
business logic code because the whole
point of the framework is to actually
prevent you from from having to do that
in the first place so let's quickly see
how we're doing on time here okay and
I'm gonna skip this one there is support
for something called access control
lists now I'll show you the first slide
for this the idea behind an access
control list is that you're going to
have security constraints that are
completely defined directly on a item
that you want to secure so they're going
to be completely outside of your regular
application logic file systems are a
good a good example of this where per
file I can actually say what users have
what type of permissions on this
particular file right and they might
actually inherit that from a directory
etc etc that's an example of an access
control which you can do this with
sprang security thing is this is not
needed in my experience for most
applications as I said in the beginning
you can trust me so if I say it's not
actually needed well that we don't
actually have to cover the support for
this so some other concerns you can also
tell sprang security oh whenever a
request comes in and some plates a plain
HTTP you enforce the secure HTTP
redirect so that's called a secure
channel support an HTTPS is important
even if you don't actually care about
the data in your application you might
have something like a public site you
don't actually have anything you need to
protect so you feel that it's okay to do
it over plain HTTP it's probably not
because that's still a plain HTTP still
gives you the possibility that an
attacker might actually be able to
intercept things and responses for
example and serve up malicious content
like maybe malicious version of jQuery
that we're going to serve up as
JavaScript so HTTPS Everywhere is in
fact a good idea
even if your data itself is not the
thing that you're trying to protect on
the other hand again just like with the
HD HSTs header this is something that
you may consider putting in your web
server or load balancer or
instead of doing it in your application
level there is support for limiting
coverage sessions seeing how often a
user can actually log in in parallel
with the same account which is
especially interesting if you're
charging for your content and have a
paywall
right you don't really want your
subscription that the user buys to be
shared with the whole friend and family
and neighborhood there is built-in
support for limiting the amount of
concurrent logins you can even do it in
a cluster as well and finally one thing
I wanted to check is how many of you are
actually storing users in your own
application database with their hashed
passwords that's a considerable number
of people that's also my experience is
actually quite common to do this now you
probably know already that in order to
do this you shouldn't store plaintext
passwords you should use hashes what I
still see however a lot is that people
will just copy like ten year old blogs
that advise you to use something like
md5 or sha-1 ah'd intended for storing
passwords maybe to make them more secure
you're adding a salt well I can tell you
one thing if you're actually storing
your passwords using md5 with the salt
you might as well just stored in plain
text right people with GPU based
hardware they can actually do a brute
force on this trying millions and
millions of password per second and they
will be able to crack most of your
passwords really in no time so make sure
that you're using an algorithm that was
actually intended for hashing passwords
and spring security has support for that
out of the box
I'll skip this one so to concludes
basically what you're seeing is that
with a framework like spring security
you can handle security at many
different layers in your application and
it's actually important to think about
all of those different layers right
security is not something that you
implement in one place and you're done
you need to think about these things so
in order to to do that when you actually
do that you will find that you get much
more of a defense in-depth approach now
this is just defense in depth at the
application level but if you're actually
attending the track today
fully at the end of the day you will
have also a bit more of an idea of what
it means to have defense in depth at all
of the layers right including things
like operating system network and your
Dockers and such but I find that
oftentimes people forget to actually
think about the application itself so
it's really important that if you're
using any security framework that you
know what it does for you how it works
but also what it does by default as I
explained there are some actual
dangerous defaults that might prevent
your application or other applications
running in the same domain from working
correctly so make sure that you read up
on this and that at least one person on
your team actually knows a little bit
about what you're doing and then maybe
well you could become unhackable or at
least you can blame someone else up in
that whole security stack for screwing
up and it won't be you as an application
you deliver right so with that thanks
for attending and do we have time for
questions okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>