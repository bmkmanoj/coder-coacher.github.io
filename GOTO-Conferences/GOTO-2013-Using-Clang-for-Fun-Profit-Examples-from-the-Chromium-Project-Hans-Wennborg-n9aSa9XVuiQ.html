<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2013 • Using Clang for Fun &amp; Profit: Examples from the Chromium Project • Hans Wennborg | Coder Coacher - Coaching Coders</title><meta content="GOTO 2013 • Using Clang for Fun &amp; Profit: Examples from the Chromium Project • Hans Wennborg - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2013 • Using Clang for Fun &amp; Profit: Examples from the Chromium Project • Hans Wennborg</b></h2><h5 class="post__date">2013-10-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/n9aSa9XVuiQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so chrome you might have heard of it you
might be using it already if you're
bored or my talk it's it's a web browser
from google it was first released in
2008 which means it's now five years old
doesn't feel like that long ago but five
years is starting to be mature web
browser the goal of the whole thing was
to push the web forward so the idea is
that the web means a lot to Google right
and we think it's awesome and I guess we
figured we could make it better by
providing a really good web browser a
long time ago JavaScript used to be slow
for instance and Google Chrome runs
JavaScript really fast and sort of by
releasing this this Chrome browser we're
pushing we're not only providing a
really good browser but also pushing all
the other vendors to provide good
browsers so chrome today has more than
750 million active users which is insane
amount of users right and that's not
only not only that but all the other
browsers have become infinitely better
as well so this is a huge benefit for
the web community and for the for the
world at large if you will it started
out on Windows then it covered the other
desktop operating systems mac and linux
and more recently it's also available on
mobile so android and iOS and this
mostly open source i'll try to explain
how that works this is the confusing
part i'll probably be mixing these two
terms freely as i give the talk this
chromium and this chrome what do these
things mean so chrome is the web browser
so you all know and use right and
chromium is the open source project that
this is based on so that's where the
code lives so we take chromium on the
left and then we add some stuff and then
we call that chrome so most obviously we
add the branding right we add the fancy
colors the red and green and yellow
which all display beautifully on this
presentation thanks to the hdmi cable
and and we add the name right you can't
have your own google chrome
unfortunately we also do some other
stuff we like we actually have software
engineering process going into this we
do it quality assurance we collect crash
reports if you opt into it we have this
whole system of releasing updates
like you can subscribe to the stable or
the debate or the dev or even the canary
channel if you're feeling dangerous then
we also add some proprietary code like
we have PDF and flash and we bundle that
in a sandboxed way but we don't have the
source so we can't it's not ours to give
right it's not open source and there's
some codex I think and this is the code
so this is this is just in the chromium
repository and this is a lot of code so
I showed this to one of my colleagues
and he was surprised because he thought
he knew it all and then when he saw this
he figured no I probably don't anymore
right maybe that was back in two
thousand eight when it started so chrome
looks like this pretty simple piece of
software right it's just a window with a
web page in a square and this like the
back button and the address bar how hard
can it be it turns out this a lot of
work going into that and this is our
code so i should also point out that not
all of this is shipped right a lot of
this is testing code which still means
we have to build it and maintain it and
run it and so on there might also be
third-party code in there like this is
spike in 2009 there was someone adding
something third party and getting it
kicked out there's also big spike in
2010 that was also a third party library
like a million is worth and that was
removed more recently but there's still
a lot of code to to keep track of and
maintained speaking of third party code
just to add to the awesomeness we have
some third-party code as well that we
sort of pull in from from different
third-party repositories the most
obvious one is blink which used to be a
cold WebKit this is this is our fork of
WebKit and that's the that's the
rendering engine that actually knows how
that's the one that actually knows about
HTML and CSS sort of interprets that and
decides how to draw it on the screen
it's also v8 which you might have heard
about because it was invented here in
Aarhus that's the JavaScript engine
that's the one that knows how to how to
run JavaScript and then there's a long
list of other stuff some of this is
developed by google some of this is
developed by third parties we use it all
I counted five million lines when I did
this two years ago so chances is that
the it has grown I should also say that
this is just the C C++ and objective-c
code we don't have some Java code as
well
for the android port but we don't build
up with rank so that's I didn't count
that this is also a pretty cool golf
like you can see that the project has
grown this is counting the number of
unique committers to chromium per per
month since the start and you can see
that in the beginning they could
probably fit in one room but today it's
this massive like spread around the
globe people committing around the clock
hacking away sort of operation which
feels awesome to me it's like we can
really build stuff but it's also really
scary like we can really break stuff
really really fast so so this again says
something about the complexity of the
project and that this this a good need
for for good software tools there so
that was chrome chromium now to the
clang compiler so clang is a new new
compiler it's an up-and-coming c++
compiler it does all the see family
languages actually it does C Objective C
objective c plus plus I think it does
open CL there may be some CUDA stuff as
well and being there aren't that many
new C++ compilers this is probably the
newest one this is probably like the
only C++ compiler that i was born in
this new millennium so it's really new
and if you like compilers that's enough
to get you excited it's part of
something that's called the llvm project
which is this open source project for
building compiler stuff it can do
everything from understanding C++ to
generating ones and zeros on your hard
drive and optimizing them and analyzing
and so on llvm used to be an
abbreviation of something but today is
really just for random letters that's
the official explanation so clang was
announced 2007 by Apple and since then
it's been worked on pretty intensely
since 2010 or roundabout 2010 we call it
the production quality compiler it's
open source its beastie sty style
license and it's designed to be GCC
compatible which means that it sort of
understands the same command line
options that's TCC does and its support
some of the same language extensions as
well which means that if you have a big
software project that used to build with
GCC such as chromium then the idea is
that it should be simple to drop in
flying as a replacement and you should
just work almost so we've been using
clang in chromium a little bit or trying
to since 2010 which is around that's the
time that I joined I was asked by two
guys in California if I wanted to help
them out trying to compile a chromium
with this new compiler called clang and
that sounded like fun so we did this for
about a year in our twenty percent time
and what does this actually mean like it
should all just work right well it
didn't all work out of the box so what
we did is this is basically a massive
cleanup operation right we want chromium
to compile warning free for instance
which means we have to fix everything it
wants about or turn off the warnings and
we didn't want to turn off the really
good warnings I do it also meant filing
some bugs on clang and so on and today
we actually use it for a bunch of
different things most importantly
perhaps is that we actually use it to
build our Mac binaries right so if you
use chrome on your Mac then we build it
with clang that means it has to work and
we do some other things as well and so
why did we get excited about trying in
the first place we already had a good
compiler right so one the first thing
about trying is that is pretty fast that
might not seem like a big deal but if
you're building all this code that i
told you about before then it does make
a difference even if it's ten percent
faster or twenty percent faster that
that that's very nice to have as a
developer it also provides good output
i'm not saying that it's provides
awesome fantastic output but it's good
and it's good enough that we can
actually ship these binaries to a user
which is like that's probably a
requirement to use it seriously then it
has clear error messages to a compiler
writer that might not seem like an
important thing like a compiler writer
might think that all they've read all
these books about compiling code right
they write a compiler the programmer is
supposed to import c++ and the compiler
supposed to output object files if the
programmer inputs something else than
C++ then you know exit one or whatever
not my problem but it's actually really
good if the compiler can be sort of
helpful that's actually a big area of
compiler technology then taking errors
to the next level it provides
high quality warnings which is even more
awesome than the eris I think and the
best part is the last parts that clang
is actually hackable and extendable and
i'll be showing some examples of that
this is my first example yeah you can
almost read the whole title so this is
the missing semicolon GCC 4.6 style so
that's not the latest GCC right but it's
probably the one that our linux use
developers would be using and what's
happening here it's probably all
screaming out at you that there's a
missing semicolon after the S
declaration but that's not what the
compiler is saying it's saying it's
expecting a semicolon before the for
loop which is technically correct right
that's usually the best kind of correct
but it's not the most user-friendly way
of saying it perhaps and then it goes
off being on being declared and you know
expecting semicolon for before the right
friend this it's not it's not great
anymore so it would be nice if the
compiler could be more helpful here and
as uses of Clan you all know that clang
will try to do this so clang I think I
can say that it gets it right here right
it takes expected semicolon at the end
of the Declaration which exists is
exactly the problem here there are also
a few other things like it's using color
which is you know welcome to the 21st
century that might not seem like a big
deal actually some if your conservative
you might not even like it in your in
your terminal but if your birthing two
screens and screens of error messages
the colors sort of help you navigate
that and like help you get to the air
pretty quickly it's even using this
green thing I don't know if you can see
it where it's trying to point out
exactly where to insert this semicolon
and it's quoting the code right so you
don't have to open your editor and
actually look what this line was which
is really helpful and in the same way
that that the chrome is pushing the web
forward trying is pushing the compilers
forward this is GCC from two weeks ago
it now has colors they're off by default
but you can turn them on if you like
them and it's sort of trying to be more
trying to be more user-friendly in this
way you can see it's doing the same
thing that clang does its quoting the
code and pointing with this green thing
right
unfortunately it doesn't get the
underlying problem right here it's still
complaining about semicolon before the
for loop and then it gets really bad
with this eye thing like I was not
declared in this scope well you can see
clearly see that it is right it's right
there on the Left I'm saying in die but
this is progress right this is awesome
and this is taking it to a whole new
level this is something that my word
processor has been able to do since I
first got it this is type of correction
so clang i misspelled see out here which
is the c++ name for the standard output
stream and clanging exact knows all the
identifiers being a compiler it consists
that there's no such thing as the out
but it does know all the other
identifies right so it sees that I have
one called see out which is close would
you like to try that and it's pointing
it out with the green things it's saying
see out there and if I pass it the right
flags it can actually go in and edit my
file and fix this for me if you're using
Xcode as you might be doing if you're
doing iphone development I'm sure you
can just right-click and get it fixed
right there and then so this now we move
on to the the warnings like this is a
perfectly correct piece of C++ or even c
code I mean this conforms to the
standard this is well-formed there
nothing to complain about here the
compiler will will will happily compile
and optimize this for you but it also
like it might suspect that this does not
do what you what you intended does
anyone see the the bug here yeah it's
like that the precedence of the
operators is is tricky here so it looks
like we're trying to take seven and then
depending on the value of this boolean
variable we want to add that to X or Y
and return it right the tranq points out
but that's not what you're that's not
what's happening we're going to do the
addition first we're going to take seven
another two booyah which is perfectly
legal in C++ like why not it's 7 plus 1
or 0 that's seven or eight depending on
which that's true or false and seven or
eight or both to right so we just take
the X and return it and the compiler
will optimize that nicely for you but
trang wants which is fantastic and it
suggests you might want to put
parenthesis stir and this is a really
good warning like we added this we found
a lot of bugs in Chrome we found about a
lot of bugs in Google internally and the
best thing is that every time it weren't
there was a bug and that's an important
property of the warnings right we want
to really low false positive rate
because if it's warning where there are
no bugs then it's just noise and we'll
turn it off that's not very useful this
is another more more contrived example
but something that could very well
happen in reality like we have probably
in the in the process of migrating user
data from one system to another we want
to see did we actually manage to copy to
the new location because if we did and
we did really don't want to delete the
user data so we set that one defaults
there and I'm sure you see the bug
already yeah the problem is we're not
let's see playing explain it actually
the problem is we're not actually
setting the value that the pointer is
pointing to we're just setting the point
to the force which sucks it's legal in
C++ to do that because force is just 0
and the pointer can be 0 it's called a
null pointer right no problems here but
the tank is trying to be smart and
saying yeah this is probably not what
you want what you want to do this is
nice warning it finds a lot of bugs I
think GCC does this these days as well
so I said the best part about crying is
the hack ability the rest is just
general compiler stuff right the clang
is built sort of with an intention to be
extendable like most of the other llvm
project is built as a set of libraries
which means you can embed it in your own
code and do cool stuff with it and we
can use this to build tools which is a
big thing like we really really want
this for chrome chrome has a lot of code
and an interesting thing with chrome is
that it's sort of this this a small
mirror image of what Google looks like
internally like if we have 12 million
lines of C++ in chrome we might have
some more inside and we want to have
tools there as well so my first example
is the chromium style checker which is a
very simple example so we in chromium we
have this
thing called the style guide which were
all love which is a long document
telling us where to put their curly
braces how long a line should be stuff
in the language we're not supposed to
use and and how we should do things and
so on this is actually an interesting
read if you like C++ you can google for
the google c++ style guide and we try to
enforce this right because we think it's
important we try to enforce this really
hard and like the code reviewers will
look for this and they will tell you
when you're wrong but humans are
fallible and and they will miss things
so we also use tools like we use Python
to check the lines the line length right
that's easy to do in Python but other
things are much harder to do in Python
and then we need better tools so for
instance we have this rule about virtual
and override in objective-c I think old
methods are probably virtual by default
when the C++ they're not so in C++ you
define you declare a member function
virtual and then if you have subclasses
of that class which have the same method
then those will be virtual as well as
well implicitly but we don't like to be
implicit about these things so we like
the programmer to spell out virtual
there the problem is how do we check
this with Python right so with Python
we'd have to parse the file and CEO this
is a function declaration or it belongs
to this clause which derives from this
other class which has the same function
and there it's virtual this gets really
you don't want to do this with the
regular expression let me let me tell
you but if we had this the compiler
knows this right so if we could just ask
the compiler or sort of use the code
from the compiler that know C++ and then
we could just ask it is it virtual and
it is it spelled that way which is
exactly what we do so this is what it
looks like this is the chromium
developer breaking the rules and he'd
get this warning and we'd actually call
it an error because we take warning
seriously so what we do is that we have
this thing it's called a plug into clang
which means you can sort of add your own
actions to be run at the same time as
the regular compilation so we hook in
there and add some extra checks to the
code i'm going to show you what it looks
like
I'm going to try to find the thing this
is where we do it check virtual method
write this function gets called for each
method declaration in the file that
we're compiling we're checking first is
it virtual if it's not then we don't
care that that's not perfect checking
for then we check is it virtual as
written like we just asking clang these
things right because it knows it's being
a compiler and then we hook in there
pull out the source location and stuff
so we can omit this diagnostic like
method requires virtual and we even try
to be nice we insert this fix-it thing
which means that clang can actually go
in and fix the source code for you if
this happens so the second tool I think
I have five in total the second tool is
something that's called clang format and
you might guess what it does already so
I said before that formatting is
important this again comes back to
having 12 million lines of code and 600
people working on it like we probably
all have our own preferences about good
code should look like and we're probably
not all consistent with ourselves even
so we have this style guide and we take
it seriously because readability of code
is like the main important property but
it's also really boring right this is
not what we would want to spend our
lives doing both editing the code
manually in our editor to you know do
the line breaks and stuff and then
especially arguing about it in the code
reviews that's the really like that's a
waste of time the only problem is that
automatic formatting of C++ is really
hard like a Java developer might not see
the problem here right they can use the
clips and ctrl shift there for whatever
and it works pretty well but C++ they
have not had this this luxury like there
are lots of tools that tries to try to
do this right that will indent your C
code stuff like that but for C++ is that
traditional traditionally been very hard
the problem is that it's a complicated
language right and you need to
understand some of the language when you
format the code so what rank format us
you might guess is that it's using
pieces of clang to sort of get this this
language knowledge and use that to build
a formatter again I have a demo here
this is all from from chromium these
lines are clearly longer than 80
characters and we could go in and start
you know go to the space or whatever
insert the line breaks and stuff but we
really don't want to we could also use
clang format and then it looks like this
it just does it for you and this sort of
changes the way developers work when
they start using this they start they
don't break the lines ever right they
don't format it they just write their
code then afterwards they format it and
that's it's done I have a second one
because this was easy right this is a
beautiful line of C++ now we're using
features this is the central part of
chromium too it's a macro which is
awesome it's doing templates it's got
the bit over you know macro pasting
whatever you call the thing there and
it's it's obvious what this like that's
right just by looking at it but but
formatting it might help the readability
there and I'm not going to format this
manually because it would be really
really boring but this is what it looks
like after clang formats done with it
and c++ developers usually find this
amazing right it's macros because no
other tools will look at a macro they're
just you know could be whatever but
clang format actually handles this and
will format our code beautifully and the
real reason we're doing this this is not
just for a convenience or if we actually
want to do I don't have demos for that
but what we actually want to do with
clang is what we want to do large-scale
we're factoring and we can kind of do
that this is again like eclipse you can
just right-click refactor right but then
c++ it's been harder traditionally we're
building tools to do that but one of the
boring things is that if you rename
something and it gets a slightly larger
name or if you add a parameter to a
function or whatever the formatting
comes out wrong and that's fine to tidy
up if you have 10 files but if you have
10,000 then it gets boring and that's
that's why we want trying format it's
also really easy to use so I had it
integrated in vim which is my favorite
and we have integrations for a bunch of
different editors so now we're coming to
the more the more hardcore compiler
tools the first one is address sanitizer
or a son it will sanitize your addresses
this is developed in Moscow so in C and
C++ and so on we do manual memory
management I don't know about
objective-c you maybe you can do it
maybe maybe you don't have to this is
awesome like we like to do this for for
speed for performance but it also bite
us in the ass a lot of time because
memory management bugs are like the best
right not only will your program maybe
it will crash maybe someone will hack
you it's not the good thing to have
memory memory management bugs in your in
your software so traditionally you'll be
using bad wine for this right on Linux
and Mac there is a solution you'll be
using well grind and what we're going
does is that it runs your program and as
it runs it is sort of jit compiling it
right but it's not bytecode it's real
coach so it's looking at your code and
that's it's running it's like adding
some more extra instruction it's adding
some more instructions around your loads
and stores to check that they are
correct and that slows down the running
of your program sometimes it's not too
much but sometimes it's slowing things
down a lot so we had this problem that
running all our tests with valgrind
takes forever and running the pro the
browser with background was not a fun
experience so what address sanitizer
does is that it's inserting the
instrumentation around the loads and
stores at compile time instead and this
is not a new idea like we've been doing
this before but doing it with langan
llvm turned out to be much easier which
means that i drew sanitizer came out as
a really successful tool it's usually
about two times slower than running the
program without the instrumentation
which is still slow right you're not
winning benchmark on tests but it's
still fast enough that you can run the
browser for instance and all the tests
and it catches many kinds of errors some
that Valgard won't detect so I have I
have demos
this is the first Excel I should show
you the code this is the first example
this is a heat buffer overflow classic
right we're allocating space for
hundreds we want to return the hundredth
int but we sort of forget about our race
or being indexed from from zero so we
actually index one step too far so this
is undefined behavior and it's totally a
bug and so on let's see what happens
when we run it no problem right it ran
fine it didn't crash it's returning zero
which is what we expected but we're
going points out that there's a bug or I
should compile with debug info can you
see this yeah we're going points out
that there's a bug right this is an
invalid we'd after the the array and
that's bad this is fantastic valgrind
fixes this for us it might have been
slower but it didn't did a matter in
this case let's see what address
sanitizer does
it uses color right it point its
pointing at the same error right we're
doing invalid read at this location and
it's sort of pointing out that it's to
the right of this this buffer that we
are located it's also showing something
about how it works internally so address
on a sanitizer is using this this thing
called shadow memory which sounds
awesome it's like you have your you have
your regular memory for your program
then you have the shadow memory
somewhere else which is sort of there's
a mapping between them and what address
sanitizer does is that it keeps track in
the shadow memory it's sort of marking
the bites us like is this bite valid to
read from in the real memory and so on
and that's what it's showing here so we
tried to read here and it was marked in
red sfa which means he left red zone
which sounds like something you should
probably shouldn't be reading from right
if you like memory related bugs then you
love concurrency bugs right and I
suppose these go for all all languages
it's not just C and C++ being evil it's
the same idea this is the sanitizer tool
it uses clanging llvm to insert the
instrumentation at compile time we've
built this tool with background as well
where it does the Val growing thing of
sort of adding at one time but it's
obviously much faster to do it this way
this has a large overhead compared to
address sanitizer but they still not
crazy still allows us to run our tests
in a relatively timely fashion and it
points out crazy situations so the thing
with concurrency bugs is that you have
them but they're never there when you
look for them right they they always
occur on your customers machine and that
makes them hard to find so the idea with
the tool is steady to point out the
situation that's raised even though the
sort of the the concurrent access to the
variable isn't actually happening at
that time let's see
this has slightly more code it's
starting to threads it's very simple
right we have this global variable
that's going to start out at zero
because it's a global that we're going
to have thread one increment it and
thread to decremented one might run
before the other right but it should
still end up at 0 then we join and then
we return the value of the global okay
it ran and it returns 0 so it seems to
be working right let's try it one more
time now it returns 10 again it seems to
be a bit random we built this random
number generator which is is great if
that's what we wanted right but that's
not that's not the case you can try Val
grind it's not going to complain well
we're leaking two things but no no we're
freeing them as well right so we have a
race there and traditionally we'd be
like opening up the code and staring
really hard at it but that's not an
efficient way to do it that's only if
you know it's there right
this is what thread sanitizer does it's
trying to it's pointing out that there's
a right by thread to in this case and
there was a previous previous right by
the other thread and there was no
synchronization in between this is a bad
situation to be in and it's giving us
the usual information about where the
threads were created and so on so in
summer there's a data race at this line
13 which is fantastic and this works
even if we sort of fix the we do the
hacky fix of making sure that they don't
write to the global at the same time
right this should totally fix the
concurrency bike so as you can see the
problem was that the threads were
running at the same time and writing to
the global but now we're making one of
them slightly slower by making the
second one sleep so the first one should
get there first and then the second one
afterwards should be safe
it's got lower performance now now it
works right let's see what thread
sanitizer says you have there's still a
race because the race is still there
right we're not synchronizing in any
reliable fashion right there they could
still write to the global at the same
time because one of the threads might
get stuck for a second maybe the machine
is really loaded or something like that
so the point is that it's detecting the
race even if it's not happening and in
this case it can even point out that as
if it was synchronized via sleep like it
knows about this sleep trick and you
know obviously can see through it so
these tools like a dress and attire and
and thread sanitizer are amazing tools
for us like before we couldn't we might
have had a lot of bugs we didn't know
about before this came it came along and
we don't want those bugs and even better
when we have bugs we know about like the
programmer can use these tools to find
them this is the third unbe hey the
third sanitizer that's the last sanitize
this is the newest one actually to see
in C++ they have this awesome language
feature which is called undefined
behavior the usual examples are division
by 0 array overflow null pointer
dereference and so on so the idea is to
help efficient language implementation
right the compiler when it sees integer
division it only wants to omit the
divided instruction it doesn't want to
have to check for zero there so other
languages might specify the behavior
that like division by zero should yield
division by zero exception or something
like that intended that the compiler
either has to check for zero or it has
to do something clever like rely on the
hardware maybe can the hard work can
help or whatever to do this but it might
turn out to be less efficient and C and
C++ they try not to compromise on
efficiency so that's why the language
works like this it also means that it so
what it does is that ok it's going to
meet the division instruction and it's
going to trust you not to try to divide
by zero by zero because if you do then
ok you're out of the safe zone of the
language like anything could have
and it could be formatting your
harddrive so that's also a source of
subtle bugs right because the define the
behavior is undefined anything could
happen so you might not know that it's
happening anything could also include
nothing on your machine and something
else on someone else's so we now have
this tool that tries to catch this I
have a demo so sorry about the see here
what this does is it's sort of a demo of
the left shift operator so you know how
this works it takes the bits of an int
in this case and it shifts them to the
left right and any bits that don't fit
in the word they're going to fall off
the edge to the left so 32 bits in this
case and this this thing just does it
like once twice three times and shows
off the result so we'd expect it should
start with one then to the fourth and
eight and so on and then all the bitch
should fall off and we should end up
with there I think that's not what
what's happening I don't know yeah you
can see this so it turns out we end up
with one here where did this come from
well this is like the high bit set and
here it should be falling off the cliff
so maybe maybe the undefined behavior of
sanitizer can tell us what's happening
yeah turns out 32 is too large for a
32-bit int right so C++ and C they leave
this as undefined behavior and you're
not allowed to shift wider than the
width of the word and what's happening
behind the scene is that this is
emitting the instruction is using for
left shift is SS HL s HL on x86 which
actually does the shift modular 32 so in
this case it's not shifting at all
that's what Intel does like power or
another platform might be doing
something else but that's not simpler
process problem so this program might be
having different values on different
machines and the reason we're doing you
be son is so the compiler can sort of
the sort of exploit the undefined
behavior what it can do is that it can
assume it doesn't happen right because
if it would happen then anything could
happen because it's undefined but the
compiler can't really be that aggressive
because a lot of programs have undefined
behavior and people are started sort of
relying on them to have predictable
results like you have a null pointer you
dereference you expect the predictable
crash well the compiler might want to do
something else there so we have
undefined behavior sanitizer to sort of
weed out the undefined behavior I have a
second now we're entering C++ so this is
a simple program it's kind of stupid it
just wants to return a really big value
so it grabs a big value stores it in a
float for some reason I don't know why
but you can do that and then it returns
it as an int and you can convert and
float to an int as well so let's see
what it does
well it did not return a really big
value so what's the bug here can anyone
spot this let's see what you be census
okay so what seems to be happening is
that we somehow end up with this value
in the float which is too large to be
converted to an int so I think what's
happening I'm not the language lawyer is
that like conversion from integer to
float is perfectly defined you might
lose some precision though so in this
case it seems that the number is getting
rounded up because it should end with a
save seven here actually that's the max
int value right and then we're returning
this as an int and you can do flow to
end conversion it just gives you like
the integer part right and that's
defined as long as the number fits in
the end and it doesn't here so that's
why we get this morning that's what
undefined behavior what does and it
works like all the other sanitizers it's
inserting instrumentation at compile
time which means it's sort of inserting
all these expensive checks that we don't
want in production like for division
it's going to check for zero and so I'm
for null pointer it's going to check for
null and this allows us to catch the
whole lot of bugs again and hopefully it
will allow us to write the better
optimizing compiler once all the
undefined behavior is gone so those were
all the demos I had what was my point so
the clang was about the talk was
supposed to be about fun and profit
right the point is that programming is
supposed to be fun that's why we do it
and we also might make a profit that
helps pay for the fun but there are
things in programming which makes it
more boring such as like trying to
figure out what the compiler is saying
when it has an error message finding
bugs that the compiler could have told
you about because it saw them right
swinging by us you complete compiled
formatting your code is really boring
finding memory bugs is boring
concurrency bugs is even worse and
undefined behavior is very very sneaky
and clan can help with all of this so
hopefully clang can help us have fun and
profits that's my point thank you very
much
or all these sanitizers ran from command
line or is it expected to have them ran
at dev time or is continuous integration
I guess or is it expected to Adam run at
that time well you can do both I mean we
do run them sort of mandatory during
continuous integration you can run them
during development time as well if you
like but there's a nice thing to do and
it's very handy to do it like when you
have a bug and you're like looking for
it I don't think a lot of us run it by
default but maybe we should actually we
also have the idea of shipping this in
the canary can channel right we don't
even have to do with that continuous
integration time because it's so fast we
can ship chrome with this to the canary
which is supposed to be unstable anyway
and when it crashes we can sort of get
in on those crash reports if you opt
into it that's that's really useful it
was also a second one here as an
objective C guy where can I find docks
for this plugging stuff would love to do
this stuff too so it's not very well
documented the plugging stuff because
they the reason for that is that the
Clank folks are not really certain about
how they want to design it it's there
but they don't feel that this is the
design they want but we can still use it
so one thing to do is that you can look
at at our plugin so this is a link to
the chromium wiki where we sort of
describe our plugin and you can sort of
look at our plugin and use that as an
example that's not really looking at
objective-c i think but then you can
sort of the documentation for planks
internals is actually pretty good like
the using doxygen and i think there are
some talks about looking at the AST even
and so you can use that to sort of write
your own plugin are there any live
questions so i came to think of one I
don't work with like these kinds of
really powerful tools I'm a dynamic
language programmer yeah I'm a small
talk and the workflow I really like with
dynamic languages
actually run the entire application
especially in small talk you can run the
entire application and make like
piecemeal changes and just rerun that
piece of it yeah and it seemed to me
since the tools you showed I only took
effect at runtime so it seems like a
runtime shame prosthetic language to me
so the question is could you actually
use this to build a life developing
environment in a small talk style that
produces fast code like this I don't
know if you can use these tools like
depends on if you wanted to run static
languages in this development
environment is that or do you want to do
this analysis for your small talk Cody
in this so there are projects that try
to to interpret C and C++ right and run
this in an ID and then you can do this
you can like you can hot patch your code
right you can run a bit and then you can
write some more and run that and you
thinking about go back and change and
stuff like that that's sort of unrelated
to the sanitizers that's a different
project called cling I think the C
language interpreter which they do at
CERN which is pretty crazy but pretty
cool too yes so people are trying to do
that with Alabama clang do you have any
experience using clang on Windows that's
very new so depends what you want to do
with it all right you can run the
compiler on windows but it might not be
able to produce a working windows
program it's hard so so the thing is we
actually announced a few weeks ago at a
conference called going native I don't
have a link but there's a great talk
they're announcing that we're starting
to look at doing that or windows like
using clang as a compiler and
integrating with visual studio which
could be really nice um so we'll address
incisor only catch like out of bounds
errors Oh we'll also catch something
like reference counting cycles in a
stretcher pointer they I don't think
you mean put it catch that you leaked
something so we have another sanitizer
for that it's called the Elsinore leak
sanitizer and I think that would catch
it yeah so the problem is the we don't
do all the analysis in one tool because
turns out that requires a lot of memory
alright so this Idris sanitizer only had
jello memory tracking if addresses are
valid to read from checking for leaks is
a different process and requires another
type of shadow memory and having both at
the same time it's really expensive so
we have sort of confusing but we have a
lot of sanitizers right we have address
sanitizer which I showed that we have
leaked sanitizer which tries to find
leaks then we have something else I
think that's a pretty new one though it
might not actually be released or stable
or whatever now we have another one
called I don't even remember what it's
called it's checking for a for
uninitialized memory reads which add the
sanitizer won't do either like if you're
inside the buffer it won't detect that
the memories of the initialize which
valgrind us that's another check that's
nice to have so we have a separate
sanitizer for that so why are these
written as client plugins versus
actually trying to get these ideas into
the main source of client I guess so
it's just the the only plug in here was
the chromium plugin sure I should have
pointed out the sanitizers are part of
the main Clank source so the way I ran
it was I just tossed this flag to clang
right and this is regular clang and the
flag is just a regular flag clang format
is a separate tool that's also not a
plug-in it's a whole separate program
that's linking against cleinias library
so they only only plug in here that I
showed was the sort of chromium style
format checker we run 17 times at a time
or how do we use this a lot of memory
one at a time or all at once no way we
run them one at a time I mean you can
try but it might take too much memory to
run them all and it might sort of fall
over itself as well I don't know if that
works
okay thank you very much else thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>