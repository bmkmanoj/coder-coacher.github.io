<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • Why is Rust Successful? • Florian Gilcher | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • Why is Rust Successful? • Florian Gilcher - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • Why is Rust Successful? • Florian Gilcher</b></h2><h5 class="post__date">2017-12-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-Tj8Q12DaEQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone you may have heard it
during the last few days that Firefox
got a new release out with this nice
logo Firefox quantum and it's in large
boats powered by rust and I'd like to
not speak about Firefox but more about
rust so Who am I I'm Korean I'm working
for a small company called s Kara you
can find me on twitter as iraq and you
can basically just put that into your
bash profile source it and you'll be me
for a day i'm arrests in elasticsearch
trainer and event organizer i've been a
ruby program since 2003 and a rest
program is since 2013 rule of some
languages was are you are good I'm the
CEO of that company I am generally a
community person I do the balloon rust
and search meetups and I organized the
Euro camp and J rubyconf conferences
which are a bit special because the
organizer of this very conference Diana
used to be involved in these two before
and I was very happy working with her
and very happy to finally speak at this
one then I also organized the European
rust conference rust fest and a couple
of other organizers are even here and
I'm part of the global rust community
team so the rest project has a community
team which I am part of as a hobby I
generally shoot arrows at stuff mine
during the QA so the title of this talk
is why is rust successful I don't want
to introduce like the language in full I
would actually talk about what is the
context and why is it currently
something that a lot of people talk
about the problem here is there's almost
no comparable net metrics for
programming languages around like even
if we gather any kind of numbers about
the rest community we neither know if
that's good or bad because almost no one
else does it there's no structured work
on how programming languages communities
even work take that like as a little
thing but that means I have to define
what success is and for me it's these
five things at least I would say a
programming language is successful at
least for us that we move the state of
technology forward it is used in
sizeable production environments
it attracts contribution if it's an
open-source programming language it
hides it has a sizable growth especially
for a beginning language that's an
important metric and it attracts
positive feedback because that's what
you want to have we won't make things
better we don't want to force stuff on
people well that means I have to explain
what rust is who here has never touched
rust that's good I'm going to do a short
introduction that's why it's here so
rust is a new systems programming
language it powers and was developed
along with servo which is a new
experimental browser engine by Mozilla
currently moving into Firefox it is
developed by Mozilla and the community
and the first stable release world may
15 2015 2 years old as a stable
programming language before that it was
a research project it's providing an
alternative to C and C++ but also to
other high level languages to
higher-level languages and the three
things that focuses on is safe
concurrent and fast and it's generally
perceived that safety especially any
kind of memory safety will make sure
that your program doesn't SEC fold and
all of these kind of things
automatically comes at a runtime cost
usually through having a garbage
collector or some kind of management
system there the thing with rust is that
if we see safe concurrent fast we said
let's pick three of them we can't step
off this the core features of the
language are if you would like to just
have like small she'd they have a static
site type system with local type
inference so you don't have to type all
type all variables that compiler finds
it out itself it has an explicit notion
of mutability so something is immutable
or not and you have to define it it has
something that we call zero cost
abstractions there's at all a small
asterisk on it we abstract stuff so that
it we don't introduce any cost through
the abstraction that's sometimes people
think like just because they're using
the abstraction and suddenly doesn't
cost anything to do it
we just don't want the language to put
any additional cost on using an
abstraction it has run time independent
concurrency safety I will come to that
it treats errors as values there are no
exceptions we have no null we have
something that we kind of move towards
calling it static automatic memory
management you don't manually manage
memory but it also happens at compile
time and you can control it if you want
to and it has absolutely no garbage
collection built into the language it
has no runtime system so what does it
look like just a small snippet of rust
code it is a curly braces language like
C C++ Java you need to have a main
function like C has and beyond that it
looks like a little bit of a mix between
C and if you ever used ml ml it has an
ml inspired matter syntax
it has bindings to variables introduced
by let and another thing that it does an
ampersand if you want to pass things by
something that is similar to a reference
I come to that in a second so it's we
are not inventing too much new syntax
here we're very much inspired on what's
out there so a couple of base concepts
of the language the first basic concept
that you need to understand is you talk
about mutability all the time so rust is
a language about control so it doesn't
say within rust
everything's immutable or within rust
everything's mutable what you say is you
have to define it so given this piece of
rust code I have two data structures one
is in the other and one has a field that
has an integer inside see if the pointer
works yeah so this is the inner one it
has an integer and this is just an outer
one that has the inner one inside I
constructed with some value and I try to
insert to assign this value to something
else this will not compile because by
default everything is immutable it will
actually tell me that cannot assign to
an immutable field denoted Val because
DS is immutable everything that's inside
is immutable I actually have to tell
rust this is moot
this is mutable I can actually mutate it
this is intended and this is you see
that in different kinds of combinations
all the time this concept is everywhere
it's simple at the beginning but it has
repercussions for others and the other
base concept and this is something that
you will if you start learning language
probably I have to get used to for one
or two weeks or something like this it
has a basic concept of who owns data and
who just gets it lend out we call it we
call that borrowing this is something
that is new usually you haven't
programmed in environments that have
this as an explicit notion data
ownership though is a thing that a lot
of people actively talk about when they
think about systems especially in C like
the one that owns data is has to
deallocate it the one who doesn't has to
make sure that they don't delegate it
rust has that as an explicit notion so
the rules around that are every piece of
data is uniquely owned it's just one
owner this ownership can be passed on
losing it in the process and when own
data reaches the end of the scope it's
destructed simply speaking we have a
reference counter that it can only count
to one and once the reference this drops
the data goes a it has to be
de-allocated and this can be done
statically so in an example I have a
file and I have a function that takes a
file and writes to it and we actually
pass ownership every time you don't do
anything special in rust you actually
pass ownership we open that
and we pass it over one of the things
that's critical here is I can never call
that function again who is that file
because I passed on the ownership and
that has very useful semantics because
anything that takes ownership could
actually close the file which would make
any subsequent calls to writing to the
file illegal which the language does
rust is very good at making illegal
State unrepresentable I just can't write
that program in that way what I can do
though is I can reach for the other base
concept that I said um I can say I can
borrow access to it retaining ownership
giving it to another piece of the system
and taking it back and borrowing happens
again in a mutable and immutable fashion
there's a very intuitive relationship
there anything that I borrow immutably I
can power to it many people as or as
many parts as I want because that
ensures that no other party in the in
the project mutates it so it always
stays the same but you can only borrow
it mutable once and it's exclusive so
you cannot have an immutable borrow at
the same time as a mutable borrow you
can have either or the other and
immutable borrows you can have as many
as you want it is indeed so that shared
new mutable state and this would be a
whole other talk is an issue even in
single threaded applications that we
ensure that we don't have it this is
what the code looked like when I would
actually borrow I said like this
ampersand moot is an indicator for I
borrow something mutable II and then I
can say I can write to that file to tie
is because I only borrow out I get it
back I've read again ownership stays in
main and drops at the end this whole
thing is rather simple
um it takes some time getting used to on
how to actually program in that
environment where these notions are they
explicit it also gives a couple of other
things this is a very minimal example
which is
I have a collection of integers and I
borrow out one of the elements and the
collection is mutable and while I still
have one of the elements of the
collection I say I want to modify the
collection by writing to it and this is
something that rust actually detects it
will tell you by the way you've got an
immutable borrower active you can't
currently modify the collection until
that borrow becomes inactive and this is
a very common problem especially in C++
applications when you have pointers to
vectors that you later change in size
and they get real I located and the
point is to the original vector are not
valid anymore we actually can invalidate
those rest checks validity of all
references at compile time even to the
point where we have a notion of some
piece of data holds an internal
reference the binding between those is
this a syntax it's called a lifetime it
says data can only live as long as the
inner data is still active and if I do
something like this and I say I have a
function that returns data which holds a
reference to a local variable once I
return from that function the stack
frame will go this number slot will go
and the pointer would actually be
invalid and the compiler will tell me
that it tells me number doesn't live
long enough it only lives until the end
this is line number nine if I would use
an actual editor I could just go to line
number nine which is this one
so all rust function signatures do not
only signal data type but also
mutability ownership and
interconnections between input and
output types that's quite a lot you can
read an awesome lot from a rust function
signature and the cool thing is this
looks rather simple in small programs
and doesn't really like communicate its
usefulness
the problem is that I can't put Firefox
on the slide I'm very sorry about that
just remember that these properties hold
even in very large programs you pass
something into a library that is 100
thousand line lines big and you do it
immutably you can be sure that no one
ever touches it rust has abstractions on
top of that that I feel a rather
standard they basically like Java
generics or C++ templates wherever you
come from they're somewhere in the
middle I won't introduce them in detail
because that's basically my mechanical
drawing suits Index but it has on top of
that a hidden feature that a lot of
people tend to ignore at first and we
call it concurrency without fear
we actually type check concurrent
patterns let's have a look at this we
have a counter the counter has an inner
integer we spawn three threats and pass
in the counter using a mutable borrow
what will happen here is that we
actually detect that we can only take
this counter and put it on one of these
threads once we would send it over we
actually have this notion of passing
ownership to a thread but because we are
starting multiple threads the compiler
will complain and tell me you're not
allowed to do this you're not allowed to
just simply move the value into one
threat because I wouldn't know what I do
on the next iteration so what do we do
when we need to share something between
multiple threads usually we reach for a
reference counter which gives us some
notion of multiple handling this counter
so let's reach for the RC the RC in rust
is a reference counter that is only
meant for single threads but I could
just use it and see if it works the
interesting thing is that rust has a
notion of things being allowed to be
sent between threads or not and the
reference counter is not for the reason
that it doesn't secure its counter using
atomic
relations that's cheaper but it's not so
that safe you might have missed counts
on the reference counter plus will
detect that what it wants to me in the
end is oh there's an error there
I must actually wrap that in mutex there
should be a mutex on top and an AR see
an atomic reference counter I built a
bug into my slides so rust will tell me
that I need to make sure that I
synchronize on the counter and that I
soon pronounce even on the reference
counter that I use for that counter M at
compile time this example could be a
concurrency bug in a garbage collected
language a sec fault if you're in C and
C++ because you miss cat M this analysis
and this nice thing is purely static and
it's independent of the concurrency
primitives that you use what we talked
about is we're talking about sending
data between threads and syncing data
between threads for between concurrency
primitives
it's descending and the syncing part
that rust knows about if you're working
on an event reactor you can use exactly
the same semantics and and it will save
you from that rust type system allows no
data races at all and that's a very
teasing thing and that's one thing that
is heavily used in production thanks
but still we assistance programming
language so we give low level control
and safety at the same time the thing is
burrows boiled down to pointers at
runtime they are a purely compile level
semantics that ensure that all point is
a valid they don't happen at all during
runtime values you've seen me use the
struct syntax are basically struct
struct like in C we use our own struct
layout we can also ask the compiler to
lay it out like C on the target platform
wall and we have an optional unsafe sub
language for cases where we cannot
guarantee that safety these cases could
be for example interacting with hardware
devices
all these kind of things what we just
can't establish these rules
automatically so our ops engineer has
coined this nice phrase safe code means
you can take better risks so basically
you've write most of your program in
safe rust but at points where you need
like the full detail control you can do
that but you opt into the unsafe part of
the language instead of saying I'm
taking an unsafe language and I'm trying
to make it safe and make sure that
people use it at most places so let's
come back to the initial question is
rust successful so does it move the
state of technology forward it does it
wraps safety techniques previously only
used in research settings in production
ready in a production ready package all
these ideas are new they're basically
from the end of the 90s we just took a
lot of them put them together mix it for
eight years rust was in production for
almost eight years before the one zero a
lot of concepts went in went out we had
a carpet collector at some point we
don't have one anymore
all of these kind of things it went to
extreme changes at some point but this
is basically research Theory applied in
a package that we actually would like to
use in production it brings memory
safety to environments where it was
previously just not possible because it
the only language is supporting it
where unsafe languages or the runtime
needed for it was just far too vast the
other thing that I said is it's used in
sizable production environments
obviously Firefox is a sizable
production environment but this is
Mozilla's house language so obviously
they're using it in Firefox there's also
many other users of it and this is
something that we enjoy a lot Dropbox
has built sizeable back-end systems in
it
so basically Dropbox is now powered by
rust both on the client and the server
side and a lot of places and especially
in the places where any control
the new chef deployment product chef
habitat is completely written in rust
and a sizable project as well canonical
is using it all through the
infrastructure but mostly internally it
is used in several games not to play but
like smaller groups so for example the
developer of start you Valley is
currently using it so it's not just its
indie games but not like small indie
games professional indie games there's a
theater actually using it in Germany for
opera productions generic wrote the code
but that's my most that's my favorite it
but we're used in opera productions we
actually used by more than a hundred
companies and we list them all if
there's someone in the room who's not on
that list but is using rust in
production please let us know because we
totally like especially like to know you
wouldn't and would like to know what
you're using it for there's a couple of
very interesting and especially big
names on it then does it attract
contribution and that's I think a very
interesting thing because the Mozilla
house language I think wouldn't be a
very teasing prospect because that would
mean we're completely reliant on Mozilla
continuing that or not the nice thing is
more than four fifths of all
contributions to the rust language the
compiler and the base libraries come
from outside of Missoula we have more
than 2000 contributors over the lifetime
of the project and a lot of the
evolution of the language is actually
not driven by Mozilla people is also on
in spaces where for example we working
on features that are not used for
Firefox it's mostly community driven but
we were good at actually taking that in
and evolving the language also for other
people so this is the contributors list
you can have we we have this thanks but
Ross landlord org domain where you can
see who contributed to what we are this
is the summary of the year from github
we are the eighth most reviewing project
like we do but the most code review on
github incomplete
we are one of the most discussing
repositories even more than OGS and
right after that there's the browser
that we built in rust so we have two of
the ten and if you sum it up we actually
like bigger than OpenShift I'm I'm quite
amazed by those numbers because I
wouldn't have expected I expected them
to be so good
yeah and do we have sizable growth yes
we doubled in T open Redmont
indices since the last year yeoman read
monk are basically how many people are
searching for us on Google
that's an interesting number it's highly
inaccurate about actually judging how
big the commits the community is but it
also maps to we have double the number
of people actually replying to our
survey that we put out every year and
yeah we currently have five conferences
per year next year it's going to be more
and we have over 100 meetups around the
world that's a sizable number for a
community let's run two years old and we
have newcomers from all directions and
that's the most interesting part of that
we have not only systems programmers
going to rust we also have Ruby and
Python programmers going to rust we have
functional language program is coming to
rust all with very different views on
how the language they would like the
language to be and that's a good thing
you can moderate that another
interesting metric is how many libraries
are published we obviously a new
language we had zero like libraries
published on our index in 2014 when we
opened it we have just last month passed
the Haskell package index so we are now
have more libraries than Haskell and it
took us two years instead of 10 I
totally love Haskell it's just like
they're in the same range as we are so
this is kind of something we need to
compare to if I would add NPM basically
all these three lines would be flat
the other one here is Alex here which I
find a very interesting thing because
they have this noticeable point where
they increase dramatically in their
growth usually these lines are flat I
don't know why package manager numbers
are very flat I would really like to
know why and we attract positive
feedback we are the most loved language
on Stack Overflow in 2017 2016 and only
around 1% of the survey respondents said
they have issues getting in touch with
the rest community or or communicating
with us which I see if we can reduce
that but and we get like this came on
our subreddit yesterday when I was
preparing this talk I just said to like
someone disperses a present bless us
stations ok I think it's a bit much but
thanks but why is that it's not like we
randomly just got successful
in my opinion because there's a lot of
things behind that first of all when I
joined the rest community four years ago
one of the heirs we had one of the air
behind this whole thing is we want this
to be used like we're working on a
language that we want to be used this is
not a research language there's awesome
research languages for example idris
owns being a research language it's
awesome for that we are a language that
we want to see used in production
software for that reason it was also
always developed in lockstep with a huge
application there was always several
next to it a sizable well multiple
hundred thousand lines code base of
building a new browser engine which
helps a lot when you develop a language
because you can actually figure out if
we change this what impact does it have
on a real large code base and not on a
ten lines slide snippet we make sure
that the language is approachable it is
easy to get an environment setup we have
tooling that just gives you a compiler
of different fashions it gives you if
you want to cross compiling tooling and
all of these kind of things
we build in built and dependency
management as part of the tool chain
that we ship so you have something like
bundler but for for rust it has
development tooling on top of that we
have a language server that implements
the language server protocol where you
can get errors over a network socket to
show them in your editor and all of
these kind of things it does all the
analysis for you and you don't need to
parse it as well as additional Inter's
for coding patterns and all these kind
of things we take a lot of pride in our
of error messages the next talk is gonna
be an elm which says we a little worse
than elm and this really like the king
of that but it's not unusual that like
new rust releases will have more and
better error messages and there's a
couple of people that take real pride in
that we have great blocks to the book
and an almost fully documented standard
API
the thing with great Doc's is they're
much better than what's mostly out there
for a lot of new programming languages
we have actually someone employed the
writes on it obviously there's always
like the one gap or the other if you
want if you if you notice one while
you're reading it let us know we
actually have a youtube channel that
collects all talks and lectures so once
this one is on YouTube it will also be
there it has some lecturers also in
German on a German university and
collects all thoughts on all conferences
on all subjects for you to be easily
searchable and we have maintained forums
and RAC and other chat platforms to get
in touch which I used heavily Russ is a
very pragmatic language and I think that
helps in adoption all features are
driven by the needs of real software so
we make sure that every release actually
unlocks something useful for some of our
users this might not be for you but it
might be for others and people see where
it's useful the language is mostly
evolved with user feedback so it's not
like some people in Mozilla just get
into a room and come up with a with a
change and we consciously choose
familiar constructs them in the case
that there are some available so the
thing like
borrowers are kind of related to
references so we use an M percent for
that so the people that are used to
references actually can just piggyback
on the syntax and we pick good ideas
from others like our error messages are
definitely elements by it so we look
around for other languages to see what
they do see how they build the
infrastructure the language plays well
with others but and that helps in
adoption we can compile code to just
normal object files or just normal
static or dynamic libraries which you
can write a header file for and then
just use it in C code or the other way
around or you can use the csfi of your
favorite language you don't need to
write rust tooling on top of that you
can it makes it things a little better
but if you use to the CF fi of your
language you can also like immediately
use Russell libraries they're binding
generators available for C and C++ that
are really good because they're heavily
used in Firefox and said though they
just need them and there's high level
bindings for some other languages Ruby
JavaScript Python you know it's a great
partner for those languages because the
nice thing is usually when dropping down
to see from pison or something you give
up memory safety when you drop down to
rust you don't give up memory safety
which means you don't SEC fault your
Django application as simple as that and
it doesn't want to be the primary
language at all cost we're very used to
all of our users using it somewhere in
the infrastructure there's almost no
people around that I know that are
purely rust programmers most of the time
they're like 50% less programmers and we
are totally built for gradual adoption
that has helped us a lot
just as a project to have a look at
stylo is the thing that powers Firefox
quantum like the speed increases behind
Firefox quantum for external marketing
purposes you also sometimes read as
quantum CSS the library is still called
stylo it is taken from the server
project hold it over to Firefox and then
it's all the styling but the style
engine does
it applies styles that you have in it it
passes a CSS file and then applies the
styles that I found to a Dom tree the
interesting thing about this is no
browser currently does that in parallel
although it's theoretically known that
this is a highly parallelizable task
Mozilla tried that two times and failed
and actually succeeded with this and one
of the things is they ran into a lot of
multi-threading bugs that would have
needed building a lot of machinery on
top of this basically the whole thing
the whole magic be here behind stylo is
the concurrency tracking that res
provides to make sure that you don't run
into accidental data races and that
allowed doing this whole rewrite in
about a year and then at the end the
ability to just use C FFI or like
directly access memory structures as a
base concept of the language rust has a
memory model similar to C allowed for
visit very easy integration also because
rust has no runtime so that you would
not have to think about how to integrate
the rest runtime into Firefox or
something like this then there's a
couple of reasons beyond plain code we
have a strict commitment to stability
rust is released every six weeks like
Firefox one of the reasons behind that
is we want changes to be small so
usually we don't have breaking changes
but sometimes we need to fix like side
some as holes in the type system they're
rare but it happens and then we want to
make sure that people don't have to move
the world just to move to the next
version it also means that you should
usually like read up on the changes in
round half an hour or something like
that
and be it's be easier to follow rust is
backwards compatible with huge machinery
to ensure that we literally download all
public rust code and build it when we
try to find out if we will build a
conscience backwards camila debug we're
currently at version 121 next one is
coming in around five weeks also we
allow no use of any kind of unstable
in development features on our stable
compiler so if you have a thrust stable
compiler everything like every interface
it exposes is stable
everything else is only available in
nightly builds so that you do know that
you're actually using unstable stuff and
we don't want to release anything that's
not ready for wide use on our stable
channel if it's unstable it's stable you
can use it it's fully supported we
piggyback on a couple of things to
provide maturity we our cogeneration is
provided to LLVM so we piggyback on the
maturity of LLVM and all the on all the
targets it supports we have no runtime
so we have no runtime bugs there was a
time when Russ still had a runtime and
that was really awful and and we have a
very conservative approach to adopt
things into a standard library so we're
not like a batteries included language
we have batteries easily downloadable
language it is a cross compiler Russ C
is by default a cross compiler and the
whole tool train is aware of that
this almost no setup press compilation
the only thing that you need is the
indifference to go for example you need
the target the Lipsy and all of these
things for the target and we support
embedded and IOT use cases we even have
a whole cortex a whole operating system
written for cortex-m IOT devices written
in rust
it's called suck us and yes we do wasn't
so for those that had seen the talk
before we also have a whole governance
structure built and that helps us a lot
for example all changes go through an
open RFC process so if even if someone
at Mozilla wants to change something
language they write a large document and
people can then comment on it usually
that works quite well and discussions
are small but it can also happen that a
feature is controversal
we for example had a reform feature that
was shot down three times over this year
and is much better for it now I have to
say but this is a part of the process
and the thing is Mozilla is about the
only
company that I know that has a great
experience with open discussion and
processes that shows that doesn't mean
like everywhere at Missoula that works
like perfectly but at least Missoula has
the concept of having open collaboration
on a project they produce we track a lot
of things for example the medium time to
merge a pull request for a change to any
kind of our things is six days which
means if you have like a correction to
the to the documentation it's probably
merged when the maintainer wakes up if
it's a larger thing it can totally be
that it takes like 30 30 to 40 days but
we don't let you hang around for a year
or something either we will deny it then
or say we have to postpone it or we we
actually move move forward to make sure
that it's merged we also support
commercial users so we do regular
interviews with production users to hear
about their issues that's usually not in
the open because they usually don't want
to talk about that in your that's fine
you can always contact us with like
production problems because we'd like to
know because that's very hard to get
this information most of the time we
have consulting developing and training
available through a US company and mine
the more coming up it slowly comes up
Russ training is actually a sizable
business that both of these companies
currently have and here's another hack
um if you run a larger open source
project I don't know why a lot of people
don't do this we put everywhere that if
you have any questions about the project
you can ask the community team we just
forward you to the right person and once
you do that for like two or three years
people who will actually use this
there's so many people that get in touch
with us who that email address that we
currently have to see that we can follow
up on all these emails but there's so
much information in this and especially
there's so many people that are like I'm
completely lost I don't know how to like
approach this problem and probably
someone who's in the community longer
just knows and this is like a three
minute task for me what could be a three
hour task for community members and I
would totally love that
they spent their time otherwise
so to close up rust bring safe
programming to targets where it was
unfeasible before while also bringing
new things to the table to compete with
other safe languages like the whole
concurrency tracking and basically the
whole thing too difficult way to sum it
up is you can't spell trust with the
rest yeah thank you I was just looking
for my mic we've got a lot of questions
that I will go through first of all is
there so good or what's the best IDE to
use for rust so people want to get
practical yeah I can oh by the way if
anyone's leaving take one of these
postcards it has like the most important
links that you need to get started with
rust and you can touch into the
community I des so we're producing the
rust language server and we're also
producing the integration into a Visual
Studio code which is an editor not quite
an ID and jetbrains actually ships rust
IDE which is their their production it's
really really good so if you want to
have if you want to have like a proper
IDE that would be the one that I would
recommend I know that there's some
people working on visual studio
integration that's also one of the
reasons why we're actually implementing
the rust language server protocol
because that's what most IDs are
actually used this to JetBrains doesn't
so to sum up a Visual Studio code
jetpens IDs are the ones that you can
totally use in our production ready be
on the lookout for visual for visual
studio proper then there was the no
that's a quote about another programming
language I will not say it but what
about the rust compile performance
that's I'm always waiting for this
question so one of the reasons the rust
has a name for not be
the fastest language to compile this is
also not the slowest but for example
several compilers for like 20 to 25
minutes one of the reasons why that is
the case is actually not quite in the
control of Rossi for example one of the
things is we we generate code and we
push it to LLVM and lrvm and losing a
lot of information in that process for
example rust as a language forbids that
any point is too awliyas any mutable
point is too odious and this is
something that c compilers try to figure
out by static analysis and we're
throwing away that information once
we're pushing that to LLVM and LVM
starts figuring it out again there's an
interface for that in LLVM it's
currently broken so we're working on
fixing that so you can you can push that
information into LLVM it will then miss
compile so these are like the things
that we're working on also that's on our
side would get generating far too much
code so this is something that people
can really work on the thing we're
constantly working on improving those
times is usually you we gain around like
20 to 30 percent over half a year in
compile performance so this is the range
of optimization that the chris compiler
currently has it is usable fast it's to
say so and also it's like when you're
using c++ if you go overboard with
generics and the compiler has to roll
out all the specializations for all the
generics that's just going to cost you
at compile time so there's even
programming techniques that go around
this problem a little if you're working
on a large scale another question that's
very often asked about about languages
that our system languages how to ask
written itself rest is written in rest
is written in rested we've got a lot of
that too that the rest compiler doesn't
know what a newline is the definition in
the rest compiler is literally if you
see /n in this in the parser if you see
slash and n then it's slash n the
literal the reason why this works is
because we compile rust with rust rust
knows what a newline is
so we can inject into the next compiler
the next generated compiler what the new
light was it's a nod to the two
reflections on trusting trust yes we we
are self hosted and we have fun with it
okay
what about performance compared to C++
or Java hi I mean that always depends on
what you're doing
so in general like the performance is on
par with C++ it's with all the footnotes
that you have was C++ as well first of
all it might be the trust doesn't update
it does not do an optimization that a
C++ compiler would do currently that's
the thing where we slower but like model
wise the languages are pretty close and
are landing in the same way in the same
range it might be a couple of
milliseconds more a couple of
milliseconds later away the comparison
with Java I find very hard to do because
there's a couple of algorithms that
really really like garbage collection so
the problem there is basically not like
it's Java faster or this Java like which
programming model do we support better
so Java is incredibly fast
so probably same range usually a little
bit faster depending on the algorithm
it's a very complex subject there's some
blog posts out there about this another
well a question to be expected is the
comparison to go or D but it's more it's
not about the performance it's more
about what is the stuff that rust offers
that those don't D is an interesting one
go go we usually have the same one as a
board game the other as a programming
language the reason the reason why these
and that's not piling on go the reason
why these languages are often compared
is because they were published like the
research project rust and the language
go from Google were published around the
same time basically two months between
and to add to that the rust that was
published back then actually had like a
little channel syntax and channel
semantics inside the language and
runtimes
and I think that influenced rusts a lot
because that meant no one needs go from
from Mozilla no one needs that you can
just go use go from Google so that meant
that rust went a radically different
direction and actually said we're
throwing our all runtime stuff we're
throwing out the garbage collector we're
moving to this completely static model
where we can go on embedded devices
everywhere AC is used and all of these
kind of things the comparison to go is a
little bit 2d is a little bit different
addy has an optional garbage collector
and depending on whether you need that
or not the language is a little bit
different so kinda has this we opted
into a runtime system or not D is old
that means it both has maturity it also
hasn't quite caught on like as a
community person mostly like D is a very
interesting thing to discuss about but I
can't say to say too much about it well
then maybe this one is interesting which
part of a legacy system would be the
best to target for replacement and rust
modules everything that uses heavy
concurrency and it's completely broken
for it so if you have if you have a
piece of the system where you don't have
any control over because of these
properties maybe rewriting in rust gives
you basically static analysis that you
would otherwise pay a hundred thousand
euros for or more
okay now more provocative question what
are the weaknesses of the language
compile times at first it is a
completely static language so if you're
trying to like I always say like if you
talk about reflection rust is a vampire
language it doesn't reflect at all so if
you want to do any kind of very dynamic
programming i'm as you've seen i'm i was
a rusty programmer before if you want to
do any kind of heavy
dynamic programming Russ is just not for
you it's not an object-oriented language
there's no like message sending between
objects or all these semantics don't
exist so if you if you are comfortable
with these client kinds of environments
then probably rust is not for you and
that's definitely a weakness of language
yeah also currently depending on the
field you are in maturity of libraries
but that's really heavily dependent on
the field you're and like everything
that has to do with HTML parsing all of
these kind of things you can use the
libraries that server provides they're
like top there's a couple of very good
libraries for writing games and engines
and all of these kind of things as like
basics you can use that this other
fields were well we're not that far yet
comes with the age what is rusts take on
non-blocking i/o okay oh it's a we have
a whole framework framework around this
it's called tocayo
and an implementation of futures so if
you're comfortable with the futures
interface we have a we have a library
that provides it as an interface and
then we have Tokyo which is a library
that runs futures on an event reactor
there's also an implementation that runs
futures on the gtk event reactor gtk is
currently binding heavily to rust and
there's implementations of running
running these on a thread pool which
wouldn't be icing io but yeah if you're
interested in that Tokyo is the thing
you want to use and then something maybe
well I I don't understand the question
but maybe you two is puzzling possible
wire LLVM why LLVM i know that we we
have tools that first using american
fuzzy blob and lip fuzz I don't know
what DLL for I don't know about the LLVM
fuzzer hmm okay that is probably that
yeah so we have fuzzing there's quite a
lot of people that actually practice it
a lot so you can find tutorials for that
and do it there's even integrations into
our build tools as a plugin okay well
any any questions in the room here we
still have Oh No
well actually we are at the end but if
there would be an urgent question I
could know okay
fine thank you
and let's forget these</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>