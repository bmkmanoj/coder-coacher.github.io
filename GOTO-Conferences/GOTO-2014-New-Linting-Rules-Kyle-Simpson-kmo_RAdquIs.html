<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2014 • New Linting Rules • Kyle Simpson | Coder Coacher - Coaching Coders</title><meta content="GOTO 2014 • New Linting Rules • Kyle Simpson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2014 • New Linting Rules • Kyle Simpson</b></h2><h5 class="post__date">2014-12-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kmo_RAdquIs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everyone I have the dubious
distinction of coming right after the
keynote that makes everybody cry
so and I have to say that you may cry
but it's for a different reason
because of your JavaScript coding but
we're going to jump in today and discuss
linting rules for JavaScript and of
course this is kind of a a a deeper
level talk because I'm gonna show code
and I'm gonna expect that you can follow
along quickly it's gonna be quite a bit
of code I'm not actually doing any live
coding but I'm going to show you code
and show you things from my experience
so we're we're gonna start with is this
linting tool that I wrote to basically
give a set of opinions about code so
we're gonna actually spend our time
today on the command line using this
linting tool and if you'll notice
closely this lending to all I wrote way
back in 1995 when JavaScript first came
out that's obviously a joke because that
wasn't true but I did write that this
linter to try to help us understand
JavaScript because that's what I spend
my time focusing on so just real briefly
I can give you some information about
myself if you don't know who I am Kyle
Simpson that's that you can't read but
I'm Kyle Simpson getify online if you're
into the online stalking thing you can
check out getify dot me and it has links
to everything that you need to know
about me and I do appreciate feedback
both positive and negative I get people
that tell me you're full of crap and I
love getting that sort of feedback as
well so do feel free to reach out and
give feedback definitely also make sure
to do the voting so that we as speakers
can get better at what we do I am an
open web evangelist I'm based in Austin
Texas over in the States but I basically
visit there these days because I spend
my time on the road I speak about
JavaScript and I teach JavaScript so as
a tiny little plug if your company is
interested in having someone come and
teach about JavaScript please let me
know because I'd love to do that alright
so a kind of a setup here that we need
to understand about why this talk is
this way
I think our industry has benefited
tremendously from books like JavaScript
the good parts but it's also hampered us
as an industry because I believe it's
taught us to sort of run away from the
difficult parts the tough parts
the books that I speak about and the
books that I ride and the things that
I'm speaking about today in fact all the
teaching that I do it's really designed
to take the alternate approach to things
which instead of saying let's relegate
ourselves to a small subset of the
language it's JavaScript all the parts
so I'm sort of the anti the good parts
but that doesn't mean the bad parts it
just means that we're gonna go after all
of the parts of JavaScript we're gonna
jump right in in just a moment talking
about types and then about coercion and
the those are the sorts of topics that
most people say oh I don't need to learn
I should avoid because we've been told
that they're just bad and I'm going to
take the opposite approach to that so
since I mentioned the books I should
just go ahead and do a quick plug of
these books this is the you don't know
Jas book series and I have some of these
I have three copies so it's not a lot
but the first three people that want to
come up and grab a copy they're also for
sale out there I think they're giving
20% off but you can read the books for
free up on you don't you don't know Jas
calm so it's a series of books I've
written three I'm working on the fourth
title right now there'll be a total of
five and I also free stickers if you're
interested so enough of that
self-promotion junk let's jump in so the
stuff that I'm going to talk about today
how many of you by the way how many of
you use a linter on your own coding so
Jas Lynn Jas and things like that okay
good those of you that are not I highly
encourage you to do so but we need to
make sure that we understand something
about lenders that I think is commonly
confused many people think that linters
are about checking program correctness
and that is not that is not true
whatsoever your program correctness is
validated by your unit tests and also by
running your programs in production
that's how you know if your program is
correctly doing what it's supposed to do
it's also not checking validity your
program validity is checked by your
compiler by parsing the code and
checking to make sure that the grammar
rules are correct that you're not doing
illegal things those are all things that
existing other tools do so then what is
the lender for if it's not for
correctness or validity the linter is a
set of opinions you probably have seen
jeaious lent that statement about that
the linter will hurt your feelings so
today's talk is a winter and I might
hurt your feelings quota
quote by suggesting to you things that I
think you're doing that I think are dumb
in code but they all come from the same
mistakes that I've made so I'm really
speaking mostly to my my past self as
well as to the rest of us so but in the
same way that when we use linters that
are a set of opinions about how our code
should be formatted and styled and and
the idioms that we should use in the
same way that we use linters to do that
I want you to take this that I say to
you today with a grain of salt
understanding that these are just my
opinions and you can choose to use those
hopefully this piques your interest and
it gets you to ask difficult questions
about your code discuss it with your
team but you're free to pick and choose
so when we call it a rule it's just a
set of opinions okay
so without any further ado let's go
ahead and jump in the first thing that
we're going to jump into is a discussion
about types I'm sure many of you have
probably heard the statement before the
JavaScript has no types because it's a
dynamic language and that's the first
myth that I'd like to bust for you to
suggest that JavaScript has no types is
to not understand the mechanism
whatsoever
now the word type of course is very
controversial depending on which
language background you come from if you
come from a static typing background
something like Haskell or something like
that
you're gonna vehemently disagree with me
using the word type and you're gonna
suggest to me that I'm completely
abusing that word and using it
incorrectly so what I will fall back on
is that I didn't make up the word type I
came along a lot later after and it's
actually the people that wrote the
specification this is a snippet from the
specification of JavaScript that uses
the word types to describe and I'll give
you a loose working definition for what
we talk about here a set of intrinsic
behavior that is associated with a
particular value for example the number
42 we know beyond it being the meaning
life we know that the number 42 being a
numeric type is something we can do math
with we can add and subtract and
multiply and divide those numbers the
string 42 quote 42 is a different type
of value of course it might be outputted
the same but we use strings differently
we can catenate them we split them we
upper and lower case them we do things
differently with these different types
and in fact the specification as you see
right here it says an equi script
language type
sponsor the values that are directly
manipulated by the programmer I think
that's really important to illustrate my
working definition for types is that
it's based on the aesthetics or the
ergonomics of what we do in our code we
reason about the number 42 value
differently than we reason about the
string 42 so these are types so let's
come back to start linting some code I'm
gonna check a file that I've got called
type CS and we're gonna see what the
linter has to say about some of these
types all right so we see right off the
bat type of operator and type of null at
the very top everybody's favorite bug in
JavaScript the typeof null returns
object it's just plain old simple it's a
bug that ought to have returned the
string null but let's look at some of
the other ones they're more well
behaving type of undefined returns
undefined typeof true returns boolean
string number object and then down at
the bottom you see function now you
would be forgiven as I was for many many
years if you thought that function was
an actual type in fact if we go back to
the specification functions aren't
really a type they're really sort of
like a subtype a subtype of the object
type and we know that all functions are
objects I'm sure you've heard that
before but as a subtype of objects it's
probably more appropriate to think about
functions as callable objects there are
objects that have this special
capability that they can be called but
again from the ergonomics of the
language we see that type of function
returns the string function so we reason
about functions very differently than we
do about general objects so I think it's
appropriate at least from the ergonomics
to think of that as a type or rather
perhaps is a subtype okay so the typeof
operator returns one of these six
strings this is es five and below
there's a new one that's being added as
of es6 but we won't dive in that today
so one of six possible strings can be
returned and they correspond directly
with the types that the spec calls out
that's my case for why these are types
so if you're going to argue and say well
it ought to have been called tags or
something like that take it up with the
spec authors as far as I'm concerned the
way I write my code I reason about the
number 42 and the string 42 differently
okay so let's see if the linter had
anything to tell us when it was checking
these things it's it gave us a couple of
warnings for sure the warning
about typeof null being buggy and also
it gives us a warning that even though
the type of function returns that object
subtype we should be careful that's a
should be careful about these type
nuances another thing to point out by
the way if it wasn't obvious to you that
in JavaScript when we have dynamic
typing or non type enforcement in our
language we have types but they're not
enforced what that really means is that
in JavaScript variables do not have
types values have types the value 42 has
an intrinsic behavior associated with it
that it's mathematical that it's numeric
so the value 42 has the type of number
but the variable that's currently
holding 42 it has no type whatsoever
it's just a general container that can
hold any value of any type so it's
important to keep that in mind because
that's different from other languages
with type enforcement where it's not the
value that we reason about the time but
it's the container we declare a
container that can hold integers we
declare a container that can hold arrays
two strings and so forth array pointers
to strings okay so now that we
understand that there really are types
the next thing that we're gonna want to
deal with let me pull up the man page
for everybody's favorite thing to hate
which is coercion the double equals
operator many people have heard about in
JavaScript and many people have heard
that it's evil that we shouldn't be
using that a double equals but I would
push back and I'd say that double equals
in coercion can actually be quite
helpful and I would caution you to be
aware of all of that negative hype that
you've heard in fact we're gonna push on
some of that and see that some of those
assumptions have really just been fun so
let's pull up the man page for the
double equals how many of you have heard
this before the double equals checks the
value and triple equals checks the value
and type unfortunately that's not true
actually what happens is the double
equals allows coercion and triple equals
disallows coercion now why does that
matter am i just you know parsing nuance
in academic speak it actually it does
really matter it matters from a
correctness perspective but also matters
from the way that we reason about these
things if you look at the first set of
descriptions which one of the two of
those appears to do more work and
clearly the triple equals appears to do
more work because it's checking both
value in the type but if we look at how
it actually works if we look at what the
spec says about how it works double
equals allows coercion and triple equals
disallows coercion
therefore double equals appears to be
doing more work and in fact this bears
out fewer to do performance tests with
veil values of different types and you
were to compare using double equals
versus triple equals the coercion rules
that go through do actually take a
little bit of time not a lot we're
talking about a couple of microseconds
difference so you're not gonna see any
differences whatsoever if you've heard
people say always use triple equals
because it's faster that's just fun
because nobody here is going to be
writing programs where you're gonna be
doing tens of millions of comparisons
all right together in one particular
thing to even come close to noticing
four or five microseconds difference
between the two so it really reframes
things now I'm gonna have to question a
little bit of authority here because
many of you are gonna say but I've read
the the good parts Doug Crockford he's a
smart guy he knows what he's talking
about and he says that we should always
avoid the double equals well actually
that's not entirely true because if you
go to his book which I will use a quote
from if you go and look at his book he
says blah blah blah when comparing any
of these falling values always use the
triple equals right but it's that part
that I've highlighted there if you want
the type coercion then use the short
form right there in the Bible for
JavaScript that everybody has taken is
their religion for how to understand
what javascript does Doug Crockford
himself endorses the idea that if you
want type coercion then the double
equals form of that operator the the
shortened form of those operators is the
appropriate mechanism to use which
actually reframes this debate it's not
about whether Doug Crockford likes it or
not it's actually about do you want type
coercion or not and then you're gonna
say absolutely I don't because it seems
like black magic and I'm gonna try to
prove to you in just a moment that it's
not but I really want to reframe this
debate it's not that it's evil or bad or
buggy or magical or any of those sorts
of things it is simply a question of
choosing as a responsible developer is
this a mechanism you want to use is that
a tool you want to use or not so let's
pull up or let's lint ourselves another
file I'm gonna look at a set of coercion
zand what I've tried to do in this
file is come up with the worst of the
worst I could give you literally an
infinite list of cases where coercion
works exactly the way we would expect
there's lots and lots of places where
coercion is totally sensible but let me
give you an example of a list of sort of
the worst possible offenders here I
picked out 24 sort of corner cases the
worst possible offenders that we could
come up with in coercion these falsey
values that tend to create some
weirdness and you'll notice that out of
the 24 of them I've marked 7 of them as
us this is oops this is some gotchas but
out of 24 there are 7 of them that
definitely bears some further
examination and then there are 17 of
them which are completely sane and
reasonable and that probably doesn't fit
with what you've heard which which is
that most people suggest that coercion
is all evil or it's mostly evil and in
fact the the comparison visually here is
that most of coercion is actually quite
sensible and reasonable and there's a
few small cases that we should avoid and
we'll look at what those cases are I'm
going to try to give you some practical
takeaways to avoid those 7 owes and it's
not going to be as difficult as you
think but if you were to try to make
this list it's an infinite list of
really good coercion stuff that's useful
if you'd like to use it in your program
and 7 gotchas that if you could come up
with a simple set of rules like the two
that I'm about to share with you then
you could avoid those 7 pitfalls and use
this mechanism to make better shorter
cleaner more concise code so let's go
back and see what the linter might have
had to say about this you notice that it
calls out those 7 it gives us some
warning so for example warning quote
zero equal equal false uses an unsafe
equal equals coercion so it's telling us
these things are unsafe you shouldn't do
that so seven warning 17 out of the 24
coercion tests were perfectly a fault
fine and we should avoid the few unsafe
ones now if you have trouble with some
of these corner cases and the rules in
fact if the rules give you issues I have
lots of bugs in my code but types are
almost never the thing that causes bugs
in my code but if you do struggle with
that there are tools that can actually
help so let me give you just one tool
that I like it's
restrict mode and if you look at
restrict mode org you can see that they
have a build tool this does not
transform your code for production but
it's a development side build tool that
will transform your code it will go
through all the places that you're doing
these quote-unquote
unsafe coercion and it will put checks
around them and then you can run that
code with real input and it will spit
out warnings if you're doing stupid
stuff like for instance comparing
strings to arrays that's an unsafe
comparison but if you're doing safe
things like string a number which in
almost all cases are totally rational
insane if you're doing those it doesn't
spit down any warnings so if you're
struggling with this and you're saying
it's just too difficult for me to reason
about just six tiny little types then
there are tools that can help you with
that it's not a well I have to avoid all
types entirely and all this nonsense
about things in fact most of that noise
that's made in our industry where people
say coercion is bad and it's evil and we
shouldn't do it if you go and look at
the code of the people that are saying
that they use coercion all over the
place yes including Doug Crockford you
can open up his code and he uses
coercion both implicit and explicit all
over the place because it's a reality
that that's what's important so that's
really more one more one of those cases
where he's saying do as I say not as I
do
which is ridiculous right see there's
something deeper here we need to be more
responsible with our code so restrict
mode org is a nice useful tool and there
are other tools out there I think
Facebook is coming out with a tool
called flow that seems to be doing
something very similar so there are
tools that that can be made and you can
make your own tools to do your own
checking so let's actually go back to
checking some more code because I
mentioned oops
I mentioned that there are the seven bad
cases so let's actually dig specifically
into those bad cases for just a moment
remember these seven bad cases these are
the ups these are the O's okay so I've
partitioned them off the four on the top
and the three on the bottom the first
rule that I want to give you as a
takeaway is that you should never ever
under any circumstances with zero
exceptions ever make a comparison with
double equals false or double equals
true if you're doing that you are doing
it wrong plain and simple end of story
double equals true and double equal
faul should always be avoided so what we
see here is the first four of our seven
are using the double equals false
comparison now I could dig into the real
reasons why that is but generally
speaking the reason why those should be
avoided is because it tricks our
developer brains that the way that it
explicitly has a boolean on one side it
tricks our developer brains into
thinking that it should take the other
side the thing that's not boolean and
make it boolean but that's not what the
algorithm says you can open up the spec
and is a very simple ten or fifteen
lines in the spec that says exactly what
to do it's not magic or random or
anything like that but the spec does not
say if boolean is on one side make the
other thing truth your fall see the
operator tries to trick us when we use
it like that into thinking that's what
should happen but that's when we get
these weird things like for instance
that false is equal to empty string we
would think that it should take that and
make it equal to a false and so it's
just sort of an happy accident that this
ends up being true but that's not really
what's happening at all in fact most of
these coercion 's depending on the way
you go through the steps most of them
end up converting to numbers and doing
comparison of numbers so avoid double
equals true and avoid double equals
false
and we've immediately taken that list of
seven bad offenders and paired it down
to three the three that I show they're
on the bottom and I won't belabor any
more specifically you know if you dig
into these things there's there's
actually reasons why line seven and
eight you almost never would actually
compare anything directly to an empty
array that's kind of ridiculous when you
actually try to examine the way that
that would happen in a real code because
we know arrays are held by reference so
you would already have some other
variable on some other side that had to
have some reference in it
that's not common that these sorts of
things happen and that's really the
theme that I'm trying to get across here
is that you've been told and you've been
believing that coercion is a real
pitfall that it's going to just break
every single program out there and in
reality there's not a lot of problems
that actually crop up if you want to
read more about that by the way this
third title of the book serious types
and grammar it has a whole like nearly
seventy page chapter on coercion x' and
i deal with specifically all of these
cases so basically if you don't follow
the rules you get what you deserve don't
be dumb the rules are
rule number one never use double equals
true or double equals false and rule
number two if the values can be empty
during zero or array you should be
careful you should perhaps probably
avoid using the double equals so reason
about your code and decide is it
possible for the values in my
comparisons to ever be empty string 0 or
are empty alright and if so just out of
an abundance of caution avoid it but in
all other cases besides these two this
is literally the only rules and I
believe you can use all the rest of
coercion to make your code simpler and
more straightforward instead of having
these double equals on true and double
equals undefined and things like that I
think it's much better to use the sort
of terse form I have this kind of theory
about coding I don't know if it applies
to anyone else but I have this theory of
coding that the more things that I write
the more chances there are for me to
screw something up so I prefer to write
less code when it can be terse and still
be correct another example where
coercion for example why coercion can be
useful is null and undefined if we open
up the Specht and the spec says that no
one and defined coerce to each other and
to no other values in the language which
is actually very useful we can treat
them as indistinguishable so I have this
a and B and we notice that a and B are
equal to each other but neither a nor B
is equal to any of those other
troublesome false key values because
they coerce to each other and to no
other values so your choice is line four
which i think is much more
straightforward or things like line 15
were you having to do things very
explicitly with the triple equals and
when people tell you well it's better to
be more explicit they never they always
gloss over the fact that you actually
have to do two comparisons now rather
than one so even if it was tiny up even
if triple equals was a tiny couple of
microseconds faster when you only do it
once when you do it twice it ends up
actually being slower so the reality is
that there's a lot of fun that I think
we should let go of we should start
using coercion to our benefit in our
code so let me boil this down for you
because everybody likes tweetable
protips
use coercion where it's safe and
convenient and don't use coercion where
it's unsafe plain and simple be a
responsible developer don't just listen
to the hype that somebody said along the
way or you had some bug and it was
because you ran across some corner case
that's not a sufficient reason for
throwing out an entire important part of
our language rather than running
from the things that are a little bit
difficult maybe we ought to run towards
those things and learn them and I've
just given you two simple rules which
should help with that okay the next
thing that we're gonna talk about I'm
gonna pull up the main page for
anonymous not the hacker group anonymous
functions are always a bad idea I'm
gonna give you three simple reasons why
I think you should never ever under any
circumstances with zero exceptions use
anonymous function expressions in your
code they yield confusing stack traces
and they make your code harder to read I
think you should avoid them so let's
pull up I will check a non-functioning
you recognize code like this anybody
have a written code where you've got
click handlers and then Ajax calls and
timeouts inside of those things and we
nest these things together alright so I
have three functions here you'll notice
that on lines one on lines three and on
lines five I have these anonymous
functions now at the moment I'm not
actually talking about whether it's in
line or not I'm simply talking about
whether it is an anonymous function
because it has for example function open
closed parenthesis it has no name there
this is of course the most common idiom
that you see and it's encouraged this
sort of anonymous lambda style is
encouraged by people that do coding and
all these other languages I mean and all
these frameworks things like jQuery and
so forth
this is incredibly easy and simple to
sort of write that kind of code but I
would suggest to you that you're making
bad code decisions by using anonymous
functions you should always put a name
there let's see if the linter had
anything to say yeah all three of those
that said the func should not have a
name anonymous functions make your code
sad what is the alternative then if I
were to fix it in a non funk stew
the alternative is to simply insert
names so I now have names like handler
request and response none of the rest of
my code has changed but instead of doing
ridiculous things like using arguments
Akali or other weird ways you know of
doing self reference you'll notice that
I have nice convenient lexical variable
names like handler and request to refer
to these functions so I promised you
three reasons why the first one is that
when you name a function expression it
gives you a simple self reference inside
of that function
no it's not the this keyword we're gonna
get to this confusion here in just a
moment but this keyword is not how you
self-reference if you give a function a
name a function expression a name then
you get a self reference so it makes it
easier for recursion for event unbinding
things like that always give it a name
and by the way give it a good name don't
use fubar give it a reasonable useful
name like I've done here with handle and
request and response so that's the first
reason the second reason why it's better
and I think this alone stands on its own
as a sufficient reason is that how many
of you have ever had stack traces where
it said anonymous function and honest
function you know a thousand times it's
ridiculous and difficult to debug guess
what if you put a name on your function
expressions it uses the name and your
stack traces so it makes your code
easier to debug especially if you use a
reasonable name and especially it's true
if you've got this code like it's all
minified on to one line and it's like
line one character thirty-two thousand
seven hundred twelve nobody knows what
that is but if you've given it a useful
and reasonable name you have a better
chance of understanding and debugging
your code and the third and final reason
is that it actually can't make I think
it's stylistically it makes code more
readable I do not have to look at the
surrounding context of the function
header for the word respond for the
function response there on line 3 as we
show I don't have to look at the
surrounding code to understand what that
function is doing the the name that I
give it is sort of self documenting if I
had the anonymous functions like I did
in the previous code snippet in the
anonymous functions here I actually have
to look at the context I have to go and
look for what is it doing and that's not
that's not useful to anyone that's
that's going to create more confusion
for your code so simply giving them
names those are the three reasons self
reference better debuggable and better
code maintainability okay so there are
other problems and this one is saying
that in this particular case there's not
really any value in using the inline
nested functions now this is where I am
actually suggesting that perhaps you
shouldn't even use function expressions
maybe you should pull things out as
function declarations as I've done here
because with function declarations
actually things get an awful lot more
readable
instead of nesting things together the
way people have always told you I didn't
change any of the functionality of my
code but I used function declaration
with those same names and now things are
a lot more reasonable because I can look
just at the handler function and
understand that after a timeout it calls
the request and then I can look just at
the request function and understand that
after an AJAX comes back it calls just
the response and then I can look at
response and see what other functions it
calls and I can reason about these
things independently which makes code
much more readable and maintainable so
in many cases you've been told you use
these inline functions because you need
to do closures or things like that all
that's nonsense there's many cases where
function declarations pulled out can
actually make more readable code okay
moving on oh there's a problem with that
code you'll notice that I subtly
introduced an iffy and anonymous if he
here right up here at the top anonymous
if he's shouldn't exist either
no anonymous functions period no
exceptions so we should simply insert a
name like for instance saying I IFE
or give it some other name that
represents what that file is doing or
something like that give it a useful
name but don't use anonymous functions
okay so that's it for my talk for my
discussion on that let's jump to a very
related topic which is scope so let's
pull up the main page for scope and I
want to go quickly through this but I
just want to point out that var the var
keyword can sometimes confuse and even
abuse your function scope and there's
this thing called block scoping which is
coming new to the language we're going
to talk about why that's useful because
block scoping can actually help
I'm not saying to replace all of your
code with that but it is very useful to
do block scoping where it's possible so
let's look at a particularly ugly piece
of code I just made this code up but in
this ugly piece of code what you notice
is that we have these VAR keywords
strewn all the way throughout this code
and how many of you have ever heard that
old adage that says you should manually
hoist all your VARs to the top of your
functions anybody have just one big long
bar I've done that plenty of times
so in unfortunately that doesn't
actually end up creating a panacea in
this case we have these VARs that are
nested inside of these inline blocks and
it's confusing whether or not they're
intended to be used only for the block
or whether we're implicitly relying upon
Hawaii sting or we don't even know so
when you look at somebody's code that's
doing that that's putting VARs inside of
blocks like that you don't know if they
intended it that way or if they're just
being an idiot and that's kind of the
problem so one of the reasons why
manually hoisted into the top is that
there's no confusion so far strewn about
the
can create issues so it's very common
for people to then do manual hoisting
like we'll see here in scope to in scope
to Jas I've manually hoisted all my
variables to the top so I have no more
var stirring throughout now if you have
a short function not such a big deal but
if you have long functions as many
people tend to do then you start to run
into very similar problems where now the
code is confusing because if I'm way
down deep here and I'm like wait where
is I coming from and G and that sort of
thing was at a parameter was at a local
variable you have to scroll all the way
top to find a function with the variable
declaration and that can become
difficult and I think the linter
actually has something to say about the
lunches all the VARs at the top can also
be confusing the point is straining your
VARs across the code is confusing and
putting them all at the top is confusing
so there has to be somewhere in the
middle and it is that block scoping that
is in the middle so let's take a look at
the man page for block scoping block
scope declares variables as close to
their intended usage as possible and
scopes them only to an enclosing block
not the whole function if you have
experience from other languages you
already understand that it's the
principle least privilege or the
principle of least exposure make the
variables only used where we need them
for example for loops when you do for
VAR i equals you're declaring
stylistically that the i is only
supposed to be used for the for loop so
you're doing exactly that you're in a
sense stylistically block scoping your i
but it's not enforced yet in javascript
which is actually why it's very cool
that javascript is adding direct support
as of es6 for block scoping so if we go
into scope 3 jas you'll notice here that
I'm doing something interesting I'm
actually doing manual blocks I'm
creating explicit blocks like I do here
on line 12 I have what is called the let
statement form of this keyword the new
let keyword that's coming in in es6 and
I'm creating a manual block for that
scoping of G and I'm saying only in this
block does G exist and don't use it
outside now Java scripts actually going
to enforce that if you tried to use G
outside of that block you're actually
getting into error back which is a good
thing for us but you'd also notice that
I can use let I instead of my for
headers and I can even do let
declarations like let F equal C and so
forth so I about to let blah
form which I'm a bigger fan of and I'll
explain that more in a moment or this
sort of implicit luck declaration syntax
in either case these variables end up
belonging only to the blocks that they
exist for and nowhere else so am i
saying only do let's there are people on
the tc39 committee that are on record is
saying let is the new var just do a
global find and replace of all your VARs
and make them too let's I think that's
absolutely patently absurd and
ridiculous
I plan to use both so in this case in my
stupid example I have some VARs because
these are variables that I'm going to
use across the entire function and then
I have some lets in places where I have
localized variables that are only gonna
be used in small places and to me that's
useful to have both keywords in play
because it's a stylistic signal to me
when I see var that means used
everywhere and when I see let it means
used only in this block and I've chosen
to to apply that style to my code and
it's made my code a lot easier to
understand for me so there is this whole
thing with the let blocks that we want
to address let's just go back here and
see the the let keyword isn't valid
until es6 so that's kind of a bummer but
there are ways to get around that there
are tools but notice this third warning
that it gives us it says it's confusing
that let is implicitly hijacking a block
scope and I agree with the linter here
because I wrote the linter that it is
confusing it's an implicit mechanism I
have an if statement that becomes also a
block of scope if there's a declaration
inside of it which means you don't just
look for functions now now you have to
go start going looking for every
matching curly brace and then scanning
the entire contents of that curly brace
pair to see if there are any let's true
anywhere throughout because you can put
them wherever you want and there's
hazards with hoisting and all sorts of
things so it's an implicit mechanism and
I'm not a fan of that but the the syntax
of let blocks unfortunately we see here
the next one it's actually flat-out
wrong because that's not even valid
JavaScript which sucks es6 decided to
reject the let block syntax the one I
think that is superior and they chose to
keep that inferior implicit mechanism so
it sucks that we would prefer to do
these explicit blocks but that
particular form even though it you know
I didn't make it up it's something that
Firefox had for a long time but they've
rejected it at least for now out of
JavaScript which means that we can use
tools
so I wrote a tool called letter and this
tool is designed to solve that problem
okay and what letter does is it
transforms non-standard let blocks into
standard JavaScript block scoping so you
can use this as a pre-processing tool
just like you use other build tools and
things like that it's just another step
in the process and you can start writing
with explicit block scoping and just
simply transform your code so very
quickly what does it do if we don't look
at scope for Dante it's gonna illustrate
for us what the letter tool does by
default by default it's gonna say well
you want to transpile all the way back
to es 3 so you can use it in all today's
browsers so we can start out with a
block like this and when you use letter
it creates this ugly crap which actually
takes advantage of the fact that catch
blocks or block scope that's a
little-known fact nobody wants that kind
of stuff but those are the hacks that we
have to sometimes deal with in tools and
in fact many other tools use this there
are other hacky tricks like there are
things where you can stick if he's in
there or you can do this thing called
hygienic variable renaming there's
various other hacks this just happens to
be the one that letter uses but it means
it works it actually enforces it if we
try to reference any outside of the
block it was in fact truly incorrectly
block scoped only to the block but it
turns out that we've got a much better
way of doing it because when we don't
want that ugly thing when we're already
going to be using tools to bridge into
es6 we can even just switch on the es6
flag in this letter tool and it will
take that same block and instead of
writing that crappy ugly stuff it will
write something that is valid es6 you
notice I just have an empty naked curly
brace pair there that's very idiomatic
in other languages but it's very caught
uncommon for people to do that in
JavaScript but it's still totally useful
so we can create these explicit blocks
exactly like I'm doing here on our own
or we can use the the syntax that I was
suggesting that Firefox has had for a
while and then use a tool but I still
think this is a much better form of
block scoping create your explicit naked
blocks for this and then use the the
letter key where the let keyword at the
top of those and so you'll notice the
transformation between line 1 and 2 and
line 10 and 11 it's a very subtle
transformation they still are going to
behave exactly the same I think line 1
and 2 is slightly better and that's why
the tool might be useful to you but in
either case you should use
Blissett block scoping in my opinion
rather than implicit okay one last thing
on scoping is loops loops actually
benefit hugely from block scoping loops
and block scoping solve pesky issues
with closures and when I show you this
code you might this might look familiar
to you if you've ever written loops with
functions inside of them and had
problems like for your check boxes or
your things I'm gonna show it with time
outs here but in going back to that
previous code sample here's I've pulled
out a version or a snippet of it and
you'll notice here that I have this set
timeout that's referencing an eye in the
previous code when I was using just
regular VARs this code would break
because it's not closing over a
different eye for each iteration but it
turns out with the let keyword this let
I the eye doesn't just belong to the for
loop it's actually specified to belong
to each iteration under the coverage
JavaScript creating a whole new eye for
every single iteration which means you
automatically close over a different eye
for each iteration and closure to start
magically working with all I let crappy
if if he hacks that we've all done for
years let block with I mean let's coping
with four loops is actually a huge win
it solves a lot of those issues with
closure so I'm a big fan of block
scoping I think you should use it in
your code I think you should start using
it now okay let's move on the next thing
we're gonna talk about the this keyword
how many of you have ever had struggles
with this keyword it's one of the most
commonly misunderstood and all and I'm
showing some tweets here from people
that have done crazy things like this
stop method call this which is
absolutely insanity I love this one new
this dot constructor passing in this
what on earth of these people thinking
the plain and simple fact is that nobody
has any idea what they're doing with of
this keyword I hear it all over the
world all the time people suggest that
you know that this keyword is doing
something almost every post on Stack
Overflow it's all suggesting just it's
total crap it's totally not how it
actually works so I actually want to
talk to you very quickly about four
simple rules of how it actually does
work it's not nearly as confusing as you
think there are four rules and I'll very
quickly go through them the first rule
is if you put a new keyword in front of
a function call like I'm doing here on
line 13 you'll see that new something I
put the new keyword in front of a
function call the new keyword is going
to create a new
this binding and use that this binding
for the function call don't be confused
that the new keyword has anything at all
to do with instantiate in classes or any
of that nonsense there is no such thing
as classes in JavaScript I don't care
what you've been told or what you've
read it's all nonsense
there aren't classes and these aren't
constructors this is putting the new
keyword in front of a function to create
an object and bind it to the this
keyword so that's the first rule check
if the call site go look for the
function we wanted to understand inside
of the something function here what is
this this keyword gonna point to the
first thing is does it have a new
keyword in front of it that's your first
rule okay let's look at the next rule
I'll look up this to jeaious and in the
next rule will see very
straightforwardly that the second rule
rule number two is if you put a dot call
or dot apply at the call site then
you're manually saying I want to use obj
one as the this binding for that
function call so the first rule does it
have a new keyword in front of it if not
go to the second rule doesn't have a dot
caller apply and if so that's gonna be
the object to use very straightforward
that's just two of our four rules
already if you want to write these rules
down on a post-it note stick it on your
monitor next to the post-it note with
your passwords and you'll never be
confused again nobody gets that joke
it's always too early in the morning
it's it you'll never be confused about
this keyword ever again
okay let's look at the third rule this
three jas oops this three jas we pull
this up and it says okay here's my
function something it's still got the
same this rule three does the call site
have an implicit context object out the
call site you've probably seen that
that's probably one of the most common
ways that people invoke methods as
they're called in JavaScript functions
that exist on as references on objects
obj one dot something says if none of
the other two rules have applied which
they don't here then the third rule says
use the implicit context object at the
call site in other words use obj one as
of this binding and in fact that is
perhaps even though it's the third of
the rules aren't perhaps the most
commonly used rule in our programs
whether you realize that or not the
implicit binding rule is used all over
the place so that's three of the four
rules and that's pretty simple
and finally the
fourth and final rule to look at if none
of those other rules apply this for Jas
is the default binding rule we have a
plain old normal undecorated simple
naked function call there's nothing to
it
just a regular function call none of the
other rules apply the three rules that
you asked in that order do not apply so
the fourth and final rule says in non
strict mode that this keyword is going
to point at the window object the global
object and in strict mode it's going to
be undefined by the way you should
always be using strict mode if you're
not you're way late to the game start
using strict mode period end of story
all code should be strict so in this
case if you had strict mode turned on
you would get early errors because you'd
be trying to access a property off of
something instead of getting it
accidentally off the global object you
beginning the this off of an undefined
which would be throwing you errors so
you definitely want to avoid non strict
mode and the default rule that the whole
thing where can be the global object is
a terrible idea four simple rules does
the new keyword appear in front of it
does call a reply appear in front of it
there's an obj one appear at the call
site you know and a context object
appear at the call site and finally the
default rule strict mode undefined non
strict mode global object that's it
there's literally no other complexity
I've taken all the complexities back and
boiled it down to that simple four rules
you too can also be a master of the this
keyword one last statement that I'll
make on the this keyword and then we'll
move on to our last topic is that
JavaScript es6 is adding a new mechanism
called the arrow function and this arrow
function is totally being misrepresented
by most of the people that are talking
about it because they're saying well
it's all about not having to write the
function keyword it's actually about
being able to use this mechanism called
lexical this and I'm not sure whether
that's a good idea but I love this idea
I love this tweet from Angus Crawley's
brilliant guy and he said there's
actually a lot of beauty to the dynamic
binding of this and people never
understood it so they created a whole
new mechanism so that they didn't have
to understand it which is kind of
ridiculous how many of you have ever
done VAR self equals this in your code
anybody anytime I see somebody doing VAR
self equals this it's almost certainly a
a statement that that person doesn't
understand
this mechanism actually works because
that's mixing the two it's taking the
this mechanism which you have to go to
extra work to use and doing it the wrong
way and falling back and when you can't
figure it out then you fall back to
lexical rules which we're all more
naturally inclined to you shouldn't be
mixing that you should never do VAR self
equals this that's ridiculous coding and
the same thing is true of the arrow
function if you need lexical this
binding you're doing it wrong you don't
need the arrow function for that you
don't need VAR self equals this pick one
of the two styles for any given unit of
code for each logical you know pick one
or the other when you mix the two you
get frankenstein code and it's just
ridiculous so our last final topic that
we'll jump into is object oriented
everybody loves object oriented I love
this t-shirt I wish I'd gotten a chance
to buy it while it was still available
because in fact as I said earlier Java
Script is classless there is no such
thing as classes in JavaScript you've
been taught that there is you've seen
people create libraries to try to fake
it I'm gonna very quickly derive for you
why I think that's total nonsense there
isn't any such thing as classes and even
when they are adding a close even though
they're adding a class keyword you're
still not gonna be classes in JavaScript
so the first thing is that all this
confusing terminology class and
inheritance and instructor and instance
and all that that's all junk that comes
to us from other object-oriented
languages class oriented languages none
of that stuff exists in JavaScript it's
nonsensical it's misdirection we've
wanted to do that because we didn't ever
think about looking at the way the
mechanism really works
my favorite worst part of this is when
people put the word prototypal in front
of the word inheritance which is
ridiculous javascript does have a
mechanism called prototype but it's
absolutely nothing to do with classes so
let's look at this whole idea lint man
prototype well let's look at this old
idea of putting the word prototype in
front of inheritance I don't have a lot
of time to get into this but the word
inheritance implies copy mechanisms both
genetically speaking you copy your DNA
metaphorically the blueprint in the
house that's being built on all those
ways inheritance is about copying of
behaviors and JavaScript by default
doesn't do any copying so it's not
appropriate to use the word inheritance
to describe JavaScript's mechanism but
people like to put the word prototypal
in front of it and say no no this is our
special form of it
of inheritance in JavaScript we just
call it prototypal inheritance as if
that's somehow supposed to make it not
confusing which actually just makes it
worse
I like inputting prototypal in front of
the inheritance and pretending that it
reverses to like me holding an apple in
one hand and an orange in the other and
then suggesting to you no no that's not
an apple it's just a red orange it's
absolutely ludicrous you'd look at me
like I was crazy it doesn't matter what
word I put in front of it it doesn't
change the intrinsic nature that that
thing is an apple so you can't put
prototypal in front of it and then get
to pretend that that doesn't mislead
people into thinking something that's
not actually true so what's really wrong
is it's a it's a we've been from the
very beginning we've been using the
wrong terms for these things so I want
to set up a comparison between the more
common term that everybody knows Oh Oh
object-oriented really object-oriented
means class oriented oo versus another
term that I've come up with called Oulu
objects linked to other objects in fact
this is really a comparison between
class oriented and between what I think
JavaScript should have been called all
along which is behavior delegation okay
and I want to show you a couple of
pieces of code to illustrate this
difference or what I call Oulu style
coding so we start out with the
traditional way that people do things
that they call classes in JavaScript
diagrammatically classes in traditional
class oriented languages start with
these copies the arrows go from left to
right and from top to bottom because the
properties are copied into instances and
a child end into child classes so we see
in JavaScript that when people try to do
that it doesn't work that although the
same way which is why everybody uses
these crazy frameworks on top of it so
let's look at class J s this is how
people do or how it suggests it sort of
natively to do class oriented coding in
JavaScript all this nonsense with
function constructors and dot prototype
and the new keyword and all this other
junk this is just crazy confusing code
there's an untold amount of gotchas that
are here which is why nobody actually
writes code like this because it's so
difficult to do class oriented coding in
JavaScript we're swimming so far against
the stream everybody's just these crazy
big complex libraries to do class or
into coding for them which is I think
ridiculous if you can't use a mechanism
the way it was designed to be used then
you're doing it wrong
you don't need another library you just
need to figure out how to use the
mechanism better so this whole prototype
thing in this new keywording thing this
is all nonsense I don't think we should
be doing it and you'll notice here the
linter just has all kinds of warnings
I'm not even gonna belabor the point
there's all kinds of warnings about
being careful about these things and
just arbitrary dot prototype references
that are writable and that can create
confusion here's the real problem
there's too much complexity to the
mental model to be able to actually
juggle all those problems here's one
diagram that I'll give you let me give
you a simple version of it here's one
diagram it's a little hard to read here
but these squares are objects and the
circles are functions and you notice
these relationships these are the
prototype linkages this is the diagram
that exists from that previous code and
actually this is the real diagram with
all the extra stuff involved and there's
two takeaways both an optimistic and a
pessimistic takeaway optimistically the
takeaway here is that there's a lot of
internal consistency in JavaScript but
pessimistically this stuff is just too
damn difficult nobody can keep this
stuff in their head I've been doing it a
long time and I can't keep it in my head
so we just that's the problem is that
it's just not possible but if we embrace
instead how JavaScript actually works if
we look at it is delegation using that
terminology you notice the arrows now go
from right to left and bottom to top
because in this particular scenario now
the relationship is how it actually
works in JavaScript these are live
linkages on the prototype chain rather
than copies of properties down the chain
and that's what javascript actually does
so I'm gonna give you very quickly to
finish things up I'm going to give you
what I call Oulu style coding does
exactly the same thing as the previous
confusing snippet of code but now it
uses and embraces this idea oops didn't
open up my file it embraces and this
idea of Oulu so you notice I still have
capital F foo and capital B bar but
they're not functions anymore they're
just objects and now I'm putting
properties directly on the objects
you'll notice this code snippet is
completely devoid of any dot prototype
references or constructors there's no
neat new keyword there's none of that
confusing crap
the only thing that actually the magic
that makes it happen is this object
create utility which is added natively
in language it's a very simple polyfill
for an object create just simply creates
objects and links them and doesn't go
through all the fanfare of trying to
pretend to be class oriented to do
I've got a lot of writing about this
it's too quick for you to understand all
of the code but it's actually very
straightforward in the second of these
books this this this and object
prototypes it goes through all of this
topic and explains exactly how only
works and why it creates simpler code
and in fact not only simpler code but
here's the big payoff it creates simpler
mental models as well
here's the new model it's just objects
linked to other objects we don't need
any of that other confusing crap so I
apologize if I've offended anyone
because there are a whole bunch of
opinions here and you know opinions are
just to be taken these are just opinions
and you can ignore the linter if you
want so hopefully there's no heart
feelings
we are on a break here so I will not
take questions in our session but if you
want to come up and ask questions of me
you know during our break that's great
but I just want to remind you that you
can reach out and give feedback on
Twitter also please definitely make sure
to vote on the app so that we get good
feedback and reach out to me in all the
various ways and tell me if I'm wrong or
something don't forget first three
people that want to grab a copy of the
books free and there's free stickers and
have a great rest of the conference day
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>