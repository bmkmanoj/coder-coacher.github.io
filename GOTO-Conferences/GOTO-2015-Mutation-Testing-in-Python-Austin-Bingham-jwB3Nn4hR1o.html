<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Mutation Testing in Python • Austin Bingham | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Mutation Testing in Python • Austin Bingham - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Mutation Testing in Python • Austin Bingham</b></h2><h5 class="post__date">2015-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jwB3Nn4hR1o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so it's late in the afternoon so energy
is kind of low you've all just had some
to eat so hello say hello back come on
fill the room hello okay great great um
as you probably know by now we'll be
talking about mutation testing and it's
a mutation testing in Python because
I'll be talking about an implementation
in Python but most of this talk is more
broadly applicable it doesn't have
anything to do necessarily with Python I
just happen to write a lot of Python
code and that's what I wrote here who
has done mutation testing or even knows
what it is just raise your hand it's not
everybody good how many of you have
experience with something like p i-- t
the java testing the python testing tool
nobody interesting okay because that's
that's the gold standard that mine is
very research he compared to theirs i
work for in part own sixty north a small
software consulting company in in norway
we're based all in oslo and in Stavanger
where I'm from on the west coast
represent right so there's an app you
probably all know about it by now the
only thing you need to know about it is
the green smiley face you can ignore the
rest of it including the questions but
we'll take the questions at the end I'm
gonna try to save time for those a
little bit about myself this is my world
that orange dot in Texas is Austin Texas
where I'm from originally about seven
well Austin's a great city right the
University of Texas then the u.s. is
largest university and the u.s. is
top-ranked public university is where I
went to graduate school it's a wonderful
place go horns Austin's a beautiful city
and it's got a real personality to it
it's the best part of Texas if you ever
go to Texas go to Austin this is a
statue of Stevie Ray Vaughan a famous
guitar player from Austin who died
tragically and this is a statue the city
built this is kind of represents how
they feel about themselves they're
really big into live music rock and roll
blues that kind of stuff it's a really
pretty city if you get a chance go to
visit it about seven years ago I moved
to a place that's very different this is
Steve Unger this is Lucifer ode from the
pulpit rock if you've ever been in
Stavanger you've probably been to
exactly that view it's the prettiest
place in Norway no arguments we have
different kinds of statues there these
are 20 metre tall stone swords ran in
the earth to represent the unification
of the kingdoms of Norway hundreds of
years ago
about 20 minutes from my house all this
stuff it's a beautiful place to visit if
you've never been Devon was great and
that's where I found it 60 North a few
years ago so enough about me let's move
on mutation testing I first heard about
mutation testing maybe two years ago
from a guy named sev Rose who if you
ever if you go to conferences you may
have heard of him he's a really great
speaker if you get a chance see him talk
on any topic and ask him what he's
passionate about that'll wind him up
he's a good guy and it was something
that resonated with me mutation testing
which I'll describe in great detail
resonated with the way I think about
programming and the kind of this the way
my brain works and I got very interested
in it and set about to write some
mutation testing stuff in Python which
is the language that I use given given
the choice it's a really neat technique
it's kind of research II not entirely
practical but I think you'll all find
that the ideas and it are really good
and something that we should strive to
have good tools for so most of what I'm
hoping to do in this talk is to get
across what mutation testing is what are
the challenges and how and to get you
interested in it enough that you might
start thinking about it as well and
contributing your own tools contributing
to these tools to the other tools and
making it a better ecosystem because
that's kind of where we are in the world
with mutation testing I think so what is
mutation testing you start off with two
premises you have your code under test
your your application or your library
whatever it's code that is presumed to
work and you have a test suite that you
presume fully tests the functionality of
that body of code you then introduce a
single controlled change and we'll
discuss these in a fair amount of detail
but a single small change to the code
only one at a time because this is
science right one at a time you want to
deke inflate your changes you then run
your test suite and if your test suite
is perfect it will it won't detect it
will fail it will say nah something's
broken you've made a change in your test
suite will detect it this is the ideal
the mutation testing kind of works on
this base is the assumption that your
test suite catches all defects well it
actually helps you make a better test
suite in the process but when you get
these tests fail when you don't get test
failures this is when you know you have
a problem you've made a change to your
code but your test suite hasn't figured
it out so this has ramifications for
either your test suite or your code
we'll talk about that in a bit of detail
but this is the fundamental idea small
change run the test suite see if it
fails and if it doesn't then examine
your code or your tests the basic
algorithm is really simple at least the
basic algorithm as I've implemented you
have some set of operators operators are
the things that make the small changes
to your code you have a number of sites
in your code where this operators can be
applied and then so you have this this
this two space that you work through
operators and sites the operators work
on and you might mutate the code and you
run your tests that's the basic idea
and you probably immediately saying that
okay this is gonna result in a lot of
stuff happening and you're right this
does result in a lot of stuff happening
it takes a long time to do a full
mutation testing suite on anything of
appreciable size but this is the basic
idea very very simple so what happens
when we when we run this test suite what
are what are the possible outcomes there
are three classes of outcomes when I run
my test suite one is what we call killed
this is this is from the research
literature really it's oh you've killed
the mutant your test suite has failed
and it's failed because it has detected
the change that you made in some way
shape or form so your test suite is
performing its job and this is good it's
properly detected the mutant we're gonna
start using words like mutant and killed
and survived and stuff and it sounds
very brutal and it is it's kind of like
a comic book which is kind of why it's
fun another class of results are what we
call incompetent you get a mutant that's
incompetent and this these are typically
cases where the modification causes your
program or your test suite to just seg
fault or to throw an exception or do
something where just can't continue so
your test suite doesn't actually finish
and give you results it just dies in
some horrible way that's normally what
incompetent mutants are like there's a
much worse class of incompetent mutants
oh and those are the ones that go into
infinite loops and we'll discuss those
in a little bit and they're they're
difficult technically impossible to deal
with finally you have the things that
survived the the mutants that aren't
detected by your test suite this is what
you don't want to happen this is what
you're trying to avoid you're trying to
reduce the number of survivors you have
in any run and there are any survivor
you get means one of two things and this
requires your analysis to determine
which of these two things it is but it
finds a spotlight on your code either
your tests are inadequate and this is
very typical none of us really in real
life have perfect test Suites so
mutation testing helps us identify the
weakness
in our test Suites and and tighten them
up another real possibility though and
especially on legacy systems their
systems that are under heavy development
is that you've got you've mutated some
code that doesn't have any tests and it
doesn't have any tests since nobody
cares about that code it's not doing
anything it doesn't represent a feature
or support any feature in your code and
so the spotlight that mutation testing
shines in your code says either you need
more or better tests or you need to zap
that code if you care about getting rid
of extraneous code because code I mean
as I think we all agree now is it's a
liability it's not an asset you don't
want more code around that just gets in
the way of things so you want to remove
code if indeed it doesn't support any
important features so the goal of course
is to kill all the mutants you want a
hundred percent death rate zero percent
survival rate and so I hope by using a
meme I engage all the the people in the
audience right the famous meme kill all
the something's the mutants what are the
goals then of mutation to see why would
you go through the trouble of doing this
the goal number one is is coverage
analysis a lot of people already do some
kind of coverage analysis where they run
their test suite and they get a little
check box by each line of code that says
this line was executed this line was
executed and that's great that is a kind
of coverage but that's that's purely
telling you what's the line execute it
doesn't tell you anything about whether
your tests meaningfully checked the
functionality or the the logic of that
line of code so what mutation testing
lets you do is to verify the
functionality verify the logic the
meaning of that line of code it tells
you if I've made an arbitrary
effectively arbitrary change in this
line of code does my test suite detect
and that's really important I love this
graphic because it somehow communicates
this sort of kind of blind stupid
optimism of yeah you know we covered all
our lines of code our test Suites
perfect when in fact generally they're
not there's a lot of test Suites just
waste time because they do okay execute
a line of code but don't tell you
anything about the quality of your
software that's goal number one and
that's that's probably the most common
goal that's that's what people will
think of most often when they think
about mutation testing the other one of
course is detecting unnecessary code
what I mentioned earlier getting rid of
the code that you no longer need so this
this picture a lot of you probably
recognize it is is a picture of part of
the gastrointestinal system and the
important bit it's down here at the end
the vermiform process the worm-shaped
process or the appendix
right we've all gotten well most of us
at least have an appendix statistically
most of us have an appendix and when I
was growing up I was taught you know
that the appendix is is vestigial part
of the body we don't need it for
anything and in fact if you go have a
dependence and ectomy and have it
removed you'll survive you'll be just
fine and so in some sense this is kind
of what mutation testing is doing is
finding the things that we no longer
need so we can get rid of them
interestingly it's kind of the the twist
moral to the story is you know in the
past few years we're starting to find
you know doctors are saying well
actually something is kind of going on
in the appendix it's not terribly
important anymore but it actually does
do something so I guess the moral here
is that when mutation testing shines a
light on your code you have to really
think hard about is it a problem in the
test suite or is it a is it a bit of
code that I no longer need it's not
always that cut-and-dry and this is
where your your reasoning your skills as
a developer come into play so don't
necessarily always cut out the appendix
think about whether or not you actually
need the appendix and I like the graphic
is kind of a cool picture I think it's
um Grey's Anatomy so it's kind of famous
Grey's Anatomy the book not the TV show
which I've never watched so what are
some examples of mutations I've talked
about this notion of operators right is
anybody know what this moth is why I
might have it up there it's it's called
the pepper moss
it may have a different name in other
languages but in during the industrial
revolution or pre industrial revolution
in the UK these moths were largely white
and they could sit on limestone
buildings and be largely camouflaged the
Industrial Revolution comes along burn a
lot of coal everything is covered in
coal dust and turns black and these mods
and you Teta to be black almost in
within the span of a few generations
because the white ones got eaten right
so that it's up there because they
evolved in we kind of studied this and
it was proof of evolution so forth so
forth a cute picture one typical example
of an operator is replace relational
operator in this case we're replacing
greater-than with less than so we're
literally going through the code looking
for greater than symbols and swapping
them out and you would hope that your
test we can catch something like this
this is a pretty egregious change right
you'd be surprised but this is an this
is a typical example of the kind of
thing that a mutation operator would do
not rocket science really were these
simple things and remember you're doing
these one at a time and then running
your full test suite so you can imagine
how this inflates into a huge amount of
runtime necessary to do a full mutation
testing run another great example is
break continued replacement where you
have a break somewhere in the code I
assume everybody knows what break and
continue are and their language of
choice and replace it with the continue
and this is a great way to introduce of
course infinite loops right a break is
supposed to kick you out of a loop and
it continues says oh just keep on going
so this is a great way to create a sort
of mutants that is incompetent because
the test suite never ends but you can't
really detect that and we need to talk
about ways to ameliorate that problem
this is the list of operators that I
plan to implement for the Python for the
Python implementation and I mean I'm not
going to go over all of these you have
some sense of what they are but you see
things about like exception swallowing
so adding some code that just grabs an
exception and doesn't let any of the
handlers work things like I think
there's yes super calling deletion where
you you remove calls to base class
implementations of functions things like
that and okay if you're programming
advanced lis different languages from
Python you'll say these don't apply to
me and you're right a kind of a research
area of your mutation testing is
deciding what are the reasonable
operators for a given language what
applies in Lisp is not going to apply
and C is not going to a plan Haskell etc
etc etc so these these are necessarily
Python specific but some of these would
apply to job on you know things about
exceptions in classes and so forth but
these give you a sense of what kind of
operators you would face in a full-blown
mutation testing suite and you could
invent your own and we'll look at
actually the implementation I've got
uses a plug-in system for operators so
if you have special ones maybe for a
specific API you're developing you could
consider adding those into the system as
well if that makes sense for your um for
your use case so what are the
complexities of mutation testing it's
you know it's conceptually quite simple
in many ways make a change on your test
suite record the results but it is doing
this blindly and naively results in some
pretty severe difficulties does anybody
know what that is
that's the Queen land pitch experiment
and that's a filter full of pitch
draining down into a jar and the drop
happens every once and once over about
two years and I don't really know what
the goal of the X
Behrman tis but it's been running for a
long long time I think the goal of the
experiment is for the guy who's running
it to actually see it happen he I think
he's never seen it so you know he always
goes for a coffee break and comes back
and it's dropped poor guy but it
represents things that take a long a
long time pitch falling out of a funnel
takes a long time what do we do to
account for this you obviously can't be
running this every day if it takes more
than a day to run one thing is that you
can paralyze it as much as possible it's
an embarrassingly parallel say that ten
times embarrassingly the parallel
problem you can if you have a thousand
cores you can run a thousand tests at
the same time you might kill your disc
at that point but conceptually you can
span it out that much and and that's
that's all the tools that I know about
do this to some degree mine just counts
how many cores each system has and runs
that many at a time another thing you
can do is run it run a full baseline you
have to start with a full baseline where
you run the full test suite mutation
testing suite and get some stats from
that you know five percent survival rate
or whatever that is after that you can
do things like only run the tests that
you think touch modified code and that
drastically reduces the the test space
you have to run a little bit more easy
is to only mutate code that you know has
been modified or added the reason the
reason that's a bit easier the second
one is a bit easier than the first is
this first one that could be a bit
difficult to get I know in Python the
tools for determining that are somewhat
iffy the ones I've tried at least this
on the other hand is really
straightforward you just look at your
git diff and say okay at this line this
line this line only mutate those lines
and that will again drastically reduce
the space you have to search through in
your mutation neither one of these is
exactly perfect though because you can
imagine that any change you make
actually changes it's safe in this case
only running tests on modified code well
if I've modified my code and I think I
know the path through the code that a
test is going to go I might have
modified that path which means that now
there's other code that I'm not testing
that I should be testing and it's it's
iffy to go down either one of these
routes and this has the same same
problems but you can use these at least
as heuristics to really drastically
reduce the amount of time you need to do
subsequent runs after a baseline finally
you can speed up your test Suites if
you've ever seen like Dan North or any
of
BDD TDD star DD guys they'll tell you
you need fast test Suites anyways and
this is another reason so that you're
you can do mutation testing in some
reasonable way if your test Suites take
two days you might have other problems
so speeding up test Suites is generally
speaking a good thing although it's not
always possible I admit the second
complexity is a competence detection you
know I mentioned that most incompetent
mutants these are the ones that just
kind of seg fault or just crash
arbitrarily they don't they don't
actually complete the test suite and
those are really easy to detect ofcourse
you just say oh died incompetent crate
but then there's the class of those that
potentially run forever right so who's
that that's Alan Turing right and he
said yeah it's not really Alan Turing
that's really Alan Turing and
apocryphally he said yeah good luck with
that good luck with detecting whether or
not the program you're running is ever
going to end I mean he famously proved
the the halting problem is undecidable
you can't know ahead of time of program
it's going to end so you can't in
principle take a mutant and say oh yeah
well he's gonna run forever so I'm just
gonna kill him off you have to have some
heuristics some other kind of analysis
it says oh he's run too long and kill it
now so the typical thing to do is you
run some baseline of the test suite just
over a healthy mutant of the healthy
unmutated code and say that takes 10
seconds and you say any mutant for which
the test suite takes more than 30
seconds we'll just call that an infinite
loop and we'll kill and call it
incompetence so that's that's the kind
of strategy you have to apply this is
again kind of part of the research
element of mutation testing kind of what
makes it interesting at some level and a
little bit impractical and the third
complexity is what we call the
equivalent mutants and on ok there's
some code and and most of it you don't
have to really croc but this an
equivalent mutant is a mutant that is
practically undetectable
when I say practically undetectable it
means that you could potentially write a
test to detect mutants of certain
classes but doing so would be ridiculous
and I'll and when I go through this
example you'll understand maybe a bit
better why this this comes out of the
Python documentation actually and then
the function consume just takes in some
sequence of things and iterates through
it effectively for the side effects
that's what consume is all about don't
worry about most what this does this is
the important bit here
it constructs a double-ended queue and
passes that iterable thing into it and
that effectively iterates through the
thing as fast as possible because
double-ended queue is written in c not
in python and the interesting bit here
is at the end max Lane 0 so we're saying
the double-ended queue can never be
larger than 0 so you're really not doing
anything except forcing iteration now
what's going to happen when you do
mutation testing is mutation the
mutation testing out where that will
eventually get to the zero and it'll
have an operator called constant
replacement which looks for constants
and replaces them with a different
constant now replace this with a one or
a thousand or negative six or something
like that if it replaces it with one
which is what cosmic-ray does right now
my mutation testing tool everything
still works just fine and the only way
to detect that that's been changed to a
one is if you can dig into your memory
allocator not just your OS but pythons
memory allocator and determined that an
extra int or object has been allocated
somewhere and nobody has tests to do
that it's it's a it's such a ridiculous
test to write that you would never do it
and that's why it's practically
undetectable no but you wouldn't waste
time to do it so that's that's the kind
of thing that that's that's an
equivalent you and that's a good example
of an equivalent mutant and I like this
example because this is idiotic Python
this is what you're told to do by the
official little official documentation
if if you want to consume some iterable
so three complexities with mutation
testing so that is sort of the the quick
overview of mutation testing in general
and then what we just talked about there
applies essentially to every instance of
mutation testing tool for every language
in the world that's the theory of
mutation testing okay we're doing pretty
good here the rest of this talk is about
cosmic-ray a mutation testing tool for
python again this tool is not you know
it's not industrial-strength it's not
really ready for anything other than
other people kind of hacking around on
it other hobbyists perhaps but again I
want to get these ideas out there
because I think they're really the kind
of need and I'm hoping that some of you
get grabbed by the ideas as much as I
was grabbed by them when I saw Seb talk
so and again we're start looking at some
Python code here but it really doesn't
matter that much any pythons easy to
read but you can hopefully kind of
translate what you see here to your
language
the very first thing that cosmic quarry
has to do again don't worry about
rocking all of that code is figure out
what it is it's going to be mutating and
what we what we do is we ask the user
please give us the name of the package
you want to work again so that's kind of
the granularity and this fine modulus
function does does all that work that
the the neat things in here are where
the red arrows are so let me back up a
second one of the things that really
grabbed me about the whole development
process of cosmic rain was how pythons
seemed to have all the bits and pieces I
need there's a lot of things that could
be really really difficult in mutation
testing finding the code to be tested
modifying the code maybe having to
recompile the code running test Suites
dynamically spawning things out multiple
processes and so forth and Python kind
of made that relatively straightforward
pleasingly so and a lot of that comes
down to the kind of the architecture of
how the languages put together if you um
take a little diversion into software
architecture if you're actually physical
architecture there's that there's a guy
named Vitruvius from ancient rome and he
wrote the you know the thing on
architecture back in the day and he said
there were three things about
architecture that were important thee
the the durability of it effectively the
commodity of it whether it did what it
was supposed to do and whether or not it
was delightful and yeah i forget the
latin of it but the delightful part is
what got me here i was continually
delighted as i wrote this code to find
that the hard parts had at least been
thought about by the designers of the
language and i hope that if you do this
kind of work in your own language you
find the same thing because otherwise i
would have given up if these hard parts
hadn't been written for me i would have
said it's not worth the effort because
i'm lazy and don't have infinite time so
one thing that was really neat is this
this api access to the the import system
so there's a keyword called import and
you give it a name and it imports the
package and binds names and stuff for
you all of that is programmatically
accessible through this thing called
import lab which is part of the standard
library so i can pass it the module name
and it imports the module for me great
that's one really difficult thing out of
the way now i can scan this module
object for sub modules which is really
all this function is doing so now I've
got the module and I look up its path on
the file system and use package utility
iterate its sub modules so I don't want
spend too much time on this except to
say this this was a piece of code that I
was worried about writing and I found
that it was actually pleasantly simple
and I learned quite a bit about how
- does imports under the hood which is
good because I do a lot of Python
training it helps if I know this kind of
stuff right the kind of next moving part
is how do you run tests this is one of
the primary things of course that
cosmic-ray has to do now there are about
a thousand different unit tests or test
automation systems and packages and
frameworks for python so I couldn't
obviously implement support for all of
them so I implemented a a plug-in system
that lets lets you provide an
implementation for your your flavor of
unit testing I I have to - that I
provide in-house unit tests which is the
or in-house but as part of cosmic-ray
one is unit test itself the standard
libraries unit testing system and PI
tests which is probably the most popular
one out there but because of the plug-in
system I'm using you can provide
whichever one you want if you have an
in-house testing system you can pretty
trivial a provide support for it if you
were using Python and you want a good
plug-in system I want to give a little
shout out to stevedore part of the
OpenStack system it's wonderful it's a
great plugin system and it made this job
very very easy the only thing you really
have to do to implement a new one is
implement a subclass of what's called
test Runner and in that class implement
a underscore run function and it's job
is to just run all the tests it finds
under a directory it's really that
simple it's probably simplistic I'll
probably run into eventually some unit
testing system for which this is
insufficient in which case we'll just
modify the plug-in API a little bit but
again the details are not all that
important but it is an important element
of any mutation system finding the tests
that are going to be run it's something
you have to tackle this is where it gets
really fun and cool right this is when
we get into computer science you stuff
now a STS abstract syntax tree sounds
very scientific and it kind of is this
is very technical this is this is when
you think about mutation testing the
kind of the meat of the problem the fun
stuff manipulating code manipulating
your executable environment and so forth
Python provides a thing called a module
called ast abstract syntax tree it's
part of the standard library and it can
do two fundamentally very important
things for cosmic-ray
one is it can take source code just a
string with source code in it and turn
it into an ast give you a tree structure
you can then traverse in various ways
and it provides a set of essentially
visitor pattern implementations these
little visitors called no transformers
that can be made to traverse the tree
and be given a chance to replace notes
as they go and these two bits here are
essentially how we implement the
mutation phase of of cosmic-ray we find
the source code file slurp up read the
greed the code out a bit pass it into
the ast generator get the ast and then
traverse it and let the operators
operate on the nodes as we go and we'll
look at that in a bit of detail but this
is distance in some sense the the core
the the neat guts of any mutation
testing suite so that leads us directly
to what is an operator what do we mean
when we say operator operators are
essentially the things responsible for
manipulating to ast they use the ast
module to replace nodes you know change
the plus to a minus you can see in this
case this all an operator does give him
this little bit of the tree and if his
job is to replace + with - that's what
he does he spits that out and shoves it
in the tree and then somebody runs the
code it's really simple to create a new
operator if you want to you just
subclass from operator which in turn
sunglasses from the node transformer we
mentioned earlier and you can provide
these also as plugins also using
stevedore which again wonderful library
they have two primary jobs one is to
identify the places in the tree that
they're allowed that they know how to
mutate so this guy would report when he
sees a plus node you say oh yeah I know
how to modify that report it back to
cosmic ray and cosmic where he would say
ok well I want you to then go ahead and
modify that that's how operators work
fundamentally they're very very simple
no no single operator is really all that
complex because they only ever make very
very small control changes typically
that is to replace a node or delete an
entire subtree out of the ast this is a
full example of a typical operator
really the whole point here is just to
see that it's actually very very small
its subclasses from operator which is
something part of cosmic right this
visitt unary office part of the know
transformer API and it's given a node
and we check to see ok is this node an
instance of unary subtraction if so we
want to signal that this is a site we
know how to mutate and if the machinery
wants us to actually do the mutation we
get this gets called and the node is
replaced
essentially replaced in place with a
unary addition and spit back this is the
flavor of almost all the operators and
all the ones I've thought about as well
I haven't implemented all the operators
I mentioned earlier very very simple
very straightforward and the kind of
thing you could piecemeal add to your
system as you go now before we get into
some of the the next bits of cosmic-ray
I want to give a quick overview of how
pythons module loading system works
because without knowing that the rest of
it doesn't make any sense so this is
getting into a bit of Python specifics
but it is a nice sophisticated pretty
elegant system I found as I was
researching into this stuff there's
three main parts the first one is these
things called the finders and a Finder
is just an object that when given a name
responds with yes or no I know how to
load up a module of that name so you can
have finders no think know how to load
modules out of zip files off of networks
stores HTTP off the hard disk or
wherever there's all sorts of methods
for importing modules in Python and you
have different finders for each of those
methods when a Finder does know how to
load something I mean it says yeah that
that's name that name is something I
recognized it's supposed to spit back a
loader
now loader is the next bit it's
responsible for taking with what amounts
to an empty module object just kind of
an empty shell and filling up its
namespace with name bindings name to
class name to function name to whatever
so the finder says yeah I know how to do
something but that that import the
loader does the actual work of filling
up the namespace the last bit is this
thing called sis meta path and sis meta
path is just a list literally a list of
finders and when somebody in python says
import foo python goes okay first finder
do you know i hit import foo no okay
next finder do you know how to import
foo goes down the list until somebody
says yes and if nobody says yes then you
get an exception you can't import that
so all these put together basically give
you complete control over how the import
keyword maps the names it gets to the
things it actually does and this is what
we need complete control over to make
the tests work to make mutation testing
work because the tests the test Suites
themselves we never modify the tests we
need to be able to say import foo and
get mutated foo when we want mutated
food to be in place and so we need to
have fine-grained control over this and
fire chain and so that's that's what
cosmic-ray does the first thing we
implement is a finder of course and the
finder does nothing more than associate
a name a module name with an ast a
mutated ast so we as part of the
algorithm take the pristine ast mutated
in some way create a finder that binds
the mute module name that ast and stick
it up in system meta path so that when
somebody says when a test says import
that module it gets the mutated version
this is this struck me as really kind of
neat and elegant and kind of a present
with a little you know bow tied on top
you just felt really nice when this
witness all started working the code is
incredibly simple this is all of it
right here - documentation of course
which I have copious amounts of because
I'm a good programmer
the only thing that you really need to
understand is that so fine spec is what
Python calls when it's asking for
whether this finder can load the module
and we just say you know is the name
that they want equal to the name that
I've been given if so pass back the ast
right here in the context of a loader no
big deal this is really really simple
and the fact that it was so simple it
gets you the sense that the designers of
this system really thought ahead they
probably didn't think about mutation
testing itself but they they they didn't
think too narrowly they really thought
broadly about giving programmers at
runtime full control over they've guts
the machinery of the language itself and
this is what we're getting into really
the guts of how Python works at toda
this is the bottom basement of how
Python works except for some bunch of C
code which come on the next bit is
loaders so the finder when it recognizes
a name spits back a loader and this
loader all it does is take the ast
object compile it into a code object and
then execute that code object in the
name space of the module okay that's a
bunch of verbage basically it just fills
up a module thing for you using the
mutated ast Oh
again super super dirt simple this is
the entire implementation - ik and
comments of the of the ast loader and
you can see this is kind of the magic of
the magic down here we had the ast some
mutated ast we compile it this produces
a code object we execute that code
object in the namespace of the module
that's passed in to us
that gets bound to the module name in
the caller's context and this is how the
tests get access to mutated ast s and
this yeah again this is kind of warm
fuzzy feelings I get when I when I think
about this code and how kind of pleasant
it was to write it what a neat project
it was to get to work on because I
didn't have to do a whole lot of work
and I got a neat tool out of it
there's some other bits and pieces that
are not too pythons specific there's
things you'll need to think about if you
end up you know thinking about mutation
testing on your own one is sandboxing
potentially a mutant can do all sorts of
wacky things like the mutant could start
doing things like manipulating system
meta paths or deleting files or sending
pings to an orbiting space station or
you don't you know you don't know what
it's going to do right because you've
mutated it's probably not going to ping
a space station but I mean we got rocket
scientists here so who knows basically
though you want to avoid what I call
cross mutant interference the potential
that they can influence how each other
works and therefore pollute and corrupt
the the output from your your testing so
there's this library called
multi-processing which has a kind of a
threads like API that lets me actually
spawn out processes in a very simple way
and that's how I do sandboxing each time
I do a run for each mutant and each test
suite pair that I have I create a
separate process to run that and that
way I can guarantee that nobody is
stomping on anybody else's name space
nobody else's module space or anything
like that it's a bit heavy-handed in a
bit of a hack but it works or seems to
work really really well and I'm
comfortable that it's doing the right
thing at least until somebody tells me
otherwise pick up this is very pythons
specific except well pick ax is an actor
an actor model implementation in Python
is anybody here I mean if you're a
scholar programmer I guess you probably
who knows actor model at all you should
all know actor model I mean this is this
is one of the most important things in
my opinion that that we should all be
thinking about it's it's a great
paradigm for developing programs
especially programs they could take
advantage of massive you know
parallelism and all the cores we've got
available nowadays actors are they're
simple to think about they're robust
they scale out really well they scale up
really well they're proven
mathematically you could read some
fascinating books on on actor model
theory
there's one called the black book by a
guy named Google a guy from MIT press
and he you know he explains actor/model
theory in terms of general relativity
and things like that it's just really
fascinating to read it and you come away
thinking yes this is the answer it
really is but yeah for me actor/model
stuff it's really simplifies design it
simplifies the cognitive space that I
have to work in as a programmer because
I don't have to think about things like
locks and threads and as so many race
conditions and all these things that if
you're doing thread programming you have
to worry about it all just disappears
because it vastly simplifies the model
you're allowed to work with without
really binding your hands too tight so I
really see just looking into it the
benefits I see from it how much time do
I have I okay ten that's good is that
these mutant testers each of these this
this these are my actors that are
actually running the test so each of
these is responsible for launching a
process that then runs the tests and I
just make as many these actors as I need
and they each feed from this thing
called the process queue were they the
queue manager actor and they just pull
the next bit of work to be done off of
that queue and they do it and there's no
way they could interfere with one
another all they can do is talk these
little messages and I could scaled up I
could scale that out just by creating
more mutant testers if I have 16 cores I
creates 16 mutant testers on this I only
make four or five or whatever the number
is I really I've seen this pattern over
and over again that the that you start
with some program that has some inherent
concurrency in it and you try to code it
up with threads or some other paradigm
and then you step back and go this is a
real mess this really ought to be simple
because conceptually it's very simple
and then you apply the actor model to it
and your code becomes simple it becomes
something you can reason about something
you can test much more easily because
testing actors is trivial you just
instantiate the actor and throw messages
at it and see what messages come out
that's the only thing actors can do so
they become really easy to test and
they're really robust and go on and on
but I'm running out of time so look into
the actor model whatever language you're
using whatever stuff you do it's really
really important I think and it's fun it
really is fun
finally I use a feature in Python called
async IO a relatively new feature it's
just an event loop that's designed to
support high performance concurrent IO
and I just had this event loop sit in a
loop checking the testers he says are
you all dead are you all dead are you
all dead and once they're all dead the
program is done so this is really a
Python implementation detail of how do
we determine when all the actors are
done but if you're using Python you
should be learning about async i/o
because it is it's the future for many
many things for event-driven programming
reactive programming that kind of stuff
in Python right so how does this all
sort of fit together the first thing
that cosmic-ray does is figure out which
test Runner it's going to use unit test
PI test whatever it's a command-line
option that the user passes in and then
figures out the modules that's going to
mutate it scans the the package
directory it figures out all the
operators it's going to use because of
course the operators could be provided
by external plugins it then lazily
generates a sequence of mutated ast s
and the Lazy is important because if you
try to generate the full sequence it
would be really really big and there's
no reason to have it all in memory at
the same time anyway they just they just
get generated as the mutant tests or
actors decide they need another one they
go hey give me another one give me
another one give me another one and the
queue manager is responsible for
essentially cranking those out as
they're needed and then for each
commuting we run the tests each test
runs in a new process and each nip you
lates its local system etta paths in its
own process and this is really important
to make sure that I mean this this is
the sandboxing here this that that each
process has its own system out of path
and that's critical if they all shared a
system at a path there would just be
complete chaos and figuring out how to
do this correctly was yeah it was
complete chaos for a while I was losing
my mind excuse me alright that's about
it I there I could do a quick demo but
it's really just me on the command line
kind of showing you how the program runs
I think maybe it's better use of time to
take questions so if anybody has any
questions now it's the time and I can do
a demo later like after us anybody wants
to see it I'm happy to show you before
we do the questions let me just say
remember to rate the session and the
only important button is the great
smiley face and thank you yeah
I thought about using AST manipulation
for other things not not really I mean
it's it's it is a general the question
was have I thought about using the ISD
module for things beyond mutation
testing not really I mean it's it is a
general purpose tool it's not mutation
testing specific in any sense and it's
kind of a cool thing if you want to do
code generation and stuff like that you
can certainly use AST to do that but I
don't have any plans right now to use it
for anything else but if you've got any
neat ideas you know it's it's an easy
module to use right the the question was
are there any other tools mutation
testing tools that I know about the only
one that I know about is called P I T or
maybe it's pronounced pit but it's a
java tool it's apparently full-featured
robust industrial-strength ready for use
it's got a lot of fans and a lot of
users and a really smart guy behind the
project
I think it's P I test org maybe is the
name of the is this URL but it's p ith
testing java that that google that
you'll find it it is
yeah it's apparently a great tool and
just kind of light-years beyond anything
else that's available right now I said
the question was have I have I thought
about how to assist the users in
interpreting the output that they get
because yeah the mutation testing just
kind of shines a light and says okay
this test failed or this test you know
everything passed and blah blah blah
typically when you get the results out
of cosmic-ray the results tell you the
line that was changed and it tells you
the nature of the operator so it's
pretty easy to figure out what was
changed and so it's not always all that
difficult to figure it out what what
could be really difficult is to figure
out sometimes if what you've got in is
equivalent to mutant that you can ignore
or if it's something you really have to
worry about because you could imagine
situations where you replace greater
than with greater than equal that's a
pretty small logical change and it can
be really it can be actually be
impossible in like C++ and a private
method to actually test that in a direct
way so I guess to answer your question I
haven't thought too hard about providing
assistance because it seems that just
having the location of the change that
survived is typically enough and beyond
that you would have to have a really
really smart system to be able to assist
beyond
that I think I had something else I was
gonna say and it's flown out of my brain
I apologize okay the question what's a
typical failure rate was or a typical
survival rate um I don't know I would
feel like I'd be lying if I told you
there was a typical number but on the
tests that I've run
I see everything from you know a hundred
percent one hundred percent mortality
rate which is what you want and that's a
really good test suite but typically
that's on small projects to you if you
got a poor and this means kind of
typical test suite you could have a
really really high survival rate and
you're like 90 plus percent because
because test suites are not that
sensitive it turns out very often one
one thing that I puzzle about and ponder
about in the wee hours of the morning is
how much if mutation testing takes off
and becomes a more popular tool well
let's start to guide the way we write
tests I wonder about that because things
like equivalent Newtons and stuff well
if we worry about those that might
modify the way we write our code to make
it more testable in a mutation testing
sense in is is that a good thing or a
bad thing that this this kind of arcane
testing system is forcing us to write
code in a certain way and I've gone off
on a bit of a tangent there but I
there's not a there's not a number I
could give you it really depends heavily
on the kind of code you've got the
number of tests and the quality of your
test suite related interesting question
and one that I don't have an answer to
but I hope somebody somebody figures out
is how much language determines the the
efficacy of mutant testing you know if
you talk to a haskell aficionados they
will tell you that of course haskell is
the perfect language and if it compiles
it works and mutation testing should not
even be necessary or in a de users might
tell you the same thing that the code is
so tight that any mutant any mutation is
going to cause things to just collapse
and i'd be interesting interested to see
research into that area just on a sort
of personal level yeah yeah the question
was how is this related to the sort of
standard code coverage analysis it's
actually it's like code coverage
analysis on steroids standard code
coverage analysis most tools will simply
tell you okay i've run my test suite in
every line of code was executed whether
that line of code did the right thing or
whether our test suite is sensitive
enough to to tell us that we broken
something i mean because a mutation is
just a stand-in for a yeah that's a good
question i mean generally
that the follow-up was is there a good
reason to use one over the other
I've coverage analysis tools are
generally much faster so there's a
reason to use them but I wouldn't I
wouldn't wait to get 100% coverage with
a standard tool then start using
mutation testing I would maybe use them
in parallel they can work together
because often coverage analysis tools
also tell you which tests exercise which
line of code and if you want to use
those that information to reduce you
mutation testing space on a per change
basis that can be really useful so they
can work in tandem I suppose in that way
yes
the reason you do that is so that you
can you can be guaranteed that the
results you know which change caused the
failure test suite if I if I change ten
things at once and my test suite starts
to fail I left left scratching my head
going well which change doing some kind
of binary space reduction like doing a
bunch of tests and then if we get a
failure then only half and then only
half or something like that yeah I I
that's that's a that's a good question
I'm sure I've thought about this to some
degree but in and concluded that you
doing one test at a time is the way to
go and maybe there's a mathematical
reason for that but um I think the the
ultimate explanation is its it's the
scientific way only change one variable
at a time but I guess in the end if
you're not too concerned about
conflating mutations like maybe I have
one mutation that made on its own would
cause a failure but then in in if it's
made in change with this guy then
there's no failures and all of a sudden
you're really confident in your code but
in fact it's crap yeah you don't want to
be in that position yeah so so the
question was could we speed things up
essentially by reducing the scope of the
test we're running and I suppose that's
that's that that would be a refinement
to the way cosmic-ray runs now you could
say instead of tastic testing a whole
package test just this class i think
that's reasonable but since it's
generally your test Suites
responsibility to insert the mocks and
stuff you get all that for free when you
test the class it's not it's not some
new responsibility of the Mutai
testing sweet yeah they can work in
concert very well okay thanks again and
if you want to talk about this later
just just grab me in the halls Thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>