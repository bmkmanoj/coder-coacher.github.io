<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • DDD &amp; Microservices: At Last, Some Boundaries! • Eric Evans | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • DDD &amp; Microservices: At Last, Some Boundaries! • Eric Evans - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • DDD &amp; Microservices: At Last, Some Boundaries! • Eric Evans</b></h2><h5 class="post__date">2015-12-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yPvef9R3k-M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I believe I'll start now my name is
Eric Evans and I'm best known for the
concept of domain driven design that's
DDD and today I'll be talking about a
certain aspect or a few aspects of
domain driven design that are I think
applicable to micro services or perhaps
from my perspective the reasons that I
found microservices to be an exciting
opportunity for people trying to do
domain driven design that's really what
I'm more interested in so starting out I
want to just briefly point out what are
some things that got me interested in
micro services and first place well I
certainly was inspired by the stories I
heard about what was done at Netflix I
think it's important at this point to
recognize that micro service has come in
many flavors so I don't think that the
things that I think of as micro service
are necessarily representative of
everything everyone is doing certainly
what I say is based on my understanding
what they did at Netflix mostly and the
creation of a truly isolated place for
an autonomous team to do development was
the single thing I think I think was
most important to me because for as long
as I can remember I've been advocating
for example that a team that's
developing some complex piece of logic
should have their own isolated data
store and not have to share some huge
database that has some kind of mishmash
of different people's ideas of what the
data should be and so forth the
free-for-all of that makes it very
difficult to do sophisticated
modeling and and subtle designs that can
solve intricate business problems so
that was one of the first things that I
thought while we could really use this
and I started trying to get some people
on projects that I was on to adopt that
just that this say let's just isolate a
piece of business logic put it at the
end of a message queue and say it can't
share data with anything else except
what sent through that queue and see
what happens and it was it was a very
interesting very successful experiment
required going back and saying ah we'll
see you still have a connection to the
so the other database don't you so let's
keep going it was funny how persistent
those attitudes were one of the things
about micro services is that it seems to
acknowledge the rough and tumble of
enterprise development in a way that
most philosophies of software
development do not one thing that I am
more than tired of is sort of idealistic
views of software development and
software systems large software systems
it just isn't like that there's so much
going on and it's so rough-and-tumble is
the phrase that always comes to my mind
now if what you want to do is to address
an interesting and intricate problem
with a subtle model those things are
fragile those things are like snowflakes
and you have to have a way of having
those exist within an overall
rough-and-tumble situation and a lot of
times when people start talking about
doing sophisticated design it's a few
steps down the road you realize that
part of the idea there is that the
entire world will be redesigned and
everything will be very elegant and tidy
and that will never happen so so if you
value your design then you value ways of
isolating those things from from that
outer world
and you have to have a philosophy that
fully acknowledges the reality of that I
think that there is a kind of boldness
to the micro-services philosophy that
really appeals to me and I think that
things like cattle not pets and the
simian army just really inspired me with
their boldness and and innovation now
these are mostly runtime considerations
you know you deploy something and that's
when you treat it as a you know
livestock rather than a pet and you
deploy things and that's when you knock
them down with chaos monkeys and so
forth so what's interesting is that this
philosophy seems to have started from
that perspective of deployment and then
changed the way people actually do the
development and design work and that's a
different you know that's a different
approach I mean in the sense of where
you start and where you end up then most
of the software philosophies that I was
exposed to earlier in my career I think
it's very interesting it's a break from
the past and sometimes incremental
changes don't work for various reasons
I'm one of them is that our mindset when
we see incremental changes we perceive
them as being the same thing as before
people don't realize that some subtly
different concept is different but when
you have something that's a true radical
break then things get really shaken up
and it's a chance for people to think
differently that doesn't mean that
everything that microservices people do
is going to work I think far from it
it's like any new thing it's going to
have a lot of misguided things going on
in it but it's truly exciting new
shake-up
so with this caveat that I think
micro-services does seem to mean a lot
of different things to different people
this is basically where I'm coming from
and and the things that I'm about to say
are based on that perspective now what
is a service well if we just take sort
of a very basic say that a service is
something that can consume messages and
produce messages and in in there in
between inside of that service anything
could happen
right it can have a lot of data or you
could have very little data you could
have a lot of logic very little logic
there's a service and so let's imagine
that there are two services and these
two services actually use information
produced by the other one through
messages now the question that I ask is
how do they understand the messages how
do I understand a message that's
produced by another service a service
that is built by an autonomous team
right a different autonomous team than
mine
so this messages that they're sending
two out they're not really necessarily
sending them specifically to me but the
messages they're sending out are in some
language so I'm just labeling the
messages according to the service that
produced them so the message is coming
from a are in the a language and the
message is coming from B or in the B
language how do they understand them
obviously
the software is written in such a way
that they can interpret these messages
that they can interpret any of the ones
that they've chosen to consume now
understanding messages requires some
kind of context this isn't anything
about specific to micro services this is
just the way language works you can
never understand a phrase that you hear
unless you know the context and so when
and this is something that that I try to
make very explicit in domain-driven
design is that when we're doing model
that the the most central thing about a
model is often the language that you
create that allows you to express the
problem and solution very crisply and to
have that clarity of language you have
to make context clear and in practice in
software that means making an explicit
boundary not the subtlety with which we
interpret context in normal conversation
which is immensely complex but simply
drawing a line around something and
saying within this space this is what
this word means this is these are the
rules here so I call that a bounded
context now we could say that a and B
are each one of these bounded contexts
within a that establishes a boundary and
within B that establish the boundary and
inside of there they've each defined
their language and we have established a
translation between the two and in this
case the way this story seems to be
going we're going to say that a and B do
actually actively collaborate with each
other that is the people the people
developing a and B they collaborate with
each other we're going to call this a
partnership and that translator is a way
of saying messages from a can be
transformed into the B language and vice
versa and language B can be transformed
into a and they both care about that
translation now C comes along this is
another service and they are consuming
messages coming from a but this is not
that kind of mutual collaborative
relationship that a and B have
established C is consuming and doing
something with these messages and but a
is not as interested in C as they are in
B so this is a a symmetrical
relationship a kind of upstream and
downstream relationship and so when
put these on to this diagram and this
lower diagram make all the context not
because it shows all these different
contexts and now they relate put an
arrow which says this is the direction
where the power is that is to say that
the communications between a and B
follow the decisions that a makes that
rather sorry between a and C follow the
decisions that a makes not decisions
that C makes so the arrow points toward
a now in a situation like this C has to
make a decision how am I going to deal
with that the fact that I don't control
the kind of messages that I'm receiving
in this case C has made the decision
that they will conform to a that is I
will make my design
compatible with a so that the message is
the language of a will be a my language
will be a lot like their language I will
make it so much like their language that
it will be very easy for me to consume
their inputs their outputs this output
from a seems to be very useful and along
comes D another service and D also wants
to consume the message is coming from a
but they've made a different decision
they've said the things that we need to
do within our service are substantially
different than apparently what the a
people have in mind it's sufficiently
different in complex that we need to
control our own model we need to change
the language so we're going to put a
significant translation in place now
there is a significant translation
between a and B but it's one that's
managed between the two and the two are
coordinating their development but D is
not they simply are consuming the a
messages as they come so we call this an
anti-corruption layer I'm going to build
a little wall between me and you and it
will transform those income
messages into a form that I will use and
it's no one else's business how this
works I think that all of these things
happen and routinely whenever we have
multiple teams developing independently
and integrating with each other it's
helpful to make it explicit have a
picture of what's going on that people
can see it a high level of course
micro-services the idea is you'll have
many of them and so now along comes e e
is going to actually provide some inputs
that a will use but they're going to do
it in a slang guack this is somewhat
common what it means is that for
internal organizational reasons perhaps
the a people are able to say we need you
to send us messages in this form now
this means that E is conforming to a the
the direction of the arrows in a context
map don't correspond to data flow
direction they correspond to the
direction of the power and a seems to be
in a very influential position so C
conforms to them while they consume but
akin he also conforms and they are
providing a with information all right
he is also going to send this same data
to D now D is now consuming messages in
the a language from a and from E but
you'll notice that there's really no
need to change the context map the
context map is not a map of where the
messages are going it's the map of who
has to understand who's language where
are the translation points and basically
what decision did they make about their
relationship to the other language
now f F is going to consume B's language
and emit things in its own so C is going
to consume those and it has to decide
well C decided to conform to F but F is
not conforming to B now you might say ah
now C is conforming to F and a which
would be a problem if F and a are
providing similar kinds of information
right if you were sending me a listing
of movies and there if a is sending out
a listing of movies and F is sending out
a listing of movies and I'm trying to
conform to both ways of listing movies
that'll be a problem but if one of them
is sending me a list of movies and the
other one is sending me some completely
different information let's say credit
card statements well that's no problem
then I can conform to both alright so
one point as we you know deal with how
are we going to do modelling make it
practical practical tool one of the
things that people often miss I think is
that models need to be clear they don't
need to be big one of the worst kinds of
models that I've seen is the sort of the
enterprise model or things that are
moving in that direction where every
piece of information that someone might
ever want to use is somehow finds a home
within this enormous schema or where
they are working out a way to compute
almost anything within a given domain
the most valuable models that I have
created and used in my career have been
actually quite modest in scope and this
fits neatly within this idea of the
bounded context we need to have very
crisp definitions and for that we need a
clear bounded context also the most
interesting models tend to make
assertions that simplify the
interpretation of what's happening
and assertions require boundaries
because anything I am certain is simply
making a statement and saying this is
this is true this is always true and you
can ever you can almost never make
statements like that in in general so
you need a boundary but with a bounded
context you can make such statements so
there are always multiple models that is
a good thing and it's a thing that is
very sort of part of the air of
micro-services I think it seems
extremely natural in that kind of a
paradigm now as we go along in this back
to the story of our context map well
people don't always make good decisions
in the eff context they make a few poor
choices about how they represent the
data about how they compute things in
general it's a it's a bit of a mess and
since C is conforming to F that mess is
immediately going to migrate into C that
is if I conform to a mess then what does
that make me so remember the the kind of
design I'm talking about is where
clarity is the premium and F has lost
the clarity and as a result C has lost
their clarity that's one of the
consequences of conforming there are
good things about conforming but this is
one of the downsides now e has made some
poor choices as a consequence of Yi
being a bit of a mess now the message is
they're emitting which are supposed to
be conforming to a
no longer really are that is to say if I
may I'm receiving messages in a form
which was supposed to be in that just as
I had dictated but it actually is not
this isn't a choice that that the e
people have made it's just that they
didn't pull it off they they just don't
quite have the the competence or they
just messed up this one time so now
what's going to happen well in the ideal
world the pressure from a and D the two
consumers would probably push them to
get their act together and go back to
emitting well-formed a messages in the
ideal world but I have never worked in
the ideal world in the world where I
work right now there is a great risk
that both a and D are about to become
corrupted by this that the model of a
will start to have to accommodate a
little bit of e and the same goes for D
and those gray circles are just going to
fill the screen there is another
possibility but we'll get to that in a
minute this picture right now is a
fictional picture sit by that I mean
that what's really happening up above is
that E is not conforming to a but the
picture still says that they are so
we're going to need to change that
picture we want the context map to
reflect what is really happening whether
we like it or not now not all of a large
system will be well designed I think
that anyone who cares about good design
needs to drum this into their mind like
say it three times themselves in the
mirror every morning because if you
don't do that you will you know you'll
end up without any good design because
you'll
you'll overreach you keep trying to fix
everything right making you know about
fixing nothing spreading your work too
thin so the real question is in this
situation yes I mean it would be worth
looking into getting you to fix things
up but recognizing when they're not
going to do that what are we going to do
about these two relationships right now
there's no real clear way to write this
thing on to the context map because it's
just not a good situation for the most
part the patterns in the context mapping
technique are ways to describe
reasonably healthy relationships one way
would be for each of them to introduce
an anti-corruption there for the a
people to say well maybe we can get e to
fix things up someday at some point but
meanwhile we need to protect the
integrity of our model and that means
that we will receive these sort of
twisted AE messages and we will
translate them into nice clean a
messages before they come in to us so
that anti-corruption layer is
essentially a translator that takes
message of one language and turns them
into messages in another language and
now we are back in a situation where
even though there is some you know there
are several contexts here now that are
not well designed yet that doesn't
inevitably lead to a degeneration of all
the design in all the contexts so we
need a level of Riis reality to prevent
that all right so that's some that's the
first thing I wanted to get across is
what is it that made me think that micro
services would be a good vehicle for
domain driven design and basically it
comes down to
this kind of you know you give a real
isolation to the work within these
different teams within these different
contexts you have a way of of managing
that in most of the traditional
techniques it's much harder to make
clear boundaries and enforce them now
one of the things that happens with any
kind of you know let's break things into
smaller things approach is that you end
up with a lot of small things and it
gets to be very hard to to see the big
picture and it gets hard to make
coherent designs on the larger scale one
of the common things that that I see
though what people often do with
micro-services is what I've dubbed the
interchange context and so let's look at
this for example this is before II went
off the rails
so we've got right now we have one two
three four contexts that receive a type
messages in addition to a itself so you
have a lot of communication happening in
this one language this language is
becoming the de facto interchange
language that is to say that more and
more of these different services are
speaking a now that is actually pretty
common that someone designed it maybe
though for quite a specific reason and
then it becomes used for that another
way of doing it though if you if you
were to anticipate such an interchange
language might be to try to devise one
that was actually well suited to that
remember that a language was primarily
probably intended for
the logic that a does the way they think
about the problem for their purposes
plus perhaps their collaboration with be
a very specific collaboration but
actually EDC they never were too
interested in that if you had designed a
more generic kind of language for
communicating with them you probably
would have chosen something different
and this is an opportunity that I think
is not one that you'd want to do up
front but when you see something
emerging like this where you suddenly
see that this service this context is
becoming the de facto language for a
large part of the communication within a
system you might say let's devise a new
language that is just for that purpose
so this would be another context this
context does not correspond to a service
so so context I is the first one up here
that actually has no physical form at
all it's just a sort of way of talking
about things
it's got crisp definitions the cover
range of things that these contexts like
to talk to each other about but it
doesn't get into the kind of things they
need in order to actually solve their
internal problems which probably a does
have some baggage of that kind as I say
I don't like to anticipate these things
and do them before we start I like to
kind of let the need for it come upon us
now one of the things when I am talking
with people who are not micro services
fans but actually you know and I say oh
I like the micro services thing I think
it's good for creating these boundaries
and so forth and they say well a lot of
the things that you're saying you like
are just logical boundaries I mean we
don't really need all that machinery for
this
we don't need separate deployment you
know
why would we do all this separate
deployment stuff sure if you need to
scale you know scale some services at
very different levels of scaling and you
need that kind of failover and you need
all those things that's one way to do it
but the things that I've been talking
about are not mostly about that they're
not mostly about that runtime side
they're mostly about the effects that
that philosophy has on the development
phase right and I'm saying I think the
effects that that has on development
phase seem to be quite good and so I
think they're undeniably right that
there are in principle other ways to
create logical boundaries and my
response is simply that we've been
trying to do that for decades now ever
since I've been in this field and I
think before then people have tried to
establish those kind of logical
boundaries in various subtle ways and I
think it's just too subtle it's - it
doesn't survive the rough and tumble
there's always it's always too tempting
and too easy to pierce through the
boundary and grab the piece of
information you need from the database
or whatever and microservices by putting
all that machinery there makes it a
actually unnatural to do that it makes
it more natural to do the thing that
maintains the isolation sometimes you
know you need a wall you you have
perhaps a fence between your house and
the next house you could just sort of
draw a dotted line there you know on the
grass but there's something about a wall
so I think that this is the reason and I
just I just I don't really have to
understand it to have just observed that
we've been trying and trying and trying
to do this for a long long time but this
when I have
reduce to this approach in a project
that was trying to isolate things in
more logical ways the physical isolation
and the visibility it gave and other
things seems to have done the trick and
pushed it over into truly decoupling
pieces of the system so you may be
driven mostly by the runtime advantages
you may need to scale parts of your
system the client that I did this with
the first time really wasn't scaling
that big they rightly pointed out that
they could handle the problem that they
had without all that stuff but we did it
and it produced a decoupling that
allowed us to do the design better of
course if you need to do the scaling and
the other advantages then that makes it
a much easier choice all right so
basically my points are these that when
we want to do subtle design and it
doesn't have to just be domain driven
design but any kind of intricate logic
we need clarity a degree of precision
that demands isolation so we need some
kind of concrete boundary and I'll have
to say that the best ones I've seen were
the ones that been cooked up in the
microservices world I'm sure it's not
the only way to do it it's just proven
to be effective in my personal
experience and it's here you know it's
real when you get a whole lot of these
services you're going to see some of the
same problems crop up really you know
you describe service and when when
people start scaling the micro service
down to say a nano service where people
start talking about a service that might
have 20 lines of code in it or something
and I start thinking boy that sounds
like an object and
because you know and especially the the
way objects were in the old days like
small talk objects or little things that
can send messages to each other and so
on and and I think that there are you
know distinctions of course I'm not
saying they are objects but there are a
lot like them and some of the same
problems arise
will arise anyway and so you know this
is not a panacea it's not a solution to
all the problems but I think that some
of those problems then can be addressed
with tools like context mapping which
was specifically to address this kind of
problem to say you can understand a
certain collection of elements that have
been crafted to solve set of problems
and then another set of elements which
have been crafted to solve a different
set of problems but you can't understand
all of it all at the same time and
furthermore those different elements
have been conceived using different
concepts different language so we need
boundaries between them and then we need
a way of seeing how they relate to each
other so the boundary context and
context Maps helps to make that explicit
even you know both in the situation
where a service defines the context
boundary but also in the case where the
communication of several services where
the message is going between them
defines a context not the interior of
the services but the messages between
that space in between is another context
it helps us to visualize that and reason
about it so I think that the modest use
of interchange languages would be one
way of helping to organize a coherent
set of services that solves a somewhat
bigger problem and I think people
actually do this you know but without
any explicit tools to explicit mental
tools I mean to talk about it
just say one more time before I wrap up
that not all of a large system will be
well designed and you can even and that
I think is you know a natural part of
the micro-services philosophy it's one
that we have to carry over even to the
point of saying even the micro-services
properties won't be perfectly exhibited
within a large system there will be
fragile parts and there will be parts
that don't scale right and so forth
parts that get tangled with other parts
in such ways that make it very difficult
to do the things you do that you talk
about doing it's replacing and so on but
that's alright you know if this is not
meant to provide create a perfect system
meant to get things moving and freshen
things up so and on that I'll close and
and hopefully leave some time for
question yeah we do so thanks for the
talk
one of the questions from the online
tool is is in that design all bounded
context does ABC and so on
would they be separated microservices
and would they be separately deployed so
the question was this these context the
ABC and so on would they be micro
services that were separately deployed
and the answer is yes that's what I'm
that's what I'm suggesting that you know
would say an old-fashioned approach the
we would try to define these contexts in
other ways maybe they would be a certain
set of modules and a certain set of
tables they were associated with those
modules and you'd have maybe a document
describing them or some kind of labeling
within the comments and and all these
ways of trying to say these are the
boundaries of this context what I'm
saying about microservices is that one
thing it seems to do is it says this
service is a context
one team owns it it's isolated it
doesn't share data I mean it doesn't
shares data but only through the
interface it doesn't share a database
and so on and so the boundaries of this
context are very well-defined okay then
there is question the wall you called
Acey what is what does it mean in the
context map Oh anti-corruption layer yes
a a C is for anti-corruption and I guess
I I apologize for not defining that one
it's become such a common little
abbreviation that we use that I forgot
to and that the point of the name is
that if I am consuming information say a
message that's coming from outside that
can corrupt my fragile high-precision
design you know and so I have this you
know if you car engine is very high
precision machine that has to operate in
a fairly dirty and uncontrolled
environment and what does it have it has
filters right the air that goes into the
engine goes through an air filter
there's an oil filter that constantly is
cleaning things so they don't get into
the engine and so on so they know that
that kind of high precision thing unless
you're going to operate it in a clean
room somewhere in which case it doesn't
need all that well that is a massive
anti-corruption layer that's used for
those kind of things actually so to have
to have a really high precision solution
you need that kind of protection neither
and not all problems are so high
precision right that the you know the
car's engine has all that kind of
filtration and stuff but you know the
windshield wipers don't have that they
just swipe on the windows and eventually
they wear out and we replace them and
you know there are low precision parts
to a car and there are high precision
parts and the high precision parts need
to be treated differently they need that
isolation
and so if you're consuming data from
outside that context you can't assume
that it's meets the requirements that
you would think it would have so you
check those things and plus you
transform it into the same terminology
the same structure that you would be
expecting data that's moving around
within in on the inside and then once
these are on the inside you can make
lots of assumptions and make assertions
about the nature the data that you're
working with okay
there is another similar question so a
bee bee om what's that Wow yeah so bebe
om stored for a big ball of mud and I
decided I actually did consciously
decide to not use that term in the talk
and I forgot to take the bee boem off of
the slides but it is a wonderful you
know you should just Google for big ball
of mud and find the original big ball of
mud paper which is from the 90s but it
describes systems that have just grown
into big messes of tangle but the great
thing about that paper is that it
describes these in a kind of admiring
way like how they observed that most big
systems are like that and that somehow
it works in there is something about the
anyway it's a it's very clever paper so
I was just saying that we were getting
some big balls of mud but they probably
weren't very big okay
so more about the the architecture one
of the questions is can or should there
be a dedicated service whose purpose is
to only be an interchange context
provider I guess that was the I that you
had in your chart should there be a
service dedicated to being the
interchange context provider I think
that my answer would be no I say it
without a lot of con a lot of confidence
because yes you could imagine everything
getting but I think my answer would be
no because the point here is keep the
decentralization
of the micro-services architecture don't
create some bottleneck and so on
but on the other hand give us a way to
exchange messages without quite so much
translation perhaps and we can do that
without having some kind of special
service that I'm not sure what it would
do you know unless you add a database
that stored things in that form but
basically I think my answer is no but if
someone comes up with some solution you
know not all that dogmatic about these
things okay so another one that is more
about the organization so would you
recommend a one on one to one
relationship between teams and boundary
contexts would I have a one-to-one
relation between teams and boundary
context I would have an one to end that
is I want a bounded context to have a
clear owner so I would want to say if
this thing is a contact say like service
then there's a team that owns it but a
team might work on multiple services so
as long as you don't have the
problematic one is when you have two
teams that work on the same thing and
you see that in in places where they
carry the concept of shared code
ownership too far too far in my view
without any context boundary separation
where anyone can change anything within
the system so people lightly touch a
part of the system that they don't
understand very well and you have the
tragedy of the Commons and everything
just kind of degenerate so the context
should have one owner but a team might
conceivably own more than one okay and
and does that mean that only the team is
supposed to change the code of those
bonded contexts that is what I mean yes
okay cool
so and this is so this powerful
separation that you're talking about
isn't that also a problem because if
things don't turn out as expected so if
one of the teams doesn't really deliver
it's going to be hard to
it still find some way of going into
production and then you might have even
the Google company fail so I think this
is a problem this idea that if one team
fails to deliver that it will lead to a
kind of bigger failure that is a problem
which you would face under any
circumstances in fact you know the
micro-services is perhaps a little more
resilient to such things than more
monolithic approach but if you look at
some of the diagrams another nice thing
about the diagrams I think is it can
give you a hint about the consequences
like if if if D doesn't come through
then probably it won't affect a very
much but if a look how terrible it would
be of a screwed up you know the so you
know that the consequences of mistakes
in a are dire throughout the
organization so I don't I would say that
might help us know where to worry and if
I didn't trust a and I will see I'd be
thinking maybe I should you know another
thing I'll throw in here one thing I've
seen is that people sometimes value the
DRI principle too highly that is the
don't repeater so that don't duplicate
stuff too highly so let's suppose that
what a really wants from either what C
is really wanting from a is some
particular capability that really isn't
that hard I would rather see C
duplicated of course the ideal might be
that this thing would be broken out and
not be part of a or C but remember we
don't have the ideal that it integrate
if if you've created a dependency on a
whole other team and their success just
to have this function that they've
already built well maybe it's better to
do some duplicating okay
so I guess the final question can we use
the logical boundaries to create
multiple mark
services in a top-down way and I guess
closely associated with that question
doesn't make any sense
to create a monolith first and then go
for micro services what was the first
part though so whether you could use
these logical boundaries to create
multiple micro services top down ah so
would you sort of plan out and and then
yeah I am NOT against a little bit of
upfront planning a kind of a sketch and
then let's go do something kind of thing
which i think is very different from
meticulously planning everything out in
advance so I wouldn't I think such a
thing you know you I think you actually
are bound to do that a little bit as you
say well what are our first two or three
services going to be and we're going to
have a couple teams working on them okay
let's go work on that now so that is a
little bit top-down but not from very
high up right and in the other part
doesn't make sense to make the monolith
first you know I actually don't think so
but people say that that have experience
and good results and so although it goes
a little bit against my sense that I
think actually that I would at this
point I would start with something
pretty broken up actually but I'm not
going to I don't I don't think I have a
very strong opinion about that one all
right thanks lot again thanks for fine
answering the questions or into talk
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>