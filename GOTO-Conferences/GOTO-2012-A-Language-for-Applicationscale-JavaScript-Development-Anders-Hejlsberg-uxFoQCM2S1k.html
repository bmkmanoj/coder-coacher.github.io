<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2012 • A Language for Application-scale JavaScript Development • Anders Hejlsberg | Coder Coacher - Coaching Coders</title><meta content="GOTO 2012 • A Language for Application-scale JavaScript Development • Anders Hejlsberg - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2012 • A Language for Application-scale JavaScript Development • Anders Hejlsberg</b></h2><h5 class="post__date">2013-04-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uxFoQCM2S1k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Andrew Salzburg technical technical
fellow at Microsoft and I'm here to talk
about typescript which is a project that
we've been working on for the last two
two and a half years so typescript is
about solving a problem that we
increasingly heard from from our
customers you know in particularly over
the last five years customers and even
internal teams keep telling us how how
hard it is to write large applications
in JavaScript several reasons you know
one being that that JavaScript really
was never designed to to write large
applications it did you know it was
there was sort of like originally
intended for these 10 line event
handlers and now we're writing 10,000 or
100,000 line apps in it and the language
doesn't really have any large-scale
application structuring concepts like
classes or modules and also it's
entirely dynamically typed which means
there's no static type information off
of which we can power intelligent
tooling and if you think about what it
is that powers the intelligent IDEs that
we all use today it really is static
type information that makes it possible
to do code completion safe refactorings
finding all references go to definition
etc etc so two two and a half years ago
where we were thinking about where do we
go next with JavaScript development
tools we thought it'd be really neat if
we could strengthen JavaScript but with
those key concepts that are missing for
large-scale development like classes
modules optional static typing but but
doings but but to do so in a way that
doesn't sacrifice the inherent thing
that makes JavaScript so interesting ie
cross-platform open standards web and so
forth and and that is what what types
grip is it is a language for application
scale JavaScript development so it's a
language for the
or application scale JavaScript
development next level down or the more
technical description is typescript is a
superset of JavaScript that compiles to
plain JavaScript and it does so the
compiler itself and the code that it
produces runs on any browser any host on
any operating system and the compiler
and the associated language services
library typings and so forth are all
open source we put this project out in
the open about two days ago and what I
have here is basically you know the
publicly available in installation of it
that that we're going to try and play
with now so typescript starts with
JavaScript all JavaScript code is valid
typescript code because we are a pure
superset of of JavaScript and that means
that you can just copy and paste
JavaScript into a typescript file and
then work with it there it also means
that types break works with all of the
existing frameworks and libraries that
are available out there today like
nodejs or jQuery backbone underscore
prototype etc etc there are lots of them
a new ones coming practically every day
so the thing that we then add on top is
optional static typing classes and
modules arm and those are really sort of
the things that that allow us then to
build great tooling because they are the
missing things that that power the the
Ides today the cool thing though is that
there's zero cost all of this all a
typescript is purely a development time
tool once you compile you you're left
with plain JavaScript and there's no
runtime component that needs to be
present in order to to run the generator
code in fact we simply compile to
idiomatic JavaScript the JavaScript that
you would have written if you wanted to
emulate classes or or modules and the
final code runs as I
in any browser any host on on any OS so
let's let's actually try to do a little
bit of demoing and see what this looks
like in action here is the typescript
website well actually is a local copy I
have just in case we lost connectivity
but but this is what it looks like and
we're going to go and play with
typescript in the typescript playground
which is basically a web page where you
can where you can type in typescript and
see the compiled output in in a window
on the side I'm going to switch here and
grab my first little demo and so here
you see some some JavaScript and here
you see the compiled output which
happens to be exactly the same because
we are just a superset of JavaScript now
if you look at this code there's
something funny about this code right I
mean I'm like taking a parameter X and
I'm adding a property to our setting a
property but I'm also plussing it
together but hey this is valid
JavaScript it just so happens to not be
meaningful but it's valid now now it
would be nice let's say for example that
I knew that X was going to be a string
it sure would be nice if I could somehow
indicate that and you know it's not like
we're inventing anything new in that
sense you know for example if you use a
tool like Google's closure where you put
type annotations in comments there are
there are tools that can check these
things for you but but having your type
system in comments is not particularly
conducive to readability of the code nor
is it particularly expressive you know
there are a bunch of things that you
can't say in these comments and you
can't put them in all the places that
you would like to put them so what
typescript does instead is it allows you
to put type annotations in your code so
i can say x is of type string and when i
do so you see that our IDE starts to
light up I should mention that that what
is powering underneath this edit box
that I'm typing in is the typescript
compiler and the typescript language
service because typescript is written in
typescript and when you
pilot you get JavaScript and you can
just use that anywhere and so that's
what we're what we're doing here and so
the first thing you see is that we get
something here that says there's no name
property on type string which is which
is true there isn't we also see if we
hover over V that we've inferred that
string clustering is a string and
therefore V is of type string and we see
that alert is a thing that takes a
string and returns void and therefore it
is valid to pass me to it now let me try
to get rid of that line and error here
and let's try one of the other primitive
types number for example and now we see
now we're inferring that number plus
number is a number and now we're trying
to pass a number to a method that
expects a string and that in turn is
also an error so so here's some more you
know static type checking happen
happening let's try to use a bool and
step and now we see that operator +
can't be applied to bools well it
actually can in JavaScript it just so
happens that you don't get a meaningful
result right then so in a sense what
this is about is trying to to to siphon
out that meaningful subset of Java the
semantic subset of JavaScript that makes
sense and that's basically what what
what what we're doing here right now we
also allow are more complicated types
like a raise for example i can say that
x is a string array and now when I index
into X and press dot you see that we
know that there are strings and
therefore we can show you all the
methods that are available on string and
not just their names but also their
signatures so we can see that care code
at is a thing that takes an index and
which is number and returns a number and
so forth other
typical patterns that are interesting is
we could say X is a function that takes
no arguments and returns a string and
now when we call it and say dot again
you see we get statement completion but
of course one thing that's really
interesting is having the ability to
describe a shape of object here for
example I'm saying that whoops that my
function takes an X that is an object
that has an A and a B property and now
when I say x dot you see that we get
statement completion here XA xB and so
forth now I might also want to give a
name to to this structural type or this
anonymous type so you see you can write
types just in line but of course you can
also name them I think I have this
little example here that shows you how
you could write an interface thing with
two properties in it that's really just
interface here think of it more as I'm
writing an object type whose name is
thing and it has two properties and let
me now try for example and say bar n
equals process of a colon 10 comma B
colon hello for example now a couple of
things worth noting here first of all if
you've been following along over in the
generated JavaScript you see that the
JavaScript we generate is really just
the JavaScript that you type minus the
type annotations and minus the type
declarations so all of that is there you
know for validation and an IDE tooling
sake and then it just compiles away now
the other thing you'll note here if we
if we try to look a little bit of this
program so we've defined a to be a
number and here we return X dot a which
means we've inferred that we return a
number which in turn means that we can
infer that process is a function that
takes a thing that returns a number
which in turn means that when we call
process we can infer that n is a number
and so you see how thi
flow-through just a few annotations and
then we can flow it through the code
once we know what what's going on let me
try to sort of show here what also
happens for example let's say I add an
extra property to my interface type here
now you'll notice that i get errors here
it says process is is missing one of the
one of the parameters um and I could fix
that by by adding by parameter C but I
could also instead indicate that C is an
optional parameter so this is a pattern
that's very common in JavaScript where
you take say options bags that are a
bunch of options but you don't actually
have to specify all of them right so
here we're saying that a and B are
mandatory but C is optional if I give a
see it must be a bool if I give a see
that isn't a pool now it's an error so
so we can we can sort of express some of
the more intricate parts of what goes on
in in JavaScript let me actually try to
take this piece of code here I'm just
going to copy it and then let's switch
to a visual studio and just get
ourselves an empty typescript file so
now part of typescript the distribution
is a plug-in for visual studio that uses
the compiler and language service to
power up all of these intelligent
facilities in the IDE as i said this
stuff is all open source so you can use
it anywhere else where you saw an
example of using in a web browser you
someone could build an eclipse plugin
and do do the same thing i'm just going
to paste it in here and then continue
playing with with our code in here so
one thing you of course can express
whips in types is is methods so now
we're saying that thing has a and B
properties of type number and a foo
method so now when I do statement
completion you see we have a foo and
when I do open curly it tells me what
the signature of that guy is and so on
and again here we
and further than that it now we return a
string because foo returns history we
actually also allow you to express
overloads so I can say there's a nut
there's foo actually is a method that
when you give it a string returns a
string and when you give it a number it
returns a number this happens very often
in JavaScript for example I'd like to
think of jQuery and a dollar object that
has seven different overloads that you
can if you give it a function then it
does this if you give it a string it
does that if you give it an object bag
it does this other thing and so on and
so it's important to be able to to model
that in the type system so we can follow
along and when you say dot on that give
you the right type information again so
now if we look here if I say X dot foo
you'll see that there are now two
overloads our old ask you in any way ah
so if I give it a number here you go
then process now returns a number now
this stuff here actually our is really
the same as writing this but so foo what
I'm really saying here with these two
overloads is that there's a foo property
that has two possible call signatures
one that takes a string and returns a
string around it takes a number and
returns a number and but i can describe
further things on my on my function for
example it also has a data property so
and this again is stuff that occurs so
now when I say foo dot you'll see that
there's a data property but I can also
call it with two different overloads and
so I can model all of these crazy things
that occur in in JavaScript libraries in
fact just for completeness sake let me
add a couple more here I could I could
now also define that thing can be a
constructor function that takes a string
and returns elements and when you index
into it you get dates and so forth and
now so crazy stuff when I say new X here
it says oh you must give me a string and
when you do then I'm going to return and
etc etc so we basically can model all of
these things that go on in the
JavaScript Dom jQuery all at all of the
frameworks ok let me get rid of this
stuff and try to paste in some other
here's a little more advanced example of
type inference a function that closes
over a local variable and returns an
object with a bunch of function
properties that use that that local and
this is how you get privacy in
javascript is a very very common pattern
right if you if you look in this piece
of code the only thing that that differs
from regular JavaScript is this one
annotation here that says that that this
function takes a number but we can infer
all of the types from from from this so
if you hover over the return statement
here you'll see that we've inferred that
this returns a thing that has three
properties that are each of a function
type that has certain argument types and
so forth and in turn make accumulator
therefore is a function taking no
arguments that returns an object literal
containing three functions that etcetera
etc etc so so we can sort of grok it all
on and now when I say bar a equals make
accumulator and then a dot you'll see
that there's an ad here and that I need
to pass a number five and and so forth
now so this shows how we can infer from
coach at your writing but sometimes
inference you want inference to go in
the other direction you may for example
I have a declaration of an interface
that you want to go implement a now
really you would like to make inferences
from that about the code that you're
that you're writing so let's say that my
make accumulator function here is
something that's supposed to return an
accumulator right well you'll see that
it all works out now because we actually
have structural typing here so the mere
fact of writing an object literal that
has the right shape is an implementation
of that interface you don't have to
first declare that you implement it but
but the other thing that's really cool
is that if I made a mistake here like
typed in the wrong
propertyname then it tells me what's
wrong it tells me that hey you're
missing property ad from accumulator arm
now this is where tooling gets really
really useful imagine that this was like
a 500 line object literal and trust me
I've seen lots of them in JavaScript
code and there's something wrong in
there somewhere how the hell do you
figure that out right I mean that's what
tools are supposed to do for you and
that's what we that's what we do here
okay another place where this kind of
contextual typing is interesting is well
actually i should show here that even
even if i get rid of that type
annotation you'll note that we can still
infer that value is a number because
you've said that you're returning an
accumulator and accumulator has an add
function that takes a number and
therefore we can relate that and still
flow the types in the other in the other
direction right this turns out to be
useful for example if i say a document
dot on mouse move here which is one of
the events you can handle equals
function of e and then open curly e dot
and you'll note that we actually know
what e is here and the way we know it is
because we know what document is
document is the root document document
has a non mouse move that takes a mouse
event and returns any and therefore we
can push the type information into e as
a mouse event and therefore we can give
your statement completion on e when you
say dot and so lots of lots of inference
going on the cool thing is i can
actually go to the definition of mouse
move and and look at what this thing is
and that jumps you into in this
particular case a file called lib DTS
and this is eight thousand lines of
typescript declarations that declare the
entire structure of the dom and the
JavaScript runtime library this is
actually generated from the IDL files
that are standardized so so we know it's
correct that the type information is
actually available it's just that
JavaScript itself has no way of
conveying this information to you
then at runtime when it's too late right
so so here we can see that mouse move is
the thing that takes a mouse event and
we can actually navigate around and and
check out all of these things and then
see what what their shapes are now the
thing that's really neat about this is
that we can provide this file just as an
adjunct file on the side and once you
have that information the tooling lights
up and we can do that for any JavaScript
library out there so we and we actually
do do that for nodejs and we do it for
jquery in the typescript distribution so
so just as an adjunct file we can
provide the missing information right
and then light up the tooling based on
on that and I think that is just super
super valuable ok so let me uh let's see
where did I want to go from here let me
go back and just sort of summarize a
little bit about the type scripting here
so basically what what what typescript
does is it formalizes javascripts type
system and provides a static view of it
but we're not trying to invent a new
type system we're actually bending over
backwards to stay true to what really is
JavaScript type system you see that we
do a lot of type inference and
structural typing and in and there and
and the reality is that when you're
writing typescript code you actually end
up writing very few type annotations and
then we just flow from from from there
as I said it works with existing
JavaScript libraries and for the type
system geeks out there this is not a
provably typesafe type system because
javascript is not in a sense provably
type safe while you do first have to
define what you really mean by that but
but the point here is that it is not a
type system for the traditional sakes of
type systems like performance or like
strict validation rather it is a type
system that helps you author code and
that reflects you know the reality if
you will but it is optional and and you
don't have to use it but when you do use
it the tooling can help you born
okay let me try to jump back and show
you some of the other features that are
available I wanted to show classes and
modules and we'll go back to the
playground because it's instructive to
see the code that the compiler generates
so typescript supports classes so I can
declare class point for example here and
say it has two fields sorry my typing is
not great x colon number and y colon
number like so and you see that we
generate the code that is sort of
typical for for for writing classes
where you have a closure in which you
have a constructor function that we then
return out of the out of the closure and
now i can save our p equals new point
and now we know that on p there's an X
and a y so we can give you statement
completion so you can say P dot x equals
10 p dot y equals 20 and so on okay now
of course it would be nice to be able to
give the arguments to my point here but
if I do I get an error because we
haven't yet written that constructor but
we could go right one constructor of X
colon number comma y colon number and in
here we can say this dot X and again you
see we get statement completion on this
because we know where you're at this dot
y equals y and so forth now this this
class syntax by the way is aligned with
akma script sixes current proposals for
classes so so the class and module
extensions that you see in typescript
are actually in a sense of preview of
what's coming in at my script six but
then on top of that we have layered
optional static typing which is not part
of what what Equus critics is is doing
so of course you can have methods in
classes so let's write a disk method
here and let's say in here we want to
return mass dot and again here you see I
get statement completion on all the
whole stuff that's available in in the
standard runtime library so I want to
return this dot x times this dot X plus
this dot y times
stop why for example for my dad a little
nicer okay so one thing you see here is
that instance variables go on this but
methods go on the prototype and this is
exactly how JavaScript saw regni script
six is planning to do classes and this
is basically the typical pattern that
people use them and they write prototype
change in JavaScript we allow some other
things in classes here for example I
could declare a static field static
origin equals new point of zero comma 0
for example and you'll note now that
statics go on the constructor function
object methods go on a prototype
instance variables go on the instance
and so forth and now we understand what
this means so when I say point dot you
see that I get an origin member on point
okay we also allow allow you to write
private member's but but with a twist so
I can say for example private color oops
hold on string like so and now down here
if I say this dot color equals red
you'll see that we generate the code and
you see that this statement completion
on this shows the color member but if I
go down here and say P dot you'll see
that there's no collar member on P
because it's private so we limit you to
access only within the class if you
declare things to be private however in
the generated code we simply just
generate a normal member called color
because there is no way of having
private members in JavaScript at least
not currently one sec rescript six rolls
around with private names we could
target private names for this kind of
code generation and and perhaps do a
better job but right now we do the best
we can okay a couple of other neat
features we support what we call
automatic
properties this pattern of declaring
fields taking constructor arguments with
the same names as tough as the
properties and then saying this dot blah
equals blah is super super common so we
have a nice shorthand for that where
instead you can simply on the
constructor arguments a public here and
public here and then we automatically
inject properties with those names and
inject the code to initialize those
properties we also support another egg
no scrip six feature which is default
argument value so i could give these
arguments default values just by saying
equals something and then we inject the
correct code to check whether they're
undefined and and so on and now of
course the the type system oops the type
system now knows that it is permissible
to omit the arguments in the in the call
so we don't get a red squiggly on that
okay ah that's well I should also show
that we of course support inheritance
for classes let's try to declare class
point 3d extends point like this and
then let's just take a look at what
happened in our generated code so we
still have our point class right here
and now we also have a point 3d and you
notice that the code gen for that is a
little bit different we generate a
function closure that takes the base
class as an argument and then we call a
helper extends that sets up the
prototype chain the way you're supposed
to do in javascript this is why classes
are hard and JavaScript because you're
supposed to do all of these crazy things
right this extends method is injected
into the generated source code only if
there are class derived classes in that
file and that is the only time we inject
code that you didn't right into the
output file otherwise the code you get
is simply the method bodies that you
wrote so there is no runtime library or
new collection classes or blah blah blah
or anything associated with typescript
it is simply just JavaScript okay I
could in here write myself a
constructor that takes X colon number
I'm a la jolla number comma say public
at an extra pop it easy colon number
like that and then in here say call
super of X comma Y for example and now
you see that we generate the appropriate
code for making a call to the super
constructor etc etc yeah so that's a
clases what I wanted to show next is
modules let's try to actually let me try
and grab a little snippet of code over
here what I wanted to show before that
in fact is arrow functions so let me go
to the tool box and let me grab a
tracker here we go okay let me paste
that in here okay here's a little piece
of code school this up so you can see
what's going on here's a little class
that declares a counter instance
variable and then it has a start method
and in the start method we capture the
onmousemove event and have a little
handler that increments our counter and
then does a consult a log of the counter
so let's try and run it so you can
actually run the output here in the
playground let's bring up the f12 tools
and go to the console window and then we
see that hmm there's there's something
wrong with our code we're getting a
bunch of Nan's out of this if we go back
and look at what's going on here the
problem that we have here and if I had
actually been typing this code in we
would have already seen what what the
problem was is but if we hover over this
now you can see that this is of type any
meaning that we do not know the type of
this here and therefore we wouldn't have
gotten statement completion to show
count and so forth but the reason it's a
problem or the reason this is is of type
any is that you never know what this
you're going to get in a function call
and sometimes you're going to get the
wrong this for example in a mouse movie
then you get the element that the move
occurred on you don't get the this of
the surrounding context now any
everyone's gotten bit by this problem
and it's got people have gotten bit
enough by
that there's a proposal in egmore
scripts six to support what's called
arrow functions or what we in c-sharp
called lambda functions so I could
instead write this code as e arrow arm
and then in a lambda function this is
always of the type of the surrounding
context or its lexically scoped meaning
that i get the dis of the outer function
and the way we coat generate that is we
do the nasty little thing that you
normally have to do where you say bar
that equals this and then that dot
inside your function or whatever we can
simply code generate that for you
instead here what's interesting about
okay and let's actually just sort of run
and prove to ourselves that that it now
works yep we're seeing what we're
supposed to see think that's interesting
too is if in my little mouse move here
let's say that I did not refer to the
outer this then you'll note that we
don't generate that that closure so we
only injected if you actually do it and
then we rewrite it to underbar this
instead okay now the other thing we
support in typescript is modules let's
say i wanted to put this class in a
module i could write here module open
curly and down here close curly oops of
course we want to give this module a
name or call it module utils and you'll
see that while we generate for a module
again is a function closure where where
we then for all of the things that you
export out of the module if I say export
class tracker we then create a property
on the module object for each of the
exported items in this is also a very
very typical pattern in in JavaScript
and now of course we get red squigglies
here because there is no tracker in the
global scope it is now utils dot and if
I say doc do you see that there's a
tracker in there and that's that's the
one that that that we want right I can
actually go deep with these things acne
doc ordered utils and you see we just
nest function closures
sort of off the screen there and now I
have to refer to it act as Ahmed our
cordon utils but you'll note that we do
track it in the type system so we know
that the name of this type is accurate
or corridor utils in fact we even allow
you to import modules so i can say
import ACU equals acne or dot utils for
example and then here i can use the
shorthand for for that ACU and if you
look down here you'll see that what
we've generated is just a variable that
grabs that module object and then you
use that to reference instead these
modules we call internal modules and
they're they're very typical like jquery
for example is an example of a module
called dollar right that has a whole
bunch of stuff in it there's another
kind of modules that are that are in
common use out there called common jas
modules and no das uses those and those
are basically like source files that get
loaded dynamically at runtime and have
the ability to state their requirements
in terms of other modules and state
their exports in terms of an exports
object and we support those so let me
actually try to close down the
playground here and then let's go back
in visual studio and let's try to open
up a server to yes here and let me try
to write a little to module node server
application so first thing I'm going to
do is I'm going to import a reference
the static typing of nodejs which is in
a declaration file called no DTS and I
simply place a reference in my in my
source file which tells the compiler
that when you compile this file also
include that other file in in the
compilation and now i can say import
HTTP equals module of HTTP which is one
of the modules defined by node and in
fact if i go to definition on this guy
you'll see that it jumps
into the adjunct static type information
file for HTTP and this is what it is
itself powering off of in order to give
me statement completion Hill ok so let
me now try to write a function here
export function simple server that takes
a port Cole on number comma message on
string like so and in here let's say we
want to call HTTP dot create server and
you see we get statement completion on
node here create server in turn is a
thing that takes a callback function
that has two parameters request and
response so i can give those guys and
then in here i can write the body of my
of my code now i'm going to just paste
in some stuff here so so you don't have
to watch me type at all but note one
thing that when i type result dot we
actually get statement completion on
that so we float the types from the
Declaration of create server into the
callback function because we know what
the types of those callback arguments
are and so we can flow it all without
you having to explicitly state it
anywhere ok let's just go back here and
say dot listen of 1337 first no sorry of
port which was the argument that we got
past ok so that's the first module of
our of our little server let me create
another see here here open another empty
file and now let's create a module that
uses the module that we just wrote so
I'm going to say import server Rip's
server equals module of server and now i
actually have referenced the module that
i just wrote and so if i say server dot
now I actually get statement completion
on the module that I just wrote so I can
now call simple server and I tell
you gotta pass me a port number so 1337
comma hello go to for example and then
let's just all so just say console dot
log of listening like so there and let's
save that guy alright and now let me
jump out and actually use the command
line compiler so we'll switch to note
are sorry demo node and in here you'll
see now that we have our three files the
node declaration file and the two
typescript files that I wrote now I can
simply tell it to compile hello TS I
don't even have to tell it about server
TS because the compiler will
automatically trace all of my imports
and all of the references that i have
and find the entire graph of files that
need to be compiled and then compile
those so if we look at the output that
got generated we now have two files
hello dot j SNL o our server gayest we
can just sort of take a look here server
ja j s if we ups let's try to take a
look at that and you'll see that the
code that's in there is the code that I
wrote with my import changed into a
require and if we type hello dot jas
you'll see again it's pretty much the
same code right let's try to run a node
on this server so node hello and it's
listening and now let's go to get rid of
this guy there and then let's go to
localhost 1337 there and we should see
hello co2 there we go yep okay so that's
a little bit about classes and modules
ah I could just quickly summarize here
that that basically you know these are
the things that allow us to do scalable
app development right and this is how
you you get to write really large
applications and have tools that
understand what what the contracts are
between different modules and have them
enforced so you find the errors before
you run your app instead of whilst
you're running it
we're aligned with the emerging standard
so as I said earlier classes modules
arrow functions are all things that are
proposed for egmore script six that
we're taking inspiration from and we
support the two popular module systems
that are out there common jeaious which
is used by nodejs and then AMD modules
which probably the most common loader
there's require da Jas and that's used
for asynchronous module loading in a
browser and we support both of those
okay last thing I wanted to show was
just a few larger applications because
we've been doing a bunch of little stuff
here so let's try to load up some of our
samples first thing I'm going to open is
let's see demo / image board this is one
of the samples that that we include and
let's just load up app to yes so this is
a multi-module nodejs application that
uses MongoDB and and the Express
framework so in here you see that we
import modules from various places HTTP
and URL come from node DB is actually a
module that we wrote we can navigate in
and look at it and in here you see that
that in turn uses MongoDB so we can
navigate into that and check out the
static typing of a MongoDB in here you
see that we opened we create a server
create a connection to it and then just
for convenience we've defined some
interface types that represent the
entities that we're storing in the
database because they are all of the
same type and it's really actually
convenient to have statement completion
and validation on these entities that we
that were putting the right thing into
into the database and then we've also
written some helper functions like get
user here that takes an ID and then
asynchronously calls you back when it's
fetched the user from the database and
here you see we use the interface files
that we that we just declare now we can
use the IDE to navigate in this larger
app we can for example find all
references of get user and you'll see
that here's the Declaration of it and
then there are two references over in
the app here's one that that I think is
interesting if you look at this
this function here there are 0 type
annotations in this function yet we know
all the secrets about it because app
elsewhere is typed as being of type
express server we know that Express
server has a get method that takes that
has a bunch of overloads and one of them
is one that takes a function that
returns that that has two arguments
request and response and so we can infer
what their types are we know what the
type of user is the one that we declared
over in the database module and so when
we're in here if I say request dot you
see that I get statement completion if I
say user dot you see that I get
statement completion so we know all of
this stuff without having use to state
it over and over it's inferred from the
code now in the interest of time I'm not
going to actually run this one I'm going
to try and switch and show you another
little sample ah which is one called
warship and let's start a load that guy
up here and let's get rid of this dude
and just dude this is a little app that
a browser app that uses jQuery and
jQuery UI and you'll see that we
referenced at typing for jquery and for
jQuery UI and let me show you how this
works then because the pattern between
these two libraries is that that jQuery
UI is a library that builds on top of
jQuery it actually sort of monkey
patches into the dollar object and adds
additional properties that that are far
for you I manipulation so if we look at
dollar well first of all you'll see that
we now have type information for jQuery
so we know the seven overloads of AB
dollar we're going to pick the one that
takes a string and then we're going to
press dot on it and here you see all of
the things that that you can say on
dollar now this is the stuff that saves
you from having the cheat sheet next to
you or or looking up in some HTML
documentation right this is what tools
are supposed to do for you if we pick
add class are then we can actually go to
the definition of that guy and you see
now we jump into the
jquery declaration file and you see
here's the main interface for jquery and
it has an address in fact has two
overloads of AD class now if we go back
let's say we pick one of the ones from
jQuery UI like draggable for example and
let's say we go to definition on that
guy you'll note that we jump into a
different file that declares the same
interface so in typescript interfaces
are open-ended and multiple files can
contribute to the same interface and
that's how we model this notion that one
module does something and then another
module builds on that first module by
adding things to its types and and so we
can model that in the type system and
that's just super super useful okay last
thing I wanted to show is a really large
project the typescript compiler itself
let me try to load that up here and
we'll just pick one of the files out of
the compile the compilers about 26,000
lines of types of typescript code here I
loaded up the file that contains the
abstract syntax tree class definitions
and I and as I said all of this is open
source so it's it's stuff that you can
just grab and look at we can navigate in
here for example go to the definition of
the case statement class which is a
class that extends statement and so
forth and so I can navigate around the
entire compiler now you saw that at the
top of this file I reference a file
called typescript es if we go to the
solution exploring in Visual Studio you
see that we've actually inferred the
entire project that I'm working on here
from those references because if we go
to typescript es you'll see that that in
turn reference is a whole bunch of other
files and through these references the
compiler can get the full picture and it
almost doesn't matter which file you
open we know the context and therefore
we can provide you all of the all of the
appropriate information so in here in
this is the main file for the typescript
compile there's a class called
typescript compiler not surprising
typescript compiler instantiates a
parser we can go to the deaf
mission of the parser the parser in turn
instantiates a scanner we can go to the
definition of that guy and then so you
can sort of navigate around very easily
and see how the compiler is built what I
wanted to show though is is one of the
really neat things that you can do once
you have static type information and
that's things like refactorings and one
of the refactorings we support is rename
for example let's say that here in the
scanner I have a field called haha
called line number that I ok i forgot to
rename that back to two line from the
last demo i gave anyway there's a field
called line number if i look at all the
places that this guy is referenced if i
do go to definition on this guy so I go
to find all references on this guy
you'll see that there are a bunch of
references in the scanner itself and
then there are some over in the parser
that we can look at ah and here's one
for example in the parser where we
reference a line now up here there's
also a property called line okay so let
me first go back to the scanner and try
to rename here ah refactor rename and
call this guy line instead okay now if I
go back to the parser you see that it
has now renamed line number over here to
line okay but now what's really
interesting is now I have two things
called line one coming from the scanner
and then I have one coming from this
line call thing that I'm that I'm using
in here as a local right let's say that
I now have to rename my scanners line
back to line number okay now if this was
JavaScript code that would be insanely
hard to do right because you have to
look at every reference to line in all
your source files and decide on the fly
is this the one or is that another one
but this is what I DS do for for you
know all day long right they because
through static typing we know the
difference so let me take this parser
file here and actually put it down at
the and at the bottom and now let's try
to show both of them here you see the
one in my scanner here you see the one
that isn't related to it let's go back
and say refactor rename
and now let's call this guy line number
instead and you'll see that we renamed
that guy but not that guy because we
understand the difference between the
two so so here we go this is again one
of those things that just make tooling
incredibly valuable when you're writing
large applications okay final thing I
want to show is just compiling the
compiler sorry there we go so in here is
the source for all the compiler that we
that we just took a look at now I'm
going to try to compile the compiler I'm
going to tell it to put the output in a
file called tsas then I'm going to tell
it to also generate generate
declarations and I'm gonna compile
typescript es so this is going to
produce two files first it's going to
produce the compiler in a file called
tsas and that's just going to be plain
JavaScript then it's also going to
produce a declaration file that
represents the external interface of the
compiler so if we look at what we we
sorry what we got here you'll see that
there are there we had two files
produced t SJ s and then TSD tes and
that's the declaration file for the
compiler and now if I load that one up
in the development environment here
let's see it it just go and then let's
just get rid of the parcel and here you
see basically the public abstract of all
of the things declared in the compiler
that someone using the compiler as a
service could use and so now I can in a
sense continue up the chain of my
modular development I can take my
typescript compiler run it through my
minify or do whatever it is that I do my
office Gator before I ship it and then I
can continue on with the declaration
file and that really is what represents
my external interface right and so you
see how you can manually author
declaration files for existing
JavaScript but if you
writing in typescript we can make the
declaration files for you automatically
all right I think that is as much as I
have time for wanted to just briefly
summarized watching what's included in
typescript open source compiler written
in typescript itself tooling there's a
browser hosted playground that uses
these services and because it's open
source you anyone can build plugins to
other editing environments we built one
for visual studio that we include we
include static typing's of a bunch of
the popular libraries out there like
nodejs and jquery and also lots of
samples and a formant language
specification so as I started out saying
application scale JavaScript development
is hard I hope I've showed you here how
typescript makes it easier and I'd love
for you to go take a look at it yourself
at typescript land or get downloaded
play with it and let us know what you
think thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>