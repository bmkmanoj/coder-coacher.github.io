<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2012 • TypeScript Keynote • Anders Hejlsberg | Coder Coacher - Coaching Coders</title><meta content="GOTO 2012 • TypeScript Keynote • Anders Hejlsberg - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2012 • TypeScript Keynote • Anders Hejlsberg</b></h2><h5 class="post__date">2012-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3dqZW_DqHIQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I am Andrew Salzburg technical technical
fellow at Microsoft and I'm here to talk
about typescript which is a project that
we've been working on for the last two
two and a half years so typescript is
about solving a problem that we've
increasingly heard from from our
customers you know in particularly over
the last five years customers and even
internal teams keep telling us how how
hard it is to write large applications
in JavaScript several reasons you know
one being that that javascript really
was never designed to to write large
applications it did you know it was it
was sort of like originally intended for
these ten line event handlers and now
we're writing ten thousand or a hundred
thousand line apps in it and the
language doesn't really have any
large-scale application structuring
concepts like classes or modules and
also it's entirely dynamically typed
which means there's no static type
information off of which we can power
intelligent tooling and if you think
about what it is that powers the
intelligent IDs that we all use today it
really is static type information that
makes it possible to do code completion
safe refactorings finding all references
go to definition etcetera etcetera so
two two and a half years ago where we
were thinking about where do we go next
with JavaScript development tools we
thought it'd be really neat if we could
strengthen JavaScript but with those key
concepts that are missing for
large-scale development like classes
modules optional static typing but but
doings but but to do so in a way that
doesn't sacrifice the inherent thing
that makes JavaScript so interesting
ie cross-platform open standards web and
so forth and and that is what what
typescript is it is a language for
application scale JavaScript development
so it's a language for the
or application scale JavaScript
development next level down or the more
technical description is typescript is a
superset of JavaScript that compiles to
plain JavaScript and it does so the
compiler itself and the code that it
produces runs on any browser any host on
any operating system and the compiler
and the associated language services and
library Taipings and so forth are all
open source we put this project out in
the open about two days ago and what I
have here is basically you know the
publicly available in installation of it
that that we're going to try and play
with now so typescript starts with
JavaScript all JavaScript code is valid
typescript code because we are a pure
superset of JavaScript and that means
that you can just copy and paste
JavaScript into a typescript file and
then work with it there it also means
that typescript works with all of the
existing frameworks and libraries that
are available out there today like
nodejs or jQuery backbone underscore
prototype etc etc there are lots of them
a new ones coming practically everyday
so the thing that we then add on top is
optional static typing classes and
modules arm and those are really sort of
the things that that allow us then to
build great tooling because they are the
missing things that that power the the
IDE s today arm
the cool thing though is that there's
zero cost all of this all the typescript
is purely a development time tool once
you compile you you're left with plain
JavaScript and there's no runtime
component that needs to be present in
order to to run the generator code in
fact we simply compile two idiomatic
JavaScript the JavaScript that you would
have written if you wanted to emulate
classes or or module
and the final code runs as I said in any
browser any host on on any OS so let's
let's actually try to do a little bit of
demoing and see what this looks like in
action here is the typescript website
well actually is a local copy I have
just in case we lost connectivity but
but this is what it looks like and we're
going to go and play with typescript in
the typescript playground which is
basically a web page where you can where
you can type in typescript and see the
compiled output in in a window on the
side I'm going to switch here and grab
my first little demo and so here you see
some some JavaScript and here you see
the compiled output which happens to be
exactly the same because we are just a
superset of JavaScript now if you look
at this code there's something funny
about this code right I mean I'm like
taking a parameter X and I'm adding a
property to or setting a property but
I'm also placing it together but hey
this is valid JavaScript it just so
happens to not be meaningful but it's
valid now now it would be nice and let's
say for example that I knew that X was
going to be a string it sure would be
nice if I could somehow indicate that
and you know it's not like we're
inventing anything new in that sense you
know for example if you use a tool like
Google's closure where you put type
annotations in comments there are there
are tools that can check these things
for you but but having your type system
in comments is not particularly
conducive to readability of the code nor
is it particularly expressive you know
there are a bunch of things that you
can't say in these comments and you
can't put them in all the places that
you would like to put them so what
typescript does instead is it allows you
to put type annotations in your code so
I can say X is of type string and when I
do so you see that our IDE starts to
light up I should mention that that what
is powering underneath this edit box
that I'm typing in is the typescript
compiler and the typescript language
service
because typescript is written in
typescript and when you compile it you
get JavaScript and you can just use that
anywhere and so that's what we're what
we're doing here and so the first thing
you see is that we get something here
that says there's no name property on
type string which is which is true there
isn't we also see if we hover over V
that we've inferred that string plus
string is a string and therefore V is of
type string and we see that alert is a
thing that takes a string and returns
void and therefore it is valid to pass V
to it now let me try to get rid of that
line and error here and let's try one of
the other primitive types number for
example and now we see now we're
inferring that number plus number is a
number and now we're trying to pass a
number to a method that expects a string
and that in turn is also an error so so
here's some more you know
static type checking happen happening
let's try to use a bool and step and now
we see that operator plus can't be
applied to bools
well it actually can in JavaScript it
just so happens that you don't get a
meaningful result right and so in a
sense what this is about is trying to to
to siphon out that meaningful subset of
Java the semantic subset of JavaScript
that makes sense and that's basically
what what what what we're doing here
right now we also allow our more
complicated types like a race for
example I can say that X is a string
array and now when I index into X and
press dot you see that we know that
there are strings and therefore we can
show you all the methods that are
available on string and not just their
names but also their signatures so we
can see that care code app is a thing
that takes an index and which is number
and returns a number and so forth other
typical patterns that are interesting is
we could say X is a function that takes
no arguments and returns a string and
now when we call it and say dot again
you see we get statement completion but
of course one thing that's really
interesting is having the ability to
describe a shape of object here for
example I'm saying that whoops that my
function takes an X that is an object
that has an A and a B property and now
when I say X dot you see that we get
statement completion here X a X B and so
forth now I might also want to give a
name to to this structural type or this
anonymous type so you see you can write
types just in line but of course you can
also name them I think I have this
little example here that shows you how
you could write an interface thing with
two properties in it that's really just
interface here think of it more as I'm
writing an object type whose name is
thing and it has two properties and let
me now try for example and say bar n
equals process of a colon 10 comma B
colon hello
for example now a couple of things worth
noting here first of all if you've been
following along over in the generated
JavaScript you see that the JavaScript
we generate is really just the
JavaScript that you type - the type
annotations and - the type declaration
so all of that is there you know for
validation and and IDE tooling sake and
then it just compiles away now
the other thing you'll note here if we
if we try to look a little bit of this
program so we've defined a to be a
number and here we return X dot a which
means we've inferred that we return a
number which in turn means that we can
infer that process is a function that
takes a thing that returns a number
which in turn means that when we call
process we can infer that n is a number
and so you see how type
flow through just a few annotations and
then we can flow it through the code
once we know what's going on let me try
to sort of show here what also happens
for example let's say I add an extra
property to my interface type here now
you'll notice that I get errors here it
says process is is missing one of the
one of the parameters and I could fix
that by by adding by parameter C but I
could also instead indicate that C is an
optional parameter so this is a pattern
that's very common in JavaScript where
you take say options bags that are a
bunch of options but you don't actually
have to specify all of them right so
here we're saying that a and B are
mandatory but C is optional if I give a
C it must be a bool if I give a C that
isn't a bool now it's an error so so we
can we can sort of express some of the
more intricate parts of what goes on in
in JavaScript let me actually try to
take this piece of code here I'm just
going to copy it and then let's switch
to visual studio and just get ourselves
an empty typescript file so now part of
typescript the distribution is a plugin
for visual studio that uses the compiler
and language service to power up all of
these intelligent facilities in the IDE
as I said this stuff is all open source
so you can use it anywhere else where
you saw an example I'm using in the web
browser you someone could build an
eclipse plug-in and do the same thing
I'm just going to paste it in here and
then continue playing with our code in
here
so one thing you of course can express
lips in types is is methods so now we're
saying that thing has a and B properties
of type number and a foo method so now
when I do statement completion you see
we have a foo and when I do open curly
it tells me what the signature of that
guy is and so on and again here we can
further than that it now we return a
string because foo returns history we
actually also allow you to express
overloads so I can say there's a nut
there's foo actually is a method that
when you give it a string returns a
string and when you give it a number it
returns a number this happens very often
in JavaScript for example I like to
think of jQuery and a dollar object that
has seven different overloads that you
can if you give it a function then it
does this if you give it a string it
does that if you give it an object bag
it does this other thing and so on and
so it's important to be able to to model
at the type system so we can follow
along and when you say dot on that give
you the right type information again so
now if we look here if I say X dot foo
you'll see that there are now two
overloads are oh that's really and
anyway ah
so if I give it a number here you go
then process now returns a number now
this stuff here actually R is really the
same as writing this but so foo what I'm
really saying here with these two
overloads is that there's a foo property
that has two possible call signatures
one that takes a string and returns a
string amount it takes a number and
returns a number and but I can describe
further things on my on my function for
example it also has a data property so
and this again is stuff that occurs so
now when I say foo dot you'll see that
there's a data property but I can also
call it with two different overloads and
so I can model all of these crazy things
that occur in in JavaScript libraries in
fact just for completeness sake let me
add a couple more here I could I could
now also define that thing can be a
constructor function that takes a string
and returns elements and when you index
into it you get dates and so forth and
now so crazy stuff when I say new X here
it says oh you must give me a string and
when you do then I'm going to return and
mint etc etc so we basically can model
all of these things that go on in the
JavaScript Dom jQuery all at all of the
frameworks okay let me get rid of this
stuff and try to paste in some other
here's a little more advanced example of
type inference a function that closes
over a local variable and returns an
object with a bunch of function
properties that use that that local and
this is how you get privacy in
JavaScript is a very very common pattern
right if you if you look in this piece
of code the only thing that that differs
from regular JavaScript is this one
annotation here that says that that this
function takes a number but we can infer
all of the types from from from this so
if you hover over the return statement
here you'll see that we've inferred that
this returns a thing that has three
properties that are each of a function
type that has certain argument types and
so forth and in turn make accumulator
therefore is a function taking no
arguments that returns an object literal
containing three functions that etcetera
etc etc so so we can sort of grok it all
on and now when i say VAR a equals make
accumulator and then a dot you'll see
that there's an ad here and that i need
to pass a number five and and so forth
now so this shows how we can infer from
code you're writing but sometimes
inference you want inference to go in
the other direction you may for example
I have a declaration of an interface
that you want to go implement and now
really you would like to make inferences
from that about the code that you're
that you're writing so let's say that my
make accumulator function here is
something that's supposed to return an
accumulator right well you'll see that
it all works out now because we actually
have structural typing here so the mere
fact of writing an object literal that
has the right shape is an implementation
of that interface you don't have to
first declare that you implement it but
but the other thing that's really cool
is that if I made a mistake here like
typed in the wrong
property name then it tells me what's
wrong it tells me that hey you're
missing property add from accumulator
now this is where tooling gets really
really useful imagine that this was like
a 500 line object literal and trust me
I've seen lots of them in JavaScript
code and there's something wrong in
there somewhere how the hell do you
figure that out right I mean that's what
tools are supposed to do for you and
that's what we that's what we do here
okay
another place where this kind of
contextual typing is interesting is well
actually I should show here that even
even if I get rid of that type
annotation you'll note that we can still
infer that value is a number because
you've said that you're returning an
accumulator and accumulator has an ADD
function that takes a number and
therefore we can relate that and still
flow the types in the other in the other
direction right this turns out to be
useful for example if I say a document
dot on mousemove pier which is one of
the events you can handle equals
function of E and then open curly
dot and you'll note that we actually
know what E is here and the way we know
it is because we know what document is
document is the root document document
has a non bounce move that takes a mouse
event and returns any and therefore we
can push the type information into E as
a mouse event and therefore we can give
you statement completion on E when you
say dot and so lots of lots of inference
going on the cool thing is I can
actually go to the definition of Mouse
move and look at what this thing is and
that jumps you into in this particular
case a file called Lib DTS and this is
eight thousand lines of typescript
declarations that declare the entire
structure of the DOM and the JavaScript
runtime library this is actually
generated from the IDL files that are
standardized so so we know it's correct
and the type information is actually
available it's just that JavaScript
itself has no way of conveying this
information to you other
then at runtime when it's too late right
so so here we can see that mousemove is
the thing that takes a mouse event and
we can actually navigate around and and
check out all of these things and then
see what what their shapes are now the
thing that's really neat about this is
that we can provide this file just as an
adjunct file on the side and once you
have that information the tooling lights
up and we can do that for any JavaScript
library out there so we and we actually
do do that for nodejs and we do it for
jQuery in the typescript distribution so
so just as an adjunct file we can
provide the missing information right
and then light up the tooling based on
on that and I think that is just super
super valuable ok
so let me uh let's see where did I want
to go from here let me go back and just
sort of summarize a little bit about the
type scripting here so basically what
what what typescript does is it
formalizes Java scripts type system and
provides a static view of it but we're
not trying to invent a new type system
we're actually bending over backwards to
stay true to what really is Java scripts
type system you see that we do a lot of
type inference and structural typing and
in and there and and the reality is that
when you're writing typescript code you
actually end up writing very few type
annotations and then we just flow from
from from there as I said it works with
existing JavaScript libraries and for
the type system geeks out there this is
not a provably type safe type system
because javascript is not in a sense
provably type safe while you do it first
have to define what you really mean by
that but but the point here is that it
is not a type system for the traditional
sakes of type systems like performance
or like strict validation rather it is a
type system that helps you author code
and that reflects you know the reality
if you will but it is optional and and
you don't have to use it but when you do
use it the tooling can help you born
let me try to jump back and show you
some of the other features that are
available I wanted to show classes and
modules and we'll go back to the
playground because it's instructive to
see the code that the compiler generates
so typescript supports classes so I can
declare class point for example here and
say it has two fields sorry my typing is
not great X colon umber and Y colon
number like so and you see that we
generate the code that is sort of
typical for for writing classes where
you have a closure in which you have a
constructor function that we then return
out of the out of the closure and now I
can save our P equals new point and now
we know that on P there's an X and a y
so we can give you statement completion
so you can say px equals 10 P dot y
equals 20 and so on okay now of course
it would be nice to be able to give the
arguments to my point here but if I do I
get an error because we haven't yet
written a constructor but we could go
write one constructor of X colon number
comma Y colon number and in here we can
say this dot X and again you see we get
statement completion on this because we
know where you're at this dot y equals y
and so forth now this class syntax by
the way is aligned with echo script
sixes current proposals for classes so
so the class and module extensions that
you see in typescript are actually in a
sense of preview of what's coming in
ECMO Script 6 but then on top of that we
have layered optional static typing
which is not part of what what echo
script 6 is is doing so of course you
can have methods in classes so let's
write a dist method here and let's say
in here we want to return math dot and
again here you see I get statement
completion on all the whole stuff that's
available in in the standard runtime
library so I want to return this dot X
times this dot X plus this dot Y times
this dot Y
for example for my dad a little nicer
okay so one thing you see here is that
instance variables go on this but
methods go on the prototype and this is
exactly how Java scripts or Eggman
script six is planning to do classes and
this is basically the typical pattern
that people use them and they write
prototype chains in JavaScript we allow
some other things in classes here for
example I could declare a static field
static origin equals new point of zero
comma zero for example and you'll note
now that statics go on the constructor
function object methods go on the
prototype instance variables go on the
instance and so forth and now we
understand what this means so when I say
point dot you see that I get an origin
member on point okay we also allow allow
you to write private members but but
with a twist so I could say for example
private color oops hold on string like
so and now down here if I say this dot
color equals red you'll see that we
generate the code and you see that this
statement completion on this shows the
color member but if I go down here and
say P dot you'll see that there's no
caller member on P because it's private
so we limit you to access only within
the class if you declare things to be
private however in the generated code we
simply just generate a normal member
called color because there is no way of
having private members in JavaScript at
least not currently ones echo Script six
rolls around with private names we could
target private names for this kind of
code generation and and perhaps do a
better job but right now we do the best
we can okay
a couple of other neat features we
support what we call automatic
properties this pad
of declaring fields taking constructor
arguments with the same names as tough
as the properties and then saying this
dot blot equals blah is super super
common so we have a nice shorthand for
that where instead you can simply on the
constructor arguments a public here and
public here and then we automatically
inject properties with those names and
inject the code to initialize those
properties we also support another echo
scrip six feature which is default
argument value so I could give these
arguments default values just by saying
equals something and then we inject the
correct code to check whether they're
undefined and and so on and now of
course the the type system oops the type
system now knows that it is permissible
to omit the arguments in the inter call
so we don't get a red squiggly on that
okay ah that's well I should also show
that we of course support inheritance
for classes let's try to declare class
point 3d extends point like this and
then let's just take a look at what
happened in our generated code so we
still have our point class right here
and now we also have a point 3d and you
notice that the code gen for that is a
little bit different we generate a
function closure that takes the base
class as an argument and then we call a
helper extends that sets up the
prototype chain the way you're supposed
to do in JavaScript this is why classes
are hard in JavaScript because you're
supposed to do all of these crazy things
right this extends method is injected
into the generated source code only if
there are class derived classes in that
file and that is the only time we inject
code that you didn't write into the
output file otherwise the code you get
is simply the method bodies that you
wrote so there is no runtime library or
new collection classes or blah blah blah
or anything associated with typescript
it is simply just JavaScript okay I
could in here write myself a
constructor that takes X : number I'm a
y : number comma say public add an extra
property z : number like that and then
in here say call super of X comma Y for
example and now you see that we generate
the appropriate code for making a call
to the super constructor etc etc yeah so
that's a classes what I wanted to show
next is modules let's try to actually
let me try and grab a little snippet of
code over here what I wanted to show
before that in fact is arrow function so
let me go to the toolbox and let me grab
tracker here we go okay let me paste
that in here okay here's a little piece
of code scroll this up so you can see
what's going on here's a little class
that declares a counter instance
variable and then it has a start method
and in the start method we captured the
onmousemove event and have a little
handler that increments our counter and
then does a consult log of the counter
so let's try and run it so you can
actually run the output here in the
playground let's bring up the f12 tools
and go to the console window and then we
see that hmm there's there's something
wrong with our code we're getting a
bunch of Nan's out of this if we go back
and look at what's going on here the
problem that we have here and if I had
actually been typing this code in we
would have already seen what what the
problem was is but if we hover over this
now you can see that this is of type any
meaning that we do not know the type of
this here and therefore we would have
gotten statement completion to show
count and so forth but the reason it's a
problem or the reason this is is of type
any is that you never know what this
you're going to get in a function call
and sometimes you're going to get the
wrong this for example in a mousemove
event you get the element that the move
occurred on you don't get the this of
the surrounding context now everyone's
gotten bit by this problem and it's got
people have gotten bit enough by it
that there's a proposal in Egmore script
six to support what's called arrow
functions or Bob Wian C sharp called
lambda functions so I could instead
write this code as e arrow armed and
then in a lambda function this is always
of the type of the surrounding context
or it's lexically scoped meaning that I
get the deserve the outer function and
the way we code generate that is we do
the nasty little thing that you normally
have to do where you say bar that equals
this and then that dot inside your
function or whatever we can simply code
generate that for you instead here
what's interesting about okay and let's
actually just sort of run and prove to
ourselves that that it now works yep
we're seeing what were supposed to see
think that's interesting too is if in my
little mouse move here let's say that I
did not refer to the outer this then
you'll note that we don't generate that
that closure so we only inject it if you
actually do it and then we rewrite it to
underbar this instead okay now the other
thing we support in typescript is
modules let's say I wanted to put this
class in a module I could write here
module open curly and down here close
curly whoops of course we want to give
this module a name or call it module
utils and you'll see that while we
generate for a module again is a
function closure where where we then for
all of the things that you export out of
the module if I say export class tracker
we then create a property on the module
object for each of the exported items in
this is also a very very typical pattern
in in JavaScript and now of course we
get red squigglies here because there is
no tracker in the global scope it is now
utils dot and if I say dot do you see
that there's a tracker in there and
that's that's the one that that that we
want right I can actually go deep with
these things
Acme doc or dot utils and you see we
just nest function closures
sort of off the screen there and now I
have to refer to it act as a comedic or
dot utils but you'll note that we do
track it in the type system so we know
that the name of this type is accurate
accord utils in fact we even allow you
to import modules so I can say import AC
u equals Acme or dot utils for example
and then here I can use the shorthand
for for that a Cu and if you look down
here you'll see that what we've
generated is just a variable that grabs
that module object and then you use that
to reference instead these modules we
call internal modules and they're
they're very typical like jQuery for
example is an example of a module called
dollar write that has a whole bunch of
stuff in it um
there's another kind of modules that are
that are in common use out there called
common GS modules and nodejs uses those
and those are basically like source
files that get loaded dynamically at
runtime and have the ability to state
their requirements in terms of other
modules and state their exports in terms
of an exports object and we support
those so let me actually try to close
down the playground here and then let's
go back in visual studio and let's try
to open up a server TS here and let me
try to write a little two module note
server application so first thing I'm
going to do is I'm going to import a
reference these static typing of node
dot J S which is in a declaration file
called node dot d TS and i simply place
a reference in my in my source file
which tells the compiler that when you
compile this file also include that
other file in in the compilation and now
I can say import HTTP equals
module of HTTP which is one of the
modules defined by node and in fact if I
go to definition on this guy you'll see
that it jumps
into the adjunct static type information
file for HTTP and this is what it is
itself powering off of in order to give
me statement completion hill okay so let
me now try to write a function here
export function simple server that takes
a port code on number comma message on
string like so and in here let's say we
want to call HTTP dot create server and
you see we get statement completion on
node here create server intern is a
thing that takes a callback function
that has two parameters request and
response so I can give those guys and
then in here
I can write the body of my of my code
now I'm going to just paste in some
stuff here so so you don't have to watch
me type at all but note one thing that
when I type result dot we actually get
statement completion on that so we float
the types from the Declaration of create
server into the callback function
because we know what the types of those
callback arguments are and so we can
flow it all without you having to
explicitly state it anywhere okay let's
just go back here and say dot listen of
1337 first no sorry of port which was
the argument that we got passed okay so
that's the first module of our of our
little server let me create another see
here here open another empty file and
now let's create a module that uses the
module that we just wrote so I'm going
to say import server oops
server equals module of server and now I
actually have referenced the module that
I just wrote and so if I say server dot
now I actually get statement completion
on the module that I just wrote so I can
now call simple server and it tells
you got to pass me a port number so 1337
comma hello go to for example and then
let's just also just say console dot log
of listening like so there and let's
save that guy all right and now let me
jump out and actually use the
command-line compiler so we'll switch to
node R sorry demo node and in here
you'll see now that we have our three
files that the node declaration file and
the two typescript files that I wrote
now I can simply tell it to compile
hello TS I don't even have to tell it
about server dot TS because the compiler
will automatically trace all of my
imports and all of the references that I
have and find the entire graph of files
that need to be compiled and then
compile those so if we look at the
output that got generated we now have
two files hello dot j s and r lo our
server jeaious we could just sort of
take a look here server j s if we hips
let's try think a look at that and
you'll see that the code that's in there
is the code that I wrote with my import
changed into a require and if we type
hello dot J s you'll see again it's
pretty much the same code right let's
try to run a node on this server so node
hello
and it's listening and now let's go to
ah get rid of this guy there and then
let's go to localhost 1337 there and we
should see hello go to there we go yep
ok so that's a little bit about classes
and modules ah I could just quickly
summarize here that that basically you
know these are the things that allow us
to do scalable app development right and
and this is how you you get to write
really large applications and have tools
that understand what what the contracts
are between different modules and have
them enforced so you find the errors
before you run your app instead of
whilst you're running it
we're aligned with the emerging
standards so as I said earlier classes
modules arrow functions are all things
that are proposed for equi script six
that we're taking inspiration from and
we support the two popular module
systems that are out there common
jeaious which is used by nodejs and then
AMD modules which probably the most
common loader there's require dot Jas
and that's used for asynchronous module
loading in a browser and we support both
of those okay last thing I wanted to
show was just a few larger applications
because we've been doing a bunch of
little stuff here so let's try to load
up some of our samples first thing I'm
going to open is let's see demo slash
image board this is one of the samples
that that we include and let's just load
up app dot - yes so this is a multi
module nodejs application that uses
MongoDB and and the Express framework so
in here you see that we import modules
from various places HTTP and URL come
from node DB is actually a module that
we wrote we can navigate in and look at
it and in here you see that that in turn
uses MongoDB so we can navigate into
that and check out the static typing of
a MongoDB in here you see that we opened
and create a server create a connection
to it and then just for convenience
we've defined some interface types that
represent the entities that we're
storing in the database because they are
all of the same type and it's really
actually convenient to have statement
completion and validation on these
entities that we that were putting the
right thing into into the database and
then we've also written some helper
functions like get user here that takes
an ID and then asynchronously calls you
back when it's fetched the user from the
database and here you see we use the
interface files that we that we just
declared now we can use the IDE to
navigate in this larger app we can for
example find all references of get user
and you'll see that here's the
Declaration of it and then there are two
references over in the app here's one
that that I think is interesting if you
look at this
dysfunction here there are zero type
annotations in this function yet we know
all the secrets about it because app
elsewhere is typed as being of type
Express server we know that Express
server has a get method that takes that
has a bunch of overloads and one of them
is one that takes a function that
returns that that has two arguments
request and response and so we can infer
what their types are we know what the
type of user is the one that we declared
over in the database module and so when
we're in here if I say request dot you
see that I get statement completion if I
say user dot you see that I get
statement completion so we know all of
this stuff without having use to state
it over and over it's inferred from the
code now in the interest of time I'm not
going to actually run this one I'm going
to try and switch and show you another
little sample R which is one called
warship and let's try to load that guy
up here and let's get rid of this dude
and this dude this is a little app that
a browser app that uses jQuery and
jQuery UI and you'll see that we
referenced at the Taiping for jQuery and
for jQuery UI and let me show you how
this works then because the the pattern
between these two libraries is that that
jQuery UI is a library that builds on
top of jQuery it actually sort of monkey
patches into the dollar object and adds
additional properties that that are for
UI manipulation so if we look at dollar
well first of all you'll see that we now
have type information for jQuery so we
know the seven overloads of dollar we're
going to pick the one that takes a
string and then we're going to press dot
on it and here you see all of the things
that that you can say on dollar now this
is the stuff that saves you from having
the cheat sheet next to you or or
looking up in some HTML documentation
right this is what tools are supposed to
do for you if we pick add class R then
we can actually go to the definition of
that guy and you see now we jump into
the
jQuery declaration file you see here's
the main interface for jQuery and it has
an ad pass in fact it has two overloads
of AD class now if we go back let's say
we pick one of the ones from jQuery UI
like draggable for example and let's say
we go to definition on that guy
you'll note that we jump into a
different file that declares the same
interface so in typescript interfaces
are open-ended and multiple files can
contribute to the same interface and
that's how we model this notion that one
module does something and then another
module builds on that first module by
adding things to its types and and so we
can model that in the type system and
that's just super super useful okay last
thing I wanted to show is a really large
project the typescript compiler itself
let me try to load that up here and
we'll just pick one of the files out of
the compile the compiler is about 26,000
lines of types of typescript code here I
loaded up the file that contains the
abstract syntax tree class definitions
and I and as I said all of this is open
source so it's it's stuff that you can
just grab and look at we can navigate in
here for example go to the definition of
the case statement class which is a
class that extends statement and so
forth and so I can navigate around the
entire compiler now you saw that at the
top of this file I reference a file
called typescript es if we go to the
solution Explorer in in Visual Studio
you see that we've actually inferred the
entire project that I'm working on here
from those references because if we go
to typescript es you'll see that that in
turn reference is a whole bunch of other
files and through these references the
compiler can get the full picture and it
almost doesn't matter which file you
open we know the context and therefore
we can provide you all of the all of the
appropriate information so in here in
this is the main file for the typescript
compiler there's a class called
typescript compiler that's pricing ah
typescript compiler instantiates a
parser we can go to the definite
mission of the parser the parser intern
instantiates a scanner we can go to the
definition of that guy and so you can
sort of navigate around very easily and
see how the compiler is built what I
wanted to show though is is one of the
really neat things that you can do once
you have static type information and
that's things like refactorings and one
of the refactorings we support is rename
for example let's say that here in the
scanner I have a field called
ha called line number that I forgot to
rename that back to to line from the
last demo I gave anyway there's a field
called line number if I look at all the
places that this guy is referenced if I
do go to definition on this guy so I go
to find out references on this guy
you'll see that there are a bunch of
references in the scanner itself and
then there are some over in the parser
that we can look at ah and here's one
for example in the parser where we
reference a line now up here there's
also a property called line ok so let me
first go back to the scanner and try to
rename here ah refactor rename and call
this guy line instead ok now if I go
back to the parser you see that it has
now renamed line number over here to
line ok but now what's really
interesting is now I have two things
called line one coming from the scanner
and then I have one coming from this
line call thing that I'm that I'm using
in here as a local right let's say that
I now had to rename my scanners line
back to line number ok now if this was
JavaScript code that would be insanely
hard to do right because you have to
look at every reference to line in all
your source files and decide on the fly
is this the one or is that another one
but this is what IDs do for for you know
all day long right they because through
static typing we know the difference so
let me take this parser file here and
actually put it down at the and at the
bottom and now let's try to actually
show both of them here you see the one
in my scanner here you see the one that
isn't related to it let's go back and
say refactor rename
now let's call this guy line number
instead and you'll see that we renamed
that guy but not that guy because we
understand the difference between the
two so so here we go this is again one
of those things that just make tooling
incredibly valuable when you're writing
large applications okay final thing I
want to show is just compiling the
compiler sorry there we go
so in here is the source for all the
compiler that we that we just took a
look at now I'm going to try to compile
the compiler I'm going to tell it to put
the output in a file called tsks then
I'm going to tell it to also generate
generate declarations and I'm going to
compile typescript es so this is going
to produce two files first it's going to
produce the compiler in a file called
tsj s and that's just going to be plain
JavaScript then it's also going to
produce a declaration file that
represents the external interface of the
compiler so if we look at what we saw
what we got here you'll see that there
are there we had two files produced
tsj s and then TS d TS and that's the
declaration file for the compiler and
now if I load that one up in the
development environment here let's see
it it just go and then let's just get
rid of the parser and here you see
basically the public abstract of all of
the things declared in the compiler that
someone using the compiler as a service
could use and so now I can in a sense
continue up the chain of my modular
development I can take my typescript
compiler run it through my minify or do
whatever it is that I do my office cater
before I ship it and then I can continue
on with the declaration file and that
really is what represents my external
interface right and so you see how you
can manually author declaration files
for existing JavaScript but if you
in typescript we can make the
declaration files for you automatically
alright I think that is as much as I
have time for wanted to just briefly
summarized watching what's included in
typescript open source compiler written
in typescript itself tooling there's a
browser hosted playground that uses
these services and because it's open
source you anyone can build plugins to
other editing environments we built one
for visual studio that we include we
include static
typings of a bunch of the popular
libraries out there like nodejs and
jquery and also lots of samples and a
formal language specification so as i
started out saying application scale
javascript development is hard I hope
I've showed you here how typescript
makes it easier and I'd love for you to
go take a look at it yourself at
typescript land or get downloaded play
with it and let us know what you think
thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>