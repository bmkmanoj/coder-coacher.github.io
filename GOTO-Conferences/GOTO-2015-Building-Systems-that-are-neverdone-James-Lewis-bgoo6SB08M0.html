<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Building Systems that are #neverdone • James Lewis | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Building Systems that are #neverdone • James Lewis - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Building Systems that are #neverdone • James Lewis</b></h2><h5 class="post__date">2015-12-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bgoo6SB08M0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay well hello my name's James as has
already been pointing out I'm going to
be talking today about building systems
that are never done so this talk is
really about it it's really about me
thinking about all the practices I've
learned over the years as a software
engineer as a developer and whether
they're applicable in the world of
building micro services that's that's
really what this talks about why is it
called never done well never done
there's a number of meanings right the
first meaning I've never done is
something that's incomplete right so do
I mean when I talk about building
systems that are never done that were
building systems that are incomplete
going back to that chaos report update
from this morning you know I don't want
to be in that 50 odd percent of of
developers who are building building
software that never that never works or
never gets into production so I don't
really mean this this is not what I mean
by never done instead I've been thinking
about what it means to build systems
that stand that last right that stand
the test of time and for me actually
this is where micro-services started
where I started getting interested in
this it was in response to talking with
quite a few people from different
software communities so that the domain
driven design community the sort of
integration community so people like
Judy to harm people like jimmy neilson
people in this and web integration
community so the rest community in the
messaging community and we sort of got
together as a group as a bunch of people
and so we were talking about systems and
why systems are getting so big but
pretty much we spent three days trying
to understand why we were all building
products that we hadn't then replaced
after a couple of years and for me that
that was the key it's like what is it
about these systems that means of the
applications that we build that the
systems that we're building that means
they don't last more than
more than two to three to four years we
have to throw them away we have to go
back to go back to our management teams
our execs and ask for another 10 million
euros to rebuild something so I'm trying
to think of never done in that in in the
sense of building systems that that last
that stand the test of time so instead
of this different this definition of
them has been incomplete I'm going to
use this definition from a terry
pratchet book the fifth element so terry
pratchet is a british fantasy author he
passed away sadly a couple of months ago
but he's written over 40 books one of
which is the Fifth Element elephant and
in this in this book he describes a
story it's a dwarf with a big long beard
and an axe telling a story about his
family's axe and this is how I kind of
think about its building building
systems these days about building
systems that are never done and he
describes his family's axe right he says
he says this this axe has been in my
family for 900 years this is my family's
axe and to paraphrase of course over
time every part of this axis changed
I've we've replaced the handle we've
replaced the blade of the axe sometimes
we've had a carve some new gifts into
the handle sometimes we've replaced the
handle again sometimes we've replaced
the head again but is this not my
family's axe 900 years later and this is
a retelling of a story where it's an
ancient sort of philosophical thought
experiment the ship of thieve thebes
and the thought experiment there is is
it this if you have a ship that last 300
years and every single piece of that
ship has been replaced over those 300
years at the end of the three hundred
years when there's nothing left of the
original ship is it still the same ship
Terry Pratchett uses this in the my
family's act and I think that's how we
should be thinking about building
systems Chad Fowler I saw him speak
recently he he had a nice phrase he said
boy in Nice ID said we need to reclaim
the word legacy his legacy and IT is
terribly bad connotations
you know legacy is a bad thing legacy
code is is a bad thing
legacy systems are bad things and I'm
charge was saying well what we need to
do is actually look at legacy in a
positive light like Mozart or Bach left
a legacy they left a positive legacy
like we want to leave a legacy to our
our our children we want to leave them
something that's positive not not
negative and so this idea of reclaiming
legacy this idea of building systems
that lasts that span that span decent
length of time but composed of smaller
systems composed of microservices that
can be individually replaced that's what
I mean by building software that's never
done building software that where the
system as a whole the system as a whole
lasts for a period of time a long period
of time but the individual components of
which can be can be changed or are
changed over time Fred if you hear the
talk a minute ago Fred was talking about
one of the reasons we might want to
whoops might want to use microservices
or the reason that people are talking
about microservices Adriane Cockroft and
netflix is very clear in this they want
to use fine-grained service-oriented
architectures because they want to go as
fast as possible we want to go faster
for all the all the reasons we heard
about earlier so you know competitive
competitors startups are taking our
market share needing to get inside our
competitors decision-making cycle to
innovate faster than them we need to be
able to go go as fast as possible and in
theory micro services should on us to do
that as well as being systems that last
they should allow us to make changes
really really quickly and we had
examples earlier of our of an
architectural of an of an implementation
of an microservice architecture which
allows you to do that so this is what I
kind of would hope for from a micro
services based architecture well you
know they should be cheap to replace
over time they should be quick to scale
we should be able to bring stuff up and
bring stuff down and they should be
robust resilient able to withstand
failure
the old line the internet is not a
five-nines fabric has never been more
appropriate and this should allow us to
go as fast as possible so I'm going to
cover quickly some of the same ground
that Fred did not much of it though so
this is a quote from from Neal Ford you
know us answering the question or
attempting to answer the question why
now and Neal's Mill's response to this
question was well it's the first post
DevOps architectural style it's the
first the first attempt we've made as an
industry and post this post of DevOps
movement the DevOps culture developing
the building running culture developing
to develop an architectural style give
up to develop systems differently Dan
North who's another former colleague
like what Fred and many others who have
been involved in this community he's got
a different take on microservices in
fact he hates the name micro-services he
thinks it's a terrible name he prefers
the much less snappy in my opinion but
no less no less valid replaceable
component architecture that's what we're
talking about with microservices
replaceable components architectures
systems that are never done that can be
changed over time dan wolf lost the
naming battle turns out when Martin
Fowler named something it stays named so
sorry Dan and it's interesting because
there's another theme running through
Fred's talk was about how we're learning
how we're we're learning how to build
these these systems composed of of
smaller systems and in some ways the
future is quite scary and I'm just going
to take a moment to explain what I mean
by this future that we're living in or
the feature that we're about to live in
or something being a little scary so
this is a quote from some decades ago
now it's attributed to John von Neumann
a Poland Polish mathematician called
stanislav Stanislaw ulam who worked
closely with newman recorded a
conversation he had where newman talked
to
the concept of a singularity a
technological singularity based on the
fact that computer hardware for example
was getting faster he says ever
accelerating progress and changes in the
mode of human life gives us gives the
appearance of approaching some essential
singularity in the history of the race
beyond which human affairs as we know
them could not continue now I've seen a
single arity with my own eyes and it
happened a couple of years ago this is a
panel at go to our who's and it's
interesting because go to our who's that
year was a couple of two years ago I
think the feedback that was gotten from
the from the people who were attending
the conference was a long a long a theme
of why don't the the speakers tell us
what to do there were lots of conference
talks about about different technologies
and about different techniques things
like microservices but no one had any
concrete answers really to give and this
is kind of this weird singularity where
a lot of the most well-known people in
in in our industry but kind of shrugging
their shoulders a bit and saying we we
don't really know what's going to happen
at the moment there's all these tools
being developed there's all this new
these new practices these new principles
this new styles so one of these I mean
you might recognize this this is from a
few years ago but it was it wondered
where it was probably last year that the
JavaScript singularity happened you
can't walk past a JavaScript developer
without three new MVC libraries falling
out that pocket right JavaScript has
just exploded but also know similarly
containers have it will hopefully not
exploded versus the container technology
and companies developing containers and
different container solutions based
solutions are exploding there's this
kind of weird container similarity and
as mentioned earlier I'm a part of the
thought Wix technology advisory board
and we've put together this TechRadar
and we've noticed another one and the
other one we've noticed is to do with
things like log aggregation so long
aggregation singularity you can't you
can't talk
to someone who in operations or loss of
personnel develops role these days
without them telling you like 15
different log aggregation families you
should be using the ELQ stack no no
we're going to be using log log stash
and key barlen no no no you need to buy
spunk to which the answer is have you
got how much money have you got right
because spunk will essentially suck all
your money out of you so you better be
able to replace it quite quickly but
there's these different singularities
that we're sort of experiencing and as
well as that there's this sort of micro
service singularity occurring so sort of
closer to home for us how we designed
software is definitely changing based on
based on all these different tools being
developed the practices the principles
and as I mentioned a minute ago you know
when Martin names something it stays
names this is our attempt Martin my
attempt to describe the characteristics
of a microscopists architectural style
so we were very clear here we weren't
trying to define what micro services are
we were trying to describe what we were
seeing teams do in the wild we talked
about containerization buy services
organized around business capabilities
and so on and that's great because teams
are having lots and lots of success
right with the micro services style
there are many many software exists and
existence proofs of companies that are
having success with this start from the
big the Netflix's and the Twitter's and
the googles and the eBay's and the
papers etc to the smaller ones to the
startups who are building building out
micro services based architectures but
there are some really hard problems to
solve with microservices the first one I
think is a really hard problem is how
did you do end-to-end testing when
you're building out a micro service
based architectures so this is something
that we have gotten used to over a
period of time and in our industry the
ability to you know to run essentially
product level tests where we we test
from the outside in maybe using a
browser or something or maybe driving an
API and that's gonna test all of our
code or at least test the happy path
maybe your user journeys through our
codebase this kind of automated
end-to-end testing is really valuable
for us to know whether our software is
working or not it gives us feedback as
part of our build cycle really really
useful the next thing is how do we
deploy these things independently how do
we avoid having to deploy lots of small
things in lockstep because the danger of
course when you separate applications
out into many small micro services is
that you go from a monolithic big ball
of mud full of spaghetti code to a
distributed monolith and distributed big
ball of mud where everything is tightly
coupled and you had to deploy everything
together we don't want that we want to
avoid doing things like deploying in lot
lockstep how do we do that and the next
thing is we hit a little about this a
minute ago how do we do service
versioning how do we evolve these these
services independently given that we
want to be deploying them on their own
given that we want or given that it's
difficult to test them end to end yeah
and these are real problems and we're
learning how to solve them I don't think
if anyone tells you they've got the
answer to this that they're that they're
telling you the truth if I'm honest I'm
also a consultant by the way so it
depends is my default response to this
but how do we do this and do we have
approaches and this led me to thinking
about whether we have whether we can
still rely on some of the other tools in
our toolbox I'll talk about that in a
moment
so what do I mean by testing
microservices it is hard so we've got a
couple of services years as a quick
example
I'm from using that the test pyramid so
large tests medium and small small
probably unit testing larger the kind of
end-to-end test your product tests I'm
calling them large not something like
end to end because it's it's a bit like
the VY Emacs battle right if you if you
say end-to-end someone else wants to
call them user journey tests or
acceptance tests or integration tests or
whatever so large tests test that that
test the execute and cover a lot of our
application a lot of our product and in
that sort of scenario we want to write a
test which is going to drive one of our
services and it's going to need to
integrate with another one of our
services so what's so hard about that
well suddenly we have to think about
creating environments to deploy these
things into deploying lots of different
things into it's fine if you've got to
maybe what if you've got a thousand
different services can you write an
end-to-end test that when you commit
some code and code passes through your
build pipeline which will be executed
against the new piece of the new service
and a thousand of its dependencies in
some kind of test environment how do you
actually do that
that's quite tricky and what we've sort
of been talking about really over the
last couple years is not doing that so
actually always testing these things in
isolation as part of the quote
end-to-end testing so doing away in some
ways with integration testing and
integration environment instead using
stubs social stubbing out any external
dependencies in a service another thing
that's quite hard and this is quite a
subtle point is it into this this not
only the testing the end-to-end testing
of these services the product level
testing of these services becoming
difficult but integrating these services
building them independently services
will pass through or total pass through
build pipeline in stages this is
generally
happens when we write software these
days and we're following them Tania's
delivery practices and that's fine when
you've got a big application because you
have a build pipeline and it passes
through it and then gets deployed
potentially automatically into
production that's brilliant it's been
verified it works but suddenly if you've
got ten build pipelines or a hundred
build pipelines and all these services
are talking with one another potentially
how do we make that work but one way the
traditional way would be to fan-in and
deploy these things into an integration
environment we'll deploy them into some
integration testing environment and run
a set of integration tests against it
which is fine if you've got a very small
number of things but when as I say you
end up with lots of these things I'm
having the same problem with with the
clickers as Fred did standing over there
so I'll move back when you've got lots
of these things this becomes almost
geometrically more complicated because
what we're having to do when each one of
these things changes is deploy the
integration environment run some tests
against them for what happens with the
race condition of me committing or
another team committing code to another
one of the services which passes through
its own build pipeline does it go into
the same integration environment what
happens if it over writes a version that
another pipeline is depending on well
maybe we'll have to create another
integration test environment well we'll
have the integration tests for each each
of the individual pipelines is based on
its production dependencies and then
we'll we'll push into that and run some
integration tests against the production
versions what happens about the deadlock
and the race condition rather do we
create another integration environment
per build pipelines so we suddenly have
to with snapshot dependencies and all
the production dependencies suddenly it
starts to get very complicated if you've
got 10 services you're talking it in
using that approach you've got to
integration environments to build
pipeline times the number of services so
that's you know it's kind of complicated
so maybe these are examples of some of
the practices that we've been following
as part of you using XP the XP practices
and things that aren't necessarily
longer that that valid and I'll talk
about some approaches to addressing this
later on but as I say I was thinking
about then the other practices we've
come to rely on and yeah I work for
thought works as as has been mentioned
and whilst we're a agile small a shop so
we don't we don't really say well you
know we're we're a scrum shop or
whatever but the thing I think we
probably all would agree on is that were
we're an extreme programming shop we've
had program on pretty much on everything
we're yeah we used tests written
development we design our code through
tests we follow a load of the principles
that you might expect from from XP and
from things like software craftsmanship
clean code formatting programmer so
emergent design and Gang of Four design
patterns keep it simple stupid the grasp
patterns these are all tools that have
been in our toolkit for a quite a long
period of time like things like
integration testing like things like
integration environments are these still
valid when we're building systems
composers of small micro services that's
what I was thinking I was chatting with
a with a friend over in the States guy
called Russ Olson who's an awesome dude
he did a fantastic talk at skew Khan
London I think it was it was called to
the moon and it was about him remember
his him remembering the the Apollo moon
landings and what we as engineers can
take from the Apollo moon landings and
the engineering that went into them
fantastic fantastic he wrote and I'd
recommend looking it up to the moon but
Russ Russ told me this other story about
about NASA and about the early stages of
our you know about manned space
exploration and he tell me about this
this thing this is the JIT this is part
of the Gemini project and with the
Gemini project they initially wanted to
land it on a runway using a hang glider
right that might sound a bit strange but
if you think back to the yeah I guess
early 60s NASA was composed of a bunch
of people who were essentially
aeronautical engineers and pilots so
that's what the Masen was made up of and
when they were tasked with designing a
space ship that was gonna essentially go
into space be launched into space over
the earth and then land back again
there's a as a test essentially for the
Apollo program going to the moon the
aeronautical engineer and the pilots
reverted to what they what they kind of
knew best and that was landing planes on
runways they were kind of in this very
closed environment and this this kind of
made sense to them based on their
experiences and then something funny
happened and that was a program manager
came from externally to the group and he
took a look at their plans actually this
this kind of did work by the way this
did land the Gemini capsule was able to
go to space and land on a using a hang
glider
but this project manager kind of took a
look at this program manager took a look
at this and he said well he basically
said are you insane um these sort of
come in from outside and eat some this
is a crazy kind of approach to solving
these problems what you want to be doing
because it's much easier much cheaper
and much safer for everyone involved is
to basically strap a couple of big
parachutes on the top and drop drop it
into the sea and then we'll we'll
collect it and that's what ended up
happening that's what ended up happening
with with Apollo as well so I was
thinking about this this idea of someone
externally coming in and looking at
looking at our practices and their ISM
and also this idea of chunking up levels
of abstraction so we've got micro
services we've got all the practices we
understand about how to write clean code
how to write you know well designed well
blah design say of your oriented code
well what does that look like in the
context of chunking up to the level of
micro services and micro services based
architectures how to think about that
and that's what the rest of this is
about and what I thought was essentially
it's Turtles all the way down it's
Turtles all the way from objects
functions all the way up to systems of
systems and so I'm going to explain
maybe my reasoning and maybe explain why
some of the things we've come to rely on
in my opinion after thinking a bit about
this are still valid
so the first thing I want to talk about
is out of this big group of big group of
techniques I won't cover them all I
might talk about world of warcraft at
the end if people really want me to and
the first thing I'm going to talk about
is the agony so now the hands up in the
room for people who have come across the
agony you aren't going to need it
alright this is a fairly common
principle by which you know people
especially extreme programmers agile
agile developers kind of approached the
idea of of writing code I mean for media
acnes is actually about test-driven
development more than anything so I
learned about the yagna principle from a
few colleagues where you know if you're
test-driving your code even even a even
a variable created that isn't needed by
your tests is essentially the agony you
know you aren't going to need it get rid
of it it's waste and Martin Fowler has
recently described this in her in an
article and it describes this three four
types of waste that you get with the
acting right so the important one from
my example that introducing an extra
variable even even if you don't think
that's like a big deal in your code it
actually increases the cost of carry of
your code base it increases the amount
of stuff you have by definition and
overtime that stuff accrues unless you
fix your broken windows it will crew in
a crew and a crew and you end up with
calamity so we actually like code was
thinking does the acne apply when we're
building out microservices applications
I I think it does I think it definitely
does in the sense that what we want to
be doing when we're building
microservices is not building stuff out
ahead of time that we
need and this might be obvious but you'd
be surprised at the number of ivory
tower types who've moved into building
micro-services who say right what we're
going to do now is design all of our
micro services right now often do it in
my opinion that's not gonna work the
approach I think we should still take is
that you aren't going to need it build
out things when you need it
when you need them only when you need
them so initially build out one service
and then when you need to build out
another one maybe the code base is too
complex
maybe maybe for other factors may be
non-functional factors build out without
the next service that's I think this
answer and almost to the idea of do we
start with the monolith or not but
crucially the Agni is applies to micro
services architectures is all about
building things out when you need them
not designing up front again so for me
that kind of still holds this is this is
a set of patterns that seems to have
fallen out of general not use because
people still recognize the importance
but of people's collective memory hands
up if you've come across grasp yeah it's
kind of interesting so this is well I
first started getting interested in sort
of design the Gang of Four and all these
things I was introduced to grasp and
it's the stands from the general
responsibility assignment in software
patterns pretty sure about that right
and they were developed by a guy called
Craig lahrman who became I guess more
well known later on for writing books
about agile management techniques as all
software development and management
managing as all software projects but
from grasp we get a couple of really
really well-known and kind of obvious
patterns that are PI at the level of
micro services I'm gonna illustrate this
was with an example so I was at a client
of ours last year last summer
and they were an interesting place
because they've been building one set of
services out in India and one set of
services in the UK I had a big team in
India a big team in the UK and meet them
either by luck or boring a happy chance
each of these different locations were
building out a particular capability
right so in India it was building one
thing a very discrete thing and in
London they were building another
discrete thing there were kind of a
travel company they sell tickets for
things so one place was building the bit
this well you could buy tickets as a
customer and the other bit was building
the bit where you got send the ticket
right essentially retail fulfilment
there's other more complicated stuff in
the middle as well but yeah that's
pretty much it we tell and fulfilment
and the really nice thing about this and
I think maybe the obvious thing that
happens and again whether by luck or
judgment or some other Samar's or
something else they'd ended up with this
solution where they had a big thing in
London and a big thing in India with a
bus in the middle and they were passing
messages across between the two
incidentally Simon Brown if you know him
hates my architecture diagrams and this
is an example actually of two patterns
from grasp so grass talked about in an
ideal world we want to have highly
adhesive software and loosely coupled
software and these two independent
capabilities were extremely loosely
coupled by this bus in the middle and
the message passing it kind of worked
out really really well the two two teams
could operate independently deploy test
independently and so on so absolutely I
think when we're building micro services
based architectures we want to be
looking for high cohesion and low
coupling and I think historically we've
done a bad job especially at cohesion
because what we've tended to do is focus
on cohesion around technical concerns so
we will be cohesive about separate
concerns and be he's of about
presentation and
systems say and so we'll put all the
presentation stuff in one place and all
the persistence stuff in another place
which is kind of cohesive I'm I'm
technical concerns but that leads to
kind of very tight coupling between
business concerns so in this example
what we're being is cohesive around the
business concerns the business
capabilities the actual functional stuff
that that this thing has to do rather
than the technical organization of it
that's the next thing the next thing I'm
going to talk about is dry so this came
up as a question in the last and at the
end of the last talk about Fred's talk
so don't repeat yourself dry and this is
this often comes up should we allow
duplication between services or schwöre
should we maybe extract some common code
extract some common domain libraries and
so that we share code between services
and so my simple answer is you shouldn't
extract common code unless it's very
very basic infrastructure type code I
explain why so this is the definition of
dry this is from prag Dave I believe if
he's in the room I'm not sure every
piece of knowledge must have a single
unambiguous authoritative representation
within a system
I was thinking does this this is still
hold true again for micro services
you've heard my answer already but I
explain my reasoning so if we've got two
services and we've got some shared code
indicated by the star in this diagram or
common there may be duplication across
these things the temptation is to
extract that star and say you know what
reuse we'll put it into some jar file
somewhere or some shared dll we'll stick
it in new get these days we'll stick it
in in our maven repo and I'm at
artifactory repository and then you know
whatever needs it can pull it down and
they can include it at compile time and
then they can be deployed it can be
deployed
but the problem with this is anytime you
introduce shared binary dependencies
between between people between different
services you completely lock their train
cycles together and if you I mean if
you've ever used wisdom binding for me
on the SS deathstar kind of stack never
ever use wisdom binding that's where you
generate stubs at you generate stubs as
a pre-processing step and then include
those stubs in your in your application
and use those stubs to make calls across
the network if you've ever used that
you've probably seen the problems with
it which is every time one of those
services one of those API is change
suddenly every single one of your
clients is going to recompile and
redeploy and this is why we don't
or rather my myself and my colleagues at
full wigs don't tend to favor using
something like wisdom binding but
extracting extracting shared domain code
gives you exactly the same problem
suddenly you're locking you'll change
cycles of your software together and if
you've got hundreds of microservices and
maybe they all share something common
called a customer you really don't want
to have to be deploying redeploying a
hundred things every time your customer
gets a new field kind of sucks there are
different approaches to addressing this
right I mentioned that for example I'm
personally okay with extracting out
things like shared like shared
infrastructure codes if you've got a
HTTP client that's probably okay to put
into a new get package somewhere go into
a jar file if you look at all the
Netflix open source too late yeah that's
all very specifically generic things
like circuit breaker implementation
bulbhead implementations monitoring
these sorts of things I'm fine with that
there's another approach which is to use
something called a service template so a
lot of the tooling now so things like
spring boot or drop wizard go some way
towards providing a template you can use
to build out services and there are
others in other languages but those are
the ones I'm most familiar with but what
they don't do is give you the
domain-specific stuff on that that you
require in your organization on top
so good practice we found is to extract
a service template which contains maybe
yeah the way we do login here the way we
do monarch monitoring the way we do
status pages put that in a shared
location and then when you need to
create a new service you can just clone
it less and get for example two service
templates and the reason another one of
the reasons that this is a good idea is
because essentially if we're not sharing
the main code or even if we are sharing
the main code each of our services over
time is going to change is going to
become is going to go through its own
set of individual changes they're going
to diverge from your service template
essentially they're going to go through
different trousers on all of bifurcating
traces of reality and so this is why
essentially I've come to this conclusion
which is the same one that Fred had
which is essentially copy and paste is
okay right
copy and paste is fine but I still think
we should be dry within services so
within the individual micro services I
think we should still apply at the same
set of practices to remove duplication
so keep the code clean next up so
there's been quite a lot of controversy
about test-driven development recently
should we do it should we do it at all
is it just waste is it just waste I have
my own opinions on this and they don't
always correspond with some of our other
well-known with other well-known people
in the UM in here in our industry so
test run develop in using test-driven
development as a tool for design
primarily before I'm not entirely sure I
don't know certainly over a decade and I
was very lucky because I actually learnt
how to write code guided by tests by a
bunch of people I work with that thought
works well I joined about 10 years ago
11 years ago um and as part of learning
how to write code guided by tests I
noticed a really funny thing which was
the code I wrote
ended up looking a certain way my people
have noticed this if you follow the test
I write a test Watson come here provide
some code refactor red green refactor
cycle but your code ends up looking a
certain way in object-oriented languages
you end up with small objects generally
with small numbers of responsibilities
you tend to inject things through
constructors dependencies through
constructors code looks simple and
understandable and over time sometimes I
don't use test-driven development
exclusively I'm going to be honest
sometimes I just think patch things you
know what I'm gonna I'm kind of I
understand this problem well enough I'll
have a test around the outside that that
verifies that my software is working
although these units of software are
working and I'll carry on writing some
code but in general over the last 10 11
years whatever it is the way I write
code has been guided by learning how to
do TDD why do I think then test-driven
development apart from the fact that it
I think it drives clean code why do I
think that this is important for micro
services well we've already talked a
minute ago at the beginning about how
end-to-end testing becomes really really
hard right so writing lots of these
large tests becomes really really
difficult
I see waiting for me writing more unit
tests then isolating these services and
writing unit tests for the functionality
within them for the code within them
becomes more important in that case
if you haven't read this book it's
fantastic burgers mike feathers
describes growing object-oriented
software guided by tests by an app price
and Steve Freeman as as the London
School of test-driven development both
of both of the authors were at full wigs
London when I joined I spent some time
met them obviously in some time with
them never actually worked on a project
with them but this book describes how
for which London or the people working
within for which London really think
about about writing or writing test
driven code and how to design your
software by writing tests first
so it wanted to answer this question or
maybe a slightly different question
should we bother with test driving our
code if we're just gonna throw things
away right well building replaceable
micro services micro services that we
can throw away building system building
software that's never done should we
bother with it in my opinion I think we
should because the value I personally
get or I and I see our teams getting
from writing tests special unit tests
and test driving their code and the
importance of having more smaller tests
with micro services for me mean I
believe we should be and I'm just going
to maybe cover off some of the
controversies these are the some of the
people I was fortunate enough to work
with in thought which London so a lot of
these people have become fairly
well-known either in the testing
community the design community the
architecture communities so for example
in that price and Steve Freeman wrote
that book down north
you know originator of BVD liske here
she's got a past award from the agile
DeAngelis a bunch of others and over
time their opinions about TDD have
changed over time a lot of well-known
figures in our industry's opinions about
QP have changed my feeling as I said is
that test driving our code is still very
very valuable and I'd like to have maybe
terrify the way I think about how maybe
some other people talk about TDD
this is something called the Dreyfus
model of skill acquisition I've been in
software for I don't know whatever is 15
not yeah 15 years 16 years I'm not quite
a graybeard cuz that's 20 years but I do
have a gray beard if that helps so I've
been writing software for a little while
and in some areas of software
development I consider myself an expert
on the Dreyfus scale for fishing or an
expert
probably proficient or expert in
test-driven development anyway and a lot
of the people who I just mentioned are
also experts in test-driven development
they've learned the lessons and they're
starting to move on their stuff and
they've internalized what they've
learned around how to write write code
guided by tests I guess the reason I'm
mentioning this is think carefully
before taking the advice that with
micro-services suddenly we shouldn't
write any wish we shouldn't test drive
our pound anymore because a lot of
people give an advice although valid
advice for for them and for the work
they do they're coming from a position
of expertise having learned the lessons
they already write code in a certain way
because they've they've learned how to
do that through writing code test first
so to sum up summarize should be write
unit tests personally I think we should
and I think it's more important than
ever we need to keep to that test
pyramid with lots of small tests at the
bottom the next thing is SRP single
responsibility principle and objects
should have a single reason to change
was the original statement so my
colleague who's now in the former
colonies now at near 4j Alastair Jones
my software on a team and we came up
with this heuristic essentially it's a
restatement of SRP and it's a class
should be no bigger than my head and
this is this is allister's head this is
an ear actually at near and their
offices in London so this is allister's
head and he's checking whether a class
is big enough or too big rather and I
think on the tweet they decided it was
fine but what do we mean by no bigger
than a head and how does that apply to
micro services well for me
send its Turtles all the way up I think
it is as you chunk up different levels
of abstraction for me the single
responsibility principle applies the
other state near the other way of
looking at them no bigger than my head
thing is I should be able to understand
everything about an object all right I
should be able to consciously actually
be able to reason about exactly what all
object is doing should have a single
responsibility single reason to change
and as you chunk up from the level of an
object into say service that should have
a single responsibility and as you chunk
up again to the level of maybe a set of
services that our team owns that should
have a single responsibility single
reason to change as you chunk up again
to the level of a system of systems
single responsibility and and each level
of abstraction you should be able to fit
this stuff into your head obviously I
can't hold my head up to a monitor and
check whether Netflix fits the entire
distributed architecture of Netflix is
as big as my head but conceptually
that's the case so SRP a service should
be no bigger than my head the next one
kiss hands up kiss keep it simple stupid
what keep it simple if we're being nice
so this is something from the last
edition of our technology radar at
ThoughtWorks and this is this is where
we put application servers on hold now
this might this is a bit scary too many
people bit scary to ops teams but we
were just trying to call out essentially
that times have changed we no longer
need to use big big iron application
servers we no longer need to deploy
micro services lots of them into a big
application server I'm afraid for those
people who are currently on the WebLogic
team it's not looking so great and the
interesting thing is it's because if you
think about it but times have changed
right we've gone from having one
expensive big machine so that we would
put a application server which would
manage lots and lots of small of
applications on it to having lots and
lots of small machines alright this is
the movement towards you know aid off
the container movement or a single
service per machine image a single
server
for instance on on the honor
infrastructure-as-a-service we don't
need the heavyweight application servers
in that world they just get in the way
of testing they make they slows testing
down
they make continuous delivery harder
they make my job is to develop again
trying to get code out fast harder
application servers on hold when I think
about kiss this goes through my head
WWJD and that probably doesn't make
sense but it means what would Joe do so
this is Joe warms who I worked with for
for a time in full ways and he is by far
the most productive developer I've ever
met I'm not a big fan of the now they're
kind of 10 times productivity thing but
Joe on his own is about equivalent to a
team of about 10 people so maybe there's
some truth in it and when I think about
what would what Joe would do what Joe
would do is the simplest possible thing
he would keep things really really
simple if he's faced with a problem he
solves it in a very very elegant simple
way an example of that is he was on a
project he wanted he needed to our he
needed to communicate by WebSockets with
a client and browser and he was looking
around all of the different WebSocket
support in the different app servers out
there he's kind of big things he's
thought now I'm not gonna do that and so
what he did instead is he broke his own
he wrote his own application server now
that sounds crazy all right it sounds
crazy that we might go out and and write
our own application server but actually
sometimes doing things like that is the
simplest thing that can possibly work
keeping it simple and I'm gonna give you
another example of this from a project I
was on so we were building out my
receiver's architectures for a science
publishing site and we had the
requirement to to try and visualize our
infrastructure we were deploying into
AWS and we wanted to visualize our
infrastructures we had couple of options
one of which was to wait until some of
the heavy tool providers were able to
support immutable servers and kind of
append-only infrastructure this is where
servers ago
a up and down all the time and lots of
the big big software houses don't
support Battlestar yet we kid to deploy
something like console but in order to
production hardening console you're
talking about you know five node rings
it's quite it's quite complicated to get
that and in the meantime until we got
there we didn't really understand what
was running in production and so two
days Mina mate came up with this
visualization so this is our production
infrastructure doing a Bluegreen deploy
if you can see that and we use cron and
Python and Bato and PI dot and graph is
and this worked right this was the
simplest thing that we could do to
visualize our infrastructure such that
you know our our testers understood well
what versions were running that the
developers could look at the screen and
see all right okay the DNS endpoint has
switched over the simplest thing that
could possibly work and then eventually
we put console in and we've got all the
nice dashboards and things so it does
keep it simple mean much in this sense I
think it still applies I think it still
applies in this sense it's always
applied which is try and find the
simplest solution that we possibly can
don't lean towards very big heavyweight
solutions do the simplest thing possible
so quickly because I've got two minutes
left I'm going to talk about integration
and deployment so I covered those off at
the start so if we are in this world
where integration testing that all these
other practices are kind of still valid
what about this kind of integration
testing integration environments problem
that don't seem to do that to be valid
are there other tools we can put into
our tool box I think there are so the
first thing we can add in is this idea
of semantic monitoring so semantic
monitoring is where in production we run
things that would be normally things
like user journey tests or acceptance
tests against our production
infrastructure so we do testing if you
like in production this is not so
different from the idea of smoke testing
it's just slightly more it's a slightly
more disciplined approach there's a big
description
of it on the bulwarks radar science if
they have a look that's the first thing
the next thing I think we can do I think
there'll be some talk talking about this
later is we can try and get feedback for
when we break things earlier animations
broken earlier you know you know you
know you know feedback cycles so we can
deploy our software into production and
see if it breaks that's one approach and
semantic monitoring will tell us if it
does buy another thing we want to might
want to do is developers is understand a
bit bit earlier and so we can write
executable contracts for our services
and give them to the people who write
the services and these are called
consumer driven contracts and these can
be executed as pal of our build cycle so
we buy consumer driven contracts hand
them over to our to the providers of
services and then when they run their
build if if behavior has changed the
build breaks sorry to get a bit meta I'm
gonna deliberately run over time by a
couple of minutes it's a reason being we
don't want to completely flood the lunch
queues I was asked to do that anyway
back to consumer driven contracts it's
quite simply what you do is you write a
set of expectations as a consumer of a
service all right it's an executable
format and you include it as part of the
build of the services build pipeline
simple idea but actually fairly it was
revolutionary ten years ago um it hasn't
really been adopted until maybe this
year last year and now there's tooling
available to do this certainly in Ruby
synthesis pact which is available on
github is an open source tool so the
next thing is testing in production I
mentioned it briefly what do I mean by
testing in production well rather than
hue aying as part of a like a formal UAT
stage before you we deploy our software
all fanning into an integration
environment we actually push our
software straight into production and
test there all right if we've got really
good monitoring so we know things aren't
gonna break this is a kind of valid
approach if we've got that semantic
monitoring if we've got from sumer
different contracts
place so we minimize the number of
breaking changes that get there this is
gonna work so what this relies on though
of course is been able to save our QA is
our product managers or product owners
are able to are able to log in and how
sorry are able to we are able to
distinguish who they are so that they
can test in production so am I really
saying we're gonna do away with
integration environments I think a lot
of companies who are building micro
service architectures already have I
think it as you get more of these things
I think it's inevitable I think that's
just the way you have to go um
that's scary I'm sorry just the way it
is but this is something that maybe
helps deal with the pain this is a real
realization I had again it's going back
to what we did in your region to have
maybe two data centers and we've we have
an active and a passive we'd have some
software software running them one and
then we'd upgrade the other one yeah
one was live and one was at warmers one
was not these days with elastic
infrastructure when we're deploying
things into infrastructure as the
service providers there is no real sorry
there is a difference between deploying
into your production environment so
sandy understanding something out that's
on that's out there that's on the web
and they're actually being used by
people there's a difference between
being live getting live traffic and
actually being in production so you can
actually deploy as many versions of
things as you want into your last rack
infrastructure but unless actually uses
a using it it's not live so this makes
the idea of getting doing away with
integration environments a bit less
scary right
because we can just deploy in the
production we can allow our product
owners product managers business folk QA
s to test things in production and then
we can make it live by directing traffic
and this is you know ways of doing this
including this is canary builds blue
green deploys and it's right into a/b
testing so
finally changing services independently
well this is something I sort of learned
from talking with a few people in
Adrienne Cockcroft in particular if
we're going to make a change to a
service commit some code it's going to
go through into production
one of things we have to think about is
what is the blast radius of that change
right who is that change gonna impact
what other services will that change
impact and I think there's almost like
three levels here the first level is
whether the change is limited within
your team whether anyone outside of your
team is going to be affected because if
it's that if it's not gonna expand in
the blast radius the blast isn't gonna
expand past your team then probably you
can handle versioning and change just by
talking to people I'm gonna change this
you have to change your thing now is
that okay yeah fine
off we go the next thing is is it
limited within a banded context or sorry
between bounded context if it is then
you might want to think about
consumer-driven contracts and maybe
semantic versioning these sort of sorts
of techniques and the third thing is
organizational so if your Google you
don't want to be changing the Maps API
very often because the blast radius of
that is well it's kind of Western
civilization as we know it right
and the reason I was thinking about this
is this book by Thomas Allen they talked
about in this he talks about how
information flows around in
organizations and it's interesting
because after about 15 meters or 10
meters away from someone the
probabilities of interacting of having
serendipitous conversations is
practically zero why is this important
well you want to limit the change you
want to apply different techniques the
further away you are from someone and
this is again where commas law kicks in
so for intercompany integration maybe
you're thinking about patterns like
semantic versioning but whether when
you're talking about change within an
organization between teams say your plot
applying different different types of
things so semantic versioning maybe
contract testing tolerant readers
and then within teams maybe we're
talking about conversational change so
I'll change this can you change your
thing it's a summer the futures scary
right we don't know how to do a lot of
this stuff yet to paraphrase Auto sorry
to reiterate what fred was saying but at
the same time a lot of the stuff we know
how to do already still applies I think
when we're building micro services so
that's kind of a cool thing and also
there's a lot of new cool stuff that we
can do right and there's a lot of new
stuff to learn and frankly one of the
reasons I'm in software is because I
love learning new stuff so in summary do
the simplest possible thing thanks very
much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>