<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2013 • Treating Legacy System in Practice • Eberhard Wolff | Coder Coacher - Coaching Coders</title><meta content="GOTO 2013 • Treating Legacy System in Practice • Eberhard Wolff - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2013 • Treating Legacy System in Practice • Eberhard Wolff</b></h2><h5 class="post__date">2013-09-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TOA715ljyhk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">for showing up so i will be talking
about how to 3d systems and practice let
me first spent fuel rods for myself so i
think 10 to 12 manager for addition we
are on the couch a certain authorities
in the Germans move region I'm speakers
of being edged so good conferences and
some other conferences offer and for
John magazine and other applications I
live blog banando and will be most
important the link to my pizza side
which is a software that i'm using for
presentation here angeles my
presentation on that side later on my
property let's say by friday the latest
so you don't
notes if you why talk about VGC systems
well I found a good quote that goes like
this it's easy to write to the programs
and that's very enjoyable but writing
got skill software's always miserable so
quite nice it's by this guy is famous
for inventing virtual reality so I guess
he knows what he's talking about so
let's see how we can deal with BBC
systems I think there are three
perspectives that you need to have in
mind we should talk about them first of
all there is the management perspective
then it's about architecture and
development skills and this is basically
what i'm going to talk about in this
presentation so let's start off by
talking about the management perspective
of the rule theta there is this nice
metaphor around technical depth that you
might be familiar with and basically
what this says is if you do compromise
on quality you will get reduced
productivity and the idea of this
metaphors to say well the dead is the
amount of work that you would
to invest to refactor your code base to
really clean your face and there's some
interest rate that you have to pay and
that's the reduced productivity so
unless you do the investment for
refactoring to a clean code base you
will need to pay the interest rate and
that is the idea around this technical
depth metaphor now one of the more
interesting questions is how do you
actually deal with this metaphor or with
with technical debt down and the
ideological today is to have a metaphor
to make it easier to talk to business
people arrived about it because business
people are used to think in a financial
terms so that might be something that
they can relate the first obvious
attempt to work with I think adapt is
it's actually stolen from these people
program community is to just well never
let any technical depth saved it I think
that's not the best idea the reason is
that trying to achieve the highest
quality possible-- is not realistic if
you think about it we do have a team
with several different people that are
more or less experienced so depending on
who works of what you will have
different quality then what you might
end up with is that you just try to
improve the quality the court and you
never get wrong to actually do any kind
of real implementation or this is what i
mean by death by refactoring so you just
keep on refactoring
wrong to do it any sensible well then
there is a crusher on pay off so if you
actually do have a clear in clean code
base and the high quality it is not the
goal by itself so the reason why you
want to have this quality is because you
want to be more productive so the
question is do you really get this
payoff an obvious example is if you have
some piece of code that is never going
to be touched again the question is do
you need quality under and then the last
point against it this is just practical
experience in a lot of cases there's
just no time and it's hard to actually
get around and do this discreetly so it
is the heaven that you have to have as a
developer but in some cases there is
just not people do not take the time to
wear pins and that is why I believe this
is not the best idea wrong there are
some ways to deal with that so there is
an article on
they have ripped together with spend one
actually of trifle nowadays and and that
talks about how to deal with taking them
so it talks a lot about different
approaches set some time apart to work
on the technical debt and to deal with
this and so on and so on so i will be
talking about this in a lot of detail if
you are interested in that you can take
a look effective for GRT as i said
technical depth is basically a metaphor
to talk to management about the problems
that you have new hobbies so let's take
that to the test also here's our team
here is the managers you can obviously
see em and the team doesn't mention and
says well you know this is our project
so we suggest some numbers from the
sonic qube installation of their in the
net and so r cube has the nice it gives
you a lot of different metrics quality
metrics and so on and this might be an
indication about the technique the depth
that you might have on your system or
not actually there is a technical debt
plugin so i've made out some numbers
using this plugin and what it says here
is well you know you run how can your
dollars have taken to them it's going to
take us about two hundred mandates to
get rid of the technical depth there
2008 sorry my problems with numbers that
notch and if you look at the technical
depth it's actually primarily code
applications then there are some
violations to coding rules there is some
over complex code test coverage
break so this is where we need to
improve our code base and note that you
can fine-tune little things who you can
have a different day rage you can have
different weights for the different
parts of yard and taking a dip these are
just some numbing to some numbers I
think what what is weird here is that it
actually says that half of the problem
half though Chopra technically dead this
application so it seems to be a somewhat
strange project or so and she set up
some instance so what happens now is
that in my opinion is that the mantra
basically says well what is that
supposed to mean so in order to get a
clean code base I need to do a
substantial investment a lot of money
actually what the team does to me is
that our code base is more or less crap
which is not that great so you might be
really unhappy and it's not entirely
clear what to do about the whole thing
because obvious the manager might just
not have the budget to invest in the
technical quality so what happens is
that also the team's somewhat frustrated
because they don't need to live people
come around to deal with the quantity so
they still need to work with this
inferior code base in Egypt week it and
work on it so this is frustrating a lot
of effort is spent on well frustrating
jobs and so on so at the end and what is
really happy I think the problem here is
that you really need to think about
which technically
should be paid back and I might I even
think that the tongue depth is probably
not the way to think about it I don't
want to think about the soothing in
terms of an investment what you're
actually doing is you are improving the
quality of your code base in order to
get better productivity out of your
system in the long run so let's try to
work with this metaphor around quality
investment for the same if you talk
about an investment we can also talk
about which are anonymous so if i invest
one day to work on the quality of my
project it might save me a certain
amount of money and that might be to the
decision to do it one of you depending
on how large the term investments and it
turns out that there are a few that
there is some research on that field
rightly some foundation around it so for
example there is the way of quality
model that talks about the remediation
of so the remediation cost is the cost
if you have to invest to fix some
problem so for example if i reduce the
complexity of this piece of code it'll
take me one day that might be the
remediation cost of fixing that
then there is the non remediation costs
that's the cost that I have to pay the
continuum of the code base as it is so
if I continue with this global context
code base implementing the next few
features might cost me an additional
three days four days whatever even
though the square model includes this
idea on non remediation costs it doesn't
go the next step which to me seemed
somewhat obvious because you can
actually calculate a profit so if I
continue working with this code faced
with in its current state as the non
remediation process that save four days
to fix the problem it's one day the
difference is three days and that's the
problem so if i decide to increase the
quality of our code base i will gain
three days and therefore the profit and
you can ejaculate return on investment
so if i get these three days as profit i
can write / the one day that i need to
invest to get this better quality and i
get in this case remember to send return
on investments
because I miss one day in quality I have
three days less effort in continuum of
the project and you can do a lot of nice
things now so what you can do is you can
break down the remediation on your
radiation across to each quality
requirement so quality requirement might
be the test coverage cyclomatic
complexity in your code whatever that
would be one of those requirements this
is stuff that Sonic Youth gives you you
can break it down fight fighting by
artifact whatever and you can wait if I
sighs so obviously if you have a large
pile a lot of them fixing the problem
might take longer more time than and
smaller so basically unity had some
means just to make well in order to
reduce the sacrament complexity in one
line of code this will take me that long
the non remediation costs depends on the
change probability so if there is some
code that won't be changed well
obviously I won't touch it so there is
no cost associated with them because
it's not going to be a touch what if it
is something that is certainly in touch
on the next iteration I have a high on
litigation because I have lower
productivity in working with this
critically
code and this this is basically the
nominations you can calculate the change
profitability from the channel so you
can go to your versioning system and see
what has been changed in the past
probably that is used for if no
additional features are added if no
edition features are added you manually
estimate which parts of the system will
be touched with which probabilities so
if the new requirement comes in and this
requirement goes to into the customer
their money for example then there is a
high change of ability and the customer
module and therefore iron on remediation
costs for any problem set there are in
the customer module so this is basically
the idea and if you put it if you use
this what happens is that the team tells
the manager something like this so what
we really want to do is we want to
increase the test coverage in customer
module to eighty percent this is a
quality requirement that I spoke this
will take us one day in the next
iteration there are some requirements
and these requirements mean that we will
change the customer module because what
information on TCP
need to be added so therefore we
estimate that the non remediation costs
will be three days so the profit would
be two days if we fix the problem the MS
one day but we don't have the
normalization constant three days we say
it one day and because we invest one day
to fix the problem and we save two days
we get a return on investment of trying
two percent this translates to dollars
or euros for that matter and isn't
easily communicate about so what happens
now is that the mansion realizes that he
is ready to make some dollars so that's
great and well basically tells the the
team that they should go ahead and do it
and the team is happy because they can
actually work on improve quality and
have the time said apartment dropped it
and it is a sensible house it's not just
quality for the toilet saying of quality
this quality to increase productivity
for the next iteration and the manager
is obvious you also have because he is
making some dollars and usually men
so yeah this is an STD idea and we have
done representation of that so sort of
proof of concept it's out there is open
source if you're interested take a look
it's based on sonar you and I actually
do have the graphic user interface here
so we can take a look at it in more
detail so on the left there are the
different modules so there is a lot of
imitation module the color tells you
which module you should get one so the
rather the color the more you should
work on it here because the change
probability is higher so if you look at
the bottom the color translates to the
change for the team and the size of the
elements translates to the return on
investment so it seems that you should
invest in the web module here because
there's probably going to be changed and
those higher return on investment to be
gained here here are the change
probabilities so in this case they have
been taken from the versioning system so
it is likely that both will be changed
or validation is slightly more likely to
be changed from this sort of data one
question that you might ask is so let's
say we have eight hours 16 hours
whatever that we want to invest in
increasing the quality so that's a
common pattern that you would apply to
use
you with quality and the questions where
should investors and this graph is meant
to answer that question so what it says
here is if you look if you just have one
hour you should really invest it in the
bed module because you get a return on
investment they are both forty five
percent and you can do some of the
things for all the other therefore if
you have not time and you can also
advocate have a specific calculation for
a certain amount of times for what it
says here is if you have seven and a
half hours you should work and then
control it up and you should increase
the code coverage and you should deal
with the lack of cohesion of methods and
data plus and then you have some
deterrence so that's the idea and we are
eager to get some some feedback from you
guys what you think about it whether
it's it's a sensible approach and just
take it as I said it's in its early
stages but I think it's very good
approach to think about quality and
tortured to managers so this is the part
about management next part is about
architecture so let's take a look at the
ikea chop heart now i need to talk about
what software it really is and as I'm
and in for perks office today I need to
take a definition by the marching
obviously and what he said is that so
far picture are those decisions in your
system that are hard to change so it's
me the stuff that set
build in your system which is a nice
definition there is a different
definition let us know from wikipedia
it's a good presenter you have to have
something from your pto so also take
that box now and what the pedia says is
if you look at your software system the
software system is a set of structures
that you need to be surrounded it's
about the software demands the relations
between them the properties that is
actually how I think about surprised
engines all about breaking your system
into smaller it says the reason why you
do that is because it's easier to reason
about smaller pieces because there's
just so much that you can keep in your
head and if large pieces it's quite
likely that you won't be able to squeeze
them into your head so you break it down
into smaller pieces we find the
relationships between them and that is
so frightened um and the question is how
does that influence our legacy systems
but if you look at a good software
picture i think what unique AF is you
need to have smaller parts that are easy
to understand so they should be so large
that they fit into your head and that
you can think about them you shouldn't
have too many dependencies and in
particular you should never inside the
dependencies the problem around cyclic
dependencies is if you have hearts and
they depend on each other a change in
one part
the other so effectively those two parts
are stuck together and not separated
this is a problem because they were
originally meant to be separated however
because of the cyclic dependencies they
are now moving together and cannot be
changed Emily so there is actually a
real issue in your system as originally
and the parts should be separated that
is what what you wrote was in heaven
needs to go now why is that important
because if you have no cyclic
dependencies and if you don't have too
many dependencies it's easier to think
about the consequences of exchanging so
you change some part somewhere and there
are some consequences but they only go
to those pieces that depend on the
peacekeepers change
so those two points basically means that
we would subtract it Chad wants you to
change your code and it also makes the
code easy maintainable because it's
easier to understand it and it is also
easier to see how a change of one part
of your system but it learns the system
involved so if you take the definition
by marty and this it basically says well
you know what if you have a bed
architecture you won't be able to change
it and you're basically it's good so
that's not too great and the question is
whether you can do something about it
and one thing that I found quite
interesting or useful in that regard
yeah it's a true that I want to talk
about for for a second Claude structure
mammalian studio it's actually true it
is somewhat successful so it is one it
needs two awards and the reason why I
want to talk about it is because I found
it very useful first of all and to get
an idea about what the code structure of
the system at hand is what the ice cream
cheese and place him to change the IT
tech chure and to sort of deal with the
problems that you might have such as
psychic nine seasons so this is what
this is real side let's go into the DJ
details here first of all there is is
manager compatible piece of the system
that says whether the system is great on
it's great and if the system is red it's
not so great and if the system is great
then it's green and you can easily
change it there are true there are two
dimensions here so first of all there is
Pat Fed says that individual parts of
your systems are too large or too
complex and then there are tangles
tangles are cyclic dependences so the
system that we have here has this ever
rather large parts as well as parts that
are tangled and a part of your second
dependency and therefore how to change
down here it says where the thing that's
on and if you switch over to the other
tab you can see the fat items the car of
the graphic display is something that
all the level of structure net what we
see here is the dependency of the parts
of the system so as you can see there
are some packages here and I'm
convention packages higher up in the
graph make pan on packages below them so
a lot of the dependencies we don't
actually see because there are quite a
few dependency
apart from the packages on top of page
to the packages down below however we do
see some error dependencies those are
the dependencies that you and the wrong
direction so they go from the bottom
edge of the top and and these are the
ones that cause the cyclic dependencies
basically what the system said it does
is it lays out the city who package
hierarchy in a way that there are that
this can be generated and that there are
not too many dependencies going in the
wrong direction this might be wrong of
course so if you look closely for
example there is a YouTube package down
here and it should really be on the very
bottom so the you to pick it should
probably not have any advances
whatsoever so it might be on the wrong
place here the layout algorithm might
not have you perfectly what I like about
this one is that it actually gives you a
lot of information but it doesn't really
confuse you by too many arrows now you
might say well there are still a lot of
time but well this is rather instruction
system so it's probably that's probably
so let's take a look at how what you can
do with it up to now I've basically
showing you stuff that you can do with
any any other system as well so it shows
you the dependencies between the
different packages and you can ease
about the quality of the system now what
I want to show is how you can actually
get rid of one side the dependency and
cyclic dependency is from the common
package at the bottom and as you can see
there are true arrows out there that go
to images that are on top of that so we
need to get rid of the of those two
dependencies in one way or not and what
you can do now is you can open that
package and see which class is
responsible so it's table bottom so you
can drag it out now terrific time is
simulated that drags out the table model
to package above that and the cyclic
dependencies are gone any change that is
simulated here is recorded in the actual
list so you can take this action is now
and actually do the real refactoring in
your integrated program this is of
course a very simple example what I
wanted to show you is that it's not just
static analysis
the code base is also about change in
the code base and you can do step
problem so let's try to find some given
here there is the one package and the
one package actually contains each and
every Gator class that you have in the
system and that's why it's quite huge it
takes sometimes opening for that reason
and as you can see there are just a lot
of classes like really a lot of classes
and what you can do now is you can have
the system try to guess some precip
clusters hey classes they really belong
together and it figures out some classes
that you belong together and if you look
at it just from the name so here for
example we have invoice fetch
overstretch line some other classes
similar name we have Ricky token here
and container so it here is where
authenticator so it sort of seems to
make sense of course you will need to
take a closer look at it and that you
can also do is you can have this will
ask the packages so you can just choose
any of those crates of clusters and made
them packages or the other way to do it
is to use auto level eyes and what
happens then is that the system sort of
guesses a new package hierarchy that is
that doesn't have any cyclic
dependencies or I said less possible and
is actually a hierarchical so there are
some packages here with
some consoles that seem to be going
together they are terrifically organized
and the names are better'n chosen of
course but unit so you need to rename
them and give them sensible name but is
this you have some starting and using
that approach you can basically forget
or the search of a system of the whole
system even and have the system guess
the new structure three I mean so what I
like about the whole thing is it
actually gives you a way to prove your I
should enter so instead of just sitting
there telling someone where you know
directive to really sucks it gives you a
way to tell them and this might be a
better cook so take a look at this is
this a better way to do it is that a
better way to do it what about breaking
apart these slightly dependencies does
that help and so one thing that I want
to add here is this is all about really
really large code base organized in one
deployment you there is a different way
of dealing with with BBC code so i mean
the problem that you have here is that
you need to refactor your code base
which might be somewhat risky and
actually what you're doing here is
you're trying to deal with those
dependencies deployment units have a
nice feature because they keep a lot of
stuff in town and just have a very
limited interface to the outside wall so
if you look if you took the department
what your mattress have so
the face arrest interface web interface
and a lot of internal workings you look
at em and that means because of this
limited interface dependencies between
home units are easier to manage because
other people just may use this interface
that you've defined so it's easier to
tell which parts i should use and it's
easier to exchange the internal workings
of the modules pencil and these large
deployment units might be a java program
because Java tends to produce such huge
deployment units and a lot of the ways
to deal with that so here is here is
something that that I did in an
consulting project we had a large a file
in there also lot of technical
infrastructure code for positions
monitoring and several other things and
some niggas e-business code and what we
wanted to do is we wanted to add some
kind of isolation layer and have new
stuff in here on there completely new
technical foundation to get rid of all
the lessee code all the bed restructured
code and have a new sort of greenfield
in this application and it turned out
that this is really really hard to do
because the isolation layer needs to
talk to the old system and if you have
two very different technologies coming
up with a way to design this legislation
it turns out to be really really hard so
even though you can do that and then
it's a lot of
of theory around it and it was leptin
specific example quite hard and as I
said this might be a Java program
because John tends to create such big
eeprom in units so the ton of time that
we came up with was but what about just
using this gear fire and keep it as it
is and instead have the new stuff in a
separate deployment units or separate
one even probably a different technology
I think the people even ended up using
various other project and then the
dependencies are the the ways that those
two modules talk to each other up just
HTML dates so the old efi on your web
interface links to the new stuff that
might be somewhere else because they're
arguing else that URL rewriting and so
you can easily implement that and HTML
ins might even use parameters so you can
sort of pass and parameters to the news
and you can use the same database which
is somewhat scary but at the end of the
day there are also a lot of integration
projects that just have a lot of
applications working together on one
database and the last thing here is it's
not that hard to do it and the new stuff
might be based and completely different
emojis so there are no limitations on
what you can do as long as it talks HTML
and it can
the database which essentially means
there is no mutation so other examples
might vary so for example you might also
have the rest or so gotta face to the
new stuff and just having trauma falls
in hand with this much will be outside
world but what I'm trying to say here is
if you use these separation like
prominence you might be better off than
just a musing then trying to fill with
your code base in transmission greatness
so that is the powder on a tech channel
lastly there are some developer skills
that you need to have clear with BBC and
there is this definition because you
could is just code without yes the
reason for that definition is that it's
hard to change curb if you don't have
any tests so and that is basically the
main feature of legal security this is
taken from this book by my father's
working effectively with X equal that
yeah it's a lot of interesting insights
around how to deal with musical talking
about tests there are two different well
there are a lot of different
you might have to adjust pick two one is
unit is unit test test in neutral
movements in isolation so a single class
are the single animal control or
whatever the benefit is that unitization
quite fast they are white box so you
have to know the internals of your
system or classes were together a.m. to
write unit tests and they break someone
easily because they are white box it
means that they actually hand on the
structure of your code in of the family
in China market surgical so if you have
a change to your codebase billion test
my bread and they also depend on Tesla
code so if you don't have tested ago you
won't be able to refugees this is also
why areum tests are a good way to prove
your design however this works against
you have needs because the niggas you
might not have such great structure
might not be testable the alternative
would be to use acceptance yes well it's
not in our engine testing something
different they usually test little
system they are not that fast but their
black box so it is some functionality
that you're testing and it's it doesn't
depend on how its implemented and
therefore they are more stable they
might still break so if you have
acceptance test that tests on the web
GUI they are and you do some tweaks to
HTML that we test my brain but that's um
they work with any good cyber Trevor so
they don't
and on well on your test approach and
they do have business means risky an
acceptance tests means that some
functionality of the systems right now
of course in the ideal world you may
need to have both if you would have both
however in the not so ideal world you
might even have none of them but the
question is where do you want to invest
what is more important and I believe
that it's probably more importantly of
acceptances I'm not trying to say that
unitus I'm a valuable but the contrary
but if I have to choose and if I'm very
humanely school-based it's probably more
info checks on deck box test as a safety
net and SN as a last resort then trying
to change all the architecture all the
code make a testable first and then
introduce new matey's the reason why I
think this is the case because they are
more stable so they don't depend on the
internal workings of your system they
don't man on the code
and they do have some business meetings
so if you have a promise set of
acceptance tests you can ensure to the
heir to the guide stakeholders that at
least the business meaning business
cycle system is still okay there are
other things that you can do so you can
do Refik drinks to your code base and
actually what I want to talk about it I
mean obviously you can do believe in
terms difficult base that's not a bigger
surprise but you what you can do is you
can actually introduce refit rings to
your code base that allow you to make
the code base law in stanville we could
use different names for your variables
you can extract the variables if you
have some kind of expression that has
some meaning you can extract it in a
separate variable give it a sensible
name and that explains what's going on
now and these refactorings are automated
if you were using proper ID and are
therefore no risk and make the code
easier to understand so that's another
thing that you can actually now what we
found valuable at a disco is to not just
talk about it as I'm going right now but
actually provide hands-on exercise how
to deal with in the security and one
thing that a time quite valuable and
also fun is to do lyrical routines so
the idea is to take some prepared legacy
code base and apply some of the
techniques
that I just spoke like introducing
acceptance yes introducing refactorings
to better understand code base and I've
done that in quite a few places so this
is a dress with a Munich and we also
going to do that and this is the side
promotion that I have here we also going
to do that at it would quite an early
next month together Martine so if you
are interested feel free to register
also to promote promotional so you can
protect me and I've been easy to
remember where else its legacy code
retreat about an LCR ditch BER BER if
you're interested register so that is
where you can actually we are going to
talk about not just this but also
general approaches to so this sort of
concrete representation to sum up first
of all what we've seen in for management
is I think it's important to think about
quality investment it quickly be the
quality of your system in terms of an
investment not just technical debt and
that leads you to concrete ideas about
what where you want
but why you want to improve it and also
makes it in my opinion easier to talk to
management about and that's showing you
the true to do that for the architecture
you might want to have small component
and small components as well and
humanities that might be easier to do
than you think because there are tools
that allow you to change the start of
your system that even can get a few
guesses about what the ideal structure
might look like and to some extent
automate the restructuring of your
cookies the alternative is you can
always try to put in an additional a
dependency formed unit those have clear
separation and different interfere in
clear interface and deaf I easier to use
so that might be an option and then
there are the developer skills and as I
said now I think acceptances are
probably more valuable than new tests
and I spoke to you about the deed is
equal to retreat where connection very
much so</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>