<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • The Scribe's Oath • Robert &quot;Uncle Bob&quot; Martin | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • The Scribe's Oath • Robert &quot;Uncle Bob&quot; Martin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • The Scribe's Oath • Robert &quot;Uncle Bob&quot; Martin</b></h2><h5 class="post__date">2017-06-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Tng6Fox8EfI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I had a very pleasant day today
flying and I'd like to invite Turin
Ackerman's up on stage if I might he was
kind enough to put me in his airplane
and fly me over the Dutch coast and show
me some of the sights and then we had a
very pleasant lunch discussing the need
for well-trained software developers and
those who meet who know test-driven
development and value software
craftsmanship skills and if I'm got this
correct you are the president of the
Encinal group is that correct good so
now I'd like to abuse you if you don't
mind if you'll just stand here this is
the reward for doing a favor to me right
you get to come up on stage if you will
spread your arms out just like yeah
you're gonna have to hold them there for
some time all right now for the rest of
you imagine that these outstretched arms
are the age of the universe no not the
university earth the earth forms here
and this is today we're on this
outstretched set of arms did the
dinosaurs die
where is it here over here oh yeah yes
so so excuse me I know this is dangerous
no no this one comes out yeah okay right
there that's where the dinosaurs died
where did the dinosaurs first appear
right there this is about 60 million
years right there there's another 60
million years they died 60 million years
ago they came on the earth 60 million
boat years before that where did life
come out of the oceans on this graph
there there was no life on land until
here life on Earth spans this particular
length but when did life begin in the
seas here left again on the Seas three
and a half billion years ago we have
fossils that are that old right and
nothing happened
hold still no nothing happened during
this period
right except you can you can put them
down actually hold yeah okay good good
don't do me any favors man
so the talk I want to give today is
called the scribes oath I have it here
in my pocket it's getting a little bit
worn I've given it a few times um
scribes let's go back to ancient times
there were a group of people in ancient
times in ancient civilizations who knew
how to read and write not very many
people had this skill it was an
extremely specialized skill most people
did not need to know how to read and
write all you had to do was till the
fields or harvest the crops or haul
rocks from the quarry or whatever it is
your job was it did not require you to
know how to read and write the scribes
on the other hand that was their skills
they had a literacy that most people did
not have they were able to write things
down now in ancient times they had laws
laws have to be written down people need
to remember them and they need to be
precise so in a king made a law when a
pharaoh made a law it had to be written
down and then if someone broke that law
a scribe would have to read the law to
make sure that it was broken if there
were large transactions that were made
some land baron sells ten thousand sheep
a strict accounting of that needed to be
made and so the scribes would write this
down the scribes understood mathematics
they understood accounting they could do
simple and complex calculations they
understood the difference between legal
language and
legal language they were a set of
professionals nothing important happened
in ancient society without scribes
nothing could happen without scribes the
scribes were the lubricant of the
society they made things work well and
because of that they were elite they
were highly regarded and respected they
wore special clothing they had secret
handshakes they had special social
status a scribe in ancient Egypt for
example could not be conscripted into
the military that was illegal guess who
wrote that law scribes could not be
taxed we're going to come back to that
one don't tax the scribes hmm they were
trained from youth they were the
administrators the managers and the wise
men of the time they had a culture
scribes did it was an internal culture
they had a set of ethics a set of
standards they had an agreement amongst
themselves about how they would behave
in order to properly serve their
societies they were disciplined they
were orderly they were professionals to
give you some kind of a feel for just
how disciplined and orderly some of
these scribes were allow me to describe
for you the rules that Hebrew scribes
used when they were copying holy
scripture the Torah
first of all they had very strict rules
about what kind of material they could
write these holy words upon it had to be
animal skins of just the right kind of
animal and those skins had to be tanned
in just the right way and pounded to
just the right thickness and have just
the right consistency and the scribes
had the talent to do these things they
had the procedures they understood how
to make the sheets that could be rolled
up into Scrolls that they could then
write their words upon they understood
how to clean them and how to bind them
they had formatting rules rules that you
and I would recognize for example they
would divide the scripture up into pages
although pages in the sense that you
would scroll through a segment a
vertical segment and then you would
scroll again to get the next page and
scroll again to get the next page you
did not turn these pages you scrolled
them similar to a web page now a page
had to be no more than 60 lines long
where did they get this number 60 they
did not have terminals that were limited
to 60 but they had this limit of 60 and
they could not be any shorter than 48 so
a page could be from 48 to 60 lines with
an interesting format restriction for a
page they had to use black ink and that
black ink was of a very special recipe
that is now lost we don't know what that
recipe was anymore but they all knew how
to make this ink just perfectly
they had rules rules about how you wrote
and you'll like these rules every word
had to be verbalized as it was being
written
you could not write in silence you had
to say the word you were writing as you
wrote it there were certain words that
were treated specially specifically the
name of God Yahweh the four-letter
Hebrew Forli Hebrew letter name of God
the Tetragrammaton Yahweh before you
could write this word you had to clean
the pen and set it aside
clean your body then come back and write
the word once you had finished copying a
section of the Torah that section of the
Torah had to be reviewed by another
scribe that other scribe had specific
rules that they used to check that the
copy was made correctly those rules
included things like they counted the
letters on the original document and
then they would count the letters in the
copied document the count had to match
then they counted the words in both they
had to match then they counted the
sentences in both they had to match then
they counted the paragraphs in both they
had to match then they found the center
letter of the original and the center
letter of the copy they had to match so
did the center word so did the center
sentence so did the center paragraph
this is not a CRC but it is similar to a
CRC it's a checksum of some kind a
document could only have three errors if
it had more than three errors it had to
be discarded but it could not be thrown
away you had to put it in a special
place because it contained holy words it
could not simply
be thrown away to discard it you put it
in a special clay jar and you put it in
a cave somewhere fortunately for us we
have found some of those jars in some of
those caves 2,000 years later and we
have the erroneous documents that we
nowadays call the Dead Sea Scrolls now I
want you to keep that in mind as I now
describe us and I'm going to start with
us in the 1960s because what I want to
do is describe our social standing where
we stand in human society in the 1960s
programmers well nobody knew who a
programmer was nobody knew what a
programmer was how many programmers do
you think there were in 1960 anybody
know a few thousand perhaps let's go
back 10 years before that how many
programmers were there in 1950 a few
hundred and when was there just one what
year was it when there was just one
programmer 1946 as well done and what
was his name Alan Turing now there were
other people who have been said to be
the first programmer it is often said
that ADA of Lovelace who now gave her
name to the horrible language ada I'm
sorry are there any ada programmers here
good it's a horrible language anyway she
is sometimes called the first programmer
that's not exactly fair she did not
write code in the sense that you and I
might write code what she did do was
fairly interesting Charles Babbage had
given a lecture in English to an
audience a Frenchman had written notes
about that Ling that lecture in French
and then someone asked Lord Byron's
daughter
ADA of Lovelace to retranslate them back
to English and as she did that she
understood Babbage's mechanism Babbage's
mechanism was a mechanical computer it
was programmed with cards pieces of wood
that had holes in it it had instructions
that you and I would recognize it had
registers that you and I would recognize
it had the ability to memorize numbers
and it had instructions that would be
executed in sequence including its
instructions that we might consider to
be if statements or jump statements all
of those were at in existence in
Babbage's machine and Ada understood
this but she understood something else
she understood and she is probably the
first person to understand that the
numbers in this mechanism did not need
to represent numbers they could
represent something else Alan Turing is
the first programmer to program an
electronic computer that you and I would
recognize as an electronic computer and
the electronic computer he programmed
was called the AC automatic computing
engine in 1946 this was an extremely
unreliable machine made up of vacuum
tubes and and CRT memory it had 20 bit
words and it had 1024 of these words and
he would program this machine in raw
binary there were no assemblers no
compilers no languages he had to program
this in raw binary well actually he used
base 32 and the kind of programs he
wrote you and I would recognize as
programs he had the problem that he
wanted to manipulate numbers but of
course a computer only has integers
especially computers of those days so he
wrote what we would recognize today as
the first flaw
point to package he realized that he
needed to be able to call bits of his
program and have those bits returned the
computer architecture did not allow for
this and so he invented the concept of
the stack and the idea of taking the
return address and pushing it on the
stack all of these things he invented in
1946 how long did it take before there
were two programmers not long not long I
mean right you're your one guy and
you're sitting there writing all this
binary and you say I need some help with
this so he gets other people to join him
and the number of programmers begins to
grow rapidly but think about it and look
around the room as you think about it
there was this moment in time when there
was one programmer in the world
how many programmers are there today
it's tough to know especially you know
the account the VBA programmers are not
all right but the number is probably
close to a hundred million maybe it's
not all the way up to a hundred million
maybe it's only 80 million maybe it's
120 million I don't know the exact
number but the number is large how do
you get from one in 1946 to a hundred
million 70 years later 70 years how do
you get there what kind of growth curve
is that is it linear it's not linear it
was mad linear growth right
it had to be exponential okay so if the
next financial curve that means there's
a doubling rate all exponential curves
have a doubling rate and we can
calculate what that doubling rate was
it's not very difficult what is the log
to the base 2 of 100 million quickly now
come come
log to the base 2 of 100 million come
come well 2 to the 20th is a is a
million and 2 to the 7th is 128 so we
will say 2 to the 27th 27 is the log to
the base 2 of 100 million and if we
divide that into 70 years we come to the
startling conclusion that the doubling
rate is on the order of two and a half
years now that's probably not fair
because Alan Turing was likely
recruiting people a lot faster than once
every five years
so the doubling rate was probably very
fast for the first 10 years and then it
slowed down to a more sedate rate of
perhaps five years the number of
programmers in the world doubles every
five years and if that's true and I
believe it is at least during certain
times then if that's true half the
programmers in the world have less than
five years experience and this will
always be true as long as we are
doubling every five years half the
programmers in the world will have less
than five years experience it's a
natural result of the growth curve which
puts our industry
a state of perpetual inexperience people
often look around at programmers and say
well they're all young this must be a
young person's thing old people don't do
this all the old people left know we're
all still here it's just that there
weren't very many of us to begin with
the social standing of programmers in
the 1940s was non-existent the social
standing of programmers in the 1950s was
virtually non-existent no one knew what
a programmer was no one had heard of the
term in the 1950s by the end of the
1950's some people might recognize that
oh there's this funny thing that people
do called programming computers but most
people certainly never knew a programmer
no one lived next door to a programmer
you didn't go to dinner parties with a
programmer not in those days there just
weren't enough of us by 1960 that really
had not changed by the 1960s there just
weren't that many programmers in the
world maybe there were 10,000 maybe
there were 20,000 something like that it
just wasn't a very large number and so
most of us didn't know what a programmer
was there was no social standing
although there was recognition the first
computer science degree program began in
the 70s oh there were guys working on it
in the 60s but degrees weren't offered
until the early 70s what did all those
early programmers do how did they learn
programming before there were degree
programs at university before you could
learn programming at university where
did you learn programming where did
those early programmers come from they
did not come out of university they
couldn't come out of university there
was no university that could teach them
this they came out of industry they had
to come out of industry if a company had
a computer the company had to have
people to program that computer who
would they get to do it Wow they would
find other engineers and other
mathematicians and other scientists and
people who had
in around for a while people who had
already understood the business already
understood professionalism and ethics
and they would ask them could you learn
how to program this machine and these
people who were in their 30s and 40s and
50s were the first programmers when did
it change when did programmers start to
be in their 20s well it didn't change in
the 50s and didn't change in the 60s it
changed in the 70s in the 70s hordes of
programmers poured out of university and
were eagerly gobbled up by industry
because there is one fact about software
developers there are never enough of
them except in the year 2000 we had too
many then for two years other than that
our world has always suffered a lack of
computer programmers the demand is
always too high the supply is always too
low which is why we're doubling every
five years in the 70s parents began to
think that it was a good idea for their
children to become computer programmers
it was a career that could be lucrative
as many of you have discovered it is a
career that was thought of as a good
stepping stone into management a good
stepping stone into a much better career
there was also a stigma about being a
programmer in the 70s if you were a
programmer in the 70s
you probably got beat up in high school
you were one of those nerdy kids that
didn't go out for sports and didn't do
all the things that all the other kids
did you are one of those mathy oriented
guys who thought about weird things like
computers and the jocks would beat you
up every once in
in the 70s we would have been the
strange kids that went to the the vide
the video store arcade where all the
video games were we were those kids that
were playing pong all the time does
anybody remember the movie wargames okay
that would have been the late 70s and
that young man I can't remember his name
now the actor but that young man was
painted with a generous light as a nerdy
little kid who set the world on fire by
the 80s the the world thought of us as
mousy people eating Twinkies drinking
caffeinated soft drinks and living in
our mother's basement while we wrote
tons and tons of code right there was
not a good attitude towards us they had
a stigma does anybody remember Jurassic
Park in fact Jurassic Park was the first
time that a programmer became a villain
Dennis Nedry
the villain programmer of Jurassic Park
the unscrupulous smuggler of of DNA who
got eaten his just resort reward being
eaten by a dinosaur prior to that movie
if programmers were shown at all they
were shown as ancillary background
unimportant prior to that movie the
computers were the stars
remember 2001 then it can anyone name
the programmer of how dr. Chandra who
made a big appearance in 2010 the movie
but in 2001 you never saw dr. Chandra
you just knew about how anybody remember
the lovely movie the Forbin project
where two computers vie for control over
the whole world Guardian and some other
one I can't remember and eventually they
enslave all of mankind the computers
were the evil ones
if the programmers were there at all
they were trying to pull the plug on
their creation in the 90s the
programmers had become the villains by
the 2000s the programmers had become
everything remember the matrix that was
all about the programmers neo was a
programmer Trinity was a programmer
these were all programmers and not only
were they programmers they were
superheroes towards the end of the
horrible horrible third Matrix show you
realized that neo was actually Christ so
just went wrong the whole thing went
wrong terrible 2010 I am probably
2012-2013 I am sitting in Stockholm at a
bar outside I had just been to visit the
guys the Minecraft guys at million this
is probably actually 2015 and we're just
sitting out there drinking a beer I'd
been giving them lectures all day and
and up runs this kid this little kid
maybe 10 years old maybe 12 little boy
and he runs up to the the beer garden
where we're sitting and he points at one
of the programmers jab because are you
Jeb and Jeb and if you follow minecraft
and if your kids are playing Minecraft
they know who Jeb is and Jeb looks at
him and with kind of a sigh yes I'm Jeb
this happens to him all the time will
you tie my autograph programmers had
become children's here
our children want to grow up to become
programmers one day and build something
like Minecraft our status in society has
changed remarkably everyone knows a
programmer now everyone lives next door
to a programmer now probably lives next
door to more than one programmer now
because there are just so many of us but
in 2015 we took another step we
graduated one further ring the day that
the CEO of Volkswagen North America
testifying before the Congress of the
United States blamed a couple of
software developers for lying and
cheating in their code for whatever
reason quote unquote we had elevated to
the highest rank of society a political
scapegoat now the thing about that was
is that it was a couple of developers
who did that it was developers
programmers you and I people in our
society people in our industry our
brothers wrote code that lied and
cheated and emitted pollutants into the
environment those programmers violated a
code of ethics that does not exist we
don't have that code of ethics we need
it but we don't have it yet those
programmers should no longer allowed to
be programmers you and I should have a
mechanism to say those people should not
be programmers anymore because they lied
and they cheated in
err code now you might say well come on
those guys really didn't even know what
they were writing and it was
requirements that were handed till they
just wrote the code it really wasn't
their fault sure I buy that right if on
tests and then don't omit I believe you
software this thing that you and I do is
a kind of literacy we know how to read
and write a special kind of language a
special kind of expressiveness most
people don't have the need to have this
kind of expressiveness most people live
their lives fine without ever knowing
what code is or looking at code they
don't want to see the code they don't
need to see the code they have lives
they live them normally you and I have
this special literacy that no one else
has and nothing happens in our society
without us that did not used to be the
case it used to be that you could get
into your car and drive to the store and
no software would be involved you used
to be able to go to the store and buy
groceries and no software would be
involved it used to be that you could
make a telephone call to your mother and
no software would be involved but those
days are gone because now there is
nothing you can do in our society unless
software is involved your grandmother
interacts with a software system
virtually every minute of every day
because there is nothing she can do in
our society if it does not somehow
involve a software system you can't
drive a car without software you can't
make a phone call without software you
can't put something in the micro
wave oven and cook it without software
you can't start the dishwasher without
software you cannot adjust the
thermostat without software you can't go
to the store you can't buy anything you
can't sell anything you can't get an
insurance policy you can't file an
insurance claim you can't make a law you
can't enforce a law there is nothing you
can do in our society without a software
system controlling and mediating that
activity we rule the world we do other
people think they rule the world but
then they hand the rules to us and we
write the rules that execute in the
machines that govern everything and so
now it's time to talk again about that
tax issue the dependence of our society
upon software is not something that our
society actually understands well yet it
is actually not something that you and I
understand well yet because you and I
are just doing our jobs we're just
writing code
somebody wants the code we write the
code it has not yet quite dawned upon us
or upon society that we are at the root
of everything eventually society will
come to this knowledge and it will come
to this knowledge most likely through an
event and that event will be some poor
idiot programmer doing some stupid thing
that causes 10,000 people to die in one
shot and it's not hard to imagine what
that might be nowadays an accident a
software accident a missing comma that
killed 10,000 people and when this
occurs and it will occur you know what
will occur software is already killing
people in the hundreds
just a few more orders of magnitude to
go when this occurs the politicians of
the world will rise up as they should in
righteous indignation and they will
point their finger squarely at us and
you might think oh no they're not going
to point it at me
it'll pointed at my boss I'm pointed at
my business note the CEO of Volkswagen
North America clearly showed what was
going to happen when the finger pointed
at him he pointed it down to us so the
finger will come to us as it should
it is our fingers on the keyboards after
all and the politicians of the world
will ask us the question how could you
have let this happen and we have to have
an answer for them because if our answer
is hello my boss told me it had to be
done by Tuesday if that's what our
answer is then the politicians of the
world will shake their heads sadly and
and moan on about the disarray in the
software industry and the chaos and
they're out of control and they will
pass laws and those laws will be what
languages you can use what processes you
have to follow what signatures you have
to obtain what courses you have to take
what books you have to read what
frameworks you can use and we will
become a deeply regulated industry this
is something I would like to avoid not
the regulation the regulation is going
to come whether we like it or not I
would like to avoid government deciding
what the regulations are I want to get
there first I want to be there with the
regulations so that when the politicians
point their finger and ask us how this
could happen we can answer and say look
this was a terrible accident but it was
not due to our negligence because here
are our standards here is our ethics
this is how we in for
sit and if we can say that credibly then
perhaps we will avoid the worst that the
politicians could do to us other
industries have done this doctors did
this they police themselves long before
their their rules were turned into laws
accountants did this architects did this
many industries have gotten to it first
and then after the fact government said
well we should turn that into law and so
I'm going to propose to you an oath the
programers oath although lately someone
said it should be called the coders code
it reads as follows and I submit it to
you in all humility think about these
words think about these promises see if
they make sense to you see if it's
something that you could promise as a
professional a professional promise is a
promise that exceeds the authority of
your employer so if you make the promise
it does not matter what your employer
tells you to do if it violates the oath
in order to defend and preserve the
honor and profession of computer
programmers I promise that one I will
not produce harmful code
what does harmful mean I think every
person has to make that decision for
themselves some of us might consider
weapon systems to be harmful some of us
might consider weapon systems to be very
beneficial but whatever your view on
that is you would hold it as part of
your oath harm is something that a
software developer does when they
release a defect a defect harms the
company that they've written
at code four and the users of that of
that code as well but defects are not
the only kind of harm there's another
kind of harm a much more insidious kind
of harm programmers cause harm if they
damage the structure of the code if they
make the code harder for other
programmers to understand and change the
word software is a compound word the
first word in that compound word is soft
meaning easy to change software was
invented so that we could easily change
the behavior of our machines that is why
software exists so that we can easily
change the behavior of our machines to
the extent that our software becomes
hard to change
we have violated the very reason that
software exists software is supposed to
be easy to change and therefore anything
a programmer does that makes that
software hard to change is harm and you
must not cause harm to the code that I
produce will always be my best work
really yeah really
I will not knowingly release code that
is defective either in behavior or
structure you should be able to go home
every night and look yourself in the eye
and say I did a great job today you
should never have to go home and take a
shower and you know exactly what I'm
talking about
three
I will provide with each release a quick
sure and repeatable proof that every
element of the code works as its
supposed to
a quick sure and repeatable proof that
the code works as it is supposed to
otherwise known as tasks where did we
begin to think the code should not be
tested when did that occur in the last
70 years when did we begin to shirk the
responsibility of making sure that every
if statement executes properly that
every while loop terminates properly
that every exception is thrown at the
appropriate time when did we decide that
it's okay
if some of that code doesn't work it is
not okay if some of that code doesn't
work and so you should provide proof
quick sure and repeatable proof that the
code works as you believe now we're all
human we all make mistakes it is not
impossible to it it is not possible to
achieve perfection but it is always an
error not to try the idea that we will
simply accept a certain level of defects
is in appropriate is unethical we can't
accept that we will try to prove for I
will make frequent small releases I will
not impede progress one of the best ways
for a software developer to slow
everybody else down is to check out a
module in whole
for three weeks and then cause a big
merge the best way for a software
developer to impede his associates is to
hold the code tight and not let anyone
else see it I want you to release the
code frequently I want you to release
the code daily maybe several times a day
so that other people can see what you
have done and integrate the work that
you have done I don't want anybody
holding onto it and saying wait till I'm
done wait till I'm done because
everybody else is going to have to wait
a long time smallness in relief is how
we make progress Fast Five I will
fearlessly and relentlessly improve the
code at every opportunity I will never
make the code worse this is an
interesting one how many of you have
been significantly slowed down by bad
code okay this is almost everybody I see
one person with their hand down they're
either not a programmer or they're lying
because of course we have all been badly
slowed down by bad code why did you
write it if you know the bad code is
going to slow you down why did you write
it or more importantly why did you allow
it to stay you see the bad code why do
you allow it to stay so let me set up a
scenario for you you are sitting at your
terminal or your laptop or whatever the
heck it is your program on now and
you're scrolling through some code on
your screen and all of a sudden you look
at something that's at home man that is
awful code I should clean it and the
very next thought in your mind is I'm
not touching it because you know if you
touch it you will break it and if you
break it
it becomes yours and so you walk away
not me I'm not going to be the one to
touch that code and so the code must
rock because no one will clean it it's
too scary to clean it and the code must
rot and get worse and worse over time
and no one will clean it I want you to
think about how wildly irresponsible
that is to be so afraid of this thing
that you have created that you are not
willing to do the one thing that might
help it clean it of course the problem
is fear how do you deal with the fear
how do you eliminate the fear how can
you not be afraid to change the code
I'll remember I mentioned that
interesting proof the quick sure
repeatable proof if you have a suite of
tests and you believe that suite of
tests and you can run that suite of
tasks then when you see that bad code on
your screen your next thought is oh I
think I'll change the name of that
variable and you'll run the tests okay
they passed good and that functions a
little too large I think I'll split it
in half run the tests ooh
passed good okay ooh this little
fragment of a function that I just
created that really belongs in that
class over there run the tests OOP they
failed put it back run the tests pass oh
I see what I did wrong okay move it over
there run the test if you have the tests
if you have a test suite that you trust
with your life you can clean the code
and that is how you fearlessly and
relentlessly improve the code at every
opportunity six I will keep
activity my own and my team's hi I will
do nothing that decreases that
productivity I will not damage the code
I will not make the code worse I will
keep productivity high I will not check
out the code for long periods of time I
will keep productivity high
I will not create a suite of tests that
take hours to run that will reduce
productivity I will make it important to
keep the tests running fast that will
enhance productivity I will do nothing
that decreases productivity seven
there's only nine seven I will
continuously ensure that others can
cover for me and that I can cover for
them imagine a team a sports team moving
the ball down the field against their
opponents and one of the team members
goes down trips falls injured what do
the other team members do they cover the
hole they keep the ball moving downfield
until the flag is thrown if the flag
gets thrown they cover the hole they
cover for that player in order to cover
for a player that's gone down you have
to know how to cover that position if we
are a team if we work on teams and we
love to use the word team but if we are
on teams then we cover for each other
Bob is the database guy Bob gets sick
somebody's got to be able to do the
database work if Bob if nobody else can
do the database work because Bob's the
only database guy then we do not have a
team and I noticed that I put the onus
upon you I will continuously ensure that
others can cover for me it is your
responsibility to make sure that
somebody else knows your
job somebody else knows your work
somebody else can cover for you if you
go down it is your responsibility to the
team to make sure that you are not the
single essential component how do you
make sure that someone can cover for you
what is the best way to teach someone
what you are doing and where your code
lives and and where your tests live and
what the structure of your stuff is what
is the best way to make sure that
someone can cover for you I suggest
perhaps that there is a discipline that
people have called pair programming that
might help eight
I will produce estimates that are honest
both in magnitude and precision I will
not make promises without certainty what
is the most honest estimate you can give
I heard it out there three little words
I don't know how long just going to take
you know not that is entirely honest it
is also not very useful so what we need
to do is make it a bit more useful
without sacrificing the honesty which is
I don't know so what we do is we put
bounds around it we outline our
uncertainty and we can do that through a
number of techniques I will describe one
for you someone says all right how long
is it's going to take you and you think
all right Wow look at if everything goes
perfectly you know and I mean perfectly
this will take me five days if things go
as they normally do it'll take me ten
days and if everything goes wrong short
of nuclear war it's going to take me 25
days and that
with that you have drawn a nice little
curve around your uncertainty you have
bounded your certainty you have
described your uncertainty it is
completely fair and completely honest
and the people you relate that to are
not going to like it because they want
certainty who doesn't and it's perfectly
fair for your manager to come back and
say oh man I can't deal with that
uncertainty perfectly fair there may not
be anything he can do about it or she
but it's perfectly fair and it's
perfectly fair for a manager to put
pressure on you say now wait what about
this what about that can't you do it
this way can't you do it that way isn't
there some way we can make this more
certain and of course you should listen
to all of that but you should never make
a promise without certainty because if
you make a promise without certainty you
are lying if you say okay I'll get it
done by Tuesday and you don't know you
can get it done by Tuesday you have to
get it done by Tuesday without fail or
you're lying now the kind of pressure
that you can be put under here is many
many different forms but one of the most
obvious is this one and watch out for
this one because it's very very tricky
you will say I think somewhere between
five and twenty five days and that no
one's going to like that right and they
might come back to you and say well I
need it by Friday and he's going I can't
promise that and then they might say
something like this will you at least
try and the answer to that is how dare
you accuse me of not trying I have been
trying this entire time I will continue
to try this entire time it is insulting
to me that you have suggested that I am
NOT trying you probably don't want to
use those words but that should be the
reaction in your mind because it's the
fundamental truth you have been trying
what what I mean is there some like
extra capacity that you haven't been
giving it we've been holding some
capacity back
are there magic beans in your pocket
with which you can change reality of
course you have been trying you provided
the best knowledge you could and then
someone wants you to try and the answer
is no I am trying I cannot change the
reality of this situation
I'm sorry manager whoever you are but
you'd better deal with the fact that I
am uncertain then I cannot narrow my
uncertainty down now you don't want to
get walk waltzing around and drawing
normal curves on all the boards and say
look at how uncertain I am that's not a
good idea and you should always be
hunting for ways to narrow the curve and
working with people and so forth but
here is the fundamental truth of why you
were hired you were hired for your
ability to say no because you are the
only people who know when the answer is
no and if you then say yes to something
when you know the answer is no you doom
the project to failure and you doom your
team members and you doom your company
last one and it's a short one nine I
will never stop learning and improving
my craft I will never stop learning and
improving my craft to some extent this
is unfortunate because much of what we
have to learn is repetitious anybody
learning a new language like Swift
anybody doing Swifter or how about go
anybody learning go or dart anybody
learning dart write anything new in
these languages
what rust yeah you're learning rust good
anything new in these languages any new
concept in any of these languages that
has not been tried before and the answer
to that is no there have been no new
language concepts probably
for 30 years but we keep on inventing
new language after new language after
new language why why do we keep on
inventing new language after and the
reason is very simple we hate the
language we're working it and we want
some new language out there there's got
to be some new language out there that's
better than the one I'm working in and
the answer is there's probably not a new
language out there that's better than
the one you're working in because there
hasn't really been a new language in the
last 30 years there just rehashes of all
the same old stuff so that's one of the
unfortunate sides of why we have to keep
learning but we have to keep on learning
because we will have to use those new
languages and we will have to use the
new frameworks and we will have to use
the new processes and you have to keep
learning them all the time otherwise you
fall behind and you as a software
developer you don't want to fall behind
because then the only option for you is
to go into management when do you do
this learning when do professionals
learn not on the job it is not your
employer's responsibility to groom your
career it is your responsibility to
groom your career you take
responsibility for your career you learn
at home you learn saturdays and in the
evenings you read you play you get your
laptop out you learn a new language you
give 40 hours a week or whatever the
hour count is that you're supposed to
give to your employer but you go home
and you spend another few hours because
that's what all professionals do
professionals spend much more than 40
hours a week on their career it's just
the truth of the matter you may not like
it but that's the way it is and with
that I think I'm going to end my talk
thank you all for your attention
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>