<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Secure Coding Patterns • Andreas Hallberg | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Secure Coding Patterns • Andreas Hallberg - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Secure Coding Patterns • Andreas Hallberg</b></h2><h5 class="post__date">2015-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/igFRvriDMqk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yes my name is andreas Alba I'm from a
Swedish company called truseq if you
were at the previous session you know a
little bit but truseq my colleague
emailed Kannamma talked about it we are
located in malmö and in Stockholm in
Sweden I'm going to be talking about
secure coding patterns and please
remember to engage through the go-to
application and without further ado
let's get started so I work at the
company truseq here's us at the in South
Africa and our company trip this year
actually I spent my time at rusik
developing and auditing security
critical systems security is important
right you need to discuss it not only
with your kids but with your colleagues
as well and the thing with security is
that it's hard to tack on security on a
project when it's nearly finished it
really needs to be an integral part of
development for it to be successful and
today I'm going to talking about some
concepts and patterns that will help you
in your daily coding activities
specifically I'll talk a bit about trust
to set the stage in the beginning I'm
going to move on to the first pattern
that's called domain driven security and
there's something called the untrusted
pattern I'm going to be talking about
immutability and I'm also going to be
talking about something called the
inverse life-coach pattern so let's get
started trust the foundation of software
security well it really is because a lot
of security issues boil down to poor
understanding of where we or our
software is placing its trust how do we
control who we trust how do we establish
trusts these are really important
questions if you want to make your
software secure so let's take a look at
a typical interaction that can happen
here here's a businessman Bob he
at the bank he wants to transfer X euros
from account Y to account Z okay you
know what could possibly go wrong this
is simple typical transaction that you
have in different forms in your
applications whatever that might be a
whatever count your application might be
so let's look at the first interaction
the authentication step as it's called
how can the bank be sure that Bob really
is Bob and how can the bank be sure
sorry how can Bob be sure that the bank
is indeed the bank that they're talking
to the correct party if we look at the
actual operation that's to be performed
do we know that Bob owns account why do
we know that account why holds X euros
and do we even know that X is a number
these are all things that our
application has to handle otherwise
we're in trouble because you know Bob
could really screw us here or the bank
could screw Bob depending on which side
you're on in this case so in order to
visualize trust it's pretty useful to
think of your application as a circle
and there's a circle of trust and your
application is inside of it so you have
all this stuff right that's outside of
your circle of trust
that's not trusted you can't trust the
user the request data the database who
knows what's in there is your
application responsible for putting
everything in there maybe no third party
services etc etc so what you need to
understand what your application must
understand is where the trust boundaries
are in your code where does trust begin
where does trust end and I'm gonna
apologize in advance for this next slide
you might want to cover your eyes I just
want to really hammer home this point
about what's trusted and untrusted
everything inside the circle is trusted
everything outside is untrusted and
you'll notice a few things about this
mainly how much larger the untrusted
area is them their trusted and
importantly that it's unbounded the
trusted is very bounded and specific you
can enumerate all the trusted states
whereas the untrusted is unbounded and
you know in a an impractical way it's
imposed
it's to enumerate the states that can
happen and this is why black listening
doesn't work when you try to enumerate
the stuff that's not allowed you have to
do white listing and enumerate the stuff
that is allowed which is which you trust
so well how does something from the
untrusted side become trusted after all
we have to interact with all this stuff
otherwise our application is pretty
worthless so through every developers
favorite activity validation that's the
most fun thing to do when you're
developing an application right that's
the first thing you start with you're
fired up to start with validation so
hopefully after this session you'll at
least think it sucks a little bit less
than you did before so well two things
can happen of course either the
validation passes we trust the data or
we do not trust it and we reject it so
we keep it outside our circle of trust
and if we're talking about validation
just to define it a little bit more this
is the typical kind of validation that
you probably think of making sure that
the data you get is valid in your domain
like is X even a number another the data
that's Bob when it transferred to the
bank or whatever there's some other
fancy names canonicalization or my
sation stuff that must happen before
validation here's a typical example of
normalization where you get a file path
maybe you love people to upload stuff to
or download whatever from C public file
upload and if your program only
validates the beginning of this on a
normalized path then you say that's fine
it's C public file upload but you have a
path traversal attack there with a dot
dot slash it slashes that the OS then
will collapse two secrets keys which
well obviously somewhere you don't want
the user poking around where they're
uploaded or downloaded files whatever so
normalization must happen before
validation then you see why there
there's something sanitization where you
clean up dangerous unknown data typical
log injection I'm willing to bet that
almost none of you is doing sanitization
know your log data because it's so
common when we do review so everything
you don't you take some value and it's
doesn't fit in your domain you log the
error say I received some invalid data
this is the one because it's good for
error checking or debugging later well
then the user can inject log entries
into your log which could make like
legal proceedings harder later if you
can question the log so that's something
to think about if the user knows what
kind of log format you can inject evil
log entries and confuse your debugging
or error checking later excuse me we
talked touched upon this before always
prefer white listing over black listing
because well the red area is unbounded
and the green area is bounded right
you cannot enumerate all the invalid
stuff and another good thing about being
strict with validation is that it finds
bugs early right instead of you get some
error like 8 steps down in the code and
you have to spend one day you know
tracking but how did this end up down
here near the database and you it turns
out that is it's a number being you know
negative instead of positive up here
that you could have caught really early
up here in the UI almost the way
application so it's not only for
security it also saves you time and
headaches and you every time you do
validation every time you have a
parameter something you need to validate
you have to ask yourself what is the
largest acceptable range and then don't
accept any more than that don't think
well you know maybe in half a year you
know people will transfer these large
amounts or maybe you know they'll change
the expiry time to a few more years more
on these credit cards I'll just put that
in there so we don't have to do an
update you know don't do that just be
really strict and if you have to change
it update your software that's better so
let's trust in general it's the
foundation of software security and
let's move on to the first pattern here
shall we
domain-driven security how many here
have heard about domain driven design
hands up please okay that's good it's
not really complicated that's that you
always model your domain like with
proper objects that interact and are
created in special ways so it's not
complicated but you can look it up if
you won't need to know more that the
term or this pattern domain-driven
security it helps us with a trust
boundary and it gives us validation
everywhere in a good way
and the pattern was coined by two
developers at the Swedish company Omega
Point Yann villain de Oak and dawn by
yunsun so domain during security is
basically the main urban design plus
some conventions for in potato
validation that we're gonna take a look
at now so let's go back to our
interaction with Bob in the bank here's
Bob again so this is a new transaction
the both the bank trusts him already and
then forgets to validate and Bob wants
to transfer a negative 1,000 euros sure
go ahead
catchy Bob gets a almost assumed to be
outdated Swedish a thousand euro
kroner or note in his pocket there so
the problem with with validation is that
the same validation always has to be
performed over and over again and that's
probably why why it's easy to forget to
validate somewhere because you can't
really see the forest for the trees and
it ends up everywhere and the code if
you don't manage it so it's there
probably that's why it's so easy to
forget it because you see it everywhere
and then if it's missing at one place
it's hard it's easy to miss and it's
easy to forget that you also need to
validate from internal sources think
sources that you think cannot give you
bad data such as your database for
example I mean surely you valid that
you've sanitized and validate everything
that comes in when it comes up again
count can i really trust it well there's
something if you haven't properly
validated if if or if are the attacker
is really clever they can store scripts
for example cross-site scripting is a
typical web attack where an attacker has
been able to put some script text in
your database and then you show it on a
page maybe I say user name is it's a
script and then some JavaScript gets
executed and then you can you can attack
other users with this script so if we go
back to the circle of trust here we have
validation of a primitive
types like strings and integers you can
still be secure right if you remember to
the validation everywhere but it's hard
to look at a variable in your
application object to see if it's been
if it's trusted or not if you're dealing
with primitive types because they look
just like any other type what
domain-driven security says is that
primitive types and data structures are
untrusted by default if you see a string
and integer a byte array a collection of
whatever being passed into a public
function or returned by a function on
your object then that data is untrusted
and you you shouldn't really see it
there because you should only see domain
objects which I'll explain what that is
domain objects by convention in domain
during security have built-in validation
meaning that they cannot be instantiated
without being validating internally
first if the validation doesn't pass an
exception is thrown and the object Kadim
even be created so let's see here hmm so
inside our circle of trust then we'll
never see strings and integers being
passed around we'll only have proper
domain objects like the string would
probably correspond to an account object
an account number an integer can be an
amount object which is then properly
validated and the good thing with
domain-driven security is that you
automatically get data validation
everywhere it's not only where you think
that oh here's the trust boundary I'm at
a web service there's a trust boundary
here I remember to validate the input
data know every time you try to
instantiate a domain object it's
validated and you immediately catch any
evil data or out of out of bounds data
that come in so it's validation
everywhere not in the places where you
just expect the bad data to appear
because it's hard to understand where
all the bad data will appear so here's a
typical domain object then an account
number which is constructed with a value
and by convention then the domain object
is immediately validated upon creation
so there's no way for us to end up with
an invalid domain object here and
another not necessary but very useful
thing with with these domain
is if they are immutable I'm going to be
talking more about immutability later
it's basically that they they can't
change the internal state of the object
cannot change after they've been
instantiated so you see that string the
value here is a final and this is Java
the final means that it cannot be set
again and there's no setter for the for
the this value just a quick hands up how
many are programming in Java here all
right
c-sharp okay and the others all right
yeah okay so it's a well good match then
because there's gonna be some Java and
c-sharp examples here cool right every
domain object is validated procreation
there's no way for us by convention to
end up with an invalid domain object we
must of course remember to do this
validation in every domain object but
after a while it becomes second nature
when you do your object so go back to we
have an example we have a web service
that takes some untrusted soap data from
the outside we validate it we get a user
object count object what whatever but
when we get some invalid data it will
just bounce off as an exception and we
don't have to worry we can be happy with
this so another thing with this is that
these primitive types if you forget to
do this it really pops out so here we
have a reticulate function that takes a
spline and reticulated a certain angle
so you know what's up with angle it's an
integer well it's not a domain object we
don't we can't trust this is is angle
ought to be negative
what's the allowed range of angle maybe
we can only reticulate a few angles to
the you know left and right whatever
what is the allowed range in our domain
now the reticulate function has to
remember to perform this validation so
of course this is how a what it should
look like we should have a proper angle
object for our domain that is validated
with the allowed ranges or whatever for
these angles and I chose this example
just to highlight that something as
trivial and simple as an angle deserves
its own domain
and therefore validation or the other
way around and why not it's easy it's
cheap to create objects you don't have
to worry about a cost or overhead about
this and you'll get validation
everywhere so the domain-driven Security
Essentials the type system ensures that
the correct domain object must be used
we're not we're not passing in integer
strings whatever that could be and
whatever integer or string it has to be
that type of object so that's using the
type system and you know by convention
all domain objects are valid and of
course there are still business rules
but you don't have to worry about the
building blocks like the foundation of
your application those are still valid
those are always valid and the good
thing with when you do like a reviewer
software you know that you forgot to
validate something if you see primitive
types being passed around you're only
supposed to see domain objects so it
makes it really hard to see sorry really
easy to see where you forgot to do
validation and just one more thing that
I like to shoehorn into this domain
driven security discussion we're talking
about domain objects as the null
question
don't use null ever never let null carry
information and what do I mean by that
null is an error
null it's just a way we have to have to
denote that something is not pointing to
you as to anything I mean you know to
say that this does not has not been
assigned it's like a thing we have to
deal with in object-oriented languages
and you should never see null in your
code except for null checks in your
domain objects if you're if you you know
paranoid with your validation because if
if like typical bad uses of null is that
you want to indicate that something
doesn't exist oh I couldn't find this
object from the database I'll just
return null don't do that because null
leads to hard to read code and null
pointer exceptions where you cannot
separate an error state from a from a
normal state in your application so if
you want to indicate that something does
not exist use something like optional of
T it's in Java eight now it's a really
simple thing that you can write in
c-sharp as well because like passing
returning
it's like returning a burning bag of dog
poop okay if the if the coats clients
managed not to get burned by this bag
they're still left with this disgusting
smelly object that then they have to
deal with right just stump it out or
something
so don't be that person that returns
null the other time when you might well
feel inclined to return knowledge then
you get this oh this shouldn't happen
I'm really supposed to find this object
I'll just return null no just throw
don't be a chicken if this is an
exceptional circumstance in your
application well use the aptly named
exception and the throw the exception
you know what the world is not gonna
explode because you do that so here's
just what the optional class would look
like in c-sharp is it generic we can
create I have to ask the is it present
yes then get the value if you try to get
the value with it so for something
that's not present then you get then you
get an exception
so if you see sharp folks out there you
know there's something called the
nullable type like you can use for
primitive types which is really useful
if you're dealing with databases that's
the use case for watches which is what's
intended because databases deal in
inherently with null so they might
return null and it's a really nice way
of doing this but it's it's not the same
as optional because here's just another
horrible way of assigning null now to a
primitive type right you can like get
like null 2.0 in your application so
only use this at the fringes of your
application at the database or at the UI
layer but it can keep useful for UI
widgets like radio button on/off not set
any kind of thing so please don't don't
put this in your application make a
proper optional object instead so okay
that's it for domain driven security we
talked about trust domain you're in
security and I'm going to talk about
another pattern now that focuses on the
trust boundary itself because maybe it's
called the untrusted pattern where make
trust the first test concept at trust
boundaries the thing with domain driven
security it's great you should use it if
you can but maybe if you're trying to
introduce it into a legacy project it's
major surgery you might not even have a
domain object at all
right a domain model at all right so
where domain Durham and security is
defense like in depth everywhere the
untrusted pattern is more of a perimeter
defense where you just want to lift up
where the trust boundary is so it
clearly is visible in the code so let's
take a look at this function we're at a
security boundary here foo takes some
input bar bar comes from the untrusted
side of the trust boundary and that do
something with function is then on that
trusted side and the thing you see here
that you can't really see the trust
boundary right it doesn't stick out yeah
we're doing validation but so you know
something is is untrusted probably but
there's really no way of telling where
the trust buck boundary is so one useful
way if you don't want to if you want
want your code to be almost like
bytecode compatible is just to rename it
that's it's a pretty pretty effective
trick if you're doing like the slow
refactorings towards finding your
security boundary just rename your
variables accordingly if something is
untrusted why put untrusted underscore
in front of it I know this violates the
naming guidelines but hey it's pretty
useful so you know just ignore that rule
in your IDE or whoever complains so the
good thing now is that when you look at
a function here you have this other
function it takes some untrusted bar and
trusts your from and just like in the
spline angle example you know what's up
with data how come we trust it we trust
it obviously because it doesn't say
untrusted before it so now it's really
easy to see that we forgot to validate
the data byte array which is probably
bad because it's a full of buffer
overflows or whatever so yeah you can
take it one step further have the
validate method return the bars and
makes it a little bit neater but we can
do better than this there's really
nothing that forces us to do validation
here right we could just take the
untrusted and just assign it to bar just
pass it in to do something with function
no one would be the wiser so what if we
do this this is the untrusted pattern
here we can use the type system and make
a generic object I'm saying generic it's
the right thing yeah yeah generics I'm
my templates in c-sharp but it's
generics here yeah sorry so you wrap our
value in a untrusted container and we
want to make it so that the only way to
get the value out to this untrusted
container is to do validation so I'm
gonna show you how to do this in in
c-sharp let's take a look at the this is
what the untrusted class would look like
and do you see anything strange for this
anyone see any is does this class seem
useful at all how do I get how do I get
the value out of this because the getter
is private right so seems impossible we
cannot get it get the value out of this
untrusted box that we've locked it into
well in in c-sharp there's something
called assemblies assemblies is like a
jar files the packaging unit in c-sharp
and there are something called assembly
directives which is like the manifest
file for the jar file basically and
there's an assembly directive called
interns miss internals visible to where
you can declare that all the internals
the private variables of in this
assembly should be visible to everyone
in this other assembly so what if we
have an assembly called validation and
the validation assembly has a validator
class the DES validate of T and then
returns the value if it's valid
otherwise throws on about a validation
exception and implementers a validator
would then override the template method
inner validate to do the actual
validation so here the validator can
actually get the value because of the
internals visible to directive so it
would look something like this
we get an untrusted of string or the
account number is we have two new up an
account number validator and call
validate and then pop we get the trusted
validated value out of it
there's no other way for us to get the
account number out to the untrusted
container so we cannot technically we
cannot forget we've put our
straightjacket on ourselves and we have
to do validation which is great of
course we can do a do-nothing validator
it's a bound to pop up in the project
sooner or later that we'll just return
without doing validation but at least
you know you're cheating right so to
create these untrusted audits we need
some glue mapping code right we have two
new up these untrusted and then just
remember to to pass them in at the at
the untrusted boundary it's not a very
elegant a little bit clunky it would be
nice if this happened automatically in
the for as far as I know it can't really
be done in c-sharp unless you rely on
some framework feature like asp.net
model binding you can take your values
and then always like wrap them in your
motor binder and pass them to Assam
trusted or which is might be semi useful
because the validation is really good in
asp.net and we see anyway but do we have
any C++ programmers here in the chrome
yes all right the untrusted pattern is
is more elegant in C++ because C++ is
something called implicit constructors
and friend classes a friend classes
means that you don't have to declare
that the package scope you can say at
the at the class scope that this should
this should be accessible to validator
instances and implicit constructors
means that you don't need this this glue
code you can just declare your inputs as
untrusted or and then c++ the compiler
will understand that there's a path
through the untrusted constructor to
your object which makes a lot of people
hate implicit constructors which is
really complicated but it's very useful
in this case so I'll leave it as an
exercise for the reader to implement
this in C++ so right that's that's the
untrusted pattern again domain-driven
security really good for should be the
preferred method I think if you can't do
it try the untrusted pattern even by
renaming or just doing the pattern of
full out like this so I mentioned before
immutability which is really a good
thing and we've talked a lot about trust
and what we need to validate something
before we can trust it but what if
something can change after we validated
it when it's inside our circle of trust
how can we trust it then it's been
changed we haven't validated anymore
right so no matter if we go from the
outside to the in
in the circle of trust or from the
inside to the outside when you pass
something out the objects that we pass
over the trust boundary should be
immutable they shouldn't be able to
change otherwise you can with clever
race conditions bypass your validation
so let's take a look at this so maybe
your application handles concurrency
probably if you're doing your web
application you have hundreds of threads
how does that affect your validation the
thing you just validated is it still
valid that's the main question so we
talked about to talk to time of check to
time of use and you've all seen this
maybe without thinking about it here's a
typical method Java method that
transfers some some amount and first it
checks that the account contains this
amount and then it transfer it otherwise
you get a validation exception so we
have a time of check toc and a time of
use tou
but what if another thread modifies
amount between time of check two time of
use then you know we become millionaires
here so the problem is that we can send
it if the amount object is not immutable
then we can pass in an amount object
that passes validation but then it's
changed and modified before the actual
use of it happens this can of course
leave us this vulnerable to an attack
then so the solution well immutability
if the amount object looks like this if
we have a final here the value cannot be
changed and there's no setter but we're
good nothing can change between the time
of check to the time of use so get rid
of those setters right news final or
read-only in c-sharp immutability is
great that you're significantly reduces
the talk to problems it plays very well
with domain driven security as I
mentioned and readability
parallelization event sourcing etc etc
immutability should really be the norm
you should strive for it you should
should be so used to it that when you
see a mutable object something that can
change
you should just oh you should feel bad
and try to contain it and move it
somewhere else
let's take another
get a race condition here how many of
you know somewhat a racist condition is
hands up okay cool that's everyone so so
when when some output is dependent on
the sequence or timing or other
uncontrollable events that's a race
condition and in web software it's
typically than the web requests threads
right that compete race for access to a
resource so apart from leading to a
super hard bugs like heissen bugs that
you cannot debug you cannot get this
when you're debugging use often then
it's a security problem as well imagine
this you have a you're doing is like a
shopping cart a wizard there are three
steps where the user first enters the
wizard chooses a product and then checks
out here we have a static map of the
data we have to assign to each user each
user has an identifier which is say grid
or a UUID in Java unique identifier and
all you concurrency aware folks in the
audience you see the static keyword and
you're like how I would never put a
static you know in a web app that's you
know begging for for problems but this
could also be a service if you have a
dependency injection container maybe
your service is a singleton then this
would be just a regular instance
variable which it would be the same
because it will be shared by everyone so
it's just static for the use of the
example here so okay step one the user
enters the wizard gets assigned a new a
unique identifier get some some data and
gets the identifier returned and step
two we get the the key and the query
string probably from the user and then
now the user has chosen some product so
okay we update your wizard data with
this Product ID and then in the third
step here it's like a checkout step we
get the data out of the of our map and
we check that the user has access to
this Product ID and if she has sir he
has then we do something with it so does
anyone see what we could do here what an
evil user could do what if what if we
hammer the application with sending step
two requests to it
while we're doing the checkout we
understand I mean this is not
far-fetched to think that okay in step
three I understand that some validation
is going on because I cannot choose this
secret idea that I somehow I've learned
about so maybe there's the talk to
vulnerability here I'll just keep
bombarding my application with step two
requests while I do the step three maybe
I'm lucky and will inject right in
between here and I will actually get
access to this secret Product ID so the
solution of course is to make data
immutable so we have the example again
looks exactly the same but we have
something called immutable data now
instead the first step is the same the
second step here's the difference
instead of just a sign of changing the
Product ID on our existing object we
can't do that anymore we have an
immutable unchangeable object we have to
create a new one so you have some
convenience method on the immutable data
object that's called clone with new
product ID I guess it should be called
so it takes all the other fields I'm
sure data has a bunch of fields in it
and clones those and assigns a new
product ID and then we set that into our
into our map and the third step looks
exactly the same we still have the time
of check the time of use we can never
escape from that right but now data is
immutable doesn't matter how many step
two requests I bombard in the middle of
there I'm just going to assign a new
object and the validation and the the
check and the use is always going to be
performed on the same data so
immutability it doesn't solve all the
problems in the universe of course but
it's it's you can consider it as a
security spray it makes your code a lot
easier to understand a lot more robust
and it should like I said it should
really be a good reason you should have
a really good reason not to make your
data immutable it should be the norm
mutable objects something that can
change should be contained isolated and
only poked with a stick
so because a lot of time you mix it
right you have an object with a lot of
properties and many of them will never
change well then you know factor out an
immutable object of that put the mutable
state and another object that you only
touch at certain certain times makes
everything a lot easier and a lot more
secure should be the norm
that's it about immutability let's talk
about the final pattern here something
called the inverse life-coach pattern
and to understand the inverse life-coach
pattern we first have to look at the
life coach anti-pattern so the life
coach anti-pattern goes something like
this this is the life coach speaking you
have done nothing yet my friend but you
are already a success right no matter
what happens in bunch of code you will
succeed right and even if you don't I'll
still charge you it's awesome being a
life coach so if for some reason you
erroneously exit somewhere in bunch of
code and have before and have not said
success to false you will return success
true which is wrong right because it
there was not a success and this is a
large part of the go to failed bug that
you might heard about that happened to
OS X that made TLS validation in OS X
disappear that they added the the ant
the sorry life coach a life coach and a
pattern together with some dub duplicate
goto statements so what you should do
and of course the inverse life coach
well you assume failure you are not a
success you have to prove yourself in
bunch of code and maybe if you're really
good enough you really got what it takes
sure go ahead and return yourself that's
a success but we can do better this is
like a see example we are using a
object-oriented language probably so
typical pattern looks like this we fail
fast like we try check and assume
failure and throw an exception if we
something is wrong there can be a bunch
of these statement if not has ax if if
not you know account this allowed to
operate on this method if not if not if
not it should be really hard to to go
through this to actually go up into a
bunch of code and then if we against all
odds'
make our way through a bunch of code
then sure
return we don't return a success you
know did did it work true or false
no you should only return a proper
domain object the only ways of exiting
this function is either to explode in an
exception or to through a really narrow
path challenging path of success end up
with a valid domain object you should
you know you should picture the function
as the Atlantic Ocean and you are a
sunburned chain-smoking Frenchman that
has to windsurf across it that's that
narrow that's that's the path of success
okay so there's no way of you to exit
this without having a valid object we're
about ready to wrap stuff up I realize
I'm talking really fast but hey that's
how it goes sometimes
I want to there's there are five things
that I want you to take home with you
from this session
the first one is consider your trust
boundaries where are you placing your
trust
think about the circle of trust
everything outside is trusted you have
this small subset inside that's trusted
and validation is the only way of
knowing this where if your data is valid
or not
or trusted so really think about this
where are you putting your trust and
minimize trust of course you should
really try the manger of insecurity it's
easy it's simple in its it might seem
almost trivial you know of course yeah
just put some validation in your
remaining objects but couple that with
the mutability
and we've been using it for a while it's
just it's so great because you know your
objects are always valid and you can
catch your bugs really early and you
don't have to you actually get a bit
hooked on validation you want more
validation so and you if you see a
primitive type being passed drawing you
like oh what's this it's not trusted
it's so easy just change it to in the
main object it gives a great defense in
depth and like I said a few times
immutability should be the norm I try to
isolate your mutable state if you see
something mutable you should feel bad
something with setters right it's
horrible try to contain it and minimize
its spread because maybe you realize
that using
need that flexibility to have mutable
state you can kill it off yeah not much
to say about this one no this an error
it's an invalid pointer do not assign
any other meaning to null okay
don't it's life becomes so much easier
when you don't pass around now you don't
have to do now checks you don't have to
see that ugly word null everywhere it's
just gone you have to forget about it
you'll sleep better at night
everything's better use optional of T to
indicate missing values if a missing
value is an exceptional thing why throw
an exception and you know watch the
world burn it's gonna be great
fire your life coach be a pessimist
assume failure you know narrow path for
success you wind surfing across the
Atlantic you're a sunbird Frenchman blah
blah blah like that that's it
folks I hope you enjoyed it and that you
learned something new and you can apply
these patterns and concepts immediately
when you get back to your programming
activities
don't be shy feel free to contact me I
have like seven tweets there but if you
tweet I get an email so then I know you
you're tweeted me I just want to plug
this a little quickly here there's a
security de conference in November in
Malmo just across the water some really
interesting stuff there it's in order
them to check it out and please remember
to rate this session and we have about
13 minutes for questions so don't be shy
- have any questions thank you you said
you also do not that often no it's
that's why they're so useful I mean it's
it's I I like to talk about it's easy to
be like discouraged when you think about
security I guess you think oh well you
know it doesn't matter if I do this or
not because you know if someone wants
they can still hack my application but
it's not true it's not really true sure
if they're like a nation-state is after
you the NSA or whatever someone someone
who's really skilled and determined yes
they probably can hack your application
and your company or whatever but you
know it's the 8020 rule with a small
amount of impact 20 percent you get 80%
of the success so this just doing proper
validation find your trust boundary
immutability really simple things that's
gonna make it a lot harder for the
average you know hacker from I'm not
going to say a country just some
somewhere to hack your application so
yeah so do it it's it's you can really
do a lot with small things
yes I'm sorry there is if you're in
trust boundary you have validated your
data and it's trusted right there's
still business rules that need to be
validated but you do not have to
validate your data again you can because
it doesn't hurt but you don't have to
because you should you should trust your
system right you have a method you
should trust it otherwise you'll just
end up with validation a little bit
scattered everywhere on the code or on
the code but if you do this properly
then you should be fine if you have
something super sensitive
maybe you should add more layers like if
you have this critical part of your
application doesn't hurt to do it do the
validation again right because maybe
someone changes this object out there
and then you end up with bad data here
so but what I when I do this I I use
domain-driven security as much as I can
and then for for those more security
critical things I had a few more layers
right there like after when you're doing
your credit card processing whatever
right there just do a few more things
just be be sure belts and suspenders I
think there was someone no okay okay
yeah yeah I uh I want to stick my neck
out and question that I love it
if it's really if it really is
performance critical I mean I don't know
what you work with but it could work at
Facebook okay but I it's I just want to
caution against like premature
optimization that's you really need to
measure that and if fine if you know
unwinding a stack and winding intercept
exception is too expensive for you sure
but it's they used to be like talking
about Java that all exceptions are
expensive you can't use them you should
use return Valis that's like fifteen
years ago
you know it doesn't apply anymore so
but make sure just make sure by by
measuring that that's really the case
and then sure go ahead and do something
else but try to use to use these
exceptions as much as possible yes
premiere of you it's pretty hard to do
so let's say you have some object that
you have like ten fields and you want to
change one field then you have to make a
constructor
you have to copy the nine fields and one
you want to change yes and what I mean
so it's not easy at all I mean our
language isn't coke for immutability so
it's quite easy to say just do it but in
fact it's totally difficult I don't
think that's it's that hard actually no
it depends maybe if you have ten fields
maybe it's too much maybe you can
refactor into two objects of course it's
it's can be annoying you know making but
you can make a use the Builder pattern
instead instead of making a huge
constructor you have to call you make a
builder object that you set the it's a
pattern you can look it up but I I think
I don't think it's that hard I don't
think I'm sure they're built for
mutability it's not like a core concept
it's not a first-class citizen in the
language but I think it can be used
successfully without too much without
any pain the benefits over way the pain
there's no there are there is pain yes
but it's it's a good pain sorry external
dependency so it's quite easy to say
okay an ankle should be zero to 90
degrees or whatever but if you have to
check before you make an account does it
exist already then you have an external
dependency on the data
and you can put that inside the entity
because that would suck I mean so it's
not so easy as you put it because I mean
the entity okay I have I'm a valid
integer but maybe some other entity
already have my Mac yes yes of course
it's it's like the domain you're in
security ensures that your basic
building blocks are valid so yes of
course you have to validate that you
have access to these account and do
these just regular checks before you
create your even create your object yes
you should never call a service from
your domain to object of course not so
you're right absolutely it doesn't cover
everything but it sure beats the heck
out of having no validation and or
having validation everywhere so yeah
it's not a it's not our silver bullet
but it's really good I think well if you
have no more questions
I think we just say thank you okay thank
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>