<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2013 • Software Development in the 21st Century • Martin Fowler | Coder Coacher - Coaching Coders</title><meta content="GOTO 2013 • Software Development in the 21st Century • Martin Fowler - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2013 • Software Development in the 21st Century • Martin Fowler</b></h2><h5 class="post__date">2013-09-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TgdFA72crHM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so the first talk I'm going to talk
about is about stimulus data structures
it's a fashionable thing to talk about
because if you all know sequel databases
one of the things it's common to pretty
much all of the notes legal Perth
databases is that they talk about their
wonderfully schemas and all the
fantastic things you can have with a
scheme of us database the when a lot of
people talk about evenness I think they
miss out a lot of the subtle tips that
you need to understand to really stand
whether it's a good idea to be scheme
alice is also have it use it effectively
so that's what this my first tuple the
first of the talks is going to talk
about a little bit about this and then
dividing into two parts first some of
the talk about what's emili´s this is
and then in the second part I will talk
about when you might want to use it and
I'm going to move around the stage a lot
as I talk about if you cause I normally
do that but because it really makes life
hard for the camera so he's got to spend
a lot of time trying catch up so the in
thinking that he knows this let's think
about what we typically imagine in a
relational database scheme so we
typically expect so we create expand the
columns flat table you say what they are
we given a particular name and we give
some indication on tightly and then at
some point
users going to duct-tape all we have to
follow backs email and if we try to
insert something the reason and define
data schema their action could be
prevented from putting the data in them
now with our email a basis to people no
simple database of course we would store
but it's not over like in level we can
have records of people with different
fields and different capabilities and
that is the thing when you hear most
people talk about what they talk about
the great thing about schema business
and the simple databases say it's really
good because you don't have to fit
yourself to the rigid structure of the
relational database instead what you can
do is store whatever it is you need to
have in whatever form it happens to come
but there are this advantages being
equals let's imagine we just want to be
storing some data in a database and we
respond to find sort of updated with a
nice simple query and with a theory that
allows us to find records of interest
unless was one of those records is
effectively what
but there is some difference in schema
so in this case in America zip code idea
but I mean what do you call that is if
you can zip code you call it busco how
do you know which to match to and what
this leads you I think to my to think
about this is saying that the data may
not have an explicit scheme and it says
how you might want to store it but
there's always an implicit Stephen you
are making assumption whether do we use
the word zip zip code do you use to go
further to go or do we use both whatever
that that is in there in the data but
it's all implicitly it's not an explicit
thing and implicit schema is effectively
defined by all the code the accesses of
database all the go-betweens write all
the code that writes to it that's where
the immersive schemas is there and just
because you're using the disk emailers
database doesn't truly mean your skills
it just means that your schema is purely
impossible now talk about this in the
context of databases because that's
where the category is most at the moment
in terms of schema lessness
but if out the same ideas apply to in
them
programming as well let's look at an
example in a couple of well-known
programming languages and what you see
is we can define certain class of
objects and define Bonfield present on
that box that is it effectively for
schema and it doesn't help you just in
an object-oriented second old-fashioned
scene has the same thing scrubbers
anytime I'm defining those types you'll
define what you have with that with a
Steven and similarly in an in-memory
language you can also go Steelers and
you go schema looks typically by using
some kind of dictionary cache map
associative array something of that mind
and most languages have this is a
built-in data type or is easily
available for standard Bibles and that
allows you that same degree of
flexibility you can store other values
in the map don't have the predefined
them work redefining the fields and the
classes or struggles but the question
then is well what's the advantage of
doing what all the other is it really
about our difference between saying dot
something as opposed to putting
something in whatever the property
accesses where is the trade-off here now
in jail like Lele means if you get a you
the field explicitly you really want to
have a defined field again to this
explicit scheme available
do you go if you're using the dictionary
and you're putting daydreams when you've
got the same kind of implicit schema
that I mentioned in the database back
serve your honor
how do I know what I'm going to use the
first name I've got a decider what my
keys are that I'm bringing to that
literally and where do I find them after
I'm going to probe around the code find
whatever I'm using first name or
Christian name where do I find a logoff
they've got those around in the code of
other implicit schema but if I'd rather
defined class with clearly defined
fields then it's easy to see what I'm
using critical things now we're at it
should be really comes in useful is when
you're not actually explicitly typing in
the field name of a literal value but
you're pulling it in from some of the
source maybe you've got display options
of the user interface where you are
treating them as or securely dynamically
and you've got property name going to be
validly something of that kind in that
situation the that's where
the kind of implicit lookup is quite
useful on the whole my view is that if
you're using something like a map or
addiction rate and you're typing in
literal values of the keys that's a bad
smell that's an indication it should be
instead thinking about having to find
the others because it's easier to see
what's going on that way
now this because you're using loops of
properties this is necessarily mean you
have to use particular hash tag you can
most languages will give you some kind
of reflection capability which you can
use to get all the battles well so this
is definitely a choice between the two
and sometimes I find that the advantages
the other various things you've got a
trade-off now this is actually a very
bold trader on how that many years ago
kept their probes or best practice
patterns and he coined this is a
difference including all common state
which is when you have the defined
fields and their area state they use
them like a dictionary what it would you
know is at the variable state is useful
when different instances have different
things that need to be stored by
themselves and then it is in this very
mistake looking for the Hatrack but when
you know most of the instances having
same things but it had it behind them
clearly and we feel this and this isn't
an arrival or choice you can combine
both techniques in the same class so in
this example here I can have defined
feels for the first name and last night
we'll also include a hashtag in the
class for any other guys icons to give
so this allows the effectively to use
both happens at the same time now
just because I'm using both patterns I
can don't actually have to use explicit
feels the storage and with this example
here what I'm doing is saying I've got a
single customer class it's got an
interface looks like Lee uses explicit
feels but it actually stores all these
in an underlying hash map now this could
be quite a useful technique particularly
these days we're seeing a lot of people
store data in things like no single
databases in say a JSON format and then
pull it out to the user interface of a
service interface and Jason or through
civil page applications and take Jason
if you're going to do that you might as
well store the data in your objects that
we might want to manipulate as Jackson
as well or deserialized them in a into a
dictionary because that's kind of stuff
is easily built in the crucial thing to
remember about objects is that the
interface implement
two different things the point of
encapsulation is too high what your
actual data representation is and as a
result using the dictionary internally
but exposing something that looks like
fine fields from the outside is a
perfectly reasonable way to go that way
you've got an explicit schema of your
design fields but at the same time you
don't have to be always having more wood
copy into different data structures as
if flowing data through application so
here we see that you in memory
programming we can combine the notions
of the explicit schema muscles but you
can do the same thing even in the
traditional relational database and in
fact we do we see this all the time
there are free common patterns to how
this is done first one is to use
effectively custom columns but don't
really have a name of values by
convention within program another
technique is to actually have a custom
lengthy all when you then fill with some
kind of structure that allows you to
from the variable state in there so it
may be JSON data is better than within a
string fields of the back line this
second technique is the closest one to
the in memory technique
and a third approach is to use some kind
of associative lookup table that allows
you to add custom feel sensations you've
probably all seen this technique if
you've ever dealt with any large
relational database application because
there's always a need to put this stuff
in and require discipline is a plum wolf
really rather clunky mechanisms this is
where if you find yourself having to
lose a lot you begin to feel that the
need for some kind of evil as a problem
step but this is really just where kind
of hacking schema lessness
into the relatively inflexible and
fairly rigid relational structures so
covering what I would make so far we can
do schemas and steeples and spoken
databases and in memory and it's not
necessarily essential is between one
with the other we can combine basic
scheming and variously the one thing
that's been there - what I've said so
far is if we've seen the schema as I
think our vows a storage scheme but what
I mean is my storage scheme it is it
says if I want to store some data in my
store we're prepared in that we store or
add a base for the schema will prevent
me from storing something that doesn't
fit that's how a relational schema
operates and it's effectively how
defining
some fields in a record structure or
glass works in memory as weapon
you can't fit something in there isn't
it but that's not the only way that we
can use a schema and that's common we're
using this key map but also what a
useful way is what I put a predicate
Steven now in a prayer good scheme of
what you're doing is your allowance
anything to be stored in whatever your
storage mechanism is but the schema is
can be used to detect what shape of
things it is so that way you can detect
have I got anything that doesn't fit the
definite defined bounds of running in
place
I might store something that says zip
code even though my schema says zip and
then as a separate step I'll go through
inside does anything not fit the schema
or perhaps when I read the data I can
first test to see if it fits the schema
and then if it does I can make certain
assumptions about how to deal with that
data now previous leaders have a
relatively unusual but long way so you
may run into them is something like
ex-felon if you've got some kind of XML
data it's just text you can store
whatever you want in them but there are
various ways to test xml against the
scheming now the best-known one that is
I guess these days is XML schema perhaps
because it's got schema reads night but
it's not the terribly good schema
language and the one I'm showing here is
something called relapsed
application which is a much nicer schema
notation that's easy to read and
understand and this is your way to have
men tested xnor government say does it
have schema
this brings up an interesting point the
when you've got things like predicate
schemers you don't have to limit
yourself to only one schema definition
language for the kinds of schemes from
regular you can use different schema
definition languages depending on the
three contexts and leaves what law you
can actually separate the schema from
the storage in order to be able to have
different schemas for different
circumstances so here are my basic
appointment schema but I have another
scheme of it says let's take that basic
one and extend it because I wanted to
have a confirmed appointment I need to
actually define who the physicians as
well as the patient information and so
this allows me to take the same data but
have multiple schemas that I can test
with that depending on where I am in the
process of the diamond looking with this
is actually a very valuable thing
because it introduces the notion of
contextual validation now what I mean by
that is when people talk about whether
they want to validate I think they often
looking it is a purely behind everything
some class record or piece of data is
valid or not but that though that works
a lot of the time
isn't really a very complete way of
looking at things usually when you want
to validate something the validation
rules will change coins in a particular
context you want and the context is
usually if something you want to do some
action we want to take and so validation
rules you may well have multiple
different sets of validations for a
particular thing so if I've got an
appointment
I might have one validation it says okay
equipment is set up and ready to go and
different validation but it says no Kay
this is confirmed and something's that's
actually going to go ahead and the
validation rules will suddenly get them
now always talking about the storage
Stephen is saying that context the
context of this validation is I'm
allowed to put it in the database okay
and this is I think where a lot of
people go down a route is that they put
very strong rules on this validation and
storing something in the database often
it's useful to have relatively weeks
rules for storing it and then the album
follow up with validation checks later
on to say is it actually of may have
stored bit but is actually something I
can do something with and what is that
thing I want to do if I'm storing a tall
order information is it enough for
nothing
like an action ship the order is enough
information perhaps that I can demand
payment and calculate a price for it or
am I still unsure people are often
reluctant to store partial information
things of that kind and that's because
you confuse the rules further the
validation step of story
with validation steps of the actual
actions you might want to take so that
schemers I hope that given your senses
there's a lot more to schemers than just
the notion of what a relational schema
might be they're actually quite
interesting and subtle things and we
could arguably use the book more widely
in our programming anyway as a way of
trying to describe the rules the
validation things of that kind
now I want to move on having sort of
talk about schemas to when we might want
to use a scheme of us approach as
opposed to using actually defining a
schema so to start with I think of when
what what is the consequence of us going
with something's even saying that we've
got the customer and we're just going to
make it a hashmap monopoly define class
or make any scheme already picked back
up
the question then comes in and I've
alluded to this molecule times reading
is what are the legal fees by which I
can access that asset have one find that
out well I've got a look through the
code
there are all the places in the code
where I access that customer and there
could be a lot of code I've got thumbs
around the triumphs are no spots so my
general advice as a kind of first
approximation is to say don't go with
implicit schemes because if you've got
an implicit scheme that you've got a
further round the local place to try and
find out that legal value to have some
form of an explicit scheme if you can
that may leave some divine storage
scheming or it may be some way of
testing against the predicate but have
some ways people know to them say ok
what my call is what one of the zip
codes you who are going to come make
that as explicit as ok and it is
certainly a common theme that I've run
into where I've talked to projects have
used stimulus solutions where they say
yeah all work really well for a while
and then we'll started having great
difficulty trying to find out what was
actually being stored in a database an
explicit scheming of the deal but that's
just personal there are cases where
having a sequel is approach can be done
an override the general advantage of Nyx
person schema and I'm going to boil this
down into this bunch of places here the
first has a grave case
is cases where the data you're actually
storing isn't uniform if most of your
data has the same fields then it's easy
to see what to do with it with 16 but if
you get very information from instance
to instance then having a big schemer is
it's just too hard because you've got to
come up with some kind of flexibility
mechanism and relational modest resource
particularly ugly
there's too many situations where you
get this kind of non-uniform data first
places where you want we will be able to
define custom feelings this is quite
common in products and where different
customers want mater slaughter for
custom values where you find in on
various of situations as well whenever
you have this kind of custom field
that's a situation where you may want to
use and somebody's skinless approach at
least all that custom fields part of it
and this is again going to be very
useful to find a way to combine both
fixed and variable state the other
situation is where you've got different
types that are very variant in their own
codes a great example of this is if
you're doing some kind of event booking
where there's an each event type
character zone different kind of data
they can vary quite enormous ly between
the different kinds of events you have
to lock in that situation again email us
approach can be very handy now you know
main reason that I hear people talk
about the benefits of going
us is in it comes to migrate as you want
to change your data storage needs over
time if you've got a skinless approach
this is correct if you change your data
structure you can to store that change
data structure and have old versions as
well as new versions in the storage area
but I think this is actually somewhat
oversold advantage because the problem
with schema migration is instilled of
implicit schemas the world's worse
they're changing over time on you now
you can manage this to some degree if
you instance just rename zip code to see
you can actually have a reader that's
able to look for either value and then a
writer that only writes a new value so
you get some flexibility baby but as you
get to more complicated migrations you
do reach the point at which you have to
do a more formal migration step and when
it comes down to it it's not necessarily
in terrible content in exercise other
people say or probably and fix in the
databases such as relational databases
is that it's very hard to change the
scheme your own time but actually that's
not terribly true a projects that we do
in forwards we change our seaters all
the time as far over we've had sheep as
part of an agile way of working and in
juggling requires is the discipline
practice of scheming migration what
boils down to making sure that every
time you change a schema it's log tied
in with a version control system when
you use lots of small migrations every
change that we make of my graphic data
and then you can change from one version
of the database to another by composing
migration
together I've lost over the process that
we can find details of it in various
places but it's it actually a very
well-known technique and the same
technique really has to be used for
those sequel schema little databases as
well
eventually all of those special books to
deal with old versions of the data get
too complicated and it's better just to
migrate the data and then only have a
simple mapping to the up-to-date
structure so you pretty much have to go
through the same vibration process with
a schema database as you do with a fixed
schema today you get a bit more
flexibility you don't happen every time
but eventually you're going to have to
pay that pulse and so as a gaining
common people see my here for our
project you see schema those databases
we still have to worry about migration
it doesn't go away but on the whole use
an explicit even as much as you can be
very clear about like you'd expect the
store in sculptures use the implicit
schemas really only in the places where
you really need that ability to handle
the long uniform data and answer the
first part of talk if you look want to
review the stuff that I've gone through
in general
page on my website I put to where my
notes are but I actually have a info
dead version of this talk that you can
read through it's got reading stuff
they're not just be talking and so
you've got a better deal going through
them too so for the second sole
ownership into a completely different
mode first one was on a very programming
and toning and this is going to be much
more process like and took a bit more
about agile stuff and this one is really
very much influenced by a paper verbs
appeared about a year ago about levels
of agile fluency it's a paper by Dianna
Larsen gesture two people have been
involved in the agile offer a great deal
of time and I first saw it when they
sent it round there is people just
looking for comments and I asked them
have you cycling and published this
paper and they said they happens in my
office on my site resin alien publishing
you through a fellow and I was very
happy when they did that because I think
way of thinking about how teams a dot
and workings want to be in the agile
adoption process and I'm going to talk
about that before I talk about that I'm
going to talk about what I see as their
essence of what agile software
development is about and I think it's
important to talk about the essence
because it's something that easily gets
lost in all of the Chinese whispers and
stuff it's gone from ten years plus of
the of the agile mode so to think about
there about what a journey it was easy
for me to think about very painful the
idea is to kind of coalesce to agile
software development appeared in the
1990s and their result of a bunch of
people relatively independently doing
their own things and developing stuff in
the 90s in general situation for
projects for the problems projects for
the problems there we hope the agile is
make things a little bit better but
these problems would certainly very
apparent them as well but at the time
the
what cue was those problems and that was
because there was a plan driven
processes capability maturity bubbles
very much is this idea of the buying
processes we need to get get rid of the
human elements we need to define steps
people could just follow to come up with
plans and designs in advance the
programming is really just something we
can kind of ship up some minor
organization preferably in a third
country where we pay them less and it
was really seeing that kind of white and
that was sensitive if we wanted to cure
the problems of software development
that was the direction together but the
people who are working in the agile
world said now we have a different
vision and it was a vision that was put
together in the agile manifesto but said
they have a different way of thinking
and when I also came across agile
methods in the late nineties one of the
things that struck me was how they
related with each other and I ended up
writing an article about this and
chuckle the new methodology because I
wrote this before the agile manifesto
came out and it was my attempt to try
and synthesize together and the thinking
that led to agile and the way it is
there was really a distinction between
agile and climb driven approaches quite
thinking and there were two main areas
where they did it the first was that the
agile world was adaptive in its approach
to planning while the wonderful world
was predictive and the second was that
the
was very much more ranging around people
in front while their plant in the world
was a rebel process I'll explore what I
mean by those things in little bit more
detail starting with money in the
between name plan driven world it was
very much operating on the basis of
first you plan your work then you work
your plan come up with a plan and then
carry that out and the two were very
much separated steps and this is what I
thought it was predictive planning
because the idea is it all went well
everything goes according to plan and in
fact the way in which time to process is
typically measured success was according
to plan whenever you hear someone saying
we were a long time and on budget the
project and therefore succeeded that
productive planning thinking but says
successes we follow along with went on
in the planet and this is all very well
problem is the plans that people made
had a very strong dependency on the
webbernet one of the school requirements
good ends even the word required if
you're going to come up with a plan
behaving to do something you need to
know what it is you try to build but the
problem of course is not just as this
entire plan and about you into my
software development process gets tied
into it and the problem then is do we
have actually have stable requirements I
always like to do this how many of you
have been on a project recently where
you require to be very unstable making
changing not nearly everybody
and that's the God that's the kind of
that where this whole thing breaks down
so 100 people said okay we're going to
stabilize we've got to get rid of this
requirements churn and we come up with
all sorts of techniques about getting
rid of that or stopping it the agile
approach is to shift away from that and
say well in software development is if
Heather depart requirements ability and
that's causing all these problems
maybe what we need to do is break in
evanston and instead find a way to get
rid of that link so hence the subtext of
the subtitle of canned export on extreme
programming was embrace change let's
look at changes something that we can
work with instead of something have to
prevent it and that shifting mindset is
very fundamental to the whole of
thinking of agile and in fact it even
goes beyond that - my favorite quote of
very often is let's actually take that
change and see if there's something good
something that gives us advantages
because we can respond to that and so as
a result if you're in an agile
environment you can't climb successes
going according to plan and in fact if
anybody says forward when project
morning's black that's really nonmetal
and you're thinking and you're pinning
says success has to be find define
something differently you know but we
were just so beautiful value for the
business of something about time where
it was according to plan or not is kind
of irrelevant because the plan has
changed
20 or 30
times so you actually did the first
version of the planet the other notion
that I rather like was a project
management said to me once a plan is
rather Lycabettus it looks good on the
day you've got it
after a few days it's looking rather
wrinkly and chrome around the edges and
after a couple of weeks it's
unrecognizable and that is again you're
thinking doesn't mean you've got one
what but it's a changing thing two very
different attitude detectable so that
says a plane is adapted it's about
understanding the consequences of change
and making informed and control
decisions about change instead of a
predictive thing that says this is how
things will work out and if there's a
lot of white light too hard to go down
DHL group we wouldn't like it if proved
things go according to plan we like
predictive running we hate it when
people most people tend to dislike
things are being unpredictable in this
one the agile way but mindset I think
you're saying well yeah we now see we
could do predictive plans and all of it
that way but sadly reality forces are
working different moment moment in time
but it's not an easy thing to say not
necessarily need to be to do anything
that distinction is easy to say but hard
to do the second one the ship to
people were some processors is even hard
even stronger now here lived a spoiled
part of usual line which is to say who
is this person who is this person
Taylor Taylor then to say he is going
kind of a scientific management
basically saying we passed in the past
before he started operating in the late
19th century people would decide how to
do work themselves the man but now we're
coming to a system and we make mended
the system essentially what it says that
if we want to if we think about the
software process terms so when we remind
software process as some combination of
steps and links between steps we now in
the languages you saw lots of diagrams
like this except there will be words of
course in the boxes the words usually
didn't really mean that much so I showed
without and so there are a bunch of
steps and we find a bunch of people
that'll totally classify me the project
managers the programmers testers
business analysis whatever your
classification might sting and way with
all project team is we get all the
people
fitting them into those appropriate
boxes the notion is the process comes
first the people let us watch it and go
with it
they're only agile marks have completely
reverses it says if you want to do a
project in agile terms the first thing
you think about is assembling the team
of people who are individually good and
work well together a human level and
they get on with each other does it work
and then once you've assembled your team
the team decides long process language
to follow they come up with a process of
suitable for the problem they're working
on unsuitable for them different people
will choose different ways of working
because different people are different
and when people work together they will
work in different kinds of ways and
that's why my view it's completely wrong
to inform to push and command the team
to go Roger a team has to choose it
themselves
if you're pushing the process of the
team that's fundamentally and
and so a long time I hear people saying
well agile stairs I've got to do this
and therefore the team has to follow
certain steps that's where the thinking
has gone backwards the team has to
decide what to try out and if the team
chooses not to do agile because it's not
going to work for them that's fine too
it's important that the team makes that
decision another element of this is that
it says in the end the quality of the
software team is going to depend very
much upon quality individuals in 90 a
lot of thinking in the plan driven
approaches so we actually don't care
about having good people in fact good
people accountable so rather not
happening and because they tend to be
argumentative want to do their own thing
and a customer or so why have a process
that works pretty much any bonking part
the other thing people will say no that
wasn't necessarily work terribly well
and the value will be want to have a
very effective group of people you need
to have a tip you're new
actually need to go out again and then
those good things don't work in
particular why thanks to need to have
them define how the process works and
it's a girl eyes I think well oddly at
the limits of we're aware when away you
should or should you handle processes
how in the early days you who said where
are the boundaries that I chose
appropriate process views people might
look at the kind of problem or the size
of team as being the typical boundary
areas most of those boundaries that we
crossed but the one boundary that is
being very very solid really lays in the
nature and culture of an organization if
you've got an environment is very
distrustful it doesn't really is
interesting if you being people oriented
that would be a hard barrier making
agile work
it's that cultural element that really
is the dominant one and certainly we've
seen that at the pub of organizations
we've spent a lot of time forwards
helping people go beyond your path and
valleys not the clearest of weather
thing goes wrong if you're in an
organization where you
build up trust you can't build up the
mutual respect but now it's a huge
barrier to overcome and cultural change
of organizations is the longest and
hardest thing to have to do and that I
think is a big is very gradual but let's
move on to the next part which is this
notion sadness is a model developed by
Banamex on the PI particular device
sorry
and they said they Nazis really as they
look at the various teams of a scene
they have observed they defined as four
star points of how the teams operate the
very careful to avoid the charity levels
and things of that kind in there my
words I'll try not to use that word
about it kind of obviously lead to that
point everything has to pass through
these stockings but teams don't always
make it all the way through happens
optic ok want to make a big way through
so the first not levels of the one star
point is typically a team that is
getting the kind of basics of the
management processes of our job
employees they've broken their work in
two iterations they have a certain
degree of some degree of self
organizations they may not be that
strong but the key thing is they're
choosing work it's all chunks usually
with some kind of iterative approach and
then delivery knows
chump and they have the ability to begin
to shift direction that adaptive
planning thing is beginning to kick in
where they can actually change their
minds and they're starting to talk about
they're doing in terms of business
features as opposed to software layers
and things back so they've been a bit of
operating at this level is you have this
visibility as to what the team is doing
even if you're not part of the team
itself you can begin to see what
features are being built what order they
get built in you've got some ability to
control that you begin to say oh I gotta
push this one feature forward push this
one back and when the team reports her
what it's going is typically doing them
in terms of these kind of business value
driven features that are describing it
now again here requires as any of these
monsters a certain degree of investment
you've got a big lesson in how the team
operates and how it develops and also in
kind of the basic look processes get
there and it's going to take a certain
amount of time their observation is to
get to this point teams usually take a
few months of preachers con portable but
a large family teams reach this level
and I can't stay this way the Avera
estimate lesson is just under half team
times beginning point you can also look
at this point as this is typical of the
team that has taken armed scrum and just
vanilla scrub as it were it's doing the
various things that described by I'm
scrum but it hasn't gone for the some
more extra things of wonder building in
particular the technical practices the
team like this has done
let's go sorted out but not any of the
technical things to discuss moving
development and all things about kind to
go to that level that is there the
second star level and this is a hard
step to do less teams get your star and
also it takes a good bit longer we're
talking perhaps about years the
investment is now much higher because
you've got to develop all these
technical skills you've got to figure
out what is continuous integration
what is continuous delivery get those
work you've got to get the factory spec
going to get testing developers right
you may want to explore things like air
programs back time you can understand
how evolution outside works they are
operating in front of one but the better
you get from it is how you get a much
more productive team more noticeably you
can get at it with a lot less defectors
this is one of the things that certainly
strikes me very much when I talk to
agile teams and often what I hear from
reasonably well performing teams on the
technical level is how they go into
production with far less defects and is
difficult for their organization that's
kind of an interesting thing because
something that people often say our
agile is kind of loosey-goosey not very
and you would expect you get problems we
have politic but actually a good
performing adulting might have
strikingly lower details and that's
because of the Empire things on testing
and development these other technical
practices the ship that this leaves from
visible sense is that you get to the
point where a team can effectively do
their shipping there
not on whether the software's ready
but when business wants those shipments
to make this is what the phrasing they
use is the market cadence it's basically
saying we can go live whenever you want
to it's really narrow businesses you're
not a technical limitation and this is
where you see team should be maybe every
couple of weeks and going into
production even more frequently while
often run into teams where they will
commit to production every day or
something of that kind and that is it of
course the technical practices the
quality is allowed to get in point where
they can do this we like young slide
these two levels obviously the second
level is of Watson periods of a first
level but not as even as I've indicated
not every team gets that sector model
the perhaps Niagara team wants to try
again to upload there is significant
investment in getting to that second
level and you are typically pass the
diverse work before you get to the
second ball but you were thinking when
you begin do I want to try aiming at
second level because you've got to make
those kinds of investments on the
technical practices who have gone the
third level in there of all this really
switch is more into the thinking of this
way we need to get into the Lean Startup
kind of territory that says at this
point up to the second level you're very
much you deceptive of what the business
what business people say this is what
you should be building we have a good
conversation but you very much all
either love ideas once you get to the
verb that you begin to initiate a much
more the team is actually taking much
more active role in saying this is what
we should be building and they're using
techniques of commanding startups as a/b
testing the things that kind to try and
decide what the good thing is to do
burnishing this point is a lot more
effort over the amount of time so
they're several years and very thick
teams actually get this done and there's
a large family investment involved
because in order to do this people
within the team must be much more aware
of what's going on in terms of business
and I have to take a much more visible
role in an organization of the local
company the first two levels you can
kind of do within a relatively small
bubble it's really having a good
software development ng is really what
that second level says this means taking
inverter has a bigger impact on
organization so a lot of organizations
are just not ready to go this third path
and often I think it's important when
again when working fluid outside are you
in an organization really tolerably the
blue is the letter are they ready to
take this on mostly
yes they're going to say no we're not at
a point where could actually go for this
point burn the advantage and the big
benefit is is you get a much much more
focus on building things are more
valuable because the team is making is
much more engaged in the process of
making these compositions
now if although is really a much more
broad of organizational view this is I
mean the test at this level is this is a
team that would spontaneously disband
the project they're working on because
they realize the entire program work
that they're doing is the most valuable
thing for the business and they should
just and themselves and work of all
proper things
it's questionable whether they mean and
that whether this video to even be there
because they say they haven't really
seen this at this point and the comment
in the paper is where we've seen this
the obvious scene is in small
organizations where really you can tell
the difference between the third or
fourth level so this is a scum of
speculative idea of where the next level
I think that's what not gonna spend a
lot but I think that that model of
thinking about agile fluency is a useful
one to think about it's worthy to need
something something that seems to match
a lot of people's experience in practice
as I've talked to people a lot of people
said
model makes sense to me it's something
that I've seen resonates in my
experience and it also gives you an idea
of where you might be awakened we want
to be going within the organization of
your party what is a realistic level to
payment what do you want you'll be your
expectations about how long it takes to
get there and I think it grabs from the
point that this is not a rapid process
in order to get even to a two-star level
you're taking typically a couple years
to the team so I can you get to that
kind of point it's not unusual to get
spend a long time getting it and I think
that's a useful thing to point down to
other people who love the feel that
going agile is really very
straightforward it usually isn't because
that shipped from saying you want a
planning process not to be a predictive
thing that is much more adaptive thing
and we really are people first and let
them decide how they want to work those
are the very big shifts shifts our
organizations don't findings so that's
so I have my decimal decent westerns are
which time the vessels but led to an
outside
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>