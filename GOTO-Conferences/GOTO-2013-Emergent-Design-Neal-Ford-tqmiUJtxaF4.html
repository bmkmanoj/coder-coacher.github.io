<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2013 • Emergent Design • Neal Ford | Coder Coacher - Coaching Coders</title><meta content="GOTO 2013 • Emergent Design • Neal Ford - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2013 • Emergent Design • Neal Ford</b></h2><h5 class="post__date">2015-10-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tqmiUJtxaF4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is a subject that I've done quite a
bit of research and development on and
I'm continuing to do research and
development on this and in fact I've
done I've been of writing about this
subject on the developerworks site I've
written 20 installments around this
subject you can get to it through this
URL but that's hideous and awful so I've
used modern technology to shorten that
and make it more accessible and so you
can read a lot more about this topic
there if you're interested in it my
agenda this morning is to talk first
about what is software design what do we
mean we talk about design and software
then a little bit about the distinction
between architecture and design and it
turns out there's a particularly useful
way to distinguish between those two
things that allow you to think about
them separately which is very often a
useful exercise to perform I then talk
about things that make you emergent
design hard I talked about some things
that make it easier and then I talked a
bit about once you've found these design
elements what can you do with them how
do you harvest them and how do you take
advantage of them but I'm going to start
with the poetry of Donald Rumsfeld who
very famously said there are known
unknowns that is to say there are things
that we now know we don't know but there
are also unknown unknowns there are
things that we do not know we don't know
and he didn't realize that but he was
really talking about software here
because this it turns out is the deadly
thing in software it's not the known
unknowns because you can make
contingency plans for that you know we
don't really understand how that works
so let's plan some time to research and
develop that and think about it it's the
unknown unknowns that end up killing you
and in fact this is the thing that
ultimately kills any kind of big giant
upfront design effort in software
you always get nabbed by the unknown
unknowns and so in the agile space what
we've realized is that the future is
really really hard to predict and in the
traditional architecture world what
they've been trying to do for years is
make their crystal ball better by
applying more and
or rigor to it and we've been doing
something different we've said you know
the future is really hard to predict
what if instead of getting better and
better at predicting the future we get
better and better at adaptability as we
go and then you don't pay quite such a
hard price for having the unknown
unknown pop up because you're a lot more
adaptable that's exactly what this talk
is about is how can we build techniques
for adaptability in the software so that
we don't pay these huge prices for the
inevitable unknown unknowns that are
always lurking right around the corner
but before we get too far into that we
really need to answer a fundamental
question like what do we mean we talk
about software design and fortunately
someone has answered this question for
us back in the fall of 1992 in the C++
journal Jack Reeves wrote a very
influential essay which you can still
get at that location it's still worth
reading because you would believe that
it was written last week and you make
some very observations in this paper
because what he's trying to do here is
do a deep metaphorical comparison
between traditional engineering and
software engineering we do lots of light
metaphorical comparisons about you know
our job is like building bridges or our
job is like gardening or mountain
climbing or all these kind of very loose
metaphorical comparisons but you want to
go a little bit deeper and see how
things really are similar and how things
really are different and he breaches
some interesting conclusions the first
one being that's the final goal of any
engineering activity it's some type of
documentation if you're a civil engineer
and you're tasked with creating a new
bridge what is your outcome for your
work it's a design for a bridge in a
particular location that operates under
particular constraints that has
particular scalability characteristics
but you don't actually build that bridge
you hand it over to a group of people
who are expert bridge builders and you
turn it over to a manufacturing team and
so the output for the engineering effort
is this design that you handle and an
engineering team it actually ends up
manufacturing it but here's one of the
places where the traditional world in
the software world differ a lot because
for physical things means stamping out
atoms and it turns out that once you've
stamped atoms into a particular shape
it's really hard to understand them to
searching a resampling in a different
shape you have to do crazy things to
like melt them or change their chemical
composition etc but we don't live in an
atoms based world we live in a bite to
base world and bytes are super soft and
malleable and you can change them all
the time the drop of a hat that's a very
different thing from our world in the
traditional engineering world but then
you have to ask yourself so what is the
analog in the software world to that
manufacturing process that traditional
engineering goes through it turns out
it's the compilation and deployment
process that we go through that's the
thing that takes our design and
manifests it into something that moves
things around in the real world in this
case electrons through wires etc which
suggests that our design our blueprint
our outcome for the engineering effort
is the source code the complete source
code this is our blueprint for software
and any change that changes source code
changes our design every time you make a
change the source code you're changing
the design of your piece of software so
debugging is part of design Quality
Assurance is part of design because they
make changes that yield changes in the
source code your software that is your
design but here's where we really differ
from the traditional in manufacturing
world because the most expensive process
in the judicial engineering world is the
stamping out atoms part in fact a lot of
the techniques of predictability that
were created in the traditional
engineering world were not created to
make things safer they were created
initially to make them more
cost-effective because it is simply too
expensive to test bridges by building
new bridges and rolling heavy stuff over
them to see if they collapse or not
that's a terrible way to build bridges
but we can build software like that all
day long because there's virtually no
cost to remanufacture it we just fix the
little hole and remanufacture the whole
thing and we have a realistic kind of
world again our manufacturing is dirt
cheap in fact every time you stop typing
now
an army of gnomes inside your computer
springs to life and manufacturers you're
designed for you and Jack Reese
concludes as essay by saying that given
that software designs are relatively
easy to turn out and essentially free to
build an unsurprising revelation is that
software designs tend to be incredibly
large and complex I think they're likely
some of the most complex things that
humans create because we don't have some
of the same constraints that other kinds
of engineering has for example we don't
have the same kind of locality to fault
that traditional systems have so if a
wing falls off an airplane a forensic
engineer can kind of go to where it was
connected the airplane and deduce that
there probably is a problem around there
but in software some little fault can
cause an instability that doesn't
manifest for a hundred thousand lines of
code away so it's very hard to trace
down exactly what is that problem it's
also extraordinarily fragile we have
very very fragile breakage points in
software unlike in traditional
engineering world so the software
designs tend to be these giant large
complex things because we don't have the
same kind of failure modes and the same
kind of constraints that would keep them
simple that exist in the real world and
his ultimate conclusion because the
software may be cheap to build but it's
incredibly expensive to design because
everything you're doing is basically
part of this design process in software
so when we was talking about design he
was really talking about what we talked
about now encompassing all of
architecture and design and all the
things that make up what you're doing as
you create new software but I want to
make a differentiation here between
architecture and what I'm calling design
unfortunately design is one of those
mega overloaded words because Jack
Reeves uses design as basically what we
call architecture and design all the
things that go into software when we
think of design now we think of user
experience design and the the kind of
user experience interaction that's not
the kind of design I'm talking about the
differentiation I want to make here is
one that Martin Fowler makes in his
white paper called a who needs an
architect and it is actually the basis
for the title of the developer work
series
that I showed you in passing earlier
it's this idea that in his a whitepaper
who needs an architect which is really a
white paper about the role of architects
on agile projects he kind of
incidentally gives some definitions of
architecture and one of those is my
favorite definition of architecture and
it leads you to this very useful kind of
ability to cleave this definition in
part is that the architectural elements
and a piece of software are the things
that are perceived as hard to change
later and that in fact leads to the
title of that developer work series I
don't know if you noticed or not was
evolutionary architecture and emergent
design and there's an important
distinction between those two things
because if the architectural elements
are the things that are hard to change
later those are represented here in kind
of these gray boxes everything sits on
top of architecture you can't have
emergent architecture because everything
rests on top of it but you can't have
emergent design so the gray boxes here
in this very abstract picture represent
architectural elements you can't start
shuffling those around without making
everything unstable so the things that
are sitting on top you can you have much
more flexibility of moving those things
around and so you can kind of ask
yourself when you look at your software
stack wotz architecture versus design if
it's hard to change later than his darka
textual so your language is certainly
architectural the web framework you've
chosen as architectural because you
can't trivially change that for
something later but the way you're using
those architectural elements so your web
framework the way you're using the
workflow and the validation and all
those pieces that come with it those are
really aspects of design and you don't
have to get those nearly as correct
because the penalty for changing those
is not nearly so high because other
things don't rest on them and depend on
them so the real trick in this world is
can we build architectural components
that are simply enough that we can
evolve over time because the second half
of this definition is ideally you'd like
to have as few of these things that are
hard to change as possible because
architectural elements give you useful
scaffolding it's things you don't have
to build yourself but they also
represent constraints and so what we'd
like to have is the most benefit with
the fewest constraints and that's
the way we try to design things and we
make this split between evolutionary
architecture which is very much in the
kind of micro-services rest and
component-based worlds the previous
speaker was talking about and that some
other people in this track are going to
talk about later today I'm going to
focus mostly in this talk on this design
aspect and in particular emergent design
and so let's talk about some definitions
if you look at the word emergence that's
basically the root word of emergent or
vice-versa and the definition from
Webster says rising or emerging out of
the sizzle but something about fluids so
I'm going to selectively edit the
Webster definition to get exactly the
one I want which is rising or emerging
out of anything that covers or conceals
or comes to light and there's another
Webster definition that's suddenly
appearing arising unexpectedly or
calling for prompt action both of these
aspects turn out our part of this world
of emergent design and I'm going to talk
about two different aspects that I will
do a much deeper dive into during the
course of this talk and here's the first
one let's say that conceptually it's
your job you have a problem that looks
kind of like this and while you're at
work you're thinking about this while
you're driving home you're thinking
about this while you're mowing your yard
you're thinking about this when your
spouse is talking to you you're supposed
to be paying attention to them they're
still part of your brain and still
working on this because you know that
there's some sort of pattern and all
this mess that you really can resolve
you think about it really long and hard
and finally some sort of useful pattern
or hierarchy comes floating out of that
that's really this exercise of taking
existing code and finding abstractions
and patterns that are living and lurking
and hiding in that code and I'll show
you some concrete techniques using
metrics and other things to actually go
and do this in an existing code base so
that's part of emergent design is taking
existing code base and being able to
find design elements that are in there
that you just never saw before because
you didn't have a particularly light
that you could shine on that corner of
your code base to illuminate that little
design issue so that's
one half of the techniques I'll talk
about the other half is this concept
from the lean software guys of the last
responsible moment to make decisions
about things the idea here is that very
often on projects you're presented with
the decision you should ask yourself is
there a way I can responsibly defer that
decision until later the idea being that
the longer you can delay that decision
the more real knowledge and context
about the true nature of the problem not
what you think the problem is but the
actual problem the longer you can delay
that the more real information you can
work on and you have a potential for a
better decision of course you can't wait
too long and that's the tricky thing is
the last responsible moment but the
longer you can delay you have more real
data for a decision and so the trick
here becomes how do you find that
inflection point of the last responsible
moment I'll talk about a few techniques
about that that's where the end of the
talk and so I'm going to talk about
these two aspects of emergent design and
it turns out that these two very nicely
fall into two categories
finding abstractions and patterns works
really well on existing brownfield
projects ten laps responsible moment
works really really well on greenfield
or brand-new kind of projects and in
fact some of the current research I'm
doing is and I won't get to in this talk
I don't just tease you for the next talk
that I'm going to do at some point in
the future is exactly when does the
inflection point change from greenfield
a brownfield and your engineering
practices should change as an inflection
point passes from greenfield a
brownfield because when that inflection
point happens you now have different
engineering concerns that you did from
when it was a greenfield project oh and
here's the the white paper that I was
talking about
Aelita - before from a Martin Fowler
that's the who needs an architect white
paper that I've talked about so I'm
going to talk about some things that
make it so you can find design elements
but I'm going to spend a couple of
minutes and talk about what is
unfortunately much more common in our
world which are things that make finding
design elements and code hard I'll talk
about three things at first of these is
the nature of complexity
software we have two kinds of complexity
and software essential or intrinsic
complexity every problem has a certain
amount of essential complexity that
there's part of that problem but we also
have a lot of accidental complexity
which are all the truly innovative ways
we have figured out how to make problems
way harder than they should be which is
seems like the most fruitful area of
innovation in software is how can we
make things ridiculously complex because
we're really really good at that this is
not a new distinction fred brooks made
this distinction back in 1975 and we
still struggle with this but a lot of
understanding design is understanding am
I looking at a central versus accidental
complexity because obviously accidental
complexity is design that shouldn't be
there and so sifting through that is one
of the initial things that you could
have to do to figure out well is this
something that needs to be preserved or
should it be gotten rid of a second
thing that makes emergent design really
tough is rampant technical debt
everywhere this is a metaphor by Ward
Cunningham that I'm sure you're all very
familiar with because it's a metaphor
that works really nicely in the real
world the idea here being that if you
look at if you can imagine your software
that you're working on right now but you
could lavish all of your love and
attention on it there's no refactoring
too big or too small
you can do anything that you want to
making them as perfect software on earth
think about that and then the the
version of it that you left to come here
the Delta between those two things is
largely going to be technical debt which
are generally externally imposed forces
that cause you to compromise design
elements schedule pressures the classic
kind of technical debt driver but there
are others on projects there's a famous
one called the boat anchor anti-pattern
which says that we paid a lot of money
for this framework of this
infrastructure and thou shalt use it on
every project where that makes sense to
use on this project or not because we
paid a lot of money for it that drives a
lot of technical debt on lots and lots
of projects or the the standard
corporate database often dries technical
debt on lots of projects because we all
use the same database for everything and
so a congratulation is trying to get
your network graph through Oracle see if
you can ever get that to happen
this is really a reality in our world
this idea of technical debt and in fact
I don't think it's necessarily a bad
thing
just like credit card debt for example
is not necessarily a bad thing but
fortunately there's a real-world
governor on credit card debt called a
credit limit and that's the thing that
most software projects lack is a credit
limit and so the real trick on technical
debt is not avoiding it I think it's
actually unavoidable because of the
nature of how business interacts with
the way that you build software the real
trick for us is negotiating repayment
but before you can negotiate repayment
you've got to convince someone that
technical debt exists in a way that they
can understand it's one thing to go to
your boss and say you know I'm starting
to feel sick inside I'm having trouble
sleeping at night I think our software
might be starting to suck and they're
gonna immediately ask you well how can
you tell well I'm going to show you how
to tell and one of my mantras in the
agile engineering space is a
demonstration Trump's discussion you can
talk about this stuff until you're blue
in the face and you'll never make any
headway but if you can start showing
objective results this is the outcome of
engineering about repeatability if you
can find something that shows your case
objectively then you can go a long way
toward convincing them some exercise
like we need to spend some time
refactoring is a useful exercise to
undergo and I want to show you a really
nice technical artifact that illustrates
technical debt but before I do that I
need to digress for just a second and do
a little background on a particular
metric call cyclomatic complexity that
many of you are no doubt familiar with
this is a very old metric that's been
around since the 1970s you also hear
this called mccabe's cyclomatic
complexity because thomas mccabe created
it but the idea here is that you can
place a numeric value on how complicated
a function or method is and here's the
formula edges minus nodes plus 2 where
nodes are lines of code and edges or
possible pathways through code so if you
look at a simple little method like this
and you draw it out in this edges and
nodes kind of view you can count things
up this is 4 minus 4 plus 2
so this has a cyclomatic complexity of
two but it's kind of boring when the two
cancel each other out so here's a
slightly more complex method or function
and you can label it with the edges at
nodes view and find out that cyclamate
complexity this guy is three so this is
one more complicated than the function
that we saw before so we now have a tool
that lets us run it against our code
base and assess what the most complex
functions are which is kind of Handy
well take advantage of that a little bit
later to go find some complex things so
we can kill them off but we can also
generate some other interesting facts
from this metric for example because
this is a function or method level
metric and your system is composed of
classes that consist of many methods and
functions you could run this against
your whole code base and get a
complexity number for the entire code
base by segregating all those together
and if you divide that by the number of
lines of code you get cyclomatic
complexity per line of code which is a
very interesting metric because you can
see trending so here's a chart that was
created by one of my colleagues on a
project there was a public facing media
site in the UK this is a snapshot of
this project in time from April 1st 2006
to August 18th 2007
the red line that you see there is
cyclomatic complexity per line of code
and the gray boxes you see your releases
of this code and the interesting thing
here is what happened around release
number three because they were hurrying
to get this out they had a lot of
schedule pressure it manifests here in
churn in complexity because they're
adding complexity and they're killing it
off and they're adding it because
they're in a lot of hurry and there's a
lot of churn on the project and the tech
lead on this project realized this trend
was happening and so produce this graph
and he did it by hand by writing a
little ruby script we ran a complexity
tool on the first version and then check
out the second version run the
complexity tool aggregate the results
and then have Excel graph it for you you
do this more easily with something like
sonar which I'll show you in a second
but he took this as evidence for the
project management's that okay looked
and where they were released three
there's a disturbing trend here because
very often in the software world the raw
values of metrics are not that
meaningful because you
a method that has a cyclamate complexion
of 12 was that good or bad well I don't
know it depends on is that essential or
accidental complexity that's making it
that high but trends are often very
interesting because if it's 12 now and
then two months later it's 20 and then
three months later it's 35 clearly
something's going in the wrong direction
and that's exactly what he assessed here
was the trend look kind of disturbing
but you have to ask yourself so what's
the impact what if we just didn't care
about that what do we just let this run
rampant and let this trend line keep
going up to the moon what ultimately is
going to be the downside of that
well the downside of that is that you're
adding more stuff in there that
shouldn't be there in terms of technical
debt which means that everyone's
velocity is going to slow down just a
little bit because now technical debt
literally means things in your code that
shouldn't be there that are compromised
for what should be there so when it
comes time to add other new features
later you have to go back and refigure
out why this weird thing is there and
then build around that compromise
frequently by building another
compromise around that and so it's like
you have a garden where you have weeds
growing up and it becomes very hard to
find the vegetables for all the weeds
over time so the long-term impact of
unaddressed technical debt is that
everyone's velocity gets a little bit
slower over time in fact some of you may
have seen this manifest at your company
where changes that two or three years
ago would take two or three days now
take several weeks because you have so
much technical debt built up and in fact
this becomes the basis for a pretty good
argument to say you know what it's not a
bad idea particularly in code bases that
have been around for a while they
inevitably accrue technical debt no
matter how careful you have been at
designing them because unknown unknowns
always manifest having a dedicated
resource a pair of rotating developers
for example that do nothing but go and
kill technical debt is a useful thing to
have because if they're successful they
increase everyone's velocity just a
little bit so their impact is greater
than the impact of just two people
touching code because they're clearing
away underbrush so that other people can
be effective at writing code and that
was convincing enough to say okay
we need to do some refactoring exercises
and that basically was 300 and 3.1 with
the efforts to kill off some of that
technical debt this is a good example of
this idea that demonstration Trump's
discussion showing hard facts very often
makes an argument that you can at least
get some leeway to try some resource
allocation or to get some time or
something like that now the person who
produced this it was a very laborious
kind of hand created process and you can
often get similar kinds of rich
visualizations from tools like in the
Java world sonar is this freeware
metrics tool that gives you lots and
lots of visualizations including
cyclomatic complexity pretty much every
structured language in the world has a
cyclomatic complexity tools that you can
get and find out so that's a pretty
useful metric and I'll talk about
another one in a bit called one of the
couple of metrics so those are both
things that make emergent design hard
let's talk about some things that make
it easier some accelerators for emergent
design and one of my favorite
accelerators for emergent design is the
use of unit testing and test-driven
development as a way of driving better
design by creating less complexity by
eliminating mistaken assumptions that
creep in very early on and they're very
hard to spot after the fact but it's
very easy for me to say this but I
wanted to illustrate this idea so what I
wanted to do is create take a very
simple little problem and solve it in
two different ways I want to solve it
first by doing tests after just write
the code and then write tests for it and
then I'm going to drive the solution
using test-driven development and see
what the difference is in the design of
those two chunks of code are and I chose
for this my favorite little problem
there's a very simple little problem
that has a little bit of meat for it on
it there's this ancient thing that the
ancient Greeks first discovered is this
thing called a perfect number it's a
number where the sum of the factors
equals the number if you don't include
the number itself so six for example is
a
number because its factors are 1 2 &amp;amp; 3
and if you add 1 + 2 + 3 it equals 6
28 is also a perfect number if you want
to sum one factor it and add the numbers
up you can verify that is in fact a
perfect number so that's what I want to
do is write some code that determines
perfect numbers and so I'll do this in
Java and here's my first pass a test
after version of this code and so what
I'm gonna do is come in and say ok well
I know that a 1 and the number are
always part of the factors a number and
now I'll go from 2 up to the number and
if I number mod I equals 0 that's the
mod operator in Java so if I goes into
number with an even remainder then it's
one of the factors you add the list of
factors you sum them up and then you
decide if it's perfect or not and I
wrote test for this and it works but
it's really slow like crazy slow and so
I thought well there's got to be some
way there's some in in elegance here so
is there a way I could optimize this it
turns out you can easily optimize this
piece right here by making the
observation that factors always come in
pairs so your target number is 28 when
you grab 2 you can also grab 14 because
2 times 14 is 28 and so you can take
advantage of that fact by saying well
let's harvest them in pairs and that
means I don't have to go all the way up
to the number if I'm harvesting in pairs
I could be much more clever and just go
up for example to half the number but I
couldn't be even more clever than that
and just go up to the square root of the
number because that by definition is the
number times itself which equals my
target number if I grab all the ones
below and all the ones above I have them
all and that's exactly what I do I
changed my code to only go up to the
square root of the number I harvest them
in pairs but it breaks one of my unit
tests does I have an edge case for whole
number square roots so you think about
16 for example when I grab four I'm
gonna grab 4 then I'm gonna grab it
twice so I ended up adding 4 twice for a
whole number square root but that's easy
enough to fix
I know that edge case so I'll just put a
little guard condition here that says if
this is not a symmetrical a square root
then add it to my list and this now
works and it's considered fast enough to
consider ok it's done so that's the test
after version you've seen the algorithm
for
not gonna go through the test-driven
version the test-driven version actually
has lots of very small methods which is
very characteristic of TDD code bases
because the act of doing TDD itself
encourages you toward very small methods
that are testable your goal is has the
smallest method that I can test and make
work in fact given the metric that I
showed you before I'll make kind of a
bold pronouncement here and if you'll
show me one metric on your code base
I'll tell you if it's a proper TDD code
base or not because in my experience
good TDD code bases typically have a
cyclomatic complexity per method between
1.5 and 2 and non TDD code bases it's
generally between 8 and 15 so it is
often an order of magnitude higher per
function in terms of complexity in non
TDD code bases because there's no
external force trying to force you to
keep them simple and they tend to expand
on their own by their own volition and
this also means that TDD code bases tend
to have a particular shape in that lots
of very small methods feeding into
larger aggregating methods but along the
way of doing that I discovered something
interesting because in my test after
version I've been keeping the factors as
a list of numbers but does the order
really matter when I'm collecting
factors turns out it doesn't order is
irrelevant in the factors it's a set of
numbers not a list of numbers and I
discovered that from one of my little
tests breakages that said I was
expecting one two three and six but I
got one six two and three and it made me
realize oh the order doesn't matter here
I should be using set and not list but
then you go back to the two versions my
code in the test after version my code
that this really have anything to do
with whole number square roots
turns out it didn't it had to do the
fact that I chose the wrong data
structure initially I chosen an ordered
data structure as to them an unordered
one and when I got that test breakage in
a perfect world I would have gone back
and reevaluated all my decisions all the
way back to the beginning of time to see
where the mistake lie but you never do
especially when you can see an easy
band-aid and that's exactly what I did
was applied this easy band-aid and so
what I did was by choosing the incorrect
data structure initially I added
accidental complexity and the way that I
fixed it was to add even more accidental
complexity because very often that's the
way you end up fixing one piece of
accidental complexity is creating an
offsetting piece of accidental
complexity rather than removing the
original source of the problem very
often TDD gets you to the original
source because it forces you to vet your
assumptions at the method level not at
the entire algorithm level and it gets
dangerous if you're trying to vet things
at the very coarse-grained level because
you'd never are forced to go back and
that your decisions it's a really really
granular level and a lot of times little
accidental complexity can creep in
because of that that's a good example of
the kind of emergent design technique on
a greenfield project where you're doing
TDD and you can use that as an aid for
doing design but let's talk about the
flip side of the coin which is a kind of
brownfield project and refactoring
toward design this is a little snippet
of code that comes from this little toy
e-commerce site that takes things from
shopping carts and put them into orders
and I would like to see if there's
anything interesting in here but I can't
tell because it's just a giant ugly pile
of code and I can't if I can't read it
then I can't pull anything useful out of
it so before I could really do anything
useful with this I need to do some
refactoring on it to get it organized
that I can see what's actually going on
here so I'm gonna make a refactoring run
on this and notice that a bunch of these
statements like these three or four
statements here are really all about
sort of setting up plumbing for the the
transactional stuff so I'm just gonna
kind of scoop them up in my IDE and say
extract method I'll do that for several
of these guys they're kind of related to
one another and get to this intermediate
state here it's just slightly better but
I can do a lot better but notice a weird
thing has happened here because I have
these local variables defined up here my
refactoring tool is a very specific
contract with me that guarantees that
once it's finished my code will still
work exactly the same way
did before and if I have local variables
like this and I'm extracting method the
only thing it can do is pass them as
parameters and so a lot of times you try
to extract method in one of these
complex functions like this or methods
like this you end up with these giant
number parameters being passed around
because that's the only option it really
has
fortunately you as a human understand
the implications of moving things to a
class level scope versus a local scope
and threading and visibility and all
that stuff and I'm a human that
understands that so I'm gonna make
another refactoring run consolidate a
bunch of these things and shared places
and end up here this is the exact same
code and the motivation for this style
of refactoring comes from kind of an
interesting place from the book small
talk best practice patterns by Kent Beck
because he calls this kind of code
composed method the idea in composed
method is that every public method reads
like an outline of all the things that
it does and those outline elements are
the private methods that get that work
done and notice that's a particularly
powerful kind of pattern for modern
ideas because all the modern IDE s
function names or method names become
hyperlinks when you hold down the
control key so you literally can browse
your code if you start with a public
top-level method and drill into the
individual methods to see their details
if you want to but you're not forced to
deal with their details all the time and
now that I've got it down boiled down to
this very simple state it's trivial to
see what's going on and in fact if I
knock out these two very specific lines
of code here then I have the kind of
template for doing a transactional data
little framework thingy that I'll
extract in a second as I talk about what
to do with these things as you've
discovered them but before I do that I
want to do one more refactoring exercise
and for this one I need one more metric
talked about a cyclomatic complexity
before now I want to talk about afferent
coupling this is to the decoupling
family afferent coupling of the number
of incoming connections to a particular
artifact either clasp or package and so
in this particular scenario this guy has
an afferent coupling of 6 the flip side
metric to this is efferent coupling
which is the number of outgoing
connections and the way to remember this
is that efferent starts with an e which
is also the first letter of the word
exit and those are the exiting calls
whereas afferent are the incoming calls
and so in many ways if you look at a
class for example it's a different
coupling is a measure of importance
because of a lot of other classes use it
it's probably pretty important so now I
have two weapons I have a metric that
can tell me complicated things and I
have a metric and tell me important
things let's go find complicated
important things because that sounds
like a good thing to find so what I
wanted to do is take an existing code
base and see if I could use some of
these metrics to go fine unharvested
idiomatic patterns that are lurking
around for a long time but I wanted to
be a publicly available code base so
that people could reproduce this I need
to be around for a while and use for a
lot of stuff so I chose struts very
well-known web framework it's been
around for more than a decade it's in
its second major release literally
thousands of web application including
industrial-strength websites have been
built on top of this and it's my
contention that every piece of software
has unharvested little idiomatic design
patterns in it so let's go see if we can
find something interesting the struts
codebase so I'll download the stretch
code base random metrics tool on it that
gives me my two metrics cyclomatic
complexity and afferent coupling the
tool I used if anyone's interested this
little freeware tool called C kjm that
runs the chittim ER and kimra object nor
metric suite on java code that's the ck
and C kjm and the way that it reports
cyclomatic complexity because it's a
class level metric tool it reports
cyclomatic complexity for the class as
the sum of the cyclomatic complexity of
all the methods and it calls it weighted
method complexity and here are the
results for strengths and so it turns
out the champion most complex component
in all the struts is this WI beam guide
with a 66 if you add all the cyclomatic
complexity of all his methods up at 66
so if I were just doing complexity
hunting I would go after that guy and
try to kill him off or make him a lot
simpler but when you look across
he's only used by three other classes
and so Herculean efforts here might
clean that up a lot but it's not gonna
have a lot of ripple effect other parts
of my codebase
let's sort them by importance instead
and not surprisingly component is the
most important one in struts being a
component based web framework but that's
not even the one I'm looking for
either what I'm looking for here are
high combinations of members remember
I'm looking for important complicated
things and I want to find out why they
exist and the one that catches my eye
here is this UI beam guy with a fifty
three and a twenty two important and
complicated so let's go see why so I
open up the SS UI beam and I find this
lovely guy he evaluate params my very
favorite part of this method by far is
the very last line of the method which
is evaluate extra params it's like the
developer just got tired of typing at
some point oh god okay evaluate extra
prams I guess I'm done so what this code
does struts as a component web framework
and it sometimes does magic automatic
things the URI parameters and sometimes
it just passes them through invisibly
and sometimes it's mappings happen on
those guys so that's the evaluate params
and evaluate extra params now as I've
started poking around in struts
I noticed that lots and lots of these
evaluate params evaluate extra prams
methods we're showing up and so I got
really curious of course you can do this
in IDE but I did it on command line with
a little bit of command line judo as
it's starting the route of struts give
me all the methods or you give me all
the Java source files and find all the
ones that have a declaration for
evaluate something params and here they
are I have found an idiomatic pattern
and struts and this is a perfect example
of an idiomatic pattern because fifteen
years ago when I started working on
struts there's no way they said you know
what in 15 years the most complicated
part of struts is gonna be how we handle
URI parameters because it's such a
simple problem it's so simple in fact
they reimplemented it over and over and
over and over and over again in the
codebase without realizing that that was
manifesting all over the place so
there's an interesting epilogue to this
story I wrote this analysis up and that
developer work series I was talking
about and one of the stress developers
contacted me and said that he had end
discovered the exact same thing had
manifest in the struts codebase and he
was in the process of fixing it by
extracting all that uri parameter
handling stuff as an internal component
of struts so if you look at struts now
you or I parameters are handled by this
internal component and by doing that he
knocked off several thousand lines of
code and several hundred complexity
points out of struts without changing
the functionality of struts he just
greatly simplified it because no one had
ever used that particular lens to
illuminate that part of the codebase
it's like oh this duplicated code is
running around all over the place
but you literally just couldn't see it
because it's lurking and hiding behind
all the other stuff that's there so once
you found these things what do you do
with them how do you capture them and
there are a couple of easy ways to do
this one easy way to do this is just
capture it as an API this is the
simplest way this is the unit of how you
capture things in the Java world so the
example that I showed you for this
idiomatic unit of work this is the code
that I want to capture it from so in
Java I can very easily come in here and
say let's use a proper gang a4 design
pattern here and we'll extract this
using the command pattern so now my
commands up there and this is now my
method it's probably worth noting that
the entire slide full of code that I
showed you before this is why didn't do
that being is this one method right here
after all the useful reusable stuff had
been sucked out of it once we determined
what the useful reusable stuff was in
fact if you look at this this little
rapid transaction thing looks a lot like
Springs do in transactional wrapper that
does basically a lot of the same stuff
Java forces a fair amount of syntactic
noise on you because really all you want
to do is this wrap this stuff in a
transaction and languages of higher
order functions like groovy and of
course Java 8 we're going to make that a
lot cleaner and simpler because you get
rid of the middleman class that's only
there as a holder for that execute
method and so for example in groovy if
you wrote this exact same thing it'd be
a lot cleaner because this anything
curly braces in groovy is a code block
and that gets passed up here and that's
syntactic sugar
the exact same thing you can do in a
language of higher order functions and
so that actually cleans this up a lot
and that turns out to be a pretty
important thing
syntactic cleanliness is a really
important because your code is your
design document and so design and
readability are very closely intertwined
with one another based on what Jack
Reeves was saying readability makes a
big difference the other way you can
harvest these guys in languages like
Java is use annotations I don't think
people use this quite enough this is
actually a very powerful mechanism in
Java because it adds an extra level of
expressiveness to the language that you
normally don't have it was a really nice
thing to have but I won't spend any more
time on that a lot of frameworks use
this but not a lot of developers use
this mechanism and it's not suitable for
everything of course but the nice thing
is that annotations live very close to
the thing that you're trying to modify
and so there's a nice kind of locality
to the modifications you're making let
me talk just a second about abstraction
styles because I mentioned the the
f-word the functional programming word
here as I mentioned Landers we're all
interested are all premiere with
imperative programming languages
structured and modular and
object-oriented they're all in styles
and period of abstraction styles but you
hear a lot about functional programming
these days realize that though it's
really just a different palette of tools
it's literally a different toolbox and
neither one is particularly suited to
solve every problem better than the
other but a lot of times using one is
more suited toward a particular kind of
problem because it matches the essential
complexity better than another one and
we end up getting caught up a lot in the
kind of underlying paradigm in the
language supports because it is the
default way that things work but you
don't have to get caught up in that and
a great example of that is this concept
of an anti object that comes from a
paper that was delivered at Uppsala in
2006 I believe called collaborative
diffusion and they created this this
concept of an anti object in their paper
they say the metaphor Rob is you can go
too far by making us create objects too
much inspired by the real world
an anti object it's kind of object that
does the opposite of what you think it
should be doing as a way of modeling
something that's simpler kind of like
this optical illusion is this of a
source at two phases and the classic
example of an anti object approach comes
to us in the form of pac-man now I have
to warn you I'm about to explain how
pac-man works if you want to keep
playing pac-man and enjoy it you should
leave now and I will understand
sometimes knowledge comes at a cost and
the cost for this is you're not going to
enjoy pac-man quite as much because I'm
gonna explain the algorithm to you when
you think about the pac-man console game
that came out in the early 1980s they
had less memory and processing power
than most watches have now and they had
a really hard problem solve is how do we
calculate the distance between two
moving objects in a maze they didn't
have anywhere nearly enough processing
power to do that
so they took an anti object approach to
this rather than build intelligence into
the goes to the individual pac-man guy
etc they built all the intelligence into
the maze the maze is basically a state
machine that for every cell it runs
rules for every time through the game
cycle and they invented this concept of
pac-man smell and when pac-man is
sitting on a cell it has maximum pac-man
smell and the cell that he just vacated
has maximum pac-man smell minus 1 and it
decays really quickly and all the ghosts
do is wander around semi randomly until
they encounter pac-man smell they go to
the next adjacent silver stronger and
they move slightly faster than pac-man
and that's the whole game pseudo-random
numbers and pac-man smell and they did a
really sneaky thing to you because the
ghosts they gave them eyes but they
should have only give them a nose
because they can't see you coming you
can run right up on them and they can't
see you but they can smell where you've
been
so the ghosts really need giant noses
but no eyes but they tricked you by
putting eyes on them but now the next
time you play pac-man you can run right
up on a ghost and unless he just
randomly turns towards you he doesn't
know you're there because they can only
follow you this is a great example of
taking a design that was too complicated
to build and the tools they had at the
time and coming up with a way of
flipping the abstract
over backwards and being able to build
something and when miss pac-man came out
they kept the same algorithm they just
made the random number generator better
so a lot of that's in this this place of
finding and harvesting idiomatic
patterns but I want to go back for a
second to last responsible moment and
talk about how do you determine this
inflection point so if you look at
complexity over time on project you look
at particular components as part of your
your architectural stack you will notice
that over time they take on varying
degrees of responsibility and if those
inflection points where they're taking
on more responsibility or making serious
changes to them that's the time you read
it and say have you really reached your
last responsible moment and so this
actually goes toward one of the
characteristics of Architects on agile
projects is they need a much better
awareness of kind of current events of
what's going on in the code because they
need to be able to make these kind of
determinations have we reached the last
responsible moment has this component
started taking on too many
responsibilities we're also big fans of
doing spikes which are experimental
coding exercises to determine to get rid
of uncertainty for things like estimates
there's another really famous
anti-pattern called the give me
estimates now anti-pattern and the way
this pattern manifests is that somebody
asked you to estimate something and you
don't know anything about it like tell
me how much it's gonna take that
geocoding this application and the
really dangerous thing here is to guess
because they give me estimates now
anti-pattern says that as soon as
numbers come out of your mouth you have
inadvertently entered into an ironclad
contract that you'll risk your life to
make that date come true no matter how
many waffle words you put in front of it
spikes allow you to get away from that
because you can now look at and
determine and get rid of some of the
uncertainty that's leading to the
speculation as to how long it's going to
take to do this so to summarize
obviously evolutionary architecture and
emergent design require good engineering
practices if you have a good TDD code
base you can be refactoring on it makes
it much easier to do these exercises on
it doesn't preclude you from doing them
it certainly makes it a lot easier if
you already have good other engineering
practices the
the most advanced engineering practice
which the architecture and design space
becomes easier trying to predict the
future leads to over engineering which
is a bad thing and this is going to be a
subtle distinction but I think a really
important one because in the agile world
we're trying to prefer being pro and
reactive to predictive we're not trying
to predict the future what we're trying
to do is be proactive about things we
know are going to happen in the future
and then being instantly reactive as
things happen in our code base that we
need to be able to respond to the
combination of Pro and reactive I think
works much better than trying to get
better and better at predictive because
as any street corner psychic will tell
you trying to get better and better at
predicting the future is really really
hard to do I'm out of time and I don't
want to cut in to lunch because I know
that's a very important agenda item for
many of you I'll be here for the rest of
week if you have any questions or
anything like that thanks very much for
coming I hope you enjoyed it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>