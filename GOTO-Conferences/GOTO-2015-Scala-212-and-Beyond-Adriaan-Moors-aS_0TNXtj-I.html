<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Scala 2.12 and Beyond • Adriaan Moors | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Scala 2.12 and Beyond • Adriaan Moors - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Scala 2.12 and Beyond • Adriaan Moors</b></h2><h5 class="post__date">2015-07-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aS_0TNXtj-I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm the I'm the team lead at a
type-safe or I lead the the Skog team
there before i was at epfl where scala
was born but almost ten years of working
on scala you can blame me for some of
the complexity impaired the type
constructors stuff the higher kind of
stuff and implicit search dependent
method types we wrote the pattern
matcher and then I came to the dark side
or two blue the dark blue side a
type-safe so well maybe I'll say just
one more thing about about type save
everything we do is written in Scala and
so Scala is very important to us both
emotionally and under from a business
perspective we see ourselves discala
stewards as you know the benign scala
stewards we definitely are trying to
open up and work with everybody who
wants to contribute wants to know what's
going on so that's why I'm telling you
about all our secret plans and this talk
and with that said everything all our
other products are designed so that they
work well with Java and that's a big
focus also for Scala 212 is that we want
to be a great citizen in the Java
platform especially not on Java 8 you
know we can do functional stuff a bit
better and speaking of openness we can't
do this alone were four people typesafe
a lot more contributors out there than
the four of us easily get overwhelmed
trying to review everything that that's
going on so that's that's that's been
very encouraging to see and Weavin been
investing from our end to make it easier
to contribute so simplifying the process
investing in infrastructure running our
denk ins on ec2 all that boring stuff
that i get to do and also things like
modularizing so spinning out more stuff
that used to be in our monolithic
standard library that is now being
maintained by people from the community
they cut releases they merge pull
requests they decide the direction and
that's something that that's worked out
well in 211 that was the fur
the first time that we really did that
and we intend to continue doing that so
to give you an idea of how the how to
commit pi is split up about a fourth it
comes from people not at epfl or a
type-safe that's a three-fold increase
over to 10 so i think our efforts are
rewarded there and we're very happy to
see that that growth epfl does a lot of
research sews college as for example is
is an EPFL project we contribute to it
but we don't we don't own it we love it
we think it's very exciting but most of
the work is being done at epfl for
example so that's why they're slice it
up I is a bit smaller for Scala too
they're also working on dotty and so on
and so the other half is is it the type
save team we merge about 50 pull
requests per month up from about 40 or
42 depending on how you like to round
things into 10 so that's all very
encouraging and here's the top 10 list
of contributors according to get short
log and you know their commit stats so
we're very happy happy to see that and
thank you I don't actually know
everybody I would not sure we recognize
all of you so if you're in the room or
in the conference please please come up
and I will buy you an appropriate
beverage most of all you know I hope you
have fun programming in Scala first and
for all and contributing to it as well
and let me know my twitter handle will
be on here some point how we can make
that easier so there's definitely
something that we think about a lot so
but today I'll be talking more about the
roadmap and how your contributions could
fit in there man so let me give you a
quick overview of the the next couple of
releases they're coming up so one of the
the themes for us since we're we we want
to find the balance between moving
quickly enough that we can add exciting
features and fix bugs and also not break
break people's code all the time like
before i joined type safe and at epfl we
thought that was kind of fun
we've decided to alternate compiler and
library releases so into 12 we're not
changing much about the library we're
adding deprecation and so on so that the
scene is set for the next release to
remove things but between those two 11
and 2 12 migrations it'll mostly be
fixing the compiler changing the back
end in this case and so you shouldn't
have to worry too much about changing
your programs except that you were
exploiting some weird bug and implicit
search or something like that so for 2
12 most of the stuff is happening in the
back end some of the Java 8 interop has
to happen at the type checker and that's
what I've been working on but I'll go
into a lot more detail that during this
talk we also finally are emerging
miguela Garcia's work we're cleaning it
up and Lucas Ritz is doing that work
making a production-ready so that we're
basically replacing the old optimizer
entirely by a new one that's based on
ASM and we'll have a much more
predictable in liner which is great one
of the projects I would like to work on
time permitting is abide that that's our
lint tool that would plug into the
compiler and knows semantically exactly
what's going on and can you give you
very precise warnings kind of like what
Matt's was talking about earlier
although I just not a shiny that's
that's something that we'd really like
to do and so as I said prepare for the
next release so that is too far into the
future to to really give a date or even
a version number although if you're good
at math you probably guess it's going to
be 2 13 mostly that will be about
cleaning up the standard library we've
accumulated a lot of stuff Skiles over
10 years old now we want to invite more
people from the community to have their
modules as part of the official
distribution spin out some stuff that
hasn't worked out really well we write
the collection library and so on so
since we're roughly on an 18-month cycle
and it takes us about six months to to
get through like the first couple that
releases of a new release expect us
about a year after 2 12 30 yeah and
anybody using macros and Scala just
wondering wow you're my favorite
audience ever
yeah don't use macros they're going to
change a lot that's all I have to say
about macros after that we're going to
have another major release that I
predict will be split up into acts one
will be again a careful refactoring and
probably a big replacement of the back
end based on on the the research that is
being done a DPF LA right now ready to
have a couple of interesting ideas about
making it back end a lot faster
maintainable and in the first phase we
would keep the front end so that you can
still compile the same code we just use
apply a different back into it we can
compare to bytecode I mean we compile up
over a million lines of code every night
from the community to make sure we don't
regress and when we move to a new
architecture like that for sure we will
be looking at the bytecode and we're
looking for all kinds of engineering
mechanisms to make sure that this kind
of transition will be a smooth one so
that also goes into abide and
refactoring tools that can help you get
rid of some of the deprecated syntax
that you might be using all this to say
we're not going to pull up by three so
don giovanni act 2 will be a front-end
rework that's where the most excitement
is right now around dotty i would say
where a lot of the crafty syntax is
going away simpler foundations at the
type level and andrew and nirman are
going to be out of business with their
puzzler books sorry about that or at
least that's our goal so that's kind of
the overview for the next five years I
guess roughly or the next 40 minutes
depending on your perspective so what
we've been working on quite intensely
already although not a lot of code has
landed in 212 is Java 8 support and I'll
tell you why it hasn't landed in 212 in
a second I mean there's a we wrote a
blog post with with all the details but
I'll tell you some more now and because
that's why you're here I guess so
regarding the timeline we're getting
close so I'm getting a little stressed
out
and 211 and 212 will be very closely
aligned again because we care a lot
about people upgrading quickly from to
10 22 11 to 12 definitely seeing that
trend improving I don't know if anyone
ever upgraded their 28 to 29 code base
or to 9 22 10 code bases that was a lot
of pain and that's never going to happen
again most people have reported like 211
was not an issue as a for an upgrade and
we hope and four to twelve that will be
the same thing especially because if
you're stuck on java 6 you'll be stuck
on 211 which means we'll be stuck
maintaining 211 a little bit longer so
we want to get all the good stuff that's
going into to 12 when possible also to
into 211 and I guess that the logical
consequence for that is that a lot of
the work that we've been doing on using
invoke dynamic to compile lambdas has
already gone into 11 under a flag and
the same code will be run by default in
212 and that probably that flag will be
flipped in m2 when we require Java 8 for
the 212 development branch and this has
always been our philosophy and I think
it's worked out really well for Scylla
is that whenever you know Java Sea does
something comparable to what we want to
do why don't we just omit the same
bytecode and ride the jet performance
wave and yeah obviously lots of profit
for typesafe then default methods are
another great great addition to Java 8
for us and so will we're working on that
right now prototyping that so that you
can actually use a scala function end
which wasn't designed to be compatible
with what java 8 now requires of these
things to rework those so that a
bytecode they look exactly the same and
that's one of the big goals commercially
for type-safe is that even though every
program in Scala we need to have
excellent Java 8 api's and I think we do
and this is one way we'll make that
easier for everybody so also for binary
compatibility
obviously that was one of the reasons
why default methods were added to
interfaces the Java side will try to
enjoy some of those benefits by
compiling our traits to interfaces where
possible not always possible so it'd
probably be an opt-in kind of thing
we're still sketching out the design for
this so the other side of the coin for
interrupt interoperating well with java
and and enjoying their their functional
Renaissance is to let you call java api
is easily from scala and i'll show you
how how that's possible from the repple
in a second not brave enough to run
these things live so I'm just gonna I'm
just going to show you a couple
transcripts but yeah that works out
really well and it's mostly a type
checker thing I'll rent a little bit
later about why it's more complicated
than it should be and I'm sure Matt's
won't take it personally when I complain
about wild cards sorry yeah so that's so
emotional I get about that stuff oh yeah
and we might eventually also compile
calls to single abstract method types to
invoke dynamics so I'll show you some
code and and how it compiles down too in
case you're not familiar with these
things where you learned at the talks
that introduced these things this
morning so Java 8 know has java.util
stream and you can relatively easily
construct an array and turn it into a
stream so the comments here is what
you'd write in Java 8 and that's what i
wrote into scala rapel and you know it's
basically the same thing we have
slightly nicer syntax for the very
common pattern where you where you
introduce a lambda binder only to
immediately discharged it so we just use
our magic underscore for that it works
out well in simple cases like this I
wouldn't in generally recommend using
underscore everywhere you potentially
could but I think in this case it reads
a little more nicely which it also means
we don't need to
just like the colon colon syntax that
the Java 8 added looks more like C++
every day so otherwise you know it's I
just I just have to slide to give you a
high-level idea that whether you're
writing Java 8 or Scala you can you can
interface with their epi is in exactly
the same way there are a couple of snags
still that I need to figure out because
wildcards type inference works very
differently in Java and Scala and I'll
talk a little bit about that later but
yeah I mean here right now I just want
to give you the idea that we have a
rapel right now java 9 will have one
probably and whatever code you can write
in Java 8 22 consume Java 8 api's it
it's completely straightforward to carry
it over even more complicated ones so
that's that's one side of the interop
and so in case you're wondering how that
works this is what the what the Java C
compiler does and this is now what we
also do so if you write this this call
above here where you say stream of and a
bunch arguments dot filter and then you
pass in that closure here what it really
compiles down to is well this filter
call needs a predicate that's what the
compiler can easily look up by by
finding the signature for fir filter and
it knows that this predicate type has
one abstract method says but I need a
predicate with and all I have is a
function one well I can easily make a
new predicate and I can implement its
only abstract method called test by
invoking that closure that I've
conveniently lifted out to a separate
method so I assume the those thing off
means that it's too simple or is it is
it too complicated can you like maybe
like open your eyes really wide if it's
not clear I can see everybody almost at
the back everybody is regular sized
pupils okay great so it's a pretty
simple transform its tricky actually
behind the scenes to figure out all the
type in for
it's overloading resolution and kind of
do it the same way as Java does but our
goal is to basically provide the same
experience that you have in Java and
that's that's kind of a general thing
for first scala when java did it right
already why why why we do it and so a
lot of people compare Java 8 to scala
and say aren't you like you know afraid
that everybody's gonna kind of run for
the for the hills or i don't know what
the right metaphor for for java is but I
like to think of scholars des Alpes and
those are the most awesome mountains so
whatever Hill you got we got the Alps
that's where you know Scala was was was
designed you can see the alps from the
office i still don't know how people get
work done there such a beautiful view
anyway um before I rent they should
probably just like stop talking about
random things let's talk a little bit
about what to me functional programming
is in Scala I mean there's lots of
different interpretations of functional
programming we're a very pragmatic bunch
but i will say that functional
programming isn't just slapping all
lambdas on a language that's a great
start it's awesome for us to have that
support in the vm i think it's great for
API design but it's it's a small
percentage of what actually it means to
program functionally and I don't claim
that I know that i have like that wisdom
to say exactly functional programming
isn't probably means a lot of different
things to a lot of different people but
i can tell you what it means to me
personally and i'm somewhat aligned with
what what we do in scala so you can take
that as you will so to me it's about
defining composing and understanding
small units of abstraction over known
sets of types so and just a side tangent
here like the whole reactive manifesto
thing is about this kind of stuff like
you have events you have small pieces of
behavior that you want to scale out and
so on and functions are a great match
for that and in a sense it's always
compliments and i think that's that's
one of the key things that scale says
you need both if you
want to make big abstractions you expect
to add new behavior sorry expect to add
new types then oh is a great solution if
you want to structure your application
you want to talk about design that's
where 0 is great when you want to talk
about small things and you want a really
reason about them that's where
functional programming comes in and i
just made a quick ranti list of bullets
and to me like immutable first has a lot
of consequences like in Scala you write
a valve by Nature you don't you never
write a far I mean I de will pick like
the most ugly contrasting color with
your background so that you can either
not see it depending on how its feeling
or it looks really horrible and so you
just don't write them but it goes much
farther than that because you can do
that in Java of course you can just slap
some more keywords on and it'll be a
vile but you have to slap more keywords
on you have to think about it
expressions versus statements is another
important distinction everything is an
expression everything is the value
having a statement encourage you to
mutate things or cause other side
effects so having that by design that
everything is an expression is pretty
fundamental thing to letting people
think immutable first and recursion is
similar because when you write a
do-while loop how would you figure out
when you need to stop and it's kind of
you know this is where were you where
you go to the bar and debate because
with recursion you're just mutating
stack frames but that's kind of where
you start talking about while persistent
data structures versus you know array
updates and and to me it really comes
down to the middle word in the title
understanding your code like knowing
what it does and as a nice side effect
it also scales better it's it's often
more performant and since we assume for
the kind of problems that we apply fp2
that we know what the different types
are that we need to reason about pattern
matching is something that comes up
naturally as well after you've
constructed it you need to deconstruct
it and yeah it helps you understand it
helps you predict the output of a
function based on case analysis of the
input which is really how we very often
think both in maths and in real life you
kind of think by examples and you
see those cases you know what the what
the output is going to be local methods
is another small thing but actually
really helps refactor your code like
once you start thinking oh everything is
an expression you start writing
expressions that you know you need three
screens to read and then someone says
well I can't review this I can't
understand this well you just you just
introduced a couple of local methods if
you don't have those you need to like
introduce some private methods and they
might like actually be moved around
somewhere else again so all these things
really fit together and you can't just
have just lambdas and and expect to
magically be programming functionally
probably since I started a minute late I
shouldn't run too much more but i think
the other points kind of speak for
themselves types are very important part
but you want them out of the way you
don't if you could have your IDE infer
your types for them and put them in the
code but then when you refactor you need
to take him back out and Riaan further
it just doesn't scale that way you have
to have good and good inference so to
give you one example of why I think wild
cards are horrible and why it's been
redeemed and net is that the natural
thing that you want to be true for your
function abstraction is that when you
have a stream of strings and you have
this function that can take anything I
want to be able to pass it to something
that transforms that stream but unless I
tell Java Java type system that actually
that's how my function behaves in this
case for map you can't do it and you
need to do it for every time you use
function because it's you side variance
even though this is a property that
defines what a function is a function
abstraction is something that well if I
require this but actually I have
something that poses less restriction on
the argument type that's a contravariant
thing then it's fine so that's what
scala and an c sharp and and other sane
languages do and and the type signature
you know becomes a lot nicer you can go
into the theory and and and and kind of
rewrite this you can we can
it's one of the things with Scala is
that you can write you cite variants you
can express it but why would you and
that's definitely one of the challenges
while you're learning scale is when do I
use variance when do you use existential
and granted that that's a challenge but
I think that goes back to to David's
talk as well is that you know simplicity
doesn't necessarily mean it's easy it
means you have to figure out what which
bricklaying technique is the right one
for this for this architectural
challenge and scala offers you all of
them and we could give you more guidance
but you know you can always hire us
first for advice if you want i won't go
into the theory but basically you know
all the work you have to go through to
make sure that wherever use function it
behaves like a like would expect a
function to behave it's much more
verbose in java and so that's just one
example of where i think the design of
the language needs to come up from
bottom up needs to be functional from
bottom up and not just like oh yeah we
have this now it's great so whereas I
think Java is great I'm confident that
people will come to languages like C
sharp F sharp Scala when they want real
functional programming so a little bit
further down the line we're going to go
into opera land and this talk was kind
of written for people who would
interrupt me so i think i'm kind of like
ahead of time and since you've all been
so polite I maybe have stacked up a
bunch of questions so getting to the end
here Ida is going to be our library
release and we're going to focus on on
reworking the collection library which
is one of the main things that we take a
lot of flack for we have can build from
in there the hierarchy is is really
nicely designed there are a couple of
warts on there but it's really designed
from implementers point of view to avoid
code reuse it's not really easily
extended if you if you weren't in the
room when it was designed and that's bad
I mean that's bad and that's something
that we
work on and and we want to basically
we've already been finalizing a lot of
the classes so that you just can't
extend them because even if you could it
would be pretty frustrating so we're
coming to terms with saying well maybe
we should compose these things a bit
more than just using inheritance
everywhere and one of the reasons why
hierarchies overloaded is that we try to
slot in parallel and sequential
collections into the same thing even
though they're fundamentally different
so we're just going to pull that out and
the same thing for laziness for views so
most people won't really experienced
this and accept if they've managed to
implement their own extensions of the of
the core collection abstractions but I
think it's important that we fix this so
as I said those are a couple of the
modules that are that are coming up we
also see a lot of people going to scalzi
or cat or skull actix library mostly for
validation and it's kind of like a
library solution to the ? for a null
ability you want to compose a bunch of
accesses to something that you don't
know whether it'll be there or not but
actually when it's not there it's
important to know that and you want to
reify that and you want to present a
nice error message to your to your to
your user later so a validation kind of
takes that idea that's also president
for comprehensions and so on and lets
you go into a tree with with potentially
holes and and and collect the errors or
collect your successful result and so
that's something that's naturally done
and stuff like Scala said but then you
have to use Scala said so probably will
come up with a nicer module for that I
said I wasn't going to talk about macros
anymore allied I'm just going to say it
one more time don't use them I mean
they're really great I mean if you if
you're willing to pay the price it's
really fun it's basically a nicer
mechanism to deliver compiler plugins to
your users but that's really the way you
should think about them there is some
implications that there's an API for
macros really it's just the compilers
you're talking directly to the compiler
it just wasn't recorded i would tell you
more about it but how it came to be
asked me at the bar so it's going to
change completely and i think for the
better so if you're using Kwazii quotes
and wide box macros but no no bun was so
don't worry about it but if you were
using Kwazii quotes and white box macros
I think you'll be happy in the future if
you're not you're going to be rewriting
your macros okay so don giovanni is is
not coincidentally do for dotty or at
least i didn't come up with the name but
I I was imagined it was because of that
as I said it's going to be a big
refracting of the compiler the code base
is about 10 years old we feel like a lot
of engineering wisdom and battle testing
has gone into it so we're not going to
lightly just throw it all out and
replace it but at some point you have to
take some components out to the backyard
and you know replace them and so that's
what we're going to do but you know
we're in five year out territory now so
one of our main obsessions with this
whole migration is that we're terrified
looking at what happened to python and I
think we have a lot of good properties
and Scala that we wouldn't easily get
into that kind of territory but whenever
something will change it will be for a
good reason for the user not just
because we have a nicer implementation
for it it will be because it'll be
simpler to understand or your code will
be nicer for it or maybe it'll just
compile faster but that's kind of where
as far as I would stretch it just a
nicer theory or a nicer implementation
it's not something that would cut muster
for me saying well we're going to change
this in the language a lot of people are
pretty deeply invested in Scala and we
certainly wouldn't want to cause any
headaches there so one of the things
though that we all kind of universally
hate in the team although people don't
necessarily agree with us is that
procedure syntax is kind of an
abomination a lot about Scotland X is
that it's extremely regular it
always introduces a definition with a
keyboard a keyword name a signature and
that optionally a body if it's a
concrete definition procedure sin tax
breaks that and so it has to go that
little kind of little bit of convenience
is very confusing because it looks a lot
like a type refinement and so if you
accidentally type well I'm not going to
tell you why you should type but if you
type certain things in there you'll be
very surprised by the results and with
the regular syntax that would never
happen like somehow literals were a
great way to get research money back in
the day not so hot anymore maybe we'll
introduce Jason literals or something I
don't know whatever i'm not so hip so i
don't know what what gets money these
days for grants i think someone can tell
me afterwards early definitions were
another thing that we needed in the
compiler i hope no one was using them
they're going away instead we'll have a
much nicer generalization of adding
parameters to traits which a lot of
people ask about why can't you write the
same thing that you can in a class well
it's actually tricky to implement but
well we'll figure it out i mean i think
we're getting close and this is kind of
what i did for a long time when I was in
academics is is the whole the whole type
system is getting a nice unification
where type parameters and tech members
used to be treated separately even
though they're really the same thing and
they can model type constructors and
abstraction over type constructors they
can model so that was universal
quantification they can also model
existential quantification it kind of
blows your mind that type members can
both be universally and essentially
quantified I still haven't really come
to terms with that but they can and so
internally there won't be any type
parameters and upcoming versions of
Scala I mean you'll have them in the
surface syntax they'll just do sugar to
type members and it won't really change
that much it'll change a little bit
exists at certain kinds of existential
can't be expressed but most of it can I
will also introduce Union types and
they're not the union types that you
would expect if you've programmed NM
hours or see or something like that it's
think of it more as a lazy lub
and you know you'll have to do some case
the sting shouldn't at runtime on them
but they're going to be very limited and
kind of expressed in terms of sets of
members and so on I'm a little wary of
how that's going to turn out in the
bytecode but we'll see this is all in
doggy already and it seems to be working
so i will see a lot of i mean if you
were in Amanda's talk she gave an
example of h lists i mean those things
just give me nightmares to be artists
from an implementation perspective
because implicit search and I mean so I
was one who said man when she asked what
you thought about about H list so
originally we had type inference and we
had implicit search and then we were
writing a paper and we thought it would
be great idea to combine them because it
lets you write your collection library
much more neatly and so I did a lot of
that work and people went crazy with it
and now like and put the search is
basically prologue is it like a prologue
resolution engine that is not really
SPECT and and we can't optimize it and
it interfaces with type inference in
very interesting ways and this is how
people do type global programming in
Scala these days and like honestly I I
wish we had an added it or we wouldn't
allow it because I think what a man is
that was spot on I mean we really want
type level programming to look just like
object level programming if we have
functions at the object level why don't
we have functions of the type level I
mean most of the stuff and I've been
looking at how we use in I've been
looking at our corpus of code and usage
of implicit and they're basically all
functions if T is int then bit sets if T
is not into then set of tea why do you
have to write a little prologue program
for that that the compiler has to search
a humongous search pays for that for
every context that you go in is
basically invalidated and we've gone to
a point where we have to put in so many
caches that people are actually relying
on implementation artifact of I warmed
up the cash on one end of my program now
this implicit is going to come first and
well that way that I
other side of my program type ticks so
that's not the kind of semantics you
want at the type level which is why
stuff like H less scares me and which
why I mean it's a sense it's frustrating
that Scala gets a reputation for this
kind of stuff because I don't think you
need this I don't think a lot of people
actually write this kind of code and if
it turns out that a lot of people needed
we'll add language support for it that
can give you nice error messages and you
know that that don't make for great hate
tweets anyway enough about that I talked
a little bit about how we would have how
we change the front end and the back end
individually and one of the key things
is is tasty which you may have heard
about is our tape typed asds which are
also great for binary compatibility but
basically it's an intermediate language
for Scala that captures all the
information that we have after type
checking so we're no longer tied to the
Java platforms interpretation of member
resolution and you have a much higher
level view of lazy valves and traits and
methods and and our way of overloading
so that if the platform changes excuse
me we we can just recompile based on
that typed ast and we know that the
semantics won't change so think of it as
a richer bytecode that you can on the
fly recompile as your as your API is
change in source compatible ways that
turn out not to be binary compatible on
the JVM martin has given multiple talks
about that explaining it much better
than I just did but it's pretty
interesting so I encourage you to have a
look at that or ask me about it during
the questions thanks very much for your
attention I know it's been a long day
but if you've any questions happy to
take them now or later thank</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>