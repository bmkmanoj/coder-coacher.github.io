<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Gradle • Etienne Studer | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Gradle • Etienne Studer - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Gradle • Etienne Studer</b></h2><h5 class="post__date">2015-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/u86cKTigxYg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">(light piano music)
- My name is Etienne. I work for Gradle.
I am leading the billchip project
(our effort to
integrate with Eclipse).
I am also co-leading
the Gradle.com efforts,
which is our Sass base solution
that will come out soon.
The focus of today is
to give you more insight
into the Gradle build,
and how it relates to the Android build.
But before we get started,
I would like to ask you:

Who is doing Android development,
that is listening?
Most of the people, I would say 90%.
Who is using Android studio?
Maybe I should ask
the other way around.
Who is not using Android studio?
Maybe 5 hands, or so.
Who has touched the Gradle build?
Interesting.
I would say maybe two thirds.
I always ask that question, and
it goes up every time I ask.
I am not sure if that is
a good sign, or not.
I think it is.
And who is using Gradle
outside of an Android project?
Java development, Scala.
Maybe five hands.
That came up.
What is the motivation
to talk about Gradle, and Android:
it is just a build system.
Why this big deal
of making this choice,
and not another.
I want to go into that some more
to give you some context.
The Android build is
implicitly very complex.
If you compare it to just a Java project,
Android build is more complex.
You can also see that on
this  hand side graph
(from Xavier, Android Lead).
It is a simplification of what happens
during the Android build, potentially.
And it does not even include everything.
There is complexity involved,
more than just compile.
You have your classes,
you chart them up,
and you are done.
Typically when you do Android development
you are part of a team,
and not everybody might do Android stuff
on that team.
You might also have a back end team.
they are doing Java or Scala;
quickly you have multiple languages.
(Java, Android, etc).
That needs to be part of it as well.
You have resource generation,
extraction of artifacts,
and conversion to other
artifacts.
You have to splat from diversity.
All the fragmentation
that you definitely know better than I do.
But it is there.
There is complexity
involved in dealing
with the Android build.
And if you look at this
complexity on this graph here,
expressiveness versus conciseness,
you can see that with Ant,
you can be very expressive,
you can basically do everything.
Ant
is very expressive,
but it also grows quickly.

You have to tell it with
detail what to do.
On the other end you have
Maven, which is very concise,
it is XML based approach.
It is concise, but not
very expressive.
To all of you who have a custom build
know how fast you get to
your limitations of that.
Gradle combines the two.
It is concise.
I am going to give you an example
(also very expressive).
In this example here,
this is a fully self
contained Android build.
Different product flavors,
two flavor dimensions
combined with a build
type;

an explosion of cross products.
That leads to tasks.
(I am not sure,
maybe in the first row
you can still read that).
(I can. But definitely not in the last row).
You end up with
300 tasks.
I want to show
the very concise DSL
(things happen behind the scenes).
If you wanted to achieve
the same with Ant,
you would have to write more
to achieve the same result.
With Maven, I do not
know how you would do that.
Regarding the languages.
You have multiple
languages.
You typically also have multiple teams.
And then you want to collaborate
on the same softwares.
So you want a build
system
that allows you to interact
between the different teams.
Artifacts are consumed, are produced.
You also want to have
these coordinated releases.
Even before the release.
If you change
something your back end,
you want to know whether
this affect your overall
application which includes
an Android part or no.
You need this coordinated release,
and that is really one of
the strengths of Gradle:
one big project,
with sub-projects and it
bonds it up, all together.
In the end you
do not just shape APK.
You shape a product,
and there is more involved,
even beyond building this artifact,
so you want to do automated releases,
send release e-mails,
do all the provision
of development environments.
You might create some test,
some documentation with
test code.
Or code that has been
tested
automated manner.
(there is a lot to it).
To give you one example:
Linkedin, a big Gradle user.
2,000 developers,
2,000 components,
and they do about 300,000 builds a week,
and 1,000 release builds a day.
If you see that scale,
that is probably not the
scale of everyone working,
or in that room  now,
but if you are working
in such a environment,
if you have a very disconnected build,
artifacts here and there,
and then you just
somehow put it together,
it is not going to scale.

Let's take a look at
the Android build system.
The Android build system is
a beautiful piece of
software in my opinion.
Because it takes the best
of read of different things.
It uses the Android Studio IDE,
it is your user interface,
based on the IntelliJ platform.
You have the Android Gradle Plugin,
which is then again based
on the Gradle platform.
And you have the Android Tooling.
We want to look at today
the Android Gradle Plugin
and the Gradle platform,
and treat them as one.
In the end,
you do not care; when your build is slow,
whether it is the Android Plugin
or it is the Gradle build.
Your build is just slow?
Or it is fast, but then
you do not care neither.

What makes it so nice
about the Android build system
is that there is a single source of truth
when it comes to the build logic.
The build is the only place
that defines what your build does.
There is nothing on top of that in the IDE.
When you open your project,
you do not go into your IDE and say,
I also need this
library and that library.
That is all defined by the build.
It is visionary,
before it had not been done.
You do
configuration in your Eclipse,
(e.g. Eclipse with Ant before).
You had to do everything in
Eclipse for Android development.
To define what
dependencies you use,
you do that in your build.
Where are my sources.
You do that in the build,
but not in the IDE.
The IDE will be configured
based on your model.
I will show you
that in a bit more detail.
Up on the left you
see the Android Studio,
that is you, the developer,
working Android Studio,
In the end, since the build,
Gradle is the only place
that has the build logic.
It has to communicate with Gradle
to understand what it has to
present/do.
That happens through the Tooling API.
Does anybody know what the tooling API is?
Or that it exists?
No one.
That is interesting.
When you
have the Android Studio,
the Gradle build, the
way they talk to each other
is through a
library called tooling API.
The tooling API lives
in the Android Studio
(on the class path of the IDE).
Through
interprocess communication,
it talks to the Gradle build.
The Gradle build
(Gradle daemon)
is a separate process.
If you want to compile,
the interstudio will tell
the tooling API, compile,
and the tooling API
will talk to the daemon
through interprocess communication.
Daemon
will compile that build with that task.
That is how it is working.
If you come from the command line,
you still interact with
Gradle. With
the Gradle daemon, if you have it enabled,
but you just come in
through a different way
(the launcher).
You do not come in
through the tooling API,
but through the launcher.
If you are in a continuous
integration server,
you also involve Gradle directly.
All that just works
because Gradle is the single source
of truth when it comes to build logic.
Everybody carries Gradle.
What are my projects?
What is my compile class path?
What is my test compile
class path, etcetera.
To dig into
that a little bit more,
the tooling API (in green).
It is a proxy
for talking to Gradle.
We will see some of the
benefits on the next slide.
There is also a mechanism
to provide custom models.
That is exactly what
happens with Android.
How does Android
get all the information
it needs from the build
that it can present it in the IDE,
or configure the IDE
(your custom model).
Android asks Gradle,
please give me that model
for Android.
Android, the model comes back
and it contains all the
information about the variants,
and the flavors.
IDE can consume that
and configure the IDE accordingly.
If you want to look at it,
it is default Android
project that is the model.
(that is what the Android guys do)
They write a model,
provide a plugin.
That is what you always
supply in your script?
It says supply plugin something Android,
and registers that model.
You can ask for that model
through the tooling API.

There is the client
VM (the IDE).
That is the little chore file
(800 k's or so).
It asks Gradle,
through the tooling API,
give me that build model
or invoke some tasks.
Build models you ask for,
to configure the IDE.
Invoking build tasks you
execute something in the build.
Some of the
advantages of that approach
is the backward
compatibility.
Even if your Gradle build used 1.0,
you could still talk to it.
You might not have all the
functionality available,
but it is still compatible.
You have Runtime Isolation.
Let's say Gradle had a memory leak.
That would not affect Android studio,
because it is a different process.
If Android Studio had a memory leak,
Gradle would not be affected
because it is a different process.
(Two sides to look at it).
There are some high level services,
so you can cancel a build.
That goes to the tooling API,
whatever it does, it will stop it.
It has a continuous mode.
I will show that later on.
And you can also execute tests.
Android Studio is not using that,
but I think
they will at some point.
If you have a specific API
on it when you run a test,
that the test is executed by Gradle.
Which makes sense,
because only Gradle knows what
is the class path, etcetera,
to run that test.
The IDE does not really know.
It can only do an approximation.
There is an event model,
as you run a build through the
tooling API you get events.
Of course you get all the log output.
You get progress.
But you also get events like
configuration phase starts, stops.
Execution phase starts, stops.
Tests have started. Tests have
finished or failed, etcetera.
All this is consumable
through the tooling API.
And if you looked up build shaper
or Gradle integration for Eclipse,
you would see that if,
when you are on the build,
you see a tree that shows you
all these events happening.
Why is all this possible?
Gradle has a very rich model.
By having a rich model,
it knows all these things.
It knows what they mean.

With that information
there is so much you can do.
If you compare this to an Ant build,
and I am not going to say
anything against Ant,
but when you do something with Ant,
Ant itself does not know
what you are doing.
It is very imperative.
There is no way to
provide these rich models
like they are, it is the case in Gradle.
Regarding perfomance.
We all want
performance to be lightning fast.
I used this picture
because it also uses
parallel lightning going
from top to bottom.
Which is that key
aspect of performance:
doing things in parallel.
What is our goal?
Our goal is to minimize the build time,
to say it in a simple way.
Using
as little memory as needed.
Why?
We want quicker feedback
about build figures.
We want to do more builds per day.
We want to do more releases per day.
And we want to do more rounds
on continuous integration.
(and many more reasons.)
There many more reasons
why we want to have fast builds.
When you do development,
from one round to the next one,
usually not much changes in your build.
You might have this complex build,
but what do you usually do?
You change some source files.
You change some tests.
Maybe once in a while
you remove a resource
or you add one.
Or you add a dependency
or change a dependency
but that is already rare.
You do not do this for every build.
Between these consecutive test runs,
typically not much changes.
And if not much changes,
not much should have
to be worked by the build.
When little changes in the build,
little work should be done.
That is something you currently
see in the Android plugin,
that is not the case.
Even if you have a big Android project,
Gradle task, or Gradle help,
it will take a while, and that time
is proportional to the size of the build.
And it should not be, because
when you say Gradle help,
you are not even executing
anything in your build.
When you do builds, do
they take longer than
you wish them to take?
Yes, nodding.
That is, for the most part,
due to the configuration phase.
we will come to that.
what is the approach at Gradle
to improve the performance?
that applies to the
Android perspective,
but also to all the other ones at Gradle
that are not related to Android.
Two approaches.
One is the evolutionary one.
You make little
improvements here and there.
They might have a significant impact.
and I will show that in a graph later on.
There is also the way to say
let's make some revolutionary changes
to make the next step
in terms of performance.
You might only
do local optimization,
but not the global optimization otherwise.
That is currently
happening. We will see that.
When you build with Gradle.
You have a two phase build.
Is anybody familiar with this,
that you have a two phases?
You have a configuration
phase and an execution phase.
Some people seem
to be familiar with that.

You say Gradle build or whatever you call,
if you ever go to the command line.
Two things will happen.
The first thing is the
configuration phase.
That is when your build logic is executed,
and the build model is built.
In the execution
phase, that build model
is acted upon, which means
the tasks are executed.
We will look at these two phases,
and I will start with the execution phase.
Because that is the one
where more has been done,
and then we will come to
the configuration phase.
What are we already doing in terms
of optimization during
the execution phase.
One is the incremental build feature.
If you think of tasks, tasks have
inputs and outputs in Gradle.
Meaning a task consumes certain
inputs, like a function,
does something with them,
and produces an output.
In Gradle you can
annotate, or declare,
what are a task's input,
and what are the outputs.
And with that information,
Gradle can do incremental builds.
If the inputs
have not changed, and the outputs
have not changed, there is no
need to run that task again.
let's say you have
project and you do a compile.
It has source files, no compiled files.
It will do the compilation.
Now you run it again.
Does it have to do anything if
you did not change the source
file or if you did not
remove the class files?
No. Everything is still the same.
And by using, by Gradle
knowing what the inputs
and outputs are it can do
that optimization for you.
So that is why, when you say
Gradle build, Gradle build,
if you have a normally
configured build, I would say,
you see it just up to date,
up to date, up to date,
and nothing really has been done.
Which is good, because
if nothing has changed,
nothing should be done.
Like I said before.
This is just a small example.
if you wrote your own
task, and it does not,
the ones from Gradle look very similar.
I wrote a task called conversion task,
and it takes a file,
it does something with that file,
and it creates a new file.
it is just a transformation.
What it does, does not matter,
that is why I put a comment there.
That is how you would call
it in your Gradle script.
You would just say I have a task,
it is of this type.
My inputs is one or more files.
I am using just this one, and
my target directory will reconvert
the files written to
this folder.
That is how you would use it.
By using these annotations,
the input files and the output directory,
you are now telling Gradle what are
my inputs and outputs.
And Gradle will manage these,
it will keep track of them,
so that when you want it, it will
remember what were the values
the last time you ran it.
If device is still
the same, it will say,
oh this task is up to date, let's skip it.
Who has used
Ant and has used
a time stamp approach to
see if no of the time stamps
have changed, and
then it is not going to do it?
There is at least one hand.
I used to do that too.
I had to do this every time again,
when I had such a task that was
sensitive to inputs and outputs.
Here it is totally baked into the system.

that is it. that is the conversion task.
To give you an idea
of what is input and output means.
We will come back to that concept during
the configuration phase.
That is why I want to show it here first.
There is another.
This is such a simple concept.
You have an input, you have an output.
You keep track of it or
Gradle keeps track of it,
and then you can do all sorts of things.
I just showed you the
incremental build feature.
Another one is the
continuous build feature.
What you can do is,
and even you could do that
with an Android build, it is not
specific to any type of build.
I am just saying gradle
that is a Gradle wrap,
or it would be Gradle.
I say test dash t.
Dash t stands for continuous mode.
You can see
it starts to build, it does
whatever it needs to do,
even if you did not have the dash t,
build successful. Whether they did
something or not does not matter
total time, but then you do not
get back to the command line
prompt. It is saying
now waiting for changes.
Then it is just waiting there,
and if you now change
something that is an input
of the task invoked, then it
would automatically trigger
the build, and do what is needed.
Let's say
you write

documentation using
something like Asciidoc.
You are always changing the file,
running Gradle build.
Changing the file, running Gradle build.
With the continuous mode, you just change
your file, and you go to the browser.
You say refresh and it is there.
As soon as you
change the source file,
and it is detecting the
change, it is going to rebuild
the artifact, and you are going to see it.
How does it know what you did,
what to track. It cannot
just track your whole file system.
What does it track is your inputs.
If your task has defined the inputs,
then it knows where to look for changes.
It will just watch these
changes if they happen.
If they happen it knows
to trigger a build.
Very powerful
feature that is possible
based on this very simple concept
of declaring inputs and outputs.
That is really key.

The more you tell Gradle
what you are doing,
and what you have, the more it can do it.
The more smarter things it can do,
without you having to do them.
You could implement yourself,
like a watch mode, and
there even plugins for that,
but now it is available to
every task that has inputs.
In terms
of performance improvements,
they are applicable to
Android projects as well.
You can command the builds;
have been there for a very long time.
But if you have a big project,
detecting whether something
has changed or not took quite some time.
It had to go over all
the files, create some,
look at the time stamps, do
some check sums, etcetera.
Just to decide whether
everything is up to date or not.
Or something is out of date or not.
And it is especially painful when you have
a big project and nothing has changed.
Because what it will do is will go through
your 400,000 files just to realize
nothing has changed
And that takes time.
In just the latest release
that is RC1 is out now,
there has been some improvements
to the management of
these file check sums.
If you have
a very large project,
you will see that if you
have almost no changes,
that will be much faster to detect.
If you have a small project,
you will also notice a difference,
but it is just not as spectacular
as the project is big.

That brings us back:


if little has changed,
little should happen.
Next: fast compilation
for continuous mode.
Let's say you are using
that continuous mode,
you are making changes,
It is always building
as things are changing.
If you are compiling as part of this,
this change that happens,
Gradle will spawn a compiler daemon,
by default at least for Java.
The other ones you can configure to
use a compiler daemon.
With continuous builds
this daemon will stay alive,
even as the build round.
As long as the build session
of a continuous build rounds,
the compiler daemon will be there.
Everything that is already
there is much faster to use
than if it has to start up,
it has to warm up.
These are all
evolutionary improvements.
Let's look at the configuration phase.
If you look
at your build scripts,
even though in
Android it is declarative
as soon as you do your own stuff,
it becomes imperative.
Even if you do not
write any imperative code,
what happens behind the
scene by the Android plugin
is quite imperative.
You might have a
DSL, that is declarative,
but what Android has to do
is imperative.
And as soon as it gets imperative
in your code or in the plugin's code
Gradle does not know what you are doing.
And if it does not know what you are doing,
it cannot optimize things.
What do people do?
They do things lazily because
it should not happen early,
Or  use lazy collections.
They detect all the
changes that come later.
Or they use the project afterEvaluate,
which is a hook where it allows you
to say, the
configuration phase is finished,
now let me do something.
What if multiple people add such hook?
Who is add, who is going to be called first,
who is going to be called last.
There is trickery
to make this work in a complex
set up like the Android build.
Is very complex if you think
of build flavors,
Android has to know.
Are you done declaring
your build flavors?
Until that is the case,
they cannot redo anything.
But when, it does not
know when you are done.
It has to do these late hooks
that do not work.
What you end up with is a
declarative build model.
That is the output
of the configuration phase.
This is declarative, you have your model.
But the problem is Gradle
does not really know
how that model came together.
It just knows it is here.
Next time you are on a build,
it has no knowledge how it happens
so it has to do everything again.
Another problem is
it is building the whole model.
Even though it will
only build some things.
That is
described with Gradle help.
It will build the whole model even though

all you really want to
do is call Gradle help.
How much time was invested to what
you wanted to do.
It is not in
the correct relation.


There is a solution for that.
Otherwise, that would
not be good.
For Android
at construction time or
at the configuration time
the whole model is built.
If you have a big project
(400 project),
project build and ten variants:
it is huge.
That is why things take so long.
I think at the Android
team
takes two minutes
to just call like Gradle tasks
(because it has
to build so many things,
which takes time).
The other thing is that
it has to do the full
dependency resolution and the processing
at evaluation time, or configuration time.
It does not
know all the flavors you want to have
until very late. Then it is so late
that it have to do stuff.
What has been done until today
to improve the configuration phase?
The build script, they compile faster.
Caching happens there,
in a reliable way.
As we use new versions of Groovy
to do the parsing of the DSL,
it get's faster,.
Gradle is not written in Groovy.
People think that.
It is not true.
The DSL layer is done with Groovy.
there is another feature
called configure on demand.
Maybe one or the other
has already used this.
It allows you to,
when you run some tasks,
only configure those projects
that are reached by those tasks.
It is only working
under certain conditions,
and if you violate these conditions,
the output is not guaranteed.
But if you have a clean
project, that does not try
to poke into other projects
of the same build,
then using configure on
demand works well.
It will not
go through these projects
that are not
reachable from the task
you want to run.
Let's say you have a
project, you run build,
and you have a compile
dependency on another project.
It will also configure that other project.
But if a third project is not
reached that way, it
will not configure it.
Which can save you time.
Again, these improvements
are evolutionary.
Let's look at the Android build.
A graph.
To set the stage,
the Android team and the Gradle team
have really good relationship,

mutual benefit.
That comes out of this relationship.
If I am pointing out some stuff
that concerns the Android side,
it is not finger pointing at all.
It is really working on
the solutions together.
If you do a clean install,
time, in this example,
is used for the pre-dexing.
All your libraries
that you are consuming
through dependencies, they
have to be dexed.
That takes a significant
amount of time in this build.
You will see it says clean
install.
They should not be upper case,
but it does not matter.
Once you do this and you run
the build again, they are cached.
It only happens once,
but still that can hurt
the first time you do it
if you have dependencies.
There is potential
for optimizations,
for the pre-dexing.
For instance, we want to have a clean,
safe cache, but it is a generic cache.
Which means if you have dependencies
and they need to be transformed
before they are consumed,
that should become part of Gradle,
and then it can be used for
the Android plugins as well.
The other one is parallelization.
This pre-dexing could happen in parallel,
but it is currently not
happening in parallel.
Something that Gradle
could support,
that this pre-dexing
can happen in parallel.
The third one is
a distributed cache
that is
already on the road map
(without a date though).
Let's imagine
you are a team and you
have a distributed cache
that lives somewhere.
The first person,
you doing the build,
will trigger the dexing
or pre-dexing of these libraries.
Other developers will also
call the build.
The pre-dexing
will first check the cache
if it is already there.
And if it is there, it
will already be consumed.
This reduces the time
for pre-dexing on your
local machine to zero.
That is another aspect.
Before going
to the distributed cache,
it will check locally if
something is already there.
If it is not there, go
to the distributed cache.
If it is there, use it from there,
download it, store it.
Like consuming
an external dependency.
Dexing
(you can see on this graph).
Again, takes a
significant amount of time.
There is not much Gradle can do.
This is really more in the hands
of the Android team,
but they are working on
a new implementation, as
I understand, is Jack.
Which for one can do faster dexing,
and the other one is it
can do incremental dexing.
That is currently not happening:
you change one file, it
has to dex everything again.
That is the current state.
What has been already
optimized to this point.
These are evolutionary changes.
Still some limitations.
Android is affected.
All the other builds are affected as well.


The bottleneck
that we are focusing
on now is the configuration phase.
Everything is built
into a build model that is then consumed.
Even if nothing needs to be consumed
off that build model.
You are just calling Gradle help.
That is called just a
new configuration model.
This is really revolutionary.
It is not just tweaking a
little bit here and there.
It is really
something that we build up
in parallel. Also have
some bridging to make
the old world work with the new world.

Having all things available
but only needing some things,
we will go to only knowing
what we need for building.
This new configuration model.
I will give some code examples.
It comes back to
what I just explained
about execution phase is
we want to know about the
inputs and the outputs,
because if you know
the inputs and outputs,
you can start, you know in
what order to do things.
You can start doing things in parallel
because you know you can build up a graph.
If you have a graph,
you take the trees,
the sub-trees, and you can
build them in parallel.
There is so much you can
do once you know this.
(What has already been
done for execution phase,
will happen for the
configuration phase now as well).
The key aspect that will change
is that you will describe your model.
It will be very declarative.
You say, watch my model B,
and then Gradle will
derive the implementation.
It will manage the model.
By managing it, Gradle
can be smart about it
and what it does about it.
It will allow you
to do richer modeling.
You can already see this
in the Android build.
They did an awesome job
of how you model a build.
If you apply the plugin and you have this
Android extension.
All the things you do
in a declarative way,
and so much magic
happens behind the scene.
It is really great,
especially given those constraints
that I listed before.
Android will really benefit from that
because they can get
rid of all the trickery.
It will be cleaner modeling,
because now if
you look at the tasks,
you would see that
there is execution logic,
as well as configuration logic.
That will be a clean separation.
The task, or it will not
be called a task anymore,
but you have your manage types
in all they contain is data.
There is nothing on there about execution.
You can collaborate better.

You do not know when things are ready,
so you have to do them very late.
That will go away.
It will be really easy to say
I am the one creating it, OR
I want to add defaults,
OR I want to mutate it,
OR I want to do something at the end,
or I want to do validation.
So much more deterministic.
And comprehensible.
By having a model,
like for the execution,
we have a task and a task graph.
If there is a model for your build,
and you know where things came from,
you can do really interesting reports,
and you know why things are happening.
Because you know who contributed what.
Let's look at the code example.
We have this managed
typed here called Picture.
It is in an interface.
Gradle will provide implementation,
such
that it knows if somebody sets the name.
If it knows who sets the name,
it is something it can report on.
I also knows I can derive
things from that as well.
Another advantage
of these managed types
is that they can be persisted.
As it goes and builds that model,
if there are certain
things it does not need,
it can write them to this,
gloat them again later.
Or it can store them in the daemon,
and when you run the next build,
it can reuse them, it can cache things.
That is why they are externalizable.
This is an example.
Has anybody written a Gradle plugin yet?
One person
who has written a Gradle plugin.
This strange a little bit.
By now it looks like this.
Very declarative.
You basically say, I want to,
there is a model for creating a picture,
and there is a way to mutate the picture.
The picture is passed in,
and you can set this argument.
When you set them,
because the implementation
of picture is controlled by Gradle,
again, it can track, and
knows who did these changes.

There is more.
But I just want to give you
a little overview.
The last part is providing
a DSL (as a developer
of an Android application,
you want to declare what to do).

Based on the example I just show,
you say ok, here is my model.
Here is a picture. I want to
create a new picture instance,
or picture node, and I want to
set the name to something,
and I want to set the tags to something.

This looks very similar to how you do it
in the Android plugin,
but the difference is the implementation
of all this is controlled by Gradle.
By knowing this,
it can be all the
optimizations I mentioned.
To give you an
example.
We have a report here.
Exactly for that example I showed.
This createPicture,
it can see what the type is.
You can see who created it.
And you can also see what were the rules
that were applied on that picture,
so the configure was
called after the creation.
You can see
it for every attribute,
who created it. What is the
value. What is the type.
With all this rich information
there is
smartness that can happen.
If you take the latest Android plugin.
It chips really with two plugins.
An old version and a new version.
And the underlying logic of
what to do during the build
is the same, but the way
it is configured is different.
One is using the new model,
the other one is using the old model.
You have to use
this model, outmost keyword.
And then within you say Android,
and then it is very similar.
it is not complete yet.
it is really work in
progress, but every time
a new Gradle release comes out,
they make use of the latest features,
and adjust their experimental plugins.
At some point, this plugin will become
the default plugin.
Not so nice things.
You have to use the
dot notation;
and you have to say
create if it is a new one,
you can use just the name
if it is an existing one.
That' will go away, sure.
But I hope this gets you excited
that you see Gradle makes these changes.
driven from Android,
but they fit into the
big vision of Gradle.
And Android consumes them.
The release by release,
making their plugin better.
What do we get from doing all this?
The configuration will
become parallelizable
like the task execution
can be parallelizable.
Manage times can be externalized,
which is important when
it comes to caching.
The model can be
reused across invocations,
because Gradle knows the
inputs and the outputs
for the configuration phase .
It knows if it can
reuse something or not.
It knows everything, basically,
and by doing this it can do the minimum
that is required to do.
That is really revolutionary change.

We do not want to break what is there.
Everything happens in
parallel to what is there;
and there is bridging from
the old work to the new.
That takes some effort.
It will not be a big bang.
It is already used today.

Soon, with the new Android plugin,
or with the new Android plugin,
the C++ support that it
has for building the NDK,
will already use the
Gradle plugin for C++,
and that is already based on this new
configuration model.
They are really
sticking to it.
If we look at the roadmap
for the next six to twelve months,
without any guarantees of course,
these improvements
are very high on the list.

Android is a very
important ecosystem for Gradle,
but also the other ecosystems
want to have better perfomance.
Everybody wants better performance.
There is
investment going on there.
The other one is
autocorrection,
it should say generify
dependency management.
There is not only
dependencies between libraries,
you can also see dependencies
between much higher level constructs.
And that is currently happening as well.
I am not going to go into that,
but I want to go into
performance just a little bit.
We have these hotspots
that we try to indentify,
and once we fix them,
the next one will show up.
Everybody that has
done performance profiling
knows how that works.
Caching and reusing is
ra key aspect.
We use what's already there,
rather than rebuilding it.
Doing work in parallel. that is huge.
In parallel means for
run on the same machine,
but it can also mean across machines.
Distributed build
will come as well.
You have a build,
you use different things,
you need to configure things.
That can happen in parallel.
It can even happen across machines.
And doing work in the background.
The continuous mode that I showed
is one example.
You do your work, and
while you do your work
Gradle can already see
if something has changed,
and if it has changed it
can already prepare it
such that when you do want to run it,
it is already there.
All these techniques
that I just mentioned
(lefthand side),
can be applied to many
things on the hand side.
The current ones focused on:
build configuration.
that is what I just explained.
The next one will be
dependency resolution.
Things can
happen in parallel there too.
Caching already happens,
but more can happen.
And task execution.
 has been done here already,
but more can be done.
Let's imagine you are tasks
are fully managed by Gradle,
which will be the case with
new configuration model.
Then you can run these
tasks in parallel.
And once you can run
them in parallel, I mean,
and Gradle knows what
can be run in parallel,
it is a huge step forward.
You can already enable
that to some extent,
but it is not super deterministic
because Gradle does not really
know what your tasks do.

So if we look at, at the performance,
this is just some like, some tests we ran.
If you use this new approach,
totally based on these managed types,
this is not an Android build, but still,
even with a Gradle builds
you can have variance,
the concept of variance came out of
the Android requirements,
but it is a concept
that applies in general, like,
even a varience could be building against
JDK six or seven or eight,
these are three different variance.
If you build one variant,
with this managed model,
takes zero time.
If you build one project,
takes some time.
If you build all, takes more time.
The key is: the less you do,
or the less you want to do,
the less Gradle has to do.
That is the thing.
If you want to do a full build,
the new model is not
going to give you that much.
going to give you some,
but it is not great.
Or not very significant.
The less you do,
the less Gradle will do,
which is to your benefit.
I think that is very
visible with this curve.
To round this off,
because this is important
to the context of Android,
as well, dependency management.
There is dependency management,
You can have your
dependencies on the variance.
But we want to go further.
When you consume external libraries,
you want to consume the variant.
Let's say you create
a library in variant ABC.
Now we have another project that consumes
this library and it also has variance ABC.
You want to consume the variant,
of that external dependency.
Same for native libraries.
You also want to consume the one.
I you are
on the debug build type,
you want to use everything
n debug.
By storing this,
this extra meta data with these variance.
And then when it comes to resolution,
it will try to pick the variant.
If it finds one, it uses it.
If it does not, it will blow up.
Same will happen in the Java space.
If I am building
a library for JDK 8,
and you are depending on another library,
if that library says,
I am only available or
I am only, I am a variant
only for JDK 9 and later,
it cannot use it.
This will
be full variant
of variant dependency management.

To round this off,
we are also working on Gradle.com
We see Android
as a really interesting target for that.
As you run your build, you can upload
like a build receipt to Gradle.com
and you can share this with
people you want to share it.
Let's say you have a
build master in your team.
You have a local problem.
You can upload that and your
build master can look at it,
and based on what he
sees, he can figure out
what is the problem.
What has changed.
Other things are, you build,.
It is all good, and then suddenly
this build stops working.
What happened?
Maybe you realize
a transitive dependency has changed.
All these things will
elp you detect
what is going on.
It will also help you detect errors
and propose solutions.
That is currently what's
going on with Gradle.com.
Let's say you want to go to the form,
you had some problems building.
You can just attach a
link to the build receipt
and then somebody can go on it and say
I see a problem here.
Somebody else had that problem too.
there is a link to the form, etcetera.
That is coming very soon.
it is in full development now.
We are making progress there.
Not sure if anybody
knows theres a udacity class
on Gradle and Android development.
This has been done
together with Google.
Awesome class.
10,000 people have already
signed up for this.
It is a good way to learn Gradle
in the context of Android.
  y
Gradle is a great company to work at.
And there are always more people needed.
And that brings me to the
end of this presentation.
(audience clapping)
- Ok, thank you very much Haten.
There has not been any questions online,
but I do not know if anybody
has a live question now?
I think that is
good,
because time is up.
Thank you again, very much,
and remember to write
feedback for Haten. Thank you.
(audience clapping)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>