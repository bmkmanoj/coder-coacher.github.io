<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Microservice Panel • F. George, R. Johnson, J. Kerr, M. Nygard &amp; S. Newman | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Microservice Panel • F. George, R. Johnson, J. Kerr, M. Nygard &amp; S. Newman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Microservice Panel • F. George, R. Johnson, J. Kerr, M. Nygard &amp; S. Newman</b></h2><h5 class="post__date">2016-08-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/r18BaOHRpE8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yes we thought it might be fun we've had
a lot of interested microservices we are
in a big room for the big reason there
are lots of people been coming along and
we have a bunch of people from different
backgrounds and have different
viewpoints on micro-services some people
here do not agree with me that's Fred
and so that's why you know I like having
this it's good to have enough conflicts
of interest to be nice so we're gonna
get some questions coming in from the
audience you should be able to go and
ask questions on the app although we've
had a couple of little niggles with the
app for the last couple of sessions but
I'm going to kick things off in a minute
but before we get going with the
questions from the audience I thought
maybe asked people to briefly introduce
themselves and sort of what their
exposure to micro services has been so
maybe we'll start with you Fred thank
you hello yes so my name is Fred George
I've been playing with micro-services
off and on for about ten years I've made
a lot of mistakes in the process and so
I'm very very precious of how I do them
now I'm brought Johnson I guess I partly
got into micro services through spring
not because micro services and spring
synonymous because obviously micro
services much more than any specific
language or any specific framework but
because really micro services is
actually the architecture that spring
always wanted to be like back in the
early days of spring OERs felt that the
big fat monolithic application server
was not the way to go that the way to go
with small pieces of functionality that
were coupled through well-defined
contracts and you know micro services
totally fit with that vision and I'm
very excited to be trying to play a role
in that future good morning I'm Jessica
Kerr have been a developer for 15 years
and I've been fascinated by micro
services since I saw since I heard Fred
talk about them for you
years ago at our dev and at the time I
was like lots of languages itty-bitty
little things that we can throw away and
over time you know I'm not so keen on
the lots of languages or the super small
size or they're throwing them away but I
am still really keen on micro-services
because they represent a form of system
evolution and I'm fascinated by the
evolution of the complex systems that
are our software today hi I'm Mike
Nygaard developer architect operations
and author my particular focus is on
building software that survives
production in the real world I spend my
day job doing two different things
developing really small loosely coupled
parts enclosure and consulting to very
large companies that wish they could
move faster so I have this sort of
whiplash when I go from one gig to
another gig so I'm constantly looking at
ways of evolving things faster and
dealing with complex systems but I'm
also always wary of the production
overhead and burden and performance
implications and stability implications
and so on so I look at things with a
jaundiced eye if I can just bite in here
if you haven't read Michael's book you
really should thanks we you get a cut on
sales for the anyway we I am now obliged
to agree with everything rod says so
maybe just to start a question for me
and we'll start taking it for the
audience why is there an interesting
market services now what's what's been
different over the last couple years why
is it the buzzword is your I think first
of all we had a big architectural
enabler
through the in fact we're using virtual
machines and now containers and so it's
now easy to build and package very small
pieces of code and deploy it versus you
know allocating an entire machine for a
process I think that's been the key
enabler that I've seen yeah I'll let on
to that that the other enabler was sort
of motivated by virtualization which was
all the automated operations tools and
particularly automated operations that
was open source so you didn't have to
commit two million dollars to implement
HP openview for your company yeah I
think there's also been a broader
move towards using larger number of
smaller boxes that's been going on for a
very long time but you know I think that
micro services and containers really
make that a very feasible thing and I
think actually one of the major drivers
is doing it the old way is becoming
increasingly problematic
we've got more client types you know
there's such we need to deliver business
functionality faster although there are
challenges in adopting micro-services I
think we'd learnt that the old
monolithic way was kind of getting
toward the end of the road I agree our
systems are getting so big now that we
just have to break them up or they grind
completely to a halt and we can't change
them because change is too risky so
we've had to find a way to be able to
make changes at a smaller scale to
decouple the work of one team from the
18 other teams in the department so
we've had a question in thank you
audience I like these things coming in
it's a bit impersonal someone so Jessica
alluded to the size of microservices
some authors have suggested
micro-services should be replaceable in
a single sprint is there a right size
for a micro service now I might start
with Fred on this one because I know
Fred you have views one of these we we
sort of settled on in Berlin some of the
micro service conferences is we kind of
all agree that if it's if it's more than
one programmer to develop and design and
maintain it it's not a micro service
mine tend to be smaller a tenant will
have 30 or 40 micro services for a team
of five or six people so generally they
are quite small in my world but it's
more than one programmer can sort of get
their head around you're probably not in
the micro world I think you get a whole
team and a team could be ideally like
fewer than six and then it has but
that's just to be an independent service
and to me a micro service is I don't
care about the size what I care about it
does it represents like one business
concept and capability and that it keeps
its data to itself yeah I tend to agree
with Jessica I think that one of the
major dry
is the data and you know so to whatever
size is appropriate to be self-contained
for that data obviously you don't want
to have a god database like obviously
you don't want to have you know an
Oracle RAC database that's trying to
scale out massively and have your whole
enterprise data model but you know if
there is some distinct piece of data
that needs to be managed for your
business that I think often indicates
the appropriate size of the service in
front of it I view things on a little
bit of a different axis I like to see
all of our code being disposable code so
if something starts to get big enough
that you view it as an asset that's
worth preserving then it's too big and
you should target it for destruction I
think once we start viewing code as an
asset where we're stepping down the dark
path yeah I won I think echoing things
that both Fred and Michael have said one
thing that I think about is whether or
not you could re implement it so
micro-services should be small enough
that the risks of experimentation are
reasonable
so let's suppose you want to write a
micro service in Julia or some other
language or framework that might be
perceived as risky in you know in the
bad old days that's like our
architecture is eg B's that run on
WebSphere you can't use anything that
doesn't fit this architecture the micro
services world is very different you
should be able to try experimentation
and you know what if it doesn't work out
you should be able to reimplemented
micro service without you know a massive
amount of time being involved sort of
moving on from that I mean Jessica
talked earlier about this idea which you
heard about micro services like great we
can experiment with all these different
languages and that's changed over time
so what are you know what do you think
about polyglots in this world and maybe
just for fun we can start with Mike just
for fun because I work for the company
that backs closure yeah I thought that'd
be fun I mean so so do you do you buy
into the whole idea that we should be
polyglots with our Marko's architectures
so I definitely view Polly it as a
benefit that micro services
allow you to be polyglot I don't hold it
as a goal to be polyglot but allowing
diversity in the tech stacks and and
reducing the cost of changing a decision
in each of those implementation points
is really valuable I've been at a lot of
companies where well I'll give you a
concrete example I was working with a
company that had their own
implementation of JDO that dated back
from like the first dot-com crash the
Java you don't want to know really but
this thing had had been a good idea at
one point in time and now it was the
foundation for their entire business
they had thousands of objects being
mapped through this thing it was their
own implementation it had diverged from
the beta of the standard you know there
were a lot of ways in which they wanted
to get off of it but couldn't because
absolutely everything used it so the the
idea that you enable polyglot languages
and frameworks and tech stacks is great
because then you can do piecewise change
and let people experiment with the
different text ax and say yes this is a
good one we should talk about it amongst
ourselves and maybe spread it further
but it doesn't mean everyone then builds
into that it means you know you still
have the ability to change point wise
Fred I know you had a lot of stuff going
on yeah I feel it just polyglots an
aspect of environment like to create
which is just an aspect of innovation
which you want to turn your programmers
loose without constraints and so the
fewer rules you have to put in place the
better off you are in most cases they
tend to you know choose a couple of
different languages to work in maybe two
at most
so they settle on it but having not
having to tell them which one to use
gives them some ability to innovate in
that space and lots of other things like
that are key to innovation it's just get
rid of the rules turn them loose with
the problems i I think what Michael said
about the decoupling that is necessarily
happens when you support polyglot is
really important and so I like not using
all the same language just because it
forces you to not in mesh in this giant
framework that is
dependent on that however I'm I'm not
really impressed with the you should use
the right tool for the job but I think
we've emphasized that that you should
like pick the language that perfectly
fits the problem that can get really
painful switching from one language to
another
having forbid you have 40 or 50 micro
services on your team and you're going
from language to language all day I do
that at work I work in too many
languages already and it's painful so
when you're picking the right tool for
the job that job is not just the
business problem you're solving it's the
ecosystem you're working in it's the
deployment tools you have
it's the languages that you and your
team are familiar with you are part of
the system
that is the problem you're solving so
what you happen to know already that
matters I think it also comes down to
what are the operational and contract
requirements of the individual services
so for example I certainly wouldn't
advocate write all services in Java or
or closure or Python or any other single
standard language I think that is a
mistake and I think that does crush
innovation as fred has mentioned however
I do think it is reasonable to impose
certain standards that might be agreed
by the overall organization like you
know what if you're going to expose a
restful interface maybe you need to
provide a swagger description of that or
you know rental or whatever your
preferred lingua franca is I do think
it's quite reasonable to say you can
write it in the language of your choice
but it has to behave in certain ways
maybe it needs to provide certain health
check endpoints to enable it to be
managed I don't think you can have it a
completely black box where you know god
help you what you're going to get when
you invoke it because there's no way you
can know yeah so if it's a 12 factor app
it doesn't matter what it is inside
because you can operate it and monitor
it the same way I wanted to represent
another point of view that that Fred and
I got to hear from Chad Fowler from
wonder list where he talked about being
in he talked about enforcing polyglot
through his team specifically so they
would not create reusable libraries
he wanted to make sure nobody was
sharing code and making reusable
libraries that would be a point of
coupling across the different services
now that's a pretty radical perspective
I wouldn't necessarily advocate it
everywhere but it's a point of view that
that's succeeded for them
I do think also that there is no
one-size-fits-all answer I mean
micro-services architectures are
inherently linked to the organizations
that develop them and you know different
organizations have different cultures
not every organization wants to have the
same culture so you know I think it's
appropriate to consider that and I an
organization may come down on a
continuum you know between point a and
point B in a different but quite valid
place to other organizations sort of
related to that extreme chad fowler
example chad does like being extreme his
concern there is driven about coupling
you know that those libraries are
coupling how do you manage coupling and
also point actually how do you manage
contracts evolution how do you avoid
breaking other services and and what
what techniques have you seen work or of
course I advocated techniques associated
with event busses and asynchronous
services and the coupling level is
basically at the messageformat levels
but we practice very permissive
structures in that structure we learned
our lessons with XML so it just has not
been really an issue relative that in
fact we had over 300 micro services and
zero documentation of our message
formats didn't need it I was a bit
surprised by that but that's that's
actually how it turned out
if you get the coupling between services
level there's there's a there's a
spectrum here there's a trade-off at one
extreme you have backwards compatibility
like the stripe external API is fully
backwards compatible not only a read
backwards compatible but whatever
version of the API you receive when you
first call it you will magically get
that forever so extreme lengths to
backwards compatibility is a technical
solution to a problem on the other side
you have what we do more of internally
which is coordination which is you're
actually working with a team to say okay
we're gonna change this for
backwards compatible and then you're
gonna do the release and then we're
gonna drop the old one and that's less
code and more people interaction so I
think I think you've got a you've got a
trade out there I think this is an
important area where there's
significantly more work to do
because I think that essentially you
very often get services that are coupled
by something either it's a message
format or actually a contract and I do
think that people need to be very
mindful about that I think I think they
should be explicit which is why I really
like any form of you know strong
documentation whether it's swagger or
whatever it is or in message formats you
know it it will differ but I do think
that it's pretty important to be
explicit I think it can help developers
it can help testing it can help
automation and it can also help you spot
things that might break before they
actually break yeah I'm I'm with rod on
this one and not just because he plucked
my book earlier but but truly with him
on on it we've actually been developing
some tooling that would take a swagger
specification and apply a derivative of
our simulation testing techniques so we
can exercise an interface and say look
your your protocol states that you allow
these inputs we gave you an activity
sequence that included these inputs and
look at the way you barfed all over our
shoes by using that kind of technique
and generative testing we get a lot more
bang for our buck than we would with any
kind of unit or integration testing and
then also by having that specification
we can apply mechanical tools to say
your new version is only expanding the
contract therefore it's backwards
compatible or we can say mmm you're now
requiring something you did not require
before that's a contraction in your
contract not allowed that's a breaking
change and and by doing that we can
apply rules locally at the levels of
individual services that make them
better citizens in the ecosystem yeah I
I strongly agree because I think the
reality is that complexity never goes
away
we're in an essentially hopeless
industry fighting a hope
spero no matter what we do better than
we did last year or yesterday people
come up with new requirements that it
make life harder right they want stuff
that's more complex they want stuff
faster so we're always fighting entropy
and the reality is if you get rid of the
monolith some of the entropy moves to
the kind of joins and contracts or lack
thereof between your micro-services and
that really is very likely in my
experience to bite you unless you're
actually very mindful of it I'll give
for the politic whirl on this book so no
he does not agree oh yeah I don't agree
with these guys it's nonsense but the so
degree my environments have been
different we've been developing
applications for internal consumption
within my companies so we're not trying
to publish api's we're not trying to
make contracts with outside world
we're don't have extra outside users
trying to use our system we've got to
figure out who to blame those are not
issues I had to wrestle with all I do is
build systems for an internal client to
make them happy they were sitting with
me we have those dialogues there I
didn't need to write the documentation
so I would I don't subscribe to
constantly you always need a document
because it makes it better or your
sponsors complicated I don't want to
spend the time doing that when it's not
necessary I got more things to do with
my money and so I want to go faster and
that will slow me down training track a
bit someone's asked a question about how
do you manage the front door when you've
got say a hundred microservices what do
you do in terms of having a facade to
the outside world is this where you'd
use an API gateway or what experiences
of you guys had of solving these sorts
of problems eventually they all come
down to something that looks like a
gateway slash router slash throttle so
that you know the the discovery and
location and naming is one very
important aspect but there's also the
operational aspect of saying at some
point your clients are going to go
berserk and try to kill your system in
fact sometimes you even do it to
yourselves I had a client that was
working with a channel intelligence type
of outfit and told them to go start
indexing every document they had at
which point they ddos themselves through
their channel
partner and if you don't have some means
of throttling that down you're just dead
so there's always some kind of a
boundary oh and put a boundary on your
outcalls as well because sometimes your
suppliers malfunction - have you got any
technology or any advice of stuff in
that space one thing that I heard in the
question and this is a little outside of
the technology because yeah I mean at
some point you have load balancing that
is hitting certain services but if you
have a hundred micro services I hope
those aren't all talking to the outside
world because at some point you still
need a level of organization above the
process so hopefully these micro
services are operating in little
ecosystems which themselves expose
certain api's that are more intended for
calls from either the outside world or
maybe from other parts of the
organization and it and some of these
hundred micro services are just little
aggregators that are like okay there's
these three internal services I'm gonna
put this stuff together and give it to
you in a format that is legible outside
this team I agree with Jessica's point
there I think there's stuff that we
learnt in the old world of writing very
large monolithic applications it can
still be valuable one is like if you've
got a number of subsystems in a large
monolithic application you want to limit
the coupling between them right you want
each subsystem to provide a surface area
that is manageable to other subsystems
and I see that is pretty much the same
issue as Jessica outlined except that
obviously it's with the different set of
technologies I think honestly if you let
your external clients at all your
hundreds of micro services and then you
you might as well give up because bad
things will happen they will happen yeah
I think the situation's kind of
analogous to if you're building a large
monolithic system and giving excess to
everybody to every class you have with
every public method available no there's
just a few of those outs to the outside
world
a few gateways into the system the
system turns on itself and spits the
answers back out and I do the same thing
when I build micro server systems sort
of sort of related to this in a way
how should micro sources talk to each
other
should they should they only ever use
asynchronous message buses should they
just talk via HTTP protocol 50 what's
the right answer
I I think there's no right answer to
this it I think it depends upon a lot of
the problem but I think there's it is
sort of an architectural decision to be
made quite early are you going to go
sort of a synchronous restful like
registration process or are you going to
try to you know decouple even further
and I think type of problem you're
trying to solve drivers that answer
I think typical systems will end up
having some cases of both but you know I
mean obviously stacking up synchronous
calls he's not going to work so you know
I don't I don't think that you can build
a system of any complexity purely
through synchronous operation you can
build a system of any complexity using a
synchronous invocation but in some cases
that will probably end up being more
complex than something that involves
some synchronous usage I mean I think
ideally we should look to technologies
that actually make it relatively easy to
make that choice so for example if I was
implementing a micro service I would
want to implement as much of the
functionality as possible so it could be
behind different styles of invocation so
for example I wouldn't want to you know
say if you're writing in any technology
that has web controllers some kind of
restful controller I mean obviously you
don't want to bake your business logic
in there because that's going to be a
problem if you ever realize that perhaps
a messaging approach was better I will
say that consider maybe not doing
everything over HTTP and JSON that is
like the first thing and it's the
easiest thing and part of the reason is
because it's kind of like human
understandable and one of the problems
with micro services is traceability
is how do you know what went where and
how do you follow the bits and if you've
got the JSON printing to the logs like
we do at every request then is that
helps with debugging and it helps with
human understanding it does not help
with speed so at the point where that
gets too slow you know can
that r0m queue or something faster I
don't not not a protocol person but then
consider how you're going to implement
traceability and how are you going to
add legibility to this system especially
as it grows and gets more complicated so
how should micro services talk to each
other why through circuit breakers of
course well that there is a resiliency
conversation to be had here isn't there
mic I mean there some of the protocols
we pick don't always lend themselves to
yeah I'm being a little tongue in cheek
of course but but in my workshops and in
my sessions I definitely point out that
you know most of the operational
problems we we incur come from
synchronous requests reply type of
protocols so it's not enough just to
introduce an event bus if you're gonna
do event style communication don't send
an event and then demand to get back
exactly one event you know sort of
announce what you have to announce and
listen for what others have to announce
and then synthesize your result but
don't just reinvent RPC over a message
bus yeah I actually think in terms of I
agree with Jessica's point that
obviously Jason serialization is
potentially very inefficient but I think
that as we all know premature
optimization is the root of all evil
very often I think it's actually a
pretty good starting point it's very
traceable as she said you know I I'm
always wary of saying well this won't be
fast enough so let's make it more opaque
no let's see let's see what happens
because it may well be that the opacity
is more dangerous than the latency
somewhat related to this area is a
cushion here around caching so can you
comment on caching between microservices
have you used reverse proxy layers or do
you only use caching inside the service
with things like Redis maybe Fred ID
we're definitely fans of caching
probably because we don't need we can
work with eventual consistency and the
problems we tend to solve so the fact
I'm a little bit out of date with
everybody else is kind of okay in the
domains I tend to work yet
and so I'm probably okay with caching
but it's it's something I don't tend to
put in there unless performance says
it's necessary and provide some value to
me I'm very lazy about what could I
decide to write because I rather write
new functionality then then make the old
work a little better yeah I mean coming
back to my point about premature
optimization and opacity if you really
want to make a system harder to
understand just sprinkle sprinkle some
magic caching pixie dust and you'll make
it very hard to figure out what's going
on obviously having said that caching is
very very important to making many
applications work and of course we also
have the option frequently of caching on
the client which can actually be really
good because it can avoid sending a
message or making a network call and
often it is the client that really
understands its need for updated
information so often the client
understands the tolerance for staleness
much more than something that the
serving content took the words right out
of my mouth this sort of outlines some
of the challenges there's lots of
questions to be answered here about how
to sort of talk how do you do handle
performance that's a lot to take in as a
question here was how do you know if
micro services are right for you I mean
is there any is there any organization
you wouldn't suggest micro services for
I've definitely walked away from clients
that said they went to micro services
and and generally I'm looking for the
enablers in place to be successful I'm
looking for an organization that if
maybe they don't have one-click
deployment but darn close to one-click
if they're not there if they've got
three weeks deployment process it's like
go fix that then call me
I'll also push pretty hard to make sure
that they have a problem that needs to
be solved with micro services that they
have a real problem that just just
doesn't is worth to a retraining the
program is refocusing our organization
resources and if you haven't got support
for almost from the top-level CIO level
that says I'm gonna make the sort of
transition because there is social
implications to how we're doing things
you're not ready for that you know again
walk away and come back when you're
ready Mike
yeah I definitely agree with all of that
you know moving to this style requires a
very high degree of trust in the
individual developers and and their
ability
to be responsible for the things that
they create and just most organizations
are antithetical to that kind of trust
especially the bigger and the older ones
I think it also depends on whether or
not the organization has a problem I
mean there exist organizations who are
successfully deploying monolithic
applications and you know I think one of
the dangers that can cause any
technology to get a bad name is when
people start to adopt it because they
feel they should adopt it rather than
because it really provides value for
them in particular so you know I think
that if an organization is perfectly
happy with their monolithic style maybe
maybe they should stay that I suspect
that most organizations are not but you
know I think we should be very careful
of just running after shiny objects my
first reaction is do you have to I mean
we're talking here about well how do
they talk to each other do we need
caching oh we definitely need circuit
breakers there's a lot of decisions and
oh and then there's there's
documentation and then there's the
tracking who depends on what and then
there's the traceability these are a lot
of problems that you just don't have
when something runs in a single process
do you need to take that on and I would
say you probably do at the point where
the coordination among people with
deploying in the monolith and they're
getting in each other's way but this is
not an all-or-nothing either you can say
this team is particularly on a different
deployment schedule than this team and
they're getting in each other's way
we need to draw a line here and separate
those pieces we need more disagreement
on this panel so I'm going to disagree
partially because I think and I'm going
to give another plug for Michael's book
because Michael's book actually gives
some great examples of where you can't
ignore things like circuit breakers and
monolithic applications so it may well
be that some of the complexity that we
talked about in micro services it may
well be that you know some of that
complexity is still gonna bite you if
you don't address it even in a
monolithic world so it's not like all
these
in you one more
add-on we were talking just before the
panel about how there's there's a very
strong correspondence between a certain
style of OO development that we mostly
saw in the small talk world and the way
that micro services ought to work the
notion of you know sending messages
describing things in terms of the
behavior that they offer or not the data
that they contain having things that are
fairly large grained and fairly
responsible for their own their own
activities all of those traits can be
true in an oo world ie a monolith and
they can be true in a micro-services
world so if you're going down the
monolith first then microservices path
just make sure that you do practice you
know good sound design don't
automatically create a layered structure
where every domain concept appears at
every layer except suffixed with table
and DTO and domain and what-have-you all
the way up through definitely think
about the horizontal isolation between
different parts of your monolith and
look for those subsystem boundaries
where you can put a facade object that
acts as an internal API in front of a
bunch of objects and you'll find that
that's a very natural transition then to
microservices later almost isomorphic
read my journey to micro services
actually started with billing in
monolithic object apps and and seeing
those and what the phenomena I saw was
after a few years the glorious structure
we put together gets you know completely
crippled and destroyed to some degree my
journey into micro services is trying to
build a defense that makes it harder for
the casual programmer who goes into a
your monolith and destroys it for the
same thing in another system if you go
in to go into a micro service and
destroy the micro service okay I got a
heartlines could be right I can do that
but you're not destroying 45 other micro
services as you used to be able to do in
a monolith one interesting benefit of
micro services is I think that it can
prevent people trying to be too clever
so one of the things you can do if
you've got a really large monolithic
codebase and you're writing in a
language with an advanced type system
for example you can do some amazing
stuff you can like say for example if
you've got the Scala type system you can
create things of wonder and the problem
is that they can actually become rather
difficult to work on whereas I think
once you break the functionality into
these relatively small things and they
talk to get to each other in relatively
dumb ways you are actually prevented
from raising you know magnificent
intellectual edifices that may haunt
generations of programmers Jessica did
you wanna I wanted to add to Michael's
point that yes practice like isolated
object-oriented design and that takes
care and and exactly not having anyone
come in and mess it up in the name of
removing duplication that is really just
code that happens to look the same but
be careful on the database side because
if if code from this object is reaching
through to the database for something
that was actually maintained over here
you are screwed because changing code is
hard but migrating data is immensely
harder I think I'd also point out that
Fred name drops upon us earlier today
he's the person that kind of invented
modules and many programmers have never
even read his papers so I think a lot of
people who create bad non-listed maybe
just learn about what a module is I just
like quickly to echo Jessica's point
about not exposing the database if you
have my presentation today I said lots
of nice things about spring I think
they're doing some really cool stuff but
one thing that they've done recently
that I don't think is cool is Auto
magically exposing your data store using
rest I think that's a truly horrible
idea obviously it's not unique to spring
many technologies have made that very
easy to do it is really really dangerous
if you want to do that view yourself is
writing something that is gonna be
throwaway because your chance of
evolving that is nil basically we did
get a question on that actually was you
know do you have to hide your data
afraid your talk was all about that
earlier today really know many ways Ivy
gives you the robustness to hide the
I think when services give their data
away they're just begging for somebody
else to do the calculations for them and
now you got you know 45 places of change
I mean the codebase I worked in India we
were I to write a unit test
I wanted to allocate an object in get
you know make sure it's not nil that's
all I was trying to do to be seven hours
write that test because it just pulled
in this code in this code in this code
in this code because those boundaries
were broken so yeah I'm huge on keeping
those boundaries strict sometimes you
like really need the data in two places
maybe for performance reasons okay one
service is in charge of that data and
you could replicate it from one place to
the other if you need that for
performance reasons or something that's
still code that's under your control and
if the structure the data needs to
change there's code that you can change
to accommodate that so fred was talking
about the entity services trap earlier
and I was actually hoping he would rant
even more in his talk but if he didn't
see the talk he should watch the video
one of the things that I always think
about with micro service designs is for
any given type of request at the edge
what are the set of services that get
activated during processing that
requests so if you think about your
tracing framework you say you know
request comes in here and it lights up
this service and these nodes and these
services and so on you can draw an
activation graph for every kind of
request and what I find when people
implement entity services is all of
their activation graphs end up with this
bottom layer entirely lit up for all the
entity services what this means is all
of their features have common mode
dependencies on those entity services
and if there's a problem with one of
them or if there's a downtime or an
outage or a release happening all
features are damaged simultaneously and
so I always like to draw these
activation graphs and sort of intersect
them and see you know are there is the
intersection of all of them empty that's
great because then you can have some of
your stuff down and other parts of your
enterprise don't even care is the
intersection all of your entity services
then you might as well not
there might as well yeah so changing
track a little bit
what about user interfaces I think we've
been talking about services talking to
other services a lot here what about how
the human beings talk to all those
services yeah so I've got one counter
example and one pro example that I'd
like to offer I talked to a company that
had done a big micro services migration
they were financial services company
they work in many different geographies
and the requirements for creating an
account in each geography were a little
bit different and so they had created an
account service for each geography and
the UI needed to know what to feed each
geography so the UI was built to know
the requirements of each service in each
geography I think pretty clearly this is
an example of doing it wrong right they
got through this big migration they
found they couldn't change anything any
faster than before on the flip side
we're seeing more interest in these
demand driven architectures
Falkor is 1 ohm dot next is another good
one
where where the the client side actually
gets to tell some entity hey these are
all the things I need to know about give
them to me and that makes a good query
interface and it's up to the the thing
on the other end to go and fetch the
entities from wherever it needs to be
that one service a proxy in front of
many or whatever it doesn't matter and
then the the change side of things is
not just like a put or a post in a
restful interface but we're actually
seeing the change being encapsulated as
an action and posted as a transaction as
a unit of work and that's a pattern that
we're finding to be very effective where
you you query based on a demand driven
style and you apply a transaction as one
unit yeah I would like to echo that I
think graph QL and Falkor are very
interesting cool now I guess a question
another question has come in here is
arguments about scalability it seems to
ignore other techniques like plug-in
architectures
they didn't say OSGi but I'm
softly conversation I've had with people
is okay we why have separate processes
why not just have a runtime I jot
different components on to I mean it's
kind of how Erlang works it's what SGI
try to do so one of the brother the pros
and cons of those approaches versus
micro-services I actually think that
there should not necessarily be a be a
one-to-one mapping between a micro
service and a container I think that is
a very very good deployment choice in
probably the majority of situations but
I think that potentially and
infrastructure should be capable of
providing choice there so but
nevertheless I think that given that the
cost of containerization is now so low
you wouldn't necessarily you know choose
to scale out your system entirely within
process I mean when you had to rack up a
new server that was a different case so
in my view it's it's all about proper
isolation so when we used to deploy
things into Java containers the idea was
that the the Java server could properly
isolate the applications from each other
never worked
we always had class path tables tables
operating systems are supposed to
completely isolate applications from
each other yeah except that they depend
on things like network configuration and
TCP settings so we're still trying to
find the right way to separate these
concerns of packaging the application
delivering the application and isolating
them from each other right now the
excitement is containers and yoonah
kernels but that may not be the final
story yeah I as I said I think there
should be the potential to have a
mapping where you're not automatically
just container container izing so for
example in particular environments that
may be in some test environments you
don't care that much about isolation you
just care about reducing footprint this
came up in the keynote this morning he
talked about the vs code and instead of
a plug-in architecture there were like
extension hosts so that each of those
hosts could be a separate process it
could run in whatever language so you
could write your c-sharp stuff in
c-sharp and so there there's the
polyglot really helping and also that
isolation
you're not gonna run a my process out of
memory probably got time for one last
question
what about testing like tech because
testing seems difficult anyway and with
marco services it just seems more
complicated so any tips from the panel
around how to test your shiny new micro
service architecture
well i already alluded to our generative
testing for individual services and i'll
say the reason that we're we're moving
in that direction is because we've been
talking about and promoting and
implementing simulation testing for
quite a while and simulation testing is
an end-to-end approach that can exercise
all of your services and to end and
actually one of the things we found is
our clients are all moving away from
centralized QA teams and there's
actually nobody responsible for
end-to-end testing and and to end QA any
more interestingly one of the ones that
sort of told us that story about six
months ago has come back and said well
we're kind of thinking about a central
QA team to to check the end-to-end
behavior so I think it's a pendulum that
that keeps moving personally I prefer to
explore a lot of the state space as much
as possible for my my automated testing
but then I also do a style of contract
testing where if I have things I depend
on from another service I write tests
that exercise the things I need
specifically from they're not the
comprehensive API just the stuff I need
and and it then if that breaks I know
that they've done something wrong and I
can go yell at them right so obviously
I'm on the other end of the spectrum
from this and the other the panel from
that yeah environments I've tended to
work in again we're developing for
internal users we don't do unit testing
we don't do integration testing we don't
do staging testing in fact we basically
deploy from notebook to production what
we have done is because our production
environments have been heavily
instrumented themselves and we're going
to see basically all the key performance
indicators for our business are
basically available to us as well we
deploy and see what happens to our real
metrics or getting more logins or
getting more sales
are we getting longer page retention
times whatever the metric is we're
measuring that and we're deploying to
live environments and see what happens
if we deploy something is not reacting
very well we take it back off
no that said we are working in
environments where we do get that fast
customer feedback and that has
eliminated the need for the integration
testing Jessica so I don't I don't think
this is a solve problem I know what I
like to do which is when I'm testing my
service I want to be able to test it
without accessing the real dependency
whatever it is and it could be the
database as well as another service so I
wind up making a fake that lets me unit
tests and generative tests and run a
whole ton of tests on mine what I wish
is if that other service would give me a
client library that included a fake mode
and then all I have to do is test the
fake once-in-a-while
against the real service like if I had a
fake github then I could just test that
against fake github to make sure it's
consistent and meanwhile run all my
tests superfast it's what it's what I
wind up creating in the small anyway and
it's it's a lot of work I have more
tests code than real code if I'm doing
it well this is one of the reasons that
I'm a fan at least for the synchronous
case in Java of using things like
Netflix final square retrofit because
they make it really really easy to test
how you're using that service with mocks
or fakes of whatever but I mean I'm
going to come back to the point that I
think it's pretty important that
something has a contract if you know if
I want to test something I want to know
what it's supposed to do and I agree
with Michael in terms of the value of
that approach and I think leaving on a
disagreement is a good place to end a
panel so I want to say thank you to our
panel members and thank you very much
for all the questions I'm so dang a
chance to get to all them but they're
all around tomorrow as well so feel free
to corner them and pepper them for the
place later at the party there's gonna
be beer so thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>