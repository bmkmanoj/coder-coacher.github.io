<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • A Peek Inside Erlang's OTP • Steve Vinoski | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • A Peek Inside Erlang's OTP • Steve Vinoski - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • A Peek Inside Erlang's OTP • Steve Vinoski</b></h2><h5 class="post__date">2016-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PkHZPTn1brc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">how many people here know early few okay
I just stuck some slides in that gives a
little tutorial we'll go through that
real quick but first what is Erlang
concurrency oriented functional language
it's got strong types of dynamic types
so there's no static type checking
checking you run into problems at
runtime it's a very small language if
you've used it it has just a few
elements and talk about those soon it's
a virtual machine that runs a byte code
called beam and it's got a built-in
pivoted system features the Erlang
language came from Ericsson in the
mid-80s
a guy named Joe Armstrong started
researching how to build switches how to
build languages that they could use to
build switches that were more reliable
and cheaper and better
and Broadwick burning and Mike Williams
then came along to help them out by the
early 90s Erlang the language was a real
thing what I'm going to talk about today
when TV came about in 96 and then
hurling itself in OTP were open sourced
in 1998 ever since then it still
maintained by Ericsson with the team
there that does that in they take open
source contributions I've contributed
quite a bit to the Erlang virtual
machine and language as have others a
nice little community think about the
requirements of telecoms which they need
a large number of concurrent activities
because you don't want to switch to just
take one phone call at a time you want
to be tolerant of failure of hardware
and software and to do that and you not
only need components I'd help with that
that you
distribution because ultimately able to
do that and you want a system that can
operate for years with minimal downtime
telephone companies could find their
switches go down for more than three or
four minutes a year every past that to
get find pretty heavily so that's with
five nine five nine per year so they
want to be able to do live updates and
maintenance so they don't have to take a
switch down now you might think I don't
work in telecom what do I care why do I
care about this stuff and the reason you
care is if you think about today's
applications web applications cloud
application big data applications micro
service applications they all want the
same stuff everybody has to be up all
the time they want to give failover in
case of error and distributed systems
problems all that stuff so this is why
Erlang I think you know still maintains
popularity and continues to grow people
are finding that actually does this
stuff pretty well the Erlang VM itself
can run multiple languages so Erlang is
a language on the VM there's elixir how
many people have tried it licks it it
seems to be very popular going into
popularity because it's kind of looks
like Ruby they've done a nice job of
that language there's a couple of lisps
list flavored Erlang and Java so those
are classic list with all the macros and
everything that run on the VM there's a
language called 15 which is sort of
inspired by the Python I believe I've
never used it and there's other kind of
little one on languages let's talk about
processes so process in Erlang there's a
whole model for processes are very
important a lot of what we'll talk about
today
process the VM supports lightweight
green threads so I remember back one of
the first early talks that gage I have
an older MacBook and on that MacBook
probably 2008-2009 I could start million
across this news in half a second so
it's only gotten better both
applications don't use the mill in
practice processes I've written some
that required up to 200,000 so it's nice
to have when you need it but most don't
use that many but all applications use
multiple processes whether they know it
or not the runtime itself does process
scheduling and those process preemption
so to let the process run for a while
swap it out and get another one running
there's nothing you have to do in your
code to make that happen
there's a feature called linking and
monitoring two features actually linking
and to make two processes together
monitoring is when one process monitor
is another one we talk a lot more about
that later mmm that's very important
feature for fault tolerance so when a
processor runs it just runs in Erlang
function and that function can of course
call other functions but as soon as that
function and it's the process and in the
process hits an unexpected exception
then the process dies or if someone
kills the process the process dies I
mentioned preemption before the virtual
machine will run a process for something
called mm mm of something called a
reduction the reduction is almost like a
function we call kind of equivalent to a
function call and it will run off to
2000 those preempted for another process
if it runs short of that and it goes
into a wait waiting for a message from
another process and it has no messages
in its queue
the scheduler or the VM will preempted
if it does I know preemption so there's
a whole bunch of rules about how things
get preempted again you as a programmer
don't really have to do anything you
don't have to call yield you don't have
to do any cooperative preemption
yourself the VM takes care of that for
you we look at how the system is put
together most I don't know people in the
back and see this but there's some CPU
cores down here or one up to core and
most systems today are multi-core then
you have on top of that your operating
system and kernel threads the VM sits on
top of that and for everything by
default for every core you get what's
called a scheduler inside the VM there's
all these scheduler threads
those are kernel threads and what each
scheduler thread has are run queues so
the run queues are where the processes
get stored the schedulers go there run
queues they'll take a process out
execute it like I described before put
it in the back of the queue grab another
one if any of them runs out of work they
can steal from other ones these
schedulers are worth studying if you
ever have time because they're not just
dumb little things pulling off this
queue is quite a bit of craft that's
gone into these things they're highly
independent all of them is running
essentially the emulator loop the thing
that runs all the bytecode so every
scheduler is running that loop and as a
result they kind of all are doing the
same thing but at different times to
keep them independent they minimize
locking between them they try not to
share anything the cases where they do
have to share things they still try to
avoid locking at all costs so it's
basically just trying to share as little
as possible across these schedulers
there's been a ton of work that's gone
into these five years ago Holika
jeweler's shared one cube doing
scalability tests the team found that
they did it this way it just scaled
better so people are always improving
the schedulers how many people have
heard let it crash for girli it's kind
of famous for that I think so Joe
Armstrong has a PhD in Erlang you may be
the only person but if you read that PhD
which is very readable a lot of PhDs are
kind of dry or whatever but this is
quite readable these are some quotes
from there let the let some other
process do the arrow recovery let it
crash do not program defensively and
when you think about it I'm sure we've
all seen code or do like a try-catch in
the catch it'll just say a comment fix
me or comment I don't know what to do
here or you know just you know not even
do anything in early it's not that you
don't deal with there's it's that you
always have to do if there is you just
deal with them differently so we'll talk
more about this when I go through so why
do you have all this concurrency is just
to be cool or yeah it's not it's because
of reliability so remember the whole
thing about our language do you rely
build reliable switches and what the
concurrency gives you is some isolation
you know across the seas that are all
running in the same virtual machine but
they don't share memory or the fact that
they're in the same process they contact
each other through message faster they
don't ever like reach into the same
memory for recovery
I mentioned links and monitors earlier
what that allows is one process to watch
another process and this one I've been
doing all the work and this one's just
kind of hanging out saying because it
still there's it's still ok should they
die because it hits some unexpected
exception this one can take action and
usually what that means it's restarting
the process and then again to have a
fault-tolerant system
all computers so all this works across
multiple computers if you want to send a
message to a process it doesn't really
matter if it's in your VM or in another
VM on the same node or another VM across
the network
you know under the network effects
dealing with latency and partial failure
basically the process model is the same
all right here's a quick Erlang overview
there's just a few elements in language
I'm not going to read through but that's
kind of the bulk of it atoms you see a
lot they're just names or just values
with names you don't know what the value
is like the Enuma and c++ for example
has a value but you're supposed to use
it that's just a name similar here those
are lowercase words variables are
capitalized variables aren't variable
they're immutable function Danny's
module names are Adams variables live
inside functions there's no Global's
functions live inside modules we'll see
some examples of that functions are
identified by their name and their era T
how many arguments they take and then
you can also have anonymous functions
functions can be exported from a module
to make them visible to other modules
and callable from other modules or there
can be internals that are called
only within that module and then
functions can also be passed around as
arguments return those values stuffed
into other data structures higher-order
functions basically because their Lang
is a functional language assignment is
pattern matching so if you have a
variable that has no binding has no
value and I say variable barnacles to
then power now is bound to - if I say
bar equals to again it's kind of like an
assertion yes bar is - I match to a bar
and it's true if I say bar equals 3 this
causes an exception called a bad match
because bar has about as
- and - of course is not three so it
takes a little getting used to but we're
getting used to it real fast
there's also pattern matching in
functions so if I have a function foo
this one says foo takes an empty list
and if it gets an empty list as an
argument that list you know is matched
and I would perform whatever the empty
list version of foo is for anything else
I get a variable named list that's bound
to the value passed in presumably of
non-empty list but again because of
dynamic typing it could be anything but
the runtime will select this version of
who said that one for anything other
there's a case expression that you used
quite a bit it's a way of matching so
you have a value or the return of a
function or something you can say case
blah blah blah and match all the values
that might come back there's default
matches as well pattern matching in
function heads we kind of saw on a
previous slide but here's an example of
food taking two arguments where they
have to be the same value so this
enforces that here's a very common idiom
where you say bar takes a list has to be
non-empty has to have at least one
element that element is going to be
called H and the rest of the list is T
so you see a lot of recursive functions
that'll take a list like that it will
take the head off the list do some
action and pass T to itself as the rest
of the list and then typically ending
function for that is catching you know
matching the empty list and ending the
recursion so you see this quite a bit as
well message passing so if you have a
process ID this is a variable process ID
holding a process ID you can use the
exclamation point to send
such a message can be any your life term
could be an atom strangle is numbered or
whatever
another process ID you can register
processes both locally and globally
there's some registries that come with
Erlang go TP and then others have been
built for various reasons of different
types of qualities of distribution so
now you know where them let's get into
OTP so ITP augments Erlang it's like a
layer built on top of Burlington and OTP
stands for open telecom platform we
don't usually use that name anymore
because it's not telecom specific so we
just call it OTP OTP brings additional
libraries a whole bunch of tools and a
bunch of principles that are really how
you use the system nobody uses Erlang by
itself anymore it's always there like TP
so they're kind of now all what I'm
saying but they still have a kind of
distinct names the design principles we
can walk through those there's behaviors
I'm going to talk fair bit about this
these are just little frameworks
classical sentences frameworks that are
partial solutions to common problems
typically what you do is you extend the
behavior with your own code to make the
full solution just like the framework
there's something called the supervision
tree which is a hierarchy of processes I
mentioned earlier how you can have a
process doing something in another one
watching it well this process is the
worker and the one watching it as a
supervisor any any managers supervisors
here Oh sort of one here kind of doing
this but you're probably in your
supervisory mode you just kind of sit
around and watch everybody right so
that's kind of
that applications are really just taking
these supervision trees and the workers
and everything packaging them up with
resources used by the system like Jason
vials or you know whatever and some
configuration data and kind of putting
that all together and that's an
application
you then have releases which are
collections of applications packaged
together as a deployables own is a
running release basically you take the
release put it on a note get it running
and that's deployed release handling is
when you have a running release and you
can upgrade it or downgrade it that's
the live operating apartment and then
clusters are just interconnected nodes
so you have this kind of whole hierarchy
of you know starting from processes all
the way up to a distributed system and
those a long way
there's just design principles that tell
you how to do all that that OTP provides
what TP also provides other things like
a whole bunch of tools for operations
management monitoring how to package up
releases and if those prepared for
deployment tools for debugging doing
test coverage doing testing doing
performance measurement it's just a
whole bunch of stuff and it reflects the
fact that the system's been around for a
long time and these are things that
people use in production and you know
the nice thing also is they've evolved
over time so there's some packages that
you know used to be used that aren't
used as much anymore and they eventually
kind of find their way out of OTP while
newer things come in so your ways of
observing a running system and looking
relationships between processes and
tracing behaviors and all that kind of
stuff so the whole system evolves
constantly there's a new release of air
lining typically every 12 to 13 months
so next month erlang 19 will come out
ever evolving system now let's talk
about behaviors there's a bunch of
standard behaviors gens server is the
most used one it's a client-server
pattern I go through a big example with
Gen server there's gen FSM which is
finite state machines and a brand new
state machine behavior called gens state
and that's uh not quite available yet
it's gonna be available when this new
release comes out next month gen event
is an event handling framework and then
there's supervisor I mentioned earlier
application I mentioned earlier so
what's the purpose of a behavior the
primary purpose is one to separate the
generic parts of a solution from those
from the domain-specific parts so you
have a bunch of a bunch of features that
you need for kind of all client servers
for example gen server contains all that
I'll show you later how do you take
Jenna server and extend it with your own
code to solve your own problem there's a
lot of corner cases represented in the
code so things learned over the years
you might think you've probably heard
you know
you don't have to handle locking and
it's not like the usual multi-threaded
programming you don't deal with race
conditions and all that and that's
partly true you always deal with race
conditions it's just that here a lot of
it's been solved because these things
have been around so long and in
production so long that these corner
cases have shown up and have been
plugged so yeah it's just like a
collection of reusable modules that are
useful across a number of domains for
solving common problems there's also
this whole thing about OTP and if you
follow all rules of OTP you follow the
design principles and everything you get
a lot back and return so things like
being able to start your application
being able to put your application into
a collection of other applications that
it might not even have you know like
might be that someone wrote an
application a someone else wrote B and
someone downstream kind of grabs both of
them then puts them together in a way
that nobody foresaw if you follow the
rules that's gonna work fine if you
don't bad things are going to happen
fortunately all the tools nerds they
kind of make it easy to follow the rules
but things like starting and stopping
your application doesn't sound difficult
unless you have dependencies on other
applications how do you force the order
well o TP does that for you observing
and monitoring being able to debug
things always has to go back and say oh
I forgot to put all my printouts in the
code how am I going to do but this
packaging and release saying doing live
upgrades it's all kind of prescribed for
you so let's run through an example it's
kind of not a very interesting example
because I wanted to keep it simple so
there's a p-value server process a key
value server process is just a process
that's running that lets you store keys
along with values
and then later you can go ask if it's
got a certain key and if it doesn't give
you the value and if it doesn't it'll
tell you I don't have that value it will
allow you to delete keys and values of
course and then you know you want
multiple clients to be able to use this
thing so you could imagine having
something like a cash you know that's
just caching values multiple clients
using it the reason I say it's not very
good example is of course Erlang comes
with key value stores of three or four
anyway so but again this keeps it simple
and everybody can understand it and I
don't have to put a lot of code on the
slides so what are the problems we're
gonna run into with defining our key
value server well who's gonna be one of
keeping server state certainly don't
want to say store key and value and it
says I did and then you say okay give me
the what I don't know are you talking
about so you want to be able to keep the
state of the server you have to be able
to start with stop it clients have to be
able to locate the server and talk to it
and the server has to handle the client
requests make sense of the requests
coming in if there's any errors has to
deal with those but it also has to be
able to reply to the clients and give
them back what they asked for
so process state is kind of interesting
Erlang variables are immutable and there
are no global variables so how do you
have a server process that can store
state one way it would be just to write
everything but disk but this is an
in-memory server so that's not really
gonna work we could cheat and use kind
of the internal Erlang keeping scores
and we sort of do that in our examples
but that's not the real point I'm trying
to get to every server process in OTP
has this thing that all the received
evaluating so what happens there is as I
said earlier processes execute functions
say a function that presumably is a key
value server function it's a loop
and the Louvre just has a state and
receives a message and says what do I do
with this message if it's like a store
message it'll stick some key value into
its state and create a new state if it's
a delete it'll get rid of the key and
the value and create a new state
whatever it does it may create a new
state it might be just a look up
education would be the same state but at
the end of the function you have the
state be a new or old and you just call
yourself with that state so the state of
the function has just kept as an
argument in so it just looks like this
we just have our state coming in we have
a receive here that handles messages
these are just comments it's not
actually doing anything and presumably
this receive statement returns a state
could be new could be old that gets a
new state and then we call loop again
with new state it's pretty simple but I
remember when I was learning Erlang I
kind of wondered how all this behaviors
you know how do they do this stuff under
the covers and go look at the code the
code has a lot there's a lot of code
there because it's handling a lot of
corner cases but fundamentally it just
works like this for diagrams basically
that our server starts and calls
initialize has some initialization but
then goes into its loop and it just sits
there maybe changing its state
eventually someone tells it stop and it
exits and maybe doesn't clean up
okay so that's that problem solved what
about starting stopping the server well
that's pretty easy because in Erlang
process can spawn another process
there's a built-in function for that for
stopping you would just send it a
message
it literally send the atom stop and that
thing can receive stock and go all up
stop I'm supposed to stop and exit so in
terms of starting a KB server we could
just have a module kv we're exporting to
function to start with stop these zeros
just mean they don't take any arguments
start is just spawning a function in the
kv module named Lugh and we pass one
argument this funny-looking thing here
is an empty map or just using a map
internally to store our keys and values
we get back the process ID from spawn we
then call register and give the name K V
so I want to register this process given
by process ID under the name K bean that
allows clients to just go and ask the
registry where is K V and it gets the
process idea that's that then we return
this Tuggle which is okay the animal K
is very commonly used in Erlang to
indicate success okay and then that
process ID so the caller of start gets
this back is double pretty
straightforward stop is equally
straightforward we just have a function
stop we take the name K V which is
registered under that process we started
and send it the message stop and then we
just return okay we don't actually care
if there's any reply to that or anything
else it will eventually get the message
and stop if it's still alive
a server code for stop is a little more
interesting but it's not that
interesting it's just our loop and our
receive block and all we're saying is
receive and I see a message that is the
Adam stop just return okay don't do
anything else because we're not calling
the function recursively the loop
function ends and when the loop function
ends the process goes away we look at
the API or our server again we have our
module declaration named kV we have all
our exports please make all these
functions visible outside the module kV
so that others can call other modules
store takes a key and value and it
stores it I don't show the actual code
just have comments fine it takes a key
it either returns a tuple which is the
key and the value or returns a boolean
false this is a case where Erlang's kind
of loose typing is kind of helpful in
other languages you would have to use
like a some type or something to say I
want to return two different things
here we're just saying it's either going
to be a couple or it's going to be false
delete just sends in the key and if it's
there deletes it if not doesn't the
client code for storing takes a key and
the value
uses the name kV the registered name of
our process and sends a message the
message is this couple with four
elements the atom store which is almost
like an instruction at this point the
key in the value that were passed in and
self self as a function that's built
into Erlang for getting your own process
ID once we send that message the client
goes into a receive and just says I'm
waiting to receive okay once I receive
okay I reach journal
and I've done and that's it I'll show
you why we send our process I think in
the server version the server has its
loop so here we have received we have
stop which we had on the previous slide
or the previous thing we implemented so
if we get stopped we return okay the
semicolon means kind of like or if we
get this do this or if we get this for
double which is our store key value
process ID we stick the key in the value
in our map that gives us a new map we
send the message
okay back to this process idea that was
passed to us
so that's letting the client know hey
it's okay guy did the store and then
with the new map we call loop
recursively
now that recursion is tail-recursive
there's no stack product owner on
forever and ever and ever as long as
your computer stays running find and
delete are really built the same way
just with different tuples so you take
the request public maybe for fine you
probably use the atom find passing the
key and you're pitted from the client
the server would receive that Tuggle
look it up in the map return the
appropriate value or send Ansari send
the appropriate value back to the client
delete similarly so I'm going to ask you
a question since you're not asking me
any what parts of what I just showed you
are a generic and what parts are
specific to a key value store
don't all jump up at once okay so it
seems generic for a key Valley okay what
if it wasn't a key value are there any
parts of that that you could keep well
though I mean the only line that sexy of
state is the only thing specific to key
value that the loop seems like a pattern
that returning okay seems roughly like
the pattern so it's just what thank you
guys for the message is and the that's
what storing the statement build a new
state okay excellent
so just repeating for the video and
you're saying that this whole thing of
you know just storing a value in a map
is specific to kV but the whole idea of
looping and receiving values and then
sending replies to the client is pretty
generic yep
good yes the generic parts are spawning
a server you know spawning a server is
always the same you call some form of
spawn you give it a module and function
and some arguments the management of the
loop state is the same thing right it's
just the state is different but the loop
is the same how you send a client
request is the same that's like a
built-in function of Erlang and ditto
for the server replies it's all the same
- and then stopping the server is the
same as well West out of the loop the
solution specific parts have to do with
initialization
because your state's going to be
different so you have to initialize it
differently based on whatever it is
you're writing for our solution for KD
we used a map as an empty map the so
that's the state the requests that are
sent from the client and the replies
from the server are specific to the
solution because you know there's
different values involved in different
commands if you will involved and then
any cleanup if there's some thing you
have to do to your state at the end to
clean up
if you want persistence story you have
to go and flush something that disk or
something but that's also specific and
that's really what behaviors are about
behaviors take all the generic stuff and
put it in a behavior module so if you go
look in your airline release and you go
and look at gen server there is a gen
server module and it does exactly this
it takes all the generic parts
client-server pattern if you want to
call it that packages of them up and
that's what the Genna server gives you
the behavior expects to be initialized
with what's called a callback module a
callback module is what you write it's
got all the parts that solved the
problem you're trying to solve and once
you start that behavior if you start
your gen server as it receives things in
its loop it's going to calling your
callback module to do the actual work to
solve the problem you're solving so
let's go through kV as a gen server we
still have a module every every other
link module starts with a module
declaration here we have this these are
called attributes by the way so behavior
attribute and if you're British
you can put au in there it still works
or if you just like to pretend you're
British I don't know here we're
declaring this module is a callback
module for Jen server so it's going to
what the compiler does in this case is
it looks at the Jen server module that's
already been compiled because it came
with your release and the Jen server
module tells it oh by the way if someone
declares themselves a callback module
for me they have to implement following
functions and it gives you a list
compiler gets a list of functions and if
you don't have those functions in your
module then
give you a warning and say hey if you're
gonna be a gender or callback module you
have to implement some functions we have
that same API that we had before which
is our own solution API but we also have
these callbacks that we have to support
and there's a number of them I'll go
through them real quickly so there's an
it when the genuine server process
starts up because you're an it function
you're an it function can create the
state that you want for that loop and
give it to the gen server that's pretty
much what an it does handle call as a
callback that handles a request reply so
if I make a find call for example I want
to reply I want either the value that
was found with its key or run the
boolean false handle call would be a way
to do that so it's like synchronous
request reply and low-caste that's like
a one-way message delete for example
could be done with a cast just send
something in and say hey delete that key
and you may not care that there's really
no reply to that would just say okay
probably there's something called handle
info which is imagine that Lu receiving
all those things we had in our previous
example store and find those tuples if
it gets the loop gets something it
doesn't know about then it's going to
call your handle info function and say
hey I just got this message I don't know
what it is maybe you know what it is an
example of this in real life is if you
have a gen server that's getting TCP
messages Jenna server doesn't know about
TCP but presumably you have a socket
somewhere in there and the socket got a
message so it calls your handle info
call and says hey there's this TCP
packet you can have it turning is called
when the process is about to stop that's
where you can do some cleanup and then
coach
is how you do upgrades or downgrades so
code Jayne code change basically what
happens I'm not going to go through it
but quickly it kind of your process is
running and the system kind of like
pauses it and says this thing needs to
do an upgrade it's going to claw your
code change function with the state that
you have currently and let you give it
back some new state so if you had a
state that was like say a record which
is kind of like a struct and you want to
add a field you could do that in your
code change by returning you know a
different record with that added field
in it and then once it gets the new
state it starts you back up and away you
go
so those little callbacks you have to
implement if you're going to write a jet
server take a look at how we do that the
way we start agenda server in this case
is we have a function called start link
and all it does is called gen server
start link start link is basically
starting a process and linking to it
we'll cover that soon this thing local
kb is a tupple that basically tells gen
server to register the process it starts
under this name kb so it's like that
register call i showed previously the
client calls kb start linked which is
this function and it just calls this
function and that returns ok and process
ID just like it did before the other
things on the end like this is the
module it's being called the anit
function of this module this is the
callback module this would be any
arguments that want to be passed to
admit we don't have any in this case and
then this is for debugging and
a start-up @kv server we have our net
function all it does is return our state
which is the empty map store is really
easy on the client because it just calls
gen server call notice that we don't
have to pass our kid in this case
because gen servers take care of that
for us well we still pass a couple with
KD key and value in it to implement that
we provide handle call which receives
that topple as an argument and basically
does what it did before but you'll
notice that returns a little different
because it has to return a value that is
known to Gen server so gents are very
expects expects that replied topple to
come back find similar we have a case
statement doing the mouse lookup and
returning appropriately stopped really
easy gen server stop so a lot of this
it's much easier with gen server because
it's doing a lot for you the internals
of call that we saw for the store and
find functions the call itself gen
server called runs in the client process
and what happens inside it is the client
process monitors the server sticks a
monitor on the server process which is
very inexpensive by the way you can do
that very quickly because server dies
the client wants to know that right now
the server is being used by other things
and it could die easily so you want to
know if it dies if that sends the
request to that server process then it
has a timeout waits by default five
seconds you can change that if you want
and then presumably if the reply comes
back from this
then it gets returned to the caller so
it's pretty simple so behaviors are kind
of handling a lot of this monitoring and
stuff for you there's something called
the SIS module which is how the system
talks to behaviors behind the scenes to
do things like code upgrade
and shut down and all that kind of stuff
since itself is fairly there's a lot in
it but there's a couple of things I just
wanted to show you so this is the Erlang
shell you can just type URL and get the
shell this thing is the prompt so number
one and here I'm calling our start link
function and I get back okay kid so kid
is represented in the shell was this
weird thing 0:36 zero I can then call
systrace with that pin it's a true once
I give that the jet server that we
started here is traced so if I send a
message to it by calling fine for
example find go to we can see these
messages that pop out in the shell that
say oh okay ve got this call
genzler or call the argument find go to
from 34 which is us to a self we see
were 34 and then it's sent false to 34
and then you see the result printed here
false so if you're working with a
behavior so easy to just turn on trace
like this
and get messages like that come out and
help you debug what's going on that's
all built in one of my other favorite
ones is something I actually added to
Erlang myself get stained so if you want
to look at the state that's in the kv
process you can just say get state and
it shows you this is the map that we
stuck with the key go to chicago into
and there's also something called
replaced state which if you're debugging
you could stick a whole new map in there
if you want to test some weird corner
case did replace the state as well so
those are some things I added a few
years ago it's quickly going to go
through applications and supervisors we
have about five minutes so application
is fairly straightforward it basically
helps you package up your supervision
tree
stuff starting stop-start itself is this
hierarchical sequence so the colonel has
something called a application
controller that's going to start up for
every application master and then the
master is going to start up the top
level supervisor for your application
that top supervisor is going to start
all of its children you've done other
supervisors or workers so most
applications look like this you have a
module whatever you name it here it's
imaginatively called my app it's a
behavior so it's an application behavior
this time has to export start and stop
the start function just calls the
supervisor and starts it up and the stop
function just says ok almost every
application that you ever see in our
line looks like that it could be more
involved there's other stuff you can do
with most look like I said before
workers and supervisors implement
application logic and supervisors
watched the application logic to make
sure there's no errors happening so
basically it kind of looks like this you
have this simple core given application
here's the top level supervisor starting
another supervisor
those are both starting some workers
this thing is trivial we saw the
triviality of the application on the
previous slide supervisor itself is
implemented as a gen server it's pretty
simple to all of the hard work is done
down here so this thing provides a nice
base for your application even if these
fail kind of come back up here and you
can restart things take action to handle
the errors there's a bunch of ways of
starting workers but you know you might
have workers for example we started at
kV and then a bunch of clients we want
the kV to come before the clients
because the clients want to use
so we can put them in a certain order
and use the rest for one strategy so if
the kV dies we want all the clients to
be killed too
you can also have a one-for-one which
just says I have a bunch of workers that
are kind of independent if any one of
them dies just restart the one that died
leave the others alone there's a lot of
flexibility there and then you can have
max number of restarts per time period
that's to escalate a failure so you
don't sit down and just move forever
trying to restart something that's never
going to restart this is just a child
specification that shows how to start up
a child you can see that it's a map and
it's got certain fields that have to be
filled in so in the in the original
solution of the server dies if the
server dies while the client has a
request outstanding or a server takes
too long to process something how is
that code that original code if you were
to go back on my slides I'll get that
original code it doesn't do anything to
handle any of that stuff yet when you
use the gen server it handles all that
stuff because of the monitoring the
timeout
you know the fact that it handles system
messages and can deal with this and the
fact that it's supervised by a
supervisor means that a lot of errors
and problems are just kind of handled
for you by following the rules thank you
so we'll wrap it up the benefits of
behaviors are handling tricky corner
cases the ability to look at something
and say oh it's a gen server I know what
that does every year Lang programmer
knows what these behaviors are what they
do so I can look at anyone's code and
kind of follow it pretty easily all the
corner cases I mentioned but those
corner cases came about because of years
of this stuff being used in production
and kind of finding them in the hard way
a lot of it's been tested and tested
just a quick checked and all that kind
of stuff so a lot there there's far more
to go TP than what I've shown me but we
only have 50 minutes there are the
behaviors I mentioned that we didn't
even cover the finite state machines the
deep-end handling stuff you can write
your own behavior such a whole framework
for that packaging and deploying that's
like a whole talking to itself upgrades
same deal so there's a lot there if you
want more information this just came out
the last book I wrote was on corpus 17
years ago so this is a little different
came out in eBook
Friday and just supposed to come out
this week I think so Francesco Cesare me
and I wrote that
Francesco also wrote a book previously
with Simon Thompson called Erlang
programming that's a great book to learn
right and guy named Fred hey bear
wrote this bit using Erlang and anger so
he works at Heroku and uses her laying
there and he's written a bunch of stuff
that's all about using Erlang and
production it's gold and then if you're
into elixir you could just go in the
elixir website they have some great
learning resources there and remember to
rate this session thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>