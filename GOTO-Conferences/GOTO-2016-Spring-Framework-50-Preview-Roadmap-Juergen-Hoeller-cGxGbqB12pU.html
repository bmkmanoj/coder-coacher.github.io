<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Spring Framework 5.0 - Preview &amp; Roadmap • Juergen Hoeller | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Spring Framework 5.0 - Preview &amp; Roadmap • Juergen Hoeller - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Spring Framework 5.0 - Preview &amp; Roadmap • Juergen Hoeller</b></h2><h5 class="post__date">2016-10-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cGxGbqB12pU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well let's do a little bit of warm-up
checking in terms of what your previous
exposure to to our stuff is who's
actually working with spring actively
developing spring applications okay well
not unexpectedly I guess in verse
question who's not currently working
with spring in in practice
is there anyone got quite a few who
hasn't ever looked at spring before and
you went there to register him say no
I'll do a little bit of a quick dive
into modern-day spring initially so
there there will be a chance to to find
a common path of hours here this morning
but the the bulk of the session is on a
very recent efforts that we've been
working on so before we actually go into
five two though I'll do a little bit of
a glance at photo three so just two to
give you the idea we we have a very
dynamic roadmap these days we actually
release feature releases every ten
months we did for the DOE for that one
for the two in very short succession for
our purposes anyway at the the feature
release is what we call a feature
release like for that one and for the
two or for the three now actually very
significant releases in their own right
they are basically major feature
releases that other people would call 5
2006 2007 2 though I'm pretty sure other
open source projects in particular we
tend to use the major version number as
a kind of baseline which means as long
as it's 4.3 here we still hang on to the
system requirements of the spring
framework full generation so even for
the 3 which has been released last
Friday on the 10th is a JDK 6 baseline
version of the framework of course with
very up-to-date JDK 8 support
as you used to we do not change system
requirements in major like in minor
feature releases within the major
generation 5 $2 the chance to do this
we'll get to that in just a bit
well actually while we while we were
doing some hand raising who's working
with spring for the two spring framework
for the to boot one two three okay for
that one anyone still stuck on 3.2 or
using three two two for some reason
okay that's cool that's basically where
we are at most of the most of the
efforts of course these days go into the
spring framework for line for the two is
just being maintained until the end of
this year but literally just maintained
full of three is a kind of wrap-up
the last feature release in our photo
decks line there's not going to be a
fall out forever full of free will have
a kind of extended maintenance life
until roughly 2019 maybe into 2020
similar to where three the two is right
now through the to the decks has an
extended maintenance phase for almost
four years now food at three is going to
be the same kind of end of a generation
basically of the framework the range of
supported platforms is as mentioned it's
still a very conservatively baselined
jdk 6 plus and Suvla 2.5 plus that
translates as examples for example that
it still runs on tomcat 6 it actually
much preferably also runs on Tomcat 8 at
5 which was released just a couple of
weeks ago so this is kind of the way
we're going about this a baseline just
means if you really want to you can
still run it there on this minimum
baseline we recommend the current
generation infrastructure out there and
that would be Tomcat 8 at 5 in the
rocket line in WebSphere just as a
common reference you can still run it on
WebSphere 7 we do
spent quite a bit of effort to make it
work properly everything worked properly
on webstie 8.5 liberty in particular and
we're working towards compatibility with
nine nothing earth-shattering we just do
our share in terms of compatibility
testing that's all really the fold of
three generation of the four the three
opportunity allowed us to do some
refinements in the programming model so
for the three is actually somewhat
significant in some of the things that
it does and i'm just going to highlight
a few of the things because i guess you
would actually expect those things to
happen in a 5-2 though we intentionally
brought some of those things forward to
folder three because they are easily
implementable on JDK six entire so we
can bring them to a wider range of
system environments and we can bring
them to you right now as opposed to next
year so that's why we took some things
that we would otherwise only really do
in a 5-2 though and brought them forward
to full of three some of them appear
minor but actually somewhat significant
if you look at this kind of component
class doesn't look out of the ordinary
but the commented out part that the
constructor is intentional
as of 4.3 you do not have to mark a
constructor as Auto white as at Auto
Wyatt if it is the only constructor
anyway in an annotated class in the
annotated setup so we kind of still
recommend to do it for the source code
readability part if you look at your
piece of source code yet Auto white
still tells you something about this
constructor that it is an auto white
constructor but technically you do not
have to annotate a single constructors
in the area anymore
we imply the at all too wide for you
this is something we considered for
quite a while and has been raised to us
it's actually feedback driven so quite a
few people raised it to us this scenario
I would actually personally opt for
annotating it because it's consistent
with the style of the rest of the class
but consider a class that doesn't have
any annotations otherwise it's maybe
it's registered
type o it's created by through some
other means not through detection in the
classpath based on stereotyped notations
maybe it doesn't have transaction
annotations at all it could not have any
annotations otherwise it would just have
this at Auto while for the constructor
for dependency injection purposes then
it becomes more compelling to just skip
the at all to Wired have a non annotated
class automatically managed by the
framework in a reasonable way so this is
the an example for the sort of
refinement you can even do this to
configuration classes these days this
might also look like somewhat common or
obvious but it is actually not
configuration classes used to not
support constructor injection because
for an ad configuration stereotype we
actually create sub classes through the
dilib and previously we did not generate
equivalent constructors on that sub
class you simply could not declare non
default constructors in a configuration
class so people resorted to like field
injection for common types that they
wanted to link into the the factory
methods here like this book admin
datasource we don't like field
interaction all that much or at least
some of us don't so we prefer to give
you the opportunity to do or to give you
the chance the ability to use
constructor injection wherever you would
otherwise use field injection we close
that gap in full of three now so just do
the obvious declare a constructor like
in any other component class make it
accept the references store them in the
field you can basically do in a
configuration class what you would do in
any other spring component class as well
now that was a goal in the design of
configuration classes anyway that there
are regular component classes with a
special role but you can basically do
whatever you can do in convict in
component classes this was a gap that we
only really closed in for the three now
and combined with the previous little
feature you don't even have to annotate
it without auto white if it is the only
constructor but you obviously can write
so again if you see a commented out a
notation here this means can be
annotated for readability purposes
doesn't have to because it is the
default on
right another example there are actually
many such refinements there's a
collection of map injection has been
refined self injection has been refined
there are quite a few things that have
been refined in the dependency injection
space but this is not a full of three
presentation so I'm just giving you two
major examples the other one here is a a
controller class and annotate the
controller this one doesn't look doesn't
look strange to you I guess I mean maybe
except for the cross a rich in part
dates back to the core support and for
the two but other than that this is
actually pretty straightforward it is
restful or rest oriented anyway it tries
to bind to a particular path to
particular puffs and uses HTTP method
bindings now a refinement that we chose
to do in photo 3 finally is to provide
precomposed annotations for some of our
mappings you might generally be aware
that spring for spring for the two in hi
in particular has a very strong
composable annotation story you can
build your own annotations for almost
anything in for the - we really are
completed the feature set in terms of
what you can compose how you can refer
to other attributes that sort of stuff
in folder 3 which shows to include some
precomposed annotations for you not
shown here for example finally we have
request scope session scope and
application scope annotations just in
case you really need them that way yeah
this is not magic this is not even
directly supported in the framework it
is literally at just precomposed
annotation met annotated with the
standard annotation shipped in the code
in our code jars that's all you could
build them on your own at any point now
for request mappings a common complaint
is that the annotations mapping style is
a little bit wordy
if you map to more than one attribute
like to a path and the method so if you
if your mapping if your constraints are
a little bit more complex than just a
single element it starts becoming a
little not as readable as it should be
in
ticular sins in the java notation model
once you specify more than one
attributes as an annotation designer we
can only select one attribute that you
can implicitly set without saying value
equals just provide the value but if you
specify more than one attribute as a
user here you always have to name the
attributes path equals this method
equals dead so as an example for what
composable annotations can do in general
and what we chose to do out of the box
full of three we provide precomposed
annotations for the typical rest
oriented mapping scenarios get mapping
and post mapping a literally just
convenience classes convenience
annotations metadata did with at request
mapping but designed in such a way that
you typically only specify one attribute
which makes it significantly shorter
because there's no attribute name equals
in here the HTTP method is implied by
the body annotation name which also
makes it well makes it more readable and
saves the second attribute there's a
little bit of a connection to another
foot of three refinement we have a set
of mapping annotations here that gets
post-match put and delete we do not do
options and head mapping because we
refined our default options and head
behavior we aligned it with what
httpservlet typically does so if you run
a for the free application against such
mappings you will find that the
dispatcher servlet is a little bit
smarter in finding out what it should
return when an options request comes in
it actually looks at your mappings
figures out what mappings what mappings
there are for particular HTTP methods
against your given path and will return
a corresponding options response we have
a quite a few refinements in that space
we are generally very HTTP oriented
these days we try to do things the HTTP
way in quite a few ways including HTTP
caching you know just a general
interaction with HTTP means this is also
one example where those things actually
add up quite nicely
all right and if you directly compare it
it is significantly more concise in the
end so who likes the get mapping first
mapping style to show the one okay
good to see Thanks by the way the
expressiveness of course is basically
the same right it is a request pepping
annotation just in a different rep and
there's always request mapping to fall
back to all right let's move on so those
were examples for for the three features
those are already out there we released
them last week and we have a 4:3 one
coming up in like July 1st at the moment
so we are already basically in the GFS
this can be used right now in this
production supported to this day already
now let's switch gears a little we look
into early 2017 we are preparing for a
$5 generation for quite a while already
so we started talking about it last year
we knew that we wanted to have a JD k-8
baseline version of the framework that
was actually one of the initial
intentions so for the 2 for 3 we decided
to do it for the free still that that's
all cool and delivers a lot of value
runs great on JDK 8 in particular but as
mentioned it's still JDK 6 baselines
which means there's some there are some
things we cannot do within the framework
because we have to restrict ourselves to
trade history 6 API level and the
Cherokee 6 language level the funny part
is you probably won't notice that much
if you run spring for the 3 on JDK 8 it
just feels like a JDK 8 based framework
to you it does everything it possibly
can it understands Java util stream it
automatically adapts to Java util
optional lambdas perfectly work a
parameter name discovery on JDK it works
everything you could typically expect as
an application developer works for you
because the framework ought to adapt if
it encounters JDK 8 code around
time if it encounters the use of JDK 8
API in your classes the framework
automatically adapts and supported
that's cool that's what we wanted to
achieve in the spring framework for line
but it doesn't change the fact that
internally we would also benefit quite a
bit from being JDK 8 plus within our
round codebase so we are dedicated plus
part is primarily for us admittedly but
it's also a a kind of measure that we
take for further evolution afterwards we
allow ourselves then to use JDK 8 API
types and now signatures we can refer to
the Java util function interfaces we can
do quite a few things we are just unable
to do in statically declared signatures
right now however the JDK baselining is
more for us right in terms of feature
themes for spring filmic 5 we aim for a
reasonably comprehensive JDK 9 story
I'll elaborate on that a bit we have a
strong focus on HTTP 2 that was part of
the initial mission I'll I'll talk a
little bit about how we're going about
this and we have a strong focus for a
reactive programming story a reactive
programming model within the core Spring
Framework style within the core Spring
Framework distribution from the ground
up integrated into the core framework
but of course also to shine through in
other parts of our portfolio so we are
talking about the generation of the
framework the targets 2017 plus we
design it for the infrastructure and the
challenges of 2017 and higher so the
baseline upgrade is actually quite a bit
more than just the JDK 8 plus baseline
we raise quite a few of them not too
aggressively and notice the servlet 3 to
the plus part right it's not even served
through that one plus but we require if
you reasonably recent API generations
here basically Java EE 7 level with a
few compromises like the server 3 that
all
and higher part we will also raise the
baseline for third-party libraries at
this point in full of three we are still
pretty generous in terms of letting you
choose the version of say hibernate and
checks in and all the common library is
typically combined with spring it's your
choice after all we just we support the
version range was always like that in
spring five we're going to use the
opportunity to raise that baseline as
well it's going to be not too aggressive
but in particular with hibernate to tell
a very current story very hot story from
from just a couple of days ago in
particular with hibernate we are not
really in the business of supporting
versions of hibernate that the hibernate
team itself doesn't support anymore
and you might be a way that terminates
well having it 3.6 which we still
support in deprecated form right now is
basically long gone from the having a
team's perspective but they don't even
support for the three anymore they just
support the latest hibernate five
generations so if you raise a buck with
hibernate you're going to get fixed in
five to two the decks if you really
strongly push you might get it in five
that 100 decks still but that's about it
so we have to adapt to that there's
nothing we can do other than being a
little generous in how long we carry
existing code around as of spring five
this going it's going to be having at
five plus in all likelihood even having
at five to two plus that we require we
have to align with what those guys do
but that's not set in stone yet so the
baseline upgrade actually goes across
the framework including third-party
libraries I've mentioned the
infrastructure themes already we'll just
have a little bit of a more extensive
discussion one by one here so what about
jdk 929 is something we did we track for
for about a year now in the meantime we
may we are started making sure that even
spring framework for the two builds rent
on jdk night for the three for a long
time the build would just run the tests
would pass on jdk nine
the problem with JDK 9 of course is it's
a moving target every time they merged
significant change in like and they
significantly rearranged the JDK itself
every time they do this the bill breaks
right so at the moment we don't actually
actively test against JDK 9 we will pick
this up again for Spring Framework 5
since JDK 9 intends to go GA next year
intense alright March 2017 is the target
that they said that's target actually 1
implies a feature freeze about 2 or 3
weeks ago which did not happen and it's
been declared that there is no feature
freeze yet they're still actively
looking for feedback they haven't got a
new feature freeze deadline my
expectation is that jd9 will not ship on
time on that basis and there is a
history for this you can just
extrapolate how how they handled it with
JDK it we are actually in touch with a
few of those people but you just don't
get the heartache from those guys or any
kind of heart statements so we can only
make assumptions my assumption is that
jd9 will be delayed a bit at least we
nevertheless focus on JDK 9 because we
believe that as a as an industry as an
ecosystem as a community here we have to
embrace the latest cool technologies
that we we have in this industry right
in our technology stack if JD King 9
goes out we have to embrace it there's
no way the Java industry is going to
move forward with for forever being
stuck on hideki 8 JD canine actually has
a lot of stuff in it that's not being
talked about much in particular JVM
improvements I mean technically even I'm
not talking about it on the slides
because everybody always talks about
chicks and I will say a little just a
few words and chicks are in a bit but
JDK 9 has much more to offer
JD canine has compact strengths JDK 9
has significant improvements to the g1
garbage collector
it has significant improvements to the
startup time of smaller applications so
in the moment in particular significant
improvements to the memory profile
overall of a running application so even
if you do not care about any API any
language enhancement of which they run
on anyway in Chile canal then just
basically forget about that and upgrade
to JDK 9 just for the JVM just for the
JVM improvements there are a few api is
in there that are not worthy they ship
an LPN stack now needed for HTTP to
really overdo that it's kind of
available out of the box without hacking
your JDK or without having to modify
your JDK installation it should be -
something to be covered in just a bit
anyway so let's keep this brief there is
a new HTTP client a kind of successor of
the good old URL connection you know in
in the JDK we have this nice little
strange api javadoc net URL connection
dates back to 1996 I think so kind of
has its 20th anniversary now but it's
just an a completely outdated API and
not particular HTTP focused either
it was meant to cover different
protocols FTP and so for friend so there
is a new client effort I've had a look
at it I'm not super convinced that
greatest step forward really I would
probably rather keep using one of the
more comprehensive HTTP libraries out
there like the okay-okay HTTP client or
even apache httpclient are all
significantly more powerful and
customizable than than this effort but
at least there is a new HTTP client so
that some things are happening that kind
of really matter to to what we are doing
these days to building modern efficient
web applications and then those chicks
are so with chicks arm we initially had
a story that I'm just going to show you
an impression of what it is supposed to
look like where we thought that's
actually a fine fit we have a decomposed
framework the framework consists of
quite a few
modules with well-defined dependencies
some of them required some often
optional
jigsaw initially was designed as a way
to formally declare some of those
structural metadata in your char files
and the idea is actually to these days
is sound the problem is that the
direction that jigsaw is going in terms
of its focus is from my perspective not
ideal but the idea is an alternative to
the class path instead of saying
bootstrap my JVM here's this really long
list of Java files that I am going to
concatenate into a single class path
string instead of that you point to
symbolic module names and the modules
internally declare required dependencies
on each other so you're taking can bring
each other in implicitly a fine idea
unfortunately it's not uncharted
territory right we've we've had OSGi
before we had other modules system
attempts for example in jboss land
before the the space is unfortunately
pretty complex module systems if you
just look at the 80% case they always
look straightforward and easy
the moment that you try to model real
life scenarios and you get closer to
downgrade percent target they become
super complex that's exactly what jigsaw
is right now the 80% case worked a year
ago or nine months ago but there's they
are struggling with the remaining 20%
and they've been struggling quite a bit
might be the main reason why JDK 9 is
delayed okay so back to our vision the
idea is pretty simple that that's
basically chick saw syntax a module
declaration in a module - info file the
idea is that it's basically the package
- info dot Java idea just in a module -
info where the compiler actually
compiles this thing into a binary
representation and the JVM can
introspect structural information a fine
idea
definitely more efficient on startup
than try
two powers manifest entries and loggers
Giada's however it's of course a kind of
new language right you specify
dependencies you you can export certain
packages you have a symbolic namespace
of modules right those are actually
symbolic names Java dot sequel is a JDK
defined name we could take our spring
JDBC char from the maven central hosted
spring JDBC jar wrap it up like this
give it a symbolic name spring that
docked a DB C along the same lines and
make it usable in the same way wouldn't
that be nice unfortunately it's
technically not feasible at this point
because our modules have a lot of
optional dependencies as you certainly
eyewear Springs web module for example
or Springs JDBC module and others
optionally supports several binding
libraries several connection pools if
you choose to use for example jackson
then your spring web module has the
jackson support inside if you don't use
jackson just ignore those few classes in
the spring web module such a scenario
cannot be modeled in check so at this
point because jigsaw does not have
optional dependencies if you compile
against something jigsaw insists on dead
something being present at runtime so if
we compile our spring web module against
the optional jackson support or the
spring JDBC module against say the
optional connection pools that we
compile against then all of those
compilation dependencies are being
enforced at runtime this is exactly what
we do not want at a module system that
in that brings unwanted dependencies on
to the runtime class path I mean come on
that's a basically the top failure for
any module system attempt that you could
possibly arrive at a module system is
supposed to have a representation of
what you actually need at runtime it's
supposed to have a well-defined set of
to bring a well-defined set of classes
through modules on to your class path
not the other way around so we have an
issue here
it's well communicated it's actually
pretty much at the top of the wish list
under chick Sawicki has a lot of
stakeholders ourselves and quite a few
others that insist on optional
dependencies being declare a balloon
jigsaw in the sense of I want it at
compilation time I do not insist on
having it at runtime I can deal with it
if it's not present at runtime basically
a requires optional keyword something
like that literally with the semantics
of at runtime if you can't find it just
proceed and let me run into my no
cluster found error please that's
basically what we want from chicks are
pretty straightforward
a feature you would think but it's at
the top of the wish list for Harvey you
know not dealt with and we have no idea
what we can or should be doing to make
it happen it's really up to the chicks
or team to decide whether and when it
will make it in so at this point this is
an idea a vision a sketch we would like
to make that happen on jigsaw if things
remain the way they are right now we
cannot make it happen so we're going to
recommend to the keyline nevertheless
for the jvm improvements and basically
please keep using the classpath mode it
works fine on JDK 9 there's nothing
wrong with it and boot has a great auto
configuration experience with the clasp
of mode so we don't depend on this
really but it would nevertheless be nice
to have a story in this space wouldn't
it okay let's move beyond jigsaw to
something that actually matters http/2
I already hinted at it I personally
strongly believe we need to embrace such
industry efforts we need to embrace not
only JDK 9 we need even more need to be
focused on industry-wide standards
beyond the Java ecosystem and there's
nothing more important than HTTP to to
be dealt with here if within the Java
space we we wouldn't get our act
together here we would really look a
little bit dated compared to almost any
other programming environment out there
if you look at the state of HTTP 2
browsers they did their job right
--chrome well even even even edge and
Firefox and Safari day basically in the
meantime they all did their job quite a
few quite a bit of the server
infrastructure is basically already
capable of handling HTTP 2 but in Java
length the servlet containers well there
are good news and we'll we'll get to
that in just a bit but there is no
strong there are no strong forces
pushing towards it between the Java
space really its efforts by selected
stakeholders not necessarily by the
ecosystem overall so we won't really get
into why HTTP 2 matters but I've just
listed a few of the things that are
really really worth having I mean
efficient binary representation symbolic
references to the same headers instead
of really clearing the same headers for
every single request Mandara if you
thought of those things
I mean connection multiplexing in
general a few of those things that
really really matter we can optimize
whatever we want within our service
system if the system keeps talking the
20 year old HTTP 1.1 to its clients it's
kind of in vain alright so much for a
little bit of an HTTP 2 pitch so what's
the story in Java Lent there is an
ongoing effort for quite a while already
to enforce HTTP 2 support through
servlet for the DOE the servlet for the
DOE revision of the spec actually
literally enforces HTTP 2 support in its
implementations the problem is that the
spec is stuck in a proposed or a like an
early draft basically just a very early
proposal from last October hasn't been
updated in about 8 months no work going
on on the expert group it's basically in
a very unclear state like most of Java
EE 8 back most of the Java EE 8
associated specs but for service for the
DOE that's really a shame it really is a
shame because the focus of several is
for the dough itself is sound it doesn't
really try to accomplish too many things
it focuses on one thing a tries to do it
well which is HTTP to support within the
servlet world
so please could we make that actually
happen
could we have that right now no at the
moment the target date is mid-2017 mid
next year on the assumption that we are
already in public final draft which we
are far from in other words mid 2017 is
not going to happen
from where it is right now unless
something dramatic happens in terms of
somebody really picks it up and makes it
happen within a few months I don't see
that push our reaction to this is we try
to make it happen we have people on the
toilet for the dough spec we kind try to
do a little bit of lobbying we care
about tomcat 9 Tomcat 9 Soviet for focus
we really want Tomcat 9 to happen to go
Chie at some point but in the meantime
and that mean time can actually last for
quite a while still in the meantime we
focus on the native efforts in the
containers which have happened to have
and http2 story in particular tomcat 8.5
recently released which is kind of a
backward of the http/2 stuff from the
tomcat 9 line but working against the
server 3.1 container that is Tomcat AIDS
so tonka data fives the final effort in
this space jd9 the three actually led
the pack it was one of the first to roll
HTTP to support into a current
generation servlet container and
undertow 1.3 1.4 move moving 204 now
those containers did their job and they
are really worth embracing if you're on
Tomcat if you're on jetty and by all
means upgrade
use use a HTTP to enabled version of
your container of course in a now you
need to make sure your anti
infrastructure actually is able to deal
with HTTP 2 but there should be 2 is a
fine arrangement right you can if
something does not work it's implicitly
downgrades to HTTP 1.1 and you're not
taking anything away from anybody you
just make it significantly more
efficient for modern-day HTTP clients to
talk to your service
so for our Spring Fair Mach 5 purposes
we have a strong HTTP to focus in the
sense of we want this to make it into
production environments as soon as
possible right now basically so we even
rolled quite a bit of this into full of
three in Spring Framework folder three
all of this modern-day separate
containers are being supported you can
set them up with HTTP two spring works
just fine we are trying to make to have
an equivalent story for spring boot
where those containers are really the
recommended versions with their HTTP to
support for spring 5 we're going to
continue along those lines of course so
new revisions of those containers or
other containers having native HTTP 2
stories we will pick them up and do
whatever we can to allow the use of HTTP
2 through the spring web application
model but it's not really dedicated HTTP
to support we can't really go beyond the
server 3 that one API in the Soviet
embassy stack so so let's for the oh we
still would like to see it happen rather
soon I at least hope that there's going
to be a revision a kind of public final
draft by early next year which we would
pick up and support the latest tomcat 9
milestone at least against it so we're
going to do our share we're going to
have early servlet for the door support
in some form in spring 5 for sure
unless it gets dropped completely which
is hopefully not the case and not in our
control right we can just pick up
whatever Oracle allows to happen in the
servlet for space all right so let's
switch gears again to just a little bit
of a discussion about our reactive model
now the we've been talking about this
service center at 4 this is primarily
relevant from a spring perspective for
what we call spring MVC it's actually
more like spring MVC spring MVC is a
servlet based web application framework
always was still is tries to maximize
basically your your ability to interact
and integrate with
a servlet based environment and this
will stay the same in spring five spray
five will have spring so that NBC in an
updated form that's basically what we've
been discussing so Everett four capable
ideally but still essentially server
based so it integrated a good citizen in
integration with other servlet based
libraries and frameworks out there in
parallel to that we have a strong focus
on a reactive programming model trying
to rethink what a modern-day web stack
needs to look like in particular if you
would like to optimize it towards the
most efficient use of your resources the
most basically a servlet container I
guess most of you are aware is not
really particularly efficient in its use
of threatening resources you get a
threat from a thread pool it's assigned
to you you process your request you do
everything you need to do within that
threat and you just hold on to the
threat you don't let it go you write the
response you actually keep writing the
response until you're done even if it's
a couple of hundred megabytes and then
you let go there are ways to optimize
this a little there's insert of 32.3
that one that where some ways where you
could spin off long-running
threads to a another worker thread pool
there are ways to go around it we have
actually support for it in spring and we
see the deferred result model and some
of those things it certainly addresses
some hotspot problems but doesn't change
the fundamental architecture the
architecture is not there's nothing
wrong with the architecture the
architecture just implies certain
compromises that you have that you have
to be willing to accept and we are all
learned to accept those in the circuit
world in the reactive world we can turn
the picture around forget basically
about server containers
what about a modern-day web stack and
network stack that does HTTP endpoint
processing on an engine such as nettie
the common choice for custom efficient
network stacks out there
so if you run on neti you basically go
back to a pre servlet world almost you
focus on the network stack itself and
the programming model that has to go
with it in order to actually allow you
to expose the capabilities at the
efficiency of this underlying network
stack has to be reactive it has to be
callback driven you react to incoming
data when it's actually there you react
to the ability to write to the response
when the network stack is actually able
to send data to the response you don't
just work with input streams and output
streams you work with reactive streams
and this little and manifesto thing
actually led to the reactive streams
initiative reactive streams is a
specification well is it it's actually
more like four types it's a very small
condensed set of types modeling a
particular part of the challenges of
reactive interaction between resources
it basically literally is a publisher
type with a subscriber a subscription
model and epic pressure arrangement
where publishers and subscribers can
interact with each other kind of the
publishers not going to just send stuff
the other way without even worrying it
actually waits on a subscriber to
require data from the publisher
publishers and subscribers interact with
each other when both are actually
capable of doing the job in simple terms
reactive streams itself is not a user
programming model reactive streams is
basically an infrastructural initiative
where network stacks HTTP containers of
some sort data store drivers and
application frameworks can agree on
basic types that they can pass along
that they allow to interact the real
power of the model only shines through
if you
can interact reactively from your HTTP
endpoint down to the data store and back
up that's why reactive streams is so
important your active streams initiative
is so important so reactive streams is
basically a github project and the
website in Auckland director streams and
has been embraced by all all current
stakeholders out there or at least they
all expressed an intent to embrace it
Eric's Java for example predates
reactive streams and rx Java to is not
kind of not actually getting there that
quickly our own reactor project this
reactive stream spaced so that's the
probably the reference example for what
a reactive streams based library and
Composition library in particular can do
and occur streams is also reactive
streams align so there is some broad
industry support already and it's even
going to be repackaged into JD keen eye
on the in you Java util concurrent flow
type in JDK 9 is the reactive streams
API repackaged into subtypes of this
flow container type but it literally is
the same API just in a different name
space so the reactive streams does not
try to model composition libraries so if
you have any impressions of Eric's job
already
Eric's Java basically is a very rich set
of of operators it's basically a
composition library where as reactive
streams is just a minimal interaction
specification they are really very
complimentary for a user programming
model these things made them much more
than reactive streams itself so you
would focus on the use of reactor or
arch Java for example so to give you an
idea what this can look like we are
talking about something really pretty
really see here this is a github project
Nardi project of ours called spring
reactive we actually somewhat close to
merging it into a Spring Framework 5
little master branch we intend to do
that in late July but at the moment you
can look at the current state on github
in the spring reactive project the idea
is that we use a
spring MVC like programming style spring
MVC oriented or aligned controller model
but running on a reactive network stack
exposing the full power of the
underlying reactive stack if you choose
to use it so we're not trying to
abstract the stack between Soviet
embassy and and and the reactive model
here we're trying to provide common
programming model elements but you
choose once they go the other basically
you have to live with the compromises
you get all the benefits but also all
the limitations of the stack that you
choose typical spring style we don't try
to abstract and take things away we try
we rather try to align so stylistically
in the sense of our at the beginning
where we talked about a couple of
stylistic elements in spray for free
sigh listicle EA web controller on a
reactive stack looks very much like a
spring MVC controller uses request
mappings uses the controller stereotyped
its regular component classes managed by
the spring container request mapping
binding requests to certain handling
methods but now look at the handler
method signature the handler method
signature does not accept a fully
converted payload from the incoming
request it doesn't return a fully
computed response either it declares a
type called flux coming from the reactor
project if you have an our Excalibur
ground think observable so you actually
get a hot stream basically a an access
to the incoming data in not fully
consumed form and you can express
operations or pass them on of course
against this incoming stream in a sense
that allows the runtime to call yours
your operations back as the data
actually comes in and as it is actually
consumable without blocking the threat
without waiting on any stream to give
you further bytes of data so you program
in a way where you
allow the runtime to call you back
efficiently you never block you just
have small processing steps four pieces
of data chunks of data the runtime is
then able to selectively call you back
as the data is actually ready to process
so this style for any anyone having ever
looked at Eric's Java should look very
familiar
you can literally switch flags to
observable and it would look the same
we intend to also support our extrav
observable by the way so the intentions
in the current prototype and in all
likelihood also going to be in spring
five proper the real power and this is a
sketch so this is not working code right
in like what what's my repository this
is more of a sketch that we're we're
working towards and the real power is in
the interaction with the underlying data
stores if your processing architecture
is reactive all the way through if your
repositories and the underlying data
store drivers support reactive streams
ideally you could make something like
this happen and an incoming hot stream
of data being passed on to the
underlying repository written to the
target data store as the data comes in
from the HTTP request and as the output
as the data's was actually able to study
the output so reactive interaction at
that level would maximize the effect
that you get because the general
questions behind this are more along the
lines of what kind of benefit will
actually get in my environment with my
work load my system constraints so this
is basically what we're working towards
spring data by the way if you think
repositories bring data repositories
spring data plants to have dedicated
reactive repository support very soon as
well so we are working at that on that
at several levels here it will also work
with customer arrangements of yours
there's no need to have a fully
spring-based stack here reactive streams
as a general industry initiative allows
you to work with other data store
drivers that we are not even aware
as long as they support reactive streams
you should be able to wire them up and
have efficient processing gents without
us having to do first-class support for
it that's the vision that we're working
towards and that's why not only we have
to do our job there are quite a few
others working on efforts that directly
connect to this reactive or at least
non-blocking drivers for some of the
data stores for example couchboys
there's even one in the works or
Postgres if I never personally looked at
it the equally important parts are in
the frameworks and the HTTP processing
libraries so a reactive server rectified
UDP service great but on the client side
in particular within a larger micro
services arrangement where some services
of yours are going to call other
services of yours we also need reactive
HTTP clients making very efficient use
of threads and HTTP connections on the
client side and last but not least we
have a joint initiative called reactive
streams Commons we're quite a few
industries they called us collaborate in
terms of carbon code for example
adaptors to several three that one a
single where our our programming model
our reactive and with MBC like web
endpoint model can actually run on a
server container but not as server at
NBC it's more like with the reactive
streams version of this disarrangement
adept adapted to the underlying server 3
that one is an i/o model this is not as
efficient as you would hope it would be
we strongly recommend a proper reactive
Network stack more towards the likes of
nettie this becomes more interesting if
jetty and Tomcats actually pick up on
reactive streams comments because
there's an SPI in there that allows them
to expose efficient reactive streams
handles to us through the server through
that one model so this is still in the
works we're talking all talking about
things that basically all in planning
stages are in the works here if this
turns out
by early next year we might actually
have a pretty efficient reactive web
stack on cheerio II and even on Tomcat
somewhat soon we'll see so we are we're
working with several several
stakeholders here trying to move this
forward in time for early next year
because early next years when we intend
to go GA with this our goal is to have a
release candidate towards the end of
this year a spring from act 5 to the RC
one towards the end of this year a
milestone one in late July that's pretty
much a given at this point in time for
our spring 1 conference in Las Vegas
this year and our C 1 towards the end of
the year and the GA date soon after as
soon as possible as you may figure we
depend on some other efforts we really
want things to work together properly we
don't want to go GA too early with this
it really needs to work top to bottom as
a sound overall arrangement so our
target is roughly March 2017 that sounds
like a JDK 9ga target doesn't it
intentionally so but if jd9 is not going
to in March we are probably nevertheless
going to go GA with spring 5 in March
we'll see this is a little bit too far
out for a heart promise the goal that we
see is a kind of hard target at this
point is an RC one by the end of the
year and we'll take it from there
alright so much for a little bit of
insight into our work on spring for Mach
5 and some of the thinking behind it
thanks for your attention
enjoy the rest of the day and if there
are any questions I'm happy to have them
here
we're running a little bit late but I
think we have time for one or two
questions that came in through the app
so let's look there's an app for that
yes there is that for that exactly so
one of the questions is when you were
talking about embracing a new industry
standards
why did spring choose to have its own
spring MVC based programming model for
restful resources and such rather than
using jax-rs Radames xrs oil a short
version of this is we primarily care for
actual industry standards in the sense
of across language standards within the
Java ecosystem we do not really have a
lot of trust for the JCP to deliver and
if you look at the current state of Java
yet just Google for the state of Java
yet if you haven't read the news then
you know what what I am referring to
here we like to be in control of not
only our vision but also our ability to
deliver on the vision and with checks or
essence bring everything particular
there's not enough time to discuss this
but there are quite a few design reasons
why we chose to have our own model we
keep it reasonably aligned so that kind
of you know how doesn't have
artificially break if you switch between
them but I would argue our way of
handling this in the sense of the
ability to release when we already when
we intend to release when we think it's
needed in in production and the ability
to evolve it from there
every year with new features and
refinements at our pace this is
essential to the success of spring and
the chassis features doesn't cut it in
that sense a new version of is back with
an overloaded API method every four
years is not my taste of evolving a
programming model there are some other
questions but there are a rather low
level technical nature so I advise
people to for more intense questions I'm
here all day I'm also here right now so
just let's just chat one-on-one so thank
you for attending please don't forget to
vote and hopefully we'll see you at the
next session here on this track
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>