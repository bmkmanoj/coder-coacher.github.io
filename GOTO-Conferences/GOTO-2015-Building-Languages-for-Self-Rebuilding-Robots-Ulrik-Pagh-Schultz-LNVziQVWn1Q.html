<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Building Languages for Self Rebuilding Robots • Ulrik Pagh Schultz | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Building Languages for Self Rebuilding Robots • Ulrik Pagh Schultz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Building Languages for Self Rebuilding Robots • Ulrik Pagh Schultz</b></h2><h5 class="post__date">2015-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LNVziQVWn1Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm going to talk about building
languages for self for building robots
there are sort of a nice combination and
we're doing both I'm from the University
of Southern Denmark and of course I mean
this is about robots and robot is
hardware and electronics and software
and AI and all kinds of other things
together it takes a team so there's a
whole bunch of people who are involved
in this and have some names up there
other people as well but so big team
effort but before I begin a here is the
standard default reminder so please
remember and moving on so a i love the
keynote this morning I mean that's just
amazing right and and we should have
more of that I I don't have anything
anything that's anyway as cool as that
but we have in fact been very inspired
by some of the same scenarios so and
here's the question right so as we
learnt this morning you can only bring a
limited payload when you go to mass it's
very expensive four kilograms so if you
want to bring a robot which one you
bring to bring well does of cost us it's
you you can bring along it can go
scouting and to scientific missions for
you so you don't have to go outside I'm
of course I'm thinking you're going to
in person right so um we could bring the
role like that I could cost cutting
force or if we're worried about this
rain so of course a role has wheels so
due to its I mean physical properties
it's going to be very efficient we're
moving across flat terrain but it will
have difficulties in more difficult
terrain so we could also bring a walker
kind of robot if you haven't seen the
Boston Dynamics now Google big dark
robot that runs around with sort of a
very natural movements see the videos
they're amazing so we could also bring
that and have that running around on the
surface of mass or maybe if we're
actually building a habitat and we're
going to live there then
maybe we should be bringing an
industrial robot around well industrial
robots as you probably know a key to
industry in Europe and in many other
Western countries at the moment they're
building lots and lots of things and of
course when we go to mass we will need
to build things and we probably don't
want to go back to having the hammer and
saw and doing things everything by hand
so you might want to bring the
industrial robot but we only have
limited space so which one do we bring
so a who votes for bringing curiosity
round for scouting so we don't have to
go out of our inhabited but we can you
skype flat areas it's one with timid
birthday okay so if you how about big
dark because let's have that running
around the mass right they'll be cool
okay yeah yeah okay and then the
industrial robot to build all the stuff
that we need so we can actually survive
survival okay all right so and of course
this is actually a picture I haven't had
a chance to see it yet it's coming out
to start this is a picture from the
Martian so there's this guy who goes to
mass with some other people and
something bad happens and the problem is
when bad things happen you don't always
know it in advance what's going to
happen so maybe you didn't bring the
right robot for the bad thing that would
happen so my answer this is of course
cheating is that all we shouldn't bring
any of these robots we should build a
robot building kit so we can build the
robot that we need when we are mass the
video here on the right is three times
normal speed by the way I a lot of our
robots are very slow so I sped up most
of the videos to make them look more
exciting so this these videos are from a
competition that we've competed in a
couple of times you bring a suitcase of
robot pants a small suitcase and then
you have to solve tasks you don't know
in advance what the tasks are and they
all have this mass like emergency
scenario you have to solve things
outside and then people building all of
these weird contraptions I mean they're
taking different robot parts putting
them together and some wood and some
tape and some string and whatever else
you have available to try and solve the
problems and you have a
how about hours to build robots and then
they have to go out into the arena and
do things to gain points and this is a
great sort of like a massive hacking
experience and but except of course when
there's only three hours you don't have
so much time to code it just takes so
long I mean and the robot even building
a robot I mean they're all the parts
have to be ready you could maybe use
legals but usually goes are not good for
building big robots that's all bigger
tasks they're mostly useful for smaller
things on the right here we actually
have to do the video from this is our
robot that just gained a lot of points
by that was one of the task raising and
then turn up into the end so they're
very simple task we have to solve but
nonetheless this illustrates one of the
basic principles here that just a few
seats are on the lifter and the basic
idea is that we have these building kits
such that we can very quickly build
robots that solve the problems that we
have so and and disclaimer don't
actually really bring these robots that
I'm showing you today to mass because
then you'll die I mean their research
prototypes but they're pointing in the
direction that we're trying to go to and
of course in the context of this
conference what I'm also eventually
going to get to is how do we program
these things but first this PowerPoint
with movies in is a little bit tricky
and let's be honest here so I mean below
so these are these have three robots
that we build ourselves from our robot
building kits it's called the h1 i'll
talk more later and mmm I mean I'm a
researcher so I'm used to making of good
stories but that's it that's a bit of a
distance from there to there right to be
honest so so we still have some work to
do and we of course need to develop this
some more but on the other hand if we
can sew these robots I should say will
never be as good as the special purpose
built one
but keeping in mind this morning's
keynote it took it was a massive
engineering effort to build the
Curiosity rover I mean it's amazing
right amazing piece of machinery but if
we stuck on mass and we have one hour or
two hours to build a robot we have to do
something different and that's the thing
we're looking at or maybe waving in the
situation where we're not there maybe we
just sent a bunch of robots Tomas and
we're not even there to build new ones
but we still want maybe other robots
from what we had in mind the first so
here's the special thing about so this
is showing the ck but a name train
they're sort of similar so these are
actually because the modular their build
from small pieces of robots that are put
together and a bigger one they can
rebuild themselves so here's something
bad happened that might not have no mass
but something else might have no math
where the robot falls apart and so who's
going to repair it well the robot on the
left ck but in this case is showing how
it can self repair this robot has
started as a walker TM trend and it's
going to rebuild itself into a snake
robot so the idea is that well as a
walker you can move more efficiently but
me it's how to get through hole so you
might transform yourself into a hole do
something and then come back out again
so these are actually transform of
robots and I'm that's what we mean by
self rebuilding robot self
reconfigurable robots we have and we
actually building these machines at the
moment which in one way is amazing we
have self rebuilding machines they're
not very good yet I mean this is not a
very good snake robot if you've seen
other pictures of snake robots well you
can do much better than this but it is a
self rebuilding machine and still
I mean it's credibly need right on the
other hand we still a long way off from
the robust I we sought to begin with so
I just want to give you a little bit of
perspective on where this we're trying
to go with this kind of technology so
the m train here is so useful that it
might actually I mean you could have
entered imagine it might maybe being
useful for something but taking a bit
father and the long-term perspective
this is like 20-30 years into the future
is what we like to call programmable
matter now imagine you take the same
principles as before but made the
modules really really really really tiny
so that's this it's a bit hype the video
on the left but it has this idea so this
is the cold electronic project so
they're building or trying to figure out
how what if we make these things be
really really tiny how can we do that in
the first place this requires completely
new fabrication techniques and how can
we program them I mean this is a
distributed system consisting of
millions of millions of nodes and you
have to somehow distribute the control
across all of these nodes I think it'll
be a while yet honestly before we see
something else I've answers but they
have actually build prototypes and also
some that I couldn't find a picture some
that they're doing a 2d version to begin
with so this is a two dimensional
version of the same principle cylinders
that can move around on each other using
electrostatic forces or electromagnets
here but if they're smaller they would
be using electrostatic forces so this is
in some way what we aspire to do with
this kind of technology we're not taking
at this only works in simulation and
probably will only work in summation for
a while yet they've been looking a lot
of how to program these things they've
been looking at that from the point of
view of how to make it work in the
simulator which sometimes lets you do
things that maybe won't really work
practice so in what I'm going to be
talking about we've been doing something
different so we've been working with the
H on robot
which you can build many different
things from it that much bigger when
modules but I mean two hands together
pretty big but in a way I mean it's not
completely unlike the clip tonics you
saw before that is fierce taken hold on
to each other with hooks the difficult
to program so if you keep if you look at
the video on the left so this is an
initial experiment trying to have the
robot rebuild itself you'll see more
about it later and when doing robot
experiments that's this thing which we
technically call the hand of God which
is the robot doesn't do what it's
supposed to do and then someone reaches
in and passion should be that does
whatever so here so here my my student
Mirko is desperately trying to get the
robot to to move but it doesn't
programming these things reliably is
difficult and I'll get into more details
later on as to why it's so difficult and
the setup we're showing here is actually
just out of hardcore random movements
because we didn't know how to program
them such that what we wanted to do was
have a sort of fabrication system so
conveyor belts built from the modules
transporting things around and of course
this is not just an a plane conveyor
belt this is a self rebuilding conveyor
belt so it can adapt its shape to
different kinds of things you want to
transport around but even though I mean
physically they're capable of doing this
we we didn't know how to program them
and that's what this talk is about I
mean eventually I think this kind of
technology can be very useful bear with
me we're looking into the future
although it will also come up with some
practical applications later on but we
first have to learn how to program them
such that they are reliable and it
doesn't take a complete PhD like three
years of our four years I'm a long time
take it takes to make the robot to a new
trick and that's what I'm going to be
talking about programming robots is
painful and a one important message I
think for you today is don't ask what
robots can do for you ask what you can
do for robots what I mean is we have
robots doing lots of useful things but
it really needs some good software
engineering that test
wordly trying to make better software
and it's not always the right people who
are writing the software that runs on
the robots so we as professionals I
think there's a lot of potential in
robotics but it really needs the right
kind of people because there's lots of
bugs lots of things that go wrong
halfway partially breaking down or
sensors that I've been inaccurate
leading to all kinds of complications
that we're not used to but that we have
to address somehow systematically and
maybe in a bit more detail so from the
point of view of of our system of the HR
robot here this is the i mean honestly
one of the problems that we built these
things ourselves that's nice because we
have this really cool hardware selfie
building machines but this is like
building your laptop I mean by
soldiering components together and I
don't know about you if I try to do that
myself the result wouldn't be very
reliable and that's the problem here I
mean we're pretty good at building
robots but still it's very hard to get
to the level of reliability we're used
to with ordinary computers so that's one
issue and I'll get into a bit more
detail about that later the other thing
is that we have some pretty complicated
stuff going on I call the intelligence
here I maybe I should have put some
quotation marks on their algorithms that
whatever makes the robot do what it's
supposed to do and when you have really
complicated behaviors advanced things
going on well then it's usually hard to
come up with a specific algorithm that
does exactly what we want unlike most
standard problems in computer science so
I put some neural networks some genetic
algorithms and some multi-agent systems
up there and whatever else approaches
that many different approaches to
dealing with this complexity where we
don't have perfect solutions where we
don't know exactly what to do and that
great but how do you program those
things into our unreliable hardware well
the standard approach that you take is
that you write a whole bunch of c code
and then when the robot does what it's
supposed to do you throw the secret away
because you don't want to look at it
again because it was awful then you
write some new C code that sort of the
what we've been looking at here and what
I'm going to present in this talk is our
experience in using domain-specific
languages so making new languages that
fit the kinds of problems we're working
with as a means to doing this so you
might be wondering why don't we just use
Java or whatever or some other
high-level language well the thing is
our high-level languages don't
necessarily run on our tiny embedded
platforms so actually the h1 as i showed
you that's pretty big and we have
actually made some more powerful
versions but they're very limited
resources and maybe that's not too bad
because we really want to go down to the
really really tiny modules and they're
never going to be really powerful with a
lot of this hardware as computational
power increases we just want to make
them small and more power efficient so I
don't think we're ever going to be
running huge complicated java programs
and these things we're going to be
running maybe not see coders but
something else something that takes into
account resource requirements time and
it's more that has more modest space
usage and my way of doing that well have
different ways of doing it so people
some people make a really clever
languages and abstraction said on
whatever I think that's horribly
complicated so the way I deal with this
is to make domain-specific languages
where I can express myself in terms of
the problem addressing and then have it
generate some C code so i said i don't
have to write it myself and if i have
the right generator then everything
works and i'm happy getting the right
generator can be tricky sometimes but
that's part of the job so just be
carrying the main specific languages for
neural networks or whatever but i'm
going to do the languages that those
people can use to make the robot do
something and just quickly catching up
on domain-specific languages so i don't
know if everyone here is familiar with
them who here is familiar with
domain-specific languages good you
should be so I mean I think they're
excellent and
half it is maybe because of the problem
facing because they're really to my tool
for the job I mean it's very hard
otherwise to abstract over the things
that robot does but being able to make
up our own abstractions is really
powerful here and some of the normal
advantages that we have from
domain-specific languages are perfect
here so we have the issue of how can we
get better productivity well it's hard
enough already writing programs for
robots so better productivity does
oneness communication with domain
experts is the domain experts here I've
roboticists so I mean they can talk
programming stuff so that's not such a
big deal change in execution context
that's exactly what I was talking about
before I want to write something high
level and get C code that's very
efficient out of it alternative
computation model well i'll be showing
you a few things where we want to do
distributed programs without worrying
about distribution but we want to have
programs that one forwards and backwards
because the robots need to do things
forwards and backwards and again it's a
diff completely different way of
thinking about the execution and of
course verification I'm not going to
talk so much about it here in this talk
because our robots were well we
verification is interesting because it
could help us catch bugs early on and
I'm going to be talking a little bit
about some more dangerous machinery
later on where verification is really
important so um just to be clear so
we're talking about how to program the H
on robot here so this is a modular self
reconfigurable robot marcha it's a
matter robot meaning that each of the
modules each of the round spheres is
unto itself a robot it has its own
battery its own actuators its own
sensors its own computational power it
has a massive 8-bit Admiral processor
with 4k of ram and and this is excellent
when you doin program generate
introducing it actually has 128 k of
rome for storing the program
that's pretty good so and again we could
put could put a pic a person signed up
but if we want to go really tiny that's
maybe not what we want and that is one
of our future goals it does 3d self
reconfiguration meaning you start with a
robot that is built in the right way
because there's certain constraints in
how can rebuild itself and it can
rebuild itself into another
three-dimensional shape of course it's
still going to be made out of eight runs
out of round blue spheres so that is a
limitation of the technology as it is it
can build lattice structures these are
like crystal structures where they're
really strong so you could build very
strong I mean bridges or pillars or
whatever because they can lock it's the
each other into a crystalline structure
essentially but you can also do
something like this snake robot we saw
before where it's more flexible and
pending and doing things there I so they
use physical connect us I'll show you a
video would be later where you can see
bit better with it to hook onto each
other and then one module can grab onto
one shifted some waters in structure and
release it again after someone else has
grabbed onto it they have they
communicate with each other using
infrared so we don't use radio because
well basically this is made out of metal
so it's one big antenna so radio
wouldn't scale so well so we use
infrared for neighbor to neighbor
communication which is nice because then
we can scale to arbitrarily large groups
of modules it's bad because it turns out
that infrared is a bit difficult to work
with when you building machinery that
rebuilds itself so we have this basic
that's a problem where sometimes our
communication diodes will be misaligned
and it's not a reproducible problem
sense that two modules that connect to
each other might communicate just fine
to other modules might that communicate
all only have one way communication I
might communicate to the wrong module
because the IR reflects off something so
that makes it a bit more complicated so
we have here a real-time embedded system
with a dynamical evolving topology
because the robot can rebuild itself and
reliable test the infrared communication
problem they also tend to lock up
sometimes maybe because we built them
ourselves also because well sketch
machinery is a bit difficult so if
you're not careful when we program then
we easily get into the I'm trying to
remember that Leslie Lamport has this
wonderful quote about how a distributed
system is a system where as server
somewhere that I've never heard of
before crashing keeps you from doing my
work on my own computer something like
that so this is basically the same
problem I mean if you're making one of
these modules locking up then we want
the whole robot to keep going that's the
whole point but when we program them we
often tend to my programs where this is
not the case where we somehow become
dependent on all of the other parts of
the system to work perfectly not
intentionally but when C is your
abstraction layer well that's how you
tend to end up thinking about things by
experience so we were looking at how to
make better languages for this well so
we went ahead and made some languages so
here's our first prototype we're
thinking oh but these round blue spheres
to like objects right and be like object
orientation so that must be nice and so
each of the we can give we can program
it such that we give each of the modules
we think of them like adopting a sort of
like a whole path design pattern so much
into design patterns at the time and so
that might be a nice way of thinking
about it and making the programming
model accessible to the program and so
we could write something some
declarations that express somehow how
things connect to each other and we have
different roles so we have the connector
in the middle the axles that hold the
wheels and they're the real modules and
we can give them different kinds of
behaviors and then we can say oh the
whole is something like this so it also
first try um and it was sort of
interesting too well compared to the C
code that would that would be like
hundreds of lines of C code to express
the same thing in a much less clear
fashion so um because modularity remote
procedure calls distributed programming
work well one thing that wasn't so nice
was dead it was actually hard to get the
connections right because we had to
write them manually
and while the programming model maybe
wasn't perfect and it actually didn't
work very well I mean all kinds of
problems we ran into it with it so back
to the drawing board do that okay so
object orientation maybe wasn't the
right way to think about this and at the
time I was I always been sort of
interested in functional programming and
I thought oh well lots of people are
doing more and more functional programs
so let's try functions and specifically
we went ahead with this concept called
functional reactive programming which is
a I mean it's an amazing idea so
basically write your program as a bunch
of functions and then they're
continuously recomputed by the
underlying system that seemed to make
sense here so we can write that or
certain parts of the control is
dependent on sensory input and then
that's how it should map the sensor
input to the actuators so I mean that
seemed to make kind of make sense and we
could write down the roles and sort of a
simple similar similar data types and
write functions functions would then
apply a crop be applied across the
structure of the robot and we could have
this so for example here there's this so
computing the number of wheels then we
fold the function that adds one to the
current number of wheels across the
structure of the robot we can write this
you know like function programs i'm
doing right this wonderfully come back
things which is ah yes this is perfect
um thought i was a one like friend so
well good things about it so the roles
as a kind of here made sense and we had
wonderful of functional abstractions
which is nice um and of course I was
telling my robotics colleagues about
this all the wonderful functional
attractions that are like nope because
it turns out that not everyone loves
wonderful functional attractions
actually going back to a show to the
electronics the simulated robot so they
were doing logic programming for
programming those and they have actually
the same problem they had this
wonderfully compact logic expressions
for expressing what a robot you do but
no one could understand them and well
the only working simulation as well and
it was also hard to actually implement
these wonderful functional abstractions
it turned
out when we only had basically 2k of RAM
free and each module because the rest
was used by the operating system and it
also it what we actually want have two
good things about these robots is that
they can rebuild themselves which is
sort of a more discreet thing and they
were more useful for continuous things
and they and we couldn't really make it
work so again maybe not the best so then
I talked to some people who are doing
role or in the programming so that's and
people also talked a lot about roles in
terms of modeling and processes how do
we do this through that ok let's try and
put that in our language so i have a
small video here and this is you in this
kind of video that you work for two
years and then you have a very
unimpressive video so this is one of
those okay so so here we have the robot
there's a bug in our program and the
program of course is the super cluster
nodes and then my student me who is
carrying one module there to reprogram
the module so they actually being
reprogrammed by flashing sending a
program message to one of the modules
that then distributes a crowd across all
of the other modules so what we got to
the point here where we had a virtual
machine running on each of the modules
which was I was pretty happy about
because we only had this 2k of RAM
available to it and we could do dynamic
updates after program type of running
there sure if that was pretty neat and
the virtual machine work in terms of
roles so each module play the roles and
then it grabs whatever code is valent
for that role and execute it and we also
made a small roller in the programming
language so we could write over the role
of a wheel is like this and it has
certain kinds of properties in some
kinds of behaviors and we could write
how they what eventually right to how
CUDA can they communicate with each
other and we could structure the rolls
into a nice hierarchy and and then I was
actually feeling pretty good and people
were sort of okay about it when I was
talking to my robot school exam but they
were all using bolts actually i should
mention so they were using roles as a to
think about how the robot should be
doing things so that makes sense um so
all that was pretty good um and we could
do small Simba
things with it so we then realized that
we didn't really this work but it didn't
really solve the hard problem the hard
problem was given a whole robot made up
of many modules how do you program the
robot as a whole so we're thinking too
much about the individual modules not
about the behavior of the robot and also
i put here doesn't really work because
we it turned out we are making
assumptions about communication being
reliable we didn't believe mean to but
yourself a can you take it into this so
we're getting into a style of
programming where the program would say
oh send a message to the wheel and ask
you to do something if that message was
lost then well how do we proceed from
there so again it although i should put
avoid much better than what we had
before i still wasn't there and then a
mother sits inside which was that we
should think much more about having one
program distribute across the robot and
here's the this is one movie that i like
better so this is a showing again the h
and robot stands out as a car which
could dry around it doesn't have just
but then it rebuilds itself and this is
made this rebuilding is done using our
distributed programming language so we
write one description of what the robot
should we do should be doing it in
rebuilt itself you can see the hooks
moving in and out and they are
continuously communicating with each
other some operations are done in
parallel and it's actually highly robust
in the sense that you could turn off
parts of the robot and when you turn the
back on or replaced if you replace the
modules they've just pick up whatever
was going on and continue we running the
program here that changed from a car to
a snake robot so again this is the case
where we're trying around us a car and
then we want to change the snake robot
so what's nice although I didn't say
that before what's nice here is that
before we made this there was only one
video of the robot doing that and it
took a week to shoot that robot I should
shoot that video they kept going for I
think the fun as you shoot the robot
at the end because they had like
40-something tries to make it to it once
and then they got the video and they
could write the paper about it here we
actually got a 30 times improvement in
robustness so we did still have a few
failures maybe once in a while but it
worked basically five out of six times
with our new and improved programming
approach so that felt very good and now
we actually and also as you can see you
we were changing the robot the robot was
changing from the car to the snake robot
no one had actually done the other way
before because I mean who wants to spend
another week doing that but our
programming language is reversible so
you can run the program one way to
change from car to snake and then you
can run it the other way to change from
snake to car from the same description
the description is I mean not incredibly
elegant but looks something like this
where you can say oh this sequence
consists of a number of regions that
happen across the modules of the robot
and this is then compiled down to a
robot's execution model where instead of
having thinking a lot about the state
and what each module is doing we have
more of a sort of a wave of state
changes propagating across the robot
they might be changing independently at
different parts of the robot and then
they're continuously trying to
communicate these state changes to each
other and merging them whenever
communication is established between
different parts of the robot this is a
completely different programming model
in terms of what happens when the system
execute we don't assume two-way
communication for example so if
information can get through it will get
through and will be merged into our
global state edit out our understanding
of the system this is an example of what
we call a spatial program language so
where's because in this kind of system
it takes time to communicate from one
end of the robot to the other so instead
of assuming we have a perfect notion of
state which is reliable and the same
across the whole robot we work we have a
programming model where state changes
avenged and will eventually end up being
being the same will eventually converge
to the
same state but as long as I have enough
information to proceed locally we do so
this was a fairly simple example but it
actually gave us a massive improvement
so just very quickly one of the key
things here is that each module has a
local notion of state and then
continuously communicates that to all
neighbors that happen to be connected
and sometimes we have two-way
communications sometimes we will have
one way communication and as soon as a
module receives information about what
happened in some other part of the
structure it merges into its own
worldview and propagates that
information to the rest of it all
messages are sent as it important
messages and all aberrations are
impotent meaning it's okay if you just
get half way and you lose track of what
you doing here to do it again it's okay
if messages are sent multiple times and
again this really did wonders for
improving out the reliability of this
otherwise highly unreliable system we
were we could shatter it all of a sudden
partial failures so parts of the system
to where otherwise we could locked up
when something bad happened would work
continue working and we could also
switch off parts of the robot and would
pick up again terms of efficiency we
were much faster than before we could do
things in parallel communication was
much more was just going on at the exact
weight which was perfect for the robot
which turns out to be around 10 Hertz
for these machines but a different kind
of robot we would just change it that's
something which we didn't put into the
program of course this is part of the
compiler part of the code generator so
something the programmer doesn't worry
about and then there's this idea about
reversibility just sort of the same
video again but that actually got us
thinking a lot because well in this case
it turns out the reversibility was very
useful so going from one shape to
another it's kind of obvious that you
want to be able to go the other way as
well so we start experimenting
bit more with so what happens if we won
reversible programs on a model group for
broker for example so what is the
reverse of goin forwards and trying to
evade obstacles well turns out that
there wasn't really that didn't work so
well but it's really perfect for
suffering configuration and a bit later
I'll show you a an excellent example of
where reversibility I she turned out to
be useful and so all in all we actually
have a system that works we have a
practical use of this notion of
reversible computing which is that
programs can run both forwards and
backwards which is also which otherwise
is sort of a highly theoretical computer
science construct the only bad thing
here about the language is it only does
sequential regions so we have some
artwork where we kept working with the
language to have a much more powerful
language I won't get into details now
because basically was about the same
principles as you saw here so a
perspectives on this so ultimately what
we'd like to do this is the program will
matter that I talked about before
morphogenesis building new things out of
smaller parts so we could imagine robot
cast build out of eight runs coming
together on the floor building up a
notch pillar so this was a sort of a
rescue scenario where you imagine oh
there's a house that's about to collapse
and you send in your small robots they
form a pillar that then supports the
house I'll build something else and the
key to making this work was
understanding that well our Hardware has
certain limitations and we must fry the
program in malda Majesty's we must limit
the expressiveness of the programmer
such that the program cannot express
things that we can make run in a
reliable way on these robots because
otherwise it's never going to work
unfortunately we don't have a systematic
way of doing this so this was about
making you two matrices we drank this I
try to convey how well there are
different kinds of abstractions that
we're thinking about of putting in there
but that was the inside
still which I mean we often know that
that you're trying to solve some
programming problem and then some point
you are so that's how it should be done
and that was soft assignments that here
at the language level we are trying to
find out ways of being more systematic
about this just like we have design
patterns for doing object and
programming we think maybe their
patterns for how to do languages that
could help us in doing this I mean
that's something I personally consider
very interesting otherwise what do we
did we learn from this well this thing
about being physically modular about
having abstractions so how does that
work for other kinds of robots and well
we have the industrial robot that I
talked about before so this is a
commercial video from Universal robots
so that the local Danish company that
does industrial robots they're doing
really well they started in our well
almost the basement in the lab in our
University ten years ago and they've
been doubling in size every since then
and there were recently sold for two
billion kronor which is well somewhat
lessened yours post a lot of money and I
promised to tell them to say that they
were hiring they desperately need high
level software people so they of doing
really well they're selling the robots
all over the world and what's
interesting about this robot is that if
you look really carefully actually you
can see it has these blue caps on the
joints so that's the exact same blue
color we had on the HR modules because
these are the same people who made the a
chance to begin with who made that robot
this robot is actually highly modular so
the joints and the various segments are
made many of them are the same and you
have the same advantages in terms of
making the robot easy to test easier to
bake easier to make and easier to
produce we do a lot of work with
industrial robots as well currently
we're looking at how to assemble things
so assembly is something that robots
traditionally have not been very good at
and it's well the thing is when you have
to several things you have to sort of
well they might be writing if it's a
food processor whatever for your kitchen
you want
simple well the plastic parts might be a
bit hard to get a line probably in two
screws and that bears other things and
well it's a bit difficult for robotic
sure but that's something we are looking
at at the moment in research and this
brings me to a next thing that we picked
on up on from the a chance which is if
you think about it assembly is might be
an example of something that's
interesting to be able to do in reverse
so that's what we're doing at the moment
so what we've done is to come up with a
language for describing assembly
operations making robots build things
that is reversible so if you run the
Rope program backwards the program will
disassemble whatever the robot was
building so if you want to take your
food processor pad for repairs the robot
now knows how to do that automatically
if you want to upgrade it to a larger
motor or than we do with food processors
then it will do that as well if in the
middle of the assembly process the robot
gets stuck because of some misalignment
well then you can pack up a few steps
and go forward again and that helps a
lot so taking this idea of faults and
backwards for the physical motions and
putting the into language is giving us a
lot of new possibilities for assembly
operations so that's something I'm
working with the one which i think is
going to be really big we have a nice so
small domain-specific language we have a
try thing here but it's not like a
try-catch it's try something a number of
times three times in this case if it
succeeds keep going otherwise well if
you fail more than three times keep
backtracking so we have these constructs
that are sort of similar but different
in terms of modularity we're also
working with agricultural robots so the
modules here I actually in the belts so
that's the so you have these this robot
here which make by Cox killer which is a
local company but in coloration with
University Southern Denmark has two of
these modules and we can use the same
modules the traction and battery and
control which is in each of them for
different kinds of implements so we have
a
again every use of physical pieces and
we can also be used a lot of the
programming we're looking into
domain-specific languages for expressing
safety concerns because these machines i
mean this is like half a ton so you
don't want to get run over by it
software is programming in the thing
called Russ robot operating system so i
just want to mention quickly because if
you want to hack your own robots might
be a good place to look and this is not
the official story but to me Russ is
like the JavaScript of robotics I mean
people who know how to do these things
probably hate it because oh this is
terrible but very easy to quickly put a
lot of things together so be careful and
we also saw one of the key words on the
track for drones unmanned aerial systems
I just want to mention that we're doing
a bit of work there but it's interesting
it's very difficult very different from
what we've been seeing so far so we're
looking at civilian applications
environmental monitoring agriculture and
other things but that's actually lot of
interest from society in working with us
on this because all of a sudden we have
robots unlike the robots are surely sofa
which tends to stay put drones tend to
fly out into the real world and that
makes things more complicated so we're
working with the Danish Transport
Authority traffic authority on license
plates for drones so you want the police
would like to know where is that drone
right up there in the air from do you
want to hold off a tablet like this if
it's unlicensed and of course it's
illegal just like normal license plates
we have a local airport so Universal in
Denmark is a torrent and as a an airport
there that was basically close to
closing down because they had a shadow
flight like a couple of times a week or
whatever which is not very much fun
airport so now they've converted the
airport into a test center for drones
it's actually nice you can have a couple
of square kilometers of airspace you can
close off and test so we have a drone
lab there that's being it's actually so
far has been very useful and
been flying things and crashing them and
it's a good it's a good place to crash
things and like OCD or whatever and all
kinds of other things that we are
picking up as well a last thing so many
of the robots that I showed before what
kind of heavy the same building kit idea
also works for lightweight
energy-efficient robots so of course the
heavier the more massive the robot the
my energy uses which is bad so here this
is a building kit for building
completely different kinds of robots
that are more springy flexible and much
more lightweight and that orders of
magnitude more energy efficient then the
other kinds of robots you've been seeing
and the building key idea here works for
being able to experiment with it quickly
so again we see the same principles
building kit different kinds of parts
being put together occurring again and
again so even though the a chance that
showed before don't really do anything
useful we're seeing it trace often in
many places so finally robots I talked
about talked about physical modularity
how it enables an incredible amount of
flexibility that's this cognitive gap
which is actually two ways so robots
have a hard time relating to the world
because they don't have limited senses
that makes them how to program and we
have a hard time dealing with how to
program these things and we need to do
some more work there and they're coming
they're becoming more more useful but
they need your help we need good
software for the robots otherwise it's
going to be a disaster dsl's to me
they're the ultimate abstraction
mechanism I love them but it's not magic
to get there are abstractions to really
get some punch in the language it still
needs to magic inside I don't know how
to I don't maybe I don't think we can
systematize that but we can make it
easier to do good languages and not
weird languages like well some of the
windows that out there and this
concludes my talk and remember the right
decision thanks
okay I think we have time for one
question or maybe two and one is how did
you decide the shape for the each one
robot vacuum that's a very good question
so i have to say that this is actually
before I joined universities so I'm
talking about other people's work here I
just did the programming but there were
actually it's actually there were we do
a lot of biologically inspired robotics
and so the inspiration for the agent was
a cell which was one reason for the
round a combined with a crystalline
structure so you want something that can
fit into a grid and something that can
move easily around in the structure
without bumping into other parts and
spheres actually really good for that so
and unlike many of the other module
robust that we saw one at the end eh one
is that it's okay that one module by
itself can't do anything useful in this
case it could just rotate in the middle
it can't move or do anything by itself
but then when you put many of them
together they can do something together
okay one more exeter to about
communication what is the plan for
scaling communications painting
bottlenecks and so so that's very good
question and so a in the white that i
showed you with the eight runs it
actually it's highly scalable and we've
shown that also both with some larger
physical experiments and some really big
similar experiments or scalable in sense
that if you only communicating a limited
amount of emotion that information is
communicated continuously neighbor to
neighbor all the time no matter whether
anything new happens enough so this
makes the system very predictable almost
well it's not actually real-time
preserves like something just clicking
on communicating information and so long
as the information want to communicate
fits into that then we find and then we
could schedule different packets of
information may be randomly or whatever
to be communicated at different times
scaling up beyond that that's actually
some of the work I didn't show you we
have a notion of scopes of in
formation so here we're talking about a
scope that's physically delimited so
maybe one innocent robot knows
information that's limited to that
physical scope and another part of robot
has a different physical scope and
certainly piece of information only gets
communicated there but this is where it
gets really hairy and we did have we
actually so what happened with the h and
robots is a color of years ago we ran
out of funding and then we did a lot of
experiments and broke all of the robots
and so right now unless we get more
funding da Tron's i sort of lying there
and we're not doing more experiments
with them right now whereas a some of
the other robust i showed you are easier
to get funding for to work with robotics
is kind of expensive to keep it going so
we have those distributors code
certified on earth while described in
nice academic papers and simulations and
a little bit of physical experiments but
I mean to me it a motivating motivation
was always to make the physical robots
that are saying that in front of me do
something new that they couldn't do
before because i programmed them better
and that motivation is not there at the
moment because the while they all did
because we use them too much but I well
if I sometimes we get more funding they
will pick up on these experiments so to
answer the question self good headway
physically local scopes so bringing
space more into the picture that's it
thank you like alright thanks
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>