<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • CoreData in 2015 and Magical Record meets Swift • Saul Mora | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • CoreData in 2015 and Magical Record meets Swift • Saul Mora - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • CoreData in 2015 and Magical Record meets Swift • Saul Mora</b></h2><h5 class="post__date">2015-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1jSuXbeIKuk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we're gonna talk about core data
magic record and swiftie stuff today
reminder before we get going to go ahead
and download the app review the session
and all that stuff so I was gonna say
also if you're not familiar with me I'm
Sol Mora you might know me from a
podcast called Dennis brief it's pretty
cool the kids like it
talk about cool developer II stuff with
developer friends from around the world
so I've got lots of European people on
there so you might like to hear what
they have to say I also work at a place
called lounge buddy out in the small
start-up in San Francisco so just so you
know you can download that app if you
travel a lot and go do some stuff with
that so what we're going to talk about
today data data is the heart of your app
or if you will the core data is is this
silent workhorse if you have these these
these nice apps and there's all this
stuff going on behind the scenes and
this is a real live shot of overnight
app in work but we've got you know we've
got these mobile devices they're really
handy they're really personal and
they're really flashy and the users kind
of don't realize that the data is is
super important so they don't realize
that data is what makes our app super
useful super functional and it's the
reason why people come back and use
their apps all right so how do we tie
the data to the UI all right so we've
got a framework called core data which
is hopefully you're aware of that and
the thing is we've got these these apps
and he's like I said these things are
nothing without data so you've got a
nice app it's got all this information
on here I'm just kind of I didn't go
through the exercise of scraping the the
the numbers off of here but if there was
no data here well would this hat be it
would be pretty useless and be just a
bunch of pixels all over the place
there's no information the information
is really what you're use what you're
looking for the fact that you have the
pixels and the presentation and all the
graphics in the UI help you consume the
data but if
without the data your app is nothing so
again we've got the this framework that
we need to actually get our data into
the app and into the users interface
here so core data you like my my
pictures there you can get that one it's
pretty easy reference right I thought
the the nerd crowd would get that so
some of you might be familiar with the
something called an ORM object
relational mapper I was kind of thinking
that this would be more of an enterprise
focused crowd and that's definitely one
of the technologies that I know
enterprises use a lot things like I
think it hibernates
I think back in the day when I did net
it was an hibernate what's the big deal
stuff like that the problem with RMS is
there are generally leaky abstractions
so things like having sequel queries
embedded in your actual app code is
generally the one big problem that we
have with ORM s just the fact that you
kind of have this idea that your your
client code knows about all how the
database works and is structured and
everything is it's kind of bad because
then you can do secret things in this
one place but then this other place
doesn't know that secret trick so then
you try to access the same data and it
doesn't do it the right way so you kind
of run into some problems by by having
those abstractions be leaky now core
data is it's a little bit different it's
actually an object graph persistence
framework so you're actually dealing
with an a graph of objects and they just
happen to save to disk or some
persistence mechanism now our previous
session had mentioned an in-memory
format now that's certainly one place
that it could go you could also write
your own custom format or you could use
something like a JSON or plist you could
actually write an atomic store that
stores all of your data to a P list if
you need to debug debug in quotes
they're some of your data you can do it
to an XML for an XML file I wouldn't use
that in your regular app so it's really
slow but anyhow let's just go over core
data and some of the objects that we
have real quick first of all this start
off with our NS persistent store like I
was just saying
could have any type of format that you
need JSON if you wanted to do JSON you'd
have to write this yourself but you
could but you have that flexibility to
do that and the persistence store is an
object in your stack think of it as the
bottom of your stack this is where all
the data goes once you actually save it
to disk so next up is our persistence
store coordinator so the coordinator
helps manage traffic between some of the
upper layers we'll talk about a second
and the persistence store so this just
kind of says here's an object where does
it need to save and it saves it in the
proper store and it kind of does a lot
of that work for you so it's kind of a
traffic cop for your data between the
upper and lower levels the next thing
that we've got in our core data tour
here is the ns-managed object model if
you're familiar with databases you can
think of this as your schema this
describes what your data looks like how
you know what entities are are what
properties they have how how each entity
is related to each other whether an
entity has a super entity or not this
this managed object model also has
things like fetch requests that you can
have pre-canned you can have some
different configurations but this
basically gives you a nice overview of
what your data looks like and it's
really nice because what we also have is
a tool that is basically a visual
modeler what what's nice about is that
you can actually see all of the objects
in your application and actually
visualize the relationships and
hierarchy so what I like to do is have
all of my kind of my my domain objects
into this in this visual editor just get
them basically I have a map of what what
I'm trying to to work with so next on
the the list here is the ns-managed
object context so the best analogy for
this is basically a scratch pad so what
you'll be doing late most often with
core data is you'll be using the
ns-managed object context with tons of
NS imagine manage objects right so an
object is going to I guess be related to
a context
in a way that one instance kind of
relates to one one instance of an object
relates to one instance of a context
alright so if you have multiple contexts
and you have multiple objects those
objects are not going to belong to two
different contexts right so context is a
place where you can say I need to save
this thing of this I need to write this
ping as a piece of data and it's only
gonna write it in that context if you
have another context which we'll talk
about shortly and you have the same
piece of data it's not gonna be the same
actual row right so this is where this
this whole flow of traffic gets down it
gets a little complicated and that's
where you have something like a
coordinator to manage who writes to the
actual store and who wins and how to
merge these things there's a lot of
moving pieces in a core data stack all
right so we've got these relationships
here so this is a really high-level
overview not very not in-depth I'm
hoping most of you already know a lot of
the things about core data and about
these objects but what I wanted to get
to was maybe some of the code this is a
very simple simple way to create a
person object for use in your code this
is kind of the raw raw way to do it
so what you do is you get the entity
description so the NS entity description
is an object that is stored in your
manage object model that describes what
that object looks like in the model
right so this is saying I haven't I have
a class the entity description so create
me an instance of a person in this case
that's a lot of code to just say person
alloc init or person new right that's a
lot of code for that seems kind of nutty
here's how we would find what are we
finding in here
I forgot I think we're finding employees
yeah it's it's it got it got moved a
little bit but yeah we're finding
employees in this example what we're
doing is we're searching for employees
we are setting a sort order and we're
actually doing a little bit of a filter
just as an example for a predicate and
then we're also sorting things and then
we have a fetch request and we send it
off and then in case we have errors we
also have to handle the errors every
time that's a lot of code
it's a lot of very error-prone messy
code alright so and if we wanted to save
stuff well we have to use perform block
now so in kind of the pre I think iOS 7
days before iOS 7 you didn't have to use
perform block you could get away with it
without using it especially since it's a
newer API but nowadays you have to use
perform block or perform block and wait
and if you're going to do anything with
with any object data you want to do that
here and to save data you're going to
take your data and you're gonna have
another context and you're gonna do it
on on this MOC MOC object here and you
have to make sure that you load the
object that you want to save into that
context that you're performing the Block
in to modify the changes inside that
block and then do your perform saves
inside the perform block call this is
very complicated I'm not even saying
this correctly to make you understand I
know this this is here to kind of show
you just how I guess difficult some of
these core data API czar because it's
not really intuitive as to when you need
to use what right just the fact that I
said this perform block is something
that you need to use all the time just
kind of adds to the confusion I think
because I don't see a whole lot of
people using that so this is the entity
modeler this is really nice the other
thing about this thing is that when you
create a new entity in your model here
all right so when you do this you'll go
up to file and I think you'll say one of
the menus and say create new entity from
the model right so you'll pick the
entity that it relates to you say say I
wanted to create the new github event
class code so I could tie that code to
this entity and then it'll Xcode will
generate you a class file well when you
change this entity here like adding a
new attribute or change the type or
change the relationship or anything like
that you have to manually go and update
that code that you just edited in Xcode
you're created in Xcode and if you go
and update it through Xcode it will go
into lead all
previous changes so that was kind of not
cool so all of these things for as cool
as core data is it's like why what what
a big pain in the butt so one of the
solutions to one of the problems is
called mo generator so that last problem
that I talked about where we have
something that you have the code tied to
the way that your entity is described in
that managed object model those things
together that is solved using this tool
called mo generator and it uses
something called the generation gap
pattern and the generation gap pattern
is really really simple
you basically have a base class a very
common base class and you have a sub
class that's generated off of that base
class so in our case with ns-managed
objects right so the manege ns-managed
object will be our base class and mode
generator will automatically generate
and regenerate based on the schema the
end of the managed object model it'll
regenerate all the properties all the
attributes all the things that you need
enable to be able to interact with core
data on a code basis much easier so
it'll generate that all of that
boilerplate code for you and it'll
update it every time and then what you
do in that in that case is then use your
own hand coded subclass off of the
generated class so this is that
generation gap so the between instead of
having ns-managed object and then
directly subclassing that you have the
generated code in the middle and that
that gets you by a lot of stuff and
that's a super handy tool I use it all
the time definitely open source can go
get that on github and the way that I
use it is I actually have it in as part
of my Xcode build step so I've got a
little script there and when you get the
the notes from this talk there'll be a
link to this script that I have and I
basically what I do is I have this
regenerate core data entities this code
that will go and rebuild and regenerate
all of those generated files and I'll
make sure I do that before the compile
sources step in my prod
in that way every time I do command-v or
you know commander are to run I've got
my entities all up-to-date based on
what's configured in my core data model
automatically there's there's no more
thinking of that it's just I change it
and it's done automatic stuff like that
is super handy so you can grab this
script I update this often enough when I
figure out how to do more scripting
Shelley stuff but it's very useful and I
recommend this as part of your build
step when you're using core data that
gets rid of a little bit more pain the
other thing to get rid of pain is
magical record this certainly has helped
me over the years and new in 3.0 we have
some more fun stuff so one of the fun
things in magical record is now we have
things called stacks so we have a whole
object to kind of collect all of those
different objects right so one of the
things is coordinated which is kind of
weird is that you have four different
objects that you have to use in order to
just access a file right so when it
comes down to it you're just trying to
get data and push it down into a file on
disk so this is really like a file
interface format right and you have all
of these different objects to kind of do
all these different things and it's
overly complicated so what I've done is
kind of created this idea of a stack
that basically holds on to all of those
objects into one object that you can use
with an easier interface so that you
just do the things that you need to do
and the stack will kind of figure out
all of the details in between to do them
to do them in the manner that is most
efficient based on the type of stack
that you've chosen right and so in this
case this is a very simple stack a
sequel light magical record stack all it
does is it has one persistent store one
coordinator one model one context done
it's very very simple one of each and
all you get is the context you save data
to the stack and it'll figure it out and
to turn it on you just say hey I need a
new sequel Lite stack if you want to
tell it a particular store file name
because you don't like the default one
just give it a parameter it's a very
simple thing like you already know what
you want to do you don't need to go
through the
the exercise of redoing all of that
coordinated code especially the sample
code that Apple gives you in their
templates horrible don't use it please
so we looked at this example a little
bit earlier with fetching if we look at
some of the stuff that was what we were
actually looking for we can actually
boil it down to something like this with
magical record so all we need to do is
let me see this was kind of going a
little bit slow maybe I'll go back here
all right here we go so what I wanted to
point out here was like out of all of
this code the only things that were
actually like really important we're
like the class name and the predicate
and how we're sorting right all of that
other stuff should just be automatic or
refactored into some kind of helper
method and that's what we were actually
trying to do with magical record so
we're actually just trying to say have a
simple way to get the data have a
function or a method that will do that
and just a really nice way to kind of
read the code and just see that you're
actually just fetching data without
having to worry about all of the details
error handling any logging how to format
the fetch request you really don't care
all you want is the data and this lets
you access the data with a really simple
API so if we wanted to save data this
one this one I think is like the the
really awesome part of magic record if
we want to save data we had to do a
whole lot of stuff we had to create
another managed object context if we
wanted to have multiple context which is
very common we have to figure out how to
merge that I have to set how to set it
up especially in the old days before our
nested context scenario with core data
we had to use and it's Notification
Center to listen for the notification
and observe and merge and do all this
all of this stuff that you just didn't
want to deal with and all I wanted was I
just want to save data as like as simple
as that and if I have to save data I
have to do it through a context on
occasion so I made this API that says
hey save with block and here's the
context that you write all your data to
basically says here's where you're going
to save your changes to I will create it
for you I will save it for you and I
will also draw the merging
we'll handle all the errors everything
is already handled it's just a really
simple API that you can focus on your
data right and what's nice is you can
also have a completion handler so when
you know that
so when magical record knows that the
competitive safe has finally completed
that step is done
everything's persisted on disk then
you'll get a completion block and you
can kind of do some stuff there I have
seen this API misuse however which I
guess any API can be misused but it's
definitely has had some good intentions
here and it's been very useful so
there's a lot of good ways that you can
use this API so the thing about core
data and like like I said it's just this
all later it boils down to core data
being a simple API or an API that lets
you save changes to a file on disk so
why do we need all of these objects and
all this configuration all this
complication when something like maybe
NS coder could do or a plist format
would do right well the thing is is like
this handles a lot of it handles objects
directly and you don't have to you have
various performance characteristics and
various flexibilities with your
architecture they solve different
problems for different things and your
in your app yeah you had a question
yeah it'sit's a well being an object
graph for systems framework I mean it's
it's about serializing and the
serialization happens in the ns-managed
object itself so so yeah so yeah it's
definitely a serialization framework and
NS coder plist they're all different
types of serialization within the cocoa
framework itself so I guess the point is
I'm trying to say is like we have these
four objects why do we need for objects
why do we need these four classes right
so in certain cases you're gonna
actually need a second managed object
context especially now because core data
is going to actually try to manage the
threading for you so what what will
typically be the case is you'll have
like one of these contexts be them on
the main thread and the other one be on
the private private queue or basically a
background context
so a lot of times you'll do your changes
and you'll save them on the background
cue and get some updates on the main cue
thread right so you'll have two
different ones and if you have them in
isolation you could say save this one
and then notify the other one and merge
those changes separately so this second
context mode is very common this is this
is kind of the preferred way to use core
data in general but there's also the
case well you'll need maybe multiple
stores and why would you need multiple
stores well think of having different
Word documents or not word pages
documents open right so you have
different files different instances of
files on disk and you have them all
connected to the same coordinator now in
your application it doesn't really care
which file is every object belongs to
that's the job of the coordinator the
coordinator knows hey here's an object
and it's going to be saved well pick you
know persistent store B or here's
another object person you know pick the
other persistence or C it knows how to
do that that's what that's what that
coordinator does it's the traffic cop so
it knows that that it knows which file
the object should go into the data
should go into but from your abs
perspective it doesn't really care it
just says hey I have some data it came
from somewhere core data can deal with
that and you don't have to deal with any
of that so it's kind of nice so another
another scenario is that if you really
need to save like a whole bunch of data
really really fast there are scenarios
we have high throughput you basically
say I'm importing a bunch of data and
I'm gonna do it at you know the store
level I'm going to do the file locking
at the lowest level possible which
basically is on disk or at the operating
system level right so in a lot of cases
you're gonna actually share this
persistent store and you're gonna have
two parallel stacks all the way up right
so this is a this is a case where you're
importing tons and tons of data and this
may be more common on a Mac but
certainly you could do this on iPhone as
well but you're going to import a lot of
data and you want to be as fast as
possible so that means if you're doing
in a multi processing or a
multi-threading environment you want to
have as few locks as possible right
because
walk slow you down so to have a few
locks as possible you having a
completely separate person store
coordinator and they're gonna share the
same model so because the data is gonna
look exactly the same so again this is
some examples of how to do that in
magical record so we can set up a sequel
light stack by the defaults really easy
if we need an in-memory store let's just
how you would do it magical record super
awesome super easy because it's pretty
readable like I don't know about you but
like some of the options in core data
I've never never remember all the stupid
enumerations and and configuration
values so this this is usually a lot
easier for me I just changed the slide
if you didn't notice hey because it's so
subtle all right all you change is Auto
migrating stack you know and if you need
to do manual one it doesn't there and if
you need to set the store name or you
can set the path a URL you know when
you're trying to save data to a file all
you care about is maybe where that file
is located and what it's named and there
may be some performance details that you
care about at one point but after that
you don't care
all right you only care that you have
something to save to so it kind of takes
care of that for you again it's on it's
on github so out there open source for
free
ah for all you guys to grab it's pretty
popular with the kids these days so yeah
but anyhow we wanted to talk about Swift
and kind of maybe going forward a little
bit so the thing about magical record
and maybe you've noticed this is like I
you know we talked we wanted to talk
about Swift but up until now all the
code has been in objective-c so
objective-c has definitely influenced
the design of magical record code base
and just the way that magical record
works it's very dynamic core data itself
is a very dynamic framework it's very
key value coding oriented if you notice
on when you're saving data when you want
to set data you set it using key value
coding type of methods you say object
set value for key right so you have that
that
same-same mechanism and it keeps it very
dynamic but with Swift it's not like
that Swift likes to be precompiled it
likes to know about all these properties
ahead of time right so how do we
reconcile that right and the the core
data engineers reconcile that by putting
a nice ns-managed at ns-managed keyword
in the language and swift so that it
could tell the compiler like this still
needs to be dynamic and its core data
specific and there's all these things
that it does for you under the covers
that we don't even know but all we have
to do is we have to tell the language
that this is a special property and it
has special special things that go on
under the covers that we don't need to
worry about but that just kind of shows
you that core data is is a different
beast when it comes to how it works with
Swift and Objective C as well so magical
record also took advantage of
objective-c just to just as the way it
works so a couple of things to note like
in this example here one of the things
that we had to do early on was add this
Mr underscore prefix to everything
alright so that prefix is a result of
Objective C in categories and what
happens when categories get redefined
and reloaded later on in the system
right so if you have two categories
named the exact same thing which one
gets loaded undefined
typically you might guess it's the last
one to be loaded which is what my
logical guess would be but that's still
undefined that's it could be that it
could be that it just picks a random
number and then picks whichever one it
likes it doesn't matter we don't know so
we had to use something like this that
basically said this is our namespace
these methods that have this prefix our
ours guaranteed if anybody over writes
them well you know they really messed up
so that's a consequence of you know a
bit of the objective-c language the
other thing that we could do here was
put stuff at class methods here now we
could still do that in in Swift but I
think an objective-c it's a little
easier to read this way with a class
method maybe it's a
a little more complicated and the other
thing is these name parameters
definitely influence the way that the
the API kind of was designed and the way
that we try to label things and flow and
kind of more classic you know API design
elements but if we were to convert it to
swift some things would read really
really weird so if we have that Mr
underscore that doesn't really fit with
the Swift language so you know we don't
want that to carry over the other thing
is that magical record code base is
pretty large it is quite large I was
surprised at how large this code base is
I've always said that magical record is
a framework and a collection of core
data related methods and helper methods
is that you could write on your own I've
just collected them all for you and put
them in one bundle and I just didn't
know how large that framework was until
I went looked I guess what's also in
there is a nice import library that
we'll go over really soon here there's
also a bunch of logging and stuff
there's a bunch of just helper methods
the stacks thing is really useful
there's a lot of stuff in there just to
make your life easier and make my life
easier too so you know when it comes to
deciding how to move forward I have to
take into account that not only is this
code base kind of large now it's pretty
stable for the most part any crashes are
just a result of user error for the most
part so I really don't want to rock the
boat and rewrite everything just because
everything's in Swift right so I've got
to take this into account the other
thing that I noticed is that Swift moves
pretty fast you see it there it was
pretty fast you miss it
Swift is pretty fast so on the timeline
here let's let's look at take a look at
some history here Swift was first
announced just last year and let's kind
of walk through that timeline here so
1.0 was about October 2nd that in turn
do
failable initializers oh my gosh can you
believe that wasn't at launch 1.1 over
1.2 was on February 9th 2015 that
introduced the as bang it introduced
compound if let statements so the if let
comma if let comma or comment if let
become let whatever I'd also introduced
what else if you have here it introduced
Objective C improvements so that you
could mark them as null or non null so
that they would actually convert over
and a swift properly right so that was
only February this is almost 3-4 months
cadence and then we got a big drop in
June and you know how that was all right
with the guard statements and the
protocol extensions and all those fun
things I mean in one year like I you
know I was still trying to learn Swift
as a functional language and in one year
it just changed a whole bunch of stuff
on me so the hard thing about converting
something that kind of works and a lot
of people's apps rely on this code base
like magical record is something that
isn't a lot of apps or code and to kind
of change that and this fast is really
hard so I really don't want to you know
basically I'd want to make less work for
myself and not have everybody come yell
at me like hey you change this API what
you do you know I'm trying to not not do
all that kind of work but still you know
keep things moving forward oh and I
forgot we've also had betas in between
that broke a lot of stuff so you know
you're never gonna win because this
thing is just going so so fast you have
to be kind of you have it sometimes it
is better to wait when it comes to some
of the Apple API s and core data is one
of those things that it doesn't feel
like apples going to really rock the
boat on API why is it feels like core
data's gonna be pretty much on its same
trajectory for a long time to come
so I really don't feel like I need to go
at this pace or magic worker needs to go
at this pace to kind of keep up with
stuff but doesn't mean that it's not not
good to kind of keep going one of the
other things with Swift was that
less dynamic and this was kind of
actually one of my one of the kind of
things I had a hard time dealing with in
the beginning was Swift
it's like how do I not use this language
that isn't dynamic because dynamic
languages are really cool I mean once I
figured out how to hack the ejector seat
runtime and you know you know intercept
messages and changes proxy objects and
you know just all that fun stuff you
know come you know writing to selector
you know writing my own selectors and
and doing that kind of stuff it was hard
to give that up so and let's let's see
how it's actually used in magical record
to be really really useful for one this
is the secret sauce and magical record
this is how it figures out what entity
to look up and how to map that entity
description to the entity class it's
really simple now what it also does is
it gives you an opportunity to override
that entity name yourself and this is
how it worked with no generator so
magical record has worked with mo
generator from the beginning because of
this secret sauce because mo generator
already implements this method so I'm
just using what mo generator already
does and if I need to change it I can
just change it in a subclass in my own
custom entity and it's works I define
the mapping where it's supposed to be in
the object and the class and the code
that it's related to but this is the
secret sauce this is dynamic it's very
useful this is very hard this is I could
to probably do this in a in a protocol
so maybe that's not the best best
example so let's move on to the next one
this is nice
remember that data importing I talked
about so should will and did import our
methods that are called back on the
calling classes when we do data imports
all right so a should import obviously
gives you an opportunity to bail out of
importing data that might be bad right
and then before and after just tells you
hey here's some data it was done right
now this is also implemented in a
protocol so maybe this isn't this isn't
really that good of an example either so
let's talk about this one what does this
one do
so this one's a little more ugly only
because I have to do things in the kind
of approved objective-c way so remember
before we could just do objects perform
selector with object and just use those
kinds of methods a long time ago maybe
around Xcode or ish I don't remember
there's a couple of years ago Apple had
said don't use the perform selector
methods use an invocation instead
because invocation does is it checks all
of your arguments checks all of your
selectors and things like that doesn't
more checking for you which is what they
want to do to help you so hence we have
the bottom I don't know the bottom third
of this is really kind of boilerplate
stuff just to be able to send off that
method but the top three lines are
really are the top two lines they are
really important in this method so we
have in the red that says import some
string with a colon so it's creating a
selector how are we creating the
selector from while we're creating the
selector from the key all right so what
we're actually doing in this method we
are importing a value for a particular
key so for one attribute on an entity
right we're going to say here's some
data import it into that attribute on an
entity and so what happens is we're
going to create a selector that says
import capital attribute name and we're
gonna create this selector dynamically I
cannot define this in a protocol this is
a convention based interface right it's
a convention based API so it lets me
write client code like this that lets me
define custom import logic on a property
by property basis or an attribute
attribute basis and my entities and I
have this all over the place and it's
useful and it doesn't it means that I
don't have to clutter up code all over
the place it says well here's all of my
custom import logic it's this giant
messy function it's just well here's my
the majority of my import routine and
this one special property needs it now
if I don't implement in this case import
name it's not going to be called
right it had it if responds to selector
check beforehand but this is the power
of dynamic programming and this is where
it's kind of hard to not have that
sometimes sometimes dynamic programming
like this is the right tool in your
toolbox right coding by convention is
actually useful so some of the other
things that kind of helped me back I
guess a little bit from jumping into the
Swift Boat thing really fast is or the
framework so sugar record is another
framework out there that was written and
swift early on I kind of ran across this
early they they're their big thing is
that they do multiple file formats so
they do core data and I think they do
realm and they have other things that
they work on as well and it's a very
similar interface so I thought oh great
you know these guys kind of they even
mentioned like hey they took inspiration
for magic record and had a lot of their
interface to define the same way so look
great you know maybe they they solved it
for me so I can just focus on the
objective-c stuff but I think there's
still room for magical record to have
some Swift inside of itself one of the
other things that I was born looking for
was I saw something called query kit so
query kit is if you've ever seen back in
the old days man I'm really dating
myself here back in the old days when I
worked on on Microsoft code one guy in
the audience right there was a
technology called link to sequel alright
so that lets you write sequel code
inside of your c-sharp code I did write
c-sharp code back in the day and query
kit reminds me a lot of that it's
basically a kind of a sequel
domain-specific language written in
Swift it's interesting it's it's an
interesting project and it kind of gave
me some ideas maybe I should kind of
venture down that way as far as how to
incorporate Swift into a magical record
but if you're curious definitely you can
take a look at that so but the one thing
that I wanted to not do was I did not
want to rewrite the entire code base
that was kind of my big thing like I
said the code base was huge so I decided
not to
and I still am able to get some Swift in
there again being pragmatic about things
not throwing away code that works just
because I have the new hotness in my
hands the other thing that really made
me want to not rewrite the code base was
when they announced Swift when Apple
announced Swift back in 2014 they made a
big deal about the interoperability
rights Swift and objective-c they're
built on the same runtime there's just
different optimizations made for Swift
versus objective-c based on the nature
of a statically linked language
dynamically bound language right so but
there's still a lot interoperability
right you can have Objective C code and
right you know have it called from Swift
and vice versa so they can talk to each
other there's no problem with that that
isn't the issue I don't need to throw
away objective-c code I can still build
more stuff going forward but there's one
problem and only recently has this been
fixed is if I have an API like this by
default right now what you would see is
you see all these crash operators so the
bang I like somebody had given that
given at that name the crash operator so
this this explicit implicitly unwrapped
object type kind of indicates that
there's a problem with with your type
setting there right so you don't know
whether it's nil or not you still have
to check if it's nil so that's a problem
and the way to fix that is with this guy
right here so if you have some code you
can just really do it on a basically an
entire file basis just basically say hey
assume all of the code in between these
things is not nil all the parameters all
the return values all this stuff is not
nil and it's super awesome you can do
stuff like this and the way that I've
been able to use it which is super
useful if I do want something to be nil
I can just say assume not nil and then
just say hey this is the this is the one
that you can say hey this is Noble this
one this one I'll allow this one right
so this gives me the right weight
basically what this does is it lets
the Swift interpreter and the compiler
convert the header information correctly
so now we end up with something without
all of the crash operators all over the
place and this helps us integrate with
Swift a lot better and a lot more
cleanly and also let's lift help you so
if you do end up giving it an optional
parameter when I really meant not to
have an optional but if I had the crush
operators I could its lift couldn't tell
it couldn't help me so this is trying to
let Swift help me help you something
like that all right so so ultimately
what I'm going to be doing is using
Swift extensions and using those to kind
of carry this forward now the benefit of
this is that what I can do is maintain
the objective-c code and the swift code
and I can just have the Swift code
almost literally call into the into the
objective-c code so basically it's just
one more level and that that could cause
its own problems later on but a lot of
times what I really want to focus on is
making the API super simple so we have
you know we have category friction
pieces prefixes and we don't need those
anymore
so this is kind of what I was thinking
with a magic record and Swift and
integration and going forward all right
there's a lot of stuff in there so let's
unpack that a little bit so we have
generics right so we have a generic find
function and then we have this really
weird function signature all right so
what I've decided to do there is use one
of the neat little features of Swift
called currying all right so currying
lets me create a partial function so
partially apply a function so basically
the the mental model that I have in my
head is if you have a whole lot of if
let's if you have an if let's and you
need to kind of have that pyramid of
doom the currying lets you get rid of
that in certain cases so basically what
I can do is I can have a partial
function and say Oh find me this type
and then just return
that function and what I have after that
is a function that will take a predicate
in order by ascending as parameters so
basically I have to call this function
twice now that's kind of weird like why
would I do that
well it's handy and like the full lot of
the functional kinds of concepts but
what it also lets me do is in the bottom
case what we have here is we can say I'm
going to set the context for this
function first and then all the calls
after that are going to use that context
so I don't have to worry about the
context anymore all right so you can
kind of specify that and you know I've
also done that up here in the top one
having the context already specified for
you and it's it's it's a crazy idea but
it lets you do some of the lets you some
functional characteristics so Swift and
it it also just it uses the generics so
but I think a lot of the big important
thing is that two of the important
things is we're using the old-school
objective-c magical record and then the
new syntax actually will read a little
bit better going forward as far as how
you use it in your Swift code and using
generics we can do some type checking
and type converting and do that all
inside of the magical record stuff
whereas you in your client code just
gets all of the help that the Swift
compiler will give you because it's
using a generic function versus the any
object kind of thing that the the
objective-c converted Swift headers give
you right because if you have this find
all sorted by method it returns an array
of any object because that's an array of
IDs right in Objective C they can't tell
you what exactly that type is but we can
kind of force it using the as question
mark operator and if we don't succeed
well we can just say well it failed and
this we got no results because we didn't
do that right so we can do this without
crashing and still have results and
still do all that stuff so that's kind
of the way that I was thinking and if if
we want to use this in our client code
so one
scenario that I had thought of was that
we could have our stack and again we
could specify the context in our first
call and now we have a find function and
if we want to limit the scope of our
calls to just in this case books we can
create a new function from the first
find function that says find these books
all right so it finds the books in the
context and then now we can say find
books where the title is valid with
everything else so then we can just
apply that function as normal so this is
how you would use that API this has some
different characteristics and it is
differently different but I think being
able to separate these steps out is as a
really important way to kind of move
forward and move forward with the way to
use magic record with Swift and to have
it feel like it's part of the Swift
language versus something that I just
poured it over from objective-c so using
some of the same same ideas we can just
kind of shorten the block syntax and do
some really simple save it's really
should be really familiar it's not that
complicated so that's about all for
Swift and yeah so we have a whole lot of
examples actually in this book that I
helped co-write core data by tutorials
it's all written in Swift it it has a
lot of stuff with threading and it's the
only book that I know of on core data
that covers migrations as well so
definitely if you wanted to see more
core data just raw core data with Swift
examples there's definitely a lot there
but anyway you can also get some more
iOS tutorials books but anyhow I think
it's my time and be sure to rate the
session thank you
so the question is what's the story on
core data and iCloud synchronization I
don't think really much has changed
since iOS 8 really I think it's just
gotten more stable but it's I think it's
it's usable but I think it's I don't
think much has changed
we do have a section on that in the book
and it walks you through that but as far
as I mean is there a more specific
something more specific to that question
so the last thing that I know of was
that core data and iCloud is usable it's
a little easier to set up and if it does
fail you can recover from it now and you
can reset things so as far as I know
it's it's usable so the question was
didn't they change the Xcode core data
entity generator but Moe generator has
always been my go-to tool and it Moe
generator also gives you some extra
accessors as well so there are api's in
core data that are very dynamic so one
of the API is in core data is set
primitive value for key and that's a
very generic dynamic function and it
turns out if you just define the
function set attribute name for key like
an actual just the header you don't have
to actually define the function if you
just define the head or core data it
will create that function for you and it
will be more efficient than the generic
dynamic function right so and Moe
generator will generate all of those
headers for you so there are definitely
some benefits to using Moe generator
that you don't get you also have an
enumeration that Moe generator will
generate for you of all the properties
for an entity so if you have an entity
and you have a list of attributes it has
an enumeration with all of the
attributes in it all right so it so you
can use compiler checked enumerations to
see if you've actually reused the same
property right
basically you have a tool that will
generate a map from compiled code to
just raw string values which coordinator
needs in order to look things up so
that's definitely a benefit so let's I
still use mo generator anyway even if
even if they've Xcode has been updated
to not like have some of the problems
they had before there's still enough
benefit with mo generator to use it even
even now so actually the the question is
with with Swift being more of a focus on
value types versus reference types being
the classical Objective C model going
forward do you think you should focus on
using the the value types instead of
core data and I actually I'm doing that
at launch buddy these days so we're
converting over a project to Swift 2 and
we're using core data and what I've
actually done is I will store all of the
data into core data so it'll import it
store it in there and basically it's got
an interface for all of the the data
that's available from the kind of the
data side of things and it will actually
convert all of the core data objects
into Struck's
and value types the the difference being
is that we actually have a protocol that
defines what the data looks like so
basically in a in a managed object model
to find in protocols and by having this
protocol and having a defined for data
what we can do on the other side of the
client is we convened it whatever
implementation we want we just tell it
that it implements the protocol so all
of the client depends on is the data
protocol the data that we give it can
either be core data it could be some
dictionary that it conforms to the
protocol somehow it could be a struct
right so it could be any one of those
things but as long as they conform to
the protocol the client code doesn't
really care so what I've done is you
know have all of my asynchronous data
management saving things on multiple
threads and do all that crazy
concurrency that have to do with core
data kind of in the background away from
kind of the
you eye client and before it gets to the
UI client it will actually vent out a
copy of the core data object and
converted over to a struct object so
basically just copy all those values
into a struct so now it's a value type
and then just give that to the client so
you can kind of mix and match it's
whether or not you're willing to accept
the trade-off of doing all of that data
copying and transformation so you know I
think they're still valuing both I mean
I could still have just vended out the
straight and core data object have it
conform to the protocol and still be
usable the problem there is that core
data really doesn't like it when you
cross the threads across the streams
when it comes to threading and that also
means that even when you're accessing
data you can sometimes crash because you
access the object on the wrong thread or
the wrong queue so that could be a
problem so I decided to just do that all
the thread management on my own and then
just vend out a read-only object that
really doesn't care so that that
hopefully eliminates a lot of those
particular problems any other questions
I don't think you can do that so core
data is a single process framework so
you really can't share the same instance
of core data you can share maybe like
the persistence tour but then you're
going to be blocked by the process of
the operating system so the operating
system still has to lock the sequel live
file alright so when you access things
and the problem with that also is that
if you're right from one process you
know how do you update the other one how
does that know that's kind of bad too so
that's why you know you really just want
to have like one process for profile at
a time but yeah but yeah the question
was what do you think about multiple
instances multiple processes accessing
the same accessing core data so yeah
it's a little little complicated there I
try to keep it simple though yeah any
other questions cool well thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>