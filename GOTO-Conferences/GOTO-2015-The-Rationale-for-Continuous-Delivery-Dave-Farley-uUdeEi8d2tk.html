<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • The Rationale for Continuous Delivery • Dave Farley | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • The Rationale for Continuous Delivery • Dave Farley - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • The Rationale for Continuous Delivery • Dave Farley</b></h2><h5 class="post__date">2016-02-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uUdeEi8d2tk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name's Dave folly this talk is
about the rationale for continuous
delivery I want to talk a little bit
about the reasons why why continue what
what continuous delivery is and the
reasons why it works and why we need it
so it's my argument that if you look at
the history of the software development
industry it's not very good we've not
been doing a great job the and that if
you look at the the analysis of software
projects over the years of all different
kinds that generally telling a fairly
dismal story of our ability as software
developers to satisfy the organization's
in which we work this this last one in
in kind of a macabre kind of way is
amusing in this in a large study of
large projects 17% of the project goes
so badly that they threaten the
existence of the company performing them
and that's kind of been the story of our
industry for for many decades and you
can take that stuff with it with with
kind of a pinch of salt you know that
these sorts of these sorts of surveys
are you know not always terribly
scientific we heard day before yesterday
about some surveys that you know you can
do more detailed more thorough
statistical analysis but a lot of these
things are just kind of people signing
up and giving giving answers and self
self describing their projects and that
kind of stuff sitting attack you with a
pinch of salt but even so I think that
what it's saying is that the state of
the software development industry has
been less than optimal to put it kindly
but I think that this kind of signs of
hope it's it's not perfect it's not it's
it's not ideal but we I think now for
possibly for the first time I think we
really know what works and that's a big
deal that's I think we have something
that generally works and we're starting
to get the data that backs up and
suggests that we're right so what have
we tried over the
years what-what-what approaches have we
looked at we've looked at other
industries and we've examined those and
kind of tried to learn from those and
picked up different techniques we've
looked at water for style techniques and
V models and siloed organizations and
slightly more iterative approaches with
lots of paperwork around them we've
looked at scrum extreme programming
hiring really smart people and putting
me in a corner hiring young smart people
and putting them in the corner because
they're cheaper and hiring young smart
people in foreign countries because
they're even cheaper and there's kind of
parts of those things like that kind of
we've learned from and have been useful
and there are parts that have not this
is this is a key side in Ireland I was
speaking at a conference in Ireland a
few months ago and I actually met a man
whose cousin is in this picture and
what's happened here is you can just see
there's a car falling off the edge of
the key so what do you do when the car
is falling off the edge of the kit you
gonna get yourself a crane so what do
you do now wait yeah you get a bigger
crane and yes the car is out now you got
to get the truck out but Albert Einstein
said that the definition of insanity is
doing the same thing over and over again
and expecting different results
so if if our software development
process has been less than optimal we
should try something different we should
try anything different and figure out
what really works what so let's start
from the beginning what is it that we
really really want what is it that every
organization that ever employs us really
wants what they really want is that they
want to have an idea they want to get
that idea in the form of high quality
working valuable software into the hands
of users and they want to figure out
what those users make of that idea and I
don't think that there's anybody that
can
even software that doesn't want that
that's kind of fundamental to what we do
so I'm gonna pose a question what's the
most successful invention in human
history
and here are some of my suggestions the
wheel that's a good one anything else
any other suggestions beer yeah I wasn't
quite sure what that supposed to be beer
or pretty girls but I think pretty girls
aren't really invented I would argue or
argue that we've without too much fear
of contradiction its science and by that
I don't mean the Large Hadron Collider
and space shuttles and space stations
and medicine those are the outputs of
science what I mean is the simple idea
of the scientific method the idea of in
fact here's a diff definition having a
hypothesis
looking at looking at a problem forming
a hypothesis to explain it figuring out
a way of testing that hypothesis
carrying out the test and seeing you
know evaluating the results seeing what
we make of it and and then iterating
repeating that has moved us so human
Humanity is in the order of about two
hundred thousand years old as a species
and science in the last two to three
hundred years science has moved us from
what is essentially an agrarian society
into the modern high-tech society that
we all living today and it's that they
as a direct result of this kind of
thinking in the age of enlightenment and
rationalizes rational thinking and all
those sort of things
that's what's moved us exponentially to
the level of understanding that we have
of our world and universe and our
ability to create all of these amazing
things that that we now rely on so what
works so what really works when we think
pulling this back to software
development process so if we want to
want to be a little little bit more
scientific about this let's look at some
more data and again and take it with a
pinch of salt it's these are kind of
self selecting people that are reporting
these things
but this is this is from the Kaos
manifesto which is published by the
Standish group and has been for many
many years and this is from the 2012
survey which is but still they're pretty
consistent with what the data that comes
up and on the whole what that's that
survey has said over years and years is
that waterfall tends to have quite a lot
of challenge challenge projects and
agile tends to do better but it's not
perfect we're still less than half of
projects are successful by that in the
terms of the people that practicing and
paying for them some people say that's
too depressing and and too pessimistic
and one of the people that says that
he's got Ambler and this is his date
he's in my organization of his data and
I've organized it with kind of iterative
approaches across the top and more more
traditional waterfall ish style
approaches across the bottom the thing
that made me that amused me a great deal
when I first saw this was that if you
make your development process of
on-the-spot it's slightly more effective
than if you use a traditional waterfall
processing that amused me when I first
saw that so the the iterative processes
are clearly doing better and if we
believe that the scientific method is an
important thing that repeats part of it
that feedback loop part of it explains
why that might be the lean stuff seems
to be doing particularly well here so
what's that about
so Lean Thinking is about delivering
things quickly we want to minimize the
amount of work that we have in process
and we want to you want to deliver
things as quickly as we can we want to
build high quality all the way through
and have quality as a key objective to
the work that we're doing we want to
optimize the whole process not just
looking at pieces of it and just and
just making this bit good we want to
look at the whole the thing holistically
and figure out how to make the whole
thing work better and we want to
eliminate waste and there are different
kinds of wastes so doing too much work
is a form of waste and will slow you
down and there's there's real hard
mathematics behind this stuff user the
queueing theory explains why if we if
we're doing too much work we can't cope
if we're task switching too much
queuing theory would just killing theory
alone can explain quite a lot of there
you want to amplify learning we want to
optimize our teams to learn rather than
to lit to deliver because that way the
team gets more and more efficient and so
as a second or direct come delivers more
and more stuff and we want to make
decisions late because if we leave
decision-making till late in the process
we're going to have the best information
to make the highest quality decisions if
we make decisions early in the process
then when there's more guesswork
involved and probably more patching up
later on when a guess is proved to be
wrong and we want to empower the team we
want to make sure that the team is able
to see the problem figure out how to
solve the problem carry out the solution
and see what whether that works or not
anything else he's putting too much
impedance in the way and and lengthening
our our ability to see what's really
going on so this this is kind of my
picture of what's really going on and
kind of funding I tend to think of
software development as a series of
interlocking feedback loops and I think
it's kind of a useful model if you look
at any piece of work that you do look
for the feedback loops how will I know
that what the outcome of this will be
how will I evaluate whether this was a
good thing or a bad thing
how will I evaluate whether this change
in my process was good
how will I value that this this change
in the code that I'm undertaking is good
and there that there are more feedback
loops involved in software development
than I'm showing here this is a simple
picture but this is an important picture
so at the outside there's that idea that
I talked about earlier the fundamental
idea of having having some idea in your
organization getting nothing to the
hands of your users and figuring out
whether it's a good idea or a bad idea
and then inside there's kind of the this
tight feedback loop of the classic TDD
cycle I'm going to write a test I'm
going to see it fail I'm going to write
some code to see it pass see it pass I'm
going to commit there I'm going to move
on to the next this is one of my you can
probably tell from the tone of my
presentation that I'm a bit of a popular
science nerd it's it's something I'm
interested in and this guy is one of my
abs
heroes does anybody know who this is
richard fineman right richard fineman
for those of you who haven't come across
mr. Feynman Richard Feynman was a
genuine genius of the first class he was
one of the finest minds that humanities
produced and and one of the best minds
of the 20th century firemen came up with
a Nobel prize-winning physicist and came
up with a theory of quantum
electrodynamics which is the most
accurate predictive tool that human
beings have ever invented it's more
accurate than general relativity as well
as being this this absolute genius he's
very amusing chap but also but also a
kind of philosophy philosopher on the
subject of science and and if ever
you're looking for quotes for
presentations Fineman is a really good
source and this is one of my favorite
quotes that so it doesn't matter how
intelligent you are if you guess and
that guess cannot be backed up by
experimental evidence then it's still a
guess so my argument is if it is if
science and the scientific method is our
strongest problem-solving technique and
software development is one of the
hardest problems that human beings
undertake shouldn't we be applying our
best problem-solving technique to some
of our hardest problems I think that the
way in which we work when we're writing
software we should be taking a more
scientific more empirical approach to
the work that we do we should be
consciously thinking about each time we
make a change and how do I evaluate the
whether this change is good or bad
whatever that means whether that's a
trend in your processor changing your
code a change in your the business
direction that you're learning as a
result of interactions from your users
all of those things all of that stuff we
should be more empirical and figuring
out how to make this stuff work and one
of the tools that allows us to do this
is the idea of cycle time and I'm going
to show you now two cycle times from
projects that I worked on this was this
was a long time ago it was on a project
when I used to work for a company called
thought works and I this was for one of
the big banks here in the UK and there's
the idea of cycle time is if you imagine
the smallest change that you can make to
your production system a one-line
changed the code or something like that
and then you want to evaluate that
change as you would for any other change
to all of the due diligence that you
ought to do to evaluate that it's a good
change before releasing into production
how long would that take so it's
effectively what's your change cycle
factoring out the the the amount of
effort it takes to actually make the
change itself and this in this Bank they
could not deploy a one-line change to
their systems in under 103 days if
you've got a cycle time of 103 days you
don't have a feedback loop if you've got
a soccer time of 103 days and you come
up to me and say Dave you broke
production with your change 103 days ago
I'm gonna say I wasn't here hundred and
three days ago I can't remember anything
about this this is a cycle time from
another project and technically in terms
of scope and ambition and and the amount
of software this was a much more
complicated project significantly more
than this one this was a this was a
project that I worked on in a start-up
where we were building a low latency
high frequency trading financial
exchange from scratch with all of the
third party interactions this was an
entire enterprise system this this
bottom on the cycle time for this
project was 57 minutes we could make any
change any change to our production
systems and evaluate it in and it would
be ready if it passed all of those
evaluations it would be ready for
release into production after 57 minutes
if you've got a socket on at 57 minutes
and you come to me 57 minutes later and
say Dave you screwed up and you broke
production I'm gonna know what you're
talking about I'm gonna remember what
was doing 57 minutes ago and I'm gonna
remember what what that was and and I'm
gonna have a possibility of either
backing it out very quickly or fixing
the problem that I introduced more than
that if I've got a cycle time of 50 if
I'm release if I'm generating releasable
software every 57 minutes the amount of
stuff that's going that's releasable in
that release candidate is going to be
small it's gonna be a small batch
which means that the risk that I'm
incurring with each of those changes is
small and so it's easy to think about
it's easy to reason about what's going
on with those changes it's easy to track
back what changes cause what problems
it's easy to deploy these things because
they're smart many small changes very
often and it's it's easy to to manage
the whole flow of information associated
with all of these changes because it's
all in these little packets so this is
the idea of continuous delivery than
undescribed really here cycle time is
kind of this wonderful tool I think I
think one of the big strengths of
continuous delivery is it's a bit like
test-driven development I'm a big fan of
test-driven development and one of the
reasons that I'm a big fan of
test-driven development is that if you
follow the rules of test-driven
development it applies a pressure to
design better software software that is
amenable to automated testing is more
modular more loosely coupled has better
separation of concerns low cohesion all
of these things that have been
classified as the hallmarks of quality
software for decades and test-driven
development applies a pressure that
didn't exist before in the direction of
generating those so the only way that
pressure existed before was by having
really smart designers who worried
enough about those things Tessenderlo
makes this extra impetus design good
software
I think continuous deliveries does the
same thing for process if you look to
optimize cycle time for cycle time and
you use an experimental approach it
pushes you in the direction of better
process incremental e step-by-step it
will make you do better things I'll talk
more about that in a moment
so here are some others well so what's
continuous delivery really about so
first of all there's as Dan said in his
keynote sorry in his presentation on the
first day nobody ever reads the second
page of the agile manifesto but if you
do that's the principles and the first
principle of the agile manifesto is that
our highest priorities to satisfy the
customer through early and continuous
delivery of valuable software so it's
the first principle of the agile
manifesto this was kind of what was in
the
of the minds of the people that were
thinking about the idea of manifesto and
they wrote it it's kind of like a
logical extension of continuous
integration if you would performing
continuous integration that's a great
thing but continuous delivery just kind
of extends that out the reach of that
out a little further so not just can we
build a something on a continuous basis
and run some tests but we can deploy we
can get to the point where it's in a
releasable state and that kind of
stretches out a little bit further
upstream in through the requirements
process and a little bit further
downstream into the release and
operations processes I think of it as a
holistic approach to development this is
not just about the the mechanisms the
the bits and bytes of the the continuous
integration cycle this is about the
whole process and we're looking about
this as a holistic way as I said when we
were thinking about Lean Thinking try
and optimize the whole process a good
kind of mental model for this is if
every time that you commit a change
that's destined for production imagine
that that's giving birth to a release
candidate and her job from then is to
prove that that release candidate is not
fit to make it into production
that's a weird idea but that's the
that's the idea of falsifiability we can
never have enough tests to prove that
our software is good but as soon as one
test fails we know that our software is
bad and we shouldn't release it and
finished means released in production
this list is kind of pinched from from
my book continuous delivery and actually
this is one of the things that if I was
rewriting the book now I would change
this finished doesn't mean released into
production that's not that's not good
enough finished means released into
production and delivering value to the
users so here is some of the principles
of continuous delivery we're trying to
create a repeatable reliable process for
releasing software if you want it to be
repeatable and reliable that kind of
eliminates us we're not very good at
being repeatable or reliable computers
are wonderful at being repeatable and
reliable we're not we're great at other
things but we're great at creativity and
you know soft fuzzy pattern
and all those sorts of things but we're
not good at repeatable and reliable and
so if you're using human beings to
validate that your software is good on a
repeated basis it's going to be
expensive it's going to be slow it's
going to be error
error-prone if we can automate all of
that we're going to get a much more
efficient effective process which will
be repeatable and we pop reliable so we
if we want it to be repeatable to
reliable we need to automate nearly
everything if we want to automate nearly
everything then we've got to keep nearly
everything under version control because
if we if we're making things we've got
to be able to get things into a known
good state and that means we've got to
can have configuration management not
just about source control but think of
the configuration of our systems and the
environments in which they operate and
the the dependencies that they have on
the infrastructure or code software's
kind of weird most of human experience
if something's nasty and painful it's
probably sensible to avoid doing it but
in software
if something's nasty and painful and you
try and shy away from it what generally
happens is it gets worse so if your if
your release is unpleasant and difficult
and fraught with risk and you're
releasing once every six months the
worst thing you can do is to say oh it's
really bad let's start releasing once
every 12 months instead that's going to
be even worse so if you're releasing
every six months and that's painful the
right thing to do is start releasing
every three months then every two months
and every one month in every week then
every hour if you can if you get to the
stage of being able to release you know
on demand being a releasable state on
demand
then you're gonna have a pretty good
story around most of this stuff and
you're going to dearest an awful lot of
it quality's kind of a difficult subject
because as an industry we've kind of got
used to working in environments where we
used quality as a way of compromising
quality as a way of speeding up delivery
and I think that's an absolutely
terrible idea and and I have no data to
prove it to you but
but my experience has been to a massive
degree that if you focus on quality you
get faster not slower the last place
where the place that I often use in
examples in my presentations is a place
called real max where we built a
continuous delivery system from the from
a blank sheet of paper from the ground
up we were building high performance
software and we were we were addressing
some challenges that we weren't aware
that anybody's solved before we were
doing some injury interesting work and
we were absolutely diligent in kind of
not just going for good we were going
for excellent in everything that we were
doing we would we would go the extra
mile to be make sure that our code was
elegant and clean and that is the most
productive software development
environment that I've ever worked in we
could make any change I mean we could we
could get it through and evaluate it and
understand the consequences of this
change very quickly because the code was
clean it was easy to reason about it was
elegant it was easy to work with and it
was tested as I will describe very very
very extensively we talked about some of
the others so don't don't means in the
hands of users delivering value
everybody is responsible for the release
process so the processes and tools and
mechanisms need to be transparent and
easy we need to be able to crunch
information down into consumable work
units if you're producing a massively
complicated graph of your performance
statistics that's not quite as good as
saying a read blocks or a green box
saying whether it passed its performance
criteria or not simple is good and you
want that you want the extra detail you
want the extra data you wanna be able to
dive in and find more but you need to
make this consumable everybody's
interested in the release process it's
not just those technical nerds it's it's
everybody the the CEO is going to be
interested in the valuable software
whether when we're releasing this thing
so making sure that that we're focusing
on the value the stuff that we're really
delivering not the intermediate steps
that as we go through is kind of
important and sort of considering that
and worrying from the perspective really
from the perspective of our users all
that's what's what it is that we're
trying to deliver so how do we present
the progress of ideas through our
systems that you know if a user came in
they would understand how those ideas
are flowing through and this is not a
process where you said okay we're gonna
have a a two year process and we're
going to be going to do continuous
delivery and then after that we'll stop
we'll just be doing it then it doesn't
really work like that what this is is a
culture change what this is is it's a
it's a it's a significant change in the
way in which you work the I hope that
the way in which I'm presenting these
ideas and I will explain more about one
is that I'm talking about in a minute is
reasonably simple and straightforward
actually in implementation this does
bloody hard it's difficult it takes an
awful lot of different moving parts from
an organization or process technology
the software design perspective all of
these things if you want to get good at
this stuff all of these things need to
come together and and play a part in
being good at this stuff
and that takes commitment and skill and
a new way of thinking about some of
these things and so we need to be
establishing ways of working that allow
us to improve continuously we need to be
experimental in the ways that we work in
the ways that we adopt process in the
way that teams are formed and organized
as well as the experimental in the way
in which you just write software this is
just pure hubris on my part this is a
quote from Forrester from a while ago
saying if agile software development is
the opening act to a great performance
continuous delivery is the headliner
with we're starting to get traction we
started to get real data is some of it
one of the presentations earlier in the
conference showed we're getting real
data to show that this is a bottom line
advantages to the organizations that are
running this is this is not just one of
the small changes that happens through
the life the life of the software
industry I believe I think this is a
step change we finally know how to do it
so what does this look like when you're
working in these sorts of environments
well it tends to be a bit messy there
tends to be lots of information flying
around it tend to be noisy environments
because they tend to be very
collaborative
places where we work and argue about
ideas and they tend to be lots of sticky
notes usually is in my experience we
have information radiators showing us
the state of our I would have thought
that the pro progress of software
through our systems we have data that
we're working on and we're working I
included this mostly just because I like
the cartoon but we altered we look to
automate all the things if we do want a
job twice we're now thinking well now
maybe we should automate this so I want
to walk you through kind of a typical
process for a continuous delivery and a
good mental model for this is if you
imagine our software dilute hands apart
where the consumer sells software
developers right so so software
developers our job is to solve problems
by designing you know implementing
software so think of your software
development process there's a problem to
be solved that let's build some software
that solves that problem so what we're
trying to do so what we want to do is
we've got some developers here working
on a change and they're going to commit
the change to source repository and
that's going to kick off an evaluation
of that change to see whether it's good
or not so we're going to run what we
call the commit stage against that
change and evaluate that change so far
this is continuous integration there's
no distinction between this and
continuous integration what we want from
this commit stage is we want very fast
feedback we want the developers to be
have as early indication that they're
that they've they've screwed something
up as we can give them and the fastest
indicate indication you get is the
little red squiggly line your IDE
underneath bad code the second-fastest
is that is you get a failing test so
we're gonna run these tests so we want
these tests to be lightweight we want
them to be close to the process we don't
want them to be touching the desk or
going to the database or talking on the
network we want them to be in process
close so we can run tens of thousands of
these tests and get results in under
five minutes ideally that's that's kind
of a ballpark figure of where we're
aiming this is where we start to diverge
a little bit from continuous integration
what we want also is that as a result a
result of a
successful commit build we want to store
the binary outputs we want to store the
deployable artifacts that will end up in
production if this kiss release
candidate makes it all the way through
the reason that we want to do that is
I've worked in many places where you
would you would compile the code that
you're working on to a particular
deployment target because you would put
in a configuration with the compiled
stuff and you would loop them together
and the downside with that is that maybe
the next time I build if I build it
further on and I'll come you know a
compile it just before I release it into
production maybe I'm using a different
version of the compiler maybe it will
link me different libraries I have
suffered from the bugs that got
introduced through doing that by using
the wrong version so what I want to do
is I want to be bloody sure that the
stuff that I tested here is the stuff
the same stuff
that's going to end up in production
should this release candidate make it
through the process so I'm going to
store the releasable artifacts whether
those are jars or rpms or young modules
or I've forgotten what net caused them
assemblies whatever they might be we're
gonna store them here now I think from
my earlier comments you probably get the
impression I'm a big fan of test-driven
development and you're right and I think
test-driven development is a huge step
forward in in in software development
but the downside of it is that what it
does is it proves that the software does
what the developer thinks the software
should do and that's a different thing
to asserting what the software does what
you the users want it to do it's a
different thing so we need tests from a
different perspective in addition to the
TDD test would have vitally important to
give us that verification that the
software does what we as developers
thing we also need a verification that
it's going to do what we're really
aiming for what we really wanted to do
so we run a bunch of acceptance tests to
to evaluate that the acceptance test we
want those acceptance tests to be
running in production like environments
we want that it to be close enough to
production to catch the common sorts of
errors that we might miss otherwise
so that the the process boundaries that
are important in the the topology of
your application the versions of the
operating system the infrastructure that
it's running in the vanilla version of
the web server database all that sort of
stuff those things we want all of those
things to be exactly the same as they
will be in production and configured in
exactly the same way when we run these
tests if the tests all pass or if they
don't we're going to collect the results
and we going to store them against the
release candidate so we've got the
history of what what went on I said
earlier about human beings not being
repeatable or reliable so what's the
role of manual testing I think that if
you use human beings for any form of
regression testing it's an anti-pattern
I think it's I think it's an abuse of
human beings it's a it's a rotten job
and it's not it's it's it's expensive
inefficient and not very high quality so
use computers for that human beings are
absolutely wonderful other kinds of
things human beings are greater
exploring and wondering about and being
creatively destructive and doing the
crazy you know if I it's really really
simple for me as a software developer to
write a button on a page that's blue
with blue text on it so that you cannot
read what the text says and the software
will happily go away and click that
button because you've built in the
assumption that that's the button that
you're clicking on and it's not reading
the label a human beings gonna spot that
kind of error immediately more subtly
and more importantly human beings are
going to get the the sense of whether
the use of this that this software is
usable whether the journey that it takes
it takes you through is sensible and and
and and gives a coherent mental picture
in so that allows you to work with the
software so you want to use human beings
for that kind of stuff and so you
involving them where you have those
sorts of things everything else automate
as I said this this this was kind of
based on some very high performance
software so performance was a critical
component of our system so we divided
performance testing into two stages we
would do component level performance
testing for
attributes that were components of our
system that we knew to be performance
critical so the messaging system the
journaling system the the matching
engine for out for our exchange those
sorts of things and we would build those
in a way so we have a threshold of
performance so that we knew that you
know you could do so many so many
million messages per second in the
matching engine and if it fell below
that I knew I'd done something stupid
and slowed it down but that again that
doesn't kind of give you the whole
picture that the thing that catch you
are the things that you don't think
about and so ruining the whole system
performance was so again we'd have a
lifelike representation of our
production system we've had precisely
the same hardware configured in
precisely the same way for the
high-performance bits and we would then
run very very lifelike scenarios so in
fact what we did is that we recorded a
day's worth of traffic and then we
replayed that at a 5 5 X version of a
day's traffic through the system and
figured out you know where that's
drained it or stretched it or whatever
and again we kind of had thresholds in
here as performance from the throughput
of trades and that sort of thing that we
used as a benchmark for whether we get a
pass/fail result out of these tests so
you can you can imagine our release
candidate moving through the process and
gradually we were increasing our
confidence in the quality of this
release candidate and you know if at any
stage a test fails we kill that release
candidate it's done we throw it out it
never makes it into production if any
test fails but if all of the tests fail
then all we've got is a higher level of
confidence but you know that's better
than we had before the last stage in
this was you know this is all great for
the kind of code that you write in the
configuration of your systems and all of
that sort of thing but what about the
data what about the data that you're
building up in production so we worked
in ways where we would we would migrate
our data sorry we would if we wanted to
change the structure of our data in any
way any static data we would do that as
a series of deltas and we would apply
those as patches and kind of our
automated deployment tools would do the
data migration for
as part of the deployment and so we
would assemble the right loom bows of
patches apply them in order and then run
a bit a series of tests of evaluate
whether the software still looked
healthy and we would do that as part of
the data migration testing eventually we
get to the point where we were ready to
release into production and at this
point so so this this this is a machine
this is a machine that's churning out
release candidates or or excluding
release candidates and at the points at
which we come ready to release what
we've now got is we've got a big list of
release candidates that we know have
passed all of these tests so as far as
we can know those release candidates are
good and ready to go into production and
so we can pick any one of those so and
we generally just pick the newest one
and press the button and releasing into
production those of us that in the
continuous delivery space make a
distinction between continuous delivery
and continuous deployment continuous
deployment is a subset of continuous
delivery continuous delivery you know
you have to do continuous delivery to
get to continuous delivery deployment
continuous deployment is the process of
automatically releasing into production
any change that has passed all of its
tests so you can kind of just you can
you can imagine getting to this point
nothing a human being here but just the
robot that's just saying it's impossible
it's test yet deploy it and many many
organizations do that but it's a de
business decision continuous delivery is
the process of working in a way so that
your software is always in a releasable
state and it's a business decision to
decide whether it's a good idea to
release that in production or not in our
case we were we were a financial
exchange low latency file a financial
exchange there was no way that we could
automate the release into the production
without imposing a change in latency to
on one of our trait one of the people
that were trading in our system so we
would be conferring an unfair advantage
on some people against another if we
were to release while people were
trading so we can do this but so we just
released periodically at the at the end
at the end of every week we just press
the button releasing to production in
the market
are closed one of the things I want you
to think about in this protein this
whole process is called a deployment
pipeline and that's kind of a
fundamental idea in continuous delivery
this is listen you know really what this
is about this is the channel for change
to production and we automate the
channel from change to production and we
vet we won't want to throw out any
release candidates that aren't fit
that's its job okay now think a little
bit particularly the software developers
in the audience I think a little bit
about what it takes to build that
channel you can't build that channel
with having without having complete
traceability so if you're working in a
regulated environment which has been my
background for it for a while this is
about as this is this is kind of like a
dream for regulators because this gives
them a complete picture of what went on
you plug this part you know you plug the
early part into you're an engineer or
something like that your requires
management system and you have full
soup-to-nuts traceability of every
corner to thought of it who worked on it
what tests were run against it who made
the decision who validate it that you
know that in the manual testing that it
was that it was okay
who pressed the button to release it
into production you know what times all
of those things happen all of that stuff
he's audited and you ever complete audit
trail all it takes is to put something a
nice little utility on top to make it
look pretty to give to the auditors my
experience is that my experience of
dealing with regulators in the finance
industry here and in the states with the
systems working this way is that at
first they're extremely wary because
it's beyond their experience and then
they they absolutely love it they eat it
up they think it's what they've been
looking for all of the time so it takes
a little bit of convincing but this is
better than what was going before from
strongly regulated industries so why I
talk about this stuff a lot and one of
the push backs that I get he's okay this
this may work for small projects but it
can't possibly scale so my example that
I cite for to dispute that is Google
so Google have made the unusual decision
taking the unusual decision of deciding
that all of their software lives in one
big repository every time as a Google
developer this is the vast majority of
things I think it's not entirely true
about everything but nearly everything
is in one big repo and every time you
make a commit that triggers the build
for everything and triggers all of the
test runs for everything and so you get
a not you know a nice coherent picture
of whether everything works together
they run six misses this is out of date
this data they run 60 million builds a
year 100 million lines of code 20
commits a minute it's 100 million test
cases expert executed per day so if your
problem is bigger than that it's
possible that this doesn't scale but I
think mostly I think what this says is
that you can make yourself they've
invested enormous ly in some very clever
stuff to do parallel builds and parallel
test runs to make this efficient and
that's the that's the that's the outcome
of making this kind of decision and
there's another way of doing it so this
is this is this is this is the other
pushback that I often see this is too
risky releasing all of the time is a
recipe for disaster might releases are
really scary I released every six months
and they said nightmare
so my argument to that is the Amazon
build Pres anybody used Amazon recently
last week which version of Amazon did
you use you don't know you don't care
that's because Amazon have the mean time
between deployments of 11.6 seconds and
the mean host simultaneously releasing a
deployment so once every 11.6 seconds
there's a change going to on average ten
thousand servers since they started
doing this they've seen a dramatic
reduction in outages and a reader a
dramatic reduction in the time spent
fixing outages and have the number of
deployments where they've had a problem
has dropped dramatically to the last
push back that last pushback that I'm
going to talk about that often sees okay
so fair enough
Amazon can do this Facebook didn't do
this school can do this but they're
they're just web sites that's the easy
right are my technology is way too hard
to do
do it and for that I cite the HP
firmware team so the HP firmware team
were in a pretty dire state a few years
ago they got to a position that was so
bad that their business had stopped
asking them for changes the business
weren't asking them for any changes
because they never got them anyway
they've just given up if you look at
what they did the breakdown of the work
that they did at that time the this it's
kind of interesting this stuff so they
spent 25% of their effort porting code
and the reason that they did that was
that this this is that so this is the
firmware that runs in each every HP
LaserJet device and what they did at
that time into that before 2008 was that
every one of those devices pretty much
had its own branch so they had a single
codebase but every one of these things
was on a separate branch and then you
added a feature to that branch and you
want to do this printer over here so you
go to migrate it to these they spent 25%
of their global development effort
porting code between branches they spent
25% on product support which probably
means they're coated was crap and they
spent less than 5% on what they called
innovation what you and I would call
feature delivery this wasn't real
innovation this was just doing anything
new so they switched that and that one
of the interesting aspects of this from
my perspective is that they hadn't read
any of the agile literature they hadn't
they didn't read my book about
continuous delivery when they made this
switch they just went and they said
let's go back to first principles let's
just think about what we'd like to do
and they just started following it
through and they they co-evolved what
looks like continuous delivery the same
process they came to the same
conclusions through following this
expert an experimental engineering lead
thinking that kind of took this down
this direction they ended up in a much
much healthier state base state they
spend an awful lot of time on continuous
integration writing automated tests
there's two things for automated tests
I'm not quite sure why that's there um
agile planning all of those sorts of
things like they're kind of traded some
of the work that they were doing here
for other stuff but the bottom line is
that they ended up now freeing up the
ability to spend 40 percent of their
global development effort on doing new
stuff the quality went through the roof
on their on their on their software and
and this is kind of detailed in a really
excellent book that I recommend to you
called practical approach to large-scale
agile development which describes kind
of from the process point of view this
is not a technical book this is much
more about how to map how do you manage
chain culture change in organizations
and he's really interesting from that
perspective and the outcome was overall
development costs were reduced programs
under development increased and and as
we described the amount of effort spent
building new stuff was increased
dramatically what I'm talking about here
is that continuous delivery changes the
economics of software development and
increasingly as we saw from the
presentation earlier earlier in the
conference which some of this data is
from there's the bottom-line advantages
to the others of the organizations that
are employing it and this is the first
time we've seen this in the software
industry we make it we software
developments are making a difference
we're able to by following a rational
empirical process of software
development by not making guesses by by
being expiring out making forming
hypotheses worth figuring out how to
test those hypotheses and working in
that way
working iteratively we're able to make a
dramatic difference of the businesses
that that we operate in the data the
data is growing all of the time and
they're a great story
I believe that you will be affected by
continuous delivery whether you whether
you employ it or not if you're employing
it you will have more fun you're right
higher quality software faster more
efficiently and you're making
bottom-line advantages to the businesses
that you operate in
if you don't employ it your competitors
will do that and they will kick your ass
so here is some of the organizations and
this is just a sample there are lots of
organizations and some of them are kind
of the ones that you would expect and
some of them are kind of probably a
little bit more unexpected Google Amazon
Facebook Etsy who do high levels of
experimentation in production we have an
infrastructure ranked doing a/b testing
and all that kind of stuff for Flickr
Netflix we kind of burn overs but we
heard yesterday for a penc talking about
ing x' experience they've seen dramatic
improvements in their in their ability
to deliver as a result s AP surprised me
there are guys out on the speaking
circuit and writing circuit talking
about big advantage in the quality of
this after and the productivity of their
teams employing this stuff oh my mental
model is si these kind of a definition
of legacy systems but New York Stock
Exchange New York Times there are lots
of organizations and the list is growing
all of the time that people are taking
notice because this works this is a more
effective way of delivering software and
we're that I'm done please remember to
vote in the application if there are any
questions happy to take them if you want
to put them I should have said this at
the start of the presentation but if you
want to put them through the app that's
fine too we have a few minutes for
questions yeah yeah cool so the first
question is building that kind of build
test pipeline is tough at least in
Jenkins how do you recommend doing it
okay I'm not so l max we use we use we
started off using cruise control which
we which is even worse than Jenkins or
was there and then we moved to Jenkins
which I confess is not my favourite
piece of software I don't like you very
much but it does the job I've used
teamcity as well to build pipelines none
of them really none of them really get
deployment pipelines to my mind yet so
the the model in them is rot is
that doesn't really matter too much
though because actually it's not that
difficult to problem I think it's doable
so you can you can use Jenkins you can
use cruise control you can use steam
city you can build your own thing it's
not that complicated or requirement each
step each little piece is relatively
straightforward and so you can kind of
write little bits of code that glue
things together and you can kind a
couple things together and you might be
a little bit ugly here in there but but
it's absolutely doable and you can build
quite sophisticated build pipelines in
this way I think there's more stuff
coming I think that I think that people
are paying notice to this there are lots
and there are lots of people that I know
that are working on tools in this space
Amazon have a code pipeline they call it
in AWS that they're looking to move I'd
be Emma talking about building some
deployment pipelines in their bluemix
stuff there's all sorts of people that
are looking at this stuff but I think as
yet the tools are immature in there and
actually they're the ideas and for me
the ideas are dramatically more
important than the tools the tools
aren't that hard to build yourself to
sort out yourself if you're committed to
the ideas
yep
there's an awful lot in the detail is
quite III have another talk about except
the except assisting is how I think the
TDD and unit testings kind of worked
quite well written about I think
acceptance testing probably a bit less
so and so so you know I do some stuff on
I'm talking about the technicalities of
there and there are what the ways in
which you write your tests have
implications for the the ways in which
they will scale up the ways in which you
can call assured the merit and all of
those sorts of things so there's that
level but you know when you're talking
about big organizations with many
projects then you you get to the kind of
div the Amazon root or the Google root
if you go for one big repository and
running everything together which has
some advantages you know it's not a
stupid thing to do it means that your
dependency management is just a one to
one relationship all of the time which
is which is nice
the one of the things that's coming out
of Amazon Amazon have gone the other way
Amazon have got their two peaks of teams
and micro service every service is kind
of built you know built by a small by a
small team and run by a small team today
the difficulty there is is is what about
what about interactions that cross the
boundaries of services and then you've
got the you know managing the protocols
of exchange of information between the
services and those sorts of things that
becomes a that's the trade-off
so the trade-off for the monolith
approach is that you have to invest in
infrastructure and clever stuff to be
able to run this stuff in parallel to
get reasonable cycle time the trade-off
of the micro service approach is that
you have to worry about the dependency
management and neither you know neither
of those ease is wrong or right it's
just those of those are the pain points
depending on which which route you go
down and and both of them were are
workable but both of them have
complexity in to be able to make them
work I know that doesn't answer your
question but I I don't think it's a
question that I can just answer in this
timeframe I'm sorry if you want to talk
afterwards in more data I'm happy to do
next question can you move to continuous
delivery without a call to change to
cross-functional koreans high
collaboration orders one
only work with the other I don't I don't
think I was so you can get benefits let
me just take a step back Mike my
experience has been that you can't
really do this transition from being a
regular organization to being a
continuous delivery an organization in
much under two years two years is going
pretty well if you can get even close to
being decent at it in after two years
but at each step along the way there's
incremental value so if you're not using
version control the introduction of
version control is Lopes a revelatory if
you're not using continuous integration
that's that's that's a huge step if
you're not using TDD that's as a massive
improvement so there are all of these
things that the the add value you're not
gonna get really world-class at this
stuff if you haven't got the kind of
learning cross collaborative teams that
we've all been talking about in this
conference you can get better than you
are you can be you can get value from
doing these things but you're not going
to get world-class
world-class requires the experimental
learning environment and that real that
requires the close collaboration of
teams in my view any of the questions
ends up you don't have to put it through
the app if you wanted to in which case
thank you very much indeed for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>