<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Beyond Flux - Scalable Frontend Architectures built upon Publish/Subscribe • M. Kurze | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Beyond Flux - Scalable Frontend Architectures built upon Publish/Subscribe • M. Kurze - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Beyond Flux - Scalable Frontend Architectures built upon Publish/Subscribe • M. Kurze</b></h2><h5 class="post__date">2016-11-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/82rrMIf48Zk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright hello everyone my name's Michael
I'm a software engineer from ike's ego
and Germany we built web-based solutions
for the financial sector for banks and
our FinTech and yeah I've come to talk
about architecture for the web climb and
yeah why is it even important I probably
don't have to convince you here because
you came to the presentation but if
you'd like to tell others well we have
to build increasingly large web
applications increasingly increasingly
large amount of code that run on the web
client and we have to define the tools
that we use for that we have to find
better tools because the code bases are
becoming more complex the teams are
becoming larger and we also have to have
a common language and understanding a
vocabulary like we used to talk about
these things so what are the aspects of
architecture that that interest me here
for this talk this complexity the web
application platform has been growing
tremendously over the last couple of
years and keeping up with with mobile
platform and so the complexity in the
platform demands more complex
applications so people are building ever
more complex web applications and this
complexity drives the arm and the
platform complexity drives this so this
is one challenge that a calm important
over the last couple of years and the
next challenge is responsiveness or
reactivity and in the concept of web
front-ends I'm not really you know
talking about fault tolerance or you
know dying early or something like that
reactivity means that the application
should always be quick to respond to the
user and when you fill out a form in a
web application nowadays you don't wait
to submit the form before getting your
feedback on validation and things like
that so so there's a concept
bi-directional communication between the
web client and the server
and then that's the third challenge
that's of particular interest here in
this talk its scalability and with web
applications you know you might think
about well scaling across multiple CPU
cores or something like that and it's
not really very interesting for the web
blind most of the time maybe you're
building a 3d game or something then
that's important too but well
scalability I'm meaning here is a
scaling across teams various backgrounds
if not only multiple program is working
on a project but actually multiple teams
and those teams tend to you know favor
different technologies tend to have
various different level of expertise are
very heterogeneous and we'd like to
support that using our architecture so
and this is well the blueprint for the
solution that that's going to be the
topic of this talk this is the so called
unidirectional data flow and it promises
to simplify the development and
maintenance of web applications so
actually not that new 10 to 20 years ago
already you had these types of web
applications where there was a database
sitting on your server and it had some
content that was interesting to users
they would make a request to the to the
server and it would serve the view just
an inch the HTML of a representation of
the contents of your database along with
that view they might get a form which
allowed them to to add or modify the
contents of the database and while they
post the form to an action and that in
turn on the server modifies your
application state so this flow of state
view action or intend to modify the
state and go full circle it's actually
not new what's new is that over the last
couple of years this has also become an
important topic for client-side software
development so who is responsible for
that Facebook to use a go they made a
presentation where they told everyone
well we have a huge problem getting our
count of unread messages to work
synchronously across the entire
application so as users navigated
Facebook there are various places
whether what
possibility to read or send chat
messages to other users and apparently
it was really difficult to get discount
to sync up everywhere and when you read
a message for it actually to stay you
know read and not come back with with
one or two hundred messages you'd click
it and oh actually nothing new so yeah
users were very very vocal about this
and so turned out that an architectural
problem had really become a user facing
problem in case you can't really read is
so there is a facebook wall message for
Mark Zuckerberg I think we're 890 people
vote up for please improve the church
this and so yeah so there was some
degree of top-down pressure to to modify
this to modify the architecture to find
out what is wrong with the current
architecture with a state that is
redundant across multiple components and
find a better way to manage this so what
does the unidirectional flow look like
that Facebook came up with and they
called this pattern the flux
architecture it's not just a software
that you can download it's an
architectural blueprint that you can
well employ in your application so the
state should be stored in this here
components called stores where each
store is responsible for a slice of the
state and those should not be
overlapping so there should be distinct
and then you have the view which is at
facebook they already used to react to
render the view so that wasn't wasn't it
was a really good match because react is
very well suited to rear ending the
entire UI every time you make a state
change so they could pick up this
traditional way of rendering web
applications you know just reflect the
current state of your database instead
they would just do it on the client
reflect the current state of your of
your store and we render the entire
component hierarchy in your app and then
of course the users just use it doesn't
just run a monobrow see a read-only view
of its application so
yeah as the so called action creator or
actually multiple action creators for
each thing that the user can do in an
application for example market messages
writ or create a new message send it to
someone there's an action creator talks
to the pasta was probably web rest api
and once it determines of an action can
be carried out and should be applied to
the application state that's stored on
the client will dispatch this action to
the so called dispatcher which just
notifies all the stores about what
happens so somebody sent a message to
someone yeah and yeah all this happens
on the client and so if this is flux
other parts of this that i can download
where do i have to fill in the blanks or
how do i have to have to write
everything myself well that most
certainly you don't there's there's a
large number actually a flux
applications nowadays forex
implementations nowadays so there's the
traditional vanilla facebook flux
implementation that not that many people
use I think there's yahoo flexible which
is pretty popular there's algae is i
think by our B&amp;amp;B and which is a bit more
concise avoids euler played and then
well redux i haven't put on here yet i
have a separate slide for that because
it's it's a bit different but it's also
very popular people mostly just say
redux instead of flux nowadays yeah and
well to get some some meat to to this
theory there's a there's a little yeah
most yeah the simple as possible webshop
you might say that dmitriev Iranians
give wrote in 15th lok cyclic
implementations so if you're into flags
you want to know more and find out the
right implementation for you huge you
might check it out and have a have a
look at all the 15 different
implementations well what does it do it
just has a list of products that you can
buy and it has a shopping cart
so it allows you to add products to the
shopping cart that's one action and then
there's another action to check out the
contents of that shopping cart so
logically you would probably define two
new components here the product list
view component and a shopping cart view
component and also it's usually sensible
in this case to define two stores one
store that manages that products are
available and their inventory so you can
determine if the product has been sold
out and well another store that manages
the estate of your current shopping cart
contents yeah and to have some some
actual code for this I try to further
simplify the example that was based on
yahoo flexible and here we have a jsx
implementation of the view component for
the product list to the left and if
you're not familiar with j sx it's the
react way of generating HTML to within
the browser so it's a way you can embed
xml literals into your JavaScript code
to simplify the generation of dome and
the most important thing that this view
component does it just renders the
current state which is has received from
the from the store from the product
store somehow we'll see how and it
allows the user to you know press the
button and to add this product to the
shopping cart for this the action
creator is called echa card that we
imported here and yeah it just renders
the title the prize and this this image
in the pattern as we've seen in the demo
and well this functionality wise this is
pretty much everything that's it's
needed to be done here but there's some
yeah some boilerplate code sorry where
you have to connect this view component
to the to the store and that's actually
depending on the Flex implementation
that you use you have to write a lot of
this boilerplate code for the initial
provisioning of
data for the querying of the store to
get the data into your view component
and then for keeping up to date you know
getting the latest or contents whenever
it changes and re-rendering the view how
our this works india is not that
important it's just boilerplate and then
yeah you wire enter everything together
and pull the other components in the
shopping cart component for example I
won't get into detail for that it looks
very similar and yeah it provide a
render method that allows you to kick
off your UI by doing the initial render
and then you're set for the view and
then having go with the next part of our
application those are the action
creators which are a bit more simple in
the most simple case you have a
synchronous action creator it's just a a
one-off call you're the framework passes
this done Kobuk for you when you invoke
an action creator so you can do
asynchronous calls too and well an
action is just a string identifier that
says you know what happened or what
should happen a product should be added
to the shopping cart so a stores later
know if they have to do something and
then some payload associated with a
section so in this case what product was
added to the to the shopping cart and
then there's the asynchronous case where
you say okay I'm going to check out this
card for example yeah there you have to
talk to the rest api obviously to do a
check out and then you it's this recipe
is wrapped hear you talk to it and
hopefully it'll say success check out
you can also dispatch dispatch that
action so this allows you to for example
show some sort of progress indicator in
between those actions and there you have
an asynchronous down call and yeah
possibly you should also handle the
arrow keys here which is of course
emitted in the example and then there's
this dispatcher which is yeah I just
didn't put anything in here because the
flux implementation is going to do that
for you it's just cool it just calls all
your stores in a row and sometimes
it has to do some other things because
flex is actually not that simple so
that's why you have to download a
framework and not just write a for loop
over your stores so for example a
product store it keeps a list of
available product and their inventory
and yeah you can query this store to get
all the products this is what the what
the view does for rendering and it says
okay I'm going to handle these methods
this depends on the flux implementation
sometimes you've just was just one big
switch case statement where all the
actions go through with your flexibility
like this you say okay I've got these
handlers and these associated callbacks
so when someone adds something to the
shopping cart I need to call my decrease
inventory method because that's what I
have to do when things are put into the
card and ya handle receive is very
similar simple that's just the action
that says okay when the application is
kicked off we need to put the initial
products into the store and equus
inventory is a bit more well weird
because the dispatcher is used as
success in this wait for call is made so
in this case the product store says when
the inventory is decreased I let the
card store go first so the cuts door is
able to put something into the cart
before I remove it from the from the
inventory because if the count goes to
zero the card store might say ok there's
actually nothing left I cannot put
anything into the card so this is a kind
of functional dependency between those
stores and this is why the dispatcher is
not a trivial you can actually now
create wait for chains that form a
circle and then you have maybe endless
recursion or yeah I deadlock so it's a
bit more complex ah so those were the
components of our application and well
what advantages do advantages do we see
to a more classical MVC approach such as
those while using angularjs or backbone
you have a very strict separation of
State in those stores the UI and the
view components
and the behavior in the actions and
action creators so you always know where
to put something that's that's nice each
store value each date value is stored
exactly once so we don't have those
inconsistency problems that you had with
we are with a traditional approach at
facebook at least head with a
traditional approach and you have a very
arm yeah good testability because you
know exactly you know view is just
supposed to transform a given state into
a dom tree and you can check if the Dom
tree looks good a store just changes its
states after an action happens you can
look at the state before and after to
see if it's good and it actually also
simplifies server-side rendering which
is very hard to do if we feel impossible
to do if you're using angularjs yeah you
just say okay I generated initial state
on the server submitted to the to send
it to the client as a JSON object and
sent the initial view as well the
initial HTML and then the machinery just
picks up on the client and starts
updating the dome when when the next
action happens of course there are also
a couple of disadvantages well the
stores in a small application is just
all of this in small applications all
these don't very meta very much but as
you have more actions your we are prone
to get conflicts or you don't really
know which stores actually work with
what actions and if you're going to
change a payload of an action what
stores are going to be affected things
like that are these hard wired store
dependencies though the stores are not
really isolated this is this makes
testing harder and this makes you know
swapping parts out harder and stores are
conceptually Singleton's so for
server-side rendering they actually have
one store instance per request but you
cannot just put two product lists into
this application so you would have to
rewrite your product list if you if you
wanted to manage you know two sources of
products that could be put into a
shopping cart
and then there's this entry pattern that
I've glossed over in the in the code
here actually mutable status transported
through these actions which can lead to
subtle errors so in this case the store
just overrides its internal product
state when new products are received but
at the same time you get this payload
through the Add to Cart action and this
is all the way through the view from the
from the past of this store through the
view through the action creator backed
into into this method and maybe the
products have already been replaced and
since the action was fired and in this
case you would modify this product here
that you get passed through the payload
and nothing would happen so you have to
be careful not to mutate the objects
that that you put in the payload and
rather use some sort of ID to to
reference objects in the store and this
is really a crucial point that is
addressed by redux so they eliminate
this problem completely as saying okay
all stores are are not allowed to mutate
air state internally they just can when
processing in action they are only
allowed to completely replace the state
so with redox this there's only one big
state in your application it's one big
state tree and whenever an action comes
in that replaces the state with a new
state it reflects this users user action
so to compare this this diagram that
we've seen before we don't have the
group of of stores anymore it's just
this one store that's provided by the
framework and because there's only one
store we know don't need the dispatcher
any more actions look very similar only
in this case the the view actually
creates them and then dispatches them
let's a minor difference maybe and yeah
how's the store actually changed or
updated for those the so-called reducers
are used those are functions that have
the signature that we've just seen they
take a state or a subtree of the state
apply the action return the new state
and with this functional programming
pattern every time an action arrives the
whole state tree is update and replaced
well due to time constraints I can't go
into full detail on redux but it's yeah
it really eliminates this mutable state
problems that other flux have as but
other than that it also gives you some
really nice maybe unexpected advantages
well you have this functional
composition so if you're for into
functional programming that's really
really great it makes parts of your
application easily testable and then
you're somewhat confident that when you
put them together they are still well we
still working and you have snapshot
replay capabilities because the state is
replaced with a new state every time the
action is dispatched you can just always
undo and go back to a previous state
because they will still work and you can
just record all the all the actions
record them sent them to the server and
then you know some someone has a problem
calls you you can just replay them
locally on your workstation and see what
has gone wrong and if you do if you're
doing it right work work with react AP
is that allow you to you know perform
some yeah more efficient dirty checking
because the well when a reference
doesn't change with redux a reference to
a part of the Earth's your state tree
you can be sure that the contents didn't
change so you may be able to skip the
rendering of an entire subtree of your
view because you know the according the
corresponding state tree didn't change
so but for that you have really have to
do it right and JavaScript doesn't
actually make it very easy to do this
right so mutating state is yeah
javascript doesn't have built-in
checking of immutability constraints so
if you're trying to keep your objects
from from being changed you you have to
jump through them through some hoops so
for example you can use a transpiler
which which allows you such as bible
which allows you to use the spread
constructor
so you can take an old object and create
a new object where some property has
been updated or edit or you yeah go
really a hard way and incall object
freeze on your entire object tree
recursively but I would suggest doing
this only for testing because it's
really heavy impact performance wise or
you can just go over and use something
like immutable J's physics which is
actually very nice it offers immutable
data types with protect you against
accidental modification but it's also
not well it's it's not just simple
JavaScript objects anymore in this case
good old JavaScript object and arrays
are very easy to work with with every
you know you can always find someone who
can work with these things neutral Jas
you definitely have to learn it and well
that amounts to the potentially steep
learning curve goes for a mutable jas
also goes for these functional
programming paradigms some people think
it's say it's very easy and natural to
me other people struggle with it but
well sir yeah it's depending on on how
well you get along with it and then
there are the container components with
redux so those are your top level
components like the product list or the
shopping cart that represent some you
know some parts of your application that
the user can do useful things with and
they yeah they usually it's that they
know the whole state tree and you have
to be careful when you change things in
the state tree because maybe you need to
add at a new piece of data or remove
something then well pretty much every
part of your view might be affected and
so we are actually during this time
where we're Redux was invented would
happened last year I think we we came up
with something different at our company
because we also were struggling with the
scalability problem working with
multiple teams on the same project and
yeah we've rediscovered an old
programming architecture or patent it's
called publish-subscribe and it's
actually used very heavily on the server
side with with messaging middleware
and well its purpose is allow you to G
couple your components so yeah
decoupling as it boils down to allowing
your components to communicate because
you always have to have a way to for
them to do that but without the center
component actually knowing about its
receivers or even if there are any
recipient components when sent a message
and the receivers should not need to
know who actually sent a message they
have to look at it evaluate what
happened what do I need to do now and
yeah how can we do this well there has
to be some some mediators a man in the
middle which is called an event bus or
event broker sometimes and well it just
knows you know this this component is
interested in events regarding the
shopping cart maybe that component is
interested in all user actions having to
do with receiving new products and when
an action happens that matches these
subscriptions and it will deliver the
message through the correct recipients
and this selection happens through the
configurable topics so these are just
string identifiers that allow you to
form channels of communication in your
application and for us to yeah to
realize this unidirectional data flow
pattern that we've seen before it
actually looks somewhat like this we
have this event bus I just mentioned
which sitting in the middle and then we
have two kinds of components really the
view components that map very closely to
the view components that you have in
flux or redux they are just trying to
display some data and well the user is
able to you know invoke actions when
interacting with these view components
and and there are the activity
components which play the role of the of
the stores and the flux context but they
no longer share the same global action
namespace instead they are connected
yeah to this event bus as well and well
they are there
actions that they process they are
selected through event topics so we have
two types of events in the system there
are resource events they just they are
meant to transport state from the
activity components to the view
components for display and usually they
get the state from the from the rest api
first and then there are the action
events which process the which transport
the users intent to to work with the
application and yeah to to segregate
these components we we employ the
concept of topics and well this forms a
yeah a kind of unidirectional flow but
on multiple layers in application so
these are these topics for example this
topic might stand for the shopping cart
contents a resource topic might be
transported to just one specific view
components the shopping cart and another
topic the list of available products
might be interesting to two more
components on this application I guess
not or an action maybe generate by one
view components such as at this article
to the shopping cart and that may be
processed by both the shopping cart
activity store if you will and the
product list activity so yeah we have
topics for both our resources and
actions and those topics allow you to
well configure after programming at
configuration time what pro what
components should be able to talk to
each other so on yet now we have a code
example that's really similar to what
we've seen before we have a view
component which in this context gets
it's not it not it state from a store
but they in the context of this pops up
application get its resource from the
event pass for this we have a little
helper library so in house of course we
developed a a library for lux our
patterns to work with this kind of of
project and it talks to the event bus
for you and it says okay whenever the
products resource changes although
resource configured for the for the
topic that is associated with products
and we need to re-render this yo
component and for this reactors used
here and it just looks at the current
state of this of this product resource
and maybe it hasn't even received
products yet that's always possible with
pops up so we also have to fall back to
an empty list in this case and it just
renders those products and then there's
well the possibility for the user to add
a product to the cart and for this we
instantiate a publisher this is also
done through this patterns library and
yeah it's also wired okay it's a bit
small here but it's why to the topic
configured under the add to cart feature
so in this case the actual topics that
are used on the event pass those are not
add to cart here and products here at
those are those are configured for these
names and the configuration looks like
this we have this list view component
for products and for the add to cart
feature there's an action configured and
that's this at dash two dash card action
and the same action is configured on the
activity that manages the state and it's
well it says okay decrement your
inventory use that feature when you
receive this at dash to dash car action
so the product activity doesn't even
need to know that there's a shopping
cart actually it just why to this to
this action on the fly at configuration
time so it could also be invoked by some
other other event and then there's this
list resource which translate transports
the latest state and while it's called
products dash list or product this leash
and it's transported from the activity
to the interested view components
and for the other half there is an
activity component and this is also
managing the product list like we saw in
the flux example before and it again it
interfaces with this patterns library
and is able to well publish the current
list of resources when all other
components are listening so there has to
be some kind of life cycle events
submitted published by the eventbus
itself that says okay everyone's
listening and listening now has has made
the subscription so you can start
publishing data and also this activity
is responsible for for updating the
products products list state when when a
new add product action was received or
in this case the decrement inventory
because that's what it's called in here
and for this it just it doesn't just
modify the product as we've seen in a
flux example which was a problem with
the mutation of state and stated it
looks at the product in the current
state and then update the inventory
there so it wouldn't even be possible to
modify the product that is coming in
because the eventbus in this in this
framework that we built always are
duplicates everything that it receives
through through a published call so
effectively components cannot talk to
each cannot modify each other state and
cannot image each other and also they
are not allowed to expose any API so we
do that by principle they are only
allowed to talk through these events so
when you just remove a component from
the application this should never break
the application maybe some components
don't get the data but usually we are
able to remove a couple of those
components and everything well it just
missing from the screen but the
application doesn't break so yeah what's
what's this solution it's a solution
track we've come up with this framework
um
that yeah provides us with an event pass
framework is called Lux rjs and it
doesn't only have the event pass it it
also takes care of component
configuration we use a JSON schema for
that so you add a schema to your
component to allow specific properties
to be set determines what what types of
topics can be configured or maybe you
just want to set some some additional
values such as and web service API URL
something like that and then it also
allows you to compose these components
also using a declarative JSON format so
these these component compositions then
look themselves like components from the
outside and yeah it managed this this
life cycle tells the component when the
others are listening it has the services
that we saw for example to to render a
component and it offers some development
tools for example you can visualize what
what events go through the application
and how the how the components are
actually structure together can just
show this quickly because I think
there's enough time if I get this yeah
so we have the same demo built with with
this pops up framework and there you I
just add this button to open this
developer widget which is also just
another component and it's able to tap
into a stream of event that goes through
your application and shows you what's
going on who's who are the collaborators
who published something who is receiving
can actually also look at the content
which is a bit hard on this display but
you know it's it makes transparent
what's happening in your application and
then you can visualize the structure
which allows you to see if you wired
together your components correctly
because it just looks at the Jason
definition of your page and matches up
these topics and then you can do suing
things like filter by either component
so now it shows only events that that
have to do with this
with this component I just selected here
yeah and and actually to the question of
architecture yeah what do we think what
our experiences with with his pops up
solution as compared to traditional flux
or maybe reacts application so yeah the
advantage clearly is the decoupling of
components which allows you to well
isolate tests components in isolation
but also to reuse them a course
application or across different pages in
your application maybe you make
architecture visible you see where
components are connected if you if you
modify one component which components
will be affected by this it well makes
composition more flex of flexible
compared to flex because you're free to
define your own patterns actually we
define for example a pattern and even
pattern that transports flags through
the application so boolean state which
is similar to resource but simpler for
those cases we just need to know if a
pop-up window is open or something like
that and maybe you have have different
things you might like to extract for
example data streams and it also says
every component is a black box because
it doesn't have any API it really
doesn't matter if it's implemented using
a functional approach or an imperative
approach so if you have development
teams with different backgrounds and
there are some hardcore functional
developers they'd like to implement
their component state using you know
reduce operations then you and I can do
that and if you have people who are
hands of reactive extensions then well
an event / subscription is really simple
to an observable subscription or xjs I
can put them put that thing on that and
then work with RX j s in their component
and you can also you know use a
different view technology if you don't
like react originally we started off
with a with angular 1 and we're still
using English it's one for a few
components mostly
but recently you can also use react it's
just a thin thin adapter layer that you
have to write of course also other
frameworks well and there's the
drawbacks the ecosystem is definitely
not comparable to what you get with with
luxor redux you walk the unread path
here but we are yeah we're using we've
been using it with with financial
institutions for 23 years now and so we
are very confident in it working yeah
but you still have the freedom to make
mistakes when you determine which
components are in your application and
how you wire them together there's
always the possibility of for example
going too small you can originally we we
defined components that were just one
button or 11 tablerow or something like
that and then it became very messy you
can imagine trying to draw this this
wire diagram with hundreds of components
well even we if we have compositions
simplifies things a bit but it can
become messy so you really should try to
identify components that have actual
business value to the end user and that
makes things very approachable usually
and we do have applications that have
hundreds of those components and they
are very manageable so 100 instances i
should say but tends to tends to a
hundred of component classes yeah and
then is a still flux so or the new we
said let's talk about flux and go beyond
that for the NM remove the creative
redux all that counts is you have
unidirectional data flow and you have
those changes described as plain objects
in that sense both redux and the
publish-subscribe based approach are
actually more flux than flux because in
flux you still have this non reactive
way of creating actions and dispatching
them at the same time so actions as
plain objects the event model fits that
very well
and well under stars is this to say well
it's it's cool that you're inventing a
petrol flags by not doing flex at all
also talking about Redux here of course
but we like to think that's somewhat
true of our approach as well and yeah
it's actually not that important it's
terminology but it's some somewhat
similar to flux what we do and then you
have the highly subjective judgment of
things all of those approaches are a
unidirectional flow we set out three
main goals that our architecture should
solve and well complexity handling well
maybe if you do flux right it will also
work but you also always have this
problem with a mutable state the
reactivity yeah also depends how you use
flux but as I said the action creation
is dispatching them hurts a bit and then
scalability meaning not not performance
wise but developer team wise we think
yeah that we really are on to something
here because we are actually developing
relatively complex single page
applications with this across multiple
teams and they don't get in the way of
each other too much so it kind of works
and then there's these problems and well
its neck snap shot record replay
important to you maybe maybe not and the
other things learning curve if you're
already functional programmer then it's
that's a non issue with redux so these
things are very depending on your
situation longevity Redux is very young
observe pops up the pattern itself has
been there for 20 years so I think those
methodologies like event sourcing all
the patterns around pops up they apply
to this technique that we showcased here
but of course what we are doing in
particular may be too early to tell
yeah and well that's about it yeah the
framework is called luck sir jas if you
want to look into that the slides should
be on get up maybe I still have to make
them public but it will be very soon
otherwise and I was wondering if there
are any questions now all right and
saying thanks for your attention
everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>