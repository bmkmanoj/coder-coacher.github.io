<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Secure Coding Patterns • Andreas Hallberg | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Secure Coding Patterns • Andreas Hallberg - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Secure Coding Patterns • Andreas Hallberg</b></h2><h5 class="post__date">2016-10-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oqd9bxy5Hvc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so yes my name is andreas Halle Berry I
come from a Swedish company called
truseq and I'm going to be talking about
secure coding patterns but not only are
they secure they're also robust and
rugged of course since this is the
rugged track so robustness is really
important important word I think in
security because if it's not robust it's
not likely to be secure please remember
to rate this session you all know this
so but I'm repeating it anyway so yes I
work at truseq here's us on a company
trip in South Africa most of my time I
spend developing maybe 95% of my time
spent developing used to do a lot of
c-sharp now it's mostly Java these days
I also do some security code review
security penetration testing security
training and stuff like this basically
anything security related and if you
don't know what I look like that's me
right there and now I've been out
talking a little bit in conferences like
this I've noticed I become somewhat of
an internet celebrity in fact there's
just a sample of the pictures that are
out on the Internet of me yeah so
paparazzi is everywhere no too shabby a
bad hair day but you know you can't win
them all
so anyway security let's talk about it
it's important or is it why why are we
here why are you why are we discussing
this at all the thing is when I talk to
sorry
before when I talk to develop ourselves
find a lot of the time that many are
disillusioned with security they say
that there's no point in securing any
code because if someone wants to get in
you know they're gonna get in eventually
if the NSA is after me they're gonna
hack me no matter what I do well maybe
that's true if the NSA is after you but
NSA is not after you and your
application your application is the
target of an army of mediocre semi
criminals and kids in basements okay
that's the that's the major threat to
your
through your application and the thing
is when we do penetration tests truseq
we don't have to bring out the big guns
we don't use zero days to take over your
systems we just use basic floss that you
could have fixed you know with a minimal
effort there's a sequel injection
there's a command injection we can run
system commands via from your website we
can upload a file and run it on your
website without any problems these are
the trivial mistakes that we find that
you can fix so just like Josh said this
morning you are the cavalry the cavalry
is not coming we are the cavalry okay
and we can fix this
and also in the rugged manifesto as Josh
was talking about it said that you
should assume that your code is being
attacked by a skilled I can't remember
the exact words but a talented and
persistent adversary I want to say that
talented maybe not so much you know
don't be afraid don't be disillusioned
persistent yes these people have a lot
of time but they're not that smart don't
given that much credit they're
persistent they use tools and use the
basic flaws that you have in your code
and we have in our code so it's arson
picture uh it's not a cavalry man but an
infantry man this is the Sweden's
fictitious national hero Sven diva who
single-handedly held the bridge against
this ragtag army of Russian invaders
there's no similarity to the internet
world of course they can be from another
country than Russia but the thing is
armed with a little bit of knowledge and
daring you can hold the bridge against
this army of mediocre attackers okay
it's the 80/20 rule which we learned is
called the Pareto rule I think with 20%
effort you get 80% done okay so let's
get started I'm going to be talking
about trust setting the stage for the
rest of the talk I'm going to dive into
the the patterns along a second and the
first pattern or method I'm gonna be
talking about is called domain-driven
security it's based on domain driven
design which
I'm sure many of you are familiar with
I'm going to be talking about something
called the untrusted pattern I want to
be talking about immutability and
finally the weirdly named the inverse
life-coach pattern so let's get started
trust the foundation of software
security both words yes it is the
foundation of software security many
security issues if not most boil down to
a poor understanding of where we and our
code is are placing the trust so let us
take a look at a typical interaction
here how do we control we trust how do
we establish trust this these are
important things so here's a businessman
Bob he's at the bank there authenticate
themselves to each other and then a Bob
wants to transfer X heroes from account
Y to account Z and sure go ahead
so what could go wrong this is just like
a typical thing you have an
authentication step and they have an
action that needs to be performed what
could go wrong here yes so first of all
let's look at the actual authentication
how does how can the bank be sure that
Bob is indeed Bob and how can Bob be
sure that the bank is the bank and when
he wants to transfer the money how do we
know that Bob owns account why do we
know that account why holds the amount
that he wants to transfer in fact yeah
and in fact do we even know that X is a
number is it a or minus 1 or foo or
something so depending on which side
you're on you can really get screwed
here Bob could screw the bank or the
bank could screw Bob so let's visualize
trust as a circle of trust and as an
application or API or whatever we have
all this stuff that is outside the
circle of trust you have the user
definitely not trusted you have the data
that's coming
you have the database you have third
party services and
etc etc and there is a trust boundary
here what that means is that everything
outside the trust boundary is untrusted
and everything inside is trusted and so
I'm gonna burn your eyes out with this
slide here it's gonna be on your retina
for the next 30 minutes so this is
really simple and and but an
illustrative slide has some many
important concepts one is that the
trusted area is bounded it's small we
can enumerate everything inside the
trusted area whereas the untrust is
unbounded it has no limits it's so much
larger and meaning that this is why
white listening versus black listening
doesn't work I'll be talking about that
a bit later white listening is where you
enumerate everything is allowed whereas
black listening is when you try to
enumerate and list everything that's not
allowed just by looking at this you can
see that black listing does not work
because everything that's not allowed is
practically infinite so that's why we
should do white listening / black
listing but then after all how does
something from the untrusted area become
trusted after all we need to work with
all this data otherwise our application
is useless well through every developers
favorite activity validation that's the
most fun part of your application it's
the first thing you start to do when you
write knew that nothing new features
nothing like that you start with the
validation maybe not but the thing is
validation is your tool to make sure
that you have trusted data so two things
can happen either your data is valid
it's in allowed inside the circle of
trust or it's not valid it's rejected
and bounces out so validation there's
some different types of validation we
have there what will you normally think
of validation meaning that it's the data
valid in the domain like we can't
transfer a euros or minus one
there's also canonicalization and
normalization
I think canonicalization is like C 13 N
or something if you want to be cool but
this these are things that must happen
before
or validation here you see a potential
path traversal attack as it's called
maybe in letting people upload stuff to
public file upload but some attacker
sends a file with the file name dot
slash dot dot slash secrets keys so your
operating system is going to collapse it
to see secrets keys but if you validate
this and say that yeah it's going to
public file upload you will be the
victim of a path traversal attack
so that's normalization has to happen
before validation then there's
sanitization where you clean up
dangerous or unknown data and a textbook
example is log injection you all have
logging on your websites and if someone
enters a value that I really don't
recognize maybe you say ok I got this I
expected X euros but got minus one and
then you log the minus one how do you
know that user doesn't type into a new
line and a total new row of logging that
way the the malicious user can actually
insert rows into your log so you have to
clean up the data that's coming that
you're logging also it's that's
sanitization now validation I mentioned
this before always prefer white listing
over black listing remember the image
it's easy to you cannot know everything
that's not valid but you can know what's
valid and another thing with strict
validation besides being a security
thing that makes your that move stuff
from the untrusted to the trusted side
it helps you find bugs early instead of
you know getting an exception eight
layers down in your code and spending
half a day trying to figure out and
pouring over stack traces if you had
caught it up here where it entered your
application you would have seen that all
this value was minus one or a is not
allowed it could have saved you all that
time so it finds bugs early if you fail
fast so every time you you validate
something you wanted to ask yourself
okay
what is the minimum acceptable range for
this parameter and make your validation
not accept any more than that because
it's always tempting as a developer to
say okay okay I have an account number
it
today it's supposed to be ten digits but
I know or I think I know that you know a
few months or half a year management's
gonna say you know now our account
numbers are twelve digits or fifteen and
I don't want to you know release this
code again and how to have them
complaining that stuff doesn't work
anymore so I'll just allow hundred
characters for the account number don't
do that be be safe and say that this is
what I know right now and this is what
I'm gonna validate so that's a briefly
about trust and validation so without
further ado let's get our hands dirty
and look at some code domain term
insecurity how many in here are are
somewhat familiar with domain driven
design hansip okay good that's almost
everyone yeah how many know what the
domain model is just a domain yeah it's
it's not hard domain is just like the
objects in your solution if I'm working
with a bank I have an account I have a
user I have money and you know that's
those types of objects and domain driven
design talks about how these objects are
related to each other how you create
them how you save them how you
manipulate them etc so domain driven
security is domain driven design plus
some conventions for validation it's
really simple but profound pattern and
the thing with this is it helps us with
a trust boundary and it gives us
validation everywhere in a good way so
domain driven security was coined by two
developers at Swedish company actually
called Omega points so I haven't made
this up to myself at all none of these
patterns I've made up myself I just
collected them okay so let's look at our
interaction here again here's Bob again
so Bob is coming back to the bank the
bank trusts him and they forget to
validate now because well bob was
trusted right so but see what he's doing
now he's transferring a - ten - thousand
euros instead from account white account
C and Bank says sure fine why not
I've already validated you I trust you
everything's fine and caching
that's ends up with this note in his
pocket so the thing with validation is
that you are painfully aware of that has
to be performed over and over right and
because of this it's easy to forget to
validate somewhere and it ends up
everywhere in the code but it's still
forgotten somewhere and it's easy to
forget to validate something that you
think is trusted like an internal
database I mean a database you think
that all the data is coming from the
database
you know we control the database we
should trust it well there's something
called cross-site scripting which you
may or may not be familiar with with
people in where you can inject script
tags into HTML pages essentially running
scripts in the context of the logged in
user so you can store it if someone
inserts a script into your database and
you show it on a page you're the victim
of the stor cross-site scripting that's
the I don't know if you remember the
myspace worm
many years ago that was a cross-site
scripting attack and MySpace funny just
totally off topic here but I got an
email three days ago about a security
vulnerability in MySpace any one of you
get this also maybe I was yeah one guy I
didn't even know myspace existed anymore
apparently I had an account that and
they had an abbreviated the developer
maybe even more so so let's take a look
at the trust boundary again and see how
domain driven security can help with
this so back to the circle of trust so
if you have a regular validation of your
types you can still be secure like you
validate them you're inside the circular
trust everything's green but this is a
picture where it's green the problem is
you can't look at your code and see that
this string which is an account number
maybe or this integer which is a sum has
been validated there's no way for you to
see that in your code it doesn't pop out
so domain-driven security what that does
is that primitive types and
the structures are untrusted by default
if you see a string and integer a byte
array whatever that's being passed
around you know that it has not been
validated so we always use domain
objects and the special thing which is
the security part of domain driven
security is that all the domain objects
by convention must have built-in
validation they cannot be created
invalid that is the key convention here
they also a good thing for them to be
mutable we're going to talk about that a
little bit more later so with the domain
objects or circle of trust
looks like this instead we have inside
the circle we have the domain objects we
don't have the primitive types we don't
have strings integers floating around so
a string containing an account number
turns into an account object an integer
which is an amount let's see yeah it
works turns out into an amount object so
inside the trust boundary only the
validated domain objects are used and
here's an example of the typical domain
object then you have your account number
which is C the key part is that upon
creation it's validated right you cannot
create an invalid account number there
can never be an invalid account number
being passed around and used somewhere
deep in the deep in your code because
you will catch it immediately upon
creation that's it that's the main
difference security that's the whole key
okay and notice also the final key
eruptive I'm gonna discuss that a little
bit more later meaning that it's
immutable so that's it you have if you
have a domain model applying domain
driven security is easy okay you just
add validation to your domain objects
you have to of course remember to do
this it's not gonna happen automatically
but after a while it becomes second
nature and if you see a domain object
without validation you're gonna react
and say what's this this is strange so
if you have a web service in circle of
trust you have a soap call integral
strings bytes coming in you get your
user object get your account object but
if we get some invalid data it's just
going to bounce off and as
exception so you know you know that
everything inside your circle it's gonna
be fine and you're gonna be happy they
don't have to worry about it
another thing that domain-driven
security does for you is that it
immediately tells you when you forgot to
validate something so here you have the
reticulate function which reticulate s--
a spline and some certain angle but you
know what's going on here in angle
that's in here what is that angle can it
be negative can it be how large can it
be is it in radians probably not since
in an integer but still there's nothing
telling you anything about this angle
here it's just an integer so this is
what it should look like the angle
should have its own domain object I
think this is a good example because it
shows that even such a trivial thing
such an as an angle should have its own
domain object maybe you're not thinking
this way that this is it's not worthy of
an object it is it's cheap and easy to
create objects so let's go ahead and do
it so anytime you see something not
being a domain object in a function a
public function in your class you know
that you forgot to validate something so
in the first example like if you don't
have validation in the domain object now
reticulate would have to remember to do
the validation you would again get this
validation spread out everywhere in your
code another another thing is that
domain driven security or domain driven
design actually helps us lean on the
type system so here you have something
that heats
heat something up for a certain amount
of time to a certain temperature maybe
it's a reactor right so we want it to
boil for five minutes
which would probably heat Otto Amsterdam
four or give it electricity four I have
no idea I'm in it maybe but is this
really what's gonna happen here you see
anything wrong with this yeah yeah it's
not gonna boil for five minutes it's
gonna be at five cool degrees Celsius
for about a hundred minutes so everyone
is everyone's gonna start complaining
over how nuclear energy doesn't work and
we should go coal instead and because
that's much better so yeah of course
this is what you want
here we have proper domain object the
type system will tell you during
compilation if you're calling this
function with the object switched so
that's robust and rugged I think and it
helps you with security
so another thing when you use domain
driven security for a while
um seeing validation outside of domain
objects oh boy almost becomes like a
code smell so here you have something
you pick up a account number for a user
from the database so we do some
validation first throw an exception and
but if it passes the validation we say
ok we transfer it but compare it to this
so what we would do is we would new up
an account number and then we would do
the transfers much cleaner much easier
to read and we know by convention the
validation will be done in there so the
code you know it's transparent to the to
the successful path use case while still
protecting you from the from the bad
paths so don't be afraid to create
objects by the way how many are c-sharp
programmers in here okay and Java okay
mostly Java right and anything else phew
yeah it's still I think yeah Java is
gaining a bit on c-sharp I've been
asking this Christian for a for a while
cool well I'm maybe in Java myself now
after a long time with c-sharp so so
let's reiterate this essentials of
domain-driven security you know by
convention that all domain objects are
valid because you that's the convention
you have to validate them and you know
that you forgot to validate something if
you see primitive types being passed
around like the angle we have there the
heap and the duration which were in
figures in the example that's where the
type system comes in and insurance that
the correct domain object must be used
and of course there's still a lot of
validation that does not fit inside
inside the domain object there's still
business rule
like this this user allowed does this
user have access to this entity or
whatever this stuff of course you still
have to validate maybe there are some
more domain objects that can pop out
that you can put your validation in but
there's not a place for a domain object
everywhere there's still a bunch of
validation has to be done but at least
you know that the basic building blocks
of your application are valid you will
catch these validation bugs early you
will not have them explode down here in
the database or close to it
you will catch them up in the you know
the first service layer you have and
there's one more thing that I want to
talk about here which sort of shoehorn
into the domain during security design
it's a question about null what do we do
with null
what is null now that's a construct that
some languages have as languages which
use a reference type which is where you
need to denote that this is an invalid
reference a reference that has not been
instantiated or assigned to an object so
some languages these days do not have
null because the dangers of null have
been realized null is an invalid pointer
it causes exceptions it's just a bad
idea so never use null in your code do
not write the word null unless you're
doing a null check in your domain object
saying that I'm constructing this from
something and it that's the thing that
I'm constructing it from should not be
no what are the reasons why you would
want to use null typically is oh this
value might not exist I'm picking
something up from the database it
doesn't exist
I'll just return null well returning now
and pardon me is like returning a bag of
burning dog crap okay if the person know
the code that gets this burning bag
manages not to get hurt they're still
left with a disgusting smelly object
that they now have to handle you know
don't be that person that gives someone
else a burning bag of dog crap okay
so make it explicit Java has this type
the optional of this is in Java 8 now
this is and this is just the c-sharp
example of what it would look like it's
a really simple class it's a generic
that you can wrap your object in and you
can ask it is it present if
is present you can get it if you try to
get it when it's not present you'll get
then you'll get an exception but this
makes your code really explicit and
clear saying that's yes when I picked
this value up from the database I don't
know if this user or account is gonna
exist or not so it's an optional of the
user it's not a user object that could
be null and you have to sprinkle your
code with null checks and end up with
burning bags of dog crap okay just have
to see short passes construct this
nullable for primitive types which is
used for the motivation for this is to
use for databases basically the days of
databases work a lot with null that's
fine and in the fringes every
application the UI layer maybe you're
dealing with radio buttons at keys and
all also and down in the database where
you're communicating with it it's
convenient to have this but do not use
it in your your domain do not use it in
your August I don't want to see this
floating around in your obviously just a
new way of adding null to your
application it's like no 2.0 now you
have null for primitive types yeah so
don't use that unless you have to unless
it's very convenient at the fringes of
your location your application the other
example the other typical example we're
returning null is tempting is when you
get instead oh this this shouldn't
happen you know how weird I'll just
return now no don't return now if
something is an exceptional circumstance
in your application while do go ahead
and use the aptly named exception and
throw that instead don't be afraid it's
better you know what would you listening
to to the talk this morning about
self-driving cars would you like the car
just to say that I'll just return now or
would you like it to save stop something
exceptional has happened you know slam
the brakes that's what I would like so
here's an example and you see the
optional pattern at work here also so
you have some kind of repository you
pick up an account for the user so you
get an optional up here maybe there is
an account for this user maybe there
isn't and in this case it is an
exceptional circumstance that a user
does not have a default account this is
the default account repository it
shouldn't happen
but you know don't return null here
because we don't have an optional we the
caller of this code always expects
account to be valid or an exception to
be thrown this is the best way to do
this so when should you return now when
should you use it anyone anyone yes good
okay so that's trust and domain-driven
security domain during security is great
I've been using it and the project I've
been working on for two years now when
using domain during security and I can't
see myself going back so moving on the
untrusted pattern just I learned this
from a colleague of mine I don't know
where he got it from if he made it up
himself or if he got it from somewhere
somewhere else
so make trust a first class concept at
trust boundaries so then maybe you don't
have a domain model so you can't use the
main difference security maybe it's a
major surgery to introduce a domain
model into the existing code that you
have so where as domain driven security
gives us defense like in depth
everywhere there's validation going on
everywhere
the untrusted pattern soon's in on the
trust boundary itself it's like a
perimeter defense so let's take a look
take a look at this function foo it's
except some bar and string and it
validates it and then it does something
with it so the thing here there's a
trust boundary here because there's
validation going on we don't trust bar
we validate it and then we do something
with it well we can't see it really
besides their being in an exception
being thrown there's nothing telling us
how however where the bar is trusted or
untrusted so a simple thing we can you
do which is really useful it's just
renaming it if we know that something is
untrusted we'll just go ahead and rename
it to untrusted of and I know this
violates every naming guideline and
c-sharp but who cares this is really
useful
so first step annotate your your
variables with untrusted underscore and
it just becomes a lot clearer what you
trust and what you do not trust where
you place your trust so if you look at
this function here's here you have
another function that does something
with a bar and a frog may have some data
coming in but what's going on here do
why do we trust data obviously we don't
trust the other ones so we probably
forgot to validate this or something is
not right here so that's good it really
pops up help us see what's trusted and
not trusted you can clean this up you
know have a validate method that returns
this bar untrusted orthros if it fails
but we can do better actually there's
nothing here that forces us to perform
validation is just a rename it's easy to
just assign you know to call the
function do something with with an
untrusted instead with the on trust
because it's still a string we can use
the type system for this how about
something like this this looks better
right we have we have taken our string
and put it into an untrusted box and
what we want to do is we want to make
sure that we cannot get the string out
of the untrusted box without doing
validation so how can we do this let's
take a look at this untrusted class so
it's just a simple generic wrapper here
just holds the value and as a getter you
can get the value out of it does anyone
see anything weird with this object does
it seem useful you shaking your head
sorry yeah there's no getter really is
there is if there's a private getter so
there's no way of getting the value out
once you put your value into this
untrusted box it's just gonna stay there
forever so how do you use this well
c-sharp has this thing the internals
visible to assembly direct them
assemblies in c-sharp it's like sort of
like jar files in Java it's the
packaging unit for for classes and you
can tell one assembly or you can say
that me my me as an assembly I would
like to have my internals
visible to this other assembly so if you
in the assembly that contains the
untrusted class have a director that
says that my internals my private
methods private classes should be
visible to the validation assembly then
we can have meanwhile going on in the
invalidation assembly a validator which
you can which has one method called
validate which takes an untrusted value
and does a uses or template method here
abstract method called inner validate
where it can get the value because the
internals of the untrusted class are
visible to the validation assembly so
the validation assembly is the only one
that can get the value out and now you
can construct your own validators from
this base validator you just have to
inherit from this validator and put in
the same assembly and he can do stuff
like this so you have an untrusted
coming in it's really clear you look at
the code yep untrusted it's in the box
we can't access it unless we run it
through a validator so we have to write
an account number of validator we have
to round write a validate method so
there's no way you can forget this of
course you can just write a do-nothing
validator that just returns to the
object that's you know then you're
shooting yourself in the in the foot
aren't you
so quite useful it prevents you from
forgetting to do validation makes the
security boundary the trust boundary
clear and forces you to do validation so
the thing is of course you have to write
some glue code to get this going you
have to recognize where you trust
boundaries and you up these objects
anyone want to work with the C++ here
yeah if you this pattern is really
suited for C++ it's better because C++
has friend-friend classes which make you
can make the visibility thing more
granular instead having the whole
assembly open and it also has implicit
constructors meaning that you don't need
a glue code the compiler will figure out
that there is a way for me to construct
an untrusted object and pass it into
this function so the glue code is needed
so if you're doing C++ take a look at
this pattern
so that's the untrusted pattern so we
talked about trust domain Dermer
security and the untrusted pattern I
have to drink some water
next up immutability what is
immutability means that something can
change something that is immutable does
not change it's it's the opposite of
mutable which means something that can
change so stuff passed over a trust
boundary regardless of direction should
not be able to change later why well
that's your application handle
concurrency maybe you have many threads
how does that affect validation if the
thing you just validate it can change
will it still be valid
how many heard of this time of check -
time of use one good one hero - you're
all about to hear about time of check
the time of use talk to if you will
you've seen this a billion times it's
everywhere but it's probably you haven't
thought about it
here's a typical talk - case here's a
time of check we check if this is a this
account contains the amount of money
that we wants to transfer and then we
use it time of check - time of use now
you can have problems here
what if amount is it's mutable it can be
changed and we have a multi-threaded
application well something like this
could happen after we've done the check
another knot a thread that's we're using
for some reason and then an attacker has
figured out that he that he or she can
bombard the application with calls
setting the value to a million euros and
if timing is right this set value the
setter will be called just after the
check but before the use so even though
we have a check we're still vulnerable
because the amount object is not
immutable it can change and it can be
changed by another thread so even though
we think we're good citizens and we've
checked this we're still going to get
screwed so how do you solve this well
make internal stay
immutable final that's the final keyword
in Java read-only in c-sharp and get rid
of those setters
there's no setter here and I know that
Java and c-sharp they're not immutable
languages intrinsically there are
languages nowadays and particularly the
functional languages which we're
immutability is like a first class
concept forces you to to have everything
immutable and if you want to some make
something mutable you'd have to jump
through a lot of Hoops maybe it you
can't even do it but that doesn't mean
you shouldn't strive to juice
immutability in Java or the you know the
normal object-oriented languages it can
be done it's not like going against the
grain it can be done it's a little bit
more complicated than it should be
but it's definitely worth doing so
because immutability significantly
reduces talk to problems as you see it
plays very well with domain during
security readability parallelization
event sourcing etc etc immutability it's
a great thing it's like a security spray
they can spray over your code and you
have a lot less problems who how many in
here knows what a race condition is yes
yes right everyone then you know that
race condition is that if the outcome of
some operation depends on the ordering
or sequence of events that are outside
of your control they race against each
other then you have a race condition
let's see a typical web example here of
this imagine a wizard base flow like you
have a shopping cart or maybe something
on your website it's like a three-step
flow so in the first one the customer
goes to the first page yeah that's a
step one okay first I just want to
mention here yeah static all your
concurrency aware people you think oh I
should net would never have a static
variable in my web application that's
crazy but you can imagine that you have
some sort of dependency injection
container that that is a singleton
instead this class then this would just
be a regular member variable so it
wouldn't be that obvious but you can
still end up with these situations where
you have in fact a static or a singleton
so in the first step
the user comes into the application you
assign some key I can grade or a UID in
Java and you create some wizard data
this holds the stuff that's you need to
keep track them doing the transaction
and then you return the key so that the
user can supply the key and the query
string perhaps in the next call second
step is that you you choose a product so
you set the product ID here to some
product that the user chooses and the
third step is sort of like the checkout
step ID you pick up the The Wizard data
you see that ok does the user have
access to this product can she buy this
product and then you do something with
and here you have the time of check-in
time of use thing going so it's easy to
see where this is going just so anyone
can see what's wrong here what can what
could go wrong how can a malicious user
a knows that the code looks sort of like
this what could she do or he what what
if we do this what if the user bombards
our application with calls to two step
two with some other Product ID that he
knows about that he shouldn't have
access to but right before checking out
you just just blasts the application
with calls to step two and maybe if the
timing is just exactly right it will end
up after the check but before the use so
the this user will get access to this
secret product that she wouldn't have
access to so how do we fix this
immutability of course let's look at it
again looks pretty much the same only
now we have something called immutable
data up here step 1 everything is the
same
just immutable data step 2 here's the
difference if something is immutable we
can't change it
there's no setter for this this product
so we have to create a new object so we
have written a convenience method called
clone with Product ID meaning that it
takes all the properties that this
object has clones them and then with a
new product ID you can imagine that
there's other properties on this object
except the Product ID step 3 looks
exactly the same
there's no
thing nothing changed here and there we
still have a time of check - time of use
where we we always have that but now we
have no problem because the data is
immutable doesn't matter how many
threads are try to change or a call step
to in between here they'll just create a
new a date object that is not being used
right now in step three so we're safe
nothing will change between time of
check - time of use so immutability like
I said a security spray it's a great
thing it helps you with security and
bugs and concurrency in general go for
it use the mutability as much as you can
it should be the norm when you see an
object that is mutable you should uh you
should cringe and feel bad because you
know this is dangerous what you can do
is of course something has to be
immutable sometimes somewhere probably
something needs to change but try to try
to contain it try to minimize it maybe
have a larger object where if you have
20 properties maybe only three of them
are mutable well factor out the mutable
object and and keep it isolated so you
can have it you know where it is and you
know where the mutable state is and
Mabley it can be refactored later or at
least you have better control of where
the mutable state is it will help you a
lot so that was immutability now let's
talk about the final pattern which we're
going to talk about today it's called
the inverse life-coach pattern be a
pessimist okay so what's the inverse
left life-coach pattern before we look
at that we have to look at the anti
pattern which is called a life coach
pattern it looks something like this
you'll seen and maybe written a function
that starts like this and you can just
hear the life coach hear you my friend
you have done nothing but you are a
success your life is gonna be great no
matter what happens in bunch of code
here we're gonna return and you're gonna
be successful and even if you do I'm
still gonna charge you that's what's so
great about being a life coach it's
awesome so what happens here what can
happen here of course is that something
goes wrong in here
and you returned prematurely and success
is still true the client of your code
will think that everything went well
when it didn't this is sort of what
happened the what's it called goto fail
if you remember that a few years ago us
on OS X go to fail Baggett bypassed the
certificate validation was a case of the
life coach pattern so this is what it
should look like should be a pessimist
you you have not done anything you are
not a success yet you have to prove
yourself in bunch of code you have to go
through it and maybe if you're good you
get out on the other side as a success
of course we used this is not a very
domain sorry object-oriented example we
use objects instead fail fast and force
a narrow path like success
fail fast meaning that if you try to do
the validation first and if something is
not valid you throw an exception there's
a bunch of code happening and then you
return the data and the only way of
getting out of this function is
returning a valid domain object there's
no success true or false parameter here
either you throw an exception or you
return a valid domain object there's no
other way to do this so when you apply
this this pattern to your code your code
is going to start look a lot like this
you have the some validation if de da da
de yada yada throw if not this then
throw this not this and then throw code
happening and return I'm not saying that
you should always use a single return
statement that's not one saying multiple
routes return statements are fine in the
languages that we are using but I'm just
saying that if your code looks like this
it's probably good if your code looks
like this it may be it's not as good I'm
not saying it's definitely draw I have
functions that looks like this and that
are perfectly fine but still you know if
you use this pattern you're gonna expect
your functions to look a lot more like
the previous example where you have
these sections of validation they you
have the code and then you return
something so give yourself you give
code a narrow challenging path of
success where you either throw an
exception or you return a valid domain
object that's the inverse life-coach
pattern
yeah so we have about 10 minutes that's
good I'm gonna wrap things up I have
there are five things to take home with
you from this session consider your
trust boundaries that's the important
part
see many security issues boil down to an
poor understanding of where you're
placing your trust you want to minimize
where you place your trust you want to
trust as little as possible you're in
inside the circular trust everything's
trusted outside its untrusted the
untrusted area is practically infinite
where the trusted is bounded and you can
control it with whitelisting
domain-driven security a great pattern
if you have domain driven design already
in your application go ahead and look
into domain your insecurities you're not
gonna regret it
only about a domain objects no primitive
types they're untrusted it's very easy
very simple but it has a profound in
fact impact on your application it will
give you defense-in-depth immutability
should be the norm try to make all your
basic immutable if you see something
mutable
you know think deeply does this have to
be mutable it's a really a reason or is
the is there an immutable object that
wants to get out of this for me try to
use it everywhere in your application
use the Builder pattern for instead of
setting properties in your constructors
instead of nearing up an object and then
setting ten properties use a builder
pattern that lets you build it in a nice
way and then creates an immutable object
yeah now that's a big bag of don't use
no use optional throw an exception if
something is an exceptional circumstance
don't pass around null okay now let's
say it's a construct that some languages
need to have doesn't mean you need to
use it okay and last but not least fire
life-coach you don't need them okay it's
better to be a pessimist and assume
failure and force a
path of success and I'd like to conclude
here with the words of Jesus Christ our
Lord and Savior I think said it best
when he said for the gate is wide and
the road is broad that leads to
destruction but the gate is small and
the road is narrow that leads to your
code returning a valid domain object
that's what he said it's true 2000 years
ago and few are the code paths that find
this gate so I want to thank you very
much for listening and I hope you
learned something that you can take home
with you and apply to your code
immediately and gives you a robust
rugged and secure code and please
remember rate this session and if you
want to contact me you can tweet me and
there's we have a blog truseq which
where we write interesting stuff
I think I'm not biased at all so yeah
and thank you very much for listening to
me thank you okay fortunately or
unfortunately too many questions via the
app actually fortunately but we cannot
ask them all so please ask andreas
afterwards I just picked three the idea
of the main model for passing parameters
is good but it is or it also produces a
lot of memory overhead how can we
balance that well I think you need to
ask yourself is memory over had a
problem for application these these are
typically short lived objects easily
collected by your garbage collector not
not usually a problem if you're working
with maybe trading or games we're also
exceptions is a problem performance wise
as well as objects yes maybe you have an
issue but then you're probably
programming in C++ anyway I I think that
you you the question of performance
always comes up right but it's always
easier to do
we're so keen on doing premature
optimization so that's why I say don't
be afraid create a lot of objects I
don't think it's gonna be a problem if
you have a typical if you have a special
domain where this is the problem
fine you know you need to deal with it
but most maybe you think you do but I
think it's more likely that you don't
that's my answer
okay mm have you used immutable stock
while implementing the main driven
securities nope
what if a domain object can't validate
itself because it has dependencies
whatever the minimum you can't validate
itself because it's dependencies well I
don't know what dependencies that might
be you're not calling a service from a
domain object that's all you can pass in
a service
well the main obvious I do usually can
validate themselves I sir can creat the
person ask the question maybe have a
concrete example yeah we can talk about
this afterwards the question but the
dependencies that your domain objects
have should themselves be validate
already if they are domain objects so
usually it works out okay and the last
one the domain objects you showed they
are actually value types okay yeah angle
is more of a value type okay yeah good
okay that's it
thank you very much thank you thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>