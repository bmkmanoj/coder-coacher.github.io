<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • What our Brains can Teach us About Software Engineering • Julie Pitt | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • What our Brains can Teach us About Software Engineering • Julie Pitt - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • What our Brains can Teach us About Software Engineering • Julie Pitt</b></h2><h5 class="post__date">2016-10-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5whMQwyW9Zw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well I really appreciate all you being
here it's good to be back for the second
year in a row today I'm going to be
talking about what makes software
projects so unpredictable and what we
can do about it so you may have noticed
this is the deep learning track and I'm
coming at deep learning from a bit of an
angle and that is that if we can
understand how the brain works that will
a help us human self problems better but
be it might also shed light on how
machines might solve these problems in
the future and being an engineer this is
kind of the area i'm focusing on how do
we become better software engineers so I
should remind you before I jump in to
please rate because I loved at your
feedback and there will be a couple
questions couple minutes at the end for
questions and also I'm going to be
mentioning a bunch of projects blog
posts etc so don't worry I have a github
link up here that has all the links the
in detail there so feel free to follow
along there so just want to tell you a
little bit about myself first Aristotle
once said that for the things that we
have to learn before we do them we need
to learn by doing them and so the
question that I'm wrestling with is what
is intelligence how does it work and
what is in particular the simplest
possible way we can describe
intelligence that is confirmed by what
we see in the world around us and also
that we could confirm in science so the
way that I'm tackling this question is
in 2014 i co-founded a company called
order of magnitude labs and so we're
learning about intelligence by
attempting to build intelligent machines
and through this process I've started to
kind of take a step back and thinking
this through and it's led me to start to
see the world in a new light and being
in a software engineer I've kind of
applied this thinking the software
engineering and come up with kind of
some different angles on it that I hope
to share with
today so we're going to discuss a big
reason why software projects are
unpredictable we're going to talk about
how we can better help computers
understand what we mean and how can we
help them become more resilient more
self-sufficient in situations of stress
that we didn't necessarily predict and
lastly to close the loop how can we
better understand what our software
systems are doing so we're going to
start with a little story and stories
about an egg it's very short because the
egg can't really do anything it's just
sitting there so along comes this
spatula and the spatula takes the egg
and turns it into a scrambled egg so
that's kind of sad because there was
really nothing I could do so let's do a
little thought experiment what if that
egg instead had a face so it could look
around and see the world around it and
then we add one more ingredient it has
legs so it can move around and see the
world from different perspectives so now
if we add a third ingredient let's say
the egg has a brain that same spatula
comes along the egg is going to see it
coming along and then it's going to run
away so it's going to prevent itself
from becoming that scrambled egg and in
my mind this is really the simplest
description I could come up with for
life so really the main ingredients for
life are you have a set of senses and
actuators if you were at the keynote
this morning you might have seen that
this is pretty similar to to what was
talked about there with having actuators
sensors and the bit in the middle is
really computation but what I'm
describing to us is as a generative
model and so the generative model
essentially interprets what's coming in
through the sensors and it's generating
perceptions about what's what it's
seeing
and then it's also generating action as
well and in some sense this is really
all we need to survive so we're trying
to navigate this imaginary bubble up
here that entails are predictable happy
States this is really our survival and
we use our generative model to find
where is the boundary and how do we stay
within that boundary because we want to
be here in the survival zone we don't
want to be out here so the neat thing
about this is we are creatures that have
evolved over millions of years and we
have very developed sensors that are
going to help us stay inside that bubble
with very little cognitive effort so for
example if I see a tiger coming from 200
yards away 200 meters away i'm in Europe
then I don't have to stop look and go
hmm what is that what should I do about
it because by the time that amount of
time has elapsed I'm already running in
the other direction so what if you are a
particular kind of human though what if
you're a software engineer and your job
now is a little bit more complicated
because not only do you need to survive
but you need to map out a magic bubble
of working software and you need to stay
out of this zone of not working software
except the problem is you don't have a
highly developed set of sensors that
have evolved over millions of years to
immediately tell you in a blink of an
eye oh this is working software and this
is not working software no instead over
the years as you've developed your skill
of engineering you have created a set of
heuristics a set of if you will high
level sensors in your brain that are
going to tell you with some mental
effort whether something's working or
not it's a good thing that our immediate
survival usually doesn't depend on this
but some in some situations it actually
does so so here's the thing
as an engineer you actually have one
level of indirection added to to
challenge you a bit the software that
you write itself is can be thought of as
a generative model of sort in that it's
taking input coming in from the world
that maybe other software system is
interacting with and it's generating
some output that needs to have some
behavior that matches what you expect
but there's something different about
this generative model than your brain we
all know that code and brains are not
the same thing I think a key difference
in my mind is that the generative model
is infinitely precise so you misplace
one character the entire meaning of your
code can change there's no tolerance for
sort of noise and uncertainty that we
all can interpret in our brains coming
from the real world so I'm going to come
back to this point in just a couple
slides so imagine you're the typical
software engineer and your boss comes in
and says oh we need to add this new
feature to our product so okay I'm going
to think about that you spend a couple
days working out a design their
colleagues challenge you with questions
I was this going to work is that going
to work and every question you can
answer and you realize this is going to
be great so you start implementing it
and pretty soon you're in the zone you
lose all track of time and you're just
imagining how great this feature is
going to be once you release it to
production so finally that big moment
comes the moment of truth and then this
happens oh my god what happened I did
not tell the robot to kill people that
is that is absolutely terrible so what
happened is you thought that you are in
this happy little zone of hey everything
is working and everything is fine but in
reality you are way out here right and
then this is in part because you're
working indirectly through this
generative model called code without the
use of senses to guide you so let's go
and look at this code
raise your hand when you see something
wrong with the code that was written
there all right somebody okay see a few
hands all right so if you didn't notice
this is most likely see code based on
the syntax and this here is an
assignment operator and that's sexually
a really bad thing in an if statement
some languages wouldn't allow this to
compile so unfortunately you're always
going to end up killing humans so I want
to point out a couple things about this
coat first of all I don't think any of
you within a couple hundred milliseconds
of seeing us except maybe that one guy
over there I was pretty impressed at how
fast that hand what up I don't think any
of you would be able to say ah oh my god
the code is not working I need to run
away because there's going to be
murdering robots this is awful right you
had to step through spend a few seconds
thinking through you know what could
possibly go wrong and what the nature of
that is the other piece that I want to
point out is that you know a single
character here was missing this is
exactly what i mean by infinite
precision right you're trying to create
some behavior in this robot but one
thing goes wrong and you're falling off
the cliff so contrast that with human
level precision if i'm going to give
instructions to a human I could tell
them something in any number of ways
maybe even an infinite number of ways
all right be nice to people respect
human life don't hurt people right that
person if they followed my instructions
would probably end up not killing human
beings right we we live in this noisy
limited precision world and we our
brains our generative models don't have
any problem with that but if you're the
computer you have to be right on target
because if you're here you're going to
end up with these crazy murdering robots
oh my god so here's another way to look
at it okay usually the first thing you
think about when you're designing a
system is what is the happy path right
and if you think of that and nothing
else you're going to wind up generate
something where the landscape looks
something like this happy happy happy oh
my god utterly broken right this is
really the cliffs of infinite precision
that we really want to avoid so all is
not lost though because we can change
the landscape a bit what we'd rather
have is a model where we think of sort
of the top of a gentle slope with
optimal States up here and when when the
noisy chaos of the world comes in you
descend the slope in a gradual way where
you're degrading and not only that but
without human intervention your system
will be resilient as in it can climb
back up to the top with us with these
optimal states when the stress goes away
so today I'm going to talk about how we
can do this we can't make the computer
less precise but we can cheat so several
ways we can do this or we can we can
think of testing in terms of testing
properties we can do remedy first design
you probably have no idea what that is
to like talk about it and we can build
intuitive insight so these are just
several ways to get you thinking about
how can we change the landscape of the
software that we produce so let's talk
about property tests so imagine that
you've never seen a rubber ball in your
life and somebody hands you a tub of
rubber balls they just say hey do you
know fiddle around with them and see
what you think so you start picking them
up some are big some are small different
colors and sooner or later you drop one
on the ground and you notice something
odd happens it bounces and you keep
playing with the balls and eat and you
drop another one and that one bounces
too pretty soon you're throwing them on
the ground going wow this is neat they
hold bounce a week goes by and your
friend has a ball and you say hey can I
see that you pick it up and it bounced
so what did you learn here you learned a
property of rubber balls that they
bounce you didn't need to see every
single rubber ball in the universe to
kind of have this idea that if you pick
up a ball it's going to
what you didn't learn is hey you know
this blue ball bounces that red ball
bounces know you you were able to
generalize to a higher degree so what we
can do is take this idea that that's
very natural and how we learn how we see
the world and apply it to how we do
testing which will have a ripple effect
into how we even think about our systems
as we design them so I'm going to take a
slight detour until we get back to this
point hopefully it'll become clear in a
few slides so getting back to the notion
of code being a generative model well
your test is code that you wrote and so
in a sense it's a generative model but
what is trying to generate in this case
is actually training examples so if
you're training a neural network as in a
supervised fashion right you want to
give it a bunch of inputs X and you want
to change the weights so that it will
produce some test outputs why
essentially so instead of say doing
brought back propagation gradient
descent on a neural network when it
comes to test suites or we're providing
test results that we give to humans to
train the humans to write better code
essentially so when you start to think
of testing in this way you kind of start
to realize hey if we just do unit tests
and nothing else there's kind of a data
problem because the way most unit tests
are written is oh well I'm going to hand
code a specific training example if you
will and i'm really going to cross my
fingers and hope that it represents this
larger bubble of state or behavior that
we're trying to test so let me give you
an example this comes from a fantastic
blog post it's about property testing in
f-sharp but you don't have to be doing f
harp to get a lot of value out of it I
don't know F sharp myself so this test
is essentially trying to test a function
that adds two integers nothing exciting
but it only provides one training
example right one plus two
I expect to get three back so your test
passes and you deploy to production like
yeah it's all going to work but it fails
spectacularly so what went wrong here
let's go back and look at the test that
we actually wrote or the code that we
actually wrote and we find that wow you
know this does not this is overfitting
essentially right you what you're saying
is well when I get the training example
the test that I wrote I'm going to give
it the right answer and any other answer
you know who cares so really all you
would have to do in terms of your tat
your training examples to find the bug
is kind of just take a one step to the
left and you would find that something
was massively wrong all right this
happens all the time if your unit
testing right you think that this one
example you came up with is
representative and in fact it's not so
let's change the the way that we frame
the problem and let's go back to that
idea of property testing right we want
to be able to think of our systems in
terms of the properties that it adheres
to we don't want to have to say well you
know pick up this blue ball and should
bounce pick up the red ball should
bounce we want to be able to say no any
ball that has these characteristics on a
hard surface is going to bounce so what
this does is it frees you up to generate
very easily using let's say random
integers in this case a massive set of
training data and you can surround your
bug with your test so what we're doing
here please take a random integer and
we're saying hey let's test the property
that you take the number X NEX add zero
to it and you're going to get that x
back right you can imagine maybe we're
going to test the commutative property
no okay all right so so maybe we're
going to test the commutative property
and swap the order of the operands so
when you start thinking in terms of the
properties it it better matches the way
that we
experience the world and it's more
tolerant to sort of noise in the
training examples right no matter what
training example we throw at it this
property should hold true and if it
doesn't then we have a problem so let's
review we can think of our test suite as
generative models they're generating
training examples for the system that
we're testing and if we do if we're able
to describe the properties of our system
then we will be able to do a lot less
effort to test and we'll get a lot
better coverage that matches kind of
this noisy uncertain nature of the world
right we can we can generate a much
larger training examples so let's talk
about remedy first design and again this
is best described in terms of real life
experiences so imagine you're standing
in the middle of the street and all of a
sudden a large heavy object you can see
out of your corner of your eye is coming
toward your head so time for multiple
choice quiz would you a turn look at the
object try and determine what it is what
its trajectory why it's flying at your
head where it came from or B would you
jump out of the way I don't know about
you but I would choose B because if I
choose B then a I'm maintaining my
original form I'm surviving and B I have
time now to go look well what was that
thing where does it came come from and
how do I avoid that and so we need to
start thinking this way when we r you
know designing building and testing our
software systems as well we want to
create software systems that are good at
jumping out of the way when these big
heavy flying objects come at them rather
than being fixated on well why did this
happen and how do we fix it right if you
can jump out of the way you have plenty
of time to go figure out why something
happened so let's go through an example
let's say you're writing a client to a
restful service and you have this
metadata request up here
and knowing nothing else about the
client or about the the API you get back
this error code huh error code two three
four what should we do about this let's
say you fiddle around a little bit you
find that oh if I retry it HAP you know
this doesn't happen again i get the
metadata back so you just add a little
hook to your client that says hey if i
get error code two three four let's just
do a retry so everything's good you push
to production but then something odd
happens you get error code 235 in
production and your client falls off a
cliff of infinite precision because you
wrote something in your client that
deals with a specific cause a specific
error code rather than kind of taking a
step back and looking at what remedies
you could apply so you go to the the
service team person that came up with
this API neyo hey what gives you know
where did this error come from and they
say you know when we design this API we
came up with a whole list of errors that
we thought were going to happen but then
we got it into production we found out
oh wait a minute there's other errors
that we need to start adding right
there's more causes and we want to have
insight into these causes and that's a
perfectly reasonable thing to do but you
say no way there's no way I'm going to
spend my time keeping up with adding all
these error codes to my client that's
like not a good use of my time so then
you both take a step back and start
thinking about it a little bit more and
you realize that if you reframe this
whole discussion to talk about how can
we get our client to get out of the jump
out of the way because guess what the
client doesn't really care if there's a
connection pool exhaustion on the server
the client just wants to do its thing
and serve the user properly so you start
to group these errors in terms of what
remedy can you apply in the moment so
that the client can make progress and
specifically I mean maybe there's some
set of errors that could retry maybe
there's some that you would want to do a
redirect for perhaps the user messed up
and you want to display an error right
it goes on maybe you want to reel CENTAC
eight so the beauty of this is that
there's far fewer
possible remedies then there are causes
it gets you out of the game of having a
predict what are all the possible things
that could go wrong on my system and
gets you in the business of how do I
react to failures when it's happening to
then buy me time to figure out whatever
causes happen so really the takeaway
from this is you added something your
guy added something to the protocol that
says oh here's an action the client can
just ignore this information the client
can just act based on what it's told to
do and then the server people can go
work out what actually went wrong so
these are application level errors but
there's a whole host of other errors
that are kind of below that level what
about things that happened in the cloud
for example if you're deployed to AWS
AWS has had its ups and downs and at any
moment there could be sort of a service
outage so for example in 2012 there was
such an outage it started with a failure
to propagate DNS changes that triggered
this latent memory leak the failover
didn't happen because the alerting
wasn't set up right and then customers
got throttled and services went down now
that is a very specific chain of events
that happened that I don't think any one
person could have predicted the timing
of or the specifics of Soviet fast
forward to 2014 there was a required
security update to about ten percent of
ec2 nodes and that meant to reboot so if
you're running a stateful application on
ec2 and you haven't come up with a
strategy to deal with reboots you might
be shaking in your boots at this point
another one happened last year there was
a dynamo DB outage a dozens of AWS
services went out and that took down
quite a bit of the internet so this is
kind of just to give you an example
diverse examples of different types of
failures that could happen and what if I
told you if there was one company that
despite making massive and public event
investments in AWS
was ready for all of these and was not
affected by any of these incidents so
that company was Netflix how many of you
guys have heard of simian army okay few
hands maybe after 30 you guys perhaps so
if you don't know what simian army is it
is an open source project by Netflix and
the goal of this project is to
deliberately cause failure in a
controlled manner in production okay
that let that sink in a moment what
deliberately cause failure in production
so the types of failure that it's going
to cause would be for example taking out
a random ec2 node taking out an entire
datacenter taking out an entire region
right these are kind of massive failures
there's another one that introduces
latency and the whole goal of this is to
validate whether systems handle failure
so it was around 2011-2012 that Netflix
really started putting this idea of
failure testing in production into
practice and I can say that that really
caused a cultural shift and that failure
became the norm it became a topic of
discussion at the very first design
discussions of a new service and I think
the most powerful idea about the simian
army is that it simulates the nature of
the failure right nodes go away all the
time data centers go away all the time
it doesn't try to simulate the causes it
didn't there was no knowledge of oh
there's this DNS failure and let's see
what happens when we trigger a DNS
failure it was very much more broad and
less precise and kind of acknowledging
the fact that we humans are terrible at
predicting specific events but we can
get a general sense of the patterns of
failure so just to review when you're
when you're creating a system you're
designing and testing it to do it with
remedies in mind think about how can you
jump out of the way of that flying
object
and and how can you buy yourself time to
go pick up the pieces later this is
actually a great thing because the
number of remedies is far less than the
number of causes and I urge you to test
your resilience during business hours
you may say that takes too much time I
don't have time for that well guess what
it's going to be tested for you no
matter what it's either going to be done
because you did on purpose or because
something catastrophic happened at three
in the morning and you got woken up so
let's turn our attention to intuitive
feedback we've kind of talked about you
know designing building testing our
system but how do we actually get
information back out of the system that
will help us point to whether there's a
problem or not and how to where to go
look next so the place that we want to
be is we want to be that guy standing on
the horizon looking out at the landscape
and able to see in a blink of an eye oh
there's a tomb of smoke over there let's
go look over there and figure out what's
going on so how do we do this today one
of the first things that a lot of us
tend to do is we add logs because
they're very easy to add to our code you
can produce a line a lot a line up and
all of a sudden you have huge log files
right okay so this is not my favorite
way of trying to get the lay of the land
because in my mind looking through logs
is kind of like you're watching a movie
one frame at a time through a keyhole
basically it's like well can you tell
what's going on maybe if you cycle back
and forth and maybe if you have enough
time but when you're in the moment and
you need to alleviate some kind of pain
point this isn't really going to be the
most effective use of your time and it
also doesn't use our highly evolved
developed senses it uses our heuristics
that we have painstakingly built in our
brains over the years that require a lot
of mental effort to process so let's
turn our attend
two charts this is a much nicer thing to
look at and it adds a new dimension
there's there's time here so you're
seeing a lot more compressed condensed
information you have some intuitive
expectations you know time goes from
left to right higher means more
different colors mean different things
great so you start adding a whole bunch
of metrics to your system you instrument
instrument like crazy because why not
why wouldn't you want that information
so now you have a new problem and that
new problem is wait a minute I have so
many metrics I don't even know which
ones to look at first right you might
have several different dimensions to
look at your metrics on and how do you
see how do you how do you look at these
in such a way that you're scanning the
landscape I would say it's slightly
better than logs actually quite a bit
better but you're still watching a movie
through a little keyhole this time you
have some sort of time lapse you can go
Oh hmm something's going on here so this
is what we actually want we want this
picture because all of you within a
couple hundred milliseconds was like oh
my god we need to go look at that guy
something crazy is going on she's okay
we don't need to worry about that right
now so there's not a whole lot that does
this yet but there's this really
interesting project and ironically yes
it's also from netflix this is an open
source project it's called visceral so i
want to show you this video that might
give you a sense for what i mean by
intuitive insight so what you're looking
at here is actually all the traffic
coming into netflix from the internet
and without any training you probably
figured out oh this there's fewer dots
here than there are here so there must
be more traffic going here and also
without any training you probably
noticed oh there's more red dots going
on up here something a little fishy is
going on right so you're using your
intuitive sense now you're looking at
and going oh that's interesting wow
there's there's little dots moving over
here maybe there's some kind of event in
progress and you can get this sort of
complex picture of what's going on but
at the same time you don't need to panic
because ok well the
error rate here isn't incredibly high we
don't need to like get all hands on deck
at this point so again it's leveraging
our low-level senses without requiring
tons of cognitive effort and so here I'm
inferring that what's happening is now
the clients have failed over right so
there's a very complex picture of what's
going on with very little effort on our
part to understand so I'm just going to
show you one more this is a view of an
entire one single region it was one of
those circles and each dot is a micro
service so I don't know anything about
what microservices these are but I do
know this looking at this wow these dots
lines in the middle of are these solid
dots these must be really important so
in terms of L if I start seeing red dots
over here I better up you know up the
urgency of my you know calling to the
engineering team that manages a service
and I can even look at this and go oh
well these other teams that are you know
linked to it are also affected right
again very little effort to get the lay
of the land so because there's not a lot
in this space yet I want to do another
thought experiment with you this is kind
of just to get you thinking about how
can we build intuitive insight so what
if the interactions between the
components of your system sounded like
cars driving down the road so just
imagine this you're sitting on the side
of the road close your eyes you just
hear cars going by it sounds normal
pretty soon your attention turns toward
you know what are you going to have for
dinner what you going to do over the
weekend you're not even thinking about
the cars driving down the road but then
a couple hours go by and you hear a loud
crash coming from over there so you
immediately open your eyes and look over
there like oh my god so you know exactly
that when something happened where it
was coming from and you can start to
very quickly respond to that so this is
really the power of our primary fences
we're not putting a lot of cognitive
effort into listening to the cars
on the road week but we can immediately
detect anomalies so I'm not suggesting
that oh the wave of the future is that
we employ humans 24-7 to listen to
server traffic on the contrary I think
this is a great job for machines but
this is kind of to get you thinking of
hey until machines are really good at
doing this how can we better present the
information about what our systems are
actually doing so just to review we want
to know at a high level is it working we
want to scan the landscape and I find
that the the tools that are most
popularly used today charts and logs
kind of inhibit us from doing that and
they'd really don't make use of our rich
sensory signals so I need more tools
that live leverage our intuition and I
think visceral is a first of hopefully
many examples of that how am i doing on
time alright so I want to wrap up and
kind of look look to the future a little
bit here so I kind of talked about a lot
of challenges in software engineering
and ultimately I think these are
actually very ripe for machines to
assist us in doing our jobs I think that
this is going to be the first wave to
get us from you know where we are now
till some point in the future when we
don't need to write code anymore and
there's nourish machines that are either
a writing code or be just learning about
the world and doing their job so let's
talk about a couple possible
applications that i think would help us
navigate this interface between
infinitely precise machines and you know
the real world with a lot of noise and
uncertainty so I think one area that I
like to when application I'd like to see
would be curiosity-driven tests so
imagine you have a test agent if you
will and it has a set of senses and it
has a set of actuators and what it's
doing is it's actuated the system under
test and really it starts out kind of
ran
Emily it just starts you know twiddling
knobs and dials and just seeing what
happens it's randomly exploring your
system and then eventually over time it
will start to build a model of what your
system is and what it does it'll form
expectations about that about it and so
with those expectations it can start to
oops not do that map out anomalies right
so it can go oh you know some something
chant must have change in the software
because last week I got this this thing
and now I'm getting this other thing
right our soft or you know are the world
of continuous delivery things change so
fast it's really hard for any one person
to keep up with all that but if you had
this curious agent if you will that was
constantly poking around it might pick
up on things that say our limited
attention spans wouldn't necessarily
pick up on and it would say hey engineer
people did you really mean that or hey
go go look over here because this
doesn't look right so I think another
really interesting area for deep
learning would be to have to basically
have an agent that would help with self
healing systems so in this case the
sense is coming in are really the
telemetry information about the system
that's being operated and the actions
that can be performed are things like
doing deployments scaling in a more
intelligent manner than say some cpu
threshold for example maybe failover and
i think this is the this is where if we
can start to nail bits and pieces of
this problem this will start to bleed
into more and more mainstream you know
maybe it's going to start doing traffic
routing right i mean i don't know how
many times human beings have written you
know a router for internet traffic but
what if those algorithms were now done
by these machines so let's review you
know we're kind of this curious bunch of
human beings that have not only to
navigate the natural world and figure
out the survival bubble but we also need
to
navigate the working software world and
we're doing it indirectly with these
generative models that today we call
code and really what we want to do
because machines are infinitely precise
we want to get away from this model
where we have this happy path notion
that leads to perhaps these uh turley
broken States and we want to get to a
landscape that supports resilience right
that are that our software system can
navigate situations that we really
didn't predict in the first place and so
that's wrapped in the end for today and
I really want to thank you for coming
and please give me a rating
so that's one question one question yes
either I did my job really great or i
confuse the heck out of you and there's
so is it fat it is fair to say that
locks and charts are are not the answer
but visualizations instead do you see
any limits to visualization so I mean
limits to visualization I mean so we
humans right we have these kind of
impress ice senses right and we make
mistakes all the time so I would say the
limitations of visualizations and
animation would be kind of similar to
the types of limitations that we
experience in real life like you know
I've been hiking at times and I've been
looking for a rattlesnake because then
you know where I live there's
rattlesnakes and a lot of times I've
seen a rattlesnake and there wasn't
really one so I think you know the
danger of that is really just the same
weaknesses that we see in the natural
world where we might see something that
doesn't really exist and one more
question what I what I working on now
right now I'm actually working on trying
to get agents to play video games
actually going back to do goes talk i
mean we want to tackle some of the games
that are inherently harder that require
some sense of sort of time and memory so
that's really the area that we want to
we want to tackle next any other
questions in the audience i am following
up on the question on the charts and
logs is not good enough it doesn't give
her the whole picture but we don't have
anything else that actually does yet so
within this is an area what do you have
any recommendations something that we at
least can do to leverage better their
logs and the graphs and everything that
we have for now right so the visceral
demos that i showed you are actually
available today it is an open source
project so anybody can start to use that
I mean it's a visualization framework
and it does operate in real time
I think the child that what you need to
do is plug in your data to it
essentially so you know i will say there
are shortcomings because there's really
not a lot out there yet i'm aware that
netflix has created a team called
intuition engineering and so I believe
that they will start to produce more and
more tools in this area I would love to
just try as an experiment to see if I
could get some sort of audio
representation of traffic like what it
we actually get it to sound like cars
you know so so yet today there's
actually not a whole lot there's one
project I know of and there's no is
anybody else know of any other amazing
type projects out there okay all the
questions okay so let's give julia big
boss
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>